<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👏🏽 😊 👩🏻‍🏫 التلاعب في الوقت الحقيقي للشبكات على الوحدة 🚠 🙃 🤱</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="أحد مزايا Unity كمنصة لتطوير الألعاب هو محركها القوي ثلاثي الأبعاد. في هذا البرنامج التعليمي ، ستتعرف على عالم الكائنات ثلاثية الأبعاد ومعالجة الشبكة....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>التلاعب في الوقت الحقيقي للشبكات على الوحدة</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428796/" style=";text-align:right;direction:rtl"><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/ce5/532/c83/ce5532c83ff152100775d62091370bf2.gif" alt="الصورة"></div><br>  أحد مزايا Unity كمنصة لتطوير الألعاب هو محركها القوي ثلاثي الأبعاد.  في هذا البرنامج التعليمي ، ستتعرف على عالم الكائنات ثلاثية الأبعاد ومعالجة الشبكة. <br><br>  نظرًا لنمو تقنيات الواقع الافتراضي والمعزز (VR / AR) ، يواجه معظم المطورين مفاهيم رسومات ثلاثية الأبعاد معقدة.  دع هذا البرنامج التعليمي يكون نقطة البداية بالنسبة لهم.  لا تقلق ، لن تكون هناك رياضيات ثلاثية الأبعاد معقدة - فقط القلوب والرسومات والسهام والكثير من الأشياء المثيرة للاهتمام! <br><a name="habracut"></a><br><blockquote style=";text-align:right;direction:rtl">  <em>ملاحظة:</em> هذا البرنامج التعليمي مخصص للمستخدمين المطلعين على Unity IDE ولديهم بعض الخبرة في البرمجة في C #.  إذا لم يكن لديك هذه المعرفة ، فقم أولاً بدراسة البرامج التعليمية <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="noopener">مقدمة إلى Unity UI</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="noopener">ومقدمة إلى Unity Scripting</a> . <br><br>  ستحتاج إلى إصدار Unity لا يقل عن 2017.3.1.  يمكن تنزيل أحدث إصدار من Unity من <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="noopener">هنا</a> .  يستخدم هذا البرنامج التعليمي محررًا مخصصًا ، ويمكنك معرفة المزيد عنها من البرنامج التعليمي <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="noopener">Extended the Unity Editor</a> . </blockquote><br><h2 style=";text-align:right;direction:rtl">  للوصول إلى العمل </h2><br>  للبدء ، تعرف على الشروط الأساسية للرسومات ثلاثية الأبعاد ، والتي ستسمح لك بفهم البرنامج التعليمي بشكل أفضل. <br><br>  المصطلحات التقنية الأساسية للرسومات ثلاثية الأبعاد: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <em>القمم</em> : كل ​​قمة هي نقطة في الفضاء ثلاثي الأبعاد. </li><li style=";text-align:right;direction:rtl">  <em>شبكة</em> : تحتوي على جميع القمم والحواف والمثلثات والمعايير وبيانات الأشعة فوق البنفسجية للنموذج. </li><li style=";text-align:right;direction:rtl">  <em>تصفية شبكة</em> : يخزن بيانات شبكة النموذج. </li><li style=";text-align:right;direction:rtl">  <em>Mesh Renderer</em> : لعرض بيانات الشبكة في المشهد. </li><li style=";text-align:right;direction:rtl">  <em>المعايير</em> : ناقل الرأس أو السطح.  يتم توجيهها إلى الخارج ، متعامدة على سطح الشبكة. </li><li style=";text-align:right;direction:rtl">  <em>خطوط / حواف</em> : خطوط غير مرئية تربط القمم ببعضها البعض. </li><li style=";text-align:right;direction:rtl">  <em>المثلثات</em> : تتكون من ربط ثلاث قمم. </li><li style=";text-align:right;direction:rtl">  <em>خريطة الأشعة فوق البنفسجية</em> : تعلق المواد على كائن ، مما يخلق نسيجًا ولونًا له. </li></ul><br>  يبدأ تشريح كائن ثلاثي الأبعاد بشبكته.  يبدأ إنشاء هذه الشبكة في قمتها.  تشكل الخطوط غير المرئية التي تربط هذه القمم مثلثات تحدد الشكل الأساسي للكائن. <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/5a7/83a/4c2/5a783a4c2ed2c144ccd0d7eb97369370.gif"></div><br>  ثم تقوم البيانات العادية وبيانات الأشعة فوق البنفسجية بتعيين التظليل واللون والملمس.  يتم تخزين بيانات الشبكة في مرشح شبكة ، ويستخدم عارض الشبكة هذه البيانات لرسم كائن في المشهد. <br><br>  أي أن الرمز الزائف لإنشاء نموذج ثلاثي الأبعاد يبدو كما يلي: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  إنشاء شبكة جديدة تسمى "myMesh". </li><li style=";text-align:right;direction:rtl">  إضافة بيانات إلى خصائص القمم والمثلثات myMesh. </li><li style=";text-align:right;direction:rtl">  قم بإنشاء مرشح شبكة جديد يسمى "myMeshFilter". </li><li style=";text-align:right;direction:rtl">  قم بتعيين خاصية شبكة myMeshFilter إلى myMesh. </li></ul><br>  بمجرد أن تتقن الأساسيات ، قم بتنزيل <a href="">المشروع</a> وفك ضغط الملفات وتشغيل قطعة عمل المشروع في Unity.  انظر إلى بنية المجلد في نافذة <em>المشروع</em> : <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/690/2d6/c2e/6902d6c2e14a98284c8af39055242bc7.png"></div><br>  وصف المجلدات: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <em>Prefabs</em> : يحتوي على Sphere الجاهزة التي سيتم استخدامها لحفظ الشبكة ثلاثية الأبعاد أثناء تنفيذ التطبيق. </li><li style=";text-align:right;direction:rtl">  <em>المشاهد</em> : تحتوي على المشاهد الثلاثة التي نستخدمها في هذا البرنامج التعليمي. </li><li style=";text-align:right;direction:rtl">  <em>المحرر</em> : تمنحنا النصوص البرمجية الموجودة داخل هذا المجلد الميزات الفائقة في المحرر الذي نستخدمه في التطوير. </li><li style=";text-align:right;direction:rtl">  <em>البرامج النصية</em> : إليك البرامج النصية لوقت التشغيل التي ترتبط بـ GameObject ويتم تنفيذها عند النقر فوق <em>تشغيل</em> . </li><li style=";text-align:right;direction:rtl">  <em>المواد</em> : يحتوي هذا المجلد على مادة الشبكة. </li></ul><br>  في القسم التالي ، سننشئ محررًا مخصصًا لتصور إنشاء شبكة ثلاثية الأبعاد. <br><br><h2 style=";text-align:right;direction:rtl">  تغيير الشبكات باستخدام محرر مخصص </h2><br>  افتح <em>العرض التوضيحي 01 Mesh Study</em> الموجود في مجلد <em>Scenes</em> .  في نافذة <em>المشهد</em> ، سترى مكعبًا ثلاثي الأبعاد: <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/6d5/ed2/812/6d5ed28123a0c65bb083c67efab702c7.gif"></div><br>  قبل الدخول في الشبكة ، دعنا نلقي نظرة على البرنامج النصي المحرر المخصص. <br><br><h3 style=";text-align:right;direction:rtl">  تحرير برنامج نصي محرر </h3><br>  حدد مجلد <em>Editor</em> في نافذة <em>Project</em> .  تضيف البرامج النصية في هذا المجلد وظائف إلى المحرر (المحرر) أثناء التطوير ولا تتوفر في وضع البناء. <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/442/653/b41/442653b41ca755b67d3a1ce42ae1ec5a.png"></div><br>  افتح <em>MeshInspector.cs</em> وعرض التعليمات البرمجية المصدر.  يجب أن تنفذ جميع البرامج النصية الخاصة <code>Editor</code> فئة <code>Editor</code> ، حيث <code>CustomEditor</code> سمة <code>CustomEditor</code> فئة <code>Editor</code> بنوع الكائن المخصص لها.  <code>OnSceneGUI()</code> هي طريقة حدث تسمح <code>OnSceneGUI()</code> في نافذة المشهد ؛  يسمح لك <code>OnInspectorGUI()</code> بإضافة عناصر GUI إضافية إلى المفتش. <br><br>  في <em>MeshInspector.cs ،</em> قبل بدء فئة <code>MeshInspector</code> أضف ما يلي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">CustomEditor(typeof(MeshStudy))</span></span>]</code> </pre> <br>  شرح الكود: <code>CustomEditor</code> السمة <code>CustomEditor</code> الوحدة بنوع الكائن الذي يمكن لفئة المحرر المخصص تعديله. <br><br>  في <code>OnSceneGUI()</code> قبل <code>EditMesh()</code> أضف ما يلي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs">mesh = target <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> MeshStudy; Debug.Log(<span class="hljs-string"><span class="hljs-string">"Custom editor is running"</span></span>);</code> </pre> <br>  شرح الكود: تحتوي فئة <code>Editor</code> على متغير <code>target</code> قياسي.  <code>target</code> هنا هو التحويل إلى <code>MeshStudy</code> .  الآن سوف يرسم المحرر المخصص جميع GameObjects في نافذة المشهد و <em>MeshStudy.cs</em> المرفقة بها.  تسمح لك إضافة رسائل تصحيح الأخطاء بالتحقق في وحدة التحكم من أن المحرر المخصص يعمل بالفعل. <br><br>  احفظ الملف وارجع إلى الوحدة.  انتقل إلى مجلد <em>البرامج النصية</em> واسحب <em>MeshStudy.cs</em> إلى <em>المكعب</em> GameObject في <em>التسلسل الهرمي</em> لإرفاقه. <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/aa6/b8a/ee4/aa6b8aee48eacb8421eff3c4e1ef4be3.png"></div><br>  الآن يجب عرض الرسالة "محرر مخصص قيد التشغيل" في وحدة التحكم ، وهذا يعني أننا فعلنا كل شيء بشكل صحيح!  يمكنك حذف رسالة تصحيح الأخطاء بحيث لا تزعجنا في وحدة التحكم. <br><br><h3 style=";text-align:right;direction:rtl">  الاستنساخ وإلقاء الشبكة </h3><br>  عند العمل مع شبكة ثلاثية الأبعاد في وضع التحرير باستخدام المحرر المخصص ، احرص على عدم استبدال شبكة الوحدة الافتراضية.  إذا حدث ذلك ، فسيتعين عليك إعادة تشغيل الوحدة. <br><br>  لنسخ الشبكة بأمان دون الكتابة فوق النموذج الأصلي ، قم بإنشاء نسخة من الشبكة من خاصية <code>MeshFilter.sharedmesh</code> وقم بتعيينها لمرشح الشبكة مرة أخرى. <br><br>  للقيام بذلك ، انقر نقرًا مزدوجًا فوق <em>MeshStudy.cs</em> في مجلد <em>البرامج النصية</em> لفتح الملف في محرر التعليمات البرمجية.  يرث هذا البرنامج النصي من فئة <code>MonoBehaviour</code> ، ولا يتم تنفيذ وظيفته <code>Start()</code> في وضع التحرير. <br><br>  في <em>MeshStudy.cs ،</em> قبل بدء فئة <code>MeshStudy</code> أضف ما يلي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">ExecuteInEditMode</span></span>]</code> </pre> <br>  شرح الكود: بعد إضافة هذه السمة ، سيتم تنفيذ وظيفة <code>Start()</code> في وضع التشغيل وفي وضع التحرير.  الآن يمكننا أولاً إنشاء كائن الشبكة واستنساخه. <br><br>  في <code>InitMesh()</code> أضف التعليمات البرمجية التالية: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs">oMeshFilter = GetComponent&lt;MeshFilter&gt;(); oMesh = oMeshFilter.sharedMesh; <span class="hljs-comment"><span class="hljs-comment">//1 cMesh = new Mesh(); //2 cMesh.name = "clone"; cMesh.vertices = oMesh.vertices; cMesh.triangles = oMesh.triangles; cMesh.normals = oMesh.normals; cMesh.uv = oMesh.uv; oMeshFilter.mesh = cMesh; //3 vertices = cMesh.vertices; //4 triangles = cMesh.triangles; isCloned = true; Debug.Log("Init &amp; Cloned");</span></span></code> </pre> <br>  شرح الكود: <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  الحصول على شبكة <code>oMesh</code> الأصلية من مكون <code>MeshFilter</code> . </li><li style=";text-align:right;direction:rtl">  نسخ <code>cMesh</code> إلى <code>cMesh</code> شبكة جديد. </li><li style=";text-align:right;direction:rtl">  يعين مرشح شبكة الشبكة المنسوخ مرة أخرى. </li><li style=";text-align:right;direction:rtl">  تحديث المتغيرات المحلية. </li></ol><br>  احفظ الملف وارجع إلى الوحدة.  يجب عرض الرسالة "Init &amp; Cloned" في وحدة تحكم التصحيح.  حدد GameObject <code>Cube</code> في <em>التسلسل الهرمي</em> وتحقق من خصائصه في <em>المفتش</em> .  يجب أن يعرض " <em>تصفية</em> الشبكة" أصل شبكة يسمى <em>استنساخ</em> .  عظيم!  هذا يعني أننا نجحنا في استنساخ الشبكة. <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/c6c/2da/3e0/c6c2da3e0e29703888bad5e50bb608a6.png"></div><br>  في مجلد Editor ، انتقل إلى <em>MeshInspector.cs</em> .  في <code>OnInspectorGUI()</code> ، بعد السطر الثاني من التعليمات البرمجية ، أضف ما يلي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GUILayout.Button(<span class="hljs-string"><span class="hljs-string">"Reset"</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//1 { mesh.Reset(); //2 }</span></span></code> </pre> <br>  شرح الكود: <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  يرسم هذا الرمز زر إعادة الضبط في <em>المفتش</em> . </li><li style=";text-align:right;direction:rtl">  عند الضغط عليه ، فإنه يستدعي وظيفة <code>Reset()</code> في <em>MeshStudy.cs</em> . </li></ol><br>  احفظ الملف وافتح <em>MeshStudy.cs</em> وأضف الكود التالي إلى وظيفة <code>Reset()</code> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cMesh != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; oMesh != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-comment"><span class="hljs-comment">//1 { cMesh.vertices = oMesh.vertices; //2 cMesh.triangles = oMesh.triangles; cMesh.normals = oMesh.normals; cMesh.uv = oMesh.uv; oMeshFilter.mesh = cMesh; //3 vertices = cMesh.vertices; //4 triangles = cMesh.triangles; }</span></span></code> </pre> <br>  شرح الكود: <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  التحقق من وجود المصدر وشبكة مستنسخة. </li><li style=";text-align:right;direction:rtl">  إعادة <code>cMesh</code> إلى الشبكة الأصلية. </li><li style=";text-align:right;direction:rtl">  التعيين إلى <code>cMesh</code> <code>oMeshFilter</code> . </li><li style=";text-align:right;direction:rtl">  تحديث المتغيرات المحلية. </li></ol><br>  احفظ الملف وارجع إلى الوحدة.  في <em>المفتش ،</em> انقر على زر <em>اختبار التحرير</em> لتشويه شبكة المكعب.  بعد ذلك ، انقر فوق زر <em>إعادة الضبط</em> ؛  يجب أن يعود المكعب إلى شكله الأصلي. <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/0c3/a8a/e22/0c3a8ae22c8f8382dd46ee652b4b6eea.gif"></div><br><h3 style=";text-align:right;direction:rtl">  شرح القمم والمثلثات في الوحدة </h3><br>  تتكون الشبكة من القمم المتصلة بحواف مثلثات.  تحدد المثلثات الشكل الأساسي للكائن. <br><br><blockquote style=";text-align:right;direction:rtl">  <em>فئة الشبكة:</em> <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  يتم تخزين القمم <code>Vector3</code> من قيم <code>Vector3</code> . </li><li style=";text-align:right;direction:rtl">  يتم تخزين المثلثات كمصفوفة صحيحة تتوافق مع مؤشرات مجموعة القمة. </li></ul><br>  بمعنى ، في شبكة رباعية بسيطة تتكون من أربعة رؤوس ومثلثين ، ستبدو بيانات الشبكة كما يلي: <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/56c/56d/794/56c56d794628ff20592f801340308790.gif"></div></blockquote><br><h3 style=";text-align:right;direction:rtl">  رسم خرائط الرأس </h3><br>  هنا نريد عرض رؤوس المكعب كنقاط زرقاء. <br><br>  في <em>MeshInspector.cs</em> سنذهب إلى وظيفة <code>EditMesh()</code> ونضيف ما يلي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs">handleTransform = mesh.transform; <span class="hljs-comment"><span class="hljs-comment">//1 handleRotation = Tools.pivotRotation == PivotRotation.Local ? handleTransform.rotation : Quaternion.identity; //2 for (int i = 0; i &lt; mesh.vertices.Length; i++) //3 { ShowPoint(i); }</span></span></code> </pre> <br>  شرح الكود: <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  يحصل <code>handleTransform</code> على قيم التحويل من <code>mesh</code> . </li><li style=";text-align:right;direction:rtl">  يحصل <code>handleRotation</code> على وضع التدوير للمفصل الحالي. </li><li style=";text-align:right;direction:rtl">  اجتياز رؤوس الشبكة وارسم النقاط باستخدام <code>ShowPoint()</code> . </li></ol><br>  في <code>ShowPoint()</code> ، مباشرةً بعد <code>//draw dot</code> ، أضف ما يلي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs">Vector3 point = handleTransform.TransformPoint(mesh.vertices[index]);</code> </pre> <br>  شرح الكود: هذا الخط يحول الموقع المحلي للرأس إلى إحداثيات في الفضاء العالمي. <br><br>  في نفس الوظيفة ، في كتلة <code>if</code> ، بعد سطر التعليمات البرمجية الذي تمت إضافته للتو ، أضف ما يلي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs">Handles.color = Color.blue; point = Handles.FreeMoveHandle(point, handleRotation, mesh.handleSize, Vector3.zero, Handles.DotHandleCap);</code> </pre> <br>  شرح الكود: <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  يضبط لون النقطة وحجمها <code>Handles</code> باستخدام فئة المساعد <code>Handles</code> . </li><li style=";text-align:right;direction:rtl">  <code>Handles.FreeMoveHandle()</code> ينشئ مناور حركة غير محدود يبسط عملية السحب والإفلات ، وهو أمر مفيد لنا في القسم التالي. </li></ol><br>  احفظ الملف وارجع إلى الوحدة.  تحقق من خاصية المكعب في <em>المفتش</em> وتأكد من تمكين الخيار <em>Move Vertex Point</em> .  يجب أن ترى الآن أن الشبكة على الشاشة مميزة بالعديد من النقاط الزرقاء.  ها هم - قمم شبكة المكعب!  حاول القيام بذلك مع كائنات ثلاثية الأبعاد أخرى ولاحظ النتائج. <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/d78/3aa/205/d783aa2054dd9ca81ee7a6c948c7c00a.gif"></div><br><h3 style=";text-align:right;direction:rtl">  تحريك قمة واحدة </h3><br>  لنبدأ بالخطوة الأبسط للتلاعب بالشبكة - تحريك قمة واحدة. <br><br>  انتقل إلى <em>MeshInspector.cs</em> .  داخل <code>ShowPoint()</code> ، مباشرة بعد <code>//drag</code> التعليق مباشرة قبل أقواس الإغلاق للكتلة <code>if</code> ، أضف ما يلي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GUI.changed) <span class="hljs-comment"><span class="hljs-comment">//1 { mesh.DoAction(index, handleTransform.InverseTransformPoint(point)); //2 }</span></span></code> </pre> <br>  شرح الكود: <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <code>GUI.changed</code> جميع التغييرات التي تحدث مع النقاط ، ويعمل بشكل جيد مع <code>Handles.FreeMoveHandle()</code> للتعرف على عملية السحب والإفلات. </li><li style=";text-align:right;direction:rtl">  بالنسبة <code>mesh.DoAction()</code> القابل للسحب ، تتلقى الدالة <code>mesh.DoAction()</code> الفهرس وقيم التحويل كمعلمات.  نظرًا لأن قيم تحويل الرأس في الفضاء العالمي ، فإننا نحولها إلى مساحة محلية باستخدام <code>InverseTransformPoint()</code> . </li></ol><br>  احفظ ملف البرنامج النصي <em>وانتقل</em> إلى <em>MeshStudy.cs</em> .  في <code>DoAction()</code> ، بعد أقواس الفتح ، أضف ما يلي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs">PullOneVertex(index, localPos);</code> </pre> <br>  ثم أضف ما يلي إلى <code>PullOneVertex()</code> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs">vertices[index] = newPos; <span class="hljs-comment"><span class="hljs-comment">//1 cMesh.vertices = vertices; //2 cMesh.RecalculateNormals(); //3</span></span></code> </pre> <br>  شرح الكود: <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  نقوم بتحديث قمة الهدف بالقيمة <code>newPos</code> . </li><li style=";text-align:right;direction:rtl">  <code>cMesh.vertices</code> قيم قمة محدثة مرة أخرى إلى <code>cMesh.vertices</code> . </li><li style=";text-align:right;direction:rtl">  في <code>RecalculateNormals()</code> بإعادة حساب الشبكة وإعادة رسمها بحيث تتطابق مع التغييرات. </li></ol><br>  احفظ الملف وارجع إلى الوحدة.  حاول سحب النقاط على المكعب.  هل رأيت شبكة مكسورة؟ <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/fca/ccf/c86/fcaccfc865e30b3c922e6cabcf9f79d7.gif"></div><br>  يبدو أن بعض القمم لها نفس الوضع ، لذلك عندما نسحب واحدة فقط ، تبقى القمم المتبقية خلفها ، وتتكسر الشبكة.  في القسم التالي ، سنقوم بإصلاح هذه المشكلة. <br><br><h3 style=";text-align:right;direction:rtl">  إيجاد جميع القمم المتشابهة </h3><br>  بصريا ، تتكون شبكة المكعب من ثمانية قمم وستة جوانب و 12 مثلثات.  دعونا نتحقق مما إذا كان الأمر كذلك. <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/253/a30/b3f/253a30b3fcca7b0d9028d92b4c4149c2.gif"></div><br>  افتح <em>MeshStudy.cs</em> ، <em>وألق</em> نظرة أمام الدالة <code>Start()</code> وابحث عن متغير <code>vertices</code> .  سنرى ما يلي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">HideInInspector</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3[] vertices;</code> </pre> <br>  شرح الكود: <code>[HideInInspector]</code> يخفي متغير مشترك من نافذة <em>المفتش</em> . <br><br>  التعليق على هذه السمة: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//[HideInInspector] public Vector3[] vertices;</span></span></code> </pre> <br><blockquote style=";text-align:right;direction:rtl">  <em>ملاحظة:</em> يساعد إخفاء قيم الذروة <code>[HideInInspector]</code> شبكات أكثر تعقيدًا ثلاثية الأبعاد.  نظرًا لأن حجم صفيف الرأس يمكن أن يصل إلى آلاف العناصر ، فقد يؤدي ذلك إلى تثبيط الوحدة عند محاولة عرض قيمة الصفيف في المفتش. </blockquote><br>  احفظ الملف وارجع إلى الوحدة.  انتقل إلى <em>المفتش</em> .  الآن ، تحت مكون البرنامج النصي <em>لدراسة شبكة</em> ، ظهرت خاصية <em>القمم</em> .  انقر على أيقونة السهم المجاورة لها ؛  حتى تقوم <code>Vector3</code> مجموعة عناصر <code>Vector3</code> . <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/feb/f83/fd0/febf83fd02d469734b73910b1769d670.gif"></div><br>  يمكنك أن ترى أن حجم المصفوفة هو 24 ، أي أن القمم لها نفس الموضع!  قبل المتابعة ، تأكد من عدم <code>[HideInInspector]</code> . <br><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">لماذا يوجد 24 قمة؟</b> <div class="spoiler_text" style=";text-align:right;direction:rtl">  هناك العديد من النظريات حول هذا الموضوع.  لكن أبسط إجابة هي: المكعب له ستة جوانب ، وكل جانب يتكون من أربعة قمم تشكل مستوى. <br><br>  لذلك ، يكون الحساب كما يلي: 6 × 4 = 24 قمة. <br><br>  يمكنك البحث عن إجابات أخرى.  ولكن في الوقت الحالي ، من السهل معرفة أن بعض الشبكات سيكون لها رؤوس لها نفس الوضع. </div></div><br>  في <em>MeshStudy.cs ، استبدل</em> <em>جميع</em> التعليمات البرمجية الموجودة داخل الدالة <code>DoAction()</code> بما يلي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs">PullSimilarVertices(index, localPos);</code> </pre> <br>  دعنا <code>PullSimilarVertices()</code> إلى وظيفة <code>PullSimilarVertices()</code> وإضافة ما يلي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs">Vector3 targetVertexPos = vertices[index]; <span class="hljs-comment"><span class="hljs-comment">//1 List&lt;int&gt; relatedVertices = FindRelatedVertices(targetVertexPos, false); //2 foreach (int i in relatedVertices) //3 { vertices[i] = newPos; } cMesh.vertices = vertices; //4 cMesh.RecalculateNormals();</span></span></code> </pre> <br>  شرح الكود: <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  نحصل على موضع قمة الهدف ، والتي سيتم استخدامها كوسيطة <code>FindRelatedVertices()</code> . </li><li style=";text-align:right;direction:rtl">  تُرجع هذه الطريقة قائمة الفهارس (المقابلة للقمم) التي لها نفس موضع الرأس المستهدف. </li><li style=";text-align:right;direction:rtl">  <code>newPos</code> الحلقة القائمة بالكامل <code>newPos</code> القمم المقابلة لـ <code>newPos</code> . </li><li style=";text-align:right;direction:rtl">  <code>cMesh.vertices</code> <code>vertices</code> المحدثة مرة أخرى إلى <code>cMesh.vertices</code> .  ثم نسمي <code>RecalculateNormals()</code> لإعادة رسم الشبكة بالقيم الجديدة. </li></ol><br>  احفظ الملف وارجع إلى الوحدة.  اسحب أي من القمم ؛  الآن يجب أن تحتفظ الشبكة بشكلها ولا تنهار. <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/b1b/66d/bcc/b1b66dbccb73ac3a8ad8c56594611919.gif"></div><br>  الآن بعد أن أكملنا الخطوة الأولى في معالجة الشبكات ، احفظ المشهد وانتقل إلى القسم التالي. <br><br><h2 style=";text-align:right;direction:rtl">  معالجة شبكة </h2><br>  في هذا القسم ، ستتعلم كيفية معالجة الشبكات في الوقت الفعلي.  هناك العديد من الطرق ، ولكن في هذا البرنامج التعليمي سنلقي نظرة على أبسط نوع من معالجة الشبكة ، أي تحريك رؤوس الشبكات التي تم إنشاؤها سابقًا. <br><br><h3 style=";text-align:right;direction:rtl">  جمع الفهارس المختارة </h3><br>  لنبدأ باختيار الذروات التي سننقلها في الوقت الفعلي. <br><br>  افتح Scene <em>02 Create Heart Mesh</em> من مجلد <em>Scenes</em> .  في نافذة المشهد ، سترى كرة حمراء.  حدد <em>المجال</em> في <em>التسلسل الهرمي وانتقل</em> إلى <em>المفتش</em> .  سترى أن مكون البرنامج النصي <em>Heart Mesh</em> مرفق بالكائن. <br><br>  نحتاج الآن إلى البرنامج النصي Editor لهذا الكائن لعرض رؤوس الشبكة في نافذة Scene.  انتقل إلى مجلد <em>Editor</em> وانقر نقرًا مزدوجًا فوق <em>HeartMeshInspector.cs</em> . <br><br>  في <code>ShowHandle()</code> ، داخل كتلة <code>if</code> ، أضف ما يلي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs">Handles.color = Color.blue; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Handles.Button(point, handleRotation, mesh.pickSize, mesh.pickSize, Handles.DotHandleCap)) <span class="hljs-comment"><span class="hljs-comment">//1 { mesh.selectedIndices.Add(index); //2 }</span></span></code> </pre> <br>  شرح الكود: <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  يضبط ويعرض رؤوس الشبكة كنوع <code>Handles.Button</code> . </li><li style=";text-align:right;direction:rtl">  عند النقر فوقه ، فإنه يضيف الفهرس المحدد إلى قائمة الضغط على <code>mesh.selectedIndices</code> . </li></ol><br>  في <code>OnInspectorGUI()</code> ، قبل قوس الإغلاق ، أضف ما يلي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GUILayout.Button(<span class="hljs-string"><span class="hljs-string">"Clear Selected Vertices"</span></span>)) { mesh.ClearAllData(); }</code> </pre> <br>  شرح الكود: هذه هي الطريقة التي نضيف بها زر إعادة الضبط إلى <em>المفتش</em> لاستدعاء <code>mesh.ClearAllData()</code> . <br><br>  احفظ الملف وافتح <em>HeartMesh.cs</em> من مجلد <em>البرامج النصية</em> .  في دالة <code>ClearAllData()</code> ، أضف ما يلي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs">selectedIndices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); targetIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; targetVertex = Vector3.zero;</code> </pre> <br>  شرح الكود: يمحو الكود القيم الموجودة في <code>targetIndex</code> <code>selectedIndices</code> و <code>targetIndex</code> .  كما يعيد تعيين <code>targetVertex</code> . <br><br>  احفظ الملف وارجع إلى الوحدة.  حدد <em>المجال</em> <em>وانتقل</em> إلى <em>المفتش</em> <em>لمكون</em> البرنامج النصي <em>HeartMesh</em> .  قم بتوسيع <em>المؤشرات المحددة</em> بالضغط على أيقونة السهم المجاورة لها.  سيسمح لنا هذا بتتبع كل قمة يتم إضافتها إلى القائمة. <br><br>  تمكين <em>وضع التعديل</em> باستخدام مربع الاختيار المجاور له.  ونتيجة لذلك ، سيتم رسم رؤوس الشبكة في نافذة المشهد.  النقر على النقاط الزرقاء في <em>المؤشرات المحددة</em> يجب أن يغير القيم وفقًا لذلك.  اختبر أيضًا زر <em>مسح القمم المحددة</em> للتأكد من أنه يمسح جميع القيم. <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/17a/271/dea/17a271dea970e9c3ade451773b87eb65.gif"></div><br>  <em>ملاحظة:</em> في <em>المفتش</em> المخصص المعدل ، لدينا خيار إظهار / إخفاء معالج التحويل باستخدام <em>إظهار مقبض التحويل</em> .  لذلك لا داعي للذعر إذا لم تجد معالج التحويل في مشاهد أخرى!  قم بتشغيله قبل الخروج. <br><br><h3 style=";text-align:right;direction:rtl">  تحويل المجال إلى قلب </h3><br>  يتكون تغيير رؤوس الشبكات في الوقت الفعلي بشكل أساسي من ثلاث خطوات: <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  انسخ رؤوس الشبكة الحالية (قبل الرسم المتحرك) إلى <code>mVertices</code> . </li><li style=";text-align:right;direction:rtl">  <code>mVertices</code> الحسابات وتغيير القيم في <code>mVertices</code> . </li><li style=";text-align:right;direction:rtl">  قم بتحديث رؤوس الشبكة الحالية باستخدام <code>mVertices</code> عند التغيير في كل خطوة ودع الوحدة تقوم بحساب القيم الطبيعية تلقائيًا. </li></ol><br>  افتح <em>HeartMesh.cs</em> والمتغيرات التالية قبل وظيفة <code>Start()</code> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> radiusofeffect = <span class="hljs-number"><span class="hljs-number">0.3f</span></span>; <span class="hljs-comment"><span class="hljs-comment">//1 public float pullvalue = 0.3f; //2 public float duration = 1.2f; //3 int currentIndex = 0; //4 bool isAnimate = false; float starttime = 0f; float runtime = 0f;</span></span></code> </pre> <br>  شرح الكود: <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  نصف قطر المنطقة المتضررة من قمة الهدف. </li><li style=";text-align:right;direction:rtl">  قوة السحب. </li><li style=";text-align:right;direction:rtl">  مدة الرسوم المتحركة. </li><li style=";text-align:right;direction:rtl">  الفهرس الحالي لقائمة المؤشرات <code>selectedIndices</code> . </li></ol><br>  في دالة <code>Init()</code> ، قبل كتلة <code>if</code> ، أضف ما يلي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs">currentIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  شرح الكود: في بداية اللعبة ، <code>currentIndex</code> على 0 ، وهو أول فهرس لقائمة المؤشرات <code>selectedIndices</code> . <br><br>  في نفس دالة <code>Init()</code> ، قبل قوس الإغلاق للكتلة <code>else</code> ، أضف ما يلي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs">StartDisplacement();</code> </pre> <br>  شرح الكود: قم بتشغيل <code>StartDisplacement()</code> إذا كان <code>isEditMode</code> خطأ. <br><br>  داخل <code>StartDisplacement()</code> ، أضف ما يلي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs">targetVertex = oVertices[selectedIndices[currentIndex]]; <span class="hljs-comment"><span class="hljs-comment">//1 starttime = Time.time; //2 isAnimate = true;</span></span></code> </pre> <br>  شرح الكود: <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  حدد <code>targetVertex</code> لبدء الرسوم المتحركة. </li><li style=";text-align:right;direction:rtl">  قم بتعيين وقت البدء وتغيير قيمة <code>isAnimate</code> إلى true. </li></ol><br>  بعد وظيفة <code>StartDisplacement()</code> ، قم بإنشاء وظيفة <code>FixedUpdate()</code> بالكود التالي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FixedUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//1 { if (!isAnimate) //2 { return; } runtime = Time.time - starttime; //3 if (runtime &lt; duration) //4 { Vector3 targetVertexPos = oFilter.transform.InverseTransformPoint(targetVertex); DisplaceVertices(targetVertexPos, pullvalue, radiusofeffect); } else //5 { currentIndex++; if (currentIndex &lt; selectedIndices.Count) //6 { StartDisplacement(); } else //7 { oMesh = GetComponent&lt;MeshFilter&gt;().mesh; isAnimate = false; isMeshReady = true; } } }</span></span></span></span></code> </pre> <br>  شرح الكود: <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  يتم تنفيذ الوظيفة <code>FixedUpdate()</code> في حلقة FPS ثابتة. </li><li style=";text-align:right;direction:rtl">  إذا كانت <code>isAnimate</code> خاطئة ، <code>isAnimate</code> بتخطي الرمز التالي. </li><li style=";text-align:right;direction:rtl">  تغيير الرسوم المتحركة <code>runtime</code> . </li><li style=";text-align:right;direction:rtl">  إذا كان <code>runtime</code> ضمن <code>duration</code> ، فإننا نحصل على إحداثيات العالم من <code>targetVertex</code> و <code>DisplaceVertices()</code> ، والتي تغطي الرأس المستهدف <code>pullvalue</code> و <code>radiusofeffect</code> . </li><li style=";text-align:right;direction:rtl">  خلاف ذلك ، انتهى الوقت.  أضف واحدًا إلى <code>currentIndex</code> . </li><li style=";text-align:right;direction:rtl">  تحقق مما إذا كان <code>currentIndex</code> بين <code>currentIndex</code> <code>selectedIndices</code> .  انتقل إلى القمة التالية في القائمة باستخدام <code>StartDisplacement()</code> . </li><li style=";text-align:right;direction:rtl">  خلاف ذلك ، في نهاية القائمة ، قم بتغيير بيانات <code>oMesh</code> إلى الشبكة الحالية <code>isAnimate</code> إلى false لإيقاف الرسوم المتحركة. </li></ol><br>  في <code>DisplaceVertices()</code> أضف ما يلي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs">Vector3 currentVertexPos = Vector3.zero; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sqrRadius = radius * radius; <span class="hljs-comment"><span class="hljs-comment">//1 for (int i = 0; i &lt; mVertices.Length; i++) //2 { currentVertexPos = mVertices[i]; float sqrMagnitute = (currentVertexPos - targetVertexPos).sqrMagnitude; //3 if (sqrMagnitute &gt; sqrRadius) { continue; //4 } float distance = Mathf.Sqrt(sqrMagnitute); //5 float falloff = GaussFalloff(distance, radius); Vector3 translate = (currentVertexPos * force) * falloff; //6 translate.z = 0f; Quaternion rotation = Quaternion.Euler(translate); Matrix4x4 m = Matrix4x4.TRS(translate, rotation, Vector3.one); mVertices[i] = m.MultiplyPoint3x4(currentVertexPos); } oMesh.vertices = mVertices; //7 oMesh.RecalculateNormals();</span></span></code> </pre> <br>  شرح الكود: <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  مربع نصف القطر. </li><li style=";text-align:right;direction:rtl">  نحن ندور عبر كل قمة للشبكة. </li><li style=";text-align:right;direction:rtl">  <code>sqrMagnitude</code> بين <code>currentVertexPos</code> و <code>targetVertexPos</code> . </li><li style=";text-align:right;direction:rtl">  إذا تجاوز <code>sqrRadius</code> ، فانتقل إلى القمة التالية. </li><li style=";text-align:right;direction:rtl">  خلاف ذلك ، استمر في تحديد قيمة <code>falloff</code> ، والتي تعتمد على <code>distance</code> القمة الحالية من نقطة مركز النطاق. </li><li style=";text-align:right;direction:rtl">  <code>Vector3</code> موضع <code>Vector3</code> الجديد <code>Vector3</code> بتطبيق تحويله على قمة الرأس الحالية. </li><li style=";text-align:right;direction:rtl">  عند الخروج من الحلقة ، نقوم بتعيين قيم <code>mVertices</code> تغييرها إلى <code>mVertices</code> ، <code>mVertices</code> الوحدة على إعادة حساب القيم الطبيعية. </li></ol><br><blockquote style=";text-align:right;direction:rtl">  <em>مصدر تكنولوجيا Falloff</em> <br>  يتم أخذ الصيغة الأصلية من ملف حزمة الأصول <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="noopener">الأمثلة الإجرائية</a> ، والذي يمكن تنزيله مجانًا من Unity Asset Store. </blockquote><br>  احفظ الملف وارجع إلى الوحدة.  حدد <em>المجال</em> ، انتقل إلى مكون <em>HeartMesh</em> وحاول إضافة بعض القمم إلى خاصية <em>المؤشرات المحددة</em> .  قم بتعطيل <em>وضع Is Edit</em> وانقر فوق <em>Play</em> لإلقاء نظرة على نتيجة عملك. <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/e1e/527/23b/e1e52723b08453591da6d10a28dbe13d.gif"></div><br>  اختبر <em>قيم Radiusofeffect</em> و <em>Pullvalue</em> و <em>Duration</em> للحصول على نتائج مختلفة.  عندما تكون جاهزًا ، قم بتغيير الإعدادات بما يتوافق مع لقطة الشاشة أدناه. <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/a63/c44/082/a63c44082183529e737f287cb746dfd6.png"></div><br>  انقر فوق <em>تشغيل</em> .  هل تحول مجالك إلى قلب؟ <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/ce5/532/c83/ce5532c83ff152100775d62091370bf2.gif"></div><br>  مبروك!  في القسم التالي ، سنحفظ الشبكة كإعداد مسبق للاستخدام المستقبلي. <br><br><h3 style=";text-align:right;direction:rtl">  حفظ الشبكة في الوقت الحقيقي </h3><br>  لحفظ شبكة إجرائية على شكل قلب في وضع التشغيل ، تحتاج إلى إعداد مسبقة يكون طفلها كائنًا ثلاثي الأبعاد ، ثم استبدال أصل شبكته بأخرى جديدة باستخدام برنامج نصي. <br><br>  في نافذة <em>Project ،</em> ابحث عن <em>CustomHeart</em> في مجلد <em>Prefabs</em> .  انقر فوق رمز السهم لتوسيع محتوياته وحدد <em>الطفل</em> .  ترى الآن كائن Sphere في نافذة معاينة <em>المفتش</em> .  هذا هو الجاهزة التي ستقوم بتخزين البيانات للشبكة الجديدة. <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/9a3/f07/048/9a3f070486f3a66ee56304dae5bd2b12.png"></div><br>  افتح <em>HeartMeshInspector.cs</em> .  داخل <code>OnInspectorGUI()</code> ، قبل قوس الإغلاق ، أضف ما يلي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!mesh.isEditMode &amp;&amp; mesh.isMeshReady) { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = <span class="hljs-string"><span class="hljs-string">"Assets/Prefabs/CustomHeart.prefab"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//1 if (GUILayout.Button("Save Mesh")) { mesh.isMeshReady = false; Object pfObj = AssetDatabase.LoadAssetAtPath(path, typeof(GameObject)); //2 Object pfRef = AssetDatabase.LoadAssetAtPath (path, typeof(GameObject)); GameObject gameObj = (GameObject)PrefabUtility.InstantiatePrefab(pfObj); Mesh pfMesh = (Mesh)AssetDatabase.LoadAssetAtPath(path, typeof(Mesh)); //3 if (!pfMesh) { pfMesh = new Mesh(); } else { pfMesh.Clear(); } pfMesh = mesh.SaveMesh(); //4 AssetDatabase.AddObjectToAsset(pfMesh, path); gameObj.GetComponentInChildren&lt;MeshFilter&gt;().mesh = pfMesh; //5 PrefabUtility.ReplacePrefab(gameObj, pfRef, ReplacePrefabOptions.Default); //6 Object.DestroyImmediate(gameObj); //7 } }</span></span></code> </pre> <br>  شرح الكود: <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  لتعيين <code>path</code> إلى المسار إلى كائن CustomHeart. </li><li style=";text-align:right;direction:rtl">  إنشاء كائنين من الإعداد <em>المسبق</em> CustomHeart ، أحدهما لإنشاء مثيل مثل GameObject ( <code>pfObj</code> ) ، والثاني كروابط ( <code>pfRef</code> ). </li><li style=";text-align:right;direction:rtl">  إنشاء مثيل لأصل شبكة <code>pfMesh</code> .  إذا لم يتم العثور عليه ، ينشئ شبكة جديدة ، وإلا فإنه ينظف البيانات الموجودة. </li><li style=";text-align:right;direction:rtl">  <code>pfMesh</code> ببيانات شبكة جديدة ، ثم يضيفها كأصل إلى <em>CustomHeart</em> . <br></li><li style=";text-align:right;direction:rtl">  يملأ أصل شبكة في <code>gameObj</code> بقيمة <code>pfMesh</code> . </li><li style=";text-align:right;direction:rtl">  يستبدل <em>CustomHeart</em> بـ <code>gameObj</code> مطابقة الاتصالات الموجودة مسبقًا. </li><li style=";text-align:right;direction:rtl">  يدمر على الفور <code>gameObj</code> </li></ol><br>  احفظ الملف <em>وانتقل</em> إلى <em>HeartMesh.cs</em> .  في طريقة <code>SaveMesh()</code> العامة ، بعد إنشاء مثيل <code>nMesh</code> أضف ما يلي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs">nMesh.name = <span class="hljs-string"><span class="hljs-string">"HeartMesh"</span></span>; nMesh.vertices = oMesh.vertices; nMesh.triangles = oMesh.triangles; nMesh.normals = oMesh.normals;</code> </pre> <br>  شرح الرمز: إرجاع أصل شبكة مع قيم من شبكة على شكل قلب. <br><br>  احفظ الملف وارجع إلى الوحدة.  انقر فوق <em>تشغيل</em> .  بعد اكتمال الرسم المتحرك ، سيظهر زر <em>Save Mesh</em> في <em>المفتش</em> .  انقر فوق الزر لحفظ الشبكة الجديدة ، ثم أوقف المشغل. <br><br>  انتقل إلى مجلد <em>Prefabs</em> وانظر إلى CustomHeart <em>الجاهزة</em> .  يجب أن ترى أنه الآن في كائن CustomHeart <em>الجاهزة ،</em> توجد شبكة جديدة تمامًا على شكل قلب. <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/126/dee/103/126dee103ce798611d2dc2e94013c23c.png"></div><br>  <i>عمل رائع!</i> <br><br><h2 style=";text-align:right;direction:rtl">  ضع كل ذلك معًا </h2><br>  في المشهد السابق ، استخدمت الدالة <code>DisplaceVertices()</code> صيغة Falloff لتحديد قوة السحب التي تم تطبيقها على كل قمة داخل نصف قطر معين.  تعتمد نقطة "السقوط" ، التي تبدأ عندها قوة السحب في الانخفاض ، على نوع السقوط المستخدم: الخطي أو الغوسي أو الإبرة.  ينتج كل نوع نتائج مختلفة في الشبكة. <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/9ff/284/9c0/9ff2849c0d0fe5f9d496d641c07e35d8.png"></div><br>  في هذا القسم ، سننظر في طريقة أخرى للتعامل مع القمم: باستخدام منحنى معين.  مع الأخذ في الاعتبار أن السرعة تساوي المسافة مقسومة على الوقت (d = (v / t)) ، يمكننا تحديد موضع المتجه ، بالإشارة إلى المسافة مقسومة على الوقت. <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/3b8/2d6/13c/3b82d613cedaf85e12db66beb6349201.gif"></div><br><h3 style=";text-align:right;direction:rtl">  باستخدام طريقة المنحنى </h3><br>  احفظ المشهد الحالي وافتح <em>03 Customize Heart Mesh</em> من مجلد <em>Scenes</em> .  سترى نسخة <em>هرمية</em> من الإعداد CustomHeart.  انقر فوق رمز السهم المجاور له لتوسيع محتوياته وحدد <em>الطفل</em> . <br><br>  عرض خصائصه في <em>المفتش</em> .    <em>Mesh Filter</em>   <em>Heart Mesh</em> .   <em>Child</em>     <em>Custom Heart</em> .      <em>HeartMesh</em>  <em>clone</em> . <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/954/27f/89d/95427f89d17410e26893a0ec27dff51d.gif"></div><br>   <em>CustomHeart.cs</em>   <em>Scripts</em> .   <code>Start()</code>  : <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> CurveType { Curve1, Curve2 } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CurveType curveType; Curve curve;</code> </pre> <br>  :     (enum)   <code>CurveType</code> ,       <em>Inspector</em> . <br><br>   <code>CurveType1()</code>   : <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs">Vector3[] curvepoints = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3[<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//1 curvepoints[0] = new Vector3(0, 1, 0); curvepoints[1] = new Vector3(0.5f, 0.5f, 0); curvepoints[2] = new Vector3(1, 0, 0); curve = new Curve(curvepoints[0], curvepoints[1], curvepoints[2], false); //2</span></span></code> </pre> <br>  : <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">      .     . </li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">نقوم بإنشاء المنحنى الأول بمساعدة </font></font><code>Curve()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">وتعيين قيمه </font></font><code>curve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">يمكن عرض المنحنى المرسوم في المعاينة إذا حددت true كمعلمة أخيرة.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">انتقل إلى </font></font><code>CurveType2()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">وقم بإضافة ما يلي:</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs">Vector3[] curvepoints = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3[<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//1 curvepoints[0] = new Vector3(0, 0, 0); curvepoints[1] = new Vector3(0.5f, 1, 0); curvepoints[2] = new Vector3(1, 0, 0); curve = new Curve(curvepoints[0], curvepoints[1], curvepoints[2], false); //2</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> شرح الكود: </font></font><br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> حدد النقاط للمنحنى الثاني. </font></font></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">نقوم بإنشاء المنحنى الثاني </font></font><code>Curve()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">وتعيين قيمه </font></font><code>curve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">يمكن عرض المنحنى المرسوم في المعاينة إذا حددت true كمعلمة أخيرة.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ب </font></font><code>StartDisplacement()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">، قبل قوس الإغلاق ، يضاف ما يلي:</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (curveType == CurveType.Curve1) { CurveType1(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (curveType == CurveType.Curve2) { CurveType2(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">شرح الكود: هنا نتحقق من الخيار الذي حدده المستخدم </font></font><code>curveType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">وننشئه وفقًا لذلك </font></font><code>curve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ب </font></font><code>DisplaceVertices()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">، داخل بيان الحلقة </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">قبل أقواس الإغلاق ، أضف ما يلي:</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> increment = curve.GetPoint(distance).y * force; <span class="hljs-comment"><span class="hljs-comment">//1 Vector3 translate = (vert * increment) * Time.deltaTime; //2 Quaternion rotation = Quaternion.Euler(translate); Matrix4x4 m = Matrix4x4.TRS(translate, rotation, Vector3.one); mVertices[i] = m.MultiplyPoint3x4(mVertices[i]);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> شرح الكود: </font></font><br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">      <code>distance</code>     <code>y</code>  <code>force</code> ,   <code>increment</code> . </li><li style=";text-align:right;direction:rtl">     <code>Vector3</code>            Transform. </li></ol><br>      Unity.     <em>CustomHeart</em>   <em>Child</em> .    ,     <em>Curve Type</em> .    <em>Edit Type</em>  <em>Add Indices</em>  <em>Remove Indices</em> ,         . <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/792/1a7/3b6/7921a73b676b205bd33ec1db076cd4a6.gif"></div><br>        ,      : <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/e06/ab3/e5d/e06ab3e5d0bfc950be0c6dbc82d36f6e.gif"></div><br>   <em>Curve Type</em>   <em>Curve1</em> , ,   <em>Edit Type</em>  <em>None</em>   <em>Play</em> .   ,     .  ,      ,       .   ,   <em>Curve Type</em>    . <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/8e1/f90/4d5/8e1f904d50987247014011ac32261134.png"></div><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/da0/e1a/df4/da0e1adf49f8503188f47826c4079cf1.png"></div><br>  هذا كل شيء!    <em>Clear Selected Vertices</em> ,   <em>Selected Indices</em>     .   ,     ,       ,  : <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  . </li><li style=";text-align:right;direction:rtl">    . </li><li style=";text-align:right;direction:rtl">    . </li><li style=";text-align:right;direction:rtl"> ,   . </li></ul><br><h2 style=";text-align:right;direction:rtl">   ? </h2><br>      <a href=""> </a> . <br><br>    !     ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">«    Unity»</a> . <br><br> ,    ,    .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="noopener"> </a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="noopener">Catlike Coding</a>    ,        . <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/190/e37/362/190e3736241796c39eac74bbe3ddc86e.png"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar428796/">https://habr.com/ru/post/ar428796/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar428786/index.html">معالج كمومي يعتمد على صدى الدوران والتلاعب بنظام مزدوج ثلاثي</a></li>
<li><a href="../ar428788/index.html">تحت غطاء محرك Bitfury Clarke - كيف تعمل رقاقة التعدين الجديدة الخاصة بنا</a></li>
<li><a href="../ar428790/index.html">نكتب محادثة بوت لـ VKontakte في python باستخدام longpoll. الجزء الثاني حلقات مزدوجة واستثناءات وهرطقات أخرى</a></li>
<li><a href="../ar428792/index.html">تجعل شريحة Apple T2 الجديدة من الصعب الاستماع عبر الميكروفون المدمج في الكمبيوتر المحمول</a></li>
<li><a href="../ar428794/index.html">نظرة عامة على الطرق الأساسية للتحسين الرياضي للمشاكل مع القيود</a></li>
<li><a href="../ar428798/index.html">كيفية النجاة من مطور مستقل. الجزء 2</a></li>
<li><a href="../ar428800/index.html">طهي CSS الكمال</a></li>
<li><a href="../ar428806/index.html">تحليل فحص المستهلك: ما يشترونه في أمازون</a></li>
<li><a href="../ar428808/index.html">القليل من الراحة في حياة الطلاب</a></li>
<li><a href="../ar428810/index.html">18 مادة عن التكنولوجيا الرقمية في الصوت</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>