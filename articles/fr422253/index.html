<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😮 👩🏾‍🤝‍👩🏻 🧖🏽 If - Cadre frontal de Rust & WebAssembly 👩‍❤️‍💋‍👩 👩🏽 👨🏾‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Yew est un analogue de React and Elm, entièrement écrit en rouille et compilé en un honnête assemblage Web. Dans l'article, Denis Kolodin, développeur...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>If - Cadre frontal de Rust & WebAssembly</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/422253/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Yew</a> est un analogue de React and Elm, entièrement écrit en rouille et compilé en un honnête assemblage Web.  Dans l'article, Denis Kolodin, développeur Yew, explique comment créer un framework sans garbage collector, garantir efficacement l'immuable, sans avoir besoin de copier l'état en raison des règles de propriété des données Rust, et quelles sont les fonctionnalités lors de la traduction de Rust en WebAssembly. <br><br><img src="https://habrastorage.org/webt/dc/ro/wt/dcrowtesfnjfmpr7wl9j0suzjug.jpeg"><br><br>  <i>Le message a été préparé sur la base du rapport de Denis lors de la conférence <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HolyJS 2018 Piter</a> .</i>  <i>Sous la coupe - transcription vidéo et texte du rapport.</i> <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/OqFOXMIwzTc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Denis Kolodin travaille pour Bitfury Group, une société qui développe diverses solutions de blockchain.</i>  <i>Depuis plus de deux ans maintenant, il codait en Rust, un langage de programmation de Mozilla Research.</i>  <i>Pendant ce temps, Denis a réussi à étudier en profondeur ce langage et à l'utiliser pour développer diverses applications système, un backend.</i>  <i>Maintenant, dans le cadre de l'avènement de la norme WebAssembly, j'ai commencé à regarder vers le front-end.</i> <br><br><h2>  Agenda </h2><br>  Aujourd'hui, nous apprendrons ce qu'est Yew (le nom du framework se lit comme le mot anglais "you" - you; "if" est un arbre d'if traduit de l'anglais). <br><br>  Parlons un peu des aspects architecturaux, des idées sur lesquelles le cadre est construit, des possibilités qui y sont intégrées, ainsi que des fonctionnalités que Rust nous offre en plus par rapport aux autres langages. <br><br>  À la fin, je vais vous montrer comment commencer à utiliser Yew et WebAssembly dès aujourd'hui. <br><br><h2>  Qu'est-ce que l'if? </h2><br>  Tout d'abord, c'est WebAssembly, c'est-à-dire  bytecode exécutable qui fonctionne dans les navigateurs.  Il est nécessaire pour exécuter des algorithmes complexes côté utilisateur, par exemple, la cryptographie, le codage / décodage.  Il est plus facile de l'implémenter dans les langages système que de visser des béquilles. <br><br>  WebAssembly est une norme clairement décrite, comprise et prise en charge par tous les navigateurs modernes.  Il vous permet d'utiliser différents langages de programmation.  Et cela est intéressant principalement parce que vous pouvez réutiliser le code créé par la communauté dans d'autres langues. <br><br>  Si vous le souhaitez, vous pouvez complètement écrire une application sur WebAssembly, et Yew vous permet de le faire, mais il est important de ne pas oublier que même dans ce cas, JavaScript reste dans le navigateur.  Il est nécessaire de préparer WebAssembly - prenez le module (WASM), ajoutez-y l'environnement et exécutez-le.  C'est-à-dire  JavaScript est indispensable.  Par conséquent, WebAssembly mérite d'être considéré comme une extension plutôt qu'une alternative révolutionnaire à JS. <br><br><h3>  À quoi ressemble le développement </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/9ef/8d5/b7f/9ef8d5b7ffb36029d2a4d840f9432980.png"><br><br>  Vous avez une source, il y a un compilateur.  Vous traduisez tout cela dans un format binaire et l'exécutez dans un navigateur.  Si le navigateur est ancien, sans prise en charge de WebAssembly, alors emscripten est requis.  Il s'agit, en gros, d'un émulateur WebAssembly pour un navigateur. <br><br><h3>  If - framework wasm prêt à l'emploi </h3><br>  Passons à Yew.  J'ai développé ce cadre à la fin de l'année dernière.  Ensuite, j'ai écrit une sorte d'application de crypto-monnaie sur Elm et face au fait qu'en raison de restrictions linguistiques, je ne peux pas créer une structure récursive.  Et à ce moment, j'ai pensé: à Rust, mon problème serait résolu très facilement.  Et puisque 99% du temps j'écris en Rust et que j'aime ce langage précisément pour ses fonctionnalités, j'ai décidé d'expérimenter - pour compiler l'application avec la même fonction de mise à jour dans Rust. <br><br>  Le premier croquis m'a pris plusieurs heures, j'ai dû comprendre comment compiler WebAssembly.  Je l'ai lancé et j'ai réalisé qu'en quelques heures, il avait posé le noyau, ce qui est très facile à développer.  Il ne m'a fallu que quelques jours pour tout apporter au moteur de framework minimum. <br><br>  Je l'ai posté en open source, mais je ne m'attendais pas à ce qu'il soit populaire.  Cependant, aujourd'hui, il a collecté plus de 4 000 étoiles sur GitHub.  Vous pouvez voir le projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Il existe de nombreux exemples. <br><br>  Le cadre est entièrement écrit en Rust.  Yew prend en charge la compilation directement sur WebAssembly (cible wasm32-unknown-unknown) sans emscripten.  Si nécessaire, vous pouvez utiliser emscripten. <br><br><h2>  L'architecture </h2><br>  Maintenant, quelques mots sur la façon dont le cadre diffère des approches traditionnelles qui existent dans le monde JavaScript. <br><br>  Tout d'abord, je vais vous montrer les restrictions linguistiques que j'ai rencontrées dans Elm.  Prenons le cas quand il y a un modèle et qu'il y a un message qui vous permet de transformer ce modèle. <br><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Model =    { <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> : <span class="hljs-type"><span class="hljs-type">Int</span></span>    }  <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Msg    = <span class="hljs-keyword"><span class="hljs-keyword">Increment</span></span>    | Decrement</code> </pre> <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> msg <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">Increment</span></span> -&gt;     { value = model.value + <span class="hljs-number"><span class="hljs-number">1</span></span> }   Decrement -&gt;     { <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = model.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre><br>  Dans Elm, nous créons simplement un nouveau modèle et l'afficher à l'écran.  La version précédente du modèle reste inchangée.  Pourquoi je me concentre là-dessus?  Parce que dans Yew, le modèle est mutable, et c'est l'une des questions les plus courantes.  Ensuite, je vais expliquer pourquoi cela est fait. <br><br>  Au départ, j'ai suivi le chemin classique lors de la recréation du modèle.  Mais au fur et à mesure que le cadre s'est développé, j'ai vu que cela n'avait aucun sens de stocker la version précédente du modèle.  Rust vous permet de suivre la durée de vie de toutes les données, qu'elles soient modifiées ou non.  Et donc je peux changer le modèle en toute sécurité, sachant que Rust contrôle l'absence de conflit. <br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Model</span></span></span></span> {   value: <span class="hljs-built_in"><span class="hljs-built_in">i64</span></span>, } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Msg</span></span></span></span> {   Increment,   Decrement, }</code> </pre><br><pre> <code class="hljs php">match msg {   Msg::Increment =&gt; {       <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.value += <span class="hljs-number"><span class="hljs-number">1</span></span>;   }   Msg::Decrement =&gt; {       <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.value -= <span class="hljs-number"><span class="hljs-number">1</span></span>;   } }</code> </pre><br>  Ceci est le premier moment.  Deuxième point: pourquoi avons-nous besoin de l'ancienne version du modèle?  Dans le même orme, il n'y a guère de problème d'accès concurrentiel.  L'ancien modèle n'est nécessaire que pour comprendre quand effectuer le rendu.  La prise de conscience de ce moment m'a permis de me débarrasser complètement de l'immuable et de ne pas conserver l'ancienne version. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c98/ff5/d94/c98ff5d946992d46ba910e36375b4fc7.png"><br><br>  Regardez l'option lorsque nous avons la fonction de <code>update</code> et deux champs - <code>value</code> et <code>name</code> .  Une valeur est enregistrée lorsque nous entrons des données dans le champ de <code>input</code> .  Le modèle change. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/140/a12/d41/140a12d4106fb15b17204d547de29b82.png"><br><br>  Il est important que la <code>value</code> ne <code>value</code> pas impliquée dans le rendu.  Et donc nous pouvons le changer autant que nous voulons.  Mais nous n'avons pas besoin d'influencer l'arborescence DOM et nous n'avons pas besoin d'initier ces changements. <br><br>  Cela m'a conduit à l'idée que seul le développeur peut savoir le bon moment où le rendu doit vraiment être lancé.  Pour commencer, j'ai commencé à utiliser l'indicateur - juste une valeur booléenne - <code>ShouldRender</code> , qui signale que le modèle a changé et que nous devons commencer le rendu.  Dans le même temps, il n'y a pas de surcharge pour les comparaisons constantes, il n'y a pas de consommation de mémoire - les applications écrites en Yew sont les plus efficaces. <br><br>  Dans l'exemple ci-dessus, il n'y avait aucune allocation de mémoire, à l'exception du message généré et envoyé.  Le modèle a conservé son état, et cela ne s'est reflété dans le rendu qu'à l'aide d'un drapeau. <br><br><h2>  Les possibilités </h2><br>  Écrire un framework qui fonctionne dans WebAssembly n'est pas une tâche facile.  Nous avons JavaScript, mais il devrait créer une sorte d'environnement avec lequel il faut interagir, ce qui représente une énorme quantité de travail.  La version initiale de ces bundles ressemblait à ceci: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3ab/5aa/f25/3ab5aaf257e0a6a9f611e885dba4bd8d.png"><br><br>  J'ai pris une démo d'un autre projet.  Il existe de nombreux projets qui vont dans ce sens, mais cela conduit rapidement à une impasse.  Après tout, le framework est un développement assez important et vous devez écrire beaucoup de code d'ancrage.  J'ai commencé à utiliser des bibliothèques à Rust qui s'appellent des caisses, en particulier la <code>Stdweb</code> . <br><br><h3>  JS intégré </h3><br>  Avec l'aide des macros Rust, vous pouvez étendre la langue - nous pouvons intégrer des morceaux de JavaScript dans le code Rust, c'est une fonctionnalité très utile de la langue. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> handle = js! {   var callback = @{callback};   var action = function() {       callback();   };   var delay = @{ms};   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {       interval_id: setInterval(action, delay),       callback: callback,   }; };</code> </pre><br>  L'utilisation de macros et de Stdweb m'a permis d'écrire rapidement et efficacement tous les liens nécessaires. <br><br><h3>  Modèles Jsx </h3><br>  Au début, j'ai suivi le chemin Elm et j'ai commencé à utiliser des modèles implémentés à l'aide de code. <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">view</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; Html&lt;Context, <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>&gt; {   nav(<span class="hljs-string"><span class="hljs-string">"nav"</span></span>, (<span class="hljs-string"><span class="hljs-string">"menu"</span></span>), <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[       button(<span class="hljs-string"><span class="hljs-string">"button"</span></span>, (), (<span class="hljs-string"><span class="hljs-string">"onclick"</span></span>, || Msg::Clicked)),       tag(<span class="hljs-string"><span class="hljs-string">"section"</span></span>, (<span class="hljs-string"><span class="hljs-string">"ontop"</span></span>), <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[           p(<span class="hljs-string"><span class="hljs-string">"My text..."</span></span>)       ])   ]) }</code> </pre><br>  Je n'ai jamais été partisan de React.  Mais quand j'ai commencé à écrire mon framework, j'ai réalisé que JSX dans React est une chose très cool.  Voici une présentation très pratique des modèles de code. <br><br>  En conséquence, j'ai pris une macro sur Rust et implémenté directement dans Rust la possibilité d'écrire du balisage HTML qui génère immédiatement des éléments d'arborescence virtuelle. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Renderable&lt;Context, Model&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Model {   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">view</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; Html&lt;Context, <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>&gt; {       html! {           &lt;div&gt;               &lt;nav class=<span class="hljs-string"><span class="hljs-string">"menu"</span></span>,&gt;                   &lt;button onclick=|_| Msg::Increment,&gt;{ <span class="hljs-string"><span class="hljs-string">"Increment"</span></span> }&lt;/button&gt;                   &lt;button onclick=|_| Msg::Decrement,&gt;{ <span class="hljs-string"><span class="hljs-string">"Decrement"</span></span> }&lt;/button&gt;               &lt;/nav&gt;               &lt;p&gt;{ <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.value }&lt;/p&gt;               &lt;p&gt;{ Local::now() }&lt;/p&gt;           &lt;/div&gt;       }   } }</code> </pre><br>  Nous pouvons dire que les modèles de type JSX sont des modèles de code pur, mais sur des stéroïdes.  Ils sont présentés dans un format pratique.  Notez également que j'insère ici une expression Rust directement dans le bouton (l'expression Rust peut être insérée à l'intérieur de ces modèles).  Cela vous permet de vous intégrer très étroitement. <br><br><h3>  Composants assez structurés </h3><br>  Ensuite, j'ai commencé à développer des modèles et réalisé la possibilité d'utiliser des composants.  Il s'agit du premier problème rencontré dans le référentiel.  J'ai implémenté des composants qui peuvent être utilisés dans le code du modèle.  Vous déclarez simplement une structure honnête dans Rust et lui écrivez quelques propriétés.  Et ces propriétés peuvent être définies directement à partir du modèle. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9b9/3d0/d37/9b93d0d3797e46f73650b00689315009.png"><br><br>  Encore une fois, je note la chose importante que ces modèles sont du code Rust généré honnêtement.  Par conséquent, toute erreur ici sera remarquée par le compilateur.  C'est-à-dire  vous ne pouvez pas vous tromper, comme c'est souvent le cas dans le développement JavaScript. <br><br><h3>  Zones dactylographiées </h3><br>  Une autre caractéristique intéressante est que lorsqu'un composant est placé à l'intérieur d'un autre composant, il peut voir le type de message du parent. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/933/831/4cb/9338314cb1560b2172c6ab11bbff7977.png"><br><br>  Le compilateur lie rigidement ces types et ne vous donnera pas la possibilité de faire une erreur.  Lors du traitement des événements, les messages que le composant attend ou peut envoyer doivent correspondre entièrement au parent. <br><br><h3>  Autres fonctionnalités </h3><br>  J'ai transféré une implémentation de Rust directement vers le framework qui vous permet d'utiliser facilement différents formats de sérialisation / désérialisation (en lui fournissant des wrappers supplémentaires).  Voici un exemple: nous allons au stockage local et, en restaurant les données, spécifions un certain wrapper - ce que nous attendons ici est json. <br><br><pre> <code class="rust hljs">Msg::Store =&gt; {   context.local_storage.store(KEY, Json(&amp;model.clients)); } Msg::Restore =&gt; {    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> Json(<span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(clients)) = context.local_storage.restore(KEY) {        model.clients = clients;   } }</code> </pre><br>  Il peut s'agir de n'importe quel format, y compris binaire.  En conséquence, la sérialisation et la désérialisation deviennent transparentes et pratiques. <br><br>  L'idée d'une autre opportunité que j'ai implémentée est venue des utilisateurs du framework.  Ils ont demandé de faire des fragments.  Et là, je suis tombé sur une chose intéressante.  Voyant en JavaScript la possibilité d'insérer des fragments dans l'arborescence DOM, j'ai d'abord décidé qu'il serait très facile d'implémenter une telle fonction dans mon framework.  Mais j'ai essayé cette option, et il s'est avéré que cela ne fonctionne pas.  Je devais le comprendre, marcher sur cet arbre, voir ce qui avait changé là-bas, etc. <br><br>  Le framework Yew utilise une arborescence DOM virtuelle, tout y existe initialement.  En fait, quand il y a des changements dans le modèle, ils se transforment en correctifs qui changent déjà l'arborescence DOM rendue. <br><br><pre> <code class="hljs xml">html! {   <span class="hljs-tag"><span class="hljs-tag">&lt;&gt;</span></span>       <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span>{ "Row" }<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span>       <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span>{ "Row" }<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span>       <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span>{ "Row" }<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;/&gt;</span></span> }</code> </pre><br><h2>  Des avantages supplémentaires </h2><br>  La rouille offre de nombreuses autres fonctionnalités puissantes, je ne parlerai que des plus importantes. <br><br><h3>  Services: interaction avec le monde extérieur </h3><br>  La première occasion dont je veux parler concerne les services.  Vous pouvez décrire les fonctionnalités nécessaires sous la forme d'un service, le publier en tant que caisse et le réutiliser. <br><br>  Dans Rust, la possibilité de créer des bibliothèques, leur intégration, l'ancrage et le collage est très bien implémentée.  En fait, vous pouvez créer diverses API pour interagir avec votre service, y compris celles en JavaScript.  Dans le même temps, le framework peut interagir avec le monde extérieur, malgré le fait qu'il fonctionne à l'intérieur du runtime WebAssembly. <br><br>  Exemples de services: <br><br><ul><li>  TimeOutService; <br></li><li>  IntervalService; <br></li><li>  FetchService; <br></li><li>  WebSocketService; <br></li><li>  Services personnalisés ... <br></li></ul><br>  Services et caisses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">antirouille</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">crates.io</a> . <br><br><h3>  Contexte: exigences de l'État </h3><br>  Une autre chose que j'ai mise en œuvre dans le cadre n'est pas entièrement traditionnelle, c'est le contexte.  React a une API Context, mais j'ai utilisé Context dans un sens différent.  Le cadre Yew se compose des composants que vous créez et le contexte est un état global.  Les composants peuvent ne pas prendre en compte cet état global, mais peuvent faire certaines demandes - de sorte que l'entité globale remplit certains critères. <br><br>  Disons que notre composant abstrait nécessite la possibilité de télécharger quelque chose sur S3. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3f6/477/776/3f6477776d227c4b7abcf64be2f17f5c.png"><br><br>  On peut voir ci-dessous qu'il utilise ce téléchargement, c'est-à-dire  envoie des données à S3.  Un tel composant peut se présenter sous la forme d'un rack.  L'utilisateur qui télécharge ce composant et l'ajoute à l'intérieur du modèle à son application rencontrera une erreur - le compilateur lui demandera où est le support S3?  L'utilisateur devra implémenter ce support.  Après cela, le composant commence automatiquement à vivre pleinement. <br><br>  Où est-il nécessaire?  Imaginez: vous créez un composant avec une cryptographie intelligente.  Il a des exigences que le contexte environnant lui permette de se connecter quelque part.  Il vous suffit d'ajouter un formulaire d'autorisation dans le modèle et de mettre en place dans votre contexte la connexion avec votre service.  C'est-à-dire  ce sera littéralement trois lignes de code.  Après cela, le composant commence à fonctionner. <br><br>  Imaginez que nous ayons des dizaines de composants différents.  Et ils ont tous la même exigence.  Cela vous permet d'implémenter une sorte de fonctionnalité une fois pour relancer tous les composants et récupérer les données nécessaires.  Hors contexte.  Et le compilateur ne vous permettra pas de faire une erreur: si vous n'avez pas d'interface qui nécessite un composant, rien ne fonctionnera. <br><br>  Par conséquent, vous pouvez facilement créer des boutons très pointilleux qui demanderont une API ou d'autres fonctionnalités.  Grâce à Rust et au système de ces interfaces (elles sont appelées trait dans Rust), il devient possible de déclarer les exigences des composants. <br><br><h3>  Le compilateur ne vous laissera pas faire d'erreur </h3><br>  Imaginez que nous créons un composant avec certaines propriétés, dont la possibilité de définir le rappel.  Et, par exemple, nous avons défini la propriété et manqué une lettre dans son nom. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/829/d84/93d/829d8493d52ccff0299dc030661c5b37.png"><br><br>  En essayant de compiler, Rust répond rapidement.  Il dit que nous nous sommes trompés et qu'il n'y a pas une telle propriété: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/02d/08d/ef7/02d08def74b01670bc6b4b0695f5cc2f.png"><br><br>  Comme vous pouvez le voir, Rust utilise directement ce modèle et peut afficher toutes les erreurs à l'intérieur de la macro.  Il vous dit comment la propriété doit vraiment s'appeler.  Si vous avez réussi le compilateur, vous n'aurez pas d'erreurs d'exécution idiotes comme des fautes de frappe. <br><br>  Imaginez maintenant, nous avons un bouton qui demande à notre contexte global de pouvoir se connecter à S3.  Et créez un contexte qui n'implémente pas le support S3.  Voyons ce qui se passe. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a50/8d6/c7e/a508d6c7e4470c16f7890f36f0bd4135.png"><br><br>  Le compilateur signale que nous avons inséré un bouton, mais cette interface n'est pas implémentée pour le contexte. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/63b/4f9/790/63b4f97902e2460ced9cbbdd0f820f23.png"><br><br>  Il ne reste plus qu'à entrer dans l'éditeur, ajouter un lien vers Amazon dans le contexte, et tout commencera.  Vous pouvez créer des services prêts à l'emploi avec une sorte d'API, puis simplement ajouter au contexte, y substituer un lien et le composant prend immédiatement vie.  Cela vous permet de faire des choses très intéressantes: vous ajoutez des composants, créez un contexte, remplissez-le de services.  Et tout cela fonctionne de manière entièrement automatique; des efforts minimes sont nécessaires pour tout lier ensemble. <br><br><h2>  Comment commencer à utiliser Yew? </h2><br>  Par où commencer si vous souhaitez essayer de compiler une application WebAssembly?  Et comment cela peut-il être fait en utilisant le cadre Yew? <br><br><h3>  Compilation de rouille à wasm </h3><br>  Tout d'abord, vous devez installer le compilateur.  Il existe un outil de rustup pour cela: <br><br> <code>curl https://sh.rustup.rs -sSf | sh <br></code> <br>  De plus, vous devrez peut-être emscripten.  À quoi cela peut-il être utile?  La plupart des bibliothèques écrites pour les langages de programmation système, en particulier pour Rust (à l'origine un système), sont développées pour Linux, Windows et d'autres systèmes d'exploitation à part entière.  De toute évidence, le navigateur n'a pas beaucoup de fonctionnalités. <br><br>  Par exemple, la génération de nombres aléatoires dans un navigateur ne se fait pas de la même manière que sous Linux.  emscripten est utile si vous souhaitez utiliser des bibliothèques qui nécessitent une API système. <br><br>  Les bibliothèques et l'ensemble de l'infrastructure passent tranquillement à un assemblage Web honnête, et emscripten n'est plus requis (vous utilisez des capacités basées sur JavaScript pour générer des nombres aléatoires et d'autres choses), mais si vous devez créer quelque chose qui n'est pas du tout pris en charge dans le navigateur, vous ne pouvez pas vous passer d'emscripten . <br><br>  Je recommande également d'utiliser cargo-web: <br><br> <code>cargo install cargo-web <br></code> <br>  Il est possible de compiler WebAssembly sans utilitaires supplémentaires.  Mais cargo-web est un outil génial qui fournit plusieurs choses utiles aux développeurs JavaScript.  En particulier, il surveillera les fichiers: si vous apportez des modifications, il commencera à compiler immédiatement (le compilateur ne fournit pas de telles fonctions).  Dans ce cas, Cargo-web vous permettra d'accélérer le développement.  Il existe différents systèmes de construction pour Rust, mais le fret représente 99,9% de tous les projets. <br><br>  Un nouveau projet est créé comme suit: <br><br> <code>cargo new --bin my-project <br></code> <br> <code>[package] <br> name = "my-project" <br> version = "0.1.0" <br> <br> [dependencies] <br> yew = "0.3.0" <br></code> <br>  Ensuite, lancez simplement le projet: <br><br> <code>cargo web start --target wasm32-unknown-unknown <br></code> <br>  J'ai donné un exemple de WebAssembly honnête.  Si vous devez compiler sous emscripten (le compilateur rust peut connecter emscripten lui-même), vous pouvez insérer le mot <code>emscripten</code> dans le tout dernier élément <code>unknown</code> , ce qui vous permet d'utiliser plus de caisses.  N'oubliez pas que emscripten est un kit supplémentaire assez volumineux pour votre fichier.  Par conséquent, il est préférable d'écrire du code WebAssembly honnête. <br><br><h3>  Restrictions existantes </h3><br>  Toute personne ayant une expérience du codage dans les langages de programmation système peut être frustrée par les limitations existantes dans le cadre.  Toutes les bibliothèques ne peuvent pas être utilisées dans WebAssembly.  Par exemple, dans un environnement JavaScript, il n'y a pas de threads.  WebAssembly ne le déclare pas en principe, et bien sûr vous pouvez l'utiliser dans un environnement multi-thread (c'est une question ouverte), mais JavaScript est toujours un environnement single-thread.  Oui, il y a des travailleurs, mais c'est l'isolement, donc il n'y aura pas de flux là-bas. <br><br>  Il semblerait que vous puissiez vivre sans flux.  Mais si vous souhaitez utiliser des bibliothèques basées sur des threads, par exemple, vous souhaitez ajouter une sorte d'exécution, cela peut ne pas décoller. <br><br>  De plus, il n'y a pas d'API système, à l'exception de celle que vous transférerez de JavaScript à WebAssembly.  Par conséquent, de nombreuses bibliothèques ne seront pas portées.  Vous ne pouvez pas écrire et lire des fichiers directement, les sockets ne peuvent pas être ouverts et vous ne pouvez pas écrire sur le réseau.  Si vous voulez créer un socket Web, par exemple, vous devez le faire glisser depuis JavaScript. <br><br>  Un autre inconvénient est que le débogueur WASM existe, mais personne ne l'a vu.  Il est encore dans un état brut tel qu'il est peu probable qu'il vous soit utile.  Le débogage de WebAssembly est donc une question délicate. <br><br>  Lors de l'utilisation de Rust, presque tous les problèmes d'exécution seront associés à des erreurs de logique métier, ils seront faciles à résoudre.  Mais très rarement des bogues de bas niveau apparaissent - par exemple, l'une des bibliothèques fait le mauvais amarrage - et c'est déjà une question difficile.  Par exemple, pour le moment, il y a un tel problème: si je compile le cadre avec emscripten et qu'il y a une cellule de mémoire variable, dont la possession est supprimée, elle est donnée, emscripten se désagrège quelque part au milieu (et je ne suis même pas sûr que ce soit emscripten).  Sachez que si vous rencontrez un problème quelque part dans le middleware à un niveau bas, il sera difficile de le résoudre pour le moment. <br><br><h2>  L'avenir du cadre </h2><br>  Comment évoluera Yew?  Je vois son objectif principal dans la création de composants monolithiques.  Vous aurez un fichier WebAssembly compilé, et vous le collez simplement dans l'application.  Par exemple, il peut fournir des capacités cryptographiques, un rendu ou une édition. <br><br><h3>  Intégration JS </h3><br>  L'intégration avec JavaScript sera renforcée.  JavaScript a écrit un grand nombre de bibliothèques intéressantes qui sont faciles à utiliser.  Et il y a des exemples dans le référentiel où je montre comment vous pouvez utiliser la bibliothèque JavaScript existante directement à partir du cadre Yew. <br><br><h3>  CSS typé </h3><br>  Étant donné que Rust est utilisé, il est évident que vous pouvez ajouter du CSS typé qui peut être généré avec la même macro que dans l'exemple d'un moteur de modèle de type JSX.  Dans ce cas, le compilateur vérifiera, par exemple, si vous avez attribué un autre attribut au lieu de la couleur.  Cela vous fera économiser beaucoup de temps. <br><br><h3>  Composants prêts </h3><br>  Je regarde également vers la création de composants prêts à l'emploi.  Sur le framework, vous pouvez faire des fissures qui fourniront, par exemple, un ensemble de quelques boutons ou éléments qui seront connectés en tant que bibliothèque, ajoutés aux modèles et utilisés. <br><br><h3>  Amélioration des performances dans les affaires privées </h3><br>  La performance est une question très délicate et complexe.  WebAssembly est-il plus rapide que JavaScript?  Je n'ai aucune preuve confirmant une réponse positive ou négative.  On dirait et selon certains tests très simples que j'ai menés, WebAssembly est très rapide.  Et je suis convaincu que ses performances seront supérieures à celles de JavaScript, simplement parce que c'est un bytecode de bas niveau où l'allocation de mémoire n'est pas requise et il existe de nombreux autres moments nécessitant des ressources. <br><br><h3>  Plus de contributeurs </h3><br>  J'aimerais attirer plus de contributeurs.  Les portes pour participer au cadre sont toujours ouvertes.  Tous ceux qui souhaitent mettre à niveau quelque chose, comprendre le noyau et transformer les outils avec lesquels un grand nombre de développeurs travaillent peuvent facilement se connecter et proposer leurs propres modifications. <br><br>  De nombreux contributeurs ont déjà participé au projet.  Mais il n'y a pas de contributeurs Core pour le moment, car pour cela vous devez comprendre le vecteur de développement du framework, mais il n'a pas encore été clairement formulé.  Mais il y a une colonne vertébrale, des gars qui connaissent très bien Yew - environ 30 personnes.  Si vous souhaitez également ajouter quelque chose au cadre, veuillez toujours envoyer une demande d'extraction. <br><br><h3>  La documentation </h3><br>  Un point obligatoire dans mes plans est la création d'une grande quantité de documentation sur la façon d'écrire des applications sur Yew.  De toute évidence, l'approche de développement dans ce cas est différente de ce que nous avons vu dans React et Elm. <br><br>  Parfois, les gars me montrent des cas intéressants sur la façon d'utiliser le cadre.  Pourtant, créer un cadre n'est pas la même chose que d'y écrire professionnellement.  Des pratiques d'utilisation du cadre sont toujours en cours d'élaboration. <br><br>  Essayez-le, installez Rust, développez vos capacités en tant que développeur.  La maîtrise de WebAssembly sera utile à chacun de nous, car la création d'applications très complexes est le moment que nous attendons depuis longtemps.  En d'autres termes, WebAssembly ne concerne pas seulement un navigateur Web, mais c'est généralement un runtime qui se développe définitivement et se développera encore plus activement. <br><br><blockquote>  Si vous avez aimé le rapport, faites attention: du 24 au 25 novembre, un nouveau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HolyJS</a> se tiendra à Moscou, et il y aura aussi beaucoup de choses intéressantes.      —  ,       ( <b>  </b>  ). </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr422253/">https://habr.com/ru/post/fr422253/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr422239/index.html">Comment lancer la livraison pour des millions d'utilisateurs</a></li>
<li><a href="../fr422241/index.html">KPI - Trois lettres d'achoppement</a></li>
<li><a href="../fr422243/index.html">CRM pour les petites entreprises. En avez-vous besoin?</a></li>
<li><a href="../fr422247/index.html">OK Instant Games Cup. Concurrence pour les développeurs de jeux HTML5</a></li>
<li><a href="../fr422251/index.html">"Un haut niveau d'auto-discipline." Jeffrey Richter explique comment coder, écrire des livres et créer ses propres entreprises</a></li>
<li><a href="../fr422255/index.html">Création de personnages dans Blender et Unity</a></li>
<li><a href="../fr422257/index.html">Critique du lecteur PocketBook 627: classe moyenne avec rétro-éclairage, Wi-Fi et service cloud</a></li>
<li><a href="../fr422259/index.html">Structures de données de base. Matériel. Les bases</a></li>
<li><a href="../fr422261/index.html">Zextras Powerstore et systèmes de hiérarchisation</a></li>
<li><a href="../fr422263/index.html">«Dormammu, je suis tombé d'accord»: un algorithme de coopération mutuellement bénéfique avec une personne</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>