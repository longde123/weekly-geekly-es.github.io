<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🤝‍👨🏽 🤲🏻 🦂 Alokasi memori JVM 🐎 👩🏿‍🎓 🚴🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! Kami ingin bertepatan dengan terjemahan materi hari ini dengan peluncuran utas baru dalam kursus Java Developer , yang akan dimulai bes...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Alokasi memori JVM</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/445312/"> Halo semuanya!  Kami ingin bertepatan dengan terjemahan materi hari ini dengan peluncuran utas baru dalam kursus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Java Developer</a> , yang akan dimulai besok.  Baiklah, mari kita mulai. <br><br>  JVM bisa menjadi binatang yang kompleks.  Untungnya, sebagian besar kerumitan ini tersembunyi di bawah tenda, dan kami, sebagai pengembang aplikasi dan bertanggung jawab atas penyebaran, sering kali tidak perlu terlalu khawatir tentang hal itu.  Meskipun karena semakin populernya teknologi penyebaran aplikasi dalam wadah, ada baiknya memperhatikan alokasi memori di JVM. <br><br><img src="https://habrastorage.org/webt/ju/oj/ek/juojekjvyfc9pflhqawoxksp-pe.png"><br><br>  <b>Dua macam memori</b> <br><br>  JVM membagi memori menjadi dua kategori utama: heap dan non-heap.  Tumpukan adalah bagian dari memori JVM yang paling akrab dengan para pengembang.  Objek yang dibuat oleh aplikasi disimpan di sini.  Mereka tetap di sana sampai mereka dipindahkan oleh pemulung.  Biasanya, ukuran tumpukan yang digunakan aplikasi bervariasi tergantung pada beban saat ini. <br><a name="habracut"></a><br>  Memori out-of-heap dibagi menjadi beberapa area.  Di HotSpot, Anda dapat menggunakan mekanisme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Native memory tracking (NMT)</a> untuk menjelajahi area memori ini.  Harap dicatat bahwa meskipun NMT tidak melacak penggunaan semua memori asli ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">misalnya, alokasi memori asli oleh kode pihak ketiga tidak dipantau</a> ), kemampuannya cukup untuk sebagian besar aplikasi Musim Semi yang khas.  Untuk menggunakan NMT, jalankan aplikasi dengan <code>-XX:NativeMemoryTracking=summary</code> dan gunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ringkasan jcmd VM.native_memory melihat informasi pada memori yang digunakan.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><br><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mari kita lihat menggunakan NMT sebagai contoh dari teman lama kita Petclinic</a> .  Diagram di bawah ini menunjukkan penggunaan memori JVM menurut data NMT (dikurangi overhead NMT-nya sendiri) saat memulai Petclinic dengan ukuran heap maksimum 48 MB ( <code>-Xmx48M</code> ): <br><br><img src="https://habrastorage.org/webt/m8/nk/be/m8nkberjczog7bolri8lwoglbbm.png"><br><br>  Seperti yang Anda lihat, memori di luar tumpukan menyumbang sebagian besar memori JVM yang digunakan, dan memori tumpukan hanya seperenam dari total.  Dalam hal ini, kira-kira 44 MB (di mana 33 MB digunakan segera setelah pengumpulan sampah).  Kehabisan memori habis menggunakan memori total sebesar 223 MB. <br><br>  <b>Area memori asli</b> <br><br>  <b>Ruang kelas terkompresi</b> : digunakan untuk menyimpan informasi tentang kelas yang dimuat.  Terbatas pada parameter <code>MaxMetaspaceSize</code> .  Fungsi dari jumlah kelas yang telah dimuat. <br><br>  <i>Catatan Penerjemah</i> <br><br><blockquote>  Untuk beberapa alasan, penulis menulis tentang ruang kelas terkompresi, dan bukan tentang seluruh area kelas.  Area ruang kelas terkompresi adalah bagian dari area kelas, dan parameter <code>MaxMetaspaceSize</code> membatasi ukuran seluruh area kelas, bukan hanya ruang kelas terkompresi.  Untuk membatasi "ruang kelas terkompresi", parameter <code>CompressedClassSpaceSize</code> digunakan. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dari sini</a> : <br>  Jika <code>UseCompressedOops</code> diaktifkan dan <code>UseCompressedClassesPointers</code> digunakan, maka dua area berbeda dari memori asli digunakan untuk metadata kelas ... <br>  Suatu wilayah dialokasikan untuk pointer kelas terkompresi ini (offset 32-bit).  Ukuran wilayah dapat diatur dengan <code>CompressedClassSpaceSize</code> dan 1 gigabyte (GB) secara default ... <br>  <code>MaxMetaspaceSize</code> berlaku untuk jumlah ruang kelas terkompresi yang dikomit dan ruang untuk metadata kelas lainnya <br><br>  Jika parameter <code>UseCompressedOops</code> dan <code>UseCompressedOops</code> digunakan, maka dua area berbeda dari memori asli digunakan untuk metadata kelas ... <br><br>  Untuk pointer terkompresi, area memori dialokasikan (offset 32-bit).  Ukuran area ini dapat diatur oleh <code>CompressedClassSpaceSize</code> dan secara default 1 GB ... <br>  Parameter <code>MaxMetaspaceSize</code> mengacu pada jumlah area pointer terkompresi dan area untuk metadata kelas lainnya. </blockquote><br><br><ul><li>  Utas: Memori yang digunakan oleh utas di JVM.  Fungsi dari jumlah utas yang berjalan. </li><li>  Cache kode: Memori yang digunakan oleh JIT untuk menjalankannya.  Fungsi dari jumlah kelas yang telah dimuat.  Terbatas untuk <code>ReservedCodeCacheSize</code> .  Anda dapat mengurangi pengaturan JIT, misalnya, dengan menonaktifkan kompilasi berjenjang. </li><li>  GC (pengumpul sampah): menyimpan data yang digunakan oleh pengumpul sampah.  Tergantung pengumpul sampah yang digunakan. </li><li>  Simbol: menyimpan karakter seperti nama bidang, tanda tangan metode, dan string yang diinternir.  Penggunaan memori karakter yang berlebihan dapat mengindikasikan bahwa garis terlalu diinternir. </li><li>  Internal: menyimpan data internal lain yang tidak termasuk dalam area lain mana pun. </li></ul><br>  <b>Perbedaan</b> <br><br>  Dibandingkan dengan heap, memori off-heap berubah lebih sedikit saat memuat.  Segera setelah aplikasi memuat semua kelas yang akan digunakan dan JIT benar-benar hangat, semuanya akan menjadi stabil.  Untuk melihat penurunan penggunaan <i>ruang kelas terkompresi</i> , pemuat kelas yang memuat kelas harus dihapus oleh pengumpul sampah.  Ini biasa di masa lalu ketika aplikasi dikerahkan dalam wadah servlet atau server aplikasi (pemuat kelas aplikasi dihapus oleh pengumpul sampah ketika aplikasi dihapus dari server aplikasi), tetapi ini jarang terjadi dengan pendekatan modern untuk penyebaran aplikasi. <br><br>  <b>Konfigurasikan JVM</b> <br><br>  Mengkonfigurasi JVM agar efisien menggunakan RAM yang tersedia tidaklah mudah.  Jika Anda menjalankan JVM dengan parameter <code>-Xmx16M</code> dan berharap tidak lebih dari 16 MB memori yang akan digunakan, maka Anda akan mendapatkan kejutan yang tidak menyenangkan. <br><br>  Area memori JVM yang menarik adalah cache kode JIT.  Secara default, HotSpot JVM akan menggunakan hingga 240 MB.  Jika cache kode terlalu kecil, JIT mungkin tidak memiliki cukup ruang untuk menyimpan datanya, dan sebagai hasilnya, kinerja akan berkurang.  Jika cache terlalu besar, maka memori mungkin terbuang sia-sia.  Saat menentukan ukuran cache, penting untuk mempertimbangkan pengaruhnya terhadap penggunaan memori dan kinerja. <br><br>  Saat berjalan dalam wadah Docker, Java versi terbaru <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sekarang menyadari</a> keterbatasan memori wadah dan mencoba mengubah ukuran memori JVM.  Sayangnya, banyak memori sering dialokasikan di luar heap dan tidak cukup di heap.  Misalkan Anda memiliki aplikasi yang berjalan dalam wadah dengan 2 prosesor dan 512 MB memori yang tersedia.  Anda ingin menangani lebih banyak beban kerja dan menambah jumlah prosesor menjadi 4 dan memori menjadi 1 GB.  Seperti yang kita bahas di atas, ukuran tumpukan biasanya bervariasi dengan beban, dan memori di luar tumpukan berubah kurang signifikan.  Oleh karena itu, kami berharap bahwa sebagian besar tambahan 512 MB akan dialokasikan ke heap untuk menangani peningkatan beban.  Sayangnya, secara default, JVM tidak akan melakukan ini dan akan mendistribusikan memori tambahan lebih atau kurang secara merata antara memori pada heap dan off heap. <br><br>  Untungnya, tim CloudFoundry memiliki pengetahuan luas tentang alokasi memori di JVM.  Jika Anda mengunduh aplikasi ke CloudFoundry, maka paket build akan secara otomatis menerapkan pengetahuan ini kepada Anda.  Jika Anda tidak menggunakan CloudFoudry atau ingin memahami lebih lanjut tentang cara mengkonfigurasi JVM, disarankan untuk membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">deskripsi dari</a> versi ketiga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kalkulator memori Java buildpack</a> . <br><br>  <b>Apa artinya ini untuk Spring</b> <br><br>  Tim Spring menghabiskan banyak waktu untuk berpikir tentang kinerja dan penggunaan memori, mengingat kemungkinan menggunakan memori baik di heap dan di heap.  Salah satu cara untuk membatasi penggunaan memori di luar tumpukan adalah dengan membuat bagian-bagian kerangka kerja sekompleks mungkin.  Contoh dari ini adalah menggunakan Refleksi untuk membuat dan menyuntikkan dependensi ke dalam kacang aplikasi Anda.  Melalui penggunaan Refleksi, jumlah kode kerangka kerja yang Anda gunakan tetap konstan, terlepas dari jumlah kacang dalam aplikasi Anda.  Untuk mengoptimalkan waktu startup, kami menggunakan cache di heap, membersihkan cache ini setelah peluncuran selesai.  Memori tumpukan dapat dengan mudah dibersihkan oleh pengumpul sampah untuk menyediakan lebih banyak memori yang tersedia untuk aplikasi Anda. <br><br>  Secara tradisional, kami menunggu komentar Anda tentang materi tersebut. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id445312/">https://habr.com/ru/post/id445312/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id445300/index.html">Berita Industri Permainan (11-25 Maret, 2019)</a></li>
<li><a href="../id445302/index.html">"Game of Thrones, teruskan." Apa yang ditunjukkan Apple hari ini di acara Show Time-nya</a></li>
<li><a href="../id445304/index.html">Memprogram Basis LibreOffice. Bagian 2</a></li>
<li><a href="../id445308/index.html">Fitur pengujian hipotesis untuk aplikasi seluler</a></li>
<li><a href="../id445310/index.html">Sovereign Runet naik harganya menjadi ₽30 miliar</a></li>
<li><a href="../id445314/index.html">Mengapa penambangan asteroid sulit?</a></li>
<li><a href="../id445316/index.html">DevDay Kelola TI. Rekaman Kinerja</a></li>
<li><a href="../id445318/index.html">Trap (terpal) untuk koneksi SSH yang masuk</a></li>
<li><a href="../id445320/index.html">Disk bergulung-gulung</a></li>
<li><a href="../id445322/index.html">Banyak pilihan sumber daya yang berguna untuk manajer produk</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>