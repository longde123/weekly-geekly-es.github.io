<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìì ü•´ ‚ñ´Ô∏è Wie wir bei IntelliJ IDEA nach Lambda-Ausdr√ºcken suchen üëº üë©üèæ‚Äç‚úàÔ∏è üö¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ein wichtiges Merkmal jeder IDE ist die Suche und Navigation durch den Code. Eine der h√§ufig verwendeten Java-Suchoptionen ist die Suche nach allen Im...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie wir bei IntelliJ IDEA nach Lambda-Ausdr√ºcken suchen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/JetBrains/blog/444052/"><p><img alt="Geben Sie Hierarchie in IntelliJ IDEA ein" src="https://habrastorage.org/webt/ff/js/7m/ffjs7m9ycsved2ciyrqdvb4uiwe.png" align="right" width="300">  Ein wichtiges Merkmal jeder IDE ist die Suche und Navigation durch den Code.  Eine der h√§ufig verwendeten Java-Suchoptionen ist die Suche nach allen Implementierungen dieser Schnittstelle.  Oft wird eine solche Funktion als Typhierarchie bezeichnet und sieht aus wie auf dem Bild rechts. </p><br><p>  Das Durchlaufen aller Klassen eines Projekts beim Aufrufen dieser Funktion ist ineffizient.  Sie k√∂nnen die vollst√§ndige Klassenhierarchie zur Kompilierungszeit im Index speichern, da der Compiler sie trotzdem erstellt.  Wir tun dies, wenn die Kompilierung von der IDE selbst gestartet und nicht delegiert wird, z. B. in Gradle.  Dies funktioniert jedoch nur, wenn sich nach der Kompilierung im Modul nichts ge√§ndert hat.  Im allgemeinen Fall sind Quellcodes jedoch die relevanteste Informationsquelle, und Indizes basieren auf Quellcodes. </p><br><p> Sofortige Erben zu finden ist eine einfache Aufgabe, wenn es sich nicht um eine funktionale Schnittstelle handelt.  Wenn Sie nach Implementierungen der <code>Foo</code> Schnittstelle suchen, m√ºssen Sie alle Klassen finden, in denen <code>implements Foo</code> , und Schnittstellen, in denen <code>extends Foo</code> , sowie anonyme Klassen der Form <code>new Foo(...) {...}</code> .  Dazu reicht es aus, den Syntaxbaum jeder Projektdatei im Voraus zu erstellen, die entsprechenden Konstruktionen zu finden und sie dem Index hinzuzuf√ºgen. </p><a name="habracut"></a><br><p>  Nat√ºrlich gibt es hier eine leichte Subtilit√§t: Vielleicht suchen Sie nach der Schnittstelle <code>com.example.goodcompany.Foo</code> , aber irgendwo wird tats√§chlich <code>org.example.evilcompany.Foo</code> verwendet.  Ist es m√∂glich, den vollst√§ndigen Namen der √ºbergeordneten Schnittstelle in den Index aufzunehmen?  Es gibt Schwierigkeiten damit.  Die Datei, in der die Schnittstelle verwendet wird, sieht beispielsweise folgenderma√üen aus: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// MyFoo.java import org.example.foo.*; import org.example.bar.*; import org.example.evilcompany.*; class MyFoo implements Foo {...}</span></span></code> </pre> <br><p>  Wenn wir nur die Datei betrachten, k√∂nnen wir nicht verstehen, wie der wirkliche vollst√§ndige Name <code>Foo</code> lautet.  Sie m√ºssen sich den Inhalt mehrerer Pakete ansehen.  Und jedes Paket kann an mehreren Stellen definiert werden (z. B. in mehreren JAR-Dateien).  Die Indizierung wird lange dauern, wenn wir bei der Analyse dieser Datei die vollst√§ndige Aufl√∂sung des Zeichens vornehmen m√ºssen.  Das Hauptproblem ist jedoch nicht einmal das, sondern dass der auf der Datei <code>MyFoo.java</code> erstellte Index nicht nur davon abh√§ngt, sondern auch von anderen Dateien.  Schlie√ülich k√∂nnen wir die Beschreibung der <code>Foo</code> Schnittstelle beispielsweise vom Paket <code>org.example.foo</code> in das Paket <code>org.example.bar</code> und nichts in der Datei <code>MyFoo.java</code> √§ndern, und der vollst√§ndige Name von <code>Foo</code> √§ndert sich. </p><br><p>  Indizes in IntelliJ IDEA h√§ngen nur vom Inhalt einer einzelnen Datei ab.  Dies ist zum einen sehr praktisch: Der Index f√ºr eine bestimmte Datei wird ung√ºltig, wenn sich diese Datei √§ndert.  Auf der anderen Seite bedeutet dies gro√üe Einschr√§nkungen f√ºr die Platzierung im Index.  Beispielsweise k√∂nnen die vollst√§ndigen Namen der √ºbergeordneten Klassen nicht zuverl√§ssig im Index gespeichert werden.  Aber im Prinzip ist das nicht so be√§ngstigend.  Wenn wir die Typhierarchie abfragen, k√∂nnen wir alles finden, was zum Kurznamen passt, und dann f√ºr diese Dateien eine ehrliche Aufl√∂sung des Zeichens durchf√ºhren und feststellen, ob es wirklich zu uns passt.  In den meisten F√§llen gibt es nicht zu viele zus√§tzliche Zeichen, und eine solche √úberpr√ºfung ist recht schnell. </p><br><p><img alt="Hierarchie der funktionalen Schnittstellen in IntelliJ IDEA" src="https://habrastorage.org/webt/e-/nn/0y/e-nn0ynvtojiydboaco5uiyzwms.png" align="right" width="300">  Die Situation √§ndert sich dramatisch, wenn die Klasse, deren Nachkommen wir suchen, eine funktionale Schnittstelle ist.  Zus√§tzlich zu expliziten und anonymen Erben erhalten wir dann Lambda-Ausdr√ºcke und Methodenlinks.  Was ist nun in einen Index aufzunehmen und was direkt bei der Suche zu berechnen? </p><br><p>  Angenommen, wir haben eine funktionale Schnittstelle: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@FunctionalInterface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringConsumer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">consume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String s)</span></span></span></span>; }</code> </pre> <br><p>  Der Code enth√§lt verschiedene Lambda-Ausdr√ºcke.  Zum Beispiel: </p><br><pre> <code class="java hljs">() -&gt; {} <span class="hljs-comment"><span class="hljs-comment">//   :   (a, b) -&gt; a + b //   :   s -&gt; { return list.add(s); //   :   } s -&gt; list.add(s); //   </span></span></code> </pre> <br><p>  Das hei√üt, wir k√∂nnen schnell nur diejenigen Lambdas filtern, die die falsche Anzahl von Parametern oder offensichtlich den falschen R√ºckgabetyp haben, z. B. void versus non-void.  Es ist normalerweise unm√∂glich, den R√ºckgabetyp genauer zu bestimmen.  <code>s -&gt; list.add(s)</code> , in lambda <code>s -&gt; list.add(s)</code> Sie dazu die <code>s -&gt; list.add(s)</code> aufl√∂sen und eine vollst√§ndige Inferenzprozedur <code>add</code> und m√∂glicherweise starten.  All dies ist lang und erfordert das Befestigen des Inhalts anderer Dateien. </p><br><p>  Wir haben Gl√ºck, wenn unsere funktionale Schnittstelle f√ºnf Argumente enth√§lt.  Wenn jedoch nur ein Argument erforderlich ist, hinterl√§sst ein solcher Filter eine gro√üe Anzahl zus√§tzlicher Lambdas.  Noch schlimmer mit Methodenreferenzen.  Grunds√§tzlich kann das Auftreten eines Verweises auf eine Methode in keiner Weise gesagt werden, ob sie geeignet ist oder nicht. </p><br><p>  Vielleicht sollten Sie sich im Lambda umsehen, um etwas zu verstehen?  Ja, manchmal funktioniert es.  Zum Beispiel: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//        Predicate&lt;String&gt; p = s -&gt; list.add(s); //      IntPredicate getPredicate() { return s -&gt; list.add(s); } //      SomeType fn; fn = s -&gt; list.add(s); //     foo((SomeFunctionalType)(s -&gt; list.add(s))); //     Foo[] myLambdas = {s -&gt; list.add(s), s -&gt; list.remove(s)};</span></span></code> </pre> <br><p>  In all diesen F√§llen kann der Kurzname der entsprechenden Funktionsschnittstelle aus der aktuellen Datei ermittelt und in den Index neben dem Funktionsausdruck eingef√ºgt werden, sei es ein Lambda oder eine Methodenreferenz.  Leider decken diese F√§lle in realen Projekten einen sehr kleinen Teil aller Lambdas ab.  In den allermeisten F√§llen wird Lambda als Argument f√ºr eine Methode verwendet: </p><br><pre> <code class="java hljs">list.stream() .filter(s -&gt; StringUtil.isNonEmpty(s)) .map(s -&gt; s.trim()) .forEach(s -&gt; list.add(s));</code> </pre> <br><p>  Welches dieser drei Lambdas kann vom Typ <code>StringConsumer</code> ?  Dem Programmierer ist klar, dass keine.  Da es offensichtlich ist, dass wir hier die Stream-API-Kette haben und es nur funktionale Schnittstellen aus der Standardbibliothek gibt, kann unser Typ nicht vorhanden sein. </p><br><p>  Die IDE sollte sich jedoch nicht t√§uschen lassen, sondern eine genaue Antwort geben.  Was ist, wenn <code>list</code> nicht <code>java.util.List</code> ist und <code>list.stream()</code> <code>java.util.stream.Stream</code> √ºberhaupt nicht <code>list.stream()</code> ?  Dazu m√ºssen Sie das Listensymbol aufl√∂sen, was bekanntlich nicht nur auf der Grundlage des Inhalts der aktuellen Datei zuverl√§ssig m√∂glich ist.  Und selbst wenn wir es installiert haben, sollte die Suche nicht auf die Implementierung der Standardbibliothek gerichtet sein.  Vielleicht haben wir in diesem Projekt speziell die Klasse <code>java.util.List</code> durch unsere eigene ersetzt?  Die Suche muss darauf reagieren.  Nat√ºrlich werden Lambdas nicht nur in Standardstr√∂men verwendet, es gibt auch viele andere Methoden, mit denen sie √ºbertragen werden. </p><br><p>  Als Ergebnis stellt sich heraus, dass wir den Index nach einer Liste aller Java-Dateien abfragen k√∂nnen, die Lambdas mit der erforderlichen Anzahl von Parametern und einem g√ºltigen R√ºckgabetyp verwenden (tats√§chlich verfolgen wir nur vier Optionen: void, non-void, boolean und any).  Und was dann?  Erstellen Sie f√ºr jede dieser Dateien einen vollst√§ndigen PSI-Baum (√§hnelt er einem Analysebaum, jedoch mit Zeichenaufl√∂sung, Typinferenz und anderen intelligenten Dingen) und f√ºhren Sie die Typinferenz f√ºr Lambda ehrlich aus?  Dann werden Sie in einem gro√üen Projekt nicht auf eine Liste aller Schnittstellenimplementierungen warten, selbst wenn es nur zwei davon gibt. </p><br><p>  Es stellt sich heraus, dass wir die folgenden Schritte ausf√ºhren m√ºssen: </p><br><ul><li>  Fragen Sie den Index (billig) </li><li>  Erstellen Sie ein PSI (teuer) </li><li>  Druck Lambda-Typ (sehr teuer) </li></ul><br><p>  In Java Version 8 und h√∂her ist die Typinferenz eine wahnsinnig teure Operation.  In einer komplexen Aufrufkette k√∂nnen Sie √ºber viele generische Platzhalterparameter verf√ºgen, deren Werte mithilfe des in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kapitel 18 der</a> Spezifikation beschriebenen Verfahrens ermittelt werden m√ºssen.  Dies kann im Hintergrund f√ºr die aktuell bearbeitete Datei erfolgen, dies ist jedoch f√ºr Tausende unge√∂ffneter Dateien schwierig. </p><br><p>  Hier k√∂nnen Sie jedoch die Ecke etwas k√ºrzen: In den meisten F√§llen ben√∂tigen wir den endg√ºltigen Typ nicht.  Wenn nur Lambda nicht an eine Methode √ºbergeben wird, die an dieser Stelle einen generischen Parameter verwendet, k√∂nnen wir den letzten Schritt der Parametersubstitution entfernen.  Angenommen, wir haben den Lambda-Typ <code>java.util.function.Function&lt;T, R&gt;</code> , k√∂nnen wir die Werte der Substitutionsparameter <code>T</code> und <code>R</code> nicht berechnen: und es ist klar, ob wir ihn zum Suchergebnis zur√ºckgeben sollen oder nicht.  Obwohl dies beim Aufrufen einer Methode wie dieser nicht funktioniert: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSmth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Class&lt;T&gt; aClass, T value)</span></span></span><span class="hljs-function"> </span></span>{}</code> </pre> <br><p>  Diese Methode kann folgenderma√üen aufgerufen werden: <code>doSmth(Runnable.class, () -&gt; {})</code> .  Dann wird der Lambda-Typ als <code>T</code> angezeigt, und Sie m√ºssen ihn trotzdem ersetzen.  Dies ist jedoch ein seltener Fall.  Daher stellt sich heraus, zu sparen, aber nicht mehr als 10%.  Das Problem ist nicht grundlegend gel√∂st. </p><br><p>  Eine andere Idee: Wenn die genaue Typinferenz komplex ist, lassen Sie uns eine ungef√§hre Schlussfolgerung ziehen.  Lassen Sie es nur f√ºr gel√∂schte Klassentypen funktionieren und reduzieren Sie nicht die Einschr√§nkungen, wie in der Spezifikation angegeben, sondern folgen Sie einfach der Aufrufkette.  Solange der gel√∂schte Typ keine generischen Parameter enth√§lt, ist alles in Ordnung.  Nehmen Sie zum Beispiel den Stream aus dem obigen Beispiel und stellen Sie fest, ob das letzte Lambda unseren <code>StringConsumer</code> implementiert: </p><br><ul><li>  Listenvariable -&gt; Typ <code>java.util.List</code> </li><li>  <code>List.stream()</code> -Methode - <code>List.stream()</code> Typ <code>java.util.stream.Stream</code> </li><li>  <code>Stream.filter(...)</code> -Methode ‚Üí <code>Stream.filter(...)</code> <code>java.util.stream.Stream</code> . Wir sehen uns nicht einmal die <code>filter</code> . Was ist der Unterschied <code>Stream.filter(...)</code> </li><li>  <code>Stream.map(...)</code> -Methode - <code>Stream.map(...)</code> <code>java.util.stream.Stream</code> Typ, √§hnlich </li><li>  Die <code>Stream.forEach(...)</code> -Methode ‚Üí es gibt eine solche Methode, deren Parameter vom <code>Consumer</code> Typ ist, der offensichtlich nicht <code>StringConsumer</code> . </li></ul><br><p>  Nun, sie haben auf eine vollst√§ndige Typinferenz verzichtet.  Mit einem so einfachen Ansatz ist es jedoch leicht, auf √ºberladene Methoden zu sto√üen.  Wenn wir die Typinferenz nicht vollst√§ndig starten, k√∂nnen Sie nicht die richtige √ºberladene Version ausw√§hlen.  Obwohl dies nicht der Fall ist, ist es manchmal m√∂glich, wenn sich die Anzahl der Methodenparameter unterscheidet.  Zum Beispiel: </p><br><pre> <code class="java hljs">CompletableFuture.supplyAsync(Foo::bar, myExecutor).thenRunAsync(s -&gt; list.add(s));</code> </pre> <br><p>  Hier k√∂nnen wir das leicht verstehen </p><br><ul><li>  Es gibt zwei <code>CompletableFuture.supplyAsync</code> Methoden, aber eine verwendet ein Argument und die zweite zwei. W√§hlen Sie also diejenige aus, die zwei verwendet.  Es wird eine <code>CompletableFuture</code> . </li><li>  <code>thenRunAsync</code> Methoden <code>thenRunAsync</code> ebenfalls zwei, und aus ihnen k√∂nnen Sie auf √§hnliche Weise diejenige ausw√§hlen, die ein Argument <code>thenRunAsync</code> .  Der entsprechende Parameter ist vom Typ <code>Runnable</code> , <code>Runnable</code> es handelt sich nicht um <code>StringConsumer</code> . </li></ul><br><p>  Wenn mehrere Methoden dieselbe Anzahl von Parametern akzeptieren oder einige eine variable Anzahl von Parametern haben und auch geeignet aussehen, m√ºssen Sie alle Optionen im Auge behalten.  Aber oft ist das auch nicht be√§ngstigend.  Zum Beispiel: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder().append(foo).append(bar).chars().forEach(s -&gt; list.add(s));</code> </pre> <br><ul><li>  <code>new StringBuilder()</code> erstellt offensichtlich <code>java.lang.StringBuilder</code> .  F√ºr Designer erlauben wir den Link weiterhin, aber eine komplexe Typinferenz ist hier nicht erforderlich.  Selbst wenn es <code>new Foo&lt;&gt;(x, y, z)</code> g√§be, zeigen wir nicht die Werte typischer Parameter an, wir interessieren uns nur f√ºr <code>Foo</code> . </li><li>  Es gibt <code>StringBuilder.append</code> Methoden, die ein Argument annehmen, aber alle geben den Typ <code>java.lang.StringBuilder</code> , sodass es keine Rolle spielt, welcher Typ <code>foo</code> und <code>bar</code> . </li><li>  Die <code>StringBuilder.chars</code> Methode <code>StringBuilder.chars</code> eine und gibt <code>java.util.stream.IntStream</code> . </li><li>  Die <code>IntStream.forEach</code> Methode <code>IntStream.forEach</code> eine und akzeptiert den <code>IntConsumer</code> Typ. </li></ul><br><p>  Auch wenn mehrere Optionen irgendwo verbleiben, k√∂nnen Sie sie alle verfolgen.  Beispielsweise kann der an <code>ForkJoinPool.getInstance().submit(...)</code> Lambda-Typ <code>ForkJoinPool.getInstance().submit(...)</code> <code>Runnable</code> oder <code>Callable</code> . Wenn wir jedoch nach etwas Drittem suchen, k√∂nnen wir dieses Lambda trotzdem verwerfen. </p><br><p>  Eine unangenehme Situation tritt auf, wenn eine Methode einen generischen Parameter zur√ºckgibt.  Dann bricht die Prozedur zusammen und Sie m√ºssen eine vollst√§ndige Typinferenz ausf√ºhren.  Wir haben jedoch einen Fall unterst√ºtzt.  Es wird gut in meiner StreamEx-Bibliothek angezeigt, die eine abstrakte Klasse hat. <code>AbstractStreamEx&lt;T, S extends AbstractStreamEx&lt;T, S&gt;&gt;</code> enth√§lt Methoden wie <code>S filter(Predicate&lt;? super T&gt; predicate)</code> .  Normalerweise arbeiten Leute mit einer bestimmten Klasse. <code>StreamEx&lt;T&gt; extends AbstractStreamEx&lt;T, StreamEx&lt;T&gt;&gt;</code> .  In diesem Fall k√∂nnen Sie die Ersetzung des Typparameters durchf√ºhren und feststellen, dass <code>S = StreamEx</code> . </p><br><p>  Nun, in vielen F√§llen haben wir eine sehr teure Typinferenz beseitigt.  Aber wir haben nichts mit dem Aufbau des PSI gemacht.  Es ist eine Schande, eine Datei in f√ºnfhundert Zeilen zu analysieren, um herauszufinden, dass das Lambda in Zeile 480 nicht zu unserer Abfrage passt.  Kommen wir zur√ºck zu unserem Stream: </p><br><pre> <code class="java hljs">list.stream() .filter(s -&gt; StringUtil.isNonEmpty(s)) .map(s -&gt; s.trim()) .forEach(s -&gt; list.add(s));</code> </pre> <br><p>  Wenn <code>list</code> eine lokale Variable, ein Methodenparameter oder ein Feld in der aktuellen Klasse ist, k√∂nnen wir bereits in der Indizierungsphase die Deklaration finden und feststellen, dass der Kurzname des Typs lautet <br>  <code>List</code>  Dementsprechend k√∂nnen wir im Index f√ºr das letzte Lambda die folgenden Informationen einf√ºgen: </p><br><blockquote>  Der Typ dieses Lambdas ist der Parametertyp der <code>forEach</code> Methode aus einem Argument, der auf das Ergebnis der <code>map</code> Methode aus einem Argument aufgerufen wird, auf das Ergebnis der <code>filter</code> aus einem Argument aufgerufen wird, auf das Ergebnis der <code>stream</code> Methode aus Null-Argumenten aufgerufen wird und auf ein Objekt vom Typ <code>List</code> aufgerufen wird. </blockquote><p>  Alle diese Informationen sind in der aktuellen Datei verf√ºgbar, dh sie k√∂nnen in den Index aufgenommen werden.  W√§hrend der Suche fragen wir den Index nach solchen Informationen √ºber alle Lambdas und versuchen, den Lambda-Typ wiederherzustellen, ohne einen PSI zu erstellen.  Zuerst m√ºssen Sie eine globale Suche nach Klassen mit dem Kurznamen <code>List</code> .  Nat√ºrlich finden wir nicht nur <code>java.util.List</code> , sondern auch <code>java.awt.List</code> oder etwas aus dem Code des Benutzerprojekts.  Ferner werden wir alle diese Klassen dem gleichen Verfahren der ungenauen Typaufl√∂sung unterwerfen, das wir zuvor verwendet haben.  Oft werden zus√§tzliche Klassen selbst schnell herausgefiltert.  In <code>java.awt.List</code> gibt es beispielsweise keine <code>stream</code> Methode, daher wird sie weiter ausgeschlossen.  Aber selbst wenn bis zum Ende etwas √úberfl√ºssiges bei uns ist und wir mehrere Kandidaten f√ºr den Typ unseres Lambda finden, besteht eine gute Chance, dass sie nicht alle in die Suchanfrage passen, und wir werden dennoch vermeiden, ein vollst√§ndiges PSI zu erstellen. </p><br><p>  Es ist m√∂glich, dass die globale Suche zu teuer ist (es gibt viele Listenklassen im Projekt). Entweder ist der Beginn der Kette im Kontext einer einzelnen Datei nicht zul√§ssig (z. B. ist dies das Feld der √ºbergeordneten Klasse), oder die Kette wird irgendwo unterbrochen, weil die Methode einen generischen Parameter zur√ºckgibt.  Dann geben wir nicht sofort auf und versuchen erneut, mit einer globalen Suche nach der n√§chsten Verkettungsmethode zu beginnen.  F√ºr die <code>map.get(key).updateAndGet(a -&gt; a * 2)</code> wurde beispielsweise die folgende Anweisung in den Index aufgenommen: </p><br><blockquote>  Der Lambda-Typ ist der Typ des einzigen Parameters der <code>updateAndGet</code> Methode, der f√ºr das Ergebnis der <code>get</code> Methode mit einem Parameter aufgerufen wird, der f√ºr das Objekt vom Typ <code>Map</code> aufgerufen wird. </blockquote><p>  Lassen Sie uns Gl√ºck haben und im Projekt gibt es nur einen <code>Map</code> - <code>java.util.Map</code> .  Es hat zwar eine <code>get(Object)</code> -Methode, gibt aber leider den generischen Parameter <code>V</code>  Dann lassen wir die Kette fallen und suchen global nach der <code>updateAndGet</code> Methode mit einem Parameter (nat√ºrlich unter Verwendung des Index).  <code>AtomicInteger</code> gibt es im Projekt nur drei solcher Methoden in den <code>AtomicReference</code> <code>AtomicInteger</code> , <code>AtomicLong</code> und <code>AtomicReference</code> mit Parametern vom Typ <code>IntUnaryOperator</code> , <code>LongUnaryOperator</code> bzw. <code>UnaryOperator</code> .  Wenn wir nach einem anderen Typ suchen, haben wir festgestellt, dass dieses Lambda nicht passt und PSI nicht gebaut werden kann. </p><br><p>  √úberraschenderweise ist dies ein anschauliches Beispiel f√ºr ein Merkmal, das im Laufe der Zeit selbst langsamer zu arbeiten beginnt.  Sie suchen beispielsweise nach der Implementierung einer funktionalen Schnittstelle, es gibt nur drei davon im Projekt, und IntelliJ IDEA sucht zehn Sekunden lang nach ihnen.  Und Sie erinnern sich sehr gut daran, dass es vor drei Jahren auch drei von ihnen gab, Sie haben auch nach ihnen gesucht, aber dann gab die Umgebung innerhalb von zwei Sekunden auf derselben Maschine eine Antwort.  Und Ihr Projekt ist zwar riesig, aber in drei Jahren gewachsen, vielleicht um f√ºnf Prozent.  Nat√ºrlich √§rgern Sie sich zu Recht dar√ºber, was diese Entwickler vermasselt haben, dass die IDE so schrecklich langsamer wurde.  H√§nde, um diese ungl√ºcklichen Programmierer abzurei√üen. </p><br><p>  Und vielleicht haben wir √ºberhaupt nichts ge√§ndert.  Vielleicht funktioniert die Suche genauso wie vor drei Jahren.  Noch vor drei Jahren sind Sie auf Java 8 umgestiegen und hatten beispielsweise hundert Lambdas in Ihrem Projekt.  Und jetzt haben Ihre Kollegen anonyme Klassen in Lambdas verwandelt, Streams aktiv genutzt oder eine Art reaktive Bibliothek verbunden. Aufgrund von Lambdas wurden es nicht einhundert, sondern zehntausend.  Und jetzt muss die IDE hundertmal mehr durchsucht werden, um die drei notwendigen Lambdas auszugraben. </p><br><p>  Ich sagte "vielleicht", weil wir nat√ºrlich von Zeit zu Zeit auf diese Suche zur√ºckkommen und versuchen, sie zu beschleunigen.  Aber hier muss man nicht einmal gegen den Bach rudern, sondern den Wasserfall hinauf.  Wir versuchen es, aber die Anzahl der Lambdas in Projekten w√§chst sehr schnell. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de444052/">https://habr.com/ru/post/de444052/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de444038/index.html">Erfahrung mit der Verwendung von "Koordinatoren" in einem echten "iOS" -Projekt</a></li>
<li><a href="../de444040/index.html">Autozentrisches Ranking. Yandex-Bericht √ºber die Suche nach relevanten Zielgruppen f√ºr Zen-Autoren</a></li>
<li><a href="../de444044/index.html">Europa wird Eisen aus Rechenzentren recyceln</a></li>
<li><a href="../de444048/index.html">Tipps und Tricks zur digitalen Forensik: Erkennen von √Ñnderungen durch Gruppenrichtlinien, die von Eindringlingen verursacht werden</a></li>
<li><a href="../de444050/index.html">Diskussion: Wird die DNA-Speicherung massiv?</a></li>
<li><a href="../de444056/index.html">Internetprovider auf der Krim haben die Preise f√ºr Dienstleistungen stark erh√∂ht</a></li>
<li><a href="../de444058/index.html">Wenn Kinder verstehen, dass ihr ganzes Leben bereits online ist</a></li>
<li><a href="../de444060/index.html">Migration von Nagios zu Icinga2 in Australien</a></li>
<li><a href="../de444062/index.html">Licht auf! Nachttransformationen des Lakhta Centers</a></li>
<li><a href="../de444064/index.html">Neue Ideen f√ºr eine neue Zukunft</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>