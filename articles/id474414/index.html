<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👍🏿 ℹ️ 💩 Kami menulis mesin voxel kami sendiri 🥒 👌🏽 🌵</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Catatan: kode sumber lengkap untuk proyek ini tersedia di sini: [ sumber ]. 

 Ketika proyek yang saya kerjakan mulai kehabisan tenaga, saya menambahk...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami menulis mesin voxel kami sendiri</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474414/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a53/e5f/dea/a53e5fdeab8992f2b647feb66ccf126b.png" alt="gambar"></div><br>  <em><strong>Catatan:</strong> kode sumber lengkap untuk proyek ini tersedia di sini: [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sumber</a> ].</em> <br><br>  Ketika proyek yang saya kerjakan mulai kehabisan tenaga, saya menambahkan visualisasi baru yang memberi saya motivasi untuk melanjutkan. <br><br>  Setelah merilis konsep <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Task-Bot asli</a> [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terjemahan</a> ke Habré], saya merasa bahwa saya dibatasi oleh ruang dua dimensi tempat saya bekerja.  Tampaknya itu menahan kemungkinan untuk perilaku bot yang muncul. <br><br>  Upaya sebelumnya yang gagal untuk mempelajari OpenGL modern telah menempatkan saya di hadapan saya penghalang mental, tetapi pada akhir Juli saya akhirnya berhasil menerobosnya.  Hari ini, pada akhir Oktober, saya sudah memiliki pemahaman konsep yang cukup percaya diri, jadi saya merilis mesin voxel sederhana saya sendiri, yang akan menjadi lingkungan untuk kehidupan dan kemakmuran Bot-Tugas saya. <br><br>  Saya memutuskan untuk membuat mesin sendiri, karena saya memerlukan kontrol penuh atas grafis;  selain itu, saya ingin menguji diri saya sendiri.  Di satu sisi, saya menciptakan sepeda, tetapi saya sangat menyukai proses ini! <br><br>  Tujuan akhir dari seluruh proyek adalah simulasi lengkap ekosistem, di mana bot dalam peran agen memanipulasi lingkungan dan berinteraksi dengannya. <br><br>  Karena mesin sudah bergerak maju sedikit dan saya akan pindah ke pemrograman bot lagi, saya memutuskan untuk menulis posting tentang mesin, fungsinya dan implementasinya untuk fokus pada tugas-tugas tingkat yang lebih tinggi di masa depan. <br><a name="habracut"></a><br><h2>  Konsep mesin </h2><br>  Mesin sepenuhnya ditulis dari awal dalam C ++ (dengan beberapa pengecualian, seperti menemukan jalan).  Saya menggunakan SDL2 untuk membuat konteks dan memproses input, OpenGL untuk membuat adegan 3D, dan DearImgui untuk mengontrol simulasi. <br><br>  Saya memutuskan untuk menggunakan voxel terutama karena saya ingin bekerja dengan kisi yang memiliki banyak keuntungan: <br><br><ul><li>  Membuat jaring untuk rendering dipahami dengan baik bagi saya. </li><li>  Kemampuan penyimpanan data dunia lebih beragam dan mudah dipahami. </li><li>  Saya telah membuat sistem untuk menghasilkan simulasi medan dan iklim berdasarkan jerat. </li><li>  Tugas bot di grid lebih mudah untuk parameter. </li></ul><br>  Engine terdiri dari sistem data dunia, sistem render, dan beberapa kelas bantu (misalnya, untuk pemrosesan suara dan input). <br><br>  Dalam artikel ini saya akan berbicara tentang daftar fitur saat ini, serta melihat lebih dekat pada subsistem yang lebih kompleks. <br><br><h3>  Kelas dunia </h3><br>  Kelas dunia berfungsi sebagai kelas dasar untuk menyimpan semua informasi dunia.  Ini menangani pembuatan, pemuatan, dan penyimpanan data blok. <br><br>  Data blok disimpan dalam potongan ukuran konstan (16 ^ 3), dan dunia menyimpan vektor fragmen yang dimuat ke dalam memori virtual.  Dalam dunia besar, praktis perlu mengingat hanya bagian tertentu dari dunia, itulah sebabnya saya memilih pendekatan ini. <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">World</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: World(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> _saveFile){ saveFile = _saveFile; loadWorld(); } <span class="hljs-comment"><span class="hljs-comment">//Data Storage std::vector&lt;Chunk&gt; chunks; //Loaded Chunks std::stack&lt;int&gt; updateModels; //Models to be re-meshed void bufferChunks(View view); //Generation void generate(); Blueprint blueprint; bool evaluateBlueprint(Blueprint &amp;_blueprint); //File IO Management std::string saveFile; bool loadWorld(); bool saveWorld(); //other... int SEED = 100; int chunkSize = 16; int tickLength = 1; glm::vec3 dim = glm::vec3(20, 5, 20); //...</span></span></code> </pre> <br>  Fragmen menyimpan data blok, serta beberapa metadata lainnya, dalam susunan datar.  Awalnya, saya menerapkan pohon oktri saya sendiri untuk menyimpan fragmen, tetapi ternyata waktu akses acak terlalu tinggi untuk membuat jerat.  Dan meskipun susunan flat tidak optimal dari sudut pandang memori, ia menyediakan kemampuan untuk membangun jerat dan manipulasi dengan blok dengan cepat, serta akses ke jalur pencarian. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Chunk</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//Position information and size information glm::vec3 pos; int size; BiomeType biome; //Data Storage Member int data[16*16*16] = {0}; bool refreshModel = false; //Get the Flat-Array Index int getIndex(glm::vec3 _p); void setPosition(glm::vec3 _p, BlockType _type); BlockType getPosition(glm::vec3 _p); glm::vec4 getColorByID(BlockType _type); };</span></span></code> </pre> <br>  Jika saya pernah menerapkan fragmen penyimpanan dan pemuatan multi-utas, maka mengonversi susunan datar menjadi pohon octree yang jarang dan sebaliknya dapat menjadi opsi yang sepenuhnya memungkinkan untuk menghemat memori.  Masih ada ruang untuk optimasi! <br><br>  Implementasi saya dari pohon octree jarang disimpan dalam kode, sehingga Anda dapat menggunakannya dengan aman. <br><br><h4>  Penyimpanan fragmen dan penanganan memori </h4><br>  Fragmen hanya terlihat ketika mereka berada dalam jarak rendering dari posisi kamera saat ini.  Ini berarti bahwa ketika kamera bergerak, Anda harus secara dinamis memuat dan menyusun fragmen di jerat. <br><br>  Fragmen diserialisasi dengan menggunakan boost library, dan data dunia disimpan sebagai file teks sederhana, di mana setiap fragmen adalah satu baris file.  Mereka dihasilkan dalam urutan tertentu sehingga mereka dapat "dipesan" dalam file dunia.  Ini penting untuk optimasi lebih lanjut. <br><br>  Dalam kasus dunia yang besar, hambatan utama adalah membaca file dunia dan memuat / menulis fragmen.  Idealnya, kita hanya perlu mengunduh dan mentransfer file dunia. <br><br>  Untuk melakukan ini, metode <code>World::bufferChunks()</code> menghapus fragmen yang ada di memori virtual tetapi tidak terlihat, dan secara cerdas memuat fragmen baru dari file dunia. <br><br>  Dengan kecerdasan berarti bahwa ia hanya memutuskan fragmen baru mana yang akan dimuat, menyortirnya berdasarkan posisi mereka di file save, dan kemudian melakukan satu pass.  Semuanya sangat sederhana. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> World::bufferChunks(View view){ <span class="hljs-comment"><span class="hljs-comment">//Load / Reload all Visible Chunks evaluateBlueprint(blueprint); //Chunks that should be loaded glm::vec3 a = glm::floor(view.viewPos/glm::vec3(chunkSize))-view.renderDistance; glm::vec3 b = glm::floor(view.viewPos/glm::vec3(chunkSize))+view.renderDistance; //Can't exceed a certain size a = glm::clamp(a, glm::vec3(0), dim-glm::vec3(1)); b = glm::clamp(b, glm::vec3(0), dim-glm::vec3(1)); //Chunks that need to be removed / loaded std::stack&lt;int&gt; remove; std::vector&lt;glm::vec3&gt; load; //Construct the Vector of chunks we should load for(int i = ax; i &lt;= bx; i ++){ for(int j = ay; j &lt;= by; j ++){ for(int k = az; k &lt;= bz; k ++){ //Add the vector that we should be loading load.push_back(glm::vec3(i, j, k)); } } } //Loop over all existing chunks for(unsigned int i = 0; i &lt; chunks.size(); i++){ //Check if any of these chunks are outside of the limits if(glm::any(glm::lessThan(chunks[i].pos, a)) || glm::any(glm::greaterThan(chunks[i].pos, b))){ //Add the chunk to the erase pile remove.push(i); } //Don't reload chunks that remain for(unsigned int j = 0; j &lt; load.size(); j++){ if(glm::all(glm::equal(load[j], chunks[i].pos))){ //Remove the element from load load.erase(load.begin()+j); } } //Flags for the Viewclass to use later updateModels = remove; //Loop over the erase pile, delete the relevant chunks. while(!remove.empty()){ chunks.erase(chunks.begin()+remove.top()); remove.pop(); } //Check if we want to load any guys if(!load.empty()){ //Sort the loading vector, for single file-pass std::sort(load.begin(), load.end(), [](const glm::vec3&amp; a, const glm::vec3&amp; b) { if(ax &gt; bx) return true; if(ax &lt; bx) return false; if(ay &gt; by) return true; if(ay &lt; by) return false; if(az &gt; bz) return true; if(az &lt; bz) return false; return false; }); boost::filesystem::path data_dir( boost::filesystem::current_path() ); data_dir /= "save"; data_dir /= saveFile; std::ifstream in((data_dir/"world.region").string()); Chunk _chunk; int n = 0; while(!load.empty()){ //Skip Lines (this is dumb) while(n &lt; load.back().x*dim.z*dim.y+load.back().y*dim.z+load.back().z){ in.ignore(1000000,'\n'); n++; } //Load the Chunk { boost::archive::text_iarchive ia(in); ia &gt;&gt; _chunk; chunks.push_back(_chunk); load.pop_back(); } } in.close(); } }</span></span></code> </pre> <br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Browser Anda tidak mendukung video HTML5. <source src="http://weigert.vsos.ethz.ch/wp-content/uploads/2019/10/chunkload.mp4" type="video/mp4"></video></div></div></div><br>  <i>Contoh memuat fragmen dengan jarak rendering kecil.</i>  <i>Artefak distorsi layar disebabkan oleh perangkat lunak perekaman video.</i>  <i>Terkadang terjadi lonjakan unduhan, terutama disebabkan oleh penyambungan</i> <br><br>  Selain itu, saya menetapkan bendera yang menunjukkan bahwa renderer harus membuat ulang jala dari fragmen yang dimuat. <br><br><h4>  Kelas Cetak Biru dan editBuffer </h4><br>  editBuffer adalah wadah bufferObjects yang dapat diurutkan yang berisi informasi tentang pengeditan di ruang dunia dan ruang fragmen. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//EditBuffer Object Struct struct bufferObject { glm::vec3 pos; glm::vec3 cpos; BlockType type; }; //Edit Buffer! std::vector&lt;bufferObject&gt; editBuffer;</span></span></code> </pre> <br>  Jika, ketika membuat perubahan ke dunia, menuliskannya ke file segera setelah melakukan perubahan, maka kita harus mentransfer seluruh file teks dan menulis SETIAP perubahan.  Ini mengerikan dalam hal kinerja. <br><br>  Jadi pertama-tama saya menulis semua perubahan yang perlu dilakukan untuk mengeditBuffer menggunakan metode addEditBuffer (yang juga menghitung posisi perubahan dalam ruang fragmen).  Sebelum menulis mereka ke file, saya mengurutkan perubahan dalam urutan fragmen yang menjadi milik mereka sesuai dengan lokasi mereka di file. <br><br>  Menulis perubahan pada file terdiri dari satu transfer file, memuat setiap baris (mis. Fragmen), yang untuknya ada perubahan di editBuffer, membuat semua perubahan dan menulisnya ke file sementara hingga editBuffer menjadi kosong.  Ini dilakukan dalam fungsi <code>evaluateBlueprint()</code> , yang cukup cepat. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> World::evaluateBlueprint(Blueprint &amp;_blueprint){ <span class="hljs-comment"><span class="hljs-comment">//Check if the editBuffer isn't empty! if(_blueprint.editBuffer.empty()){ return false; } //Sort the editBuffer std::sort(_blueprint.editBuffer.begin(), _blueprint.editBuffer.end(), std::greater&lt;bufferObject&gt;()); //Open the File boost::filesystem::path data_dir(boost::filesystem::current_path()); data_dir /= "save"; data_dir /= saveFile; //Load File and Write File std::ifstream in((data_dir/"world.region").string()); std::ofstream out((data_dir/"world.region.temp").string(), std::ofstream::app); //Chunk for Saving Data Chunk _chunk; int n_chunks = 0; //Loop over the Guy while(n_chunks &lt; dim.x*dim.y*dim.z){ if(in.eof()){ return false; } //Archive Serializers boost::archive::text_oarchive oa(out); boost::archive::text_iarchive ia(in); //Load the Chunk ia &gt;&gt; _chunk; //Overwrite relevant portions while(!_blueprint.editBuffer.empty() &amp;&amp; glm::all(glm::equal(_chunk.pos, _blueprint.editBuffer.back().cpos))){ //Change the Guy _chunk.setPosition(glm::mod(_blueprint.editBuffer.back().pos, glm::vec3(chunkSize)), _blueprint.editBuffer.back().type); _blueprint.editBuffer.pop_back(); } //Write the chunk back oa &lt;&lt; _chunk; n_chunks++; } //Close the fstream and ifstream in.close(); out.close(); //Delete the first file, rename the temp file boost::filesystem::remove_all((data_dir/"world.region").string()); boost::filesystem::rename((data_dir/"world.region.temp").string(),(data_dir/"world.region").string()); //Success! return true; }</span></span></code> </pre> <br>  Kelas cetak biru berisi editBuffer, serta beberapa metode yang memungkinkan Anda membuat editBuffers untuk objek tertentu (pohon, kaktus, gubuk, dll.).  Kemudian cetak biru dapat dikonversi ke posisi di mana Anda ingin meletakkan objek, dan kemudian hanya menulisnya ke memori dunia. <br><br>  Salah satu kesulitan terbesar ketika bekerja dengan fragmen adalah bahwa perubahan dalam beberapa blok antara batas fragmen dapat berubah menjadi proses yang monoton dengan banyak modulo aritmatika dan membagi perubahan menjadi beberapa bagian.  Ini adalah masalah utama yang ditangani oleh kelas cetak biru dengan cemerlang. <br><br>  Saya secara aktif menggunakannya pada tahap generasi dunia untuk memperluas "bottleneck" dari menulis perubahan ke file. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> World::generate(){ <span class="hljs-comment"><span class="hljs-comment">//Create an editBuffer that contains a flat surface! blueprint.flatSurface(dim.x*chunkSize, dim.z*chunkSize); //Write the current blueprint to the world file. evaluateBlueprint(blueprint); //Add a tree Blueprint _tree; evaluateBlueprint(_tree.translate(glm::vec3(x, y, z))); }</span></span></code> </pre> <br>  Kelas dunia menyimpan cetak biru perubahan yang dibuat untuk dunia, sehingga ketika bufferChunks () dipanggil, semua perubahan ditulis ke hard disk dalam satu pass dan kemudian dihapus dari memori virtual. <br><br><h3>  Rendering </h3><br>  Penyaji dalam strukturnya tidak terlalu rumit, tetapi membutuhkan pengetahuan tentang OpenGL untuk memahaminya.  Tidak semua bagiannya menarik, terutama pembungkus fungsionalitas OpenGL.  Saya bereksperimen dengan visualisasi selama beberapa waktu untuk mendapatkan apa yang saya sukai. <br><br>  Karena simulasi bukan dari orang pertama, saya memilih proyeksi ortografi.  Ini dapat diimplementasikan dalam format pseudo-3D (mis., Untuk memproyeksikan petak-petak dan menatanya dalam renderer perangkat lunak), tetapi tampaknya konyol bagi saya.  Saya senang saya beralih menggunakan OpenGL. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/61e/923/40e/61e92340e2801dc8f6dd63b54badc438.png"></div><br>  Kelas dasar untuk rendering disebut View, berisi sebagian besar variabel penting yang mengontrol visualisasi simulasi: <br><br><ul><li>  Ukuran layar dan tekstur bayangan </li><li>  Objek shader, kamera, matriks, dll. Faktor zoom </li><li>  Nilai Boolean untuk hampir semua fungsi penyaji <ul><li>  Menu, kabut, kedalaman bidang, tekstur butir, dll. </li></ul></li><li>  Warna untuk penerangan, kabut, langit, pemilihan jendela, dll. </li></ul><br>  Selain itu, ada beberapa kelas pembantu yang melakukan rendering dan pembungkus OpenGL sendiri! <br><br><ul><li>  Shader kelas <ul><li>  Memuat, mengkompilasi, mengkompilasi dan menggunakan shader GLSL </li></ul></li><li>  Kelas Model <ul><li>  Berisi fragmen data VAO (Vertex Arrays Object) untuk rendering, fungsi membuat jerat dan metode render. </li></ul></li><li>  Papan iklan kelas <ul><li>  Berisi FBO (FrameBuffer Object) untuk di-render - berguna untuk membuat efek post-processing dan shadowing. </li></ul></li><li>  Kelas sprite <ul><li>  Menarik relatif berorientasi segi empat ke kamera, diambil dari file tekstur (untuk bot dan objek).  Juga dapat menangani animasi! </li></ul></li><li>  Kelas antarmuka <ul><li>  Untuk bekerja dengan ImGUI </li></ul></li><li>  Kelas audio <ul><li>  Dukungan suara yang sangat sederhana (jika Anda mengkompilasi mesin, tekan "M") </li></ul></li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e5/0f3/ef6/6e50f3ef66d7d71dd5ae76b94b3c168a.png"></div><br>  <i>Kedalaman Tinggi Bidang (DOF).</i>  <i>Pada jarak rendering yang besar, ini bisa lambat, tapi saya melakukan semua ini di laptop saya.</i>  <i>Mungkin di komputer yang bagus remnya tidak akan terlihat.</i>  <i>Saya mengerti bahwa itu menegangkan mata saya dan melakukannya hanya untuk bersenang-senang.</i> <br><br>  Gambar di atas menunjukkan beberapa parameter yang dapat diubah selama manipulasi.  Saya juga menerapkan peralihan ke mode layar penuh.  Gambar menunjukkan contoh bot sprite yang diberikan sebagai segiempat bertekstur yang diarahkan ke kamera.  Rumah dan kaktus dalam gambar dibangun menggunakan cetak biru. <br><br><h4>  Membuat Jejaring Fragmen </h4><br>  Awalnya, saya menggunakan versi naif untuk membuat jerat: Saya hanya membuat kubus dan membuang simpul yang tidak menyentuh ruang kosong.  Namun, solusi ini lambat, dan ketika memuat fragmen baru, pembuatan jerat ternyata menjadi “bottleneck” yang lebih sempit daripada akses ke file. <br><br>  Masalah utamanya adalah pembuatan fragmen VBO yang diberikan secara efisien, tetapi saya berhasil mengimplementasikan C ++ versi saya sendiri “greedy meshing” (greedy meshing), kompatibel dengan OpenGL (tanpa struktur aneh dengan loop).  Anda dapat menggunakan kode saya dengan hati nurani yang bersih. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Model::fromChunkGreedy(Chunk chunk){ <span class="hljs-comment"><span class="hljs-comment">//... (this is part of the model class - find on github!) }</span></span></code> </pre> <br>  Secara umum, transisi ke meshing serakah mengurangi jumlah segi empat yang ditarik rata-rata 60%.  Kemudian, setelah optimasi minor lebih lanjut (pengindeksan VBO), jumlahnya dikurangi dengan 1/3 lainnya (dari 6 simpul ke ujung menjadi 4 simpul). <br><br>  Saat merender adegan 5x1x5 dalam jendela yang tidak dimaksimalkan, saya mendapatkan rata-rata sekitar 140 FPS (dengan VSYNC dinonaktifkan). <br><br>  Meskipun saya cukup senang dengan hasil ini, saya masih ingin datang dengan sistem untuk rendering model non-kubik dari data dunia.  Tidak mudah untuk diintegrasikan dengan ketamakan rakus, jadi patut dipertimbangkan. <br><br><h4>  Shader dan penyorotan voxel </h4><br>  Implementasi GLSL shaders adalah salah satu yang paling menarik dan pada saat yang sama bagian yang paling mengganggu dari penulisan mesin karena kompleksitas debugging pada GPU.  Saya bukan spesialis GLSL, jadi saya harus belajar banyak saat bepergian. <br><br>  Efek yang saya terapkan secara aktif menggunakan FBO dan sampling tekstur (misalnya, kabur, membayangi, dan menggunakan informasi mendalam). <br><br>  Saya masih tidak suka model pencahayaan saat ini, karena tidak menangani "gelap" dengan baik.  Saya berharap ini akan diperbaiki di masa depan ketika saya bekerja pada siklus perubahan siang dan malam. <br><br>  Saya juga menerapkan fungsi pemilihan voxel sederhana menggunakan algoritma Bresenham yang dimodifikasi (ini adalah keuntungan lain dari menggunakan voxels).  Berguna untuk mendapatkan informasi spasial selama simulasi.  Implementasi saya hanya berfungsi untuk proyeksi ortografis, tetapi Anda dapat menggunakannya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c60/020/f2c/c60020f2cd1b4507152fdee4ef16e0ea.png"></div><br>  <i>Labu "disorot".</i> <br><br><h3>  Kelas game </h3><br>  Beberapa kelas tambahan telah dibuat untuk memproses input, men-debug pesan, serta kelas Item terpisah dengan fungsionalitas dasar (yang akan diperluas lebih lanjut). <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">eventHandler</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-comment"><span class="hljs-comment">/* This class handles user input, creates an appropriate stack of activated events and handles them so that user inputs have continuous effect. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//Queued Inputs std::deque&lt;SDL_Event*&gt; inputs; //General Key Inputs std::deque&lt;SDL_Event*&gt; scroll; //General Key Inputs std::deque&lt;SDL_Event*&gt; rotate; //Rotate Key Inputs SDL_Event* mouse; //Whatever the mouse is doing at a moment SDL_Event* windowevent; //Whatever the mouse is doing at a moment bool _window; bool move = false; bool click = false; bool fullscreen = false; //Take inputs and add them to stack void input(SDL_Event *e, bool &amp;quit, bool &amp;paused); //Handle the existing stack every tick void update(World &amp;world, Player &amp;player, Population &amp;population, View &amp;view, Audio &amp;audio); //Handle Individual Types of Events void handlePlayerMove(World &amp;world, Player &amp;player, View &amp;view, int a); void handleCameraMove(World &amp;world, View &amp;view); };</span></span></code> </pre> <br>  Penangan event saya jelek, tapi fungsional.  Saya dengan senang hati akan menerima rekomendasi untuk perbaikannya, terutama pada penggunaan Acara Poll SDL. <br><br><h2>  Catatan terbaru </h2><br>  Mesinnya sendiri hanyalah sebuah sistem di mana saya meletakkan bot-tugas saya (saya akan membicarakannya secara rinci di posting berikutnya).  Tetapi jika Anda menemukan metode saya menarik dan Anda ingin tahu lebih banyak, maka menulis kepada saya. <br><br>  Kemudian saya memindahkan sistem task-bot (jantung sebenarnya dari proyek ini) ke dunia 3D dan secara signifikan memperluas kemampuannya, tetapi lebih banyak tentang itu nanti (namun, kode telah diposting secara online)! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id474414/">https://habr.com/ru/post/id474414/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id474400/index.html">Mitos tentang ketersediaan kontras warna</a></li>
<li><a href="../id474402/index.html">Panduan API Koleksi Vavr</a></li>
<li><a href="../id474404/index.html">Analisis masalah yang dipecahkan dari kejuaraan pemrograman dari Yandex (pengembangan front-end) 2019</a></li>
<li><a href="../id474406/index.html">Penampilan pertama BlueKeep di alam direkam</a></li>
<li><a href="../id474408/index.html">Revolusi atau evolusi Model Obyek Halaman?</a></li>
<li><a href="../id474418/index.html">Konferensi DEFCON 27. Manfaat dari produk-produk peretas untuk macOS. Bagian 1</a></li>
<li><a href="../id474420/index.html">Pembentukan termostat: bagaimana hal itu terjadi</a></li>
<li><a href="../id474422/index.html">Memuji Platform Sumber Terbuka untuk Mengembangkan Aplikasi Seluler</a></li>
<li><a href="../id474424/index.html">Pelatihan campuran - apa itu dan bagaimana cara kerjanya</a></li>
<li><a href="../id474426/index.html">Serial animasi "Lingkaran Matematika"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>