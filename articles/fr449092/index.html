<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👟 🌄 👩🏾‍🏫 Trois paradigme de programmation asynchrone dans Vertx 🤜🏾 🕎 🤘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je veux montrer trois paradigmes de programmation asynchrone - rappels, futurs, coroutines en utilisant un exemple d'une simple application web sur le...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Trois paradigme de programmation asynchrone dans Vertx</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449092/"> Je veux montrer trois paradigmes de programmation asynchrone - rappels, futurs, coroutines en utilisant un exemple d'une simple application web sur le framework Vertx.  Nous allons écrire le code dans Kotlin. <br><br>  Supposons que nous ayons une application qui reçoit une certaine chaîne dans une requête HTTP, recherche une URL dans la base de données qui l'utilise, accède à cette URL et renvoie son contenu au client. <br>  Vertx est conçu comme un framework asynchrone pour des applications très chargées, utilise netty, nouvelle IO, bus d'événements <br><br><a name="habracut"></a>  Comme d'habitude dans Vertx, un Verticle (un analogue de l'acteur, si vous connaissez Akka) reçoit une demande, envoie une chaîne de bus d'événements pour rechercher l'URL d'un autre BusinessVerticle, qui est réellement engagé dans le travail. <br><br><pre><code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> Main { <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> vertx = Vertx.vertx() vertx.deployVerticle(HttpVerticle()) vertx.deployVerticle(BusinessVerticle()) } }</code> </pre> <br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HttpVerticle</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AbstractVerticle</span></span></span></span>() { <span class="hljs-meta"><span class="hljs-meta">@Throws(Exception::class)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(startFuture: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Future</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Void</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> router = createRouter() vertx.createHttpServer() .requestHandler(router) .listen(<span class="hljs-number"><span class="hljs-number">8080</span></span>) { result -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.succeeded()) { startFuture.complete() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { startFuture.fail(result.cause()) } } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createRouter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Router = Router.router(vertx).apply { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"/"</span></span>).handler(handlerRoot) } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> handlerRoot = Handler&lt;RoutingContext&gt; { rc -&gt; vertx.eventBus().send(<span class="hljs-string"><span class="hljs-string">"my.addr"</span></span>, rc.request().getParam(<span class="hljs-string"><span class="hljs-string">"id"</span></span>) ?: <span class="hljs-string"><span class="hljs-string">""</span></span>) { resp: AsyncResult&lt;Message&lt;String&gt;&gt; -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (resp.succeeded()) { rc.response().end(resp.result().body()) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { rc.fail(<span class="hljs-number"><span class="hljs-number">500</span></span>) } } } }</code> </pre><br>  Dans l'API standard, toute l'asynchronie se fait via les rappels, donc l'implémentation initiale de BusinessVerticle ressemblera à ceci: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BusinessVerticle</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AbstractVerticle</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dbclient: JDBCClient <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> webclient: WebClient <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { vertx.eventBus().consumer&lt;String&gt;(<span class="hljs-string"><span class="hljs-string">"my.addr"</span></span>) { message -&gt; handleMessage(message) } dbclient = JDBCClient.createShared( vertx, JsonObject() .put(<span class="hljs-string"><span class="hljs-string">"url"</span></span>, <span class="hljs-string"><span class="hljs-string">"jdbc:postgresql://localhost:5432/payroll"</span></span>) .put(<span class="hljs-string"><span class="hljs-string">"driver_class"</span></span>, <span class="hljs-string"><span class="hljs-string">"org.postgresql.Driver"</span></span>) .put(<span class="hljs-string"><span class="hljs-string">"user"</span></span>, <span class="hljs-string"><span class="hljs-string">"vala"</span></span>) .put(<span class="hljs-string"><span class="hljs-string">"password"</span></span>, <span class="hljs-string"><span class="hljs-string">"vala"</span></span>) .put(<span class="hljs-string"><span class="hljs-string">"max_pool_size"</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> options = WebClientOptions() .setUserAgent(<span class="hljs-string"><span class="hljs-string">"My-App/1.2.3"</span></span>) options.isKeepAlive = <span class="hljs-literal"><span class="hljs-literal">false</span></span> webclient = WebClient.create(vertx, options) } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Message</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { dbclient.getConnection { res -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res.succeeded()) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> connection = res.result() connection.query(<span class="hljs-string"><span class="hljs-string">"SELECT url FROM payee_company where name='</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${message.body()}</span></span></span><span class="hljs-string">'"</span></span>) { res2 -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res2.succeeded()) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> url = res2.result().rows[<span class="hljs-number"><span class="hljs-number">0</span></span>].getString(<span class="hljs-string"><span class="hljs-string">"url"</span></span>).removePrefix(<span class="hljs-string"><span class="hljs-string">"http://"</span></span>) webclient .<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(url,<span class="hljs-string"><span class="hljs-string">"/"</span></span>) .send { ar -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ar.succeeded()) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> response = ar.result() message.reply(response.bodyAsString()) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { message.fail(<span class="hljs-number"><span class="hljs-number">500</span></span>, ar.cause().message) } } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: Exception) { message.fail(<span class="hljs-number"><span class="hljs-number">500</span></span>, e.message) } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { message.fail(<span class="hljs-number"><span class="hljs-number">500</span></span>, res2.cause().message) } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { message.fail(<span class="hljs-number"><span class="hljs-number">500</span></span>, res.cause().message) } } } }</code> </pre> <br>  Cela a l'air franchement, tant bien que mal - les rappels d'enfer, en particulier la gestion des erreurs. <br><br>  Essayons d'améliorer la situation, comme nous l'apprend le gourou du rappel - en sélectionnant chaque rappel dans une méthode distincte: <br><br><pre> <code class="kotlin hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BusinessVerticle</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AbstractVerticle</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dbclient: JDBCClient <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> webclient: WebClient <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { vertx.eventBus().consumer&lt;String&gt;(<span class="hljs-string"><span class="hljs-string">"my.addr"</span></span>) { message -&gt; handleMessage(message) } dbclient = JDBCClient.createShared( vertx, JsonObject() .put(<span class="hljs-string"><span class="hljs-string">"url"</span></span>, <span class="hljs-string"><span class="hljs-string">"jdbc:postgresql://localhost:5432/payroll"</span></span>) .put(<span class="hljs-string"><span class="hljs-string">"driver_class"</span></span>, <span class="hljs-string"><span class="hljs-string">"org.postgresql.Driver"</span></span>) .put(<span class="hljs-string"><span class="hljs-string">"user"</span></span>, <span class="hljs-string"><span class="hljs-string">"vala"</span></span>) .put(<span class="hljs-string"><span class="hljs-string">"password"</span></span>, <span class="hljs-string"><span class="hljs-string">"vala"</span></span>) .put(<span class="hljs-string"><span class="hljs-string">"max_pool_size"</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> options = WebClientOptions() .setUserAgent(<span class="hljs-string"><span class="hljs-string">"My-App/1.2.3"</span></span>) options.isKeepAlive = <span class="hljs-literal"><span class="hljs-literal">false</span></span> webclient = WebClient.create(vertx, options) } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Message</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { dbclient.getConnection { res -&gt; handleConnectionCallback(res, message) } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleConnectionCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( res: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">AsyncResult</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">SQLConnection</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, message: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Message</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; )</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res.succeeded()) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> connection = res.result() connection.query(<span class="hljs-string"><span class="hljs-string">"SELECT url FROM payee_company where name='</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${message.body()}</span></span></span><span class="hljs-string">'"</span></span>) { res2 -&gt; handleQueryCallBack(res2, message) } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { message.fail(<span class="hljs-number"><span class="hljs-number">500</span></span>, res.cause().message) } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleQueryCallBack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( res2: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">AsyncResult</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ResultSet</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, message: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Message</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; )</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res2.succeeded()) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> url = res2.result().rows[<span class="hljs-number"><span class="hljs-number">0</span></span>].getString(<span class="hljs-string"><span class="hljs-string">"url"</span></span>).removePrefix(<span class="hljs-string"><span class="hljs-string">"http://"</span></span>) webclient .<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(url, <span class="hljs-string"><span class="hljs-string">"/"</span></span>) .send { ar -&gt; handleHttpCallback(ar, message) } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: Exception) { message.fail(<span class="hljs-number"><span class="hljs-number">500</span></span>, e.message) } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { message.fail(<span class="hljs-number"><span class="hljs-number">500</span></span>, res2.cause().message) } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleHttpCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ar: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">AsyncResult</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">HttpResponse</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Buffer</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&gt;, message: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Message</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; )</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ar.succeeded()) { <span class="hljs-comment"><span class="hljs-comment">// Obtain response val response = ar.result() message.reply(response.bodyAsString()) } else { message.fail(500, ar.cause().message) } } }</span></span></code> </pre> <br>  Eh bien, ça s'est amélioré.  Mais aussi moyen. <br><br>  Beaucoup de lignes, pas de code particulièrement lisible, vous devez faire glisser l'objet de <i>message le</i> long de la réponse, la gestion des erreurs répartie sur le code. <br><br>  Essayons de réécrire cette merde en utilisant <i>Futures</i> <br>  <i>Les futurs</i> sont particulièrement bons car ils peuvent être facilement combinés à l'aide de <i>Future.compose ()</i> <br><br>  Tout d'abord, nous allons traduire les méthodes Vertx standard qui acceptent un rappel et ne renvoient rien en méthodes qui renvoient Future. <br><br>  Nous profitons de la capacité de Kotlin à ajouter des méthodes aux classes existantes: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> JDBCClient.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getConnectionF</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Future&lt;SQLConnection&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> f = Future.future&lt;SQLConnection&gt;() getConnection { res -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res.succeeded()) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> connection = res.result() f.complete(connection) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { f.fail(res.cause()) } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> SQLConnection.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">queryF</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(query:</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Future&lt;ResultSet&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> f = Future.future&lt;ResultSet&gt;() query(query) { res -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res.succeeded()) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> resultSet = res.result() f.complete(resultSet) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { f.fail(res.cause()) } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T,M&gt;</span></span></span><span class="hljs-function"> HttpRequest</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendF</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Future&lt;HttpResponse&lt;M&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> f = Future.future&lt;HttpResponse&lt;M&gt;&gt;() send() { res -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res.succeeded()) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> response = res.result() f.complete(response) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { f.fail(res.cause()) } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f }</code> </pre><br>  Et transformez notre BusinessVerticle.handleMessage en ceci: <br><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Message</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> content = getContent(message) content.setHandler{res-&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res.succeeded()) { <span class="hljs-comment"><span class="hljs-comment">// Obtain response val response = res.result() message.reply(response) } else { message.fail(500, res.cause().message) } } } private fun getContent(message: Message&lt;String&gt;): Future&lt;String&gt; { val connection = dbclient.getConnectionF() val resultSet = connection.compose { it.queryF("SELECT url FROM payee_company where name='${message.body()}'") } val url = resultSet.map { it.rows[0].getString("url").removePrefix("http://") } val httpResponse = url.compose { webclient.get(it, "/").sendF() } val content = httpResponse.map { it.bodyAsString() } return content }</span></span></code> </pre><br>  Ça a l'air cool. <br><br>  Code simple et lisible.  Gestion des erreurs en un seul endroit.  Si nécessaire, vous pouvez réagir différemment à différentes exceptions ou, par exemple, le mettre dans une fonction distincte. <br><br>  Le rêve du poète! <br><br>  Mais que se passe-t-il si nous devons mettre fin à la chaîne <i>Futures</i> par une condition? <br>  Par exemple, s'il n'y a pas d'entrée correspondante dans la base de données, nous ne voulons pas lever d'exception (et coder 500 au client), mais renvoyer la chaîne "No record" avec le code 200. <br><br>  La seule façon (que je connais) de mettre fin à la chaîne de <i>Future.compose ()</i> est de <i>lever</i> une exception. <br><br>  C'est-à-dire  vous devez faire quelque chose comme ceci: déterminer votre type d'exception, lever cette exception s'il n'y a pas d'entrée dans la base de données, gérer cette exception d'une manière spéciale. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NoContentException</span></span></span></span>(message:String):Exception(message) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getContent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Message</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: Future&lt;String&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> connection = dbclient.getConnectionF() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> resultSet = connection.compose { it.queryF(<span class="hljs-string"><span class="hljs-string">"SELECT url FROM payee_company where name='</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${message.body()}</span></span></span><span class="hljs-string">'"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> url = resultSet.map { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (it.numRows&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> NoContentException(<span class="hljs-string"><span class="hljs-string">"No records"</span></span>) it.rows[<span class="hljs-number"><span class="hljs-number">0</span></span>].getString(<span class="hljs-string"><span class="hljs-string">"url"</span></span>).removePrefix(<span class="hljs-string"><span class="hljs-string">"http://"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> httpResponse = url.compose { webclient.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(it, <span class="hljs-string"><span class="hljs-string">"/"</span></span>).sendF() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> content = httpResponse.map { it.bodyAsString() } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> content } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Message</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> content = getContent(message) content.setHandler{res-&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res.succeeded()) { <span class="hljs-comment"><span class="hljs-comment">// Obtain response val response = res.result() message.reply(response) } else { if (res.cause() is NoContentException) message.reply(res.cause().message) else message.fail(500, res.cause().message) } } }</span></span></code> </pre><br>  Ça marche! <br><br>  Mais cela semble déjà pire - utiliser des exceptions pour contrôler le flux d'exécution n'est pas beau.  Et si de nombreux cas de ce genre nécessitent un traitement séparé, le code deviendra beaucoup moins lisible. <br><br>  Essayons de faire de même avec les coroutines Kotlin. <br>  Beaucoup a été écrit sur les coroutines, y compris sur Habré ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3</a> , ...) donc je n’écrirai pas à leur sujet séparément. <br><br>  Les dernières versions de Vertx génèrent automatiquement des versions coroutine de toutes les méthodes qu'un rappel devrait accepter. <br><br>  Nous connectons les bibliothèques <br>  «vertx-lang-kotlin-coroutines» <br>  «vertx-lang-kotlin» <br><br>  et obtenez, par exemple <br><br><pre> <code class="kotlin hljs">JDBCClient.getConnectionAwait() SQLConnection.queryAwait()</code> </pre><br>  etc. <br><br>  Ensuite, nos méthodes de traitement des messages se transforment en quelque chose de bien simple: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Message</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> content = getContent(message) message.reply(content) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(e:Exception){ message.fail(<span class="hljs-number"><span class="hljs-number">500</span></span>, e.message) } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getContent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Message</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: String { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> connection = dbclient.getConnectionAwait() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> resultSet = connection.queryAwait(<span class="hljs-string"><span class="hljs-string">"SELECT url FROM payee_company where name='</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${message.body()}</span></span></span><span class="hljs-string">'"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> url = resultSet.rows[<span class="hljs-number"><span class="hljs-number">0</span></span>].getString(<span class="hljs-string"><span class="hljs-string">"url"</span></span>).removePrefix(<span class="hljs-string"><span class="hljs-string">"http://"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> httpResponse = webclient.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(url, <span class="hljs-string"><span class="hljs-string">"/"</span></span>).sendAwait() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> content = httpResponse.bodyAsString() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> content }</code> </pre> <br>  Eh bien, vous devez changer l'appel en fournissant un contexte coroutine: <br><br><pre> <code class="kotlin hljs">vertx.eventBus().consumer&lt;String&gt;(<span class="hljs-string"><span class="hljs-string">"my.addr"</span></span>) { message -&gt; GlobalScope.launch(vertx.dispatcher()) { handleMessage(message)} }</code> </pre><br>  Que se passe-t-il ici? <br><br>  Toutes ces méthodes avec Await appellent le code de manière asynchrone, attendent le résultat de celui-ci, et pendant qu'elles attendent, le thread passe à l'exécution d'une autre coroutine. <br><br>  Si nous regardons sous le capot, cela ressemble à ceci: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> SQLClient.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getConnectionAwait</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: SQLConnection { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> awaitResult { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getConnection(it) } } <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">awaitResult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">h</span></span></span></span><span class="hljs-function"><span class="hljs-params">: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Handler</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">AsyncResult</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&gt;)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>): T { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> asyncResult = awaitEvent(block) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (asyncResult.succeeded()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> asyncResult.result() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> asyncResult.cause() } <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">awaitEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">h</span></span></span></span><span class="hljs-function"><span class="hljs-params">: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Handler</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>): T { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> suspendCancellableCoroutine { cont: CancellableContinuation&lt;T&gt; -&gt; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { block.invoke(Handler { t -&gt; cont.resume(t) }) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: Exception) { cont.resumeWithException(e) } } }</code> </pre><br>  Quelque chose de similaire à notre implémentation auto-écrite avec Futures. <br><br>  Mais ici, nous obtenons le code normal - String comme type de retour (au lieu de Future), essayez / catch au lieu du vilain rappel avec AsyncResult <br><br>  Et si nous devons arrêter la chaîne d'exécution au milieu, cela semble naturel, sans aucune exception: <br><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getContent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Message</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: String { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> connection = dbclient.getConnectionAwait() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> resultSet = connection.queryAwait(<span class="hljs-string"><span class="hljs-string">"SELECT url FROM payee_company where name='</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${message.body()}</span></span></span><span class="hljs-string">'"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (resultSet.numRows&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"No records"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> url = resultSet.rows[<span class="hljs-number"><span class="hljs-number">0</span></span>].getString(<span class="hljs-string"><span class="hljs-string">"url"</span></span>).removePrefix(<span class="hljs-string"><span class="hljs-string">"http://"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> httpResponse = webclient.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(url, <span class="hljs-string"><span class="hljs-string">"/"</span></span>).sendAwait() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> content = httpResponse.bodyAsString() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> content }</code> </pre><br>  À mon avis, super! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr449092/">https://habr.com/ru/post/fr449092/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr449080/index.html">Conteneur Docker pour la gestion des serveurs HP via l'OIT</a></li>
<li><a href="../fr449082/index.html">La qualité est la responsabilité de l'équipe. Notre expérience QA</a></li>
<li><a href="../fr449086/index.html">À l'intérieur de la flamme: une nouvelle méthode pour étudier les systèmes réactifs à haute température</a></li>
<li><a href="../fr449088/index.html">Il est temps que les investisseurs et les entrepreneurs commencent à résoudre le problème de la santé mentale dans les startups.</a></li>
<li><a href="../fr449090/index.html">Modifier dynamiquement le schéma JSON dans Go with gob</a></li>
<li><a href="../fr449094/index.html">Psychologie de démarrage: des transformations que tout le monde ne vivra pas</a></li>
<li><a href="../fr449096/index.html">Étendre et compléter Kubernetes (revue et rapport vidéo)</a></li>
<li><a href="../fr449098/index.html">Comment une entreprise de logiciels espions est entrée dans le magasin de certificats de Mozilla et ce qui en est sorti</a></li>
<li><a href="../fr449100/index.html">Dans le sillage de RTM. Enquête médico-légale sur un ordinateur infecté par un cheval de Troie bancaire</a></li>
<li><a href="../fr449106/index.html">UPS pour les institutions bancaires et financières</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>