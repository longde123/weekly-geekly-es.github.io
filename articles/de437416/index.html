<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕴🏽 👩🏿‍🤝‍👩🏾 🚍 Kapazitätsmanagement: Das perfekte Gleichgewicht finden 🍡 🤦🏻 🔠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo! Mein Name ist Ivan Davydov, ich beschäftige mich mit Leistungsforschung in Yandex.Money. 


 Stellen Sie sich vor, Sie haben leistungsstarke Se...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kapazitätsmanagement: Das perfekte Gleichgewicht finden</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yamoney/blog/437416/"><p>  Hallo!  Mein Name ist Ivan Davydov, ich beschäftige mich mit Leistungsforschung in Yandex.Money. </p><br><p>  Stellen Sie sich vor, Sie haben leistungsstarke Server, auf denen jeweils eine Reihe von Anwendungen gehostet werden.  Wenn es nicht sehr viele davon gibt, stören sie sich nicht gegenseitig in der Arbeit - sie sind bequem und gemütlich.  Sobald Sie zu Microservices kommen und einen Teil der "schweren" Funktionalität in separaten Anwendungen ausschalten. </p><br><p>  Hier können Sie sich mitreißen lassen, und es wird zu viele Microservices geben, wodurch es schwierig wird, sie zu verwalten und ihre Fehlertoleranz sicherzustellen.  Infolgedessen werden ein Dutzend Anwendungen, die um gemeinsam genutzte Ressourcen kämpfen, auf jedem Server "gebündelt".  Es wird sich als "große Familie" herausstellen, aber in einer großen Familie klicken Sie nicht mit Ihrem Schnabel! </p><br><p>  Einmal haben wir uns auch damit konfrontiert.  Meine Geschichte handelt von schweren und schlaflosen Nächten, in denen ich nachts unter einer Lampe saß und auf den Stoß schoss.  Alles begann mit der Tatsache, dass wir Netzwerkprobleme auf den Kampfservern bemerkten. </p><br><p><img src="https://habrastorage.org/webt/oy/x6/zl/oyx6zly8ejckx_cr0devc65tdb0.png"></p><a name="habracut"></a><br><p>  Sie haben die Leistung stark beeinflusst und erhebliche Drawdowns erzielt.  Gleichzeitig stellte sich heraus, dass bei einem regulären Benutzerstrom dieselben Fehler auftreten, jedoch in viel geringerem Umfang. </p><br><p>  Das Problem lag in der Auslastung der TCP-Sockets um mehr als 100%.  Dies geschieht, wenn alle Sockets auf den Servern ständig geöffnet und geschlossen werden.  Aus diesem Grund treten Netzwerkprobleme bei der Interaktion zwischen Anwendungen auf und es treten verschiedene Arten von Fehlern auf - der Remote-Host ist nicht verfügbar, die HTTP / HTTPS-Verbindung (Zeitlimit für Verbindung / Lesen, SSL-Peer wurde falsch heruntergefahren) und andere sind unterbrochen. </p><br><p>  Selbst wenn Sie keinen eigenen elektronischen Zahlungsdienst haben, ist es nicht sehr schwierig, das Ausmaß der Schmerzen bei einem nächsten Verkauf einzuschätzen. Der Datenverkehr nimmt um ein Vielfaches zu, und Leistungseinbußen können zu erheblichen Verlusten führen.  Wir sind also zu zwei Schlussfolgerungen gekommen: Wir müssen bewerten, wie die aktuellen Kapazitäten genutzt werden, und die Anwendungen voneinander isolieren. </p><br><p>  Um Anwendungen zu isolieren, haben wir uns für die Containerisierung entschieden.  Zu diesem Zweck haben wir einen Hypervisor verwendet, der viele separate Container mit Anwendungen enthält.  Auf diese Weise können Sie die Ressourcen des Prozessors, des Speichers, der Eingabe- / Ausgabegeräte, der Netzwerke sowie der Prozessbäume, Benutzer, Dateisysteme usw. isolieren. </p><br><p>  Bei diesem Ansatz verfügt jede Anwendung über eine eigene Umgebung, die Flexibilität, Isolation und Zuverlässigkeit bietet und die Gesamtsystemleistung verbessert.  Dies ist eine schöne und elegante Lösung, aber vorher müssen Sie eine Reihe von Fragen beantworten: </p><br><ul><li>  Welche Leistungsspanne hat eine Anwendungsinstanz derzeit? </li><li>  Wie ist die Anwendung skaliert und gibt es in der aktuellen Konfiguration Ressourcenredundanz? </li><li>  Ist es möglich, die Leistung einer Instanz zu verbessern und was ist der Engpass? </li></ul><br><p>  Mit solchen Fragen kamen Kollegen zu uns - ein Team von Leistungsforschern. </p><br><h2 id="chem-my-zanimaemsya">  Was machen wir </h2><br><p>  Wir tun alles, um die Leistung unseres Service sicherzustellen, und erforschen und verbessern ihn zunächst für die Geschäftsprozesse unserer Produktion.  Jeder Geschäftsprozess, ob es sich um die Bezahlung von Waren in einem Geschäft mit einer Brieftasche oder die Überweisung von Geld zwischen Benutzern handelt, stellt für uns im Wesentlichen eine Kette von Anforderungen im System dar. </p><br><p>  Wir führen Experimente durch und erstellen Berichte, um die Systemleistung bei hoher Intensität eingehender Anforderungen zu bewerten.  Die Berichte enthalten Leistungsmetriken und eine detaillierte Beschreibung der erkannten Probleme und Engpässe.  Mit Hilfe dieser Informationen verbessern und optimieren wir unser System. </p><br><p>  Die Bewertung des Potenzials jeder Anwendung wird durch die Tatsache erschwert, dass mehrere Microservices, die die Leistung aller beteiligten Instanzen nutzen, an der Organisation der Abfolge von Geschäftsprozessanforderungen beteiligt sind. </p><br><p>  Metaphorisch gesehen kennen wir die Macht unserer Armee, aber nicht das Potenzial jedes einzelnen Kämpfers.  Daher ist es neben der laufenden Forschung erforderlich, die im Rahmen des Kapazitätsmanagementprozesses verwendeten Ressourcen zu bewerten.  Dieser Prozess wird als Kapazitätsmanagement bezeichnet. </p><br><p>  Unsere Forschung hilft, einen Mangel an Ressourcen zu identifizieren und zu verhindern, Eiseneinkäufe vorherzusagen und genaue Daten über die aktuellen und potenziellen Fähigkeiten des Systems zu erhalten.  Im Rahmen dieses Prozesses wird die tatsächliche Anwendungsleistung (sowohl Median als auch Maximum) überwacht und Daten zum aktuellen Bestand bereitgestellt. </p><br><p>  <strong>Das Wesentliche beim Kapazitätsmanagement ist es, ein Gleichgewicht zwischen verbrauchten Ressourcen und Produktivität zu finden.</strong> </p><br><p>  Vorteile: </p><br><ul><li>  Es ist jederzeit bekannt, was mit der Leistung jeder Anwendung geschieht. </li><li>  Geringeres Risiko beim Hinzufügen neuer Microservices. </li><li>  Geringere Kosten für den Kauf neuer Geräte. </li><li>  Die bereits vorhandenen Kapazitäten werden intelligenter genutzt. </li></ul><br><h1 id="kak-rabotaet-upravlenie-moschnostyami">  Wie das Kapazitätsmanagement funktioniert </h1><br><p>  Kommen wir mit vielen Anwendungen auf unsere Situation zurück.  Wir haben eine Studie durchgeführt, deren Zweck es war, zu bewerten, wie Kapazitäten auf Produktionsservern verwendet werden. </p><br><p>  Kurz gesagt, der Aktionsplan lautet wie folgt: </p><br><ol><li>  Definieren Sie die Benutzerintensität für bestimmte Anwendungen. </li><li>  Erstellen Sie ein Aufnahmeprofil. </li><li>  Bewerten Sie die Leistung jeder Anwendungsinstanz. </li><li>  Skalierbarkeit der Rate. </li><li>  Erstellen Sie Berichte und Schlussfolgerungen zur Mindestanzahl von Instanzen für jede Anwendung in einer Kampfumgebung. </li></ol><br><p>  <em>Und jetzt im Detail.</em> </p><br><h2 id="instrumenty">  Die Werkzeuge </h2><br><p>  Wir verwenden Heka und Zabbix, um benutzerdefinierte Intensitätsmetriken zu erfassen.  Grafana wird verwendet, um gesammelte Metriken zu visualisieren. </p><br><p>  <strong>Zabbix wird</strong> zur Überwachung von Serverressourcen benötigt, z. <strong>B</strong> .: CPU, Speicher, Netzwerkverbindungen, Datenbank und andere.  <strong>Heka</strong> liefert Daten zur Anzahl und zum Zeitpunkt der Ausführung eingehender / ausgehender Anforderungen, zur Erfassung von Metriken in internen Anwendungswarteschlangen und zu einer endlosen Menge anderer Daten.  <strong>Grafana</strong> ist ein flexibles Visualisierungstool, das von verschiedenen Yandex.Money-Teams verwendet wird.  Wir sind keine Ausnahme. </p><br><p><img src="https://habrastorage.org/webt/5q/ru/bu/5qrubu5iblepg4sostjygegfp58.png"><br>  <em>Grafana kann zum Beispiel solche Dinge zeigen</em> </p><br><p>  <strong>Apache JMeter wird</strong> als Verkehrsgenerator verwendet.  Mit seiner Hilfe wird ein Aufnahmeszenario erstellt, das die Implementierung von Anforderungen, die Überwachung der Gültigkeit der Antwort, die flexible Steuerung des Feed-Streams und vieles mehr umfasst.  Dieses Tool hat sowohl Vor- als auch Nachteile, aber um genau zu sein: „Warum dieses spezielle Produkt?“  Ich werde nicht. </p><br><p>  Zusätzlich zu JMeter wird das <strong>Yandex-Tank-</strong> Framework verwendet - ein Tool zum Stresstest und zur Analyse der Leistung von Webdiensten und -anwendungen.  Sie können Ihre Module anschließen, um die gewünschten Funktionen zu erhalten und die Ergebnisse in der Konsole oder in Form von Diagrammen anzuzeigen.  Die Ergebnisse unseres Feuers werden im Lunapark (analog zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://overload.yandex.net</a> ) angezeigt, wo wir sie in Echtzeit bis zu zweiten Spitzen detailliert beobachten können, um die notwendige und ausreichende Diskretion zu gewährleisten und dadurch schneller auf Bursts zu reagieren. aus dem Schießen entstehen.  In Graphan kann man auch die Diskretion anpassen, aber diese Lösung ist in Bezug auf physische und logische Ressourcen teurer.  Und manchmal laden wir sogar Rohdaten hoch und visualisieren sie über das GUI Jmeter.  Aber nur - shhh! </p><br><p>  Apropos Erniedrigung.  Fast alle Abstürze, die in der Anwendung unter einem großen Verkehrsfluss auftreten, werden mit <strong>Kibana</strong> schnell analysiert.  Dies ist jedoch auch kein Allheilmittel. Einige Netzwerkprobleme können nur durch Entfernen und Analysieren des Datenverkehrs analysiert werden. </p><br><p>  Mit Grafana haben wir die Benutzerintensität in der Anwendung mehrere Monate lang analysiert.  Wir haben beschlossen, die Gesamtprozessorzeit für die Ausführung von Anforderungen als Maßeinheit zu verwenden, d. H. Die Anzahl der Anforderungen und die Zeit ihrer Ausführung wurden berücksichtigt.  Deshalb haben wir eine Liste der „schwersten“ Anfragen zusammengestellt, die den größten Teil des Flusses zur Anwendung ausmachen.  Diese Liste bildete die Grundlage für das Schießprofil. </p><br><p><img src="https://habrastorage.org/webt/5r/kc/5n/5rkc5nqnllvdoxoeqs4wlgstxfs.png"><br>  <em>Benutzerintensität pro Anwendung für mehrere Monate</em> </p><br><h2 id="profil-strelby-i-pristrelka">  Schieß- und Sichtprofil </h2><br><p>  Wir nennen das Auslösen eines Skriptstarts als Teil eines Experiments.  Das Profil besteht aus zwei Teilen. </p><br><p>  Der erste Teil ist das Schreiben eines Abfrageskripts.  Während der Implementierung ist es erforderlich, die Benutzerintensität für jede eingehende Anwendungsanforderung zu analysieren und ein prozentuales Verhältnis zwischen ihnen zu erstellen, um die am häufigsten aufgerufenen und lang laufenden zu identifizieren.  Der zweite Teil ist die Auswahl der Strömungswachstumsparameter: mit welcher Intensität und wie lange zu laden. </p><br><p>  Zur besseren Übersichtlichkeit lässt sich die Methode zum Erstellen eines Profils am besten anhand eines Beispiels demonstrieren. </p><br><p>  Grafana erstellt ein Diagramm, das die Benutzerintensität und den Anteil jeder Anforderung am Gesamtfluss widerspiegelt.  Basierend auf dieser Verteilung und Antwortzeit für jede Anforderung werden Gruppen in JMeter erstellt, von denen jede ein unabhängiger Verkehrsgenerator ist.  Das Szenario basiert nur auf den „schwierigsten“ Anforderungen, da es schwierig ist, alles zu implementieren (in einigen Anwendungen gibt es mehr als hundert), und dies ist aufgrund ihrer relativ geringen Intensität nicht immer erforderlich. </p><br><p><img src="https://habrastorage.org/webt/so/r-/lh/sor-lhmdrw0z5egoxcjye2z1htk.png"><br>  <em>Prozentsatz der Abfragen</em> </p><br><p>  Diese Studie untersucht die Benutzerintensität in einem konstanten Fluss, und periodisch auftretende „Bursts“ werden am häufigsten privat betrachtet. </p><br><p>  In unserem Beispiel werden zwei Gruppen betrachtet.  Die erste Gruppe enthielt "Anfrage 1" und "Anfrage 2" im Verhältnis 1 zu 2. Ebenso enthielt die zweite Gruppe die Anfragen 3 und 4. Die verbleibenden Anforderungen für die Komponente sind viel weniger intensiv, sodass wir sie nicht in das Skript aufnehmen. </p><br><p><img src="https://habrastorage.org/webt/fe/oo/mv/feoomv8l4vvhd7oab7ia8sdm_iq.png"><br>  <em>Gruppieren von Abfragen in Jmeter</em> </p><br><p>  Basierend auf der mittleren Antwortzeit für jede Gruppe wird die Leistung durch die Formel geschätzt: </p><br><p>  x = 1000 / t, wobei t die mittlere Zeit ist, ms </p><br><p>  Wir erhalten das Berechnungsergebnis und schätzen die ungefähre Intensität mit zunehmender Anzahl von Threads: </p><br><p>  TPS = x * p, wobei p die Anzahl der Threads ist, TPS die Transaktion pro Sekunde ist und x das Ergebnis der vorherigen Berechnung ist. </p><br><p>  Wenn die Anfrage in 500 ms verarbeitet wird, haben wir mit einem Stream 2 Tps und mit 100 Threads idealerweise 200 Tps.  Basierend auf den erhaltenen Ergebnissen können anfängliche Wachstumsparameter ausgewählt werden.  Nach der ersten Iteration der Forschung werden diese Parameter normalerweise angepasst. </p><br><p>  Wenn das Aufnahmeszenario fertig ist, starten wir die Aufnahme - eine Minute lang in einem Stream.  Dies geschieht, um die Funktionsfähigkeit des Skripts mit einem konstanten Fluss zu überprüfen, die Antwortzeit auf Anforderungen in jeder Gruppe zu bewerten und ein prozentuales Verhältnis der Anforderungen zu erhalten. </p><br><p>  Bei der Ausführung dieses Profils haben wir festgestellt, dass bei gleicher Intensität der Prozentsatz der Anforderungen erhalten bleibt, da die durchschnittliche Antwortzeit in der zweiten Gruppe länger ist als in der ersten.  Daher stellen wir für beide Gruppen die gleiche Durchflussrate ein.  In anderen Fällen wäre es notwendig, die Parameter für jede Gruppe separat experimentell auszuwählen. </p><br><p>  In diesem Beispiel wurde die Intensität schrittweise angewendet, dh eine bestimmte Anzahl von Flüssen wurde über ein bestimmtes Intervall hinzugefügt. </p><br><p><img src="https://habrastorage.org/webt/6u/th/hw/6uthhwf_o2ehsuukwdc2ko_4emi.png"><br>  <em>Optionen für das Intensitätswachstum</em> </p><br><p>  Die Intensitätswachstumsparameter waren wie folgt: </p><br><ul><li>  Die Zielanzahl der Fäden beträgt 100 (während der Sichtung bestimmt). </li><li>  Wachstum für 1000 Sekunden (~ 16 Minuten). </li><li>  100 Schritte. </li></ul><br><p>  Daher fügen wir alle 10 Sekunden einen Stream hinzu.  Das Intervall zwischen dem Hinzufügen von Threads und der Anzahl der hinzugefügten Threads hängt vom Verhalten des Systems in einem bestimmten Schritt ab.  Oft wird die Intensität mit einem gleichmäßigen Wachstum geliefert, so dass Sie den Status des Systems in jeder Phase verfolgen können. </p><br><h2 id="boevye-strelby">  Feuern </h2><br><p>  Normalerweise wird das Brennen nachts von Remote-Servern aus gestartet.  Zu diesem Zeitpunkt ist der Benutzerverkehr minimal - dies bedeutet, dass das Aufnehmen die Benutzer kaum beeinträchtigt und der Fehler in den Ergebnissen geringer ist. </p><br><p>  Entsprechend den Ergebnissen des ersten Brennens in einem Fall passen wir die Anzahl der Fäden und die Wachstumszeit an, analysieren das Verhalten des Gesamtsystems und stellen Abweichungen in der Arbeit fest.  Nach allen Anpassungen beginnt das wiederholte Auslösen einer Instanz.  In dieser Phase ermitteln wir die maximale Leistung und überwachen die Verwendung der Hardwareressourcen des Servers mit der Anwendung und allem, was dahinter steckt. </p><br><p>  Nach den Ergebnissen der Aufnahme betrug die Leistung einer Instanz unserer Anwendung etwa 1000 Tps.  Gleichzeitig wurde eine Verlängerung der Antwortzeit für alle Anforderungen aufgezeichnet, ohne die Produktivität zu erhöhen, dh wir erreichten eine Sättigung, aber keine Verschlechterung. </p><br><p>  Im nächsten Schritt vergleichen wir die Ergebnisse aus anderen Fällen.  Dies ist wichtig, da die Hardware unterschiedlich sein kann, was bedeutet, dass verschiedene Instanzen sehr unterschiedliche Indikatoren liefern können.  So war es auch bei uns - einige der Server erwiesen sich aufgrund ihrer Generierung und Eigenschaften als um eine Größenordnung produktiver.  Daher haben wir eine Gruppe von Servern mit den besten Ergebnissen identifiziert und deren Skalierbarkeit untersucht. </p><br><p><img src="https://habrastorage.org/webt/cm/kt/qc/cmktqc3ytdxz24bkphym7ozyrjg.png"><br>  <em>Vergleich der Serverleistung</em> </p><br><h2 id="masshtabiruemost-i-poisk-uzkih-mest">  Skalierbarkeit und Engpass </h2><br><p>  Der nächste Schritt besteht darin, die Leistung in den Instanzen 2, 3 und 4 zu untersuchen.  Theoretisch sollte die Leistung mit zunehmender Anzahl von Instanzen linear wachsen.  In der Praxis ist dies normalerweise nicht der Fall. </p><br><p>  In unserem Beispiel stellte sich heraus, dass dies eine nahezu perfekte Option war. </p><br><p><img src="https://habrastorage.org/webt/0s/2z/na/0s2znafo_1qtkiiyqj29t2-xhws.png"></p><br><p>  Der Grund für das gesättigte Produktivitätswachstum war die Erschöpfung der Konnektorpools vor dem anschließenden Backend.  Dies wird durch die Steuerung der Größe der Pools auf der ausgehenden und eingehenden Seite gelöst und führt zu einer Steigerung der Anwendungsleistung. </p><br><p>  In anderen Studien sind wir auf interessantere Dinge gestoßen.  Experimente haben gezeigt, dass mit der Leistung die Auslastung von CPU- und Datenbankverbindungen schnell zunimmt.  In unserem Fall geschah dies, weil wir in der Konfiguration mit einer Instanz auf unsere eigenen Einstellungen für Anwendungspools gestoßen sind und bei zwei Instanzen diese Anzahl verdoppelt haben, wodurch der ausgehende Stream verdoppelt wurde.  Die Datenbank war für ein solches Volume nicht bereit.  Aus diesem Grund verstopften die Pools in der Datenbank, der Prozentsatz der verbrauchten CPU erreichte eine kritische Marke von 99%, und die Verarbeitungszeit für Abfragen nahm zu, und ein Teil des Datenverkehrs fiel insgesamt ab.  Und solche Ergebnisse haben wir bereits in zwei Fällen erzielt! </p><br><p>  Um uns endlich von unseren Ängsten zu überzeugen, haben wir in drei Fällen geschossen.  Die Ergebnisse waren ungefähr die gleichen wie in den ersten beiden, außer dass sie schnell zu einer Störung kamen. </p><br><p>  Es gibt ein weiteres Beispiel für „Stecker“, das meiner Meinung nach am schmerzhaftesten ist - dies ist schlecht geschriebener Code.  Sie können alles Mögliche tun, angefangen bei Datenbankabfragen, die in wenigen Minuten ausgeführt werden, bis hin zu Code, der den Speicher eines Java-Computers falsch zuordnet. </p><br><h2 id="itogi">  Zusammenfassung </h2><br><p>  Infolgedessen hat die in unserer Beispielanwendung untersuchte Anwendungsspanne eine Leistungsspanne von mehr als dem Fünffachen. </p><br><p>  Um die Produktivität zu steigern, muss in den Anwendungseinstellungen eine ausreichende Anzahl von Prozessorpools berechnet werden.  Zwei Instanzen für eine bestimmte Anwendung sind ausreichend, und die Verwendung aller 15 verfügbaren Instanzen ist redundant. </p><br><p>  Nach der Studie wurden die folgenden Ergebnisse erhalten: </p><br><ul><li>  Die Benutzerintensität für 1 Monat wurde bestimmt und überwacht. </li><li>  Die Leistungsspanne einer Instanz der Anwendung wurde ermittelt. </li><li>  Die Ergebnisse werden über Fehler erhalten, die unter einem großen Strom auftreten. </li><li>  Es wurden Engpässe für weitere Arbeiten zur Steigerung der Produktivität festgestellt. </li><li>  Die Mindestanzahl von Instanzen für den korrekten Betrieb der Anwendung wurde ermittelt.  Infolgedessen wurde der übermäßige Einsatz von Kapazitäten aufgedeckt. </li></ul><br><p>  Die Ergebnisse der Studie bildeten die Grundlage des Projekts für den Transfer von Komponenten in Behälter, das wir in den folgenden Artikeln diskutieren werden.  Jetzt können wir mit Sicherheit sagen, wie viele Container und mit welchen Eigenschaften sie benötigt werden, wie ihre Kapazitäten rational genutzt werden können und woran gearbeitet werden sollte, um eine ordnungsgemäße Leistung sicherzustellen. </p><br><p>  Besuchen Sie unseren gemütlichen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Telegramm-Chatroom,</a> in dem Sie jederzeit um Rat fragen, Kollegen helfen und einfach über Produktivitätsforschung sprechen können. </p><br><hr><br><p>  Das ist alles für heute.  Stellen Sie Fragen in den Kommentaren und abonnieren Sie den Yandex.Money-Blog - bald werden wir über Phishing sprechen und wie Sie es vermeiden können. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437416/">https://habr.com/ru/post/de437416/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437402/index.html">Wie ich dem Roboter beigebracht habe, auf YouTube-Videos zu laufen</a></li>
<li><a href="../de437406/index.html">Mikrokernel seL4. Formale Überprüfung von Programmen in der realen Welt</a></li>
<li><a href="../de437408/index.html">802.1x, EX2200, NPS und alles in allem ...</a></li>
<li><a href="../de437410/index.html">Einführung in Spring Boot mit Spring Data Mongo</a></li>
<li><a href="../de437414/index.html">Wo in Russland mehr als 20 Millionen Transportkarten gefährdet sind: Wir zerlegen und entwickeln MIFARE Classic</a></li>
<li><a href="../de437418/index.html">Informationen zu Entitäten, DTO, ORM und Lazy Load</a></li>
<li><a href="../de437420/index.html">Willst du ewige LEDs? Lötkolben und Feilen aufdecken. Oder hausgemachte hausgemachte Beleuchtung</a></li>
<li><a href="../de437422/index.html">Ausgangspunkt</a></li>
<li><a href="../de437424/index.html">Träume von künstlicher Intelligenz von Zerglingen</a></li>
<li><a href="../de437426/index.html">Studenten, ewige Studenten und Durst nach neuem Wissen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>