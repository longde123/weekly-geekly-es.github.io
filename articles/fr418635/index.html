<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚇 👨🏿‍🚀 🧔🏻 Création d'une machine d'arcade d'émulation. Partie 1 🈯️ 👩🏻‍🔬 🉑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'écriture d'un émulateur de machine d'arcade est un excellent projet éducatif, et dans ce tutoriel, nous examinerons très en détail l'ensemble du pro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Création d'une machine d'arcade d'émulation. Partie 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418635/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6eb/735/b99/6eb735b9990860a94f9ef0a18ba46a82.jpg" alt="image"></div><br>  L'écriture d'un émulateur de machine d'arcade est un excellent projet éducatif, et dans ce tutoriel, nous examinerons très en détail l'ensemble du processus de développement.  Vous voulez vraiment mettre la main sur le processeur?  La création d'un émulateur est alors la meilleure façon de l'apprendre. <br><br>  Vous aurez besoin de connaissances en C, ainsi que de connaissances en assembleur.  Si vous ne connaissez pas le langage d'assemblage, l'écriture d'un émulateur est la meilleure façon de l'apprendre.  Vous devrez également maîtriser les mathématiques hexadécimales (également appelées base 16 ou simplement «hex»).  Je vais parler de ce sujet. <br><br>  J'ai décidé de choisir un émulateur pour la machine Space Invaders, qui utilise le processeur 8080. Ce jeu et ce processeur sont très populaires, car sur Internet, vous pouvez trouver beaucoup d'informations à leur sujet.  Vous en aurez besoin pour terminer le projet. <br><br>  Le code source complet du tutoriel est téléchargé sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github</a> .  Si vous n'avez pas maîtrisé le travail avec git, alors sur la page github il y a un bouton "Télécharger ZIP" qui vous permet de télécharger l'archive avec tout le code. <br><a name="habracut"></a><br><h1>  Introduction aux nombres binaires et hexadécimaux </h1><br>  En mathématiques "ordinaires", le système de nombres décimaux est utilisé.  Chaque chiffre du nombre peut avoir une valeur de zéro à neuf, et lorsque nous dépassons 9, nous ajoutons un au nombre dans le chiffre suivant et recommençons à partir de zéro.  Tout cela est assez simple et direct, et vous n'y avez probablement jamais pensé. <br><br>  Vous avez peut-être su ou entendu que les ordinateurs fonctionnent avec des données binaires.  Les geeks informatiques appellent les mathématiques décimales base-10 et les appels binaires base-2.  En notation binaire, chaque chiffre d'un nombre ne peut avoir que deux valeurs, zéro ou une.  En code binaire, le nombre est le suivant: 0, 1, 10, 11, 100, 101, 110, 111, 1000. Ce ne sont pas des nombres décimaux, vous ne pouvez donc pas les appeler «zéro, un, dix, onze, cent, cent un».  Ils sont prononcés comme "zéro, un, un zéro, un un, un zéro zéro", etc.  Je lis rarement les nombres binaires à haute voix, mais si nécessaire, vous devez indiquer clairement le système numérique utilisé.  Dix, onze et cent n'ont aucune signification en notation binaire. <br><br>  En notation décimale, un nombre a les chiffres suivants: unités, dizaines, centaines, milliers, dizaines de milliers, etc.  Dans le système binaire, les chiffres suivants: unités, deux, quatre, huit, etc.  <strong>En informatique, la valeur de chaque bit binaire est appelée bit.</strong>  <strong>8 bits constituent un octet.</strong> <br><br>  En termes binaires, une chaîne de nombres devient rapidement très longue.  Pour représenter le nombre décimal 20 000 en termes binaires, 16 chiffres sont requis: 0b100111000100000.  Pour résoudre ce problème, il est pratique d'utiliser un système numérique hexadécimal, également appelé base 16 (ou hex).  En base 16, chaque chiffre contient 16 valeurs.  Pour les valeurs de zéro à neuf, les mêmes caractères sont utilisés que dans la base-10, mais pour les 6 valeurs restantes, les substitutions sont utilisées sous la forme des 6 premières lettres de l'alphabet, de A à F. <br><br>  Le compte dans le système hexadécimal est effectué comme suit: 0 1 2 3 4 5 6 7 8 9 ABCDEF 10 11 12, etc.  Dans l'hexadécimal, les dizaines, les centaines et ainsi de suite n'ont pas la même signification qu'en décimal, donc les gens prononcent les nombres séparément.  Par exemple, $ A57 est prononcé à haute voix par "A-cinq-sept".  Pour plus de clarté, vous pouvez également ajouter un hex, par exemple, "A-cinq-sept-hex".  Dans le système numérique hexadécimal, l'équivalent du nombre décimal 20 000 est 4E20 $ - une forme beaucoup plus compacte que 16 bits du système binaire. <br><br>  Je pense que le système hexadécimal a été choisi en raison d'une conversion très naturelle du binaire en hexadécimal et vice versa.  Chaque chiffre hexadécimal correspond à 4 bits (4 bits) d'un nombre binaire similaire.  <strong>2 chiffres hexadécimaux constituent un octet (8 bits).</strong>  Un seul chiffre hexadécimal peut être appelé grignotage, et certaines personnes l'écrivent même par y comme «nybble». <br><br><table><tbody><tr><th colspan="4">  Chaque chiffre hexadécimal est composé de 4 chiffres binaires </th></tr><tr><td>  Hex </td><td>  Un </td><td>  5 </td><td>  7 </td></tr><tr><td>  Binaire </td><td>  1010 </td><td>  0101 </td><td>  0111 </td></tr></tbody></table><br>  Lors de l'écriture du code C, on pense que le nombre est décimal (base-10), sauf indication contraire.  Pour indiquer au compilateur C que le nombre est binaire, nous ajoutons le nombre zéro et la lettre b en minuscules, comme ceci: <code>0b1101101</code> .  Le nombre hexadécimal peut être écrit en code C en ajoutant au début de zéro et x en minuscule: <code>0xA57</code> .  Certaines langues d'assemblage utilisent le signe dollar $: <code>$A57</code> pour indiquer un nombre hexadécimal. <br><br>  Si vous y réfléchissez, la connexion entre les nombres binaires, hexadécimaux et décimaux est assez évidente, mais pour le premier ingénieur, qui y avait pensé avant l'invention de l'ordinateur, cela aurait dû devenir un moment de réflexion. <br><br>  Vous avez compris tout ça?  Super. <br><br><h1>  Une brève introduction au processeur </h1><br>  <em>Si vous le savez déjà, vous pouvez ignorer la section en toute sécurité.</em> <br><br>  Une unité centrale de traitement (CPU) est une machine conçue pour exécuter des programmes.  Les blocs fondamentaux de la CPU sont les registres et les instructions.  En tant que développeur de logiciels, vous pouvez traiter ces registres comme des variables.  Dans notre processeur 8080, entre autres registres, il existe des registres 8 bits appelés A, B, C, D et E. Ces registres peuvent être interprétés comme le code C suivant: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> A, B, C, D, E;</code> </pre> <br>  Tous les processeurs ont également un compteur de programmes (Program Counter, PC).  Vous pouvez le prendre comme pointeur. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* pc;</code> </pre> <br>  Pour un CPU, un programme est une séquence de nombres hexadécimaux.  Chaque instruction en langage assembleur en 8080 correspond à 1 à 3 octets dans le programme.  Afin de savoir quelle commande correspond à quel numéro, le manuel du processeur (ou toute autre information sur le processeur 8080 sur Internet) est utile. <br><br>  Les noms des commandes (instructions) sont souvent des mnémoniques des opérations effectuées par ces commandes.  Le mnémonique pour le chargement en 8080 est MOV (déplacer) et ADD est utilisé pour effectuer l'addition. <br><br><h4>  Des exemples </h4><br>  La valeur de mémoire actuelle indiquée par le compteur d'instructions est 0x79.  Ceci est conforme à l'instruction <code>MOV A,C</code> processeur 8080. Ce code d'assemblage en code C ressemble à <code>A=C;</code>  . <br><br>  Si, à la place, la valeur dans le PC était 0x80, alors le processeur exécuterait <code>ADD B</code>  En C, cela correspond à la chaîne <code>A = A + B;</code>  . <br><br>  Une liste complète des instructions du processeur 8080 peut être trouvée <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Pour implémenter notre émulateur, nous utiliserons ces informations. <br><br><h4>  Timings </h4><br>  Dans le CPU, l'exécution de chaque instruction nécessite un certain temps (timing), mesuré en cycles.  Dans les processeurs modernes, ces informations peuvent être difficiles à obtenir, car les délais dépendent de nombreux aspects différents.  Mais dans les processeurs plus anciens comme le 8080, les délais sont constants et ces informations sont souvent fournies par le fabricant du processeur.  Par exemple, une instruction de transfert d'un registre vers un registre MOV prend 1 cycle. <br><br>  Les informations de synchronisation sont utiles pour écrire du code efficace dans le processeur.  Un programmeur peut chercher à éviter les instructions qui prennent plusieurs cycles à compléter. <br><br>  Plus important pour nous, nous utiliserons des informations de synchronisation pour émuler le processeur.  Pour que le jeu fonctionne de la même manière que sur l'original, les instructions doivent être exécutées à la bonne vitesse.  Certains émulateurs y mettent beaucoup d'efforts, mais lorsque nous y arriverons, nous devrons décider quelle précision nous voulons obtenir. <br><br><h1>  Opérations logiques </h1><br>  Avant de clore le sujet des nombres binaires et hexadécimaux, nous devrions parler des opérations logiques.  Vous êtes probablement déjà habitué à utiliser la logique dans votre code, par exemple, dans des constructions comme <code>if ((conditionA) and (conditionB))</code> .  Dans les programmes qui fonctionnent directement avec du matériel, vous devez souvent manipuler des bits de nombres individuels. <br><br><h3>  ET opération </h3><br>  Voici tous les résultats possibles de l'opération ET (ET) (table de vérité) entre deux nombres à un seul bit. <br><br><table><tbody><tr><td>  x </td><td>  y </td><td>  Résultat </td></tr><tr><td>  0 </td><td>  0 </td><td>  0 </td></tr><tr><td>  0 </td><td>  1 </td><td>  0 </td></tr><tr><td>  1 </td><td>  0 </td><td>  0 </td></tr><tr><td>  1 </td><td>  1 </td><td>  1 </td></tr></tbody></table><br>  Le résultat de AND n'est égal à l'unité que lorsque les deux valeurs sont égales à l'unité.  Lorsque nous combinons deux nombres avec l'opération ET, ET pour chaque bit d'un nombre est ET avec le bit correspondant de l'autre nombre.  Le résultat est stocké dans ce bit du numéro de destination.  Il vaut probablement mieux regarder un exemple: <br><br><table><tbody><tr><td></td><td colspan="8">  binaire </td><td>  hex </td></tr><tr><td>  source x </td><td>  0 </td><td>  1 </td><td>  1 </td><td>  0 </td><td>  1 </td><td>  0 </td><td>  1 </td><td>  1 </td><td>  6 G $ </td></tr><tr><td>  source y </td><td>  1 </td><td>  1 </td><td>  0 </td><td>  1 </td><td>  0 </td><td>  0 </td><td>  1 </td><td>  0 </td><td>  $ D2 </td></tr><tr><td>  x ET y </td><td>  0 </td><td>  1 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  0 </td><td>  1 </td><td>  0 </td><td>  42 $ US </td></tr></tbody></table><br>  En C, l'opération AND logique est une simple esperluette "&amp;". <br><br><h3>  Opération OU (OU) </h3><br>  L'opération OR fonctionne de manière similaire.  La seule différence est que le résultat sera égal à un si au moins une des valeurs de x ou y est égale à un. <br><br><table><tbody><tr><td>  x </td><td>  y </td><td>  Résultat </td></tr><tr><td>  0 </td><td>  0 </td><td>  0 </td></tr><tr><td>  0 </td><td>  1 </td><td>  1 </td></tr><tr><td>  1 </td><td>  0 </td><td>  1 </td></tr><tr><td>  1 </td><td>  1 </td><td>  1 </td></tr></tbody></table><br><table><tbody><tr><td></td><td colspan="8">  binaire </td><td>  hex </td></tr><tr><td>  source x </td><td>  0 </td><td>  1 </td><td>  1 </td><td>  0 </td><td>  1 </td><td>  0 </td><td>  1 </td><td>  1 </td><td>  6 G $ </td></tr><tr><td>  source y </td><td>  1 </td><td>  1 </td><td>  0 </td><td>  1 </td><td>  0 </td><td>  0 </td><td>  1 </td><td>  0 </td><td>  $ D2 </td></tr><tr><td>  x OU y </td><td>  1 </td><td>  1 </td><td>  1 </td><td>  1 </td><td>  1 </td><td>  0 </td><td>  1 </td><td>  1 </td><td>  $ Fb </td></tr></tbody></table><br>  En C, une opération OU logique est indiquée par une barre verticale "|". <br><br><h3>  Pourquoi est-ce important? </h3><br>  Dans de nombreux processeurs plus anciens, et en particulier dans les machines d'arcade, le jeu nécessite souvent de travailler avec un seul bit du nombre.  Il existe souvent un code similaire: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/*  1:     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *buttons_ptr = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-number"><span class="hljs-number">0x2043</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buttons = *buttons_ptr; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buttons &amp; <span class="hljs-number"><span class="hljs-number">0x4</span></span>) HandleLeftButton(); <span class="hljs-comment"><span class="hljs-comment">/*  2:  LED-    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * LED_pointer = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) <span class="hljs-number"><span class="hljs-number">0x2089</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> led = *LED_pointer; led = led | <span class="hljs-number"><span class="hljs-number">0x40</span></span>; <span class="hljs-comment"><span class="hljs-comment">//,  LED   6 *LED_pointer = led; /*  3:   LED- */ char * LED_pointer = (char *) 0x2089; char led = *LED_pointer; led = led &amp; 0xBF; //  6 *LED_pointer = led;</span></span></code> </pre> <br>  Dans l'exemple 1, l'adresse 2043 $ allouée en mémoire est l'adresse des boutons du panneau de commande.  Ce code lit et répond au bouton enfoncé.  (Bien sûr, dans Space Invaders, ce code sera en langage assembleur!) <br><br>  Dans l'exemple 2, le jeu veut allumer un indicateur LED, qui se trouve dans le bit 6 de l'adresse de 2089 $ allouée en mémoire.  Le code doit lire la valeur existante, modifier un seul bit et la réécrire. <br><br>  Dans l'exemple 3, vous devez désactiver l'indicateur de l'exemple 2, donc le code devrait réinitialiser le bit 6 de l'adresse 2089 $.  Cela peut être fait en effectuant l'opération ET pour l'octet de commande d'indicateur avec une valeur pour laquelle seul le bit 6 est nul. Nous n'affecterons donc que 6, en laissant les bits restants inchangés. <br><br>  Ceci est généralement appelé un «masque».  En C, un masque est généralement écrit à l'aide de l'opérateur NOT, désigné par un tilde ("~").  Par conséquent, au lieu d'écrire <code>0xBF</code> , j'écris simplement <code>~0x40</code> et j'obtiens le même nombre, mais sans mettre beaucoup d'efforts. <br><br><h1>  Introduction au langage d'assemblage </h1><br>  Si vous lisez ce didacticiel, vous connaissez probablement la programmation informatique, par exemple en Java ou en Python.  Ces langages vous permettent de faire beaucoup de travail en seulement quelques lignes de code.  Le code est considéré comme intelligemment écrit s'il fait autant de travail que possible sur le moins de lignes possible, peut-être même en utilisant les fonctionnalités des bibliothèques intégrées.  Ces langues sont appelées «langues de haut niveau». <br><br>  En langage d'assemblage, en revanche, il n'y a pas de fonctions de sauvetage intégrées, et de nombreuses lignes de code simples peuvent être nécessaires pour effectuer des tâches simples.  Le langage d'assemblage est considéré comme un langage de bas niveau.  Dans ce document, vous devez vous habituer à penser dans le style de "quelle séquence spécifique d'étapes doit être prise pour terminer cette tâche?" <br><br>  La chose la plus importante que vous devez savoir sur le langage assembleur est que chaque ligne est traduite en une seule commande de processeur. <br><br>  Considérez une telle construction à partir du langage C: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = b + <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre> <br>  En langage assembleur, cette tâche devra être effectuée dans l'ordre suivant: <br><br><ol><li>  Charger l'adresse de la variable B dans le registre 1 </li><li>  Charger le contenu de cette adresse mémoire dans le registre 2 </li><li>  Ajouter une valeur directe 0x64 pour enregistrer 2 </li><li>  Charger l'adresse de la variable A dans le registre 1 </li><li>  Écrire le contenu du registre 2 à l'adresse stockée dans le registre 1 </li></ol><br>  Dans le code, cela ressemblera à ceci: <br><br><pre> <code class="hljs pgsql"> lea a1, #<span class="hljs-meta"><span class="hljs-meta">$1000</span></span> ;   a lea a2, #<span class="hljs-meta"><span class="hljs-meta">$1008</span></span> ;   b <span class="hljs-keyword"><span class="hljs-keyword">move</span></span>.l d0,(a2) <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>.l d0, #<span class="hljs-meta"><span class="hljs-meta">$64</span></span> mov (a1),d0</code> </pre> <br>  Il convient de noter les éléments suivants: <br><br><ul><li>  Dans un langage de haut niveau, le compilateur décide où placer les variables en mémoire.  Lorsque vous écrivez du code dans l'assembleur, vous êtes vous-même responsable de chaque adresse mémoire que vous utiliserez. </li><li>  Dans la plupart des langages d'assemblage, les crochets signifient «mémoire à cette adresse». </li><li>  Dans la plupart des langages d'assembleur, # désigne un nombre algébrique, également appelé valeur immédiate.  Par exemple, à la ligne 1 de l'exemple ci-dessus, le code écrit en fait la valeur # 0x1000 pour enregistrer a1.  Si le code ressemblait à <code>move.l a1, ($1000)</code> , alors a1 recevrait le contenu de la mémoire à l'adresse 0x1000. </li><li>  Chaque processeur possède son propre langage d'assemblage, et le portage de code d'un processeur à un autre peut être difficile. </li><li>  Ce n'est pas un vrai langage d'assemblage de processeur, je l'ai proposé comme exemple. </li></ul><br>  Cependant, il y a une chose en commun entre les programmeurs intelligents de haut niveau et les assistants d'assemblage.  Les programmeurs assembleurs considèrent comme un honneur de terminer la tâche aussi efficacement que possible et de minimiser le nombre d'instructions utilisées.  Le code des machines d'arcade est généralement hautement optimisé et tous les jus sont extraits de chaque octet et cycle supplémentaire. <br><br><h1>  Piles </h1><br>  Parlons un peu plus du langage d'assemblage.  Dans tout programme informatique assez complexe dans les sous-programmes d'assembleur sont utilisés.  La plupart des processeurs ont une structure appelée pile. <br><br>  Imaginez une pile sous la forme d'une pile.  Si nous devons enregistrer un numéro, nous le mettons en haut de la pile.  Lorsque nous devons le ramener, nous le prenons du haut de la pile.  Les programmeurs assembleurs appellent popping le nombre sur la pile «push», et le faire sortir est appelé «pop». <br><br>  Disons que mon programme doit appeler un sous-programme.  Je peux écrire un code similaire: <br><br><pre> <code class="hljs css"> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1000</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">d0</span></span> ;  <span class="hljs-selector-tag"><span class="hljs-selector-tag">d0</span></span>   0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1004</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> ;     0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1008</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">d1</span></span> ;  <span class="hljs-selector-tag"><span class="hljs-selector-tag">d1</span></span>   0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1010</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> ;  .. 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1014</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">a0</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1018</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x101C</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">a1</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1020</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1024</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>), <span class="hljs-selector-id"><span class="hljs-selector-id">#0x1030</span></span> ;   0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1028</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x102C</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">jmp</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#0x2040</span></span> ;   <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x2040</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1030</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">a1</span></span>, (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>) ;    0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1034</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sub</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> ;    0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1038</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">a0</span></span>, (<span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>) ;    0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x103c</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sub</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sp</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span>  ..</code> </pre> <br>  Le code montré ci-dessus pousse les valeurs d0, d1, a0 et a1 sur la pile.  La plupart des processeurs utilisent un pointeur de pile.  Il peut s'agir d'un registre normal, par convention utilisé comme pointeur de pile, ou d'un registre spécial avec des fonctions pour certaines instructions. <br><br>  Sur les processeurs de la série 68K, le pointeur de pile n'est déterminé que par convention, sinon c'est un registre régulier.  Dans notre processeur 8080, le registre SP est un registre spécial.  Il a des commandes PUSH et POP qui écrivent et sautent de la pile en une seule commande. <br><br>  Dans notre projet d'émulateur, nous n'écrirons pas de code à partir de zéro.  Mais si vous avez besoin d'analyser des programmes en langage assembleur, il est bon d'apprendre à reconnaître de telles constructions. <br><br><h4>  Langues de haut niveau </h4><br>  Lors de l'écriture d'un programme dans un langage de haut niveau, toutes les opérations de sauvegarde et de restauration des registres sont effectuées à chaque appel de fonction.  Nous n'y pensons pas, car le compilateur les traite.  Les appels de fonction dans un langage de haut niveau peuvent prendre beaucoup de mémoire et de temps processeur. <br><br>  Avez-vous déjà vu un programme se bloquer lors de l'appel d'un sous-programme dans une boucle infinie?  Cela peut se produire car chaque appel de fonction a poussé les valeurs de registre sur la pile et à un moment donné, la mémoire a été épuisée.  (Si la pile devient trop grande, cela s'appelle débordement de pile ou débordement de pile.) <br><br>  Vous avez peut-être entendu parler des fonctions en ligne.  Ils évitent de sauvegarder et de restaurer les registres en incluant le code de routine dans la fonction appelante.  Le code devient plus grand, mais grâce à cela, plusieurs commandes et opérations de lecture / écriture en mémoire sont enregistrées. <br><br><h4>  Conventions d'appel </h4><br>  Lorsque vous écrivez un programme assembleur qui n'appelle que votre code, vous pouvez décider vous-même comment les routines communiqueront entre elles.  Par exemple, comment retourner à la fonction appelante une fois la routine terminée?  Une façon consiste à écrire l'adresse de retour dans un registre spécifique.  L'autre consiste à placer l'adresse de retour au-dessus de la pile.  Très souvent, la décision dépend de ce que le processeur prend en charge.  Le 8080 a une commande CALL qui pousse l'adresse de retour d'une fonction sur la pile.  Vous utiliserez peut-être cette commande 8080 pour implémenter des appels de sous-programme. <br><br>  Une décision de plus doit être prise.  La conservation du registre relève-t-elle de la fonction appelante ou du sous-programme?  Dans l'exemple ci-dessus, les registres sont stockés par la fonction appelante.  Mais que faire si nous avons 32 registres?  Sauvegarder et restaurer 32 registres lorsqu'une routine n'en utilise qu'une petite fraction sera une perte de temps. <br><br>  Le compromis peut être une approche mixte.  Supposons que nous choisissions une politique dans laquelle une routine peut utiliser les registres r10-r32 sans enregistrer leur contenu, mais ne peut pas détruire r1-r9.  Dans une situation similaire, la fonction appelante connaît les éléments suivants: <br><br><ul><li>  Au retour d'une fonction, le contenu de r1-r9 restera inchangé </li><li>  Je ne peux pas dépendre du contenu du r10-r32 </li><li>  Si j'ai besoin d'une valeur dans r10-r32 après avoir appelé un sous-programme, alors avant de l'appeler, je dois l'enregistrer quelque part </li></ul><br>  De même, chaque routine connaît les éléments suivants: <br><br><ul><li>  Je peux détruire r10-r32 </li><li>  Si je veux utiliser r1-r9, je dois enregistrer le contenu et le restaurer avant de retourner à la fonction qui m'a appelé </li></ul><br><h4>  Abi </h4><br>  Sur la plupart des plates-formes modernes, ces politiques sont créées par des ingénieurs et publiées dans des documents appelés ABI (Application Binary Interface).  Grâce à ce document, les créateurs de compilateurs savent comment compiler du code pouvant appeler du code compilé par d'autres compilateurs.  Si vous souhaitez écrire du code assembleur qui peut fonctionner dans un tel environnement, vous devez connaître ABI et écrire du code conformément à celui-ci. <br><br>  Connaître ABI permet également de déboguer du code lorsque vous n'avez pas accès à la source.  L'ABI définit l'emplacement des paramètres des fonctions, donc lorsque vous envisagez un sous-programme, vous pouvez examiner ces adresses pour comprendre ce qui est transmis aux fonctions. <br><br><h4>  Retour à l'émulateur </h4><br>  La plupart des codes d'assemblage écrits à la main, en particulier pour les processeurs et les jeux d'arcade plus anciens, ne suivent pas ABI.  Les programmes sont assemblés et peuvent ne pas avoir beaucoup de routines.  Chaque routine enregistre et restaure les registres uniquement en cas d'urgence. <br><br>  Si vous voulez comprendre ce que fait le programme, il serait bien de commencer par marquer les adresses ciblées pour les commandes CALL. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr418635/">https://habr.com/ru/post/fr418635/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr418625/index.html">Appel secret à Andy Grove qui a aidé Apple à acheter le NeXT</a></li>
<li><a href="../fr418627/index.html">En savoir plus sur les méthodes de résolution de systèmes d'équations algébriques linéaires</a></li>
<li><a href="../fr418629/index.html">Comment vérifier indépendamment si vous pouvez breveter votre produit et effectuer une recherche de brevets</a></li>
<li><a href="../fr418631/index.html">7 directives de code javascript</a></li>
<li><a href="../fr418633/index.html">Réactivité JavaScript: un exemple simple et intuitif</a></li>
<li><a href="../fr418637/index.html">Kubernetes aux masses: Slurm démarre le 3 août</a></li>
<li><a href="../fr418639/index.html">Akka Streams pour les simples mortels</a></li>
<li><a href="../fr418641/index.html">Une erreur qui empêche un designer de grandir</a></li>
<li><a href="../fr418643/index.html">Assis vs debout: comment mieux travailler?</a></li>
<li><a href="../fr418645/index.html">Articles de la conférence de printemps C ++ Russie 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>