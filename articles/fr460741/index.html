<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👷🏻 🕛 🤽🏿 Introduction à ECMAScript 6 (ES-2015) 🧜 ☁️ 💪🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction à ES6 

 Table des matières 
 1. Modèles de littéraux 
 2. let et const 
 3. Expressions des fonctions fléchées 
 4. Pour ... de 
 5. Nom...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Introduction à ECMAScript 6 (ES-2015)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460741/"><h2>  Introduction à ES6 </h2><br><br>  <b>Table des matières</b> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1. Modèles de littéraux</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2. let et const</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3. Expressions des fonctions fléchées</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4. Pour ... de</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">5. Noms de propriété calculés</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">6. Object.assign ()</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">7. Paramètres de repos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">8. Paramètres par défaut</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">9. Mission de restructuration</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">10. Carte</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">11. Set</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">12. Classes</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">13. Promesse</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">14. Itérateurs</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">15. Générateurs</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">16. Sumbol</a> <br><br><a name="section001"></a><h2>  Littéraux de modèle (chaînes de modèle) </h2><br>  Les littéraux de modèle sont des littéraux de chaîne qui permettent l'utilisation d'expressions à l'intérieur.  Avec eux, vous pouvez utiliser des littéraux multilignes et une interpolation de chaînes. <br><br>  Les littéraux de modèle sont entourés de guillemets (``) au lieu de doubles ou simples.  Ils peuvent contenir des caractères génériques indiqués par un signe dollar et des accolades ($ {expression}).  Les expressions de substitution et le texte entre elles sont passés à la fonction.  Par défaut, la fonction concatène simplement toutes les parties dans une chaîne.  S'il y a une expression avant la ligne (ici c'est tag), alors la ligne de modèle est appelée "modèle de balise".  Dans ce cas, l'expression de balise (généralement une fonction) est appelée avec le littéral de modèle traité, que vous pouvez modifier avant la sortie.  Pour échapper à la citation inverse dans les littéraux de modèle, spécifiez la barre oblique inverse \. <br><a name="habracut"></a><br>  <b>Littéraux multilignes</b> <br>  Les caractères de nouvelle ligne font partie des littéraux génériques.  En utilisant des chaînes régulières, l'encapsulage nécessiterait la syntaxe suivante: <br><pre><code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'string text line 1\n'</span></span> + <span class="hljs-string"><span class="hljs-string">'string text line 2'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// "string text line 1 // string text line 2"</span></span></code> </pre> <br>  Même chose avec l'utilisation des littéraux de modèle: <br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`string text line 1 string text line 2`</span></span>); <span class="hljs-comment"><span class="hljs-comment">// "string text line 1 // string text line 2"</span></span></code> </pre> <br><br>  <b>Interpolation d'expression</b> <br>  Pour insérer des expressions dans des chaînes régulières, vous devez utiliser la syntaxe suivante: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Fifteen is '</span></span> + (a + b) + <span class="hljs-string"><span class="hljs-string">' and not '</span></span> + (<span class="hljs-number"><span class="hljs-number">2</span></span> * a + b) + <span class="hljs-string"><span class="hljs-string">'.'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// "Fifteen is 15 and not 20."</span></span></code> </pre> <br><br>  Maintenant, avec l'aide des modèles de littéraux, vous pouvez utiliser le «sucre syntaxique», ce qui rend les substitutions comme celle-ci plus lisibles: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Fifteen is </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${a + b}</span></span></span><span class="hljs-string"> and not </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">2</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> * a + b}</span></span></span><span class="hljs-string">.`</span></span>); <span class="hljs-comment"><span class="hljs-comment">// "Fifteen is 15 and not 20."</span></span></code> </pre> <cut></cut><br><br>  <b>Modèles imbriqués</b> <br>  Parfois, l'imbrication d'un motif est le moyen le plus court et peut-être le plus lisible de créer une chaîne.  Mettez simplement un autre dans le modèle backquoted, en les enveloppant dans la substitution $ {}.  Par exemple, si l'expression est vraie, vous pouvez renvoyer un littéral de modèle. <br>  Dans ES5: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classes = <span class="hljs-string"><span class="hljs-string">'header'</span></span> classes += (isLargeScreen() ? <span class="hljs-string"><span class="hljs-string">''</span></span> : item.isCollapsed ? <span class="hljs-string"><span class="hljs-string">' icon-expander'</span></span> : <span class="hljs-string"><span class="hljs-string">' icon-collapser'</span></span>);</code> </pre> <br>  Dans ES2015 avec des modèles de littéraux sans imbrication: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> classes = <span class="hljs-string"><span class="hljs-string">`header </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${ isLargeScreen() ? </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">''</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> : (item.isCollapsed ? </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'icon-expander'</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> : </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'icon-collapser'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">) }</span></span></span><span class="hljs-string">`</span></span>;</code> </pre> <br>  Dans ES2015 avec des littéraux de modèle imbriqués: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> classes = <span class="hljs-string"><span class="hljs-string">`header </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${ isLargeScreen() ? </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">''</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> : </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">`icon-</span></span></span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${item.isCollapsed ? </span></span></span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'expander'</span></span></span></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"> : </span></span></span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'collapser'</span></span></span></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">}</span></span></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">`</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> }</span></span></span><span class="hljs-string">`</span></span>;</code> </pre> <br><cut></cut><br>  <b>Modèles de balises</b> <br>  Une forme étendue de littéraux de modèle est les modèles balisés.  Ils vous permettent d'analyser les littéraux de modèle à l'aide d'une fonction.  Le premier argument d'une telle fonction contient un tableau de valeurs de chaîne et le reste contient des expressions de substitutions.  Par conséquent, la fonction doit renvoyer la chaîne assemblée (ou quelque chose de complètement différent, comme cela sera montré plus loin).  Le nom de la fonction peut être n'importe quoi. <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> person = <span class="hljs-string"><span class="hljs-string">'Mike'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> age = <span class="hljs-number"><span class="hljs-number">28</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myTag</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">strings, personExp, ageExp</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> str0 = strings[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// "That " var str1 = strings[1]; // " is a " // ,     // (  )    , //    (""),    . // var str2 = strings[2]; var ageStr; if (ageExp &gt; 99){ ageStr = 'centenarian'; } else { ageStr = 'youngster'; } //     ,     return `${str0}${personExp}${str1}${ageStr}`; } var output = myTag`That ${ person } is a ${ age }`; console.log(output);// That Mike is a youngster</span></span></code> </pre> <br>  La fonction de balise n'est pas requise pour renvoyer une chaîne. <br><cut></cut><br>  <b>Lignes brutes</b> <br>  La propriété brute spéciale, disponible pour le premier argument du modèle de balise, vous permet d'obtenir la chaîne sous la forme dans laquelle elle a été entrée, sans interprétation. <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tag</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">strings</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> strings.raw[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } tag<span class="hljs-string"><span class="hljs-string">`string text line 1 \\n string text line 2`</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  "string text line 1 \\n string text line 2", //  'n'    '\'</span></span></code> </pre> <br>  En outre, il existe une méthode String.raw () qui retourne exactement la même chaîne source que la fonction de modèle par défaut et la concaténation de chaîne retournerait ensemble. <br><cut></cut><br>  Dans ECMAScript 2016, les modèles balisés suivent les règles pour échapper les caractères suivants: <br><ul><li>  Caractères Unicode commençant par "\ u", par exemple, \ u00A9 </li><li>  Points de code Unicode commençant par "\ u {}", par exemple, \ u {2F804} </li><li>  représentations de caractères hexadécimaux commençant par "\ x", par exemple, \ xA9 </li><li>  représentations octales de caractères commençant par "\", par exemple, \ 251 </li></ul><br><cut></cut><br><a name="section002"></a><h2>  let et const </h2><br>  La portée des variables déclarées par les mots clés let et const est le bloc dans lequel elles sont déclarées, et tout cela sous les blocs.  En cela, le fonctionnement de la directive let est similaire à celui de la directive var.  La principale différence est que la portée de la variable déclarée par la directive var est la fonction entière dans laquelle elle est déclarée.  En plus des variables, la valeur des constantes ne peut pas être modifiée par une nouvelle affectation, ni redéfinie.  Lors de la déclaration d'une variable avec le mot clé const, vous devez utiliser l'opérateur d'affectation pour définir la valeur de la constante. <br><br>  Les constantes globales ne deviennent pas des propriétés de l'objet window, contrairement aux variables var. <br>  L'initialisation d'une constante est requise. <br>  Vous devez spécifier une valeur en même temps que la déclaration (le fait est qu'alors cette valeur ne peut plus être modifiée). <br>  La déclaration de variables avec le mot clé const crée une constante (une nouvelle référence nommée à une région de mémoire) qui est en lecture seule. <br>  Cela ne signifie pas que la valeur indiquée est inchangée, mais cela signifie que l'identifiant ne peut pas être réaffecté.  Par exemple, si une constante pointe vers un objet, l'objet lui-même peut être modifié. <br>  Les noms de constantes ne peuvent pas coïncider avec des noms de fonctions ou de variables de même étendue. <cut></cut><br><br>  Un exemple de la différence entre la portée globale et la portée de bloc: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a); <span class="hljs-comment"><span class="hljs-comment">//SyntaxError   a     if if (true) var b = 5; console.log(b); //5   b     }</span></span></code> </pre> <br><br><a name="section003"></a><h2>  Expressions de la fonction flèche </h2><br>  Les expressions de fonction de flèche ont une syntaxe plus courte que les expressions fonctionnelles et sont lexicalement liées à la valeur de this (mais pas liées à leur propre this, arguments, super ou new.target).  L'expression des fonctions fléchées ne vous permet pas de spécifier un nom, par conséquent les fonctions fléchées sont anonymes sauf si elles sont affectées à quoi que ce soit. <br><cut></cut><br>  <b>Syntaxe de base</b> <br><pre> <code class="javascript hljs">(param1, param2, …, paramN) =&gt; { statements } (param1, param2, …, paramN) =&gt; expression <span class="hljs-comment"><span class="hljs-comment">// : (param1, param2, …, paramN) =&gt; { return expression; } //       : (singleParam) =&gt; { statements } singleParam =&gt; { statements } //       : () =&gt; { statements } () =&gt; expression // : () =&gt; { return expression; }</span></span></code> </pre> <br><br>  <b>Syntaxe étendue</b> <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     ,     params =&gt; ({foo: bar}) // Rest       (param1, param2, ...rest) =&gt; { statements } (param1 = defaultValue1, param2, …, paramN = defaultValueN) =&gt; { statements } //    var f = ([a, b] = [1, 2], {x: c} = {x: a + b}) =&gt; a + b + c; f(); // 6</span></span></code> </pre> <br>  Vous trouverez plus d'informations sur les fonctions fléchées <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><a name="section004"></a><h2>  Pour ... de </h2><br>  L'instruction for ... of exécute une boucle à travers des objets itérables (y compris Array, Map, Set, un objet d'arguments et similaires), invoquant à chaque étape d'itération les opérateurs pour chaque valeur à partir de diverses propriétés de l'objet. <br><cut></cut><br>  Pourquoi NE DEVRAIT PAS utiliser une boucle for ... in pour itérer?  Parce que selon le moteur, JavaScript peut itérer dans un ordre aléatoire, ce qui peut conduire à des résultats imprévisibles.  Si une propriété change dans une itération, puis change à nouveau, sa valeur dans la boucle est sa dernière valeur.  Une propriété supprimée avant que le cycle ne l'atteigne n'y participera pas.  Les propriétés ajoutées aux objets de la boucle peuvent être ignorées.  En général, il est préférable de ne pas ajouter, modifier ou supprimer une propriété de l'objet pendant l'itération si vous ne l'avez pas déjà transmise.  Il n'y a aucune garantie que la propriété ajoutée sera visitée par le cycle, modifiée après les modifications et supprimée après la suppression.  De plus, la variable itérative est une chaîne et non un nombre, ce qui signifie que si vous souhaitez effectuer des calculs avec la variable, vous devrez concaténer les chaînes au lieu de les ajouter.  Donc, pour éviter les erreurs logiques, vous ne devez pas l'utiliser! <br><br>  Contrairement à la boucle for ... of, la boucle for ... in renvoie toutes les propriétés énumérées, y compris celles avec des noms non entiers et héritées. <br><br>  <b>Pour ... de la syntaxe de boucle</b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> arr) <span class="hljs-comment"><span class="hljs-comment">//for ( of ) arr[i] = "something value"</span></span></code> </pre> <br>  Exemples: <br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.objCustom = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}; <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype.arrCustom = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> iterable = [<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>]; iterable.foo = <span class="hljs-string"><span class="hljs-string">'hello'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> iterable) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i); <span class="hljs-comment"><span class="hljs-comment">// 0, 1, 2, "foo", "arrCustom", "objCustom" for (let i in iterable) { if (iterable.hasOwnProperty(i)) console.log(i); //  0, 1, 2, "foo" } for (let i of iterable) console.log(i); // 3, 5, 7</span></span></code> </pre><cut></cut><br>  Chaque objet héritera de la méthode objCustom et chaque tableau héritera de la méthode arrCustom en les créant dans Object.prototype et Array.prototype.  L'objet itérable héritera des méthodes objCustom et arrCustom en raison de l'héritage du prototype. <br><br>  La boucle affiche uniquement les propriétés énumérées de l'objet itérable, dans l'ordre dans lequel elles ont été créées.  Il n'imprime pas les valeurs 3, 5, 7 et bonjour car elles ne sont pas énumérables.  Les noms des propriétés et des méthodes sont affichés, par exemple, arrCustom et objCustom. <br><br>  La boucle est similaire à la précédente, mais utilise hasOwnProperty () pour vérifier si cette propriété de l'objet est la sienne ou héritée.  Seules les propriétés propres sont affichées.  Les noms 0, 1, 2 et foo n'appartiennent qu'à l'instance de l'objet (non hérité).  Les méthodes arrCustom et objCustom ne sont pas sorties car elles sont héritées. <br><br>  Cette boucle contourne l'itérable et affiche les valeurs de l'objet itérable qui sont définies dans la méthode d'itération, c'est-à-dire  pas les propriétés de l'objet, mais les valeurs du tableau 3, 5, 7. <br><br><a name="section005"></a><h2>  Noms de propriété calculés </h2><br>  La syntaxe de déclaration des objets et de leurs éléments prend en charge les noms de propriété calculés.  Cela vous permet d'ajouter une expression entre crochets [] qui sera évaluée comme le nom de la propriété.  Il ressemble aux littéraux de modèle. <br><br>  <b>Exemple de noms calculés:</b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">"world"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = { [<span class="hljs-string"><span class="hljs-string">"a"</span></span> + (<span class="hljs-number"><span class="hljs-number">10</span></span> - <span class="hljs-number"><span class="hljs-number">6</span></span>)]: { [<span class="hljs-string"><span class="hljs-string">"some"</span></span> + <span class="hljs-string"><span class="hljs-string">"string"</span></span>]: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, [<span class="hljs-number"><span class="hljs-number">10</span></span> + <span class="hljs-number"><span class="hljs-number">20</span></span>]: <span class="hljs-number"><span class="hljs-number">10</span></span>, [<span class="hljs-string"><span class="hljs-string">`hello </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${a()}</span></span></span><span class="hljs-string">`</span></span>]: a() } }</code> </pre> <br><cut></cut><br><br><a name="section006"></a><h2>  Object.assign () </h2><br>  La méthode Object.assign () est utilisée pour copier les valeurs de toutes ses propres propriétés énumérées d'un ou plusieurs objets source vers l'objet cible.  Après la copie, il renvoie l'objet cible. <br><br>  La méthode Object.assign () copie uniquement les propriétés énumérées et natives des objets source vers l'objet cible.  Il utilise la méthode interne [[Get]] sur les objets source et la méthode interne [[Set]] sur l'objet cible, il appelle donc également les getters et setters.  C'est pourquoi il attribue des propriétés au lieu de simplement copier ou définir de nouvelles propriétés.  Ce comportement peut rendre la méthode inappropriée pour injecter de nouvelles propriétés dans le prototype si les objets source injectés contiennent des getters.  Au lieu de cela, pour copier des prototypes de définitions de propriétés, y compris un signe de leur énumération, les méthodes Object.getOwnPropertyDescriptor () et Object.defineProperty () doivent être utilisées. <br><br>  Les propriétés des types de chaîne et de symbole sont copiées. <br><br>  En cas d'erreur, par exemple, lorsque la propriété n'est pas accessible en écriture, une exception TypeError est levée et l'objet cible reste inchangé. <br><br>  Notez que la méthode Object.assign () ne lève pas d'exception si les valeurs initiales sont nulles ou non définies. <br><br>  <b>Exemple: clonage d'un objet</b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> copy = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign({}, obj); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(copy); <span class="hljs-comment"><span class="hljs-comment">// { a: 1 }</span></span></code> </pre> <br>  <b>Exemple: fusion d'objets</b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o1 = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o2 = { <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o3 = { <span class="hljs-attr"><span class="hljs-attr">c</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign(o1, o2, o3); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj); <span class="hljs-comment"><span class="hljs-comment">// { a: 1, b: 2, c: 3 } console.log(o1); // { a: 1, b: 2, c: 3 },     .</span></span></code> </pre> <br><br><a name="section007"></a><h2>  Paramètres de repos </h2><br>  La syntaxe des autres paramètres de la fonction vous permet de représenter un ensemble illimité d'arguments sous la forme d'un tableau. <br><br>  Si le dernier argument de fonction nommé a un préfixe ..., il devient automatiquement un tableau avec des éléments de 0 à theArgs.length en fonction du nombre réel d'arguments passés à la fonction. <br><br>  <b>Syntaxe</b> <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b, ...theArgs</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><br>  <b>Un exemple d'utilisation de la syntaxe des paramètres restants:</b> <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">name</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b, ...c</span></span></span><span class="hljs-function">) </span></span>{} name (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>,)</code> </pre> <br>  Dans cet exemple, a = 0 b = 1 c [0] = 2 c [1] = 3 <br>  Si le paramètre restant n'est pas transmis, ce sera un tableau vide (contrairement aux paramètres ordinaires, il ne sera jamais indéfini). <br><br>  Cette syntaxe peut être utilisée non seulement dans les arguments de fonction, mais également à d'autres endroits, par exemple, pour copier et combiner des tableaux: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = [ <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = [ <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c = [ ...a, ...b ]; <span class="hljs-comment"><span class="hljs-comment">// [ 0, 1, 2, 3, 4, 5 ]</span></span></code> </pre> <br><br><a name="section008"></a><h2>  Paramètres par défaut </h2><br>  Les paramètres par défaut vous permettent de définir des paramètres de fonction formels sur des valeurs par défaut si la fonction est appelée sans arguments ou si le paramètre est explicitement transmis non défini. <br><br>  En JavaScript, les paramètres d'une fonction qui ne reçoivent pas de valeurs lors de son appel prennent la valeur par défaut non définie.  Cependant, dans certains cas, il peut être utile de définir une valeur par défaut différente.  C'est dans de tels cas que les paramètres par défaut sont prévus. <br><br>  La valeur par défaut n'est affectée à un paramètre formel que si, lors d'un appel de fonction, la valeur de ce paramètre n'a pas été transmise ou non définie a été explicitement transmise. <br><br>  <b>Un exemple d'utilisation des paramètres par défaut:</b> <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFun</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5</span></span></span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a*a; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myFun()); <span class="hljs-comment"><span class="hljs-comment">// 25</span></span></code> </pre> <cut></cut><br><br><a name="section009"></a><h2>  Mission de restructuration </h2><br>  La syntaxe de déstructuration des affectations dans les expressions JavaScript vous permet de récupérer des données à partir de tableaux ou d'objets à l'aide d'une syntaxe similaire à la déclaration d'un tableau ou de littéraux dans un objet. <br><br>  Les expressions de déclaration d'objets ou de tableaux fournissent un moyen simple de créer un ensemble de données homogènes.  Lors de la création d'un tel package, vous avez la possibilité de l'utiliser de toutes les manières possibles.  Vous pouvez également le retourner dans les fonctions. <br><br>  L'une des principales façons d'utiliser l'affectation destructive est de lire la structure de données avec un seul opérateur, bien que vous puissiez trouver de nombreuses autres utilisations en plus de cela. <br><br>  <b>Exemple d'affectation destructrice:</b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a, b, rest; [a, b] = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a); <span class="hljs-comment"><span class="hljs-comment">// 1 console.log(b); // 2 [a, b, ...rest] = [1, 2, 3, 4, 5]; console.log(a); // 1 console.log(b); // 2 console.log(rest); // [3, 4, 5] ({a, b} = {a:1, b:2}); console.log(a); // 1 console.log(b); // 2</span></span></code> </pre> <br>  Vous pouvez voir plus d'exemples <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><a name="section010"></a><h2>  La carte </h2><br>  Map - Un objet contenant des paires clé-valeur et préservant l'ordre d'insertion.  Toute valeur (objets et primitives) peut être utilisée comme clé. <br><br>  <b>Un exemple:</b> <cut></cut><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myMap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> keyObj = {}, keyFunc = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}, keyString = <span class="hljs-string"><span class="hljs-string">"a string"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   myMap.set(keyString, "value associated with 'a string'"); myMap.set(keyObj, "value associated with keyObj"); myMap.set(keyFunc, "value associated with keyFunc"); myMap.size; // 3 //   myMap.get(keyString); // "value associated with 'a string'" myMap.get(keyObj); // "value associated with keyObj" myMap.get(keyFunc); // "value associated with keyFunc" myMap.get("a string"); // "value associated with 'a string'" //   keyString === 'a string' myMap.get({}); // undefined,   keyObj !== {} myMap.get(function() {}) // undefined,   keyFunc !== function () {}</span></span></code> </pre> <br>  <b>Différence de la carte de l'objet:</b> <br><br><ul><li>  Les clés d'objet sont des lignes et des symboles, tandis que toute valeur peut être une clé de carte, y compris des fonctions, des objets et des primitives. </li><li>  Contrairement aux objets, les clés de la carte sont ordonnées.  Ainsi, lors de l'itération Map, les clés sont retournées dans l'ordre d'insertion. </li><li>  Vous pouvez facilement obtenir le nombre d'éléments dans une carte à l'aide de la propriété size, tandis que le nombre d'éléments dans un objet ne peut être déterminé que manuellement. </li><li>  La carte est un objet itérable et peut être itéré directement, tandis que l'objet nécessite la réception manuelle de la liste des clés et de leur itération. </li><li>  L'objet a un prototype et a donc un jeu de clés standard qui, s'il est imprudent, peut croiser vos clés.  Depuis la sortie d'ES5, cela peut être changé en utilisant map = Object.create (null). </li><li>  La carte peut avoir de meilleures performances en cas d'ajout ou de suppression fréquents de clés. </li></ul><cut></cut><br>  <b>Propriétés et méthodes:</b> <br><br><ul><li>  Map.prototype.size - Renvoie le nombre de paires clé / valeur sur une carte </li><li>  Map.prototype.set (clé, valeur) - Ajoute la paire clé \ valeur transmise à la carte.  Si la clé spécifiée existe déjà, elle sera remplacée par la nouvelle valeur. </li><li>  Map.prototype.get (key) - Renvoie la valeur de la clé transmise.  S'il n'y a pas de clé, alors undefined reviendra </li><li>  Map.prototype.has (key) - Renvoie true si la clé transmise existe et false dans le cas contraire </li><li>  Map.prototype.delete (key) - Supprime la paire clé / valeur spécifiée et renvoie true.  Renvoie false si la clé n'existe pas. </li><li>  Map.prototype.clear () - Supprime toutes les paires clé / valeur de la carte </li><li>  Map.prototype.keys () - Retourne un itérateur de clés sur une carte pour chaque élément </li><li>  Map.prototype.values ​​() - Retourne un itérateur de valeurs sur la carte pour chaque élément </li><li>  Map.prototype.entries () - Retourne un itérateur du tableau [clé, valeur] sur la carte pour chaque élément </li></ul><cut></cut><br><br><a name="section011"></a><h2>  Ensemble </h2><br>  Vous permet d'enregistrer des valeurs uniques de tout type, à la fois des primitives et d'autres types d'objets. <br><br>  Les objets Set représentent des collections de valeurs que vous pouvez parcourir dans l'ordre dans lequel les éléments sont insérés.  La valeur d'un élément dans Set ne peut être présente que dans une seule instance, ce qui garantit son caractère unique dans la collection Set. <br><br>  Ensemble de propriétés et de méthodes d'instance <br><ul><li>  size - Renvoie le nombre d'éléments dans l'objet Set. </li><li>  add (value) - Ajoute un nouvel élément avec la valeur donnée à l'objet Set.  Renvoie un objet Set. </li><li>  clear () - Supprime tous les éléments de l'objet Set. </li><li>  delete (value) - Supprime l'élément associé à la valeur et renvoie la valeur que (value) renverrait précédemment.  has (value) retournera false plus tard. </li><li>  entries () - Renvoie un nouvel objet Iterator qui contient un tableau de [valeur, valeur] pour chaque élément de l'objet Set dans l'ordre d'insertion.  Il est stocké de manière similaire à l'objet Map, donc chaque entrée a la même valeur pour sa clé et sa valeur ici. </li><li>  forEach (callbackFn [, thisArg]) - Appelle callbackFn une fois pour chaque valeur présente dans l'objet Set, dans l'ordre d'insertion.  Si thisArg est spécifié pour thisEach, il sera utilisé comme valeur this pour chaque rappel. </li><li>  has (value) - Retourne une valeur booléenne confirmant si l'élément avec la valeur donnée est présent ou non dans l'objet Set. </li><li>  values ​​() - Renvoie un nouvel objet Iterator qui contient les valeurs de chaque élément de l'objet Set dans l'ordre d'insertion. </li></ul><br>  <b>Utilisation de l'objet Set</b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mySet = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span>(); mySet.add(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Set { 1 } mySet.add(5); // Set { 1, 5 } mySet.add(5); // Set { 1, 5 } mySet.add("some text"); // Set { 1, 5, 'some text' } var o = {a: 1, b: 2}; mySet.add(o); mySet.add({a: 1, b: 2}); //  o    ,      mySet.has(1); // true mySet.has(3); // false, 3     set mySet.has(5); // true mySet.has(Math.sqrt(25)); // true mySet.has("Some Text".toLowerCase()); // true mySet.has(o); // true mySet.size; // 5 mySet.delete(5); //  5  set mySet.has(5); // false, 5   mySet.size; // 4,     console.log(mySet); // Set {1, 'some text', Object {a: 1, b: 2}, Object {a: 1, b: 2}}</span></span></code> </pre> <br>  <b>Ensemble de dérivation</b> <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    : 1, "some text", {"a": 1, "b": 2} for (let item of mySet) console.log(item); //    : 1, "some text", {"a": 1, "b": 2} for (let item of mySet.keys()) console.log(item); //    : 1, "some text", {"a": 1, "b": 2} for (let item of mySet.values()) console.log(item); //    : 1, "some text", {"a": 1, "b": 2} //(key  value    ) for (let [key, value] of mySet.entries()) console.log(key); //  Set  Array var myArr = Array.from(mySet); // [1, "some text", {"a": 1, "b": 2}] //       HTML  mySet.add(document.body); mySet.has(document.querySelector("body")); // true //   Array  Set   mySet2 = new Set([1,2,3,4]); mySet2.size; // 4 [...mySet2]; // [1,2,3,4] //      var intersection = new Set([...set1].filter(x =&gt; set2.has(x))); //      var difference = new Set([...set1].filter(x =&gt; !set2.has(x))); //   set   forEach mySet.forEach(function(value) { console.log(value); }); // 1 // 2 // 3 // 4</span></span></code> </pre> <br><cut></cut><br><br><a name="section012"></a><h2>  Cours </h2><br>  Les classes en JavaScript ont été introduites dans ECMAScript 2015 et sont du sucre syntaxique sur l'héritage de prototype en JavaScript.  La syntaxe de classe n'introduit pas de nouveau modèle orienté objet, mais fournit un moyen plus simple et plus intuitif de créer des objets et d'organiser l'héritage. <br><br>  Les classes sont en fait des «fonctions spéciales», donc tout comme vous définissez des fonctions (expressions de fonction et déclarations de fonction), vous pouvez définir des classes avec: des déclarations de classe et des expressions de classe. <br><br>  La différence entre une déclaration de fonction et une déclaration de classe est qu'une déclaration de fonction est hissée, tandis qu'une déclaration de classe ne l'est pas.  Par conséquent, vous devez d'abord déclarer votre classe et ensuite travailler avec elle, sinon une exception de type ReferenceError sera levée. <br><cut></cut><br><h4>  Déclaration de classe </h4><br>  La première façon de définir une classe consiste à utiliser une déclaration de classe.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour ce faire, utilisez le mot clé class et spécifiez le nom de la classe (dans l'exemple, «myClass»). </font></font><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">myClass</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(height, width) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height = height; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.width = width; } }</code> </pre> <cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La deuxième façon de définir une classe est l'expression de classe. </font><font style="vertical-align: inherit;">Vous pouvez créer des expressions nommées et sans nom. </font><font style="vertical-align: inherit;">Dans le premier cas, le nom de l'expression de classe se trouve dans la portée locale de la classe et peut être obtenu via les propriétés de la classe elle-même, et non son instance.</font></font><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  var myClass = class { constructor(height, width) { this.height = height; this.width = width; } }; //  var myClass = class myClass { constructor(height, width) { this.height = height; this.width = width; } };</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les expressions de classe sont sujettes aux mêmes problèmes de levage que les déclarations de classe! </font></font><cut></cut><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les corps de déclaration de classe et les expressions de classe sont exécutés en mode strict. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le mode strict modifie la syntaxe et le comportement du runtime. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour être plus précis, le mode strict se caractérise par les éléments suivants:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Convertir les erreurs en exceptions </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> des changements qui simplifient le calcul d'une variable dans certains cas d'utilisation de son nom; </font></font></li><li> ,  eval  arguments; </li><li> ,   «» JavaScript; </li></ul><br> <b>   </b> <br><ol><li>        . </li><li>     . </li><li> ,      ,  . </li><li>        (           ). </li><li>  ,    ,     .       ,      . </li><li>         .             . </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La syntaxe du système numérique octal est interdite. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La définition de propriétés avec des valeurs primitives est interdite. </font></font></li></ol><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simplification du travail avec les variables</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le mode strict simplifie la comparaison du nom de variable avec la place de sa définition dans le code.</font></font><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'utilisation avec est interdite. </font><font style="vertical-align: inherit;">Le problème avec est qu'au moment de l'exécution, tout nom à l'intérieur du bloc peut faire référence à une propriété de l'objet en cours de traitement ou à une variable dans le contexte environnant (ou même global) - il est impossible de le savoir à l'avance. </font><font style="vertical-align: inherit;">Une alternative simple avec existe déjà - assigner l'objet à une variable avec un nom court puis accéder à la propriété souhaitée en tant que propriété de cette variable.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eval () en mode strict n'ajoute pas de nouvelles variables au contexte environnant. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Il est interdit de supprimer des noms simples. </font></font></li></ol><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simplification de l'eval et des arguments</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le mode strict réduit le nombre de bizarreries dans le comportement des arguments et de l'eval, qui mélangent tous les deux une certaine quantité de magie en code normal. </font><font style="vertical-align: inherit;">Donc, eval ajoute ou supprime des variables et modifie leurs valeurs, et la variable arguments peut vous surprendre avec ses propriétés indexées, qui sont des références (synonymes) pour les arguments des fonctions nommées.</font></font><cut></cut><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les mots clés eval et les arguments ne peuvent pas être remplacés ou modifiés. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les champs de l'objet arguments ne sont pas associés aux arguments de la fonction nommée, mais sont leurs copies dupliquées des valeurs. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La propriété arguments.callee n'est pas prise en charge. </font><font style="vertical-align: inherit;">Dans le code normal, la propriété arguments.callee fait référence à la fonction elle-même, pour l'invocation dont l'objet arguments a été créé.</font></font></li></ol><cut></cut><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JavaScript «sécurisé»</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Certains sites Web offrent aux utilisateurs la possibilité d'écrire du JavaScript qui sera exécuté sur le site au nom d'autres utilisateurs. </font><font style="vertical-align: inherit;">Dans les navigateurs, JavaScript peut avoir accès à des informations privées, ce qui constitue une faille de sécurité dans JavaScript.</font></font><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La valeur transmise à la fonction car elle n'est pas convertie en objet en mode strict. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Il n'est pas possible de «lancer» la pile JavaScript via les extensions ECMAScript de base. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dans les fonctions, la propriété arguments ne donne plus accès aux variables créées à l'intérieur de la fonction. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez consulter </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la spécification</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ECMAScript 5.1 pour en savoir plus sur le mode strict. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et aussi la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de Mozilla.</font></font><br><cut></cut><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Constructeurs </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> constructeur est une méthode spéciale utilisée pour créer et initialiser des objets créés à l'aide de la classe. </font></font><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Student</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> robert = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Student(<span class="hljs-string"><span class="hljs-string">'Robert'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(robert.name); <span class="hljs-comment"><span class="hljs-comment">// Outputs 'Robert'</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors de la création de nouveaux objets à partir de la classe, constructor () sera lancé, ce qui est nécessaire pour initialiser les objets. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il ne peut y avoir qu'une seule méthode dans une classe appelée constructeur. </font><font style="vertical-align: inherit;">Si la classe contient plusieurs constructeurs, une exception SyntaxError sera levée. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le super mot-clé peut être utilisé dans le constructeur pour appeler le constructeur de la classe parente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous n'avez pas défini de méthode constructeur, le constructeur par défaut sera utilisé. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour les classes de base, le constructeur par défaut est:</font></font><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() {}</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour les classes dérivées, le constructeur par défaut est: </font></font><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(...args) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(...args); }</code> </pre> <br><cut></cut><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les méthodes </font></font></h4><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Syntaxe de déclaration de méthode:</font></font></b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { property([parameters]) {}, get property() {}, set property(value) {}, * generator() {} };</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abréviation des méthodes de générateur</font></font></b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { * g() { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> index = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> index++; } }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> it = obj.g(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(it.next().value); <span class="hljs-comment"><span class="hljs-comment">// 0 console.log(it.next().value); // 1</span></span></code> </pre> <br><cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Toutes les définitions de méthode, à l'exception des méthodes de générateur, ne peuvent pas être des constructeurs et lèveront une TypeError si vous essayez de les instancier. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Noms de propriété calculés</font></font></b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { [<span class="hljs-string"><span class="hljs-string">"foo"</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>](){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj.foo2()); <span class="hljs-comment"><span class="hljs-comment">// 2 };</span></span></code> </pre> <br><cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le mot clé statique définit des méthodes statiques pour une classe. </font><font style="vertical-align: inherit;">Les méthodes statiques sont appelées sans instancier leur classe et ne peuvent pas être appelées sur des instances de la classe.</font></font><br><cut></cut><cut></cut><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Syntaxe des getters et setters</font></font></b> <br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Student</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } get Name() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name; } set Name(newName) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(newName) != <span class="hljs-string"><span class="hljs-string">"string"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Name is not a string!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = newName; <span class="hljs-comment"><span class="hljs-comment">// Robert } } var robert = new Student('robert'); robert.Name = "Robert"; console.log(robert.Name);</span></span></code> </pre> <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> setter - Requis pour la validation des paramètres écrits (comme dans l'exemple ci-dessus) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">getter - Nécessaire pour obtenir des propriétés (bien qu'elles puissent être obtenues directement). </font><font style="vertical-align: inherit;">Ne peut pas avoir d'arguments</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Il n'y a pas d'encapsulation intégrée dans ES6, mais vous pouvez l'organiser vous-même. </font></font> Par exemple, comme ceci: <br><cut></cut><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Student = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> privateProps = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">WeakMap</span></span>(); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name, Age) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; <span class="hljs-comment"><span class="hljs-comment">// public privateProps.set(this, {age: Age}); // private } get Age() { return privateProps.get(this).age; } set Age (newAge) { privateProps.set(this, {age: newAge}); } } return Person; })(); var robert = new Student('Robert', 19); robert.Age = 20; console.log(robert.Age); // 20</span></span></code> </pre> <br><cut></cut><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Héritage </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le mot clé extend est utilisé dans les déclarations de classe et les expressions de classe pour créer une classe qui est un enfant d'une autre classe. </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span> (age) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.age = age; } sayAge () { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.age; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Student</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span> (name, age) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(age); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } sayFull () { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`Hello my name is </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.name}</span></span></span><span class="hljs-string"> and I'm </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.sayAge()}</span></span></span><span class="hljs-string"> years old`</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> robert = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Student(<span class="hljs-string"><span class="hljs-string">"Robert"</span></span>, <span class="hljs-number"><span class="hljs-number">19</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(robert.sayFull()); <span class="hljs-comment"><span class="hljs-comment">// Hello my name is Robert and I'm 19 years old</span></span></code> </pre> <br><cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans le constructeur, le mot clé super () est utilisé comme une fonction qui appelle le constructeur parent. </font><font style="vertical-align: inherit;">Il doit être appelé avant le premier appel au mot-clé this dans le corps du constructeur. </font><font style="vertical-align: inherit;">Le super mot-clé peut également être utilisé pour appeler des fonctions de l'objet parent. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque vous substituez les méthodes de la classe parent dans la classe enfant, les méthodes de la classe enfant seront appelées par défaut, mais vous pouvez appeler explicitement les méthodes de la classe parent à l'aide de la fonction super ().</font></font><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">obj</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } displayName(){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name.length; } } <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">obj_2</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">obj</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(name); } displayName() { <span class="hljs-comment"><span class="hljs-comment">//     return [this.name, super.displayName()]; } } var Obj = new obj_2("obj_2"); console.log(Obj.displayName()); // Array [ "obj_2", 5 ]</span></span></code> </pre><cut></cut><br><cut></cut><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Extension d'objets en ligne avec extend</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cet exemple étend un objet Date en ligne.</font></font><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">myDate</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Date</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); } getFormattedDate() { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> months = [ <span class="hljs-string"><span class="hljs-string">'Jan'</span></span>, <span class="hljs-string"><span class="hljs-string">'Feb'</span></span>, <span class="hljs-string"><span class="hljs-string">'Mar'</span></span>, <span class="hljs-string"><span class="hljs-string">'Apr'</span></span>, <span class="hljs-string"><span class="hljs-string">'May'</span></span>, <span class="hljs-string"><span class="hljs-string">'Jun'</span></span>, <span class="hljs-string"><span class="hljs-string">'Jul'</span></span>, <span class="hljs-string"><span class="hljs-string">'Aug'</span></span>, <span class="hljs-string"><span class="hljs-string">'Sep'</span></span>, <span class="hljs-string"><span class="hljs-string">'Oct'</span></span>, <span class="hljs-string"><span class="hljs-string">'Nov'</span></span>, <span class="hljs-string"><span class="hljs-string">'Dec'</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getDate() + <span class="hljs-string"><span class="hljs-string">'-'</span></span> + months[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getMonth()] + <span class="hljs-string"><span class="hljs-string">'-'</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getFullYear(); } }</code> </pre> <br><br><a name="section013"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Promesse </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'objet Promise est utilisé pour les calculs différés et asynchrones. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La promesse peut être dans trois états:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en attente: état initial, non terminé et non rejeté. </font></font></li><li>  (fulfilled):   . </li><li>  (rejected):    . </li></ul><br>       (pending),      (fulfilled),    (),   (rejected),   .       ,     then. (         ,     , ..           « », , ,      DOM.) <br><br>    Promise.prototype.then()  Promise.prototype.catch()   ,    ,  . <br><img src="https://habrastorage.org/getpro/habr/post_images/835/119/a5c/835119a5c72db92a1ae89730a7af1251.png" alt="image"><br><br> <b>  (promise)</b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un objet Promise est créé à l'aide du nouveau mot clé et de son constructeur. </font><font style="vertical-align: inherit;">Le constructeur Promise prend comme argument un argument appelé fonction exécuteur. </font><font style="vertical-align: inherit;">Cette fonction doit accepter deux fonctions de rappel comme paramètres. </font><font style="vertical-align: inherit;">La première (résolution) est appelée lorsque l'opération asynchrone s'est terminée avec succès et a renvoyé le résultat de son exécution en tant que valeur. </font><font style="vertical-align: inherit;">Le deuxième rappel (rejet) est appelé lorsque l'opération a échoué et renvoie une valeur indiquant la raison de l'échec, le plus souvent un objet d'erreur.</font></font><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   ,    : resolve(someValue); //   //  reject("failure reason"); //  });</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un objet fonction avec deux arguments, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">résoudre</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rejeter,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fait réussir la promesse; le second la rejette. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour fournir à la fonction la fonctionnalité de promesse, il vous suffit de lui renvoyer l'objet Promise.</font></font><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myAsyncFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> xhr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest(); xhr.open(<span class="hljs-string"><span class="hljs-string">"GET"</span></span>, url); xhr.onload = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(xhr.responseText); xhr.onerror = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> reject(xhr.statusText); xhr.send(); }); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilisation. </font><font style="vertical-align: inherit;">puis les gestionnaires d'exécution et de rejet sont associés.</font></font><br><cut></cut><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les méthodes</font></font></b> <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promise.all (itérable) - Attend que toutes les promesses soient exécutées ou rejetées pour l'une d'entre elles. </font><font style="vertical-align: inherit;">Renvoie une promesse qui sera exécutée une fois toutes les promesses exécutées en itérable. </font><font style="vertical-align: inherit;">Dans le cas où l'une des promesses est rejetée, Promise.all sera également rejetée.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promise.allSettled (itérable) - Attend la fin de toutes les promesses reçues (à la fois l'exécution et le rejet). </font><font style="vertical-align: inherit;">Renvoie une promesse qui est exécutée lorsque toutes les promesses reçues sont terminées (exécutées ou rejetées), contenant un tableau des résultats de l'exécution des promesses reçues.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promise.race (itérable) - Attend l'exécution ou le rejet de l'une des promesses reçues. </font><font style="vertical-align: inherit;">Renvoie une promesse qui sera exécutée ou rejetée avec le résultat de l'exécution de la première promesse exécutée ou rejetée de .iterable.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Promise.reject (reason) - Renvoie une promesse rejetée pour raison. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Promise.resolve (value) - Renvoie la promesse exécutée avec la valeur de résultat. </font></font></li></ul><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promise Prototype</font></font></b> <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> catch (onRejected) - Ajoute une fonction de rappel pour gérer le rejet d'une promesse, qui renvoie une nouvelle promesse faite avec la valeur transmise si elle est appelée, ou la valeur de résolution d'origine si la promesse est faite. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> then (onFulfilled, onRejected) - Ajoute un gestionnaire de réalisation et de rejet de promesse, et renvoie une nouvelle promesse exécutée avec la valeur du gestionnaire appelé, ou la valeur d'origine si la promesse n'a pas été traitée (c'est-à-dire si le gestionnaire onFulfilled ou onRejected correspondant n'est pas une fonction). </font></font></li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Création d'une requête http asynchrone: </font></font><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> URL = <span class="hljs-string"><span class="hljs-string">"https://getfestivo.com/v1/holidays?api_key=f8f42551-eb66-49d2-bcba-b8e42727ddfb&amp;country=US&amp;year=2019"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  API      function asyncHttpRequest (url) { return new Promise((resolve, reject) =&gt; { //  promise if (url == undefined) //     url reject(new Error("Expected url and received nothing")); else { resolve(() =&gt; { fetch(url).then((response) =&gt; { //   return response.json(); //    JSON   }).then((myJson) =&gt; { return(console.log(myJson)); //      }); }); } } );} asyncHttpRequest(URL).then((result) =&gt; result(), (error) =&gt; console.log(error));</span></span></code> </pre> <br><cut></cut><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez obtenir plus d'exemples et d'informations sur les promesses dans la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> officielle </font><font style="vertical-align: inherit;">, ainsi que dans la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documentation de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mozilla </font><font style="vertical-align: inherit;">.</font></font><br><br><a name="section014"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Itérateurs </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le traitement de chaque élément d'une collection est une opération très courante. JavaScript offre plusieurs façons d'itérer sur une collection, d'une simple boucle for à map (), filter () et des compréhensions de tableau. Les itérateurs et les générateurs implémentent le concept d'énumération directement dans le cœur du langage et fournissent un mécanisme pour définir le comportement pour ... des boucles. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un objet est un itérateur s'il peut accéder aux éléments de la collection un par un, tout en suivant sa position actuelle dans cette séquence. En JavaScript, un itérateur est un objet qui fournit une méthode next () qui renvoie l'élément suivant d'une séquence. Cette méthode renvoie un objet avec deux propriétés: done et value. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une fois créé, l'objet itérateur peut être utilisé explicitement en appelant la méthode next ().</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iterable - Il s'agit d'un objet dont le contenu peut être itéré. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'objet itérable diffère de l'objet non itérable en ce qu'il a une méthode spéciale qui renvoie un objet d'accès auquel un symbole spécial est utilisé: Symbol.iterator</font></font><br><pre> <code class="javascript hljs">Iterable { [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.iterator]() }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'objet qui renvoie la méthode est officiellement appelé un itérateur. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'itérateur n'a qu'une seule méthode next ()</font></font><br><pre> <code class="javascript hljs">Iterator { next(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Qui retourne un objet (appelons-le itreratorResult) avec deux propriétés done et value </font></font><br><pre> <code class="javascript hljs">IteratorResult { done, value }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> done indique s'il y a encore une valeur dans la séquence recherchée, et la valeur contient l'élément suivant de la séquence. </font></font><br><cut></cut><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Après l'initialisation, la méthode next () peut être appelée pour accéder une par une aux paires clé-valeur de l'objet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un objet est itérable s'il définit une méthode d'énumération des valeurs, c'est-à-dire, par exemple, comment les valeurs sont énumérées dans la construction for..of. </font><font style="vertical-align: inherit;">Certains types intégrés, tels que Array ou Map, sont itérables par défaut, tandis que d'autres types, tels que Object, ne le sont pas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour être itérable, un objet doit implémenter la méthode itérateur, ce qui signifie qu'il (ou l'un des objets de la chaîne prototype) doit avoir une propriété appelée Symbol.iterator. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voici à quoi ressemble l'itérateur standard:</font></font><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeIterator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">array</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nextIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nextIndex &lt; array.length ? { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: array[nextIndex++], <span class="hljs-attr"><span class="hljs-attr">done</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> } : { <span class="hljs-attr"><span class="hljs-attr">done</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; } } }</code> </pre> <br><br><a name="section015"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Générateurs </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les générateurs sont un type spécial de fonction qui fonctionne comme une usine d'itérateurs. </font><font style="vertical-align: inherit;">Une fonction devient un générateur si elle contient une ou plusieurs instructions yield et utilise la syntaxe function *.</font></font><br><cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les générateurs sont un nouveau type de fonction qui peut suspendre son exécution et retourner un résultat intermédiaire et reprendre l'exécution plus tard. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regardons une fonction régulière qui fait des calculs et renvoie un résultat:</font></font><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunction</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">) </span></span>{ a = a*<span class="hljs-number"><span class="hljs-number">2</span></span>; a = a - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myFunction(<span class="hljs-number"><span class="hljs-number">5</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// 9</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetez maintenant un œil à une fonction de générateur similaire: </font></font><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">) </span></span>{ a = a*<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> a; a = a - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> a; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> it = generator(<span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(it.next().value); <span class="hljs-comment"><span class="hljs-comment">// 10 console.log(it.next().value); // 9&lt;/i&gt;</span></span></code> </pre> <cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme indiqué précédemment, les générateurs peuvent suspendre leur exécution et retourner un résultat intermédiaire. Cet exemple montre qu'au moment du premier appel, la fonction comme si elle suspend son exécution sur le premier point d'arrêt donne et renvoie le résultat de la première expression. Dans le deuxième appel, la fonction continue du point d'arrêt précédent et passe au suivant, renvoyant le résultat de l'expression suivante. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les générateurs de fonctions fournissent un outil puissant pour écrire des fonctions séquentielles complexes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les générateurs calculent les résultats de leurs expressions de rendement à la demande, ce qui leur permet de travailler efficacement avec des séquences à haute complexité de calcul, voire des séquences infinies.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La méthode next () prend également une valeur qui peut être utilisée pour modifier l'état interne du générateur. La valeur passée à next () sera considérée comme le résultat de la dernière expression de rendement qui a interrompu le générateur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez forcer le générateur à lever une exception en appelant sa méthode throw () et en transmettant la valeur de l'exception qui doit être levée en tant que paramètre. Cette exception sera levée à partir du contexte de pause actuel du générateur comme si l'instruction de rendement en pause actuelle était une instruction throw. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si l'instruction yield ne se produit pas lors du traitement de l'exception levée, l'exception est transmise ci-dessus via l'appel throw (), et le résultat des appels suivants à next () sera la propriété done égale à true.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les générateurs ont une méthode return (value) qui renvoie la valeur donnée et arrête le générateur. </font></font><br><br><a name="section016"></a><h2>  Symbole </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le symbole est un type de données primitif dont les instances sont uniques et immuables. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans le runtime JavaScript, une valeur de «symbole» est créée en appelant la fonction Symbol (), qui crée dynamiquement une valeur anonyme et unique. </font><font style="vertical-align: inherit;">La seule utilisation raisonnable consiste à enregistrer le caractère, puis à utiliser la valeur stockée pour créer la propriété de l'objet.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsqu'un caractère est utilisé comme identificateur dans une affectation de propriété, la propriété (par exemple, un caractère) est anonyme; </font><font style="vertical-align: inherit;">et aussi non dénombrable. </font><font style="vertical-align: inherit;">Étant donné que la propriété n'est pas calculable, elle ne sera pas affichée dans la boucle "pour (... dans ...)" et, comme la propriété est anonyme, elle ne sera pas affichée dans le tableau de résultats "Object.getOwnPropertyNames ()". </font><font style="vertical-align: inherit;">Cette propriété est accessible en utilisant la valeur initiale du symbole qui l'a créée, ou en itérant via le tableau de résultats «Object.getOwnPropertySymbols ()».</font></font><br><br><cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vous pouvez donc créer une propriété de caractère: </font></font><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Alex"</span></span>, [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">"password"</span></span>)]: <span class="hljs-string"><span class="hljs-string">"12hsK3I"</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour obtenir un tableau d'objets de caractère, utilisez la propriété Object.getOwnPropertySymbols (obj); </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour accéder n'importe où dans votre code, utilisez les méthodes Symbol.for () et Symbol.keyFor (). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour plus d'informations sur le type de données Sumbol, consultez la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> officielle </font><font style="vertical-align: inherit;">, ainsi que la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mozilla.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr460741/">https://habr.com/ru/post/fr460741/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr460729/index.html">Agréable et utile dans l'enseignement</a></li>
<li><a href="../fr460731/index.html">Les autorités américaines achèvent une enquête sur un accident de bus robotisé en 2017</a></li>
<li><a href="../fr460735/index.html">CI \ CD pour les startups: quels outils existe-t-il et pourquoi pas seulement les grandes entreprises bien connues les utilisent</a></li>
<li><a href="../fr460737/index.html">Écoutez le contexte: podcasts de gestion de projet</a></li>
<li><a href="../fr460739/index.html">Nous sommes venus en paix de toute l'humanité</a></li>
<li><a href="../fr460743/index.html">Guide du débutant Flutter</a></li>
<li><a href="../fr460745/index.html">Expérience dans l'utilisation d'un module GSM en domotique</a></li>
<li><a href="../fr460747/index.html">Rechercher des profits ou resserrer les noix: Spotify a cessé de travailler directement avec les auteurs - qu'est-ce que cela signifie</a></li>
<li><a href="../fr460751/index.html">Comment nous avons lancé des robots dans le petit Tchernobyl. Partie 1</a></li>
<li><a href="../fr460755/index.html">Robot Trolley ROS - Partie 1: Fer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>