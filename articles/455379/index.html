<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游뱣游낗 游쓇릞 游둣游낕 (Est치tica) Selecci칩n de contenedores 칩ptimos en programas C ++ 游늶 游붂 游녧游낖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Hoy me gustar칤a volver a hablar sobre el an치lisis est치tico. Y nuevamente sobre C ++. Solo, a diferencia de PVS-Studio, no buscaremos ning칰n error...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>(Est치tica) Selecci칩n de contenedores 칩ptimos en programas C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455379/">  Hola  Hoy me gustar칤a volver a hablar sobre el an치lisis est치tico.  Y nuevamente sobre C ++.  Solo, a diferencia de PVS-Studio, no buscaremos ning칰n error en nuestros programas (aunque no solo busquen errores), sino tambi칠n lugares que no est칠n escritos de manera 칩ptima.  Y uno de estos lugares es elegir un contenedor para los datos en el programa.  Si estoy interesado en ti, 춰entonces bienvenido a cat! <br><a name="habracut"></a><br><h3>  El problema </h3><br>  En CoreHard 2018 Autumn (una muy buena conferencia, venga) habl칠 sobre c칩mo los compiladores de C ++ no se optimizan bien en este momento.  Y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una</a> de mis quejas fue que los compiladores no pueden optimizar el uso de contenedores en nuestros programas.  Veamos algunos ejemplos de c칩digo. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v(<span class="hljs-number"><span class="hljs-number">42</span></span>); }</code> </pre> <br>  Parecer칤a que en un caso tan simple, el compilador deber칤a poder optimizar esta funci칩n y simplemente arrojar una declaraci칩n variable del tipo std :: vector, ya que a partir de C ++ 14 el compilador puede eliminar asignaciones de memoria din치mica, pero el compilador no lo hace.  La raz칩n de esto es que, por el momento, solo un compilador de C ++ implementa la optimizaci칩n para eliminar las asignaciones din치micas: Clang.  Todos los otros compiladores hasta ahora no saben c칩mo hacer esto.  Pero incluso Clang puede hacer esto en un n칰mero limitado de casos. <br><br>  En este caso, podr칤amos reemplazar std :: vector con std :: array, siempre que el tama침o del vector seleccionado no sea demasiado grande, ya que es posible que no tengamos suficiente pila para dicho reemplazo.  Tal reemplazo eliminar치 una asignaci칩n de memoria bastante costosa para el mont칩n, y la ventaja es que cuando se usa std :: array, 춰el compilador ya puede arrojar std :: array de la funci칩n por completo! <br><br>  Si hablamos de optimizaci칩n del rendimiento, proponemos considerar el siguiente ejemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">42</span></span>; ++i) { v.insert(v.begin(), <span class="hljs-number"><span class="hljs-number">42</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> val : v) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; val &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; } }</code> </pre> <br>  En este caso, vemos el uso de una operaci칩n extremadamente ineficaz en el caso de std :: vector - insertion al comienzo del contenedor.  Todos los programadores de C ++ saben que esto es extremadamente malo, ya que hace que todos los elementos cambien cada vez, lo que conlleva grandes costos para copiar / mover.  Ser칤a mucho mejor en este caso reemplazarlo con std :: list, que no le importa d칩nde se realiza la inserci칩n, o std :: deque (aunque es en este caso que puede ver claramente que no solo necesita usar insert. Pero este es solo un ejemplo, no m치s :) <br><br>  Veamos otro c칩digo de ejemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; ++i) { v.push_front(i); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> val : v) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; val &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; } }</code> </pre> <br>  En este caso, podemos notar que podemos reemplazar sin problemas std :: list (s칤, s칠 que pocas personas lo usan) con std :: forward_list.  En este caso, en este caso, no perderemos absolutamente nada, pero obtendremos ahorros de memoria.  Naturalmente, el compilador no hace tal optimizaci칩n ahora. <br><br>  Se puede hacer un truco similar en el siguiente ejemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">deque</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; ++i) { v.push_back(i); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; ++i) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; v.back() &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; v.pop_back(); } }</code> </pre> <br>  Aqu칤 podemos ver que lo que realmente necesitamos no es std :: deque, sino std :: stack.  Esto no se puede llamar optimizaci칩n, ya que std :: stack es un adaptador, y por defecto usa std :: deque en su interior (a menos que el usuario especifique lo contrario).  Aqu칤 podemos hablar m치s sobre la optimizaci칩n sem치ntica, es decir  simplificando el c칩digo para entender.  Desde mi punto de vista, esto tambi칠n es importante.  Si usted pregunta: "쯊al reemplazo de este tipo tambi칠n proporciona un aumento de rendimiento?", Responder칠 "Tal vez.  Consulte los detalles de implementaci칩n en su versi칩n de la biblioteca est치ndar ". <br><br>  Bueno, creo que hay suficientes ejemplos.  Cada uno de ustedes tambi칠n puede pensar en muchos de ellos. <br><br><h3>  Herramientas usadas </h3><br>  Para implementar el analizador est치tico, utilic칠 Clang Static Analzyer (CSA) y Clang Tidy, que forman parte del paquete LLVM.  Eleg칤 estas herramientas, ya que las considero las m치s prometedoras entre las herramientas abiertas para el an치lisis est치tico.  Adem치s, Clang proporciona uno de los analizadores de C ++ de la m치s alta calidad que otros analizadores est치ticos no pueden presumir (a menos que, por supuesto, usen libclang). <br><br>  Tanto CSA como Clang Tidy son analizadores est치ticos, los cuales forman parte de LLVM.  Cual es la diferencia  La diferencia es que Clang Tidy est치 dise침ado para escribir verificaciones simples, que b치sicamente consisten en encontrar alg칰n tipo de patr칩n en el 치rbol de sintaxis abstracta, mostrar alg칰n tipo de advertencia y posiblemente reemplazarlo autom치ticamente por otro.  Puedes aprender m치s sobre Clang Tidy <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu칤</a> . <br><br>  CSA est치 dise침ado para escribir comprobaciones m치s "serias" e intensivas en recursos (tanto desde el punto de vista de la implementaci칩n como desde el punto de vista del tiempo de ejecuci칩n / memoria gastada).  All칤, por ejemplo, hay disponible un mecanismo de ejecuci칩n simb칩lico. <br><br>  Decid칤 implementar la verificaci칩n en CSA, ya que no me parece un lugar com칰n, adem치s, en el futuro ser치 cada vez m치s dif칤cil.  Y se decidi칩 ejecutar Clang Tidy, ya que este analizador est치tico tiene <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">muchas</a> integraciones con varios IDE. <br><br><h3>  C칩mo (intentaremos) resolver los problemas </h3><br>  Para empezar, vale la pena introducir un par de restricciones bastante fuertes, que est치n relacionadas principalmente con el hecho de que hasta ahora es solo un prototipo: <br><br><ul><li>  An치lisis solo a nivel de funciones;  Esta limitaci칩n significa que no habr치 an치lisis entre funciones, as칤 como entre unidades de traducci칩n.  La restricci칩n en el an치lisis entre funciones se impuso para simplificar la implementaci칩n de este an치lisis y en el futuro se puede solucionar con relativa facilidad ejecutando un an치lisis est치tico para toda la unidad de traducci칩n, y no solo para cada funci칩n.  La restricci칩n en el an치lisis entre las unidades de traducci칩n est치 impuesta por las restricciones existentes en el CSA, que se solucionar치n pronto (ya se est치n enviando confirmaciones en el flujo ascendente); </li><li>  Soporte solo para un n칰mero limitado de contenedores.  Esto se soluciona relativamente f치cilmente en el futuro al agregar nuevas reglas para nuevos contenedores. </li><li>  Use para el an치lisis solo un 치rbol de sintaxis abstracta.  Dado que para la creaci칩n de prototipos, este es el tipo de an치lisis m치s simple.  Para obtener resultados m치s precisos, por supuesto, puede intentar usar al menos una ejecuci칩n simb칩lica, pero este m칠todo tiene sus inconvenientes.  Puedes leer m치s sobre m칠todos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu칤</a> . </li></ul><br>  Ahora el prototipo implementa el siguiente algoritmo simple: <br><br><ul><li>  Primero, en el 치rbol de sintaxis abstracta, encontramos los v칠rtices que son responsables de declarar las variables de tipo contenedor que admitimos. </li><li>  Luego, encontramos las operaciones relacionadas con estos contenedores, las clasificamos y guardamos esta informaci칩n en un cach칠 temporal. </li><li>  Despu칠s de llegar al final de la funci칩n, analizamos las estad칤sticas recopiladas y, en base a reglas predefinidas, emitimos una recomendaci칩n sobre el uso de un contenedor. </li></ul><br>  La clasificaci칩n de las operaciones de contenedores en este momento es la siguiente (se ampliar치 en el futuro): <br><br><ul><li>  Agregue un art칤culo a la parte superior del contenedor. </li><li>  Agregar un art칤culo a la mitad del contenedor. </li><li>  Agregar un art칤culo al final del contenedor. </li><li>  Eliminar un art칤culo desde el principio del contenedor. </li><li>  Retirar un art칤culo del medio del contenedor. </li><li>  Eliminar un art칤culo del final del contenedor. </li></ul><br>  La clasificaci칩n en este momento es incompleta e incluso en esta lista no funciona correctamente.  Por ejemplo, la operaci칩n de inserci칩n, incluso si se realiza al principio, el analizador clasifica como inserci칩n en el medio, aunque en realidad no lo es en absoluto. <br><br><h3>  Lucha contra falsos positivos </h3><br>  En cualquier an치lisis est치tico, los falsos positivos son el principal dolor de cabeza.  Si hay demasiados, se pierden mensajes 칰tiles en la basura.  Por lo tanto, en este caso, debe actuar de manera muy conservadora y emitir advertencias solo en los casos en que tengamos mucha confianza en nuestros diagn칩sticos y podamos decir que algo est치 realmente mal en alg칰n lugar del c칩digo. <br><br>  Si estamos hablando de la optimizaci칩n del compilador, entonces todav칤a es m치s triste all칤: la optimizaci칩n adecuada no puede cambiar el comportamiento del programa de acuerdo con el Est치ndar C ++ (de lo contrario, dicho optimizador no tiene valor).  Y la optimizaci칩n tampoco deber칤a introducir pesimismo :) As칤 que aqu칤 debes ser mucho m치s cuidadoso en tus decisiones. <br><br>  En este analizador, esta lucha result칩 en el hecho de que si el analizador ve que actualmente se est치 realizando una operaci칩n no admitida, el an치lisis de este contenedor est치 desactivado. <br><br><h3>  Desventajas y posibles soluciones. </h3><br>  Hay varios problemas con este m칠todo. <br><br>  El primer problema es que para el analizador en este momento todas las ramas del c칩digo son igualmente probables.  M치s precisamente, 칠l ni siquiera sabe acerca de algo como las diferentes ramas de ejecuci칩n de c칩digo. <br>  Esto se traduce en problemas con el an치lisis de algo como este c칩digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* ptr, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ptr == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { v.insert(v.begin(), <span class="hljs-number"><span class="hljs-number">42</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { v.push_back(<span class="hljs-number"><span class="hljs-number">84</span></span>); } }</code> </pre> <br>  Lo m치s probable es que, en nuestra aplicaci칩n, estas ramas de c칩digo no tengan las mismas probabilidades de ejecuci칩n, ya que en el mundo real un puntero generalmente indica algo normal, y no nullptr.  En el mismo LLVM hay heur칤sticas est치ticas en este puntaje.  Por ejemplo, tiene en cuenta el caso anterior al comparar punteros con nullptr, y al comparar entre s칤 la igualdad de valores de dos variables con un punto flotante, y algunos otros casos interesantes.  Pero esto se parece cada vez m치s a las muletas, y desde mi punto de vista, la soluci칩n real a este problema es agregar an치lisis din치mico o instrumentaci칩n. <br><br>  El segundo problema es la falta de soporte para contenedores personalizados.  Vivimos en el mundo de C ++, les gusta viajar aqu칤 (dejemos la discusi칩n de las razones de este fen칩meno no siempre malo fuera del alcance de este art칤culo) todo, incluidos nuestros contenedores.  Los ejemplos incluyen el mismo LLVM, LibreOffice y muchos otros.  A este respecto, surge la pregunta: 쯖칩mo analizar los contenedores que no provienen de la biblioteca STL?  Despu칠s de todo, me gustar칤a incluir el an치lisis de tantos contenedores como sea posible. <br><br>  Hay diferentes formas de resolver el problema. <br><br>  El primero es que el usuario anota sus contenedores de alguna manera (un tipo especial de comentario, atributos de C ++, algo m치s).  El problema con este m칠todo es que necesitamos entender c칩mo anotar, en general, qu칠 informaci칩n necesitamos para un an치lisis cualitativo.  Otro problema puede ser la modificaci칩n del c칩digo de los propios contenedores, que no siempre es posible. <br><br>  El segundo m칠todo ofrece al usuario un mecanismo para escribir sus propias reglas.  Por el momento, las reglas en el analizador est치n cosidas en el c칩digo fuente del analizador en s칤, y si el usuario desea agregar sus propias reglas, entonces deber치 descargar el c칩digo fuente del analizador, armarlo, descubrir c칩mo escribir cheques, escribir, reconstruir, etc.  Puede proporcionar al usuario una forma de configurar sus comprobaciones en algunos DSL, donde el usuario escribe solo comprobaciones para sus contenedores y el analizador participa en toda la rutina.  Considero que este m칠todo es m치s prometedor que el anterior. <br><br>  Adem치s, el reemplazo autom치tico de contenedores no es compatible, ya que esta funcionalidad no est치 en CSA (pero s칤 en Clang Tidy).  Pero en casos dif칤ciles, realizar la Autocorrecci칩n no siempre es una tarea trivial, y el analizador funciona m치s probablemente en modo semi-manual. <br><br><h3>  Posibles aplicaciones </h3><br>  Veo varias aplicaciones para este tipo de an치lisis: <br><br><ol><li>  Como un analizador est치tico.  Aqu칤 todo es simple: otra prueba de an치lisis est치tico, que ejecuta seg칰n lo desee su coraz칩n (con sus manos, en el IDE autom치ticamente durante el desarrollo, en CI, etc.), donde probablemente se le dar치 una pista de que en alg칰n lugar podr칤a recoger un contenedor y mejor. </li><li>  Como optimizaci칩n en el compilador.  En algunos casos, podemos garantizar que reemplazar el contenedor definitivamente no afectar치 negativamente el rendimiento.  Por ejemplo, reemplazando std :: vector por tama침os peque침os conocidos en tiempo de compilaci칩n con std :: array o reemplazando std :: list por std :: forward_list cuando no necesitamos biconnectness y no tomamos el tama침o de la lista.  El compilador podr칤a reemplazar los contenedores con otros m치s 칩ptimos sin nuestro conocimiento, como ya lo hace para una gran cantidad de cosas. </li><li>  Como un analizador din치mico.  Esta es la direcci칩n que me parece m치s prometedora para este tipo de an치lisis.  De hecho, con la ayuda del conocimiento sobre el perfil de ejecuci칩n del programa, nosotros, por ejemplo, podemos obtener informaci칩n tan importante para nosotros como las probabilidades de cada ejecuci칩n de ramificaci칩n de c칩digo.  Y esto es necesario para una evaluaci칩n m치s precisa.  Y con tal an치lisis, ya puede pensar en la direcci칩n de integraci칩n con PGO ... </li></ol><br>  Tambi칠n vale la pena se침alar que este m칠todo es aplicable, por supuesto, no solo para los programas de C ++.  Realmente me gustar칤a ver este tipo de an치lisis / optimizaci칩n est치tica en el compilador y para otros lenguajes de programaci칩n.  Por ejemplo, el analizador est치tico de SAP para ABAP ya sabe c칩mo llevar a cabo an치lisis de optimizaci칩n est치tica a un nivel b치sico, lo cual es una buena noticia.  Si conoce proyectos similares para otros lenguajes de programaci칩n, escriba en los comentarios y los agregar칠 al art칤culo. <br><br><h3>  Trabaja en direcciones similares </h3><br>  Para el mundo C ++, no he encontrado analizadores de este tipo en ning칰n lado.  Para el mundo ABAP, mencion칠 el analizador anterior, que puede encontrar operaciones ineficientes para alguna parte de los contenedores est치ndar, pero que yo sepa, se implementa un an치lisis est치tico muy simple all칤. <br><br>  Un trabajo mucho m치s interesante es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Chameleon</a> , un analizador din치mico para Java, que se realiza de manera muy inteligente.  Ajustaron un poco la JVM, y durante la operaci칩n recopilan varias estad칤sticas sobre el uso de contenedores y, seg칰n el perfil de carga actual, seleccionan ciertos contenedores y los reemplazan autom치ticamente durante la operaci칩n.  Desafortunadamente, las fuentes est치n cerradas y no hay posibilidad de obtenerlas (lo intent칠). <br><br>  Tambi칠n recomiendo mirar varios trabajos (hay muchos) en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SETL</a> .  En ellos, los autores tambi칠n sol칤an plantear preguntas sobre la selecci칩n autom치tica del contenedor. <br><br><h3>  Referencias </h3><br><ol><li>  Implementaci칩n actual en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C ++ Rusia 2017: Yuri Efimochev, clang-tidy: un viaje dentro del 치rbol de sintaxis abstracta de C ++</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Camale칩n: selecci칩n adaptativa de colecciones</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gu칤a de analizador est치tico de Clang</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Chat</a> en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">idioma ruso</a> sobre el desarrollo de compiladores en Telegram.  Si est치s interesado, entra, es muy interesante all칤.  Solo ten cuidado con la inundaci칩n, inmediatamente lo castigar치n :) </li></ol><br>  En lugar de una conclusi칩n, me gustar칤a centrarme en el hecho de que hasta ahora es solo un prototipo y tiene demasiados "agujeros" en la implementaci칩n.  En este art칤culo, solo quiero compartir con ustedes la idea de tal an치lisis y su popularizaci칩n.  Bueno, tal vez alguien est칠 interesado en este tema y haya un deseo de conectarse con el proyecto. 춰Solo estar칠 feliz!  Adem치s, siempre puede recopilar este analizador en su propio lugar para probarlo en sus ejemplos de prueba. <br><br>  Si tiene algo para complementar el material, ha encontrado una tarea similar o simplemente tiene alguna informaci칩n que puede ser 칰til sobre este tema, no dude en compartir esta informaci칩n en los comentarios. <br><br>  Gracias por su atencion! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/455379/">https://habr.com/ru/post/455379/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../455369/index.html">Certificaci칩n de administradores de bases de datos y mucho m치s en el aniversario DevConfX (21-22 de junio en Mosc칰)</a></li>
<li><a href="../455371/index.html">Fuente de corriente estable de 5 풮A a 20 mA</a></li>
<li><a href="../455373/index.html">쮺칩mo ajustar la ley de Spring para que se convierta en un est칤mulo para los peque침os proveedores? Cancelarlo</a></li>
<li><a href="../455375/index.html">Escribiendo UDR en Pascal</a></li>
<li><a href="../455377/index.html">Arquitectura IoT</a></li>
<li><a href="../455381/index.html">El soporte t칠cnico de 3CX responde: captura el tr치fico SIP en el servidor PBX</a></li>
<li><a href="../455387/index.html">Comprensi칩n del aprendizaje autom치tico en Elastic Stack (tambi칠n conocido como Elasticsearch, tambi칠n conocido como ELK)</a></li>
<li><a href="../455389/index.html">Haxe 4: 쯈u칠 hay de nuevo?</a></li>
<li><a href="../455391/index.html">Parte 1: RISC-V / RocketChip en un h치bitat antinatural</a></li>
<li><a href="../455393/index.html">Sobre el uso de m칠todos param칠tricos de estimaci칩n espectral en radar: el m칠todo MUSIC. Adici칩n al art칤culo.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>