<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßñüèø ‚ûñ üñåÔ∏è √úberschreiben von Equals und GetHashCode. Aber ist es notwendig? üßóüèº üíæ üóûÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn Sie mit C # vertraut sind, wissen Sie h√∂chstwahrscheinlich, dass Sie Equals und GetHashCode immer √ºberschreiben GetHashCode , um Leistungseinbu√üe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√úberschreiben von Equals und GetHashCode. Aber ist es notwendig?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/418515/"> Wenn Sie mit C # vertraut sind, wissen Sie h√∂chstwahrscheinlich, dass Sie <code>Equals</code> und <code>GetHashCode</code> immer √ºberschreiben <code>GetHashCode</code> , um Leistungseinbu√üen zu vermeiden.  Aber was passiert, wenn dies nicht getan wird?  Heute vergleichen wir die Leistung mit zwei Optimierungsoptionen und betrachten Tools, um Fehler zu vermeiden. <br><br><img src="https://habrastorage.org/webt/w9/iq/7g/w9iq7gen1fjdvh3j6jcxai470ec.jpeg"><a name="habracut"></a><br><br><h2>  Wie ernst ist dieses Problem? </h2><br>  Nicht jedes potenzielle Leistungsproblem wirkt sich auf die Laufzeit der Anwendung aus.  Die <code>Enum.HasFlag</code> Methode <code>Enum.HasFlag</code> nicht sehr effizient (*). Wenn Sie sie jedoch nicht f√ºr einen ressourcenintensiven Code verwenden, treten im Projekt keine ernsthaften Probleme auf.  Dies ist auch bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gesch√ºtzten Kopien</a> der Fall, die von nicht schreibgesch√ºtzten Strukturtypen im schreibgesch√ºtzten Kontext erstellt wurden.  Das Problem besteht, ist jedoch bei normalen Anwendungen wahrscheinlich nicht erkennbar. <br><br>  <i>(*) In .NET Core 2.1 behoben. Wie bereits <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in einer fr√ºheren Ver√∂ffentlichung erw√§hnt</a> , k√∂nnen die Konsequenzen jetzt mithilfe des selbstkonfigurierten HasFlag f√ºr √§ltere Versionen gemindert werden.</i> <br><br>  Aber das Problem, √ºber das wir heute sprechen werden, ist etwas Besonderes.  Wenn die Methoden <code>Equals</code> und <code>GetHashCode</code> nicht in der Struktur erstellt werden, werden ihre Standardversionen von <code>System.ValueType</code> .  Und sie k√∂nnen die Leistung der endg√ºltigen Anwendung erheblich reduzieren. <br><br><h2>  Warum sind Standardversionen langsam? </h2><br>  Die CLR-Autoren haben ihr Bestes getan, um die Standardversionen von Equals und GetHashCode f√ºr Werttypen so effizient wie m√∂glich zu gestalten.  Es gibt jedoch mehrere Gr√ºnde, warum diese Methoden an Effektivit√§t der Benutzerversion verlieren, die f√ºr einen bestimmten Typ manuell geschrieben (oder vom Compiler generiert) wurde. <br><br>  1. Verteilung der Verpackungsumwandlung.  Die CLR ist so konzipiert, dass jeder Aufruf eines Elements, das in den Typen <code>System.ValueType</code> oder <code>System.Enum</code> definiert ist, eine Wrapping-Transformation (**) ausl√∂st. <br><br>  <i>(**) Wenn die Methode die JIT-Kompilierung nicht unterst√ºtzt.</i>  <i>In Core CLR 2.1 erkennt der JIT-Compiler beispielsweise die <code>Enum.HasFlag</code> Methode und generiert geeigneten Code, der nicht mit dem <code>Enum.HasFlag</code> beginnt.</i> <br><br>  2. M√∂gliche Konflikte in der Standardversion der <code>GetHashCode</code> Methode.  Bei der Implementierung einer Hash-Funktion stehen wir vor einem Dilemma: Die Verteilung der Hash-Funktion muss gut oder schnell sein.  In einigen F√§llen k√∂nnen Sie beides tun, aber beim Typ <code>ValueType.GetHashCode</code> ist dies normalerweise schwierig. <br><br>  Eine traditionelle Hash-Funktion vom Typ struct "kombiniert" die Hash-Codes aller Felder.  Die einzige M√∂glichkeit, den Feld-Hash-Code in der <code>ValueType</code> Methode <code>ValueType</code> , ist die Verwendung von Reflection.  Aus diesem Grund haben die CLR-Autoren beschlossen, die Geschwindigkeit f√ºr die Verteilung zu opfern. Die Standardversion von <code>GetHashCode</code> nur den Hash-Code des ersten Felds ungleich Null zur√ºck und <a href="">‚Äûverdirbt‚Äú ihn mit einer</a> <code>RegularGetValueTypeHashCode</code> (***) (weitere Informationen finden Sie unter <code>RegularGetValueTypeHashCode</code> in coreclr repo auf github). <br><br>  <i>(***) Gemessen an den Kommentaren im CoreCLR-Repository kann sich die Situation in Zukunft √§ndern.</i> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Location { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Path { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Position { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Location</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> position</span></span></span><span class="hljs-function">)</span></span> =&gt; (Path, Position) = (path, position); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hash1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Location(path: <span class="hljs-string"><span class="hljs-string">""</span></span>, position: <span class="hljs-number"><span class="hljs-number">42</span></span>).GetHashCode(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hash2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Location(path: <span class="hljs-string"><span class="hljs-string">""</span></span>, position: <span class="hljs-number"><span class="hljs-number">1</span></span>).GetHashCode(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hash3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Location(path: <span class="hljs-string"><span class="hljs-string">"1"</span></span>, position: <span class="hljs-number"><span class="hljs-number">42</span></span>).GetHashCode(); <span class="hljs-comment"><span class="hljs-comment">// hash1 and hash2 are the same and hash1 is different from hash3</span></span></code> </pre> <br>  Dies ist ein vern√ºnftiger Algorithmus, bis etwas schief geht.  Wenn Sie jedoch kein Gl√ºck haben und der Wert des ersten Felds Ihres Strukturtyps in den meisten F√§llen gleich ist, f√ºhrt die Hash-Funktion immer zum gleichen Ergebnis.  Wie Sie vielleicht vermutet haben, sinkt die Leistung, wenn Sie diese Instanzen in einem Hash-Set oder einer Hash-Tabelle speichern. <br><br>  3. Die auf Reflexion basierende Implementierungsgeschwindigkeit ist gering.  Sehr niedrig.  Reflexion ist ein m√§chtiges Werkzeug, wenn es richtig eingesetzt wird.  Die Konsequenzen sind jedoch schrecklich, wenn Sie es auf einem ressourcenintensiven Code ausf√ºhren. <br><br>  Mal sehen, wie sich eine fehlgeschlagene Hash-Funktion, die sich aus (2) und einer reflexionsbasierten Implementierung ergeben kann, auf die Leistung auswirkt: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Location1 { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Path { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Position { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Location1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> position</span></span></span><span class="hljs-function">)</span></span> =&gt; (Path, Position) = (path, position); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Location2 { <span class="hljs-comment"><span class="hljs-comment">// The order matters! // The default GetHashCode version will get a hashcode of the first field public int Position { get; } public string Path { get; } public Location2(string path, int position) =&gt; (Path, Position) = (path, position); } public readonly struct Location3 : IEquatable&lt;Location3&gt; { public string Path { get; } public int Position { get; } public Location3(string path, int position) =&gt; (Path, Position) = (path, position); public override int GetHashCode() =&gt; (Path, Position).GetHashCode(); public override bool Equals(object other) =&gt; other is Location3 l &amp;&amp; Equals(l); public bool Equals(Location3 other) =&gt; Path == other.Path &amp;&amp; Position == other.Position; } private HashSet&lt;Location1&gt; _locations1; private HashSet&lt;Location2&gt; _locations2; private HashSet&lt;Location3&gt; _locations3; [Params(1, 10, 1000)] public int NumberOfElements { get; set; } [GlobalSetup] public void Init() { _locations1 = new HashSet&lt;Location1&gt;(Enumerable.Range(1, NumberOfElements).Select(n =&gt; new Location1("", n))); _locations2 = new HashSet&lt;Location2&gt;(Enumerable.Range(1, NumberOfElements).Select(n =&gt; new Location2("", n))); _locations3 = new HashSet&lt;Location3&gt;(Enumerable.Range(1, NumberOfElements).Select(n =&gt; new Location3("", n))); _locations4 = new HashSet&lt;Location4&gt;(Enumerable.Range(1, NumberOfElements).Select(n =&gt; new Location4("", n))); } [Benchmark] public bool Path_Position_DefaultEquality() { var first = new Location1("", 0); return _locations1.Contains(first); } [Benchmark] public bool Position_Path_DefaultEquality() { var first = new Location2("", 0); return _locations2.Contains(first); } [Benchmark] public bool Path_Position_OverridenEquality() { var first = new Location3("", 0); return _locations3.Contains(first); }</span></span></code> </pre> <br><br><pre> <code class="cs hljs"> Method | NumOfElements | Mean | Gen <span class="hljs-number"><span class="hljs-number">0</span></span> | Allocated | -------------------------------- |------ |--------------:|--------:|----------:| Path_Position_DefaultEquality | <span class="hljs-number"><span class="hljs-number">1</span></span> | <span class="hljs-number"><span class="hljs-number">885.63</span></span> ns | <span class="hljs-number"><span class="hljs-number">0.0286</span></span> | <span class="hljs-number"><span class="hljs-number">92</span></span> B | Position_Path_DefaultEquality | <span class="hljs-number"><span class="hljs-number">1</span></span> | <span class="hljs-number"><span class="hljs-number">127.80</span></span> ns | <span class="hljs-number"><span class="hljs-number">0.0050</span></span> | <span class="hljs-number"><span class="hljs-number">16</span></span> B | Path_Position_OverridenEquality | <span class="hljs-number"><span class="hljs-number">1</span></span> | <span class="hljs-number"><span class="hljs-number">47.99</span></span> ns | - | <span class="hljs-number"><span class="hljs-number">0</span></span> B | Path_Position_DefaultEquality | <span class="hljs-number"><span class="hljs-number">10</span></span> | <span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">214.02</span></span> ns | <span class="hljs-number"><span class="hljs-number">0.2441</span></span> | <span class="hljs-number"><span class="hljs-number">776</span></span> B | Position_Path_DefaultEquality | <span class="hljs-number"><span class="hljs-number">10</span></span> | <span class="hljs-number"><span class="hljs-number">130.04</span></span> ns | <span class="hljs-number"><span class="hljs-number">0.0050</span></span> | <span class="hljs-number"><span class="hljs-number">16</span></span> B | Path_Position_OverridenEquality | <span class="hljs-number"><span class="hljs-number">10</span></span> | <span class="hljs-number"><span class="hljs-number">47.67</span></span> ns | - | <span class="hljs-number"><span class="hljs-number">0</span></span> B | Path_Position_DefaultEquality | <span class="hljs-number"><span class="hljs-number">1000</span></span> | <span class="hljs-number"><span class="hljs-number">589</span></span>,<span class="hljs-number"><span class="hljs-number">014.52</span></span> ns | <span class="hljs-number"><span class="hljs-number">23.4375</span></span> | <span class="hljs-number"><span class="hljs-number">76025</span></span> B | Position_Path_DefaultEquality | <span class="hljs-number"><span class="hljs-number">1000</span></span> | <span class="hljs-number"><span class="hljs-number">133.74</span></span> ns | <span class="hljs-number"><span class="hljs-number">0.0050</span></span> | <span class="hljs-number"><span class="hljs-number">16</span></span> B | Path_Position_OverridenEquality | <span class="hljs-number"><span class="hljs-number">1000</span></span> | <span class="hljs-number"><span class="hljs-number">48.51</span></span> ns | - | <span class="hljs-number"><span class="hljs-number">0</span></span> B |</code> </pre> <br>  Wenn der Wert des ersten Felds immer gleich ist, gibt die Hash-Funktion standardm√§√üig einen gleichen Wert f√ºr alle Elemente zur√ºck und die Hash-Menge wird effektiv in eine verkn√ºpfte Liste mit O (N) Einf√ºge- und Suchoperationen konvertiert.  Die Anzahl der Operationen zum F√ºllen der Sammlung wird zu O (N ^ 2) (wobei N die Anzahl der Einf√ºgungen mit der Komplexit√§t O (N) f√ºr jede Einf√ºgung ist).  Dies bedeutet, dass das Einf√ºgen in einen Satz von 1000 Elementen fast 500.000 Aufrufe von <code>ValueType.Equals</code> .  Hier sind die Konsequenzen einer Methode mit Reflexion! <br><br>  Wie der Test zeigt, ist die Leistung akzeptabel, wenn Sie Gl√ºck haben und das erste Element der Struktur eindeutig ist (im Fall von <code>Position_Path_DefaultEquality</code> ).  Ist dies jedoch nicht der Fall, ist die Produktivit√§t √§u√üerst gering. <br><br><h2>  Echtes Problem </h2><br>  Ich denke, jetzt k√∂nnen Sie erraten, auf welches Problem ich k√ºrzlich gesto√üen bin.  Vor einigen Wochen erhielt ich eine Fehlermeldung: Die Laufzeit der Anwendung, an der ich arbeite, wurde von 10 auf 60 Sekunden erh√∂ht.  Gl√ºcklicherweise war der Bericht sehr detailliert und enthielt eine Spur von Windows-Ereignissen, sodass der Problempunkt schnell <code>ValueType.Equals</code> - <code>ValueType.Equals</code> 50 Sekunden <code>ValueType.Equals</code> geladen. <br><br>  Nach einem kurzen Blick auf den Code wurde klar, wo das Problem lag: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> HashSet&lt;(ErrorLocation, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)&gt; _locationsWithHitCount; <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ErrorLocation { <span class="hljs-comment"><span class="hljs-comment">// Empty almost all the time public string OptionalDescription { get; } public string Path { get; } public int Position { get; } }</span></span></code> </pre> <br>  Ich habe ein Tupel verwendet, das einen benutzerdefinierten Strukturtyp mit der Standardversion von <code>Equals</code> enthielt.  Und leider hatte es ein optionales erstes Feld, das fast immer gleich <code>String.equals</code> .  Die Produktivit√§t blieb hoch, bis die Anzahl der Elemente im Satz signifikant anstieg.  Innerhalb weniger Minuten wurde eine Sammlung mit Zehntausenden von Elementen initialisiert. <br><br><h2>  <code>ValueType.Equals/GetHashCode</code> die Standardimplementierung von <code>ValueType.Equals/GetHashCode</code> immer langsam? </h2><br>  Sowohl <code>ValueType.Equals</code> als auch <code>ValueType.GetHashCode</code> verf√ºgen √ºber spezielle Optimierungsmethoden.  Wenn der Typ keine ‚ÄûZeiger‚Äú hat und korrekt gepackt ist (ich werde in einer Minute ein Beispiel zeigen), werden optimierte Versionen verwendet: <code>GetHashCode</code> Iterationen werden f√ºr <code>GetHashCode</code> ausgef√ºhrt, XOR von 4 Bytes wird verwendet, die <code>Equals</code> Methode vergleicht zwei Instanzen mit <code>memcmp</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Optimized ValueType.GetHashCode implementation static INT32 FastGetValueTypeHashCodeHelper(MethodTable *mt, void *pObjRef) { INT32 hashCode = 0; INT32 *pObj = (INT32*)pObjRef; // this is a struct with no refs and no "strange" offsets, just go through the obj and xor the bits INT32 size = mt-&gt;GetNumInstanceFieldBytes(); for (INT32 i = 0; i &lt; (INT32)(size / sizeof(INT32)); i++) hashCode ^= *pObj++; return hashCode; } // Optimized ValueType.Equals implementation FCIMPL2(FC_BOOL_RET, ValueTypeHelper::FastEqualsCheck, Object* obj1, Object* obj2) { TypeHandle pTh = obj1-&gt;GetTypeHandle(); FC_RETURN_BOOL(memcmp(obj1-&gt;GetData(), obj2-&gt;GetData(), pTh.GetSize()) == 0); }</span></span></code> </pre> <br>  Die Pr√ºfung selbst wird in <code>ValueTypeHelper::CanCompareBits</code> . Sie wird sowohl aus der Iteration von <code>ValueType.Equals</code> als auch aus der Iteration von <code>ValueType.GetHashCode</code> . <br><br>  Aber Optimierung ist eine sehr heimt√ºckische Sache. <br><br>  Erstens ist es schwer zu verstehen, wann es eingeschaltet ist;  Selbst geringf√ºgige √Ñnderungen am Code k√∂nnen ihn ein- und ausschalten: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Case1 { <span class="hljs-comment"><span class="hljs-comment">// Optimization is "on", because the struct is properly "packed" public int X { get; } public byte Y { get; } } public struct Case2 { // Optimization is "off", because struct has a padding between byte and int public byte Y { get; } public int X { get; } }</span></span></code> </pre> <br>  Weitere Informationen zur Speicherstruktur finden Sie in meinem Blog <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûInterne Elemente eines verwalteten Objekts, Teil 4. Feldstruktur‚Äú</a> . <br><br>  Zweitens f√ºhrt ein Vergleich des Speichers nicht unbedingt zum richtigen Ergebnis.  Hier ist ein einfaches Beispiel: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> MyDouble { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> Value { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyDouble</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> =&gt; Value = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> d1 = <span class="hljs-number"><span class="hljs-number">-0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> d2 = +<span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// True bool b1 = d1.Equals(d2); // False! bool b2 = new MyDouble(d1).Equals(new MyDouble(d2));</span></span></code> </pre> <br>  <code>-0,0</code> und <code>+0,0</code> sind gleich, haben aber unterschiedliche bin√§re Darstellungen.  Dies bedeutet, dass <code>Double.Equals</code> wahr und <code>MyDouble.Equals</code> falsch ist.  In den meisten F√§llen ist der Unterschied nicht signifikant, aber stellen Sie sich vor, wie viele Stunden Sie damit verbringen werden, das durch diesen Unterschied verursachte Problem zu beheben. <br><br><h2>  Wie vermeide ich ein √§hnliches Problem? </h2><br>  K√∂nnen Sie mich fragen, wie das oben genannte in einer realen Situation passieren kann?  Eine naheliegende M√∂glichkeit, die Methoden <code>Equals</code> und <code>GetHashCode</code> in Strukturtypen <code>GetHashCode</code> , ist die Verwendung der FxCop <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CA1815-Regel</a> .  Es gibt jedoch ein Problem: Dies ist ein zu strenger Ansatz. <br><br>  Eine Anwendung, f√ºr die die Leistung entscheidend ist, kann Hunderte von Strukturtypen haben, die nicht unbedingt in Hash-Sets oder W√∂rterb√ºchern verwendet werden.  Daher k√∂nnen Anwendungsentwickler die Regel deaktivieren, was unangenehme Folgen hat, wenn der Strukturtyp ge√§nderte Funktionen verwendet. <br><br>  Ein korrekterer Ansatz besteht darin, den Entwickler zu warnen, wenn die Struktur vom Typ "unangemessen" mit gleichen Standardwerten von Elementen (in der Anwendung oder in einer Bibliothek eines Drittanbieters definiert) in einem Hash-Set gespeichert ist.  Nat√ºrlich spreche ich √ºber <a href="">ErrorProne.NET</a> und die Regel, die ich dort hinzugef√ºgt habe, sobald ich auf dieses Problem <a href="">gesto√üen</a> bin: <br><br><img src="https://habrastorage.org/webt/fx/dp/2u/fxdp2u0isbov-7e2vh0stw70x2m.png"><br><br>  Die ErrorProne.NET-Version ist nicht perfekt und gibt dem korrekten Code die Schuld, wenn im Konstruktor ein benutzerdefinierter Gleichheitsaufl√∂ser verwendet wird: <br><br><img src="https://habrastorage.org/webt/9b/16/0p/9b160peycjwrjmiblktkuroajk0.png"><br><br>  Ich denke jedoch immer noch, dass es eine Warnung wert ist, wenn eine Struktur mit gleichen Elementen standardm√§√üig nicht verwendet wird, wenn sie erstellt wird.  Als ich beispielsweise meine Regel √ºberpr√ºfte, stellte ich fest, dass die in mscorlib definierte <code>System.Collections.Generic.KeyValuePair &lt;TKey, TValue&gt;</code> -Struktur <code>Equals</code> und <code>GetHashCode</code> nicht √ºberschreibt.  Es ist unwahrscheinlich, dass heute jemand eine Variable wie <code>HashSet &lt;KeyValuePair&lt;string, int&gt;&gt;</code> , aber ich glaube, dass sogar BCL die Regel brechen kann.  Daher ist es n√ºtzlich, dies zu entdecken, bevor es zu sp√§t ist. <br><br><h2>  Fazit </h2><br><ul><li>  Das Implementieren der Standardgleichheit f√ºr Strukturtypen kann schwerwiegende Folgen f√ºr Ihre Anwendung haben.  Dies ist ein reales, kein theoretisches Problem. </li><li>  Die Standardgleichheitselemente f√ºr Werttypen basieren auf Reflexion. </li><li>  Die von der Standardversion von <code>GetHashCode</code> durchgef√ºhrte Verteilung ist sehr schlecht, wenn das erste Feld vieler Instanzen denselben Wert hat. </li><li>  Es gibt optimierte Versionen f√ºr die Standardmethoden <code>Equals</code> und <code>GetHashCode</code> , aber Sie sollten sich nicht auf sie verlassen, da sie bereits durch eine kleine Code√§nderung <code>GetHashCode</code> werden k√∂nnen. </li><li>  Verwenden Sie die FxCop-Regel, um sicherzustellen, dass jeder Strukturtyp Gleichheitselemente √ºberschreibt.  Es ist jedoch besser, das Problem mit dem Analysator zu vermeiden, wenn die ‚Äûunangemessene‚Äú Struktur in einem Hash-Set oder in einer Hash-Tabelle gespeichert ist. </li></ul><br><h2>  Zus√§tzliche Ressourcen </h2><br><ul><li>  <a href="">ErrorProne.NET auf Github</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ErrorProne.NET-Strukturen im Speicher</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418515/">https://habr.com/ru/post/de418515/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418503/index.html">Nach 2020 wird Gro√übritannien den ersten Raumhafen erwerben - in Schottland</a></li>
<li><a href="../de418505/index.html">√úbersicht und Vergleich von Quanten-Software-Plattformen auf Gate-Ebene</a></li>
<li><a href="../de418507/index.html">Was hat uns die Kosmonautik gegeben?</a></li>
<li><a href="../de418509/index.html">Amazon Rekognition erkennt 28 US-Kongressabgeordnete als Kriminelle an</a></li>
<li><a href="../de418513/index.html">Wie schreibe ich nur guten Code</a></li>
<li><a href="../de418517/index.html">Code Coverage: So verbessern Sie die Testqualit√§t</a></li>
<li><a href="../de418519/index.html">Was kann im Code eines anderen gefunden werden? Eine Auswahl n√ºtzlicher Materialien f√ºr .NET</a></li>
<li><a href="../de418521/index.html">Der Schleier der Geheimhaltung √ºber den Start aus Alaska</a></li>
<li><a href="../de418523/index.html">Warum ‚Äûbelauschen‚Äú Einzelh√§ndler ihre Mitarbeiter und warum setzen sie immer noch Audiotechnologie ein?</a></li>
<li><a href="../de418525/index.html">Opera ging an die √ñffentlichkeit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>