<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😺 🏐 🐘 PVS-Studio untuk Java 💎 💎 😐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam versi ketujuh dari analisa statis PVS-Studio, kami menambahkan dukungan untuk bahasa Java. Sudah waktunya untuk berbicara sedikit tentang bagaim...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PVS-Studio untuk Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/436434/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/859/2ca/ccd/8592caccdc92ac430645bd487d7b5284.png" alt="PVS-Studio untuk Java"></div><br>  Dalam versi ketujuh dari analisa statis PVS-Studio, kami menambahkan dukungan untuk bahasa Java.  Sudah waktunya untuk berbicara sedikit tentang bagaimana kami mulai melakukan dukungan untuk bahasa Jawa, apa yang kami lakukan dan apa rencana masa depan.  Dan, tentu saja, artikel itu akan menunjukkan tes pertama dari penganalisa pada proyek terbuka. <br><a name="habracut"></a><br><h2>  PVS-Studio </h2><br>  Untuk pengembang Java yang belum pernah mendengar tentang alat PVS-Studio sebelumnya, saya akan memberikan deskripsi singkat tentang itu. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PVS-Studio</a> adalah alat untuk mendeteksi kesalahan dan kerentanan potensial dalam kode sumber program yang ditulis dalam C, C ++, C # dan Java.  Ini berjalan pada Windows, Linux, dan macOS. <br><br>  PVS-Studio melakukan analisis kode statis dan menghasilkan laporan yang membantu programmer menemukan dan memperbaiki cacat.  Bagi mereka yang tertarik bagaimana tepatnya PVS-Studio mencari kesalahan, saya sarankan Anda membaca artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Teknologi yang Digunakan dalam Analisis Kode PVS-Studio untuk Menemukan Kesalahan dan Kerentanan Potensial</a> ". <br><br><h2>  Mulai </h2><br>  Saya bisa menghasilkan cerita yang cerdas, karena kami telah berpikir selama dua tahun tentang bahasa apa yang akan didukung di PVS-Studio.  Fakta bahwa Java adalah pilihan yang masuk akal berdasarkan popularitas tinggi bahasa ini dan sebagainya. <br><br>  Namun, seperti yang terjadi dalam hidup, semuanya diputuskan bukan oleh analisis mendalam, tetapi dengan eksperimen :).  Ya, kami berpikir ke arah mana penganalisa PVS-Studio harus dikembangkan lebih lanjut.  Bahasa pemrograman seperti: Java, PHP, Python, JavaScript, IBM RPG dipertimbangkan.  Dan kami cenderung ke bahasa Jawa, tetapi pilihan terakhir belum dibuat.  Mereka yang matanya terpaku pada IBM RPG yang tidak dikenal, saya merujuk pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">catatan</a> ini di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , dari mana semuanya akan menjadi jelas. <br><br>  Pada akhir 2017, rekan Egor Bredikhin melihat perpustakaan siap pakai untuk kode parsing (dengan kata lain, parser) tersedia untuk arah baru yang menarik bagi kami.  Dan saya menemukan beberapa proyek untuk mem-parsing kode Java.  Berdasarkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Spoon</a> , ia dengan cepat berhasil membuat alat analisa prototipe dengan beberapa diagnosa.  Selain itu, menjadi jelas bahwa kita dapat menggunakan beberapa mekanisme penganalisa C ++ dengan bantuan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SWIG</a> dalam penganalisis Java.  Kami melihat apa yang terjadi dan menyadari bahwa pengurai kami berikutnya adalah untuk Jawa. <br><br>  Terima kasih kepada Egor untuk usahanya dan pekerjaan aktif yang dilakukan olehnya pada Java analyzer.  Bagaimana perkembangan berlangsung ia menjelaskan dalam artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengembangan Analyzer Statis Baru: PVS-Studio Java</a> ". <br><br><h2>  Pesaing? </h2><br>  Ada banyak penganalisa kode statis gratis dan komersial untuk Java di dunia.  Tidak masuk akal untuk mendaftar semuanya dalam artikel, dan saya hanya meninggalkan tautan ke " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Daftar alat untuk analisis kode statis</a> " (lihat bagian Java dan Multi-bahasa). <br><br>  Namun, saya tahu bahwa pertama-tama kita akan ditanya tentang IntelliJ IDEA, FindBugs dan SonarQube (SonarJava). <br><br>  <b>IntelliJ IDEA</b> <br><br>  IntelliJ IDEA memiliki penganalisa kode statis yang sangat kuat.  Selain itu, penganalisa sedang berkembang, dan penulisnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memantau dengan</a> cermat kegiatan kami.  Dengan IntelliJ IDEA kami akan menjadi yang paling sulit.  Kami tidak akan dapat melampaui IntelliJ IDEA dalam kemampuan diagnostik, setidaknya untuk saat ini.  Karena itu, kami akan mencoba berkonsentrasi pada keunggulan kami yang lain. <br><br>  Analisis statis di IntelliJ IDEA adalah, pertama-tama, salah satu chip lingkungan pengembangan, yang menerapkan batasan tertentu padanya.  Kami bebas dalam apa yang dapat kami lakukan dengan analis kami.  Misalnya, kami dapat dengan cepat mengadaptasi analisa untuk kebutuhan spesifik pelanggan.  Dukungan cepat dan mendalam adalah keunggulan kompetitif kami.  Klien kami berkomunikasi langsung dengan programmer yang sedang mengembangkan bagian tertentu dari PVS-Studio. <br><br>  PVS-Studio memiliki banyak kemungkinan untuk mengintegrasikannya ke dalam siklus pengembangan proyek-proyek besar yang lama.  Ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">integrasi dengan SonarQube</a> .  Ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penindasan besar</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">besaran dari</a> pesan analisa, yang memungkinkan Anda untuk segera mulai menggunakan analisa dalam proyek besar untuk melacak kesalahan hanya dalam kode baru atau yang diubah.  PVS-Studio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terintegrasi</a> ke dalam proses integrasi berkelanjutan.  Saya pikir ini dan fitur lainnya akan membantu penganalisa kami menemukan tempat di bawah matahari di dunia Jawa. <br><br>  <b>Findbugs</b> <br><br>  Proyek FindBugs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ditinggalkan</a> .  Tetapi harus diingat dengan alasan bahwa ini mungkin merupakan penganalisa statik bebas yang paling terkenal dari kode Java. <br><br>  Penerus FindBugs adalah proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SpotBugs</a> .  Namun, ia kurang populer, dan apa yang akan terjadi padanya juga belum sepenuhnya jelas. <br><br>  Secara umum, kami percaya bahwa meskipun FindBugs adalah dan tetap sangat populer, dan juga penganalisa gratis, kita tidak boleh memikirkannya.  Proyek ini hanya diam-diam saja di masa lalu. <br><br>  Ngomong-ngomong, sekarang PVS-Studio juga dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">digunakan secara gratis</a> ketika bekerja dengan proyek terbuka. <br><br>  <b>SonarQube (SonarJava)</b> <br><br>  Kami percaya bahwa kami tidak bersaing dengan SonarQube, tetapi melengkapinya.  PVS-Studio terintegrasi dengan SonarQube, yang memungkinkan pengembang untuk menemukan lebih banyak kesalahan dan kerentanan potensial dalam proyek mereka.  Bagaimana cara mengintegrasikan alat PVS-Studio dan alat analisis lainnya ke SonarQube, kami secara teratur berbicara di kelas master yang kami selenggarakan di berbagai konferensi ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh</a> ). <br><br><h2>  Bagaimana cara memulai PVS-Studio untuk Java </h2><br>  Kami telah menyediakan bagi pengguna cara paling populer untuk mengintegrasikan alat analisis ke dalam sistem perakitan: <br><br><ul><li>  Plugin untuk Maven; </li><li>  Plugin untuk Gradle; </li><li>  Plugin untuk IntelliJ IDEA </li></ul><br>  Pada tahap pengujian, kami bertemu banyak pengguna yang memiliki sistem perakitan yang ditulis sendiri, terutama dalam pengembangan ponsel.  Mereka menyukai kemampuan untuk menjalankan analisa secara langsung, mendaftar sumber dan classpath. <br><br>  Anda dapat menemukan informasi terperinci tentang semua metode memulai analisa pada halaman dokumentasi " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara memulai PVS-Studio Java</a> ". <br><br>  Kami tidak dapat mengabaikan platform kontrol kualitas kode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SonarQube</a> , yang sangat populer di kalangan pengembang Java, jadi kami menambahkan dukungan bahasa Java ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">plugin SonarQube</a> kami. <br><br><h2>  Rencana selanjutnya </h2><br>  Kami memiliki banyak ide yang perlu dipelajari lebih lanjut, tetapi beberapa rencana khusus untuk analisis kami terlihat seperti ini: <br><br><ul><li>  Pembuatan diagnostik baru dan penyempurnaan yang sudah ada; </li><li>  Pengembangan analisis aliran data; </li><li>  Meningkatkan keandalan dan kegunaan. </li></ul><br>  Kami mungkin menemukan waktu untuk menyesuaikan plugin IntelliJ IDEA untuk CLion.  Hai C ++ kepada pengembang yang membaca tentang Java analyzer :-) <br><br><h2>  Contoh kesalahan ditemukan di proyek sumber terbuka </h2><br>  Saya tidak akan menjadi saya jika saya tidak menunjukkan kesalahan yang ditemukan menggunakan penganalisa baru dalam artikel.  Kita dapat mengambil beberapa proyek Java open source besar dan menulis artikel klasik dengan analisis kesalahan, seperti yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">biasa</a> kita <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lakukan</a> . <br><br>  Namun, saya segera meramalkan pertanyaan apakah kita dapat menemukan sesuatu dalam proyek seperti IntelliJ IDEA, FindBugs dan sebagainya.  Karena itu, saya tidak punya jalan keluar, dan saya akan memulai dengan tepat dengan proyek-proyek ini.  Jadi, saya memutuskan untuk segera memeriksa dan menulis beberapa contoh kesalahan yang menarik dari proyek-proyek berikut: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Edisi Komunitas IntelliJ IDEA</a> .  Saya pikir tidak perlu menjelaskan mengapa proyek ini dipilih :). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SpotBugs</a>  Seperti yang saya tulis sebelumnya, proyek FindBugs tidak berkembang.  Jadi lihatlah proyek SpotBugs, yang merupakan penerus FindBugs.  SpotBugs adalah penganalisa kode Java statis klasik. </li><li>  Beberapa proyek SonarSource, yang mengembangkan perangkat lunak untuk kontrol kualitas kode berkelanjutan.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lihatlah proyek SonarQube</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SonarJava</a> . </li></ul><br>  Menulis tentang bug dalam proyek-proyek ini adalah tugas yang sulit.  Faktanya adalah bahwa proyek-proyek ini berkualitas sangat tinggi.  Sebenarnya, ini tidak mengejutkan.  Seperti pengamatan kami menunjukkan, kode analisa statis selalu diuji dan diverifikasi dengan baik menggunakan alat lain. <br><br>  Terlepas dari semua ini, saya harus mulai dengan proyek-proyek ini.  Saya tidak akan memiliki kesempatan kedua untuk menulis sesuatu tentang mereka.  Saya yakin bahwa setelah rilis rilis PVS-Studio untuk Java, pengembang proyek ini akan menggunakan PVS-Studio dan akan mulai menggunakannya untuk pemeriksaan kode mereka secara teratur atau setidaknya secara berkala.  Sebagai contoh, saya tahu bahwa Tagir Valeyev ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">lany</a> ), salah satu pengembang JetBrains yang terlibat dalam penganalisis kode statis IntelliJ IDEA, sudah bermain dengan versi Beta PVS-Studio pada saat saya menulis artikel.  Dia telah menulis kepada kami sekitar 15 surat dengan laporan bug dan rekomendasi.  Tagir terima kasih! <br><br>  Untungnya, saya tidak perlu menemukan kesalahan sebanyak mungkin dalam satu proyek tertentu.  Sekarang tugas saya adalah untuk menunjukkan bahwa alat analisa PVS-Studio untuk Java muncul tidak sia-sia dan akan dapat mengisi garis alat lain yang dirancang untuk meningkatkan kualitas kode.  Saya baru saja membaca laporan analisa dan menulis beberapa kesalahan yang sepertinya menarik bagi saya.  Kapan pun memungkinkan, saya mencoba menulis kesalahan dari berbagai jenis.  Mari kita lihat apa yang terjadi. <br><br><h3>  Divisi Integer IDEA IntelliJ </h3><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkSentenceCapitalization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String value)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;String&gt; words = StringUtil.split(value, <span class="hljs-string"><span class="hljs-string">" "</span></span>); .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> capitalized = <span class="hljs-number"><span class="hljs-number">1</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> capitalized / words.size() &lt; <span class="hljs-number"><span class="hljs-number">0.2</span></span>; <span class="hljs-comment"><span class="hljs-comment">// allow reasonable amount of // capitalized words }</span></span></code> </pre> <br>  Peringatan PVS-Studio: V6011 [CWE-682] Literal '0,2' dari tipe 'ganda' dibandingkan dengan nilai tipe 'int'.  TitleCapitalizationInspection.java 169 <br><br>  Sebagaimana dimaksud, fungsi harus mengembalikan true jika kurang dari 20% dari kata-kata dimulai dengan huruf kapital.  Bahkan, pemeriksaan tidak berfungsi, karena pembagian bilangan bulat terjadi.  Sebagai hasil dari pembagian, hanya dua nilai yang dapat diperoleh: 0 atau 1. <br><br>  Fungsi akan mengembalikan nilai yang salah hanya jika semua kata dimulai dengan huruf kapital.  Dalam semua kasus lain, pembagian akan menghasilkan 0, dan fungsi akan mengembalikan nilai sebenarnya. <br><br><h3>  Siklus Mencurigakan IntelliJ IDEA </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findPreviousIndex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> current)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = myPainter.getErrorStripeCount(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> foundIndex = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> foundLayer = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= current &amp;&amp; current &lt; count) { current--; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = count - <span class="hljs-number"><span class="hljs-number">1</span></span>; index &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; index++) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= int layer = getLayer(index); if (layer &gt; foundLayer) { foundIndex = index; foundLayer = layer; } } .... }</span></span></code> </pre> <br>  Peringatan PVS-Studio: V6007 [CWE-571] Ekspresi 'indeks&gt; = 0' selalu benar.  Updater.java 184 <br><br>  Pertama, lihat kondisinya <i>(0 &lt;= saat &amp;&amp; saat ini &lt;hitung)</i> .  Ini hanya dieksekusi jika nilai variabel <i>jumlah</i> lebih besar dari 0. <br><br>  Sekarang lihat loop: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = count - <span class="hljs-number"><span class="hljs-number">1</span></span>; index &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; index++)</code> </pre> <br>  <i>Indeks</i> variabel diinisialisasi dengan jumlah ekspresi <i>- 1</i> .  Karena variabel <i>jumlah</i> lebih besar dari 0, nilai awal variabel <i>indeks</i> selalu lebih besar dari atau sama dengan 0. Ternyata loop akan dieksekusi sampai variabel <i>indeks</i> meluap. <br><br>  Kemungkinan besar, ini hanya salah ketik dan kenaikannya tidak boleh dieksekusi, tetapi penurunan variabel: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = count - <span class="hljs-number"><span class="hljs-number">1</span></span>; index &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; index--)</code> </pre> <br><h3>  IntelliJ IDEA, Copy-Paste </h3><br><pre> <code class="cpp hljs">@NonNls <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> final String BEFORE_STR_OLD = <span class="hljs-string"><span class="hljs-string">"before:"</span></span>; @NonNls <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> final String AFTER_STR_OLD = <span class="hljs-string"><span class="hljs-string">"after:"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isBeforeOrAfterKeyword</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String str, boolean trimKeyword)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (trimKeyword ? LoadingOrder.BEFORE_STR.trim() : LoadingOrder.BEFORE_STR).equalsIgnoreCase(str) || (trimKeyword ? LoadingOrder.AFTER_STR.trim() : LoadingOrder.AFTER_STR).equalsIgnoreCase(str) || LoadingOrder.BEFORE_STR_OLD.equalsIgnoreCase(str) || <span class="hljs-comment"><span class="hljs-comment">// &lt;= LoadingOrder.BEFORE_STR_OLD.equalsIgnoreCase(str); // &lt;= }</span></span></code> </pre> <br>  PVS-Studio Warning: V6001 [CWE-570] Ada sub-ekspresi identik 'LoadingOrder.BEFORE_STR_OLD.equalsIgnoreCase (str)' ke kiri dan ke kanan '||'  operator.  Periksa baris: 127, 128. ExtensionOrderConverter.java 127 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Efek</a> lama yang bagus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari baris terakhir</a> .  Si programmer bergegas dan, setelah mengalikan satu baris kode, lupa memperbaikinya.  Akibatnya, dua kali string <i>str</i> dibandingkan dengan <i>BEFORE_STR_OLD</i> .  Kemungkinan besar, salah satu perbandingan harus dengan <i>AFTER_STR_OLD</i> . <br><br><h3>  Kesalahan ketik IDEA IntelliJ </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> synchronized boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isIdentifier</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String name, final Project project)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!StringUtil.startsWithChar(name,<span class="hljs-string"><span class="hljs-string">'\''</span></span>) &amp;&amp; !StringUtil.startsWithChar(name,<span class="hljs-string"><span class="hljs-string">'\"'</span></span>)) { name = <span class="hljs-string"><span class="hljs-string">"\""</span></span> + name; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!StringUtil.endsWithChar(name,<span class="hljs-string"><span class="hljs-string">'"'</span></span>) &amp;&amp; !StringUtil.endsWithChar(name,<span class="hljs-string"><span class="hljs-string">'\"'</span></span>)) { name += <span class="hljs-string"><span class="hljs-string">"\""</span></span>; } .... }</code> </pre> <br>  PVS-Studio Warning: V6001 [CWE-571] Ada sub-ekspresi identik '! StringUtil.endsWithChar (nama,' "')' di sebelah kiri dan di sebelah kanan operator '&amp;&amp;'. JsonNamesValidator.java 27 <br><br>  Potongan kode ini memverifikasi bahwa nama itu dalam tanda kutip tunggal atau ganda.  Jika ini bukan masalahnya, tanda kutip ganda ditambahkan secara otomatis. <br><br>  Karena kesalahan ketik, akhir nama hanya diperiksa untuk tanda kutip ganda.  Akibatnya, nama yang diambil dalam tanda kutip tunggal tidak akan diproses dengan benar. <br><br>  Nama depan <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">'Abcd'</span></span></code> </pre> <br>  karena penambahan tanda kutip ganda tambahan itu akan berubah menjadi: <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">'Abcd'</span></span><span class="hljs-string"><span class="hljs-string">"</span></span></code> </pre> <br><h3>  IntelliJ IDEA, perlindungan overflow array yang salah </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Context </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = offset; i &lt; endOffset; i++) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c = text.charAt(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c == <span class="hljs-string"><span class="hljs-string">'&lt;'</span></span> &amp;&amp; i &lt; endOffset &amp;&amp; text.charAt(i + <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-string"><span class="hljs-string">'/'</span></span> &amp;&amp; startTag != null &amp;&amp; CharArrayUtil.regionMatches(text, i + <span class="hljs-number"><span class="hljs-number">2</span></span>, endOffset, startTag)) { endTagStartOffset = i; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } .... }</code> </pre> <br>  Peringatan PVS-Studio: V6007 [CWE-571] Ekspresi 'i &lt;endOffset' selalu benar.  MasukkanAfterJavadocTagHandler.java 183 <br><br>  Subekspresi <i>i &lt;endOffset</i> dalam kondisi <i>pernyataan if</i> tidak masuk akal.  Variabel <i>i</i> selalu kurang dari <i>endOffset</i> , sebagai berikut dari kondisi untuk mengeksekusi loop. <br><br>  Kemungkinan besar, pemrogram ingin melindungi dirinya dari keluar saat memanggil fungsi: <br><br><ul><li>  text.charAt (i +1) </li><li>  CharArrayUtil.regionMatches (teks, i + 2, endOffset, startTag) </li></ul><br>  Dalam hal ini, subekspresi untuk memeriksa indeks harus seperti ini: <i>i &lt;endOffset - 2</i> . <br><br><h3>  IntelliJ IDEA Ulangi Periksa </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateWarningMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer.length() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer.length() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { buffer.append(<span class="hljs-string"><span class="hljs-string">" "</span></span>).append( IdeBundle.message(<span class="hljs-string"><span class="hljs-string">"prompt.delete.and"</span></span>)).append(<span class="hljs-string"><span class="hljs-string">" "</span></span>); } } .... }</code> </pre> <br>  Peringatan PVS-Studio: V6007 [CWE-571] Ekspresi 'buffer.length ()&gt; 0' selalu benar.  DeleteUtil.java 62 <br><br>  Ini bisa berupa kode berlebihan yang tidak berbahaya atau kesalahan serius. <br><br>  Jika pemeriksaan duplikat muncul secara kebetulan, misalnya, selama refactoring, maka tidak ada yang salah dengan itu.  Pemeriksaan kedua hanya dapat dihapus. <br><br>  Tapi skenario lain mungkin terjadi.  Pemeriksaan kedua harus benar-benar berbeda dan kode tidak berlaku sebagaimana dimaksud.  Maka ini adalah kesalahan nyata. <br><br>  <b>Catatan</b>  Omong-omong, ada banyak cek berlebih yang berbeda.  Selain itu, sering terlihat bahwa ini bukan kesalahan.  Namun, pesan penganalisa juga tidak bisa disebut false positive.  Untuk memperjelas, berikut ini sebuah contoh, juga diambil dari IntelliJ IDEA: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isMultiline</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PsiElement element)</span></span></span><span class="hljs-function"> </span></span>{ String text = element.getText(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> text.contains(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>) || text.contains(<span class="hljs-string"><span class="hljs-string">"\r"</span></span>) || text.contains(<span class="hljs-string"><span class="hljs-string">"\r\n"</span></span>); }</code> </pre> <br>  Penganalisa mengatakan bahwa fungsi <i>text.contains ("\ r \ n")</i> selalu mengembalikan false.  Memang, jika simbol "\ n" dan "\ r" tidak ditemukan, maka tidak ada gunanya mencari "\ r \ n".  Ini bukan kesalahan, dan kode itu buruk hanya karena kerjanya sedikit lebih lambat, melakukan pencarian yang tidak berarti untuk substring. <br><br>  Bagaimana menangani kode seperti itu, dalam setiap kasus, terserah programmer untuk memutuskan.  Saat menulis artikel, sebagai aturan, saya tidak memperhatikan kode tersebut. <br><br><h3>  IntelliJ IDEA, ada sesuatu yang salah </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">satisfiedBy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull PsiElement element)</span></span></span><span class="hljs-function"> </span></span>{ .... @NonNls final String text = expression.getText().replaceAll(<span class="hljs-string"><span class="hljs-string">"_"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (text == null || text.length() &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">"0"</span></span>.equals(text) || <span class="hljs-string"><span class="hljs-string">"0L"</span></span>.equals(text) || <span class="hljs-string"><span class="hljs-string">"0l"</span></span>.equals(text)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> text.charAt(<span class="hljs-number"><span class="hljs-number">0</span></span>) == <span class="hljs-string"><span class="hljs-string">'0'</span></span>; }</code> </pre> <br>  Peringatan PVS-Studio: V6007 [CWE-570] Ekspresi '"0". Equals (text)' selalu salah.  ConvertIntegerToDecimalPredicate.java 46 <br><br>  Kode ini jelas mengandung kesalahan logis.  Tetapi saya merasa sulit untuk mengatakan apa yang ingin diperiksa oleh programmer, dan bagaimana cara memperbaiki cacat tersebut.  Karena itu, di sini saya hanya akan menunjukkan pemeriksaan yang tidak berarti. <br><br>  Pada awalnya, diperiksa bahwa string harus mengandung setidaknya dua karakter.  Jika tidak, maka fungsi mengembalikan <i>false</i> . <br><br>  Berikut ini adalah tanda <i>“0”. Sama dengan (teks)</i> .  Ini tidak ada artinya, karena sebuah string tidak dapat berisi hanya satu karakter. <br><br>  Secara umum, ada sesuatu yang salah di sini dan kode harus diperbaiki. <br><br><h3>  SpotBugs (penerus FindBugs), kesalahan batas iterasi </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getXMLType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@WillNotClose InputStream in)</span></span></span><span class="hljs-function"> throws IOException </span></span>{ .... String s; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (count &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) { s = r.readLine(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s == null) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } Matcher m = tag.matcher(s); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m.find()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m.group(<span class="hljs-number"><span class="hljs-number">1</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IOException(<span class="hljs-string"><span class="hljs-string">"Didn't find xml tag"</span></span>); .... }</code> </pre> <br>  Peringatan PVS-Studio: V6007 [CWE-571] Ekspresi 'count &lt;4' selalu benar.  Util.java 394 <br><br>  Sesuai rencana, pencarian untuk tag xml harus dilakukan hanya dalam empat baris pertama file.  Tetapi karena fakta bahwa mereka lupa untuk menambah jumlah variabel, seluruh file akan dibaca. <br><br>  Pertama, ini bisa berubah menjadi operasi yang sangat lambat, dan kedua, di suatu tempat di tengah file dapat ditemukan sesuatu yang akan ditafsirkan sebagai tag xml, tetapi tidak akan seperti itu. <br><br><h3>  SpotBugs (penerus FindBugs), nilai yang ditimpa </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reportBug</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> priority = LOW_PRIORITY; String pattern = <span class="hljs-string"><span class="hljs-string">"NS_NON_SHORT_CIRCUIT"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sawDangerOld) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sawNullTestVeryOld) { priority = HIGH_PRIORITY; <span class="hljs-comment"><span class="hljs-comment">// &lt;= } if (sawMethodCallOld || sawNumericTestVeryOld &amp;&amp; sawArrayDangerOld) { priority = HIGH_PRIORITY; // &lt;= pattern = "NS_DANGEROUS_NON_SHORT_CIRCUIT"; } else { priority = NORMAL_PRIORITY; // &lt;= } } bugAccumulator.accumulateBug( new BugInstance(this, pattern, priority).addClassAndMethod(this), this); }</span></span></code> </pre> <br>  Peringatan PVS-Studio: V6021 [CWE-563] Nilai ini ditetapkan untuk variabel 'prioritas' tetapi tidak digunakan.  FindNonShortCircuit.java 197 <br><br>  Nilai variabel <i>prioritas</i> diatur tergantung pada nilai variabel <i>sawNullTestVeryOld</i> .  Namun, ini tidak memainkan peran apa pun.  Selanjutnya, variabel <i>prioritas</i> akan diberi nilai berbeda dalam hal apa pun.  Kesalahan yang jelas dalam logika fungsi. <br><br><h3>  SonarQube, Salin-Tempel </h3><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RuleDto</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> final RuleDefinitionDto definition; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> final RuleMetadataDto metadata; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUpdatedAtFromDefinition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nullable Long updatedAt)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (updatedAt != null &amp;&amp; updatedAt &gt; definition.getUpdatedAt()) { setUpdatedAt(updatedAt); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUpdatedAtFromMetadata</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nullable Long updatedAt)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (updatedAt != null &amp;&amp; updatedAt &gt; definition.getUpdatedAt()) { setUpdatedAt(updatedAt); } } .... }</code> </pre> <br>  PVS-Studio: V6032 Aneh bahwa tubuh metode 'setUpdatedAtFromDefinition' sepenuhnya setara dengan tubuh metode lain 'setUpdatedAtFromMetadata'.  Periksa baris: 396, 405. RuleDto.java 396 <br><br>  Metode <i>setUpdatedAtFromMetadata</i> menggunakan bidang <i>definisi</i> .  Kemungkinan besar, bidang <i>metadata</i> harus digunakan.  Ini sangat mirip dengan konsekuensi dari Copy-Paste gagal. <br><br><h3>  SonarJava, duplikat pada inisialisasi Peta </h3><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> final Map&lt;JavaPunctuator, Tree.Kind&gt; assignmentOperators = Maps.newEnumMap(JavaPunctuator.class); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">KindMaps</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... assignmentOperators.put(JavaPunctuator.PLUSEQU, Tree.Kind.PLUS_ASSIGNMENT); .... assignmentOperators.put(JavaPunctuator.PLUSEQU, Tree.Kind.PLUS_ASSIGNMENT); .... }</code> </pre> <br>  Peringatan PVS-Studio: V6033 [CWE-462] Item dengan kunci yang sama 'JavaPunctuator.PLUSEQU' telah ditambahkan.  Periksa baris: 104, 100. KindMaps.java 104 <br><br>  Pasangan nilai kunci yang sama ditempatkan dua kali dalam kartu.  Kemungkinan besar, ini ternyata lalai, dan sebenarnya tidak ada kesalahan nyata.  Namun, dalam hal apa pun, kode ini perlu diperiksa, karena Anda mungkin lupa menambahkan beberapa pasangan lain. <br><br><h2>  Kesimpulan </h2><br>  Tapi apa kesimpulannya?!  Saya mengundang semua orang, tanpa penundaan, untuk mengunduh PVS-Studio dan mencoba menguji proyek Anda yang sedang berjalan di Jawa!  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Unduh PVS-Studio</a> . <br><br>  Terima kasih atas perhatiannya.  Saya berharap bahwa segera kami akan menyenangkan pembaca dengan serangkaian artikel yang ditujukan untuk memeriksa berbagai proyek Java terbuka. <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br>  Jika Anda ingin berbagi artikel ini dengan audiens yang berbahasa Inggris, silakan gunakan tautan ke terjemahan: Andrey Karpov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PVS-Studio untuk Java</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id436434/">https://habr.com/ru/post/id436434/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id436424/index.html">Makhluk kecil, perbuatan besar: peran pemotong daun dalam efek rumah kaca neotropik</a></li>
<li><a href="../id436426/index.html">Jeda aplikasi jika koneksi jaringan terputus</a></li>
<li><a href="../id436428/index.html">Mengapa kita mendukung program olahraga</a></li>
<li><a href="../id436430/index.html">Pengakuan seorang graphomaniac</a></li>
<li><a href="../id436432/index.html">SAP: Apa yang Anda butuhkan untuk mulai belajar SAPUI5?</a></li>
<li><a href="../id436436/index.html">CERN berencana untuk membangun akselerator baru dengan panjang terowongan 100 km</a></li>
<li><a href="../id436438/index.html">Roscosmos menyebut kemungkinan alasan hilangnya komunikasi dengan observatorium orbital Spektr-R</a></li>
<li><a href="../id436440/index.html">Gotta Go Fast: Membangun untuk Kecepatan di iOS. Bagian 2</a></li>
<li><a href="../id436442/index.html">Satu kepala baik, dan dua lebih baik, atau memasangkan pemrograman dalam aksi</a></li>
<li><a href="../id436444/index.html">Penyebaran aplikasi monolitik yang tak terlihat dalam produksi di AWS. Pengalaman pribadi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>