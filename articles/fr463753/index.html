<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👧‍👦 👮 🍴 PVS-Studio visite Apache Hive 🎫 👂🏾 🙆🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Au cours des dix dernières années, le mouvement open-source a été l'un des principaux moteurs du développement de l'industrie informatique et sa compo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PVS-Studio visite Apache Hive</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/463753/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ad/2d0/eb3/0ad2d0eb30d726eefba9c913edaa346a.png" alt="Figure 1"></div><br>  Au cours des dix dernières années, le mouvement open-source a été l'un des principaux moteurs du développement de l'industrie informatique et sa composante cruciale.  Le rôle des projets open source prend de plus en plus d'importance non seulement en termes de quantité mais également en termes de qualité, ce qui modifie le concept même de leur positionnement sur le marché informatique en général.  Notre courageuse équipe PVS-Studio ne reste pas les bras croisés et participe activement au renforcement de la présence de logiciels open source en trouvant des bogues cachés dans les profondeurs énormes des bases de code et en offrant des options de licence gratuites aux auteurs de tels projets.  Cet article n'est qu'une autre partie de cette activité!  Aujourd'hui, nous allons parler d'Apache Hive.  J'ai le rapport - et il y a des choses qui méritent d'être examinées. <br><a name="habracut"></a><br><h2>  À propos de PVS-Studio </h2><br>  L'analyseur de code statique <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PVS-Studio</a> , qui existe depuis plus de 10 ans maintenant, est une solution logicielle multifonctionnelle et facile à intégrer.  À l'heure actuelle, il prend en charge C, C ++, C # et Java et s'exécute sur Windows, Linux et macOS. <br><br>  PVS-Studio est une solution B2B payante utilisée par de nombreuses équipes dans plusieurs entreprises.  Si vous voulez essayer l'analyseur, visitez cette <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">page</a> pour télécharger la distribution et demander une clé d'essai. <br><br>  Si vous êtes un geek open-source ou, disons, un étudiant, vous pouvez profiter de l'une de nos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">options de</a> licence gratuites. <br><br><h2>  À propos d'Apache Hive </h2><br>  La quantité de données a augmenté à un rythme énorme au cours des dernières années.  Les bases de données standard ne peuvent plus faire face à cette croissance rapide, d'où le terme Big Data ainsi que d'autres notions connexes (telles que le traitement, le stockage et d'autres opérations sur les Big Data). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Apache Hadoop</a> est actuellement considéré comme l'une des technologies pionnières du Big Data.  Ses tâches principales sont le stockage, le traitement et la gestion de grandes quantités de données.  Les principaux composants du cadre sont Hadoop Common, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HDFS</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Hadoop MapReduce</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Hadoop YARN</a> .  Au fil du temps, un vaste écosystème de projets et de technologies connexes s'est développé autour de Hadoop, dont beaucoup ont initialement commencé dans le cadre du projet, puis se sont développés pour devenir indépendants.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Apache Hive</a> est l'un d'entre eux. <br><br>  Apache Hive est un entrepôt de données distribué.  Il gère les données stockées dans HDFS et fournit le langage de requête basé sur SQL (HiveQL) pour gérer ces données.  Plus de détails sur le projet peuvent être trouvés <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><h2>  Exécution de l'analyse </h2><br>  Il n'a pas fallu beaucoup d'efforts ou de temps pour commencer l'analyse.  Voici mon algorithme: <br><br><ul><li>  Téléchargé Apache Hive depuis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> ; </li><li>  Lisez le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">guide</a> sur le démarrage de l'analyseur Java et lancez l'analyse; </li><li>  A obtenu le rapport de l'analyseur, l'a étudié et a écrit les cas les plus intéressants. </li></ul><br>  Les résultats de l'analyse sont les suivants: 1456 avertissements de niveaux élevé et moyen (602 et 854 respectivement) sur plus de 6 500 fichiers. <br><br>  Tous les avertissements ne font pas référence à de véritables bogues.  C'est tout à fait normal;  vous devez modifier les paramètres de l'analyseur avant de commencer à l'utiliser régulièrement.  Après cela, vous vous attendez généralement à un taux assez faible de faux positifs ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exemple</a> ). <br><br>  J'ai omis les 407 avertissements (177 niveau élevé et 230 niveau moyen) déclenchés par les fichiers de test.  J'ai également ignoré le diagnostic <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V6022</a> (car vous ne pouvez pas distinguer de manière fiable les fragments défectueux et corrects lorsque vous n'êtes pas familier avec le code), qui a été déclenché jusqu'à 482 fois.  Je n'ai pas non plus examiné les 179 avertissements générés par le diagnostic <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V6021</a> . <br><br>  En fin de compte, j'avais encore assez d'avertissements pour y aller, et comme je n'ai pas modifié les paramètres, il y a toujours un certain pourcentage de faux positifs parmi eux.  Cela ne sert à rien d'inclure trop d'avertissements dans un article comme celui-ci :).  Nous allons donc simplement parler de ce qui a attiré mon attention et qui avait l'air assez curieux. <br><br><h2>  Conditions prédéterminées </h2><br>  Parmi les diagnostics examinés pour cette analyse, le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V6007</a> détient un record pour le nombre d'avertissements émis.  Un peu plus de 200 messages !!!  Certains semblent inoffensifs, d'autres méfiants et d'autres sont de véritables bogues après tout!  Jetons un coup d'œil à certains d'entre eux. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V6007</a> Expression 'key.startsWith ("hplsql.")' Est toujours vrai.  Exec.java (675) <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initOptions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key == null || value == null || !key.startsWith(<span class="hljs-string"><span class="hljs-string">"hplsql."</span></span>)) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= continue; } else if (key.compareToIgnoreCase(Conf.CONN_DEFAULT) == 0) { .... } else if (key.startsWith("hplsql.conn.init.")) { .... } else if (key.startsWith(Conf.CONN_CONVERT)) { .... } else if (key.startsWith("hplsql.conn.")) { .... } else if (key.startsWith("hplsql.")) { // &lt;= .... } }</span></span></code> </pre> <br>  C'est une construction if-else-if assez longue!  L'analyseur n'aime pas la condition dans le dernier <i>if (key.startsWith ("hplsql."))</i> Parce que si l'exécution l'atteint, cela signifie que c'est vrai.  En effet, si vous regardez la première ligne de cette construction if-else-if, vous verrez qu'elle contient déjà la vérification opposée, donc si la chaîne ne commence pas par <i>"hplsql".</i>  , l'exécution sautera immédiatement à la prochaine itération. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V6007 L'</a> expression 'columnNameProperty.length () == 0' est toujours fausse.  OrcRecordUpdater.java (238) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> TypeDescription </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTypeDescriptionFromTableProperties</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tableProperties != null) { final String columnNameProperty = ....; final String columnTypeProperty = ....; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !Strings.isNullOrEmpty(columnNameProperty) &amp;&amp; !Strings.isNullOrEmpty(columnTypeProperty)) { List&lt;String&gt; columnNames = columnNameProperty.length() == <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;String&gt;() : ....; List&lt;TypeInfo&gt; columnTypes = columnTypeProperty.length() == <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;TypeInfo&gt;() : ....; .... } } } .... }</code> </pre> <br>  La comparaison de la <i>longueur de la</i> chaîne <i>columnNameProperty</i> avec zéro renvoie toujours <i>false</i> .  Cela se produit car cette comparaison suit la <i>vérification! Strings.isNullOrEmpty (columnNameProperty)</i> .  Donc, si l'exécution atteint notre condition, cela signifie que la chaîne <i>columnNameProperty</i> n'est sûrement ni nulle ni vide. <br><br>  Il en va de même pour la chaîne <i>columnTypeProperty</i> une ligne plus tard: <br><br><ul><li>  V6007 L'expression 'columnTypeProperty.length () == 0' est toujours fausse.  OrcRecordUpdater.java (239) </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V6007 L'</a> expression 'colOrScalar1.equals ("Column")' est toujours fausse.  GenVectorCode.java (3469) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateDateTimeArithmeticIntervalYearMonth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] tdesc)</span></span></span><span class="hljs-function"> throws Exception </span></span>{ .... String colOrScalar1 = tdesc[<span class="hljs-number"><span class="hljs-number">4</span></span>]; .... String colOrScalar2 = tdesc[<span class="hljs-number"><span class="hljs-number">6</span></span>]; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colOrScalar1.equals(<span class="hljs-string"><span class="hljs-string">"Col"</span></span>) &amp;&amp; colOrScalar1.equals(<span class="hljs-string"><span class="hljs-string">"Column"</span></span>)) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { .... } else if (colOrScalar1.equals("Col") &amp;&amp; colOrScalar1.equals("Scalar")) { .... } else if (colOrScalar1.equals("Scalar") &amp;&amp; colOrScalar1.equals("Column")) { .... } }</span></span></code> </pre><br>  Le bon vieux copier-coller.  Du point de vue de la logique actuelle, la chaîne <i>colOrScalar1</i> peut avoir deux valeurs différentes à la fois, ce qui est impossible.  De toute évidence, les contrôles doivent avoir la variable <i>colOrScalar1</i> à gauche et <i>colOrScalar2</i> à droite. <br><br>  Avertissements similaires quelques lignes ci-dessous: <br><br><ul><li>  V6007 L'expression 'colOrScalar1.equals ("Scalar")' est toujours fausse.  GenVectorCode.java (3475) </li><li>  V6007 L'expression 'colOrScalar1.equals ("Column")' est toujours fausse.  GenVectorCode.java (3486) </li></ul><br>  Par conséquent, cette construction if-else-if ne fera jamais rien. <br><br>  Quelques autres avertissements <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V6007</a> : <br><br><ul><li>  V6007 L'expression "caractères == null" est toujours fausse.  RandomTypeUtil.java (43) </li><li>  V6007 L'expression 'writeIdHwm&gt; 0' est toujours fausse.  TxnHandler.java (1603) </li><li>  V6007 L'expression 'fields.equals ("*")' est toujours vraie.  Server.java (983) </li><li>  V6007 L'expression 'currentGroups! = Null' est toujours vraie.  GenericUDFCurrentGroups.java (90) </li><li>  V6007 L'expression 'this.wh == null' est toujours fausse.  Nouveau retourne une référence non nulle.  StorageBasedAuthorizationProvider.java (93), StorageBasedAuthorizationProvider.java (92) </li><li>  et ainsi de suite ... </li></ul><br><h2>  NPE </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V6008 Déréférence</a> nulle potentielle de 'dagLock'.  QueryTracker.java (557), QueryTracker.java (553) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleFragmentCompleteExternalQuery</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(QueryInfo queryInfo)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (queryInfo.isExternalQuery()) { ReadWriteLock dagLock = getDagLock(queryInfo.getQueryIdentifier()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dagLock == null) { LOG.warn(<span class="hljs-string"><span class="hljs-string">"Ignoring fragment completion for unknown query: {}"</span></span>, queryInfo.getQueryIdentifier()); } boolean locked = dagLock.writeLock().tryLock(); ..... } }</code> </pre> <br>  Un objet nul est intercepté, enregistré et ... le programme continue de fonctionner.  Par conséquent, la vérification est suivie d'une déréférence de pointeur nulle.  Aïe! <br><br>  Les développeurs doivent avoir réellement voulu que le programme quitte la fonction ou lève une exception spéciale dans le cas de l'obtention d'une référence nulle. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V6008 Déréférence</a> nulle de 'buffer' dans la fonction 'unlockSingleBuffer'.  MetadataCache.java (410), MetadataCache.java (465) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lockBuffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LlapBufferOrBuffers buffers, ....)</span></span></span><span class="hljs-function"> </span></span>{ LlapAllocatorBuffer buffer = buffers.getSingleLlapBuffer(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer != null) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= return lockOneBuffer(buffer, doNotifyPolicy); } LlapAllocatorBuffer[] bufferArray = buffers.getMultipleLlapBuffers(); for (int i = 0; i &lt; bufferArray.length; ++i) { if (lockOneBuffer(bufferArray[i], doNotifyPolicy)) continue; for (int j = 0; j &lt; i; ++j) { unlockSingleBuffer(buffer, true); // &lt;= } .... } .... } .... private void unlockSingleBuffer(LlapAllocatorBuffer buffer, ....) { boolean isLastDecref = (buffer.decRef() == 0); // &lt;= if (isLastDecref) { .... } }</span></span></code> </pre> <br>  Un autre NPE potentiel.  Si l'exécution atteint la méthode <i>unlockSingleBuffer</i> , cela signifie que l'objet <i>tampon</i> est nul.  Supposons que c'est ce qui s'est passé!  Si vous regardez la méthode <i>unlockSingleBuffer</i> , vous remarquerez comment notre objet est déréférencé directement dans la première ligne.  Gotcha! <br><br><h2>  Un changement devenu fou </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V6034 Le</a> décalage de la valeur de 'bitShiftsInWord - 1' peut être incompatible avec la taille du type: 'bitShiftsInWord - 1' = [-1 ... 30].  UnsignedInt128.java (1791) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shiftRightDestructive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wordShifts, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bitShiftsInWord, boolean roundUp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wordShifts == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; bitShiftsInWord == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } assert (wordShifts &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>); assert (bitShiftsInWord &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>); assert (bitShiftsInWord &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wordShifts &gt;= <span class="hljs-number"><span class="hljs-number">4</span></span>) { zeroClear(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } final <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> shiftRestore = <span class="hljs-number"><span class="hljs-number">32</span></span> - bitShiftsInWord; <span class="hljs-comment"><span class="hljs-comment">// check this because "123 &lt;&lt; 32" will be 123. final boolean noRestore = bitShiftsInWord == 0; final int roundCarryNoRestoreMask = 1 &lt;&lt; 31; final int roundCarryMask = (1 &lt;&lt; (bitShiftsInWord - 1)); // &lt;= .... }</span></span></code> </pre> <br>  Il s'agit d'un décalage potentiel de -1.  Si la méthode est appelée avec, disons, <i>wordShifts == 3</i> et <i>bitShiftsInWord == 0</i> , la ligne signalée se terminera par 1 &lt;&lt; -1.  Est-ce un comportement planifié? <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V6034 Le</a> décalage de la valeur de 'j' peut être incompatible avec la taille du type: 'j' = [0 ... 63].  IoTrace.java (272) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logSargResult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> stripeIx, boolean[] rgsToRead)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, valOffset = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; elements; ++i, valOffset += <span class="hljs-number"><span class="hljs-number">64</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> val = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">64</span></span>; ++j) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ix = valOffset + j; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rgsToRead.length == ix) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!rgsToRead[ix]) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; val = val | (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; j); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } .... } .... }</span></span></code> </pre> <br>  Dans la ligne rapportée, la variable <i>j</i> peut avoir une valeur dans la plage [0 ... 63].  Pour cette raison, le calcul de la valeur de <i>val</i> dans la boucle peut s'exécuter de manière inattendue.  Dans l'expression <i>(1 &lt;&lt; j)</i> , la valeur 1 est de type <i>int</i> , donc la décaler de 32 bits et plus nous emmène au-delà des limites de la plage du type.  Cela peut être corrigé en écrivant <i>((long) 1 &lt;&lt; j)</i> . <br><br><h2>  Se laisser emporter par la journalisation </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V6046</a> Format incorrect.  Un nombre différent d'éléments de format est attendu.  Arguments non utilisés: 1, 2. StatsSources.java (89) <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ImmutableList&lt;PersistedRuntimeStats&gt; extractStatsFromPlanMapper (....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stat.size() &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> || sig.size() &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { StringBuffer sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuffer(); sb.append(String.format( <span class="hljs-string"><span class="hljs-string">"expected(stat-sig) 1-1, got {}-{} ;"</span></span>, <span class="hljs-comment"><span class="hljs-comment">// &lt;= stat.size(), sig.size() )); .... } .... if (e.getAll(OperatorStats.IncorrectRuntimeStatsMarker.class).size() &gt; 0) { LOG.debug( "Ignoring {}, marked with OperatorStats.IncorrectRuntimeStatsMarker", sig.get(0) ); continue; } .... }</span></span></code> </pre> <br>  Lors de l'écriture du code pour formater la chaîne à l'aide de <i>String.format ()</i> , le développeur a utilisé une syntaxe incorrecte.  Par conséquent, les paramètres passés n'ont jamais atteint la chaîne résultante.  Je suppose que le développeur avait travaillé sur la journalisation avant d'écrire ceci, d'où il a emprunté la syntaxe. <br><br><h2>  Une exception volée </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V6051</a> L'utilisation de l'instruction 'return' dans le bloc 'finalement' peut entraîner la perte d'exceptions non gérées.  ObjectStore.java (9080) <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;MPartitionColumnStatistics&gt; getMPartitionColumnStatistics(....) throws NoSuchObjectException, MetaException { boolean committed = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { .... <span class="hljs-comment"><span class="hljs-comment">/*some actions*/</span></span> committed = commitTransaction(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { LOG.error(<span class="hljs-string"><span class="hljs-string">"Error retrieving statistics via jdo"</span></span>, ex); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ex instanceof MetaException) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> (MetaException) ex; } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MetaException(ex.getMessage()); } finally { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!committed) { rollbackTransaction(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Lists.newArrayList(); } } }</code> </pre> <br>  Renvoyer quoi que ce soit du bloc <i>finally</i> est une très mauvaise pratique, et cet exemple montre clairement pourquoi. <br><br>  Dans le bloc <i>try</i> , le programme forme une demande et accède au stockage.  La variable validée a la valeur <i>false</i> par défaut et ne change son état qu'après l'exécution réussie de toutes les actions précédentes du bloc <i>try</i> .  Cela signifie que si une exception est déclenchée, cette variable sera toujours <i>fausse</i> .  Le bloc catch interceptera l'exception, l'ajustera un peu et le lancera.  Donc, quand c'est le tour du bloc <i>finalement</i> , l'exécution entrera dans la condition à partir de laquelle une liste vide sera retournée.  Que nous coûte ce retour?  Eh bien, cela nous coûte d'éviter que toute exception capturée ne soit jetée à l'extérieur où elle pourrait être correctement gérée.  Aucune des exceptions spécifiées dans la signature de la méthode ne sera levée;  ils sont tout simplement trompeurs. <br><br>  Un message de diagnostic similaire: <br><br><ul><li>  V6051 L'utilisation de l'instruction 'return' dans le bloc 'finalement' peut entraîner la perte d'exceptions non gérées.  ObjectStore.java (808) </li></ul><br><h2>  Divers </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V6009 La</a> fonction 'compareTo' reçoit un argument impair.  Un objet 'o2.getWorkerIdentity ()' est utilisé comme argument de sa propre méthode.  LlapFixedRegistryImpl.java (244) <br><br><pre> <code class="cpp hljs">@Override <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;LlapServiceInstance&gt; getAllInstancesOrdered(....) { .... Collections.sort(<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Comparator&lt;LlapServiceInstance&gt;() { @Override <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> compare(LlapServiceInstance o1, LlapServiceInstance o2) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> o2.getWorkerIdentity().compareTo(o2.getWorkerIdentity()); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } }); .... }</span></span></code> </pre> <br>  Il pourrait y avoir un certain nombre de causes menant à une erreur aussi stupide: copier-coller, négligence, hâte, etc.  Nous voyons souvent des erreurs comme ça dans les projets open-source et nous avons même un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> entier à ce sujet. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V6020</a> Divisez par zéro.  La plage des valeurs du dénominateur du «diviseur» comprend zéro.  SqlMathUtil.java (265) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divideUnsignedLong</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dividend, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> divisor)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (divisor &lt; <span class="hljs-number"><span class="hljs-number">0L</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/*some comments*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (compareUnsignedLong(dividend, divisor)) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">0L</span></span> : <span class="hljs-number"><span class="hljs-number">1L</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dividend &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Both inputs non-negative return dividend / divisor; // &lt;= } else { .... } }</span></span></code> </pre> <br>  Celui-ci est assez banal.  Une série de contrôles a été impuissante pour éviter la division par zéro. <br><br>  Quelques avertissements supplémentaires: <br><br><ul><li>  V6020 Mod par zéro.  La plage des valeurs du dénominateur du «diviseur» comprend zéro.  SqlMathUtil.java (309) </li><li>  V6020 Divisez par zéro.  La plage des valeurs du dénominateur du «diviseur» comprend zéro.  SqlMathUtil.java (276) </li><li>  V6020 Divisez par zéro.  La plage des valeurs du dénominateur du «diviseur» comprend zéro.  SqlMathUtil.java (312) </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V6030</a> La méthode située à droite du '|'  L'opérateur sera appelé quelle que soit la valeur de l'opérande gauche.  Peut-être vaut-il mieux utiliser '||'.  OperatorUtils.java (573) <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Operator&lt;? extends OperatorDesc&gt; findSourceRS(....) { .... List&lt;Operator&lt;? extends OperatorDesc&gt;&gt; parents = ....; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parents == null | parents.isEmpty()) { <span class="hljs-comment"><span class="hljs-comment">// reached end eg TS operator return null; } .... }</span></span></code> </pre> <br>  Le programmeur a écrit l'opérateur au niveau du bit |  au lieu de la logique ||.  Cela signifie que la partie droite sera exécutée quel que soit le résultat de la partie gauche.  Si <i>parents == null</i> , cette faute de frappe se terminera avec un droit NPE dans la prochaine sous-expression logique. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V6042</a> La <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">compatibilité de</a> l'expression avec le type «A» est vérifiée, mais elle est convertie en type «B».  VectorColumnAssignFactory.java (347) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> VectorColumnAssign </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buildObjectAssign</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VectorizedRowBatch outputBatch, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> outColIndex, PrimitiveCategory category)</span></span></span><span class="hljs-function"> throws HiveException </span></span>{ VectorColumnAssign outVCA = null; ColumnVector destCol = outputBatch.cols[outColIndex]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (destCol == null) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (destCol instanceof LongColumnVector) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(category) { .... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> LONG: outVCA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> VectorLongColumnAssign() { .... } .init(.... , (LongColumnVector) destCol); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TIMESTAMP: outVCA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> VectorTimestampColumnAssign() { .... }.init(...., (TimestampColumnVector) destCol); <span class="hljs-comment"><span class="hljs-comment">// &lt;= break; case DATE: outVCA = new VectorLongColumnAssign() { .... } .init(...., (LongColumnVector) destCol); break; case INTERVAL_YEAR_MONTH: outVCA = new VectorLongColumnAssign() { .... }.init(...., (LongColumnVector) destCol); break; case INTERVAL_DAY_TIME: outVCA = new VectorIntervalDayTimeColumnAssign() { .... }.init(...., (IntervalDayTimeColumnVector) destCol);// &lt;= break; default: throw new HiveException(....); } } else if (destCol instanceof DoubleColumnVector) { .... } .... else { throw new HiveException(....); } return outVCA; }</span></span></code> </pre> <br>  Nous sommes intéressés par les classes <i>LongColumnVector étend ColumnVector</i> et <i>TimestampColumnVector étend ColumnVector</i> .  La vérification que l'objet <i>destCol</i> est une instance de <i>LongColumnVector</i> suggère explicitement que c'est un objet de cette classe qui sera traité dans le corps de l'instruction conditionnelle.  Malgré cela, cependant, il est toujours casté dans <i>TimestampColumnVector</i> !  Comme vous pouvez le voir, ce sont des classes différentes, sauf qu'elles sont dérivées du même parent.  Par conséquent, nous obtenons une <i>exception ClassCastException</i> . <br><br>  La même chose est vraie dans le cas de la conversion en <i>IntervalDayTimeColumnVector</i> : <br><br><ul><li>  V6042 La compatibilité de l'expression avec le type «A» est vérifiée, mais elle est convertie en type «B».  VectorColumnAssignFactory.java (390) </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V6060</a> La référence «var» a été utilisée avant d'être vérifiée par rapport à null.  Var.java (402), Var.java (395) <br><br><pre> <code class="cpp hljs">@<span class="hljs-function"><span class="hljs-function">Override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object obj)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (getClass() != obj.getClass()) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= return false; } Var var = (Var)obj; if (this == var) { return true; } else if (var == null || // &lt;= var.value == null || this.value == null) { return false; } .... }</span></span></code> </pre> <br>  Ici, vous voyez une étrange vérification de l'objet <i>var</i> pour <i>null</i> après que la déréférence s'est déjà produite.  Dans ce contexte, <i>var</i> et <i>obj</i> sont le même objet ( <i>var = (Var) obj</i> ).  La présence de la vérification <i>nulle</i> implique que l'objet transmis peut être nul.  Donc, appeler <i>égal (nul)</i> se traduira par un NPE, au lieu du <i>faux</i> attendu, juste à la première ligne.  Oui, le chèque <i>est</i> là, mais, malheureusement, il est au mauvais endroit. <br><br>  Quelques autres cas similaires, où un objet est utilisé avant la vérification: <br><br><ul><li>  V6060 La référence «valeur» a été utilisée avant d'être vérifiée par rapport à null.  ParquetRecordReaderWrapper.java (168), ParquetRecordReaderWrapper.java (166) </li><li>  V6060 La référence 'defaultConstraintCols' a été utilisée avant d'être vérifiée par rapport à null.  HiveMetaStore.java (2539), HiveMetaStore.java (2530) </li><li>  V6060 La référence 'projIndxLst' a été utilisée avant d'être vérifiée par rapport à null.  RelOptHiveTable.java (683), RelOptHiveTable.java (682) </li><li>  V6060 La référence «oldp» a été utilisée avant d'être vérifiée par rapport à null.  ObjectStore.java (4343), ObjectStore.java (4339) </li><li>  et ainsi de suite ... </li></ul><br><h2>  Conclusion </h2><br>  Si vous vous êtes déjà intéressé au Big Data, ne serait-ce qu'un peu, alors vous pourriez à peine ignorer l'importance d'Apache Hive.  Il s'agit d'un projet populaire et assez important, composé de plus de 6500 fichiers source (* .java).  De nombreux développeurs l'ont écrit depuis de nombreuses années, ce qui signifie qu'il y a beaucoup de choses qu'un analyseur statique peut y trouver.  Cela prouve une fois de plus que l'analyse statique est extrêmement importante et utile lors du développement de projets de moyenne et grande envergure! <br><br>  Remarque  Les vérifications ponctuelles comme celle que j'ai faite ici sont bonnes pour présenter les capacités de l'analyseur, mais sont un scénario totalement inapproprié de l'utiliser.  Cette idée est développée <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  L'analyse statique doit être utilisée régulièrement! <br><br>  Cette vérification de Hive a révélé pas mal de défauts et de fragments suspects.  Si les auteurs d'Apache Hive rencontrent cet article, nous serons heureux de vous aider dans la tâche difficile d'améliorer le projet. <br><br>  Vous ne pouvez pas imaginer Apache Hive sans Apache Hadoop, donc la licorne de PVS-Studio pourrait bien rendre visite à celle-ci aussi.  Mais c'est tout pour aujourd'hui.  En attendant, je vous invite à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">télécharger</a> l'analyseur et à vérifier vos propres projets. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr463753/">https://habr.com/ru/post/fr463753/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr463741/index.html">Firefox (déjà corrigé) et Chrome vous permettent d'utiliser l'en-tête Alt-Svc pour analyser les ports intranet</a></li>
<li><a href="../fr463745/index.html">La complication du C ++ est inévitable. Et pas seulement C ++</a></li>
<li><a href="../fr463747/index.html">Accéder aux propriétés à l'intérieur du champ Jsonb pour Npgsql</a></li>
<li><a href="../fr463749/index.html">Scrum vs Kanban: Restez calme et choisissez ce qui vous convient le mieux</a></li>
<li><a href="../fr463751/index.html">iOS 13: ce dont vous avez besoin et ce que vous n'avez absolument pas besoin de faire lors du développement d'un nouvel OS</a></li>
<li><a href="../fr463755/index.html">La différence entre «juin», «moyen» et «senior». Et que faire pour monter d'un niveau</a></li>
<li><a href="../fr463759/index.html">PVS-Studio visite Apache Hive</a></li>
<li><a href="../fr463761/index.html">Framework de microservice PHP - Swoft</a></li>
<li><a href="../fr463763/index.html">Simplifiez la migration d'OpenShift 3 vers OpenShift 4</a></li>
<li><a href="../fr463765/index.html">Slurm DevOps: pourquoi nous ne discuterons pas de la philosophie de DevOps et de ce qui se passera à la place</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>