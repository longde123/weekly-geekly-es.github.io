<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥄 👨🏼‍🎨 👨🏼‍🍳 Bagaimana STP Bekerja 🛏️ 🛤️ 🍐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Alasan untuk membuat STP 
 Alasan untuk membuat protokol STP adalah munculnya loop pada sakelar. Apa itu loop? Definisi loop adalah sebagai berikut: 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana STP Bekerja</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419491/"><h4>  Alasan untuk membuat STP </h4><br>  Alasan untuk membuat protokol STP adalah munculnya loop pada sakelar.  Apa itu loop?  Definisi loop adalah sebagai berikut: <br><br>  <b>Bridging loop (Switching loop)</b> - keadaan dalam jaringan di mana ada transfer frame tanpa akhir antara sakelar yang terhubung ke segmen jaringan yang sama. <br><br>  Dari definisi itu menjadi jelas bahwa penampilan loop menciptakan masalah besar - itu menyebabkan kelebihan switch dan tidak dapat dioperasikannya segmen jaringan ini.  Bagaimana sebuah loop muncul?  Gambar di bawah ini menunjukkan topologi di mana loop akan terjadi tanpa adanya mekanisme perlindungan: <br><br><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/126/e5d/0de/126e5d0dea4a92a1d6ec0c4dd2c7c897.jpg" alt="Gambar saya"></a> <a name="habracut"></a><br><br>  Munculnya loop dalam kondisi berikut: <br><br>  <b>1. Salah satu host mengirimkan bingkai Broadcast:</b> <br><br><ol><li>  Misalnya, VPC5 mengirim paket dengan alamat tujuan Siaran. </li><li>  Setelah menerima paket ini, Switch1 harus mengirimkannya melalui semua port kecuali port dari mana paket ini berasal.  Paket akan melewati porta Gi0 / 0, Gi1 / 0. </li><li>  Switch2 Switch2, Switch3 setelah menerima paket ini juga harus mengirimnya paket.  Dengan demikian, Switch2, yang menerima paket dari Switch1, akan mengirimkannya ke Switch3, dan Switch3 akan mengirimkannya ke Switch2. </li><li>  Selanjutnya, Switch2 menerima paket dari Switch3, mengirimkannya ke Switch1, dan Switch3 menerima paket dari Switch2, mengirimkannya juga ke Switch1.  Jadi, kita sampai pada langkah 1) dan itu akan berlanjut tanpa batas.  Selain itu, semuanya diperparah oleh fakta bahwa pada langkah 4), Switch1 akan memiliki dua instance frame, karena ia akan menerima keduanya dari Switch2 dan Switch3. </li></ol><br>  Langkah 1) - 4) akan diulang tanpa henti dan pada komutator ini terjadi dalam sepersekian detik.  Juga, pembentukan loop mengarah pada fakta bahwa tabel alamat poppy pada sakelar akan terus berubah dan alamat poppy pengirim VPC5 akan secara konstan ditugaskan ke antarmuka Gi0 / 0, Gi1 / 0 atau Gi0 / 2 (jika pada saat itu VPC5 mengirimkan paket lainnya).  Siklus seperti itu akan menyebabkan operasi jaringan yang tidak benar dan semua sakelar.  Dan mengirimkan paket Broadcast untuk host adalah hal yang umum, sebagai contoh, protokol ARP. <br><br>  <b>2. Sebuah loop juga dapat terbentuk tanpa mengirim bingkai Broadcast.</b> <br><br><ol><li>  Misalnya, VPC5 mengirim bingkai dengan alamat mac tujuan unicast. </li><li>  Ada kemungkinan bahwa alamat mac tujuan tidak ada dalam tabel alamat switch mac.  Dalam hal ini, switch akan meneruskan paket melalui semua port kecuali port yang menerima frame.  Dan kami mendapatkan situasi yang sama dengan frame Broadcast. </li><li>  Di bawah ini kita akan melihat protokol STP pada switch Cisco.  Mereka menggunakan STP secara terpisah untuk setiap vlan, protokol PVST +.  Kami hanya memiliki satu vlan, jadi artinya ini tidak berubah. </li></ol><br><h4>  Dasar-Dasar STP </h4><br>  Prinsip operasi protokol ini didasarkan pada kenyataan bahwa semua saluran yang berlebihan antara sakelar diblokir secara logis dan lalu lintas tidak ditransmisikan melalui mereka.  Untuk membangun topologi tanpa saluran redundan, pohon dibangun (grafik matematika).  Untuk membangun pohon seperti itu, pertama-tama perlu untuk menentukan akar pohon dari mana grafik akan dibangun.  Oleh karena itu, langkah pertama dalam protokol STP adalah menentukan saklar root (Root Switch).  Untuk menentukan Root Switch, aktifkan pertukaran pesan BPDU.  Secara umum, protokol STP menggunakan dua jenis pesan: BPDU - berisi informasi tentang sakelar dan TCN - memberi tahu tentang perubahan topologi.  Mari kita pertimbangkan BPDU lebih detail.  Kami akan berbicara lebih banyak tentang TCN di bawah ini.  Ketika Anda mengaktifkan STP pada sakelar, sakelar itu mulai mengirim pesan BPDU.  Pesan-pesan ini mengandung informasi berikut: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8ab/b03/95d/8abb0395d6af59aa1d0d89717a430640.jpg" alt="Gambar saya"><br><br>  Bingkai BPDU memiliki bidang-bidang berikut: <br><br><ul><li>  Pengidentifikasi versi protokol STA (2 byte).  Switch harus mendukung versi protokol STA yang sama </li><li>  Versi protokol STP (1 byte) </li><li>  Jenis BPDU (1 byte).  Ada 2 jenis BPDU - pemberitahuan konfigurasi dan konfigurasi ulang </li><li>  Bendera (1 byte) </li><li>  Root Switch Identifier (8 byte) </li><li>  Biaya rute ke sakelar root (Biaya Jalur Root) </li><li>  ID Pengirim (ID Jembatan) (8 byte) </li><li>  Pengidentifikasi port dari mana paket ini dikirim (Port ID) (2 byte) </li><li>  Umur pesan (2 byte).  Diukur dalam satuan 0,5 s, digunakan untuk mendeteksi pesan usang </li><li>  Umur pesan maksimum (2 byte).  Jika frame BPDU memiliki masa pakai yang melebihi batas maksimum, maka frame diabaikan oleh sakelar </li><li>  Halo interval (2 byte), interval pengiriman paket BPDU </li><li>  Nyatakan perubahan keterlambatan (2 byte).  Minimum waktu aktif saklar </li></ul><br>  Bidang utama yang memerlukan perhatian khusus adalah sebagai berikut: <br><br><ul><li>  ID Pengirim (ID Jembatan) </li><li>  Root Bridge ID </li><li>  Pengidentifikasi port dari mana paket ini dikirim (Port ID) </li><li>  Biaya rute ke sakelar root (Biaya Jalur Root) </li></ul><br>  Untuk menentukan sakelar root, pengidentifikasi sakelar digunakan - Bridge ID.  Bridge ID adalah nomor 8-byte yang terdiri dari Bridge Priority (prioritas, 0 hingga 65535, standar 32768) dan alamat MAC perangkat.  Saklar akar memilih sakelar dengan prioritas terendah, jika prioritasnya sama, maka alamat MAC dibandingkan (berdasarkan karakter, yang lebih kecil menang). <br><br>  Ini adalah output informasi Bridge ID dari Switch1 dari gambar pertama.  Prioritas - 32769 (default 32768 + Vlan Id), alamat MAC - Alamat 5000.0001.0000: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f0e/0a9/a20/f0e0a9a20fcaf20601fb2e5ffb02564e.jpg" alt="Gambar saya"><br><br>  Bayangkan gambarnya, sakelar-sakelar dihidupkan dan sekarang mulai membangun topologi bebas loop.  Segera setelah saklar boot, mereka mulai mengirimkan BPDU, di mana mereka memberitahu semua orang bahwa mereka adalah akar dari pohon.  Di BPDU, sebagai Root Bridge ID, sakelar menunjukkan Bridge ID mereka sendiri.  Misalnya, Switch1 mengirim BPDU ke Switch3, dan Switch3 mengirim ke Switch1.  BPDU dari Switch1 ke Switch3: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dc9/6ef/4e3/dc96ef4e309f4c565aa7fc68eda75137.jpg" alt="Gambar saya"><br><br>  BPDU dari Switch3 ke Switch1: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/809/4de/aee/8094deaeef6449cdf3dc280000fc6e78.jpg" alt="Gambar saya"><br><br>  Seperti yang dapat Anda lihat dari Root Identifier, kedua komutator saling memberi tahu bahwa dialah yang merupakan sakelar Root. <br><br><h4>  Memilih sakelar root </h4><br>  Sampai topologi STP dibangun, lalu lintas normal tidak ditransmisikan karena status port khusus, yang akan dibahas di bawah ini.  Jadi, Switch3 mendapatkan BPDU dari Switch1 dan memeriksa pesan ini.  Switch3 terlihat di bidang Root Bridge ID dan melihat bahwa Root Bridge ID yang berbeda ditunjukkan di sana daripada di pesan yang dikirim oleh Switch3 sendiri.  Dia membandingkan Root Bridge ID dalam pesan ini dengan Root Bridge ID-nya dan melihat bahwa meskipun Prioritas adalah sama, alamat MAC dari sakelar ini (Switch1) lebih baik (kurang) daripada yang dimilikinya.  Oleh karena itu, Switch3 menerima Root Bridge ID dari Switch1 dan berhenti mengirim BPDU-nya, tetapi hanya mendengarkan BPDU dari Switch1.  Port yang menerima BPDU terbaik menjadi Port Root.  Switch1 juga menerima BPDU dari Switch3, membuat perbandingan, tetapi dalam kasus ini, perilaku Switch1 tidak berubah, karena BPDU yang diterima berisi Root Bridge ID yang lebih buruk daripada Switch1.  Jadi, antara Switch1 dan Switch3, sebuah switch root didefinisikan.  Dengan cara yang sama, saklar root dipilih antara Switch1 dan Switch2.  Port Gi0 / 0 pada Switch2 dan Switch3 menjadi Root Port - port yang mengarah ke switch root.  Melalui port ini, Switch2 dan Switch3 menerima BPDU dari Root Bridge.  Sekarang mari kita cari tahu apa yang akan terjadi pada saluran antara Switch2 dan Switch3. <br><br><h4>  Memblokir saluran yang berlebihan </h4><br>  Seperti yang kita lihat dari topologi, saluran antara Switch2 dan Switch3 harus diblokir untuk mencegah pembentukan loop.  Bagaimana STP menangani ini? <br><br>  Setelah Root Bridge dipilih, Switch2 dan Switch3 berhenti mengirim BPDU melalui Root Ports, tetapi BPDU diterima dari Root Bridge, mereka meneruskan melalui semua port aktif lainnya, hanya mengubah bidang berikut dalam data BPDU: <br><br><ul><li>  ID Pengirim (Bridge ID) - diganti dengan ID Anda. </li><li>  Pengidentifikasi port dari mana paket ini dikirim (ID Port) - berubah menjadi pengidentifikasi port dari mana BPDU akan dikirim. </li><li>  Biaya rute ke sakelar root (Biaya Jalur Root) - biaya rute dihitung relatif terhadap sakelar itu sendiri. </li></ul><br>  Dengan demikian, Switch2 menerima BPDU berikut dari Switch3: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0cb/1cb/bdf/0cb1cbbdfae70fb3ccf78a2ef590e847.jpg" alt="Gambar saya"><br>  Dan Switch3 dari Switch2 menerima BPDU seperti itu: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/91e/cc4/3a4/91ecc43a4ba7a061e38552d59fa26075.jpg" alt="Gambar saya"><br><br>  Setelah bertukar BPDU seperti itu, Switch2 dan Switch3 menyadari bahwa topologi itu redundan.  Mengapa switch mengerti bahwa topologi itu berlebihan?  Switch2 dan Switch3 melaporkan Root Bridge yang sama di BPDU mereka.  Ini berarti bahwa ada dua cara untuk Root Bridge, sehubungan dengan Switch3, melalui Switch1 dan Switch2, dan ini adalah redundansi yang kami perjuangkan.  Ada juga dua cara untuk Switch2 - melalui Switch1 dan Switch3.  Untuk menyingkirkan redundansi ini <br>  Anda harus memblokir saluran antara Switch3 dan Switch2.  Bagaimana kabarnya? <br><br>  Pilihan sakelar untuk memblokir port adalah sebagai berikut: <br><br><ul><li>  Biaya Jalur Akar Lebih Kecil. </li><li>  ID Bridge yang lebih kecil. </li><li>  ID port yang lebih kecil. </li></ul><br>  Dalam skema ini, Biaya Path Root memainkan peran yang lebih penting daripada Bridge ID.  Dulu saya berpikir bahwa pilihan ini mirip dengan pilihan sakelar Root dan terkejut bahwa, misalnya, dalam topologi ini, port sakelar dengan prioritas terburuk tidak akan diblokir: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a36/58f/9fc/a3658f9fca69d52cadf3b6d632e9d4c3.jpg" alt="Gambar saya"><br><br>  Di sini, ternyata, port Gi 0/1 pada sakelar Sw2 diblokir.  Dalam pemungutan suara ini, Biaya Path Root menjadi menentukan.  Mari kembali ke topologi kita.  Karena jalur ke Root Bridge adalah sama, Switch2 menang dalam pilihan ini, karena prioritasnya sama, Bridge IDs dibandingkan.  Switch2 memiliki 50: 00: 00: 00: 00, Switch3 memiliki 50: 00: 00: 03: 00: 00.  Switch2 memiliki alamat MAC yang lebih baik (kurang).  Setelah pilihan dibuat, Switch3 berhenti meneruskan paket apa pun melalui port ini - Gi1 / 0, termasuk BPDU, tetapi hanya mendengarkan BPDU dari Switch2.  Status port dalam STP ini disebut Blocking (BLK).  Port Gi1 / 0 pada Switch2 beroperasi secara normal dan meneruskan berbagai paket jika perlu, tetapi Switch3 segera membuangnya, hanya mendengarkan BPDU.  Jadi, dalam contoh ini, kami membangun topologi tanpa saluran yang berlebihan.  Satu-satunya saluran redundan antara Switch2 dan Switch3 diblokir dengan mengalihkan port Gi1 / 0 pada Switch3 ke status pemblokiran khusus - BLK.  Sekarang kita akan memeriksa secara lebih rinci mekanisme STP. <br><br><h4>  Status pelabuhan </h4><br>  Kami katakan di atas bahwa, misalnya, port Gi1 / 0 pada Switch3 masuk ke status pemblokiran khusus - Pemblokiran.  Status port berikut ada di STP: <br><br>  <b>Blocking</b> - blocking.  Dalam keadaan ini, tidak ada frame yang dikirimkan melalui port.  Digunakan untuk menghindari redundansi topologi. <br><br>  <b>Mendengarkan</b> - mendengarkan.  Seperti yang kami katakan di atas, sebelum sakelar root masih dipilih, port berada dalam keadaan khusus di mana hanya BPDU ditransmisikan, frame data tidak ditransmisikan dan tidak diterima dalam kasus ini.  Keadaan Mendengarkan tidak pergi ke yang berikutnya bahkan jika Jembatan Root didefinisikan.  Status port ini berlangsung selama waktu tunda Teruskan, yang secara default adalah 15. Mengapa saya selalu harus menunggu 15 detik?  Ini karena kehati-hatian protokol STP sehingga Root Bridge yang salah tidak dipilih secara tidak sengaja.  Setelah periode ini, port masuk ke status berikutnya - Belajar. <br><br>  <b>Belajar</b> - pelatihan.  Dalam keadaan ini, port mendengarkan dan mengirim BPDU, tetapi tidak mengirim informasi dengan data.  Perbedaan antara keadaan ini dan Mendengarkan adalah bahwa frame dengan data yang datang ke pelabuhan dipelajari dan informasi alamat MAC dimasukkan dalam tabel alamat MAC saklar.  Transisi ke status berikutnya juga memerlukan timer tunda maju. <br><br>  <b>Penerusan</b> - Penerusan.  Ini adalah keadaan normal port tempat BPDU dan frame dengan data normal dikirim.  Jadi, jika kita pergi melalui skema ketika switch baru saja boot, kita mendapatkan skema berikut: <br><br><ol><li>  Switch menempatkan semua port yang terhubung ke status Listening dan mulai mengirim BPDU di mana ia menyatakan dirinya sebagai switch root.  Selama periode ini, switch tetap root jika tidak menerima BPDU terbaik, atau memilih switch root.  Itu berlangsung 15 detik. </li><li>  Setelah itu memasuki status Belajar dan mempelajari alamat MAC.  15 detik </li><li>  Menentukan port mana yang akan diatur ke Penerusan dan yang akan Diblokir. </li></ol><br><h4>  Peran port </h4><br>  Selain status port, STP juga perlu menentukan port peran mereka.  Hal ini dilakukan agar port yang diharapkan BPDU dari switch root, dan melalui port mana untuk mengirimkan salinan BPDU yang diterima dari switch root.  Peran port adalah sebagai berikut: <br><br>  <b>Root Port</b> - port root switch.  Saat memilih sakelar root, porta root juga ditentukan.  Ini adalah port di mana switch root terhubung.  Misalnya, dalam topologi kami, port Gi0 / 0 pada Switch2 dan Switch3 adalah port root.  Melalui port ini, Switch2 dan Switch3 tidak mengirim BPDU, tetapi hanya mendengarkan mereka dari Root Bridge.  Timbul pertanyaan - bagaimana port root dipilih?  Mengapa port Gi1 / 0 tidak dipilih?  Lagi pula, dapatkah Anda juga berkomunikasi dengan sakelar yang melewatinya?  Untuk menentukan port root di STP, metrik digunakan yang menunjukkan Biaya Path Root (biaya rute ke switch root) di bidang BPDU.  Biaya ini ditentukan oleh kecepatan saluran. <br><br>  Switch1 di BPDU di bidang Biaya Path Root menetapkan 0, karena itu sendiri Root Bridge.  Tetapi ketika Switch2, ketika mengirimkan BPDU ke Switch3, itu mengubah bidang ini.  Ini menetapkan Biaya Path Root sama dengan biaya saluran antara dirinya dan Switch1.  Pada gambar BPDU dari Switch2 dan Switch3, Anda dapat melihat bahwa di bidang ini Biaya Path Root adalah 4, karena saluran antara Switch1 dan Switch2 adalah 1 Gbps.  Jika jumlah switch lebih besar, maka setiap switch berikutnya akan menambah Biaya Path Root.  Tabel Biaya Path Root. <br><br>  <b>Designated Port</b> - <b>Port yang</b> ditugaskan pada segmen.  Untuk setiap segmen jaringan, harus ada port yang bertanggung jawab untuk menghubungkan segmen ini ke jaringan.  Secara relatif, segmen jaringan dapat berarti kabel yang menghubungkan segmen ini.  Misalnya, port Gi0 / 2 pada Switch1, Switch3 menghubungkan setiap segmen jaringan yang hanya dituntun oleh kabel ini.  Juga, misalnya, port di Root Bridge tidak dapat diblokir dan semua port yang ditunjuk pada segmen.  Setelah penjelasan ini, Anda dapat memberikan definisi yang lebih ketat untuk port yang ditugaskan: <br>  Designated Port - Port jembatan non-root antara segmen jaringan yang menerima lalu lintas dari segmen yang sesuai.  Setiap segmen jaringan hanya dapat memiliki satu port yang ditugaskan.  Switch root memiliki semua port yang ditetapkan. <br><br>  Penting juga untuk dicatat bahwa port Gi1 / 0 pada Switch2 juga ditetapkan, meskipun faktanya saluran komunikasi ini diblokir pada Switch3.  Secara relatif, Switch2 tidak memiliki informasi bahwa port diblokir di ujung yang lain. <br><br>  <b>Nondesignated Port</b> - <b>Port</b> segmen yang tidak ditetapkan.  Non-ditunjuk Port - Port yang bukan root atau port yang ditunjuk.  Transmisi bingkai data melalui port semacam itu dilarang.  Dalam contoh kita, port Gi1 / 0 tidak ditugaskan. <br><br>  <b>Disabled Port</b> - port yang dalam kondisi tidak aktif. <br><br><h4>  Pengatur Waktu dan STP </h4><br>  Setelah STP menyelesaikan konstruksi topologi bebas loop, pertanyaannya tetap - Bagaimana mendeteksi perubahan jaringan dan bagaimana meresponsnya?  Pesan BPDU yang digunakan oleh STP dikirim oleh Root Bridge setiap 2 detik, secara default.  Timer ini disebut Hello Timer.  Sisa switch, setelah menerima pesan ini melalui port root mereka, meneruskannya lebih jauh melalui semua port yang ditugaskan.  Telah dikatakan secara lebih rinci perubahan apa yang terjadi pada BPDU ketika meneruskan sakelar-sakelarnya.  Jika selama waktu yang ditentukan oleh pengatur waktu Max Age (secara default - 20 detik), sakelar tidak menerima BPDU apa pun dari sakelar akar, maka peristiwa ini dianggap sebagai kehilangan komunikasi dengan Root Bridge.  Untuk menggambarkan konvergensi protokol dengan lebih tepat, perlu untuk mengubah topologi kami dan menempatkan hub di antara switch.  Kami menambahkan hub sehingga ketika salah satu sakelar gagal atau tautan gagal, sakelar lainnya tidak menentukan ini oleh penurunan tautan, tetapi menggunakan penghitung waktu: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ea3/0e7/105/ea30e7105f926c505b0a46f1e2adf758.jpg" alt="gambar"><br><br>  Sebelum Anda mulai, penting juga untuk memberi tahu Anda lebih banyak tentang jenis pesan STP lainnya - TCN.  TCN dikirim oleh sakelar jika terjadi perubahan topologi - segera setelah topologi berubah pada sakelar apa pun, misalnya, keadaan antarmuka telah berubah.  TCN dikirim oleh switch hanya melalui Root Port.  Segera setelah sakelar root menerima TCN, ia segera mengubah parameter untuk menyimpan alamat MAC dalam tabel dari 300 detik menjadi 15 (yang akan dibahas di bawah), dan di BPDU berikutnya, Root Switch meletakkan bendera - TCA (Topologi Ubah Acknledgement), yang dikirim ke sakelar yang mengirim TCN untuk memberi tahu bahwa TCN diterima.  Segera setelah TCN mencapai Root Bridge, ia mengirimkan BPDU khusus yang berisi flag TCN pada semua antarmuka lain ke sakelar lain.  Gambar menunjukkan struktur TCN: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/871/0e9/123/8710e9123047de570b5fbf6eb8127ca9.jpg" alt="gambar"><br><br>  TCN dimasukkan dalam STP sehingga sakelar non-root dapat memberi tahu perubahan di jaringan.  Mereka tidak dapat melakukan ini dengan BPDU biasa, karena sakelar non-root tidak mengirim BPDU.  Seperti yang Anda lihat, struktur TCN tidak mengandung informasi apa pun tentang apa sebenarnya dan di mana telah berubah, tetapi hanya melaporkan bahwa di suatu tempat ada sesuatu yang berubah.  Sekarang mari kita beralih ke pertanyaan tentang konvergensi STP. <br><br>  Mari kita lihat apa yang terjadi jika kita menonaktifkan antarmuka Gi0 / 1 pada Switch1 dan melihat mekanisme apa yang dibangun dengan pohon STP.  Switch2 akan berhenti menerima BPDU dari Switch1 dan tidak akan menerima BPDU dari Switch3, karena port ini diblokir pada Switch3.  Switch2 akan membutuhkan waktu 20 detik (Max Age Timer) untuk memahami kehilangan koneksi dengan Root Bridge.  Hingga saat ini, Gi0 / 0 pada Switch2 akan berada dalam status Penerusan dengan peran Root Port.  Segera setelah Max Age Timer kedaluwarsa dan Switch2 memahami hilangnya komunikasi, ia akan membangun kembali pohon STP dan, seperti tipikal untuk STP, akan mulai menganggap dirinya Root Bridge.  Dia akan mengirim BPDU baru, di mana dia akan menunjukkan dirinya sebagai Root Bridge melalui semua port aktif, termasuk Switch3.  Tetapi timer Max Age yang kedaluwarsa pada Switch2 juga berakhir pada Switch3 untuk antarmuka Gi1 / 0.  Port ini belum menerima BPDU selama 20 detik dan port ini akan masuk ke status MENDENGARKAN dan mengirim BPDU yang menunjukkan Root Bridge - Switch1.  Segera setelah Switch2 menerima BPDU ini, itu akan berhenti menganggap dirinya sebagai Root Bridge dan akan memilih Gi1 / 0 sebagai Port Root.  Pada titik ini, Switch2 juga akan mengirim TCN melalui Gi1 / 0, karena ini adalah Port Root baru.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini akan mengarah pada fakta bahwa waktu penyimpanan alamat MAC pada sakelar akan berkurang dari 300 detik menjadi 15. Namun ini tidak sepenuhnya memulihkan jaringan, Anda harus menunggu sampai port Gi1 / 0 pada Switch3 melewati status Mendengarkan lalu Belajar. Ini akan memakan waktu yang sama dengan dua periode pengatur waktu tunda maju - 15 + 15 = 30 detik. Apa yang kita dapatkan adalah bahwa ketika koneksi terputus, Switch2 menunggu waktu Max Age = 20 detik untuk berakhir, memilih kembali Root Bridge melalui antarmuka lain dan menunggu 30 detik hingga port yang sebelumnya diblokir masuk ke mode Forwarding. Secara total, kami mendapatkan bahwa koneksi antara VPC5 dan VPC6 akan terputus selama 50 detik. Seperti disebutkan oleh beberapa kalimat di atas, ketika mengubah Root Port dari Gi0 / 0 ke Gi1 / 0 di Switch2, TCN dikirim. Jika ini tidak terjadi, maka semua alamat MAC yang dipelajari melalui port Gi 0/0,akan tetap melekat pada Gi0 / 0. Sebagai contoh, alamat MAC dari VPC5 dan VPC7 terlepas dari kenyataan bahwa STP menyelesaikan konvergensi dalam 50 detik, koneksi antara VPC6 dan VPC5, VPC7 tidak akan dipulihkan, karena semua paket yang ditujukan untuk VPC5, VPC7 dikirim melalui Gi0 / 0. Anda harus menunggu bukan 50 detik, tetapi 300 detik hingga tabel alamat MAC dibangun kembali. Menggunakan TCN, waktu penyimpanan berubah dari 300 detik menjadi 15 dan sementara antarmuka Gi1 / 0 pada Switch3 lulus status Mendengarkan, maka data alamat Pembelajaran dan MAC akan diperbarui.waktu penyimpanan berubah dari 300 detik menjadi 15 dan sementara antarmuka Gi1 / 0 pada Switch3 melewati status Mendengarkan, maka data alamat Pembelajaran dan MAC akan diperbarui.waktu penyimpanan berubah dari 300 detik menjadi 15 dan sementara antarmuka Gi1 / 0 pada Switch3 melewati status Mendengarkan, maka data alamat Pembelajaran dan MAC akan diperbarui.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yang juga menarik adalah pertanyaannya, apa yang terjadi jika kita mengaktifkan kembali antarmuka Gi0 / 1 pada Switch1? </font><font style="vertical-align: inherit;">Ketika antarmuka Gi0 / 1 diaktifkan, itu, sebagaimana layaknya, akan masuk ke status Mendengarkan dan mulai mengirim BPDU. </font><font style="vertical-align: inherit;">Segera setelah Switch2 menerima BPDU pada port Gi0 / 0, ia akan segera memilih kembali Root Port-nya, karena di sini Biaya akan menjadi yang terkecil dan mulai mengirimkan lalu lintas melalui antarmuka Gi0 / 0, tetapi kita perlu menunggu sampai antarmuka Gi0 / 1 melewati Listening, Learning state to Forwarding . </font><font style="vertical-align: inherit;">Dan penundaan tidak akan lagi 50 detik, tetapi 30. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Protokol STP juga memikirkan berbagai teknologi untuk mengoptimalkan dan mengamankan pengoperasian protokol STP. </font><font style="vertical-align: inherit;">Saya tidak akan mempertimbangkannya secara lebih rinci dalam artikel ini, materi tentang mereka dapat ditemukan berlimpah di berbagai situs.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id419491/">https://habr.com/ru/post/id419491/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id419475/index.html">Cara menemukan inspirasi dan tidak kehilangan keunikan</a></li>
<li><a href="../id419477/index.html">Lebih mudah daripada kedengarannya. Bab 11</a></li>
<li><a href="../id419479/index.html">Keamanan "Ekaterinburg Arena": bagaimana kami mempersiapkan stadion untuk Piala Dunia 2018</a></li>
<li><a href="../id419483/index.html">PowerShell dan Shift + Ins, atau cara mendapatkan kecepatan Hermes saat bekerja dengan GPP</a></li>
<li><a href="../id419485/index.html">Ada aplikasi untuk itu: pengumuman Mobius 2018 Moscow</a></li>
<li><a href="../id419493/index.html">Mengapa Anda perlu Splunk? Analisis Peristiwa Keamanan</a></li>
<li><a href="../id419495/index.html">Yang "menemukan" konduksi tulang, mengapa digunakan dan seberapa aman untuk pendengaran</a></li>
<li><a href="../id419503/index.html">Buku “Algoritma dan struktur data. Pengambilan Informasi Java »</a></li>
<li><a href="../id419505/index.html">Anda sekarang dapat menerima paket tanpa pemberitahuan dan paspor melalui surat di seluruh negara.</a></li>
<li><a href="../id419507/index.html">Tinjauan umum tentang printer 3D Rusia PICASO 3D Designer X dari 3Dtool</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>