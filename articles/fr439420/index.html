<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👃🏿 ☁️ 👩🏾 Création d'un package de transport sans installer MODX 😴 🗄️ 🗞️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'écriture de vos packages pour MODX n'est pas facile pour un débutant, et un développeur expérimenté passe parfois un bon moment. Mais le débutant a ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Création d'un package de transport sans installer MODX</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439420/"><img src="https://habrastorage.org/webt/jv/hq/2n/jvhq2nbsj0ti2v8v_ucoyk_bwam.jpeg"><br><br>  L'écriture de vos packages pour MODX n'est pas facile pour un débutant, et un développeur expérimenté passe parfois un bon moment.  Mais le débutant a peur et l'expérimenté comprend :). <br><br>  Cet article explique comment vous pouvez écrire et créer un package de composants pour MODX sans installer et configurer MODX lui-même.  Le niveau est supérieur à la moyenne, vous devrez donc peut-être vous creuser la tête dans certains cas, mais cela en vaut la peine. <br><br>  Je demande des détails sous chat. <br><a name="habracut"></a><br>  Une fois, lorsque MODX Revolution est apparu, c'était dans la première version bêta, les développeurs ne savaient pas encore comment travailler avec lui et comment écrire des plugins pour cela.  Eh bien, sauf pour l'équipe qui s'est penchée sur le CMS.  Et l'équipe, je dois dire, a partiellement réussi et a fourni au système la possibilité de collecter facilement les packages qui peuvent ensuite être installés via le référentiel, ce qui semble logique.  Mais depuis lors, de nombreuses années se sont écoulées et les exigences relatives aux emballages et à leur assemblage ont quelque peu changé. <br><br><h2>  Le copier-coller est mauvais, mais pas toujours </h2><br>  Au cours des derniers mois, j'ai été hanté par la pensée de savoir pourquoi, pour construire un package pour MODX, vous devez l'installer, créer une base de données, créer un administrateur, etc.  Tant d'actions supplémentaires.  Non, il n'y a rien de mal à cela si vous le configurez une fois puis l'utilisez.  Beaucoup le font.  Mais qu'en est-il lorsque vous voulez confier l'assemblage au scénario et aller prendre un café vous-même? <br><br>  Il se trouve que les créateurs de MODX étaient habitués à travailler avec MODX lui-même et ont ajouté des classes au package directement dans le noyau.  Ils ont également écrit les premiers composants, les premiers scripts de construction, qui ont ensuite été utilisés comme exemples par d'autres développeurs qui ont simplement copié la solution, ne plongeant pas toujours dans l'essence de ce qui se passait.  Et je l'ai fait. <br><br>  Mais la tâche est d'automatiser l'assemblage du package, de préférence sur le serveur, toujours avec un ensemble minimum de logiciels requis, avec un minimum de ressources et donc avec une plus grande vitesse.  La tâche a été fixée et après avoir étudié la source, Jason freinant dans le chat a trouvé une solution. <br><br><h2>  Et lequel? </h2><br>  La première chose que j'ai découverte est que le code responsable de la construction du paquet se trouve directement dans la bibliothèque xPDO, et dans MODX il n'y a que des classes wrapper qui fournissent une API plus pratique et sont un peu plus faciles à travailler, mais seulement si MODX est installé.  Par conséquent, seul xPDO peut probablement être utilisé d'une manière ou d'une autre, mais dans le code, le constructeur de l'objet xPDO vous oblige à spécifier des données pour la connexion à la base de données. <br><br><pre><code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( $dsn, $username = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">''</span></span></span></span><span class="hljs-function"><span class="hljs-params">, $password = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">''</span></span></span></span><span class="hljs-function"><span class="hljs-params">, $options = [], $driverOptions= null )</span></span></span></span>;</code> </pre> <br>  Après avoir interrogé Jason, il est devenu clair que bien que des paramètres doivent être définis, la véritable connexion physique à la base de données se produit exactement au moment où elle est nécessaire.  Charge paresseuse dans toute sa splendeur.  Le deuxième problème a été résolu. <br><br>  Le troisième problème était celui de la connexion de xPDO au projet.  Composer m'est immédiatement venu à l'esprit, mais la version 2.x sur laquelle le MODX actuel s'exécute ne prend pas en charge Composer, et la branche 3.x utilise des espaces de noms et les noms de classe sont écrits différemment que dans 2.x, ce qui entraîne des conflits et des erreurs.  En général, incompatible.  Ensuite, j'ai dû utiliser des outils git et connecter xPDO en tant que sous-module. <br><blockquote><h4>  Comment utiliser les sous-modules </h4><br><br>  Tout d'abord, lisez leur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> . <br><br>  Ensuite, s'il s'agit d'un nouveau projet, vous devez ajouter un sous-module: <br><br><pre> <code class="plaintext hljs">$ git submodule add https://github.com/username/reponame</code> </pre> <br>  Cette commande clonera et installera un sous-module dans votre projet.  Ensuite, vous devrez ajouter le dossier du sous-module à votre référentiel avec la commande git add.  Il n'ajoutera pas le dossier entier avec le sous-module, mais ajoutera à git uniquement un lien vers le dernier commit du sous-module. <br><br>  Pour qu'un autre développeur puisse cloner le projet avec toutes les dépendances, vous devez créer une configuration .gitmodules pour les sous-modules.  Dans le projet Slackify, c'est comme ça: <br><br><pre> <code class="plaintext hljs">[submodule "_build/xpdo"] path = _build/xpdo url = https://github.com/modxcms/xpdo.git branch = 2.x</code> </pre><br>  Après cela, lors du clonage, spécifiez simplement l'indicateur récursif et git téléchargera tous les référentiels dépendants. </blockquote>  En conséquence, nous avons xPDO, xPDO peut être utilisé sans se connecter à la base de données, si ce n'est pas nécessaire, xPDO peut être connecté au code du composant en tant que dépendance externe (sous-module git).  Maintenant l'implémentation du script de construction. <br><br><h2>  Comprenons </h2><br>  Je décrirai le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">script de construction de l'</a> add-on <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Slackify</a> récemment publié par moi.  Ce composant est gratuit et accessible au public sur GitHub, ce qui facilitera l'auto-apprentissage. <br><br><h3>  Connecter xPDO </h3><br>  Nous omettons la tâche des constantes avec le nom du package et les autres appels nécessaires et connectons xPDO. <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">require_once</span></span> <span class="hljs-string"><span class="hljs-string">'xpdo/xpdo/xpdo.class.php'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">require_once</span></span> <span class="hljs-string"><span class="hljs-string">'xpdo/xpdo/transport/xpdotransport.class.php'</span></span>; $xpdo = xPDO::getInstance(<span class="hljs-string"><span class="hljs-string">'db'</span></span>, [ xPDO::OPT_CACHE_PATH =&gt; <span class="hljs-keyword"><span class="hljs-keyword">__DIR__</span></span> . <span class="hljs-string"><span class="hljs-string">'/../cache/'</span></span>, xPDO::OPT_HYDRATE_FIELDS =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, xPDO::OPT_HYDRATE_RELATED_OBJECTS =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, xPDO::OPT_HYDRATE_ADHOC_FIELDS =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, xPDO::OPT_CONNECTIONS =&gt; [ [ <span class="hljs-string"><span class="hljs-string">'dsn'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'mysql:host=localhost;dbname=xpdotest;charset=utf8'</span></span>, <span class="hljs-string"><span class="hljs-string">'username'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'test'</span></span>, <span class="hljs-string"><span class="hljs-string">'password'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'test'</span></span>, <span class="hljs-string"><span class="hljs-string">'options'</span></span> =&gt; [xPDO::OPT_CONN_MUTABLE =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>], <span class="hljs-string"><span class="hljs-string">'driverOptions'</span></span> =&gt; [], ] ] ]);</code> </pre> <br>  J'ai ajouté le sous-module xPDO dans le dossier _build, dont nous n'avons besoin qu'au stade de développement et d'assemblage du package et qui n'entrera pas dans l'archive principale du composant.  Nous n'avons pas besoin de la deuxième copie de xPDO sur le site avec MODX en direct. <br><br>  Dans les paramètres de connexion xPDO, j'ai défini le nom de la base de données dans <code>dsn</code> , mais il ne joue aucun rôle.  Il est important que le dossier de cache dans xPDO soit accessible en écriture.  Voilà, xPDO est initialisé. <br><br><h3>  Faire un hack délicat avec les classes </h3><br>  Lorsque vous utilisez le MODX installé lors de la création du package, tout est simple, nous prenons et créons un objet de la classe dont nous avons besoin.  MODX trouve en fait la classe requise, trouve l'implémentation nécessaire pour cette classe (la classe avec le suffixe _mysql), qui dépend de la base de données et crée ensuite l'objet souhaité (en raison de cette fonctionnalité, vous pouvez obtenir des erreurs lors de la construction du package que la classe * _mysql introuvable, ce n'est pas effrayant).  Cependant, nous n'avons ni base ni implémentation.  Nous devons en quelque sorte remplacer la classe souhaitée, ce que nous faisons. <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">modNamespace</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xPDOObject</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">modSystemSetting</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xPDOObject</span></span></span><span class="hljs-class"> </span></span>{}</code> </pre> <br>  Nous créons une classe factice (stub), qui est nécessaire pour créer l'objet souhaité.  Cela ne devrait pas être fait si xPDO ne vérifiait pas spécifiquement à quelle classe l'objet appartient.  Mais il vérifie. <br><br>  Mais il existe des cas particuliers où vous devez faire un peu plus que simplement définir une classe.  Ce sont des cas de dépendances entre classes.  Par exemple, nous devons ajouter un plugin à la catégorie.  Dans le code, juste <code>$category-&gt;addOne($plugin);</code>  mais dans notre cas, cela ne fonctionnera pas. <br><br>  Si vous avez déjà regardé <a href="">le schéma de la base de données MODX</a> , vous avez probablement vu des éléments comme l'agrégat et le composite.  Il est écrit à leur sujet dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> , mais s'ils sont simples, ils décrivent la relation entre les classes. <br><br>  Dans notre cas, il peut y avoir plusieurs plugins dans une catégorie, dont l'élément d'agrégation est responsable de la classe <code>modCategory</code> .  Par conséquent, puisque nous avons une classe sans implémentation concrète, nous devons indiquer cette connexion à la main.  Il est plus facile de le faire en <code>getFKDefinition</code> méthode <code>getFKDefinition</code> : <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">modCategory</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xPDOObject</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFKDefinition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($alias)</span></span></span><span class="hljs-function"> </span></span>{ $aggregates = [ <span class="hljs-string"><span class="hljs-string">'Plugins'</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">'class'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'modPlugin'</span></span>, <span class="hljs-string"><span class="hljs-string">'local'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'id'</span></span>, <span class="hljs-string"><span class="hljs-string">'foreign'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'category'</span></span>, <span class="hljs-string"><span class="hljs-string">'cardinality'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'many'</span></span>, <span class="hljs-string"><span class="hljs-string">'owner'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'local'</span></span>, ] ]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">isset</span></span>($aggregates[$alias]) ? $aggregates[$alias] : []; } }</code> </pre> <br>  Dans notre composant, seuls les plugins sont utilisés, nous ajoutons donc des liens uniquement pour eux.  Après cela, la méthode addMany de la classe modCategory peut facilement ajouter les plugins nécessaires à la catégorie, puis au package. <br><br><h3>  Créer un package </h3><br><pre> <code class="php hljs">$package = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> xPDOTransport($xpdo, $signature, $directory);</code> </pre> <br>  Comme vous pouvez le voir, tout est très, très simple.  Ici, nous devions passer le paramètre <code>$xpdo</code> , que nous avons initialisé au tout début.  Sinon pour l'instant, il n'y aurait pas de problème 2.  <code>$signature</code> - le nom du paquet, y compris la version, le <code>$directory</code> - l'endroit où le paquet sera soigneusement placé.  D'où viennent ces variables, voyez par vous-même dans la source. <br><br><h3>  Créez un espace de noms et ajoutez-le au package </h3><br>  Nous avons besoin d'un espace de noms pour lui lier des lexiques et des paramètres système.  Dans notre cas, juste pour cela, d'autres ne sont pas encore pris en compte. <br><br><pre> <code class="php hljs">$namespace = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> modNamespace($xpdo); $namespace-&gt;fromArray([ <span class="hljs-string"><span class="hljs-string">'id'</span></span> =&gt; PKG_NAME_LOWER, <span class="hljs-string"><span class="hljs-string">'name'</span></span> =&gt; PKG_NAME_LOWER, <span class="hljs-string"><span class="hljs-string">'path'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'{core_path}components/'</span></span> . PKG_NAME_LOWER . <span class="hljs-string"><span class="hljs-string">'/'</span></span>, ]); $package-&gt;put($namespace, [ xPDOTransport::UNIQUE_KEY =&gt; <span class="hljs-string"><span class="hljs-string">'name'</span></span>, xPDOTransport::PRESERVE_KEYS =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, xPDOTransport::UPDATE_OBJECT =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, xPDOTransport::RESOLVE_FILES =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, xPDOTransport::RESOLVE_PHP =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, xPDOTransport::NATIVE_KEY =&gt; PKG_NAME_LOWER, <span class="hljs-string"><span class="hljs-string">'namespace'</span></span> =&gt; PKG_NAME_LOWER, <span class="hljs-string"><span class="hljs-string">'package'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'modx'</span></span>, <span class="hljs-string"><span class="hljs-string">'resolve'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-string"><span class="hljs-string">'validate'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ]);</code> </pre> <br>  La première partie est claire pour quiconque a déjà écrit du code pour MODX.  Le second, avec l'ajout au package, est un peu plus compliqué.  La méthode <code>put</code> prend 2 paramètres: l'objet lui-même et un tableau de paramètres qui décrivent cet objet et son comportement possible au moment de l'installation du package.  Par exemple, <code>xPDOTransport::UNIQUE_KEY =&gt; 'name'</code> signifie que pour l'espace de noms, le champ de <code>name</code> avec le nom de l'espace de noms lui-même comme valeur sera utilisé comme clé unique dans la base de données.  Vous pouvez en savoir plus sur les paramètres <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans la documentation xPDO</a> , et mieux en étudiant le code source. <br><br>  De la même manière, vous pouvez ajouter d'autres objets, tels que les paramètres système. <br><br><pre> <code class="php hljs">$package-&gt;put($setting, [ xPDOTransport::UNIQUE_KEY =&gt; <span class="hljs-string"><span class="hljs-string">'key'</span></span>, xPDOTransport::PRESERVE_KEYS =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, xPDOTransport::UPDATE_OBJECT =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, <span class="hljs-string"><span class="hljs-string">'class'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'modSystemSetting'</span></span>, <span class="hljs-string"><span class="hljs-string">'resolve'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-string"><span class="hljs-string">'validate'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-string"><span class="hljs-string">'package'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'modx'</span></span>, ]);</code> </pre> <br><h3>  Créer une catégorie </h3><br>  Avec l'ajout d'une catégorie, j'ai eu le plus grand bâillon quand j'ai tout compris.  Les éléments placés dans une catégorie dans le modèle xPDO doivent tous deux appartenir à cette catégorie, c'est-à-dire  être imbriqué dedans, et alors seulement la catégorie elle-même doit être imbriquée dans le package.  Et en même temps, vous devez prendre en compte les relations entre les classes, que j'ai déjà décrites ci-dessus.  Il a fallu beaucoup de temps pour le comprendre, le réaliser et l'appliquer correctement. <br><br><pre> <code class="php hljs">$package-&gt;put($category, [ xPDOTransport::UNIQUE_KEY =&gt; <span class="hljs-string"><span class="hljs-string">'category'</span></span>, xPDOTransport::PRESERVE_KEYS =&gt; <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, xPDOTransport::UPDATE_OBJECT =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, xPDOTransport::ABORT_INSTALL_ON_VEHICLE_FAIL =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, xPDOTransport::RELATED_OBJECTS =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, xPDOTransport::RELATED_OBJECT_ATTRIBUTES =&gt; [ <span class="hljs-string"><span class="hljs-string">'Plugins'</span></span> =&gt; [ xPDOTransport::UNIQUE_KEY =&gt; <span class="hljs-string"><span class="hljs-string">'name'</span></span>, xPDOTransport::PRESERVE_KEYS =&gt; <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, xPDOTransport::UPDATE_OBJECT =&gt; <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, xPDOTransport::RELATED_OBJECTS =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> ], <span class="hljs-string"><span class="hljs-string">'PluginEvents'</span></span> =&gt; [ xPDOTransport::UNIQUE_KEY =&gt; [<span class="hljs-string"><span class="hljs-string">'pluginid'</span></span>, <span class="hljs-string"><span class="hljs-string">'event'</span></span>], xPDOTransport::PRESERVE_KEYS =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, xPDOTransport::UPDATE_OBJECT =&gt; <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, xPDOTransport::RELATED_OBJECTS =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> ] ], xPDOTransport::NATIVE_KEY =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, <span class="hljs-string"><span class="hljs-string">'package'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'modx'</span></span>, <span class="hljs-string"><span class="hljs-string">'validate'</span></span> =&gt; $validators, <span class="hljs-string"><span class="hljs-string">'resolve'</span></span> =&gt; $resolvers ]);</code> </pre> <br>  Cela a l'air monstrueux, mais pas si vu.  Un paramètre important est <code>xPDOTransport::RELATED_OBJECTS =&gt; true</code> , qui indique que la catégorie a des éléments imbriqués qui doivent également être empaquetés puis installés. <br><br>  Étant donné que la plupart des modules contiennent divers éléments (morceaux, extraits, plugins), la catégorie avec les éléments est l'élément le plus important du package de transport.  C'est donc ici que sont spécifiés les valideurs et résolveurs, qui sont effectués lors de l'installation du package. <br><blockquote>  Les validateurs sont effectués avant l'installation, les résolveurs - après. </blockquote><br>  J'ai presque oublié, avant d'emballer la catégorie, nous devons y ajouter nos éléments.  Comme ça: <br><br><pre> <code class="php hljs">$plugins = <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> $sources[<span class="hljs-string"><span class="hljs-string">'data'</span></span>] . <span class="hljs-string"><span class="hljs-string">'transport.plugins.php'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_array($plugins)) { $category-&gt;addMany($plugins, <span class="hljs-string"><span class="hljs-string">'Plugins'</span></span>); }</code> </pre> <br><h3>  Ajoutez d'autres données au package. </h3><br>  Dans le package, vous devez ajouter un autre fichier avec une licence, un fichier avec un journal des modifications et un fichier avec une description du composant.  Si nécessaire, vous pouvez ajouter un autre script spécial via l'attribut <code>setup-options</code> , qui affichera la fenêtre avant d'installer le package.  C'est alors qu'au lieu de "Installer" le bouton "Options d'installation".  Et à partir de la version de MODX 2.4, il est devenu possible de spécifier des dépendances entre les packages en utilisant l'attribut require, et vous pouvez également y spécifier la version de PHP et MODX. <br><br><pre> <code class="php hljs">$package-&gt;setAttribute(<span class="hljs-string"><span class="hljs-string">'changelog'</span></span>, file_get_contents($sources[<span class="hljs-string"><span class="hljs-string">'docs'</span></span>] . <span class="hljs-string"><span class="hljs-string">'changelog.txt'</span></span>)); $package-&gt;setAttribute(<span class="hljs-string"><span class="hljs-string">'license'</span></span>, file_get_contents($sources[<span class="hljs-string"><span class="hljs-string">'docs'</span></span>] . <span class="hljs-string"><span class="hljs-string">'license.txt'</span></span>)); $package-&gt;setAttribute(<span class="hljs-string"><span class="hljs-string">'readme'</span></span>, file_get_contents($sources[<span class="hljs-string"><span class="hljs-string">'docs'</span></span>] . <span class="hljs-string"><span class="hljs-string">'readme.txt'</span></span>)); $package-&gt;setAttribute(<span class="hljs-string"><span class="hljs-string">'requires'</span></span>, [<span class="hljs-string"><span class="hljs-string">'php'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'&gt;=5.4'</span></span>]); $package-&gt;setAttribute(<span class="hljs-string"><span class="hljs-string">'setup-options'</span></span>, [<span class="hljs-string"><span class="hljs-string">'source'</span></span> =&gt; $sources[<span class="hljs-string"><span class="hljs-string">'build'</span></span>] . <span class="hljs-string"><span class="hljs-string">'setup.options.php'</span></span>]);</code> </pre> <br><h3>  Nous emballons </h3><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($package-&gt;pack()) { $xpdo-&gt;log(xPDO::LOG_LEVEL_INFO, <span class="hljs-string"><span class="hljs-string">"Package built"</span></span>); }</code> </pre> <br>  Voilà, récupérez le package fini dans <code>_packages</code> , ou à partir de l'endroit où vous avez configuré l'assembly. <br><br><h2>  Quel est le résultat? </h2><br>  Le résultat a dépassé mes attentes, puisque cette approche, bien qu'elle impose certaines limites et ajoute à certains endroits quelques inconvénients, mais gagne en termes de possibilités d'application. <br><br>  Pour construire le package, il suffit d'exécuter 2 commandes: <br><br><pre> <code class="plaintext hljs">git clone --recursive git@github.com:Alroniks/modx-slackify.git cd modx-slackify/_build &amp;&amp; php build.transport.php</code> </pre> <br>  Le premier est le clonage du référentiel et de ses sous-modules.  Un paramètre important est <code>--recursive</code> , grâce à cela git téléchargera et installera, en plus du code du composant lui-même, toutes les dépendances décrites comme des sous-modules. <br><br>  La seconde consiste à construire le package directement.  Après cela, vous pouvez récupérer le <code>package-1.0.0-pl.transport.zip</code> dans le dossier <code>_packages</code> et le charger, par exemple, dans le référentiel. <br><br>  Les perspectives sont larges.  Par exemple, vous pouvez configurer un hook dans GitHub, qui, après s'être engagé dans une branche, exécutera un script sur votre serveur qui collectera le package et le placera dans tous les sites que vous avez.  Ou téléchargez la nouvelle version dans un référentiel, et à ce moment-là, vous ferez du café pour vous-même, comme je l'ai dit au début.  Ou vous pouvez créer et écrire des tests pour le module et exécuter le test et construire via Jenkins ou Travis.  Oui, un tas de scénarios que vous pouvez imaginer.  Avec cette approche, cela est désormais beaucoup plus facile. <br><br>  Posez des questions, essayez de répondre. <br><br>  PS Ne passez pas, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mettez une étoile Slackify sur GitHub</a> , s'il vous plaît. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr439420/">https://habr.com/ru/post/fr439420/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr439408/index.html">Pseudo Lens Flare</a></li>
<li><a href="../fr439410/index.html">Jeff Hawkins est enfin prêt à expliquer ses recherches sur le cerveau</a></li>
<li><a href="../fr439414/index.html">Client pour «Push Message Server»</a></li>
<li><a href="../fr439416/index.html">Article sur la révision du cadre A</a></li>
<li><a href="../fr439418/index.html">Pentaho Data Integration (PDI), Python et Deep Learning</a></li>
<li><a href="../fr439422/index.html">De quoi a besoin un programmeur pour développer des jeux et qui est un développeur de jeux à partir d'un programmeur?</a></li>
<li><a href="../fr439424/index.html">Comment j'ai lutté avec l'hébergement gratuit et Composer</a></li>
<li><a href="../fr439426/index.html">Situation: une nouvelle vague d'attaques avec interception de requêtes DNS - nous analysons les méthodes de base de protection</a></li>
<li><a href="../fr439428/index.html">Comment prévenir les cyberattaques ciblées? 10 meilleurs sandbox réseau</a></li>
<li><a href="../fr439430/index.html">Croyez-moi si vous le pouvez. Compteurs d'eau. partie 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>