<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ… ğŸ•´ï¸ ğŸ˜¹ Pointer di Python: apa gunanya? ğŸ’› ğŸ‘¨ğŸ¿â€ğŸš’ ğŸº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jika Anda pernah bekerja dengan bahasa tingkat rendah seperti C atau C ++, Anda mungkin pernah mendengar tentang pointer. Mereka memungkinkan Anda unt...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pointer di Python: apa gunanya?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/454324/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/_i/vd/cj/_ivdcjv0itamifffxs0i1i-mqh4.jpeg"></div><br>  Jika Anda pernah bekerja dengan bahasa tingkat rendah seperti C atau C ++, Anda mungkin pernah mendengar tentang pointer.  Mereka memungkinkan Anda untuk sangat meningkatkan efektivitas potongan kode yang berbeda.  Tetapi mereka juga dapat membingungkan pemula - dan bahkan pengembang yang berpengalaman - dan menyebabkan bug manajemen memori.  Apakah ada pointer di Python, bisakah saya meniru mereka? <br><br>  Pointer banyak digunakan dalam C dan C ++.  Bahkan, ini adalah variabel yang berisi alamat memori di mana variabel lain berada.  Untuk membaca petunjuk, baca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ulasan</a> ini. <br><br>  Berkat artikel ini, Anda akan lebih memahami model objek dengan Python dan mencari tahu mengapa pointer sebenarnya tidak ada dalam bahasa ini.  Jika Anda perlu mensimulasikan perilaku pointer, Anda akan belajar cara meniru mereka tanpa mimpi buruk yang menyertai manajemen memori. <br><a name="habracut"></a><br>  Dengan artikel ini, Anda: <br><br><ul><li>  Pelajari mengapa Python tidak memiliki petunjuk. </li><li>  Pelajari perbedaan antara variabel C dan nama dalam Python. </li><li>  Belajar meniru pointer dengan Python. </li><li> Gunakan <code>ctypes</code> bereksperimen dengan pointer nyata. </li></ul><br>  <b>Catatan</b> : Di sini, istilah "Python" diterapkan pada implementasi Python di C, yang dikenal sebagai CPython.  Semua diskusi perangkat bahasa berlaku untuk CPython 3.7, tetapi mungkin tidak sesuai dengan iterasi berikutnya. <br><br><h2>  Mengapa tidak ada pointer di Python? </h2><br>  Saya tidak tahu.  Bisakah pointer ada di Python secara asli?  Mungkin, tetapi tampaknya, petunjuknya bertentangan dengan konsep <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Zen Python</a> , karena mereka memprovokasi perubahan implisit alih-alih yang eksplisit.  Pointer seringkali cukup kompleks, terutama untuk pemula.  Selain itu, mereka mendorong Anda ke keputusan yang gagal atau untuk melakukan sesuatu yang sangat berbahaya, seperti membaca dari area memori, di mana Anda seharusnya tidak membacanya. <br><br>  Python mencoba untuk mengabstraksi detail implementasi dari pengguna, seperti alamat memori.  Seringkali dalam bahasa ini, penekanannya pada kegunaan, bukan kecepatan.  Oleh karena itu pointer dengan Python tidak masuk akal.  Tapi jangan khawatir, bahasa default memberi Anda beberapa manfaat menggunakan pointer. <br><br>  Untuk memahami pointer dalam Python, mari kita membahas fitur implementasi bahasa secara singkat.  Secara khusus, Anda perlu memahami: <br><br><ol><li>  Apa itu benda yang bisa berubah dan tidak berubah. </li><li>  Bagaimana variabel / nama diatur dalam Python. </li></ol><br>  Pegang alamat memori Anda, ayo pergi! <br><br><h2>  Objek dalam Python </h2><br>  Segala sesuatu di Python adalah objek.  Misalnya, buka REPL dan lihat bagaimana <code>isinstance()</code> : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>isinstance(<span class="hljs-number"><span class="hljs-number">1</span></span>, object) <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> &gt;&gt;&gt; isinstance(list(), object) <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> &gt;&gt;&gt; isinstance(<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, object) <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> &gt;&gt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> ... &gt;&gt;&gt; isinstance(foo, object) <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br>  Kode ini menunjukkan bahwa segala sesuatu di Python sebenarnya adalah objek.  Setiap objek mengandung setidaknya tiga jenis data: <br><br><ul><li>  Penghitung referensi. <br></li><li>  Jenis <br></li><li>  Nilai. <br></li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penghitung referensi</a> digunakan untuk mengelola memori.  Rincian tentang manajemen ini ditulis dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memory Management in Python</a> .  Jenis ini digunakan pada tingkat CPython untuk memberikan keamanan jenis selama runtime.  Dan nilai adalah nilai aktual yang terkait dengan objek. <br><br>  Tetapi tidak semua benda itu sama.  Ada satu perbedaan penting: objek bisa berubah dan tidak berubah.  Memahami perbedaan antara jenis-jenis objek ini akan membantu Anda lebih memahami lapisan pertama bawang yang disebut "pointer di Python." <br><br><h2>  Benda yang bisa berubah dan tidak berubah </h2><br>  Ada dua jenis objek di Python: <br><br><ol><li>  Objek yang tidak dapat diubah (tidak dapat diubah); <br></li><li>  Objek yang dapat dimodifikasi (dapat berubah). <br></li></ol><br>  Menyadari perbedaan ini adalah kunci pertama untuk melakukan perjalanan melalui dunia pointer di Python.  Berikut ini adalah karakterisasi ketidakmampuan dari beberapa tipe yang populer: <br><br><div class="scrollable-table"><table><tbody><tr><th width="400">  Jenis <br></th><th width="400">  Abadi? <br></th></tr><tr><td>  int <br></td><td>  Ya <br></td></tr><tr><td>  mengapung <br></td><td>  Ya <br></td></tr><tr><td>  bool <br></td><td>  Ya <br></td></tr><tr><td>  kompleks <br></td><td>  Ya <br></td></tr><tr><td>  tuple <br></td><td>  Ya <br></td></tr><tr><td>  frozenset <br></td><td>  Ya <br></td></tr><tr><td>  str <br></td><td>  Ya <br></td></tr><tr><td>  daftar <br></td><td>  Tidak <br></td></tr><tr><td>  diatur <br></td><td>  Tidak <br></td></tr><tr><td>  dikt <br></td><td>  Tidak <br></td></tr></tbody></table></div><br>  Seperti yang Anda lihat, banyak tipe primitif yang umum digunakan tidak berubah.  Anda dapat memverifikasi ini dengan menulis beberapa kode Python.  Anda akan membutuhkan dua alat dari perpustakaan standar: <br><br><ol><li>  <code>id()</code> mengembalikan alamat memori objek; <br></li><li>  <code>is</code> mengembalikan <code>True</code> jika dan hanya jika dua objek memiliki alamat memori yang sama. <br></li></ol><br>  Anda dapat menjalankan kode ini di lingkungan REPL: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = <span class="hljs-number"><span class="hljs-number">5</span></span> &gt;&gt;&gt; id(x) <span class="hljs-number"><span class="hljs-number">94529957049376</span></span></code> </pre> <br>  Di sini kita mengatur variabel <code>x</code> ke <code>5</code> .  Jika Anda mencoba mengubah nilai menggunakan tambahan, Anda akan mendapatkan objek baru: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x += <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;&gt;&gt; x <span class="hljs-number"><span class="hljs-number">6</span></span> &gt;&gt;&gt; id(x) <span class="hljs-number"><span class="hljs-number">94529957049408</span></span></code> </pre> <br>  Walaupun sepertinya kode ini hanya mengubah nilai <code>x</code> , pada kenyataannya Anda mendapatkan objek <b>baru</b> sebagai jawaban. <br><br>  Jenis <code>str</code> juga tidak berubah: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>s = <span class="hljs-string"><span class="hljs-string">"real_python"</span></span> &gt;&gt;&gt; id(s) <span class="hljs-number"><span class="hljs-number">140637819584048</span></span> &gt;&gt;&gt; s += <span class="hljs-string"><span class="hljs-string">"_rocks"</span></span> &gt;&gt;&gt; s <span class="hljs-string"><span class="hljs-string">'real_python_rocks'</span></span> &gt;&gt;&gt; id(s) <span class="hljs-number"><span class="hljs-number">140637819609424</span></span></code> </pre> <br>  Dan dalam hal ini, <code>s</code> setelah operasi <code>+=</code> mendapatkan alamat memori yang <b>berbeda</b> . <br><br>  <b>Bonus</b> : Operator <code>+=</code> menerjemahkan ke berbagai panggilan metode. <br><br>  Untuk beberapa objek, seperti daftar, <code>+=</code> convert ke <code>__iadd__()</code> (append lokal).  Ini akan berubah sendiri dan mengembalikan ID yang sama.  Namun, <code>str</code> dan <code>int</code> tidak memiliki metode ini, dan sebagai hasilnya, <code>__add__()</code> akan dipanggil alih-alih <code>__iadd__()</code> . <br><br>  Lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi model data</a> Python <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuk lebih jelasnya</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">.</a> <br><br>  Ketika kami mencoba untuk secara langsung mengubah nilai string dari <code>s</code> kami mendapatkan kesalahan: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>s[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-string"><span class="hljs-string">"R"</span></span></code> </pre> <br>  Jejak balik (panggilan terbaru ditampilkan terakhir): <br><br><pre> <code class="python hljs"> File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;mdule&gt; TypeError: <span class="hljs-string"><span class="hljs-string">'str'</span></span> object does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> support item assignment</code> </pre> <br>  Kode di atas lumpuh dan laporan Python bahwa <code>str</code> tidak mendukung perubahan ini, yang sesuai dengan definisi kekekalan dari tipe <code>str</code> . <br><br>  Bandingkan dengan objek yang bisa berubah, misalnya, dengan daftar: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>my_list = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] &gt;&gt;&gt; id(my_list) <span class="hljs-number"><span class="hljs-number">140637819575368</span></span> &gt;&gt;&gt; my_list.append(<span class="hljs-number"><span class="hljs-number">4</span></span>) &gt;&gt;&gt; my_list [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>] &gt;&gt;&gt; id(my_list) <span class="hljs-number"><span class="hljs-number">140637819575368</span></span></code> </pre> <br>  Kode ini menunjukkan perbedaan utama antara kedua jenis objek.  Awalnya, <code>my_list</code> memiliki ID.  Bahkan setelah menambahkan <code>4</code> ke daftar, <code>my_list</code> masih memiliki ID yang <b>sama</b> .  Alasannya adalah bahwa <code>list</code> jenis bisa berubah. <br><br>  Berikut ini adalah demonstrasi lain dari daftar yang dapat diubah menggunakan penugasan: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>my_list[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span> &gt;&gt;&gt; my_list [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>] &gt;&gt;&gt; id(my_list) <span class="hljs-number"><span class="hljs-number">140637819575368</span></span></code> </pre> <br>  Dalam kode ini, kami mengubah <code>my_list</code> dan menetapkannya ke <code>0</code> sebagai elemen pertama.  Namun, daftar tersebut mempertahankan ID yang sama setelah operasi ini.  Langkah selanjutnya di jalur kami untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">belajar Python</a> adalah menjelajahi ekosistemnya. <br><br><h2>  Kami berurusan dengan variabel </h2><br>  Variabel dalam Python secara fundamental berbeda dari variabel dalam C dan C ++.  Pada dasarnya, mereka tidak ada di Python.  <b>Alih-alih variabel, ada nama</b> . <br><br>  Mungkin kedengarannya luar biasa, dan sebagian besar memang demikian.  Paling sering, Anda bisa menggunakan nama dalam Python sebagai variabel, tetapi Anda harus memahami perbedaannya.  Ini sangat penting ketika Anda mempelajari topik yang sulit seperti petunjuk. <br><br>  Untuk membuatnya lebih mudah bagi Anda untuk memahami, mari kita lihat bagaimana variabel bekerja di C, apa yang mereka wakili, dan kemudian membandingkannya dengan karya nama dalam Python. <br><br><h3>  Variabel dalam C </h3><br>  Ambil kode yang mendefinisikan variabel <code>x</code> : <br><br><pre> <code class="python hljs">int x = <span class="hljs-number"><span class="hljs-number">2337</span></span>;</code> </pre> <br>  Eksekusi garis pendek ini melewati beberapa tahap yang berbeda: <br><br><ol><li>  Mengalokasikan cukup memori untuk suatu nomor. <br></li><li>  Penugasan <code>2337</code> ke lokasi memori ini. <br></li><li>  Pemetaan yang <code>x</code> menunjukkan nilai ini. <br></li></ol><br>  Memori yang disederhanakan mungkin terlihat seperti ini: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f13/e62/d71/f13e62d71774b73aecff45931b6db57f.png"><br><br>  Di sini, variabel <code>x</code> memiliki alamat palsu <code>0x7f1</code> dan nilai <code>2337</code> .  Jika nanti Anda ingin mengubah nilai <code>x</code> , Anda dapat melakukan ini: <br><br><pre> <code class="python hljs">x = <span class="hljs-number"><span class="hljs-number">2338</span></span>;</code> </pre> <br>  Kode ini menetapkan variabel <code>x</code> nilai baru <code>2338</code> , sehingga menimpa nilai <b>sebelumnya</b> .  Ini berarti bahwa variabel <code>x</code> <b>berubah</b> .  Skema memori yang diperbarui untuk nilai baru: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/347/491/19b/34749119bcba5c4009861aa4e7c40c45.png"><br><br>  Harap dicatat bahwa lokasi <code>x</code> tidak berubah, hanya nilainya sendiri.  Ini penting.  Ini memberitahu kita bahwa <code>x</code> adalah <b>tempat di memori</b> , dan bukan hanya nama. <br><br>  Anda juga dapat mempertimbangkan masalah ini sebagai bagian dari konsep kepemilikan.  Di satu sisi, <code>x</code> memiliki tempat dalam memori.  Pertama, <code>x</code> adalah kotak kosong yang hanya bisa berisi satu bilangan bulat, di mana nilai integer dapat disimpan. <br><br>  Saat Anda menetapkan <code>x</code> beberapa nilai, Anda memasukkan nilai ke dalam kotak milik <code>x</code> .  Jika Anda ingin memperkenalkan variabel baru <code>y</code> , Anda dapat menambahkan baris ini: <br><br><pre> <code class="python hljs">int y = x;</code> </pre> <br>  Kode ini menciptakan kotak baru bernama <code>y</code> dan menyalin nilai dari <code>x</code> ke dalamnya.  Sekarang sirkuit memori terlihat seperti ini: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/caa/74d/ed3/caa74ded301b1f527e1b94516f1b1196.png"><br><br>  Perhatikan lokasi baru <code>y</code> - <code>0x7f5</code> .  Meskipun nilai <code>x</code> disalin ke <code>x</code> , variabel <code>y</code> memiliki alamat baru di memori.  Oleh karena itu, Anda dapat menimpa nilai <code>y</code> tanpa mempengaruhi <code>x</code> : <br><br><pre> <code class="python hljs">y = <span class="hljs-number"><span class="hljs-number">2339</span></span>;</code> </pre> <br>  Sekarang sirkuit memori terlihat seperti ini: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fcf/f8d/ed4/fcff8ded49647ad0053a45f0773cb4bb.png"><br><br>  Saya ulangi: Anda mengubah nilai <code>y</code> , tetapi bukan lokasi.  Selain itu, Anda tidak memengaruhi variabel asli <code>x</code> . <br><br>  Dengan nama dalam Python, situasinya benar-benar berbeda. <br><br><h3>  Nama dengan Python </h3><br>  Tidak ada variabel dalam Python, hanya nama.  Anda dapat menggunakan istilah "variabel" sesuai kebijaksanaan Anda, namun penting untuk mengetahui perbedaan antara variabel dan nama. <br><br>  Mari kita ambil kode yang setara dari contoh C di atas dan tulis dengan Python: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = <span class="hljs-number"><span class="hljs-number">2337</span></span></code> </pre> <br>  Seperti dalam C, kode melewati beberapa langkah terpisah selama eksekusi ini: <br><br><ol><li>  PyObject dibuat. <br></li><li>  Nomor untuk PyObject diberikan kode ketik. <br></li><li>  <code>2337</code> diberi nilai untuk PyObject. <br></li><li>  Nama <code>x</code> dibuat. </li><li>  <code>x</code> menunjuk ke PyObject baru. </li><li>  Jumlah referensi PyObject bertambah 1. <br></li></ol><br>  <b>Catatan</b> : <a href="">PyObject</a> tidak sama dengan objek dalam Python, entitas ini khusus untuk CPython dan mewakili struktur dasar dari semua objek Python. <br><br>  PyObject didefinisikan sebagai struktur-C, jadi jika Anda bertanya-tanya mengapa Anda tidak bisa langsung memanggil kode ketik atau penghitung referensi, maka alasannya adalah bahwa Anda tidak memiliki akses langsung ke struktur.  Metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">panggilan</a> seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sys.getrefcount ()</a> dapat membantu mendapatkan beberapa hal internal. <br><br>  Jika kita berbicara tentang memori, maka akan terlihat seperti ini: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9d9/ad7/932/9d9ad79327405315461e3880fe3db256.png"><br><br>  Di sini, sirkuit memori sangat berbeda dari sirkuit di C yang ditunjukkan di atas.  Alih-alih memiliki <code>x</code> memiliki blok memori yang menyimpan nilai <code>2337</code> , objek Python yang baru dibuat memiliki memori yang hidup di <code>2337</code> .  Nama Python <code>x</code> tidak secara langsung memiliki alamat di memori, seperti halnya variabel C memiliki sel statis. <br><br>  Jika Anda ingin menetapkan <code>x</code> nilai baru, coba kode ini: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = <span class="hljs-number"><span class="hljs-number">2338</span></span></code> </pre> <br>  Perilaku sistem akan berbeda dari apa yang terjadi di C, tetapi itu tidak akan terlalu berbeda dari ikatan asli dengan Python. <br><br>  Dalam kode ini: <br><br><ul><li>  PyObject baru dibuat. <br></li><li>  Nomor untuk PyObject diberikan kode ketik. <br></li><li>  <code>2</code> diberi nilai untuk PyObject. <br></li><li>  <code>x</code> menunjuk ke PyObject baru. <br></li><li>  Jumlah referensi dari PyObject baru bertambah 1. <br></li><li>  Jumlah referensi dari PyObject lama dikurangi sebesar 1. <br></li></ul><br>  Sekarang sirkuit memori terlihat seperti ini: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/712/860/996/712860996aa37da34fdb69a466cdf5de.png"><br><br>  Ilustrasi ini menunjukkan bahwa <code>x</code> menunjuk ke referensi ke objek dan tidak memiliki area memori seperti sebelumnya.  Anda juga melihat bahwa perintah <code>x = 2338</code> bukan tugas, tetapi lebih merupakan pengikatan nama <code>x</code> ke tautan. <br><br>  Selain itu, objek sebelumnya (berisi nilai <code>2337</code> ) sekarang ada dalam memori dengan jumlah referensi 0, dan akan dihapus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">oleh pengumpul sampah</a> . <br><br>  Anda dapat memasukkan nama baru <code>y</code> , seperti dalam contoh C: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>y = x</code> </pre> <br>  Nama baru akan muncul di memori, tetapi tidak harus berupa objek baru: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/958/adc/410/958adc41013bb5483f0526689a48a871.png"><br><br>  Sekarang Anda melihat bahwa objek Python baru <b>belum</b> dibuat, hanya nama baru yang dibuat yang menunjuk ke objek yang sama.  Selain itu, penghitung referensi objek bertambah 1. Anda dapat memeriksa kesetaraan identitas objek untuk mengonfirmasi identitas mereka: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>y <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br>  Kode ini menunjukkan bahwa <code>x</code> dan <code>y</code> adalah satu objek.  Tapi jangan salah: Anda masih abadi.  Misalnya, Anda dapat melakukan operasi tambahan dengan <code>y</code> : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>y += <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;&gt;&gt; y <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br>  Setelah penambahan dipanggil, Anda akan mengembalikan objek Python baru.  Sekarang memori terlihat seperti ini: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8bd/abc/3e7/8bdabc3e7576ab86b00ba9c2b43b57b4.png"><br><br>  Objek baru telah dibuat, dan sekarang Anda menunjuk ke sana.  Sangat mengherankan bahwa kita akan mendapatkan keadaan akhir yang persis sama jika kita secara langsung menautkan <code>y</code> ke <code>2339</code> : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>y = <span class="hljs-number"><span class="hljs-number">2339</span></span></code> </pre> <br>  Setelah ungkapan ini, kami memperoleh memori terakhir, seperti dalam operasi penambahan.  Biarkan saya mengingatkan Anda bahwa dengan Python Anda tidak menetapkan variabel, tetapi ikat nama ke tautan. <br><br><h3>  Tentang magang di Python </h3><br>  Sekarang Anda mengerti bagaimana objek baru dibuat dengan Python dan bagaimana nama dilampirkan.  Sudah waktunya untuk berbicara tentang objek yang diinternir. <br><br>  Kami memiliki kode Python ini: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = <span class="hljs-number"><span class="hljs-number">1000</span></span> &gt;&gt;&gt; y = <span class="hljs-number"><span class="hljs-number">1000</span></span> &gt;&gt;&gt; x <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br>  Seperti sebelumnya, <code>x</code> dan <code>y</code> adalah nama yang menunjuk ke objek Python yang sama.  Tetapi objek ini yang berisi nilai <code>1000</code> tidak selalu dapat memiliki alamat memori yang sama.  Misalnya, jika Anda menambahkan dua angka dan mendapatkan 1000, Anda akan mendapatkan alamat lain: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = <span class="hljs-number"><span class="hljs-number">1000</span></span> &gt;&gt;&gt; y = <span class="hljs-number"><span class="hljs-number">499</span></span> + <span class="hljs-number"><span class="hljs-number">501</span></span> &gt;&gt;&gt; x <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br>  Kali ini, string <code>x is y</code> mengembalikan <code>False</code> .  Jika Anda malu, jangan khawatir.  Inilah yang terjadi ketika kode ini dieksekusi: <br><br><ol><li>  Objek Python dibuat ( <code>1000</code> ). <br></li><li>  Itu diberi nama <code>x</code> . <br></li><li>  Objek Python dibuat ( <code>499</code> ). <br></li><li>  Objek Python dibuat ( <code>501</code> ). <br></li><li>  Dua objek ini bertambah. <br></li><li>  Objek Python baru dibuat ( <code>1000</code> ). <br></li><li>  Dia diberi nama <code>y</code> . <br></li></ol><br>  <b>Penjelasan Teknis</b> : Langkah-langkah yang dijelaskan hanya terjadi ketika kode ini dijalankan di dalam REPL.  Jika Anda mengambil contoh di atas, tempel ke file dan jalankan, maka baris <code>x is y</code> akan mengembalikan <code>True</code> . <br><br>  Alasannya adalah kecerdasan cepat dari kompiler CPython, yang mencoba melakukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">optimasi lubang intip</a> yang membantu untuk menyimpan langkah-langkah eksekusi kode sebanyak mungkin.  Detail dapat ditemukan dalam <a href="">kode sumber CPython optimizer peyphole</a> . <br><br>  Tapi bukankah itu boros?  Ya, tapi Anda membayar harga ini untuk semua manfaat besar Python.  Anda tidak perlu berpikir untuk menghapus objek perantara tersebut, dan Anda bahkan tidak perlu tahu tentang keberadaannya!  Leluconnya adalah bahwa operasi ini dilakukan relatif cepat, dan Anda tidak akan mengetahuinya sampai saat itu. <br><br>  Pembuat Python dengan bijaksana memperhatikan overhead ini dan memutuskan untuk membuat beberapa optimasi.  Hasilnya adalah perilaku yang mungkin mengejutkan pemula: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = <span class="hljs-number"><span class="hljs-number">20</span></span> &gt;&gt;&gt; y = <span class="hljs-number"><span class="hljs-number">19</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;&gt;&gt; x <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br>  Dalam contoh ini, kodenya hampir sama seperti di atas, kecuali kita mendapatkan <code>True</code> .  Ini semua tentang benda yang diinternir.  Python pra-membuat subset objek tertentu dalam memori dan menyimpannya dalam namespace global untuk penggunaan sehari-hari. <br><br>  Objek mana yang bergantung pada implementasi Python?  Dalam CPython 3.7, interniran adalah: <br><br><ol><li>  Bilangan bulat mulai dari <code>-5</code> hingga <code>256</code> . <br></li><li>  String yang hanya berisi huruf, angka, atau garis bawah ASCII. <br></li></ol><br>  Ini karena variabel-variabel ini sangat sering digunakan dalam banyak program.  Dengan magang, Python mencegah alokasi memori untuk objek yang persisten. <br><br>  Baris dengan ukuran kurang dari 20 karakter dan berisi huruf, angka, atau garis bawah ASCII akan diinternir karena seharusnya digunakan sebagai pengidentifikasi: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>s1 = <span class="hljs-string"><span class="hljs-string">"realpython"</span></span> &gt;&gt;&gt; id(s1) <span class="hljs-number"><span class="hljs-number">140696485006960</span></span> &gt;&gt;&gt; s2 = <span class="hljs-string"><span class="hljs-string">"realpython"</span></span> &gt;&gt;&gt; id(s2) <span class="hljs-number"><span class="hljs-number">140696485006960</span></span> &gt;&gt;&gt; s1 <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> s2 <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br>  Di sini <code>s1</code> dan <code>s2</code> menunjuk ke alamat yang sama dalam memori.  Jika kami tidak memasukkan huruf, angka, atau garis bawah ASCII, kami akan mendapatkan hasil yang berbeda: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>s1 = <span class="hljs-string"><span class="hljs-string">"Real Python!"</span></span> &gt;&gt;&gt; s2 = <span class="hljs-string"><span class="hljs-string">"Real Python!"</span></span> &gt;&gt;&gt; s1 <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> s2 <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br>  Contoh ini menggunakan tanda seru, sehingga string tidak diinternir dan objek yang berbeda dalam memori. <br><br>  <b>Bonus</b> : Jika Anda ingin objek ini merujuk ke objek yang diinternir yang sama, Anda dapat menggunakan <code>sys.intern()</code> .  Salah satu cara untuk menggunakan fitur ini dijelaskan dalam dokumentasi: <br><br><blockquote>  Pemanggangan string berguna untuk sedikit meningkatkan kinerja pencarian kamus: jika kunci dalam kamus dan kunci yang akan dicari diinternir, maka perbandingan kunci (setelah hashing) dapat dilakukan dengan membandingkan pointer daripada string.  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sumber</a> ) </blockquote><br>  Internee sering membingungkan programmer.  Ingatlah bahwa jika Anda mulai ragu, Anda selalu dapat menggunakan <code>id()</code> dan untuk menentukan kesetaraan objek. <br><br><h2>  Emulasi Pointer Python </h2><br>  Fakta bahwa pointer tidak ada secara asli di Python tidak berarti bahwa Anda tidak dapat memanfaatkan pointer.  Sebenarnya ada beberapa cara untuk meniru pointer dengan Python.  Di sini kita melihat dua di antaranya: <br><br><ol><li>  Gunakan sebagai pointer ke tipe yang bisa berubah. <br></li><li>  Menggunakan objek Python yang disiapkan khusus. <br></li></ol><br><h3>  Gunakan sebagai pointer jenis bisa berubah </h3><br>  Anda sudah tahu jenis apa yang bisa berubah.  Berkat mutabilitas mereka, kita dapat meniru perilaku pointer.  Katakanlah Anda perlu mereplikasi kode ini: <br><br><pre> <code class="python hljs">void add_one(int *x) { *x += <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  Kode ini membawa pointer ke angka ( <code>*x</code> ) dan menambah nilainya dengan 1. Berikut adalah fungsi utama untuk mengeksekusi kode: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdi.h&gt; int main(void) { int y = 2337; printf("y = %d\n", y); add_one(&amp;y); printf("y = %d\n", y); return 0; }</span></span></code> </pre> <br>  Dalam fragmen di atas, kami menetapkan <code>y</code> ke <code>2337</code> , menampilkan nilai saat ini, meningkatkannya dengan 1, dan kemudian menampilkan nilai baru.  Berikut ini muncul di layar: <br><br><pre> <code class="python hljs">y = <span class="hljs-number"><span class="hljs-number">2337</span></span> y = <span class="hljs-number"><span class="hljs-number">2338</span></span></code> </pre> <br>  Salah satu cara untuk mereplikasi perilaku ini dengan Python adalah dengan menggunakan tipe yang bisa berubah.  Misalnya, terapkan daftar dan ubah elemen pertama: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_one</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> ... x[<span class="hljs-number"><span class="hljs-number">0</span></span>] += <span class="hljs-number"><span class="hljs-number">1</span></span> ... &gt;&gt;&gt; y = [<span class="hljs-number"><span class="hljs-number">2337</span></span>] &gt;&gt;&gt; add_one(y) &gt;&gt;&gt; y[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-number"><span class="hljs-number">2338</span></span></code> </pre> <br>  Di sini <code>add_one(x)</code> merujuk ke elemen pertama dan meningkatkan nilainya dengan 1. Menggunakan daftar berarti bahwa sebagai hasilnya kita mendapatkan nilai yang diubah.  Jadi ada pointer di Python?  Tidak.  Perilaku yang dijelaskan menjadi mungkin karena daftar adalah tipe yang bisa berubah.  Jika Anda mencoba menggunakan tuple, Anda mendapatkan kesalahan: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>z = (<span class="hljs-number"><span class="hljs-number">2337</span></span>,) &gt;&gt;&gt; add_one(z)</code> </pre> <br>  Jejak balik (panggilan terbaru terakhir): <br><br><pre> <code class="python hljs"> File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> add_one TypeError: <span class="hljs-string"><span class="hljs-string">'tuple'</span></span> object does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> support item assignment</code> </pre> <br>  Kode ini menunjukkan ketidakstabilan tuple, sehingga tidak mendukung penetapan elemen. <br><br>  <code>list</code> bukan satu-satunya tipe yang bisa berubah, pointer bagian juga ditiru menggunakan <code>dict</code> . <br><br>  Misalkan Anda memiliki aplikasi yang harus melacak terjadinya peristiwa menarik.  Ini dapat dilakukan dengan membuat kamus dan menggunakan salah satu elemennya sebagai penghitung: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>counters = {<span class="hljs-string"><span class="hljs-string">"func_calls"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>} &gt;&gt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... counters[<span class="hljs-string"><span class="hljs-string">"func_calls"</span></span>] += <span class="hljs-number"><span class="hljs-number">1</span></span> ... &gt;&gt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... counters[<span class="hljs-string"><span class="hljs-string">"func_calls"</span></span>] += <span class="hljs-number"><span class="hljs-number">1</span></span> ... bar() ... &gt;&gt;&gt; foo() &gt;&gt;&gt; counters[<span class="hljs-string"><span class="hljs-string">"func_calls"</span></span>] <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br>  Dalam contoh ini, kamus menggunakan penghitung untuk melacak jumlah panggilan fungsi.  Setelah memanggil <code>foo()</code> penghitung bertambah 2, seperti yang diharapkan.  Dan semua berkat <code>dict</code> . <br><br>  Jangan lupa, ini hanya <b>emulasi</b> dari perilaku pointer, ini tidak ada hubungannya dengan pointer nyata di C dan C ++.  Kita dapat mengatakan bahwa operasi ini lebih mahal daripada jika dilakukan dalam C atau C ++. <br><br><h3>  Menggunakan Objek Python </h3><br>  <code>dict</code> adalah cara yang bagus untuk meniru pointer dengan Python, tetapi terkadang membosankan untuk mengingat nama kunci yang Anda gunakan.  Terutama jika Anda menggunakan kamus di berbagai bagian aplikasi.  Kelas Python khusus dapat membantu di sini. <br><br>  Katakanlah Anda perlu melacak metrik dalam suatu aplikasi.  Cara terbaik untuk mengabaikan detail yang menjengkelkan adalah membuat kelas: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Metrics</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self._metrics = { <span class="hljs-string"><span class="hljs-string">"func_calls"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"cat_pictures_served"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, }</code> </pre> <br>  Kode ini mendefinisikan kelas <code>Metrics</code> .  Masih menggunakan kamus untuk menyimpan data terbaru yang terletak pada <code>_metrics</code> anggota <code>_metrics</code> .  Ini akan memberi Anda mutabilitas yang diperlukan.  Sekarang Anda hanya perlu mengakses nilai-nilai ini.  Anda dapat melakukan ini menggunakan properti: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Metrics</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... @property def func_calls(self): return self._metrics["func_calls"] @property def cat_pictures_served(self): return self._metrics["cat_pictures_served"]</span></span></code> </pre> <br>  Di sini kita menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@ properti</a> .  Jika Anda baru mengenal dekorator, baca artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Primer tentang Python Dekorator</a> .  Dalam hal ini, dekorator <code>@property</code> memungkinkan Anda untuk mengakses <code>func_calls</code> dan <code>cat_pictures_served</code> , seolah-olah mereka adalah atribut: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>metrics = Metrics() &gt;&gt;&gt; metrics.func_calls <span class="hljs-number"><span class="hljs-number">0</span></span> &gt;&gt;&gt; metrics.cat_pictures_served <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  Fakta bahwa Anda dapat merujuk nama-nama ini sebagai atribut berarti bahwa Anda disarikan dari fakta bahwa nilai-nilai ini disimpan dalam kamus.  Selain itu, Anda membuat nama atribut lebih eksplisit.  Tentu saja, Anda harus dapat meningkatkan nilai: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Metrics</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def inc_func_calls(self): self._metrics["func_calls"] += 1 def inc_cat_pics(self): self._metrics["cat_pictures_served"] += 1</span></span></code> </pre> <br>     : <br><br><ol><li> <code>inc_func_calls()</code> </li> <li> <code>inc_cat_pics()</code> </li> </ol><br>      <code>metrics</code> .     ,     ,   : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>metrics = Metrics() &gt;&gt;&gt; metrics.inc_func_calls() &gt;&gt;&gt; metrics.inc_func_calls() &gt;&gt;&gt; metrics.func_calls <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br>     <code>func_calls</code>   <code>inc_func_calls()</code>         Python.    ,     -  <code>metrics</code> ,          . <br><br> <b></b> :   ,   <code>inc_func_calls()</code>  <code>inc_cat_pics()</code>   <code>@property.setter</code>        <code>int</code> ,     . <br><br>      <code>Metrics</code> : <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Metrics</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self._metrics = { <span class="hljs-string"><span class="hljs-string">"func_calls"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"cat_pictures_served"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, } @property <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func_calls</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._metrics[<span class="hljs-string"><span class="hljs-string">"func_calls"</span></span>] @property <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cat_pictures_served</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._metrics[<span class="hljs-string"><span class="hljs-string">"cat_pictures_served"</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inc_func_calls</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self._metrics[<span class="hljs-string"><span class="hljs-string">"func_calls"</span></span>] += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inc_cat_pics</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self._metrics[<span class="hljs-string"><span class="hljs-string">"cat_pictures_served"</span></span>] += <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><h2>     ctypes </h2><br>  , -    Python,   CPython?     ctypes    ,   C.      ctypes,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Extending Python With C Libraries and the Â«ctypesÂ» Module</a> . <br><br>       ,     ,   .     - <code>add_one()</code> : <br><br><pre> <code class="python hljs">void add_one(int *x) { *x += <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br> ,      <code>x</code>  1.   ,      (shared) .  ,      <code>add.c</code> ,      gcc: <br><br><pre> <code class="python hljs">$ gcc -c -Wall -Werror -fpic add.c $ gcc -shared -o libadd1.so add.o</code> </pre> <br>      C   <code>add.o</code> .           <code>libadd1.so</code> . <br><br> <code>libadd1.so</code>      .    ctypes    Python: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ctypes &gt;&gt;&gt; add_lib = ctypes.CDLL(<span class="hljs-string"><span class="hljs-string">"./libadd1.so"</span></span>) &gt;&gt;&gt; add_lib.add_one &lt;_FuncPtr object at <span class="hljs-number"><span class="hljs-number">0x7f9f3b8852a0</span></span>&gt;</code> </pre> <br>  ctypes.CDLL  ,     <code>libadd1</code> .      <code>add_one()</code> ,      ,        Python-.     ,    .  Python  ,      . <br><br>         , ctypes       : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>add_one = add_lib.add_one &gt;&gt;&gt; add_one.argtypes = [ctypes.POINTER(ctypes.c_int)]</code> </pre> <br>     ,    C. ,        ,       : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>add_one(<span class="hljs-number"><span class="hljs-number">1</span></span>) Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; ctypes.ArgumentError: argument <span class="hljs-number"><span class="hljs-number">1</span></span>: &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> '</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TypeError</span></span></span><span class="hljs-class">'&gt;:</span></span> \ expected LP_c_int instance instead of int</code> </pre> <br> Python    ,  <code>add_one()</code>   ,     .  ,  ctypes      .       : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = ctypes.c_int() &gt;&gt;&gt; x c_int(<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>      <code>x</code>   <code>0</code> . ctypes    <code>byref()</code> ,      . <br><br> <b></b> :  <b> </b>     <b> </b> . <br><br>          ,       .         ,        . <br><br>   <code>add_one()</code>    : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>add_one(ctypes.byref(x)) <span class="hljs-number"><span class="hljs-number">998793640</span></span> &gt;&gt;&gt; x c_int(<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Hebat!     1. ,     Python  . <br><br><h2>  Kesimpulan </h2><br>        Python  .          ,              Python. <br><br>         Python: <br><br><ul><li>          . <br></li><li>   Python-   . <br></li><li>       ctypes. <br></li></ul><br>       Python       . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id454324/">https://habr.com/ru/post/id454324/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id454314/index.html">10 prinsip pemrograman berorientasi objek yang harus diperhatikan oleh setiap pengembang</a></li>
<li><a href="../id454316/index.html">Mengikuti jejak ninja industri: kami mengundang Anda untuk berpartisipasi dalam kompetisi keamanan industri online</a></li>
<li><a href="../id454318/index.html">Terdengar masa lalu. Panduan bagi sejarawan tentang mengonversi data menjadi suara</a></li>
<li><a href="../id454320/index.html">Analis Pasar Tenaga Kerja dan Ilmuwan Data</a></li>
<li><a href="../id454322/index.html">Ada yang mengatakan bahwa teknologi DANE untuk browser telah gagal</a></li>
<li><a href="../id454326/index.html">Selain Moore - siapa lagi yang merumuskan hukum skala sistem komputer</a></li>
<li><a href="../id454330/index.html">10 highlight dari TechTrain 2018: AI untuk massa, antarmuka, dan banyak lagi</a></li>
<li><a href="../id454332/index.html">Bagaimana Telegram dapat mengatasi penundaan penundaan perancang dan membantu meningkatkan pendapatan agensi digital</a></li>
<li><a href="../id454334/index.html">Moto. Menangis AWS</a></li>
<li><a href="../id454336/index.html">Klien: - Berapa biaya salinan Facebook?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>