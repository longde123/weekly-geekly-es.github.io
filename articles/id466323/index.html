<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸµ ğŸ§¢ ğŸ¤ŸğŸ½ Kami membuat game platform portabel di mikrokontroler Cortex M0 + ğŸŒ¾ ğŸ“… âš—ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 
 (Tautan ke kode sumber dan proyek KiCAD disediakan di akhir artikel.) 

 Meskipun kami dilahirkan di era 8-bit, komputer pertama kami ad...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami membuat game platform portabel di mikrokontroler Cortex M0 +</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466323/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/mg/8v/j_/mg8vj_mlkkh99th0jwxuun5mudk.png"></div><br><h2>  Pendahuluan </h2><br>  <em>(Tautan ke kode sumber dan proyek KiCAD disediakan di akhir artikel.)</em> <br><br>  Meskipun kami dilahirkan di era 8-bit, komputer pertama kami adalah Amiga 500. Ini adalah mesin 16-bit yang hebat dengan grafis dan suara yang luar biasa, menjadikannya hebat untuk bermain game.  Platforming telah menjadi genre game yang sangat populer di komputer ini.  Banyak dari mereka sangat berwarna-warni dan memiliki paralaks yang sangat halus.  Ini dimungkinkan berkat programmer berbakat yang dengan cerdik menggunakan prosesor Amiga untuk meningkatkan jumlah warna layar.  Lihatlah LionHeart misalnya! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/567/0f4/c54/5670f4c541f76158b62e57d951a0f83f.png"></div><br>  <i>Lionheart on Amiga.</i>  <i>Gambar statis ini tidak menampilkan keindahan gambar.</i> <br><br>  Sejak 90-an, elektronik telah banyak berubah, dan sekarang ada banyak mikrokontroler kecil yang memungkinkan Anda untuk membuat hal-hal luar biasa. <br><br>  Kami selalu menyukai game platform, dan hari ini, hanya dengan beberapa dolar, Anda dapat membeli Raspberry Zero, menginstal Linux, dan â€œcukup mudahâ€ menulis game platform yang penuh warna. <br><br>  Tapi tugas ini bukan untuk kita - kita tidak ingin menembak burung pipit dari meriam! <br><br>  Kami ingin menggunakan mikrokontroler dengan memori terbatas, dan bukan sistem yang kuat pada chip dengan GPU terintegrasi!  Dengan kata lain, kami menginginkan kesulitan! <br><a name="habracut"></a><br>  Ngomong-ngomong, tentang kemungkinan video: beberapa orang berhasil memeras semua jus dari mikrokontroler AVR dalam proyek mereka (misalnya, dalam proyek Uzebox atau Craft dari pengembang lft).  Namun, untuk mencapai ini, mikrokontroler AVR memaksa kita untuk menulis dalam assembler, dan meskipun beberapa gim sangat bagus, Anda akan menghadapi keterbatasan serius yang tidak memungkinkan Anda membuat gim dalam gaya 16-bit. <br><br>  Oleh karena itu, kami memutuskan untuk menggunakan mikrokontroler / papan yang lebih seimbang, yang memungkinkan kami untuk menulis kode sepenuhnya dalam C. <br><br>  Dia tidak sekuat Arduino Due, tetapi tidak selemah Arduino Uno.  Menariknya, "Jatuh Tempo" berarti "dua," dan "Uno" berarti "satu."  Microsoft mengajarkan kami untuk menghitung dengan benar (1, 2, 3, 95, 98, ME, 2000, XP, Vista, 7, 8, 10), dan Arduino juga menggunakan cara ini!  Kami akan menggunakan Arduino Zero, yang berada di tengah antara 1 dan 2! <br><br>  Ya, menurut Arduino, 1 &lt;0 &lt;2. <br><br>  Secara khusus, kami tidak tertarik pada papan itu sendiri, tetapi pada seri prosesornya.  Arduino Zero memiliki mikrokontroler seri ATSAMD21 dengan Cortex M0 + (48 MHz), memori flash 256 KB dan RAM 32 KB. <br><br>  Meskipun Cortex M0 + 48-MHz secara signifikan mengungguli MC68000 7-MHz yang lama dalam kinerja, Amiga 500 memiliki RAM 512 KB, sprite perangkat keras, papan permainan ganda terintegrasi, Blitter (mesin transfer blok berbasis gambar DMA dengan sistem pengenalan tabrakan pixel-akurasi bawaan) dan transparansi) dan Tembaga (coprocessor raster yang memungkinkan Anda untuk melakukan operasi dengan register berdasarkan posisi sapuan untuk menciptakan banyak efek yang sangat indah).  SAMD21 tidak memiliki semua perangkat keras ini (dengan pengecualian yang agak sederhana dibandingkan dengan Blitter DMA), jadi banyak yang akan ditampilkan secara terprogram. <br><br>  Kami ingin mencapai parameter berikut: <br><br><ul><li>  Resolusi 160 x 128 piksel pada layar SPI 1,8 inci. </li><li>  Grafik dengan 16 bit per piksel; </li><li>  Frame rate tertinggi.  Setidaknya 25 fps pada 12 MHz SPI, atau 40 fps pada 24 MHz; </li><li>  lapangan bermain ganda dengan scroll parallax; </li><li>  semuanya ditulis dalam C. Tidak ada kode assembler; </li><li>  Pixel-akurat pengakuan tabrakan; </li><li>  hamparan layar. </li></ul><br>  Tampaknya mencapai tujuan-tujuan ini cukup sulit.  Ya, terutama jika kita menolak kode asm! <br><br>  Misalnya, dengan warna 16-bit, ukuran layar 160 Ã— 128 piksel akan membutuhkan 40 KB untuk buffer layar, tetapi kami hanya memiliki 32 KB RAM!  Dan kita masih perlu menggulir paralaks pada bidang permainan ganda dan banyak lagi, dengan frekuensi setidaknya 25/40 fps! <br><br>  Tapi tidak ada yang mustahil bagi kita, kan? <br><br>  Kami menggunakan trik dan fungsi bawaan ATSAMD21!  Sebagai "perangkat keras", kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">uChip</a> , yang dapat dibeli di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Toko Itaca</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ff/e77/4aa/9ffe774aac84e2df3534d9ac2f16724b.jpg"></div><br>  <i>uChip: jantung dari proyek kami!</i> <br><br>  Ini memiliki karakteristik yang sama dengan Arduino Zero, tetapi jauh lebih sedikit, dan juga lebih murah daripada Arduino Zero asli (ya, Anda dapat membeli Arduino Zero palsu seharga $ 10 pada AliExpress ... tetapi kami ingin membangun yang asli).  Ini akan memungkinkan kami untuk membuat konsol portabel kecil.  Anda dapat mengadaptasi proyek ini untuk Arduino Zero dengan mudah, hanya hasilnya akan cukup rumit. <br><br>  Kami juga membuat papan uji kecil yang mengimplementasikan konsol portabel untuk orang miskin.  Detail di bawah! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a8a/c34/04e/a8ac3404e35351c6e02368763ef985a5.jpg"></div><br>  Kami tidak akan menggunakan kerangka kerja Arduino.  Itu tidak cocok ketika datang untuk mengoptimalkan dan mengelola peralatan.  (Dan jangan bicara tentang IDE!) <br><br>  Pada artikel ini, kami akan menjelaskan bagaimana kami sampai pada versi final game, menjelaskan semua optimasi dan kriteria yang digunakan.  Gim itu sendiri belum lengkap, tidak memiliki suara, level, dll.  Namun, ini dapat digunakan sebagai titik awal untuk berbagai jenis permainan! <br><br>  Selain itu, ada banyak lagi opsi optimasi, bahkan tanpa assembler! <br><br>  Jadi, mari kita mulai perjalanan kita! <br><br><h2>  Kesulitan </h2><br>  Sebenarnya, proyek ini memiliki dua aspek kompleks: pengaturan waktu dan memori (RAM dan penyimpanan). <br><br><h3>  Memori </h3><br>  Mari kita mulai dengan memori.  Pertama, alih-alih menyimpan gambar tingkat besar, kami menggunakan ubin.  Bahkan, jika Anda dengan hati-hati menganalisis sebagian besar platformer, Anda akan melihat bahwa mereka dibuat dari sejumlah kecil elemen grafis (ubin) yang diulang berkali-kali. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f36/950/80a/f3695080a0bfe4d7f1ce6809c8efe275.png"></div><br>  <i>Turrican 2 di Amiga.</i>  <i>Salah satu game platform terbaik sepanjang masa.</i>  <i>Anda dapat dengan mudah melihat ubin di dalamnya!</i> <br><br>  Dunia / tingkat tampaknya beragam berkat berbagai kombinasi ubin.  Ini menghemat banyak memori pada drive, tetapi tidak memecahkan masalah buffer bingkai besar. <br><br>  Trik kedua yang kami gunakan adalah mungkin karena kekuatan komputasi UC yang agak besar dan keberadaan DMA!  Alih-alih menyimpan semua data frame dalam RAM (dan mengapa ini diperlukan?) Kami akan membuat adegan di setiap frame dari awal.  Secara khusus, kami akan terus menggunakan buffer, tetapi sedemikian rupa sehingga sesuai dalam satu blok horizontal grafik data dengan tinggi 16 piksel. <br><br><h3>  Pengaturan waktu - CPU </h3><br>  Ketika seorang insinyur perlu membuat sesuatu, dia pertama-tama memeriksa untuk melihat apakah ini mungkin.  Tentu saja, pada awalnya kami melakukan tes ini! <br><br>  Jadi, kita membutuhkan setidaknya 25 fps pada layar 160 Ã— 128 piksel.  Itu adalah 512.000 piksel / s.  Karena mikrokontroler beroperasi pada frekuensi 48 MHz, kami memiliki setidaknya 93 siklus clock per piksel.  Nilai ini turun menjadi 58 siklus jika kita bertujuan 40 fps. <br><br>  Faktanya, mikrokontroler kami mampu memproses hingga 2 piksel dalam satu waktu, karena setiap piksel membutuhkan 16 bit, dan ATSAMD21 memiliki bus internal 32-bit, yaitu, kinerjanya akan lebih baik! <br><br>  Nilai 93 clock cycle memberi tahu kita bahwa tugas itu sepenuhnya bisa dilakukan!  Bahkan, kita dapat menyimpulkan bahwa CPU sendiri dapat menangani semua tugas rendering tanpa DMA.  Kemungkinan besar, ini benar, terutama ketika bekerja dengan assembler.  Namun, kodenya akan sangat sulit ditangani.  Dan di C itu harus sangat dioptimalkan!  Sebenarnya, Cortex M0 + tidak ramah-C seperti Cortex M3, dan tidak memiliki banyak instruksi (bahkan tidak memuat / menghemat dengan kenaikan / pra-kenaikan / pengurangan berikutnya!), Yang harus dilaksanakan dengan dua atau lebih instruksi sederhana. <br><br>  Mari kita lihat apa yang perlu kita lakukan untuk menggambar dua bidang bermain (dengan asumsi kita sudah tahu koordinat x dan y, dll.). <br><br><ul><li>  Hitung lokasi piksel latar depan dalam memori flash. </li><li>  Dapatkan nilai piksel. </li><li>  Jika transparan, hitung posisi piksel latar belakang dalam blitz. </li><li>  Dapatkan nilai piksel. </li><li>  Hitung lokasi target. </li><li>  Simpan piksel ke buffer. </li></ul><br>  Selain itu, untuk setiap sprite yang dapat masuk ke buffer, operasi berikut harus dilakukan: <br><br><ul><li>  Hitung posisi piksel sprite dalam memori flash. </li><li>  Mendapatkan nilai piksel. </li><li>  Jika tidak transparan, maka hitung lokasi buffer tujuan. </li><li>  Menyimpan piksel dalam buffer. </li></ul><br>  Semua operasi ini tidak hanya tidak diimplementasikan sebagai instruksi ASM tunggal, tetapi setiap instruksi ASM membutuhkan dua siklus ketika mengakses RAM / memori flash. <br><br>  Selain itu, kami masih belum memiliki logika permainan (yang, untungnya, membutuhkan sedikit waktu, karena dihitung sekali per frame), pengenalan tabrakan, pemrosesan buffer, dan instruksi yang diperlukan untuk mengirim data melalui SPI. <br><br>  Sebagai contoh, ini adalah pseudo-code dari apa yang harus kita lakukan (untuk saat ini, kita asumsikan bahwa permainan tidak memiliki scrolling, dan lapangan bermain memiliki latar belakang warna yang konstan!) Hanya untuk latar depan. <br><br>  Biarkan cameraY dan cameraX menjadi koordinat sudut kiri atas layar di dunia game. <br><br>  Biarkan xTilepos dan yTilepos menjadi posisi petak saat ini di peta. <br><br><pre><code class="cpp hljs">xTilepos = cameraX / <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-comment"><span class="hljs-comment">// this is a rightward shift of 4 bits. yTilepos = cameraY / 16; destBufferAddress = &amp;buffer[0][0]; for tile = 0...9 nTile = gameMap[yTilepos][xTilepos]; tileDataAddress = &amp;tileData[nTile]; xTilepos = xTilepos + 1; for y = 0â€¦15 for x = 0â€¦15 pixel = *tileDataAddress; tileDataAddress = tileDataAddress + 1; *destBufferAddress = pixel; destBufferAddress = destBufferAddress + 1; next destBufferAddress = destBufferAddress + 144; // point to next row next destBufferAddress = destBufferAddress â€“ ( 160 * 16 - 16); // now point to the position where the next tile will be saved. next</span></span></code> </pre> <br>  Jumlah instruksi untuk 2560 piksel (160 x 16) adalah sekitar 16rb, mis.  6 per piksel.  Bahkan, Anda bisa menggambar dua piksel sekaligus.  Ini membagi dua jumlah instruksi aktual per pixel, yaitu, jumlah instruksi level tinggi per pixel adalah sekitar 3. Namun, beberapa instruksi level tinggi ini akan dibagi menjadi dua atau lebih instruksi assembler, atau memerlukan setidaknya dua siklus untuk menyelesaikan karena mereka mengakses ke memori.  Juga, kami tidak mempertimbangkan mengatur ulang pipa CPU karena melompat dan menunggu status untuk memori flash.  Ya, kami masih jauh dari siklus 58-93 yang kami miliki, tetapi kami masih perlu mempertimbangkan latar belakang lapangan bermain dan sprite. <br><br>  Meskipun kami melihat bahwa masalah dapat diselesaikan pada satu CPU, DMA akan jauh lebih cepat.  Akses memori langsung menyisakan lebih banyak ruang untuk sprite layar atau efek grafis yang lebih baik (misalnya, kita dapat menerapkan alpha blending). <br><br>  Kami akan melihat bahwa untuk mengonfigurasi DMA untuk setiap ubin, kami membutuhkan kurang dari 100 instruksi C, mis. Kurang dari 0,5 per piksel!  Tentu saja, DMA masih harus melakukan jumlah transfer yang sama dalam memori, tetapi peningkatan alamat dan transmisi dilakukan tanpa campur tangan CPU, yang dapat melakukan hal lain (misalnya, menghitung dan merender sprite). <br><br>  Menggunakan timer SysTick, kami menemukan bahwa waktu yang diperlukan untuk menyiapkan DMA untuk seluruh blok, dan kemudian untuk menyelesaikan DMA, adalah sekitar 12k clock cycle.  Catatan: siklus jam!  Bukan instruksi level tinggi!  Jumlah siklus cukup tinggi untuk hanya 2560 piksel, mis.  1.280 kata 32-bit.  Bahkan, kami mendapatkan sekitar 10 siklus per kata 32-bit.  Namun, Anda perlu mempertimbangkan waktu yang diperlukan untuk menyiapkan DMA, serta waktu yang diperlukan DMA untuk memuat deskriptor transfer dari RAM (yang pada dasarnya berisi pointer dan jumlah byte yang ditransfer).  Selain itu, selalu ada semacam perubahan bus memori (sehingga CPU tidak dapat diam tanpa data), dan memori flash memerlukan setidaknya satu keadaan tunggu. <br><br><h3>  Pengaturan waktu - SPI </h3><br>  Kemacetan lain adalah SPI.  Apakah 12 MHz cukup untuk 25 fps?  Jawabannya adalah ya: 12 MHz sesuai dengan sekitar 36 frame per detik.  Jika kita menggunakan 24 MHz, maka batasnya akan berlipat ganda! <br><br>  Omong-omong, spesifikasi layar dan mikrokontroler mengatakan bahwa kecepatan SPI maksimum masing-masing adalah 15 dan 12 MHz.  Kami menguji dan memastikan bahwa itu dapat ditingkatkan ke 24 MHz tanpa masalah, setidaknya dalam "arah" yang kita butuhkan (mikrokontroler menulis ke layar). <br><br>  Kami akan menggunakan tampilan SPI 1,8 inci yang populer.  Kami memastikan bahwa ILI9163 dan ST7735 beroperasi secara normal dengan frekuensi 12 MHz (setidaknya dengan 12 MHz. Telah diverifikasi bahwa ST7735 beroperasi dengan frekuensi hingga 24 MHz).  Jika Anda ingin menggunakan tampilan yang sama seperti dalam tutorial "Cara memutar video di Arduino Uno", kami sarankan Anda memodifikasinya jika Anda ingin menambahkan dukungan SD di masa depan.  Kami menggunakan versi kartu SD sehingga kami memiliki banyak ruang untuk elemen lain, seperti suara atau level tambahan. <br><br><h2>  Grafik </h2><br>  Seperti yang telah disebutkan, permainan menggunakan ubin.  Setiap level terdiri dari ubin yang diulang sesuai tabel, yang kami sebut "gameMap".  Seberapa besar masing-masing ubin?  Ukuran setiap ubin sangat mempengaruhi konsumsi memori, detail, dan fleksibilitas (dan, seperti yang akan kita lihat nanti, kecepatan juga).  Ubin yang terlalu besar akan membutuhkan pembuatan ubin baru untuk setiap variasi kecil yang kita butuhkan.  Ini akan memakan banyak ruang di drive. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a96/a66/32a/a96a6632abfec9bef7341e42bed6cf45.png" width="580" height="165"></div><br>  <i>Dua ubin berukuran 32 Ã— 32 piksel (kiri dan tengah), yang berbeda dalam sebagian kecil (bagian kanan atas piksel adalah 16 Ã— 16).</i>  <i>Karena itu, kita perlu menyimpan dua ubin berbeda dengan ukuran 32 Ã— 32 piksel.</i>  <i>Jika kita menggunakan ubin 16 Ã— 16 piksel (di sebelah kanan), maka kita hanya perlu menyimpan dua ubin 16 Ã— 16 (ubin yang sepenuhnya putih dan ubin di sebelah kanan).</i>  <i>Namun, saat menggunakan 16 Ã— 16 ubin, kami mendapatkan 4 elemen peta.</i> <br><br>  Namun, ubin lebih sedikit per layar diperlukan, yang meningkatkan kecepatan (lihat di bawah) dan mengurangi ukuran peta (yaitu jumlah baris dan kolom dalam tabel) dari setiap level.  Ubin terlalu kecil menciptakan masalah sebaliknya.  Tabel peta semakin besar dan kecepatan melambat.  Tentu saja, kita tidak akan membuat keputusan bodoh.  misalnya, pilih ubin dengan ukuran 17 Ã— 31 piksel.  Teman setia kami - derajat dua!  Ukuran 16 Ã— 16 hampir menjadi "aturan emas", digunakan dalam banyak game, dan kami akan memilihnya! <br><br>  Layar kami memiliki ukuran 160 Ã— 128.  Dengan kata lain, kita membutuhkan 10 Ã— 8 ubin per layar, mis.  80 entri dalam tabel.  Untuk level besar 10 Ã— 10 layar (atau 100 Ã— 1 layar), hanya 8.000 catatan akan diperlukan (16 KB jika kita menggunakan 16 bit untuk merekam. Kemudian kita akan menunjukkan mengapa kita memutuskan untuk memilih 16 bit untuk merekam). <br><br>  Bandingkan ini dengan jumlah memori yang kemungkinan akan ditempati oleh gambar besar di seluruh layar: 40 KB * 100 = 4 MB!  Ini gila! <br><br>  Mari kita bicara tentang sistem rendering. <br><br>  Setiap frame harus mengandung (dalam urutan gambar): <br><br><ul><li>  grafik latar belakang (bidang bermain kembali) </li><li>  grafik level itu sendiri (foreground). </li><li>  sprite </li><li>  teks / hamparan teratas. </li></ul><br>  Secara khusus, kami akan melakukan operasi berikut secara berurutan: <br><br><ol><li>  Menggambar latar belakang + latar depan (ubin) </li><li>  menggambar ubin tembus + sprite + overlay atas </li><li>  mengirim data dengan SPI. </li></ol><br>  Latar belakang dan ubin yang sepenuhnya buram akan ditarik oleh DMA.  Ubin yang sepenuhnya buram adalah ubin yang tidak memiliki piksel transparan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2da/1dd/417/2da1dd41756746a4b387988c191ca673.png"></div><br>  <i>Ubin sebagian transparan (kiri) dan benar-benar buram (kanan).</i>  <i>Dalam ubin sebagian transparan, beberapa piksel (di kiri bawah) transparan, dan karenanya latar belakang terlihat melalui area ini.</i> <br><br>  Ubin, sprite, dan overlay yang sebagian transparan tidak dapat dibuat secara efektif oleh DMA.  Faktanya, sistem DMA chip ATSAMD21 hanya menyalin data, dan tidak seperti Blitter komputer Amiga, itu tidak memeriksa transparansi (ditentukan oleh nilai warna).  Semua elemen transparan sebagian digambar oleh CPU. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bb/8a2/950/7bb8a29500f57268d62dae5b1de2a9ea.png"></div><br>  Data kemudian ditransmisikan ke layar menggunakan DMA. <br><br><h3>  Membuat saluran pipa </h3><br>  Seperti yang Anda lihat, jika kami melakukan operasi ini secara berurutan dalam satu buffer, itu akan memakan banyak waktu.  Bahkan, ketika DMA sedang berjalan, CPU tidak akan sibuk kecuali menunggu DMA selesai!  Ini adalah cara yang buruk untuk mengimplementasikan mesin grafis.  Selain itu, ketika DMA mengirim data ke perangkat SPI, itu tidak menggunakan bandwidth penuh.  Bahkan, bahkan ketika SPI beroperasi pada frekuensi 24 MHz, data ditransmisikan hanya pada frekuensi 3 MHz, yang cukup kecil.  Dengan kata lain, DMA tidak digunakan untuk potensi penuh: DMA dapat melakukan tugas-tugas lain tanpa benar-benar kehilangan kinerja. <br><br>  Itulah sebabnya kami mengimplementasikan pipeline, yang merupakan pengembangan dari ide buffering ganda (kami menggunakan tiga buffer!).  Tentu saja, pada akhirnya, operasi selalu dilakukan secara berurutan.  Tetapi CPU dan DMA secara bersamaan melakukan tugas yang berbeda, tanpa (terutama) saling mempengaruhi. <br><br>  Inilah yang terjadi pada saat yang bersamaan: <br><br><ul><li>  Buffer digunakan untuk menggambar data latar belakang menggunakan saluran DMA 1; </li><li>  Di buffer lain (yang sebelumnya diisi dengan data latar belakang), CPU menggambar sprite dan ubin transparan sebagian; </li><li>  Kemudian buffer lain (yang berisi blok data horizontal penuh) digunakan untuk mengirim data ke tampilan melalui SPI menggunakan saluran DMA 0. Tentu saja, buffer yang digunakan untuk mengirim data melalui SPI sebelumnya diisi dengan sprite sedangkan SPI mengirim blok sebelumnya dan sementara buffer lain penuh dengan ubin. </li></ul><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a75/56e/a95/a7556ea9572df04f967fae2035275c01.png"></div><br><h3>  DMA </h3><br>  Sistem DMA chip ATSAMD21 tidak dapat dibandingkan dengan Blitter, namun demikian ia memiliki fitur-fiturnya yang bermanfaat.  Berkat DMA, kami dapat memberikan kecepatan refresh yang sangat tinggi, meskipun memiliki lapangan bermain ganda. <br><br>  Konfigurasi transfer DMA disimpan dalam RAM, dalam â€œdeskriptor DMAâ€, memberi tahu DMA bagaimana dan di mana ia harus melakukan transfer saat ini.  Deskriptor ini dapat digabungkan bersama: jika ada koneksi (mis. Tidak ada pointer nol), maka setelah transfer selesai, DMA akan secara otomatis menerima deskriptor berikutnya.  Melalui penggunaan banyak deskriptor, DMA dapat melakukan "transfer kompleks" yang berguna ketika, misalnya, buffer sumber adalah urutan segmen yang tidak berdampingan dari byte yang berdekatan.  Namun, butuh waktu untuk mendapatkan dan menulis deskriptor, karena Anda perlu menyimpan / memuat 16 byte deskriptor dari RAM. <br><br>  DMA dapat bekerja dengan data dengan panjang yang berbeda: byte, setengah kata (16 bit) dan kata-kata (32 bit).  Dalam spesifikasinya, panjang ini disebut "beat size".  Untuk SPI, kami dipaksa untuk menggunakan transfer byte (meskipun spesifikasi REVD saat ini menyatakan bahwa chip ATSAMD21 SERCOM memiliki FIFO, yang, menurut Microchip, dapat menerima data 32-bit, pada kenyataannya, tampaknya mereka tidak memiliki FIFO. Spesifikasi REVD juga menyebutkan Register SERCOM CTRLC, yang tidak ada di file header dan di bagian deskripsi register. Untungnya, tidak seperti AVR, ATSAMD21 setidaknya memiliki register data transfer buffer, sehingga tidak akan ada jeda dalam pengiriman!).  Untuk menggambar ubin, kami, tentu saja, menggunakan 32 bit.  Ini memungkinkan Anda untuk menyalin dua piksel per ketukan.  Chip ATSAMD21 DMA juga memungkinkan setiap sumber mengalahkan untuk meningkatkan sumber atau alamat tujuan dengan jumlah ukuran ketukan yang tetap. <br><br>  Dua aspek ini sangat penting dan menentukan cara kita menggambar ubin. <br><br>  Pertama, jika kami membuat satu pixel per beat (16 bit), kami akan membagi dua throughput sistem kami.  Kami tidak dapat menolak bandwidth penuh! <br><br>  Namun, jika kita menggambar dua piksel per ketukan, bidang permainan akan dapat menggulir hanya sejumlah piksel, yang akan menyebabkan pergerakan halus.  Untuk menangani ini, Anda dapat menggunakan buffer yang dua atau lebih piksel lebih besar.  Saat mengirim data ke layar, kita akan menggunakan offset yang benar (0 atau 1 piksel), tergantung pada apakah kita perlu memindahkan "kamera" dengan jumlah piksel genap atau ganjil. <br><br>  Namun, demi kesederhanaan, kami menyediakan ruang untuk 11 ubin penuh (160 + 16 piksel), dan bukan untuk 160 + 2 piksel.  Pendekatan ini memiliki satu keuntungan besar: kami tidak perlu menghitung dan memperbarui alamat penerima dari setiap deskriptor DMA (ini akan membutuhkan beberapa instruksi, yang dapat menghasilkan terlalu banyak perhitungan per ubin).  Tentu saja, kami hanya akan menggambar jumlah minimum piksel, yaitu, tidak lebih dari 162. Ya, pada akhirnya, kami akan menghabiskan sedikit memori tambahan (dengan mempertimbangkan tiga buffer, ini adalah sekitar 1500 byte) untuk kecepatan dan kesederhanaan.  Anda juga dapat melakukan optimasi lebih lanjut. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/061/899/2ee/0618992eedba5d01c4d00da2aceec886.gif"></div><br>  Semua buffer blok 16-baris (tanpa deskriptor) terlihat dalam animasi GIF ini.  Di sebelah kanan adalah apa yang sebenarnya ditampilkan.  32 frame pertama ditampilkan dalam GIF, di mana kami memindahkan 1 piksel ke kanan di setiap frame.  Area hitam buffer adalah bagian yang tidak diperbarui, dan isinya tetap dari operasi sebelumnya.  Saat layar menggulirkan jumlah bingkai yang ganjil, lebar 162 piksel ditarik ke dalam buffer.  Namun, kolom pertama dan terakhir dari mereka (yang disorot dalam animasi) dibuang.  Ketika nilai gulir kelipatan 16 piksel, operasi draw dalam buffer dimulai dari kolom pertama (x = 0). <br><br>  Bagaimana dengan pengguliran vertikal? <br><br>  Kami akan menghadapinya setelah kami menunjukkan metode menyimpan ubin di memori flash. <br><br><h3>  Cara menyimpan ubin </h3><br>  Pendekatan naif (yang cocok untuk kita jika kita hanya merender melalui CPU) adalah menyimpan ubin dalam memori flash sebagai urutan warna piksel.  Pixel pertama dari baris pertama, kedua, dan seterusnya, hingga keenam belas.  Kemudian kita menyimpan piksel pertama dari baris kedua, baris kedua, dan seterusnya. <br><br>  Mengapa keputusan seperti itu naif?  Karena dalam kasus ini, DMA hanya dapat membuat 16 piksel per deskriptor DMA!  Oleh karena itu, kita memerlukan 16 deskriptor, yang masing-masing memerlukan 4 + 4 operasi akses memori (yaitu, untuk mentransfer 32 byte - 8 operasi membaca memori + 8 operasi penulisan memori - DMA harus melakukan 4 lebih banyak pembacaan + 4 penulisan).  Ini sangat tidak efisien! <br><br>  Bahkan, untuk setiap deskriptor, DMA hanya dapat menambah sumber dan alamat tujuan dengan jumlah kata yang tetap.  Setelah menyalin baris pertama ubin ke buffer, alamat penerima tidak boleh ditambah 1 kata, tetapi dengan nilai yang menunjuk ke baris buffer berikutnya.  Ini tidak mungkin karena setiap deskriptor transmisi hanya mengindikasikan kenaikan transmisi beat, yang tidak dapat diubah. <br><br>  Akan jauh lebih pintar untuk mengirim dua piksel pertama dari setiap baris ubin secara berurutan, yaitu, piksel 0 dan 1 dari garis 0, piksel 0 dan 1 dari garis 1, dll., Hingga piksel 0 dan 1 dari garis 15. Kemudian kami mengirim piksel 2 dan 3 dari garis 0, dan seterusnya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fee/f1a/2ee/feef1a2eea76233cd37000f8643f098f.png"></div><br>  <i>Bagaimana ubin disimpan?</i> <br><br>  Pada gambar di atas, setiap angka menunjukkan urutan piksel 16-bit disimpan dalam larik ubin. <br><br>  Ini dapat dilakukan dengan deskriptor, tetapi kita membutuhkan dua hal: <br><br><ul><li>  Ubin harus disimpan sehingga saat menambah sumber dengan satu kata, kami selalu menunjuk ke posisi piksel yang benar.  Dengan kata lain, jika (r, c) adalah piksel dalam baris r dan kolom c, maka kita perlu menyimpan piksel (0,0) (0,1) (1,0) (1,1) (2,0) secara berurutan (2.1) ... (15.0) (15.1) (0.2) (0.3) (1.2) (1.3) ... </li><li>  Lebar buffer harus 256 piksel (bukan 160) </li></ul><br>  Tujuan pertama sangat mudah dicapai: cukup ubah urutan data, Anda dapat melakukan ini saat mengekspor grafik ke file c (lihat gambar di atas). <br><br>  Masalah kedua dapat diselesaikan karena DMA memungkinkan Anda untuk meningkatkan alamat penerima setelah setiap ketukan dengan 512 byte.  Ini memiliki dua konsekuensi: <br><br><ul><li>  Kami tidak dapat mengirim data menggunakan deskriptor tunggal melalui blok SPI.  Ini bukan masalah yang sangat serius, karena pada akhirnya kita membaca satu deskriptor hingga 160 piksel.  Dampak kinerja akan minimal. </li><li>  Blok harus memiliki ukuran 256 * 2 * 16 byte = 8 KB, dan akan ada banyak "ruang yang tidak digunakan" di dalamnya. </li></ul><br>  Namun, ruang ini masih dapat digunakan, misalnya, untuk deskriptor. <br><br>  Faktanya, masing-masing deskriptor berukuran 16 byte.  Kami membutuhkan setidaknya 10 * 8 (dan sebenarnya 11 * 8!) Penjelas untuk ubin dan 16 penjelas untuk SPI. <br><br>  Itu sebabnya semakin banyak ubin, semakin tinggi kecepatannya.  Bahkan, jika kita menggunakan, misalnya, ubin 32 x 32, maka kita akan membutuhkan lebih sedikit deskriptor per layar (320 bukannya 640).  Ini akan mengurangi pemborosan sumber daya. <br><br><h3>  Tampilkan blok data </h3><br>  Buffer blok, deskriptor, dan data lainnya disimpan dalam tipe struktur, yang kami namakan displayBlock_t. <br><br>  displayBlock adalah array 16 elemen displayLineData_t.  Data DisplayLine mengandung 176 piksel ditambah 80 kata.  Dalam 80 kata ini, kami menyimpan deskriptor tampilan atau data tampilan bermanfaat lainnya (menggunakan gabungan). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/817/4cc/f0b/8174ccf0b746674367693a5c6bcd47a5.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a2/539/677/0a2539677818cc593c80aba690af6679.png"></div><br>  Karena kami memiliki 16 baris, setiap ubin pada posisi X menggunakan 8 DMA deskriptor pertama (0 hingga 7) dari garis X. Karena kami memiliki maksimum 11 ubin (garis tampilan adalah 176 piksel lebar), ubin hanya menggunakan deskriptor DMA pertama 11 baris data.  Deskriptor 8â€“9 dari semua baris dan deskriptor 0â€“9 dari baris 11â€“15 gratis. <br><br>  Dari jumlah tersebut, deskriptor 8 dan 9 dari baris 0..7 akan digunakan untuk SPI. <br><br>  Deskriptor 0..9 baris 11-15 (hingga 50 deskriptor, meskipun kami hanya akan menggunakan 48 di antaranya) akan digunakan untuk bidang permainan latar belakang. <br><br>  Gambar di bawah menunjukkan strukturnya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e38/017/7c0/e380177c03a9a6ca50538e438bb0552f.png"></div><br><h3>  Lapangan bermain latar belakang </h3><br>  Latar belakang bermain ditangani secara berbeda.  Pertama, jika kita membutuhkan pengguliran yang halus, maka kita harus kembali ke format dua-pixel, karena latar depan dan latar belakang akan menggulir dengan kecepatan yang berbeda.  Karena itu, beat akan setengah jalan.  Meskipun ini tidak menguntungkan dalam hal kecepatan, pendekatan ini memfasilitasi integrasi.  Kami hanya memiliki sedikit deskriptor yang tersisa, sehingga ubin kecil tidak dapat digunakan.  Selain itu, untuk menyederhanakan pekerjaan dan dengan cepat menambahkan paralaks, kita akan menggunakan "sektor" yang panjang. <br><br>  Latar belakang diambil hanya jika setidaknya ada satu piksel yang sebagian transparan.  Ini berarti bahwa jika hanya ada satu ubin transparan, latar belakang akan digambar.  Tentu saja, ini adalah pemborosan bandwidth, tetapi menyederhanakan semuanya. <br><br>  Bandingkan bidang latar belakang dan permainan depan: <br><br><ul><li>  Di latar belakang, sektor digunakan, yang ubin panjang disimpan dengan cara "naif". </li><li>  Latar belakang memiliki peta sendiri, tetapi secara horizontal berulang.  Berkat ini, lebih sedikit memori yang digunakan. </li><li>  Latar belakang memiliki paralaks untuk setiap sektor. </li></ul><br><h3>  Lapangan bermain depan </h3><br>  Seperti yang dikatakan, di setiap blok kami memiliki hingga 11 ubin (10 ubin penuh, atau 9 ubin penuh dan 2 file parsial).  Masing-masing ubin ini, jika tidak ditandai sebagai transparan, DMA ditarik.  Jika tidak sepenuhnya buram, maka ditambahkan ke daftar, yang akan dianalisis nanti, saat merender sprite. <br><br><h3>  Kami terhubung bersama dua bidang bermain </h3><br>  Deskriptor bidang bermain latar belakang (yang selalu dihitung) dan bidang bermain depan membentuk daftar yang sangat panjang.  Bagian pertama menggambar bidang bermain latar belakang.  Bagian kedua menggambar ubin di latar belakang.  Panjang bagian kedua mungkin variabel, karena deskriptor DMA dari ubin transparan sebagian dikeluarkan dari daftar.  Jika blok hanya berisi ubin buram, maka DMA dikonfigurasi sebagai berikut.  untuk memulai langsung dari deskriptor pertama dari ubin pertama. <br><br><h3>  Sprite dan ubin dengan transparansi </h3><br>  Ubin dengan transparansi dan sprite diproses hampir sama.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analisis piksel ubin / sprite dilakukan. </font><font style="vertical-align: inherit;">Jika hitam, maka transparan, dan karena itu ubin latar belakang tidak berubah. </font><font style="vertical-align: inherit;">Jika bukan hitam, maka piksel latar belakang diganti oleh piksel sprite / ubin.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pengguliran vertikal </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat bekerja dengan pengguliran horizontal, kami menggambar hingga 11 ubin, meskipun saat menggambar 11 ubin, yang pertama dan terakhir hanya sebagian digambar. </font><font style="vertical-align: inherit;">Render parsial semacam itu dimungkinkan karena fakta bahwa setiap deskriptor menggambar dua kolom ubin, sehingga kita dapat dengan mudah mengatur awal dan akhir daftar tertaut. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika bekerja dengan pengguliran vertikal, kita perlu menghitung register penerima dan volume transmisi. </font><font style="vertical-align: inherit;">Mereka harus diatur beberapa kali per frame. </font><font style="vertical-align: inherit;">Untuk menghindari kerepotan ini, kita cukup menggambar hingga 9 blok penuh per frame (8 jika scrolling merupakan kelipatan 16).</font></font><br><br><h2>  Peralatan </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti yang kami katakan, inti dari sistem ini adalah uChip. </font><font style="vertical-align: inherit;">Bagaimana dengan yang lainnya? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini adalah diagram! </font><font style="vertical-align: inherit;">Beberapa aspeknya layak disebut.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb1/b94/910/bb1b94910b94dc1289cc67f4f3e0022d.png"></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kunci </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mengoptimalkan penggunaan I / O, kami menggunakan sedikit trik. </font><font style="vertical-align: inherit;">Kami akan memiliki 4 bus sensor L1-L4, dan satu kawat LC umum. </font><font style="vertical-align: inherit;">1 dan 0 secara bergantian diterapkan pada kawat biasa. Dengan demikian, bus sensor akan secara bergantian ditarik ke bawah atau ke atas dengan bantuan resistor pull-up internal. </font><font style="vertical-align: inherit;">Dua kunci terhubung antara masing-masing bus utama dan bus umum. </font><font style="vertical-align: inherit;">Dioda dimasukkan secara seri dengan dua tombol ini. </font><font style="vertical-align: inherit;">Masing-masing dioda ini diaktifkan dalam arah yang berlawanan, sehingga setiap kali hanya satu kunci yang "dibaca".</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena tidak ada pengontrol keyboard bawaan (dan tidak ada pengontrol keyboard bawaan menggunakan metode yang menarik ini), delapan tombol dengan cepat disurvei pada awal setiap frame. Karena input harus ditarik ke atas dan ke bawah, kita tidak dapat (dan tidak ingin) menggunakan resistor eksternal, jadi kita perlu menggunakan yang terintegrasi, yang dapat memiliki resistansi yang cukup tinggi (60 kOhm). Ini berarti bahwa ketika bus umum mengubah status, dan bus data mengubah status tarik naik / turunnya, Anda harus memasukkan beberapa penundaan sehingga resistor tarik naik / turun bawaan mengubah kontrak dan mengatur kapasitansi liar ke level yang diinginkan. Tapi kami tidak mau menunggu! Oleh karena itu, kami menempatkan bus umum dalam keadaan impedansi tinggi (sehingga tidak ada perbedaan pendapat), dan pertama-tama ubah bus sensor ke nilai logis 1 atau 0,untuk sementara mengkonfigurasi mereka sebagai output. Kemudian mereka dikonfigurasi sebagai input dengan menarik ke atas atau ke bawah. Karena resistansi keluaran berada pada urutan puluhan Ohm, keadaan berubah dalam beberapa nanodetik, yaitu, ketika bus sensor beralih kembali ke input, maka sudah dalam keadaan yang diinginkan. Setelah itu, bus umum beralih ke output dengan polaritas yang berlawanan.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ini sangat meningkatkan kecepatan pemindaian dan menghilangkan kebutuhan untuk penundaan / instruksi nop. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Koneksi SPI </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menghubungkan SD dan layar sehingga mereka berkomunikasi satu sama lain tanpa mentransfer data ke ATSAMD21. </font><font style="vertical-align: inherit;">Ini bisa bermanfaat jika Anda ingin memutar video. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resistor yang menghubungkan MISO dan MOSI harus rendah. </font><font style="vertical-align: inherit;">Jika terlalu besar, maka SPI tidak akan berfungsi, karena sinyalnya akan terlalu lemah.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Optimalisasi dan pengembangan lebih lanjut </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Salah satu masalah terbesar adalah penggunaan RAM. Tiga blok menempati masing-masing 8 KB, hanya menyisakan 8 KB per tumpukan dan variabel lainnya. Saat ini, kami hanya memiliki 1,3 KB RAM gratis + 4 KB tumpukan (4 KB per tumpukan - ini banyak, mungkin kami akan menguranginya). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, Anda dapat menggunakan blok dengan ketinggian tidak 16, tetapi 8 piksel. Ini akan meningkatkan pemborosan sumber daya pada deskriptor DMA, tetapi hampir mengurangi separuh jumlah memori yang ditempati oleh buffer blok (perhatikan bahwa jumlah deskriptor tidak akan berubah jika kita terus menggunakan 16 Ã— 16 ubin, jadi kita harus mengubah struktur blok). Ini dapat membebaskan sekitar 7,5 KB RAM, yang akan sangat berguna untuk mengimplementasikan fungsi-fungsi seperti kartu yang dapat dimodifikasi dengan rahasia atau menambahkan suara (walaupun suara dapat ditambahkan bahkan dengan 1 KB RAM).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masalah lain adalah sprite, tetapi modifikasi ini lebih sederhana untuk dilakukan, dan Anda hanya perlu fungsi createNextFrameScene () untuk itu. Faktanya, kami membuat dalam RAM sebuah array yang sangat besar dengan kondisi semua sprite. Kemudian, untuk setiap sprite, kami menghitung apakah posisinya berada di area layar, dan kemudian menghidupkannya dan menambahkannya ke daftar render.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebagai gantinya, Anda dapat melakukan optimasi. Misalnya, di gameMap Anda tidak hanya dapat menyimpan nilai ubin, tetapi juga bendera yang menunjukkan transparansi ubin, yang diatur dalam editor. Ini akan memungkinkan kami untuk dengan cepat memeriksa apakah ubin harus dirender: DMA atau CPU. Itu sebabnya kami menggunakan catatan 16-bit untuk kartu ubin. Jika kita berasumsi bahwa kita memiliki satu set 256 ubin (saat ini kita memiliki kurang dari 128 ubin, tetapi ada cukup ruang pada memori flash untuk menambahkan yang baru), maka ada 7 bit gratis yang dapat digunakan untuk keperluan lain. Tiga dari tujuh bit ini dapat digunakan untuk menunjukkan apakah sprite / objek sedang disimpan.</font></font> Sebagai contoh: <br><br> <code>0b000 =    <br> 0b001 =  <br> 0b010 =  <br> 0b011 =  <br> 0b100 =  <br> 0b101 =  <br> 0b110 =  <br> 0b111 =    , ,   .</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kemudian Anda dapat membuat tabel bit dalam RAM di mana setiap bit berarti apakah (misalnya, musuh) terdeteksi / apakah (misalnya, bonus) diambil / apakah objek tertentu diaktifkan (switch). </font><font style="vertical-align: inherit;">Pada level 10 Ã— 10 layar, ini akan membutuhkan 8000 bit, mis. </font><font style="vertical-align: inherit;">RAM 1 KB. </font><font style="vertical-align: inherit;">Bit direset ketika musuh terdeteksi atau bonus diambil. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam createNextFrameScene (), kita harus memeriksa bit yang sesuai dengan ubin di area yang terlihat saat ini. </font><font style="vertical-align: inherit;">Jika mereka memiliki nilai 1:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jika ini bonus, tambahkan saja ke daftar sprite untuk rendering. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika ini adalah musuh, buat sprite dinamis dan setel ulang benderanya. </font><font style="vertical-align: inherit;">Dalam bingkai berikutnya, adegan akan berisi sprite dinamis hingga musuh meninggalkan layar atau terbunuh.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pendekatan ini memiliki kelemahan. </font></font><br><br><ol><li> -,           (       ).      . </li><li> -,       80  ,  ,    .      ,            32 .          ,   Â«/Â» (      Â«Â», ..        0!).           Â«Â»,          Â«Â» (           ). </li><li> -,      .       (    ),     .  ,      . </li><li> -,   ,   ,    ,     .     ,       ,     .          ,     ,   ,     ,   ! </li><li>     ,          (,    Unreal Tournament   ,        ). </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun demikian, dengan cara ini kita dapat menyimpan dan memproses sprite pada level yang jauh lebih efisien. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, teknik ini lebih relevan dengan "logika permainan" daripada mesin grafis dari permainan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mungkin di masa depan kita akan mengimplementasikan fungsi ini.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Untuk meringkas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami harap Anda menikmati artikel pengantar ini. </font><font style="vertical-align: inherit;">Kita perlu menjelaskan lebih banyak aspek yang akan menjadi topik artikel mendatang. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sementara itu, Anda dapat mengunduh kode sumber lengkap game! </font><font style="vertical-align: inherit;">Jika Anda suka, maka Anda dapat mendukung secara finansial artis </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ansimuz</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang menggambar semua gambar dan memberikannya kepada dunia secara gratis. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami juga menerima donasi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Game belum selesai. </font><font style="vertical-align: inherit;">Kami ingin menambahkan suara, banyak level, objek yang dapat Anda gunakan untuk berinteraksi dan sejenisnya. </font><font style="vertical-align: inherit;">Anda dapat membuat modifikasi sendiri! </font><font style="vertical-align: inherit;">Kami berharap dapat melihat game baru dengan grafik dan level baru! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami akan segera merilis editor peta, tetapi untuk saat ini terlalu sederhana untuk menunjukkannya kepada komunitas!</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Video </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Catatan: karena pencahayaan yang buruk, video direkam pada frame rate yang jauh lebih rendah! Sebentar lagi kami akan memperbarui video sehingga Anda dapat memperkirakan kecepatan penuh pada 40 fps!) </font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/1ekTeCCWKNI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Terima kasih </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grafik permainan (dan ubin yang ditunjukkan pada beberapa gambar) diambil dari </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aset gratis "Sunny Land" yang dibuat oleh ansimuz</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bahan yang bisa diunduh </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode sumber proyek adalah dalam domain publik, yaitu disediakan gratis. </font><font style="vertical-align: inherit;">Kami membagikannya dengan harapan itu akan bermanfaat bagi seseorang. </font><font style="vertical-align: inherit;">Kami tidak menjamin bahwa karena bug / kesalahan dalam kode tidak akan ada masalah! </font></font><br><br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diagram </font></font></a> <br><br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">skematik </font></font></a> <font style="vertical-align: inherit;"><a href=""><font style="vertical-align: inherit;">proyek </font></a><a href=""><font style="vertical-align: inherit;">KiCad </font></a></font><br><br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proyek Atmel Studio 7 (sumber)</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id466323/">https://habr.com/ru/post/id466323/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id466307/index.html">Bagaimana cara mendesain SCS</a></li>
<li><a href="../id466311/index.html">Lokakarya SLS 6 September</a></li>
<li><a href="../id466315/index.html">@Pythonetc kompilasi, Agustus 2019</a></li>
<li><a href="../id466317/index.html">Kiat dan trik dari saluran Telegram saya @pythonetc, Agustus 2019</a></li>
<li><a href="../id466319/index.html">Kesepakatan: VMware membeli startup berbasis cloud</a></li>
<li><a href="../id466329/index.html">Peta elektronik pembuatan anggur di Rusia. Desain dan konten</a></li>
<li><a href="../id466333/index.html">Bagaimana mengatur tempat kerja untuk Anda sendiri</a></li>
<li><a href="../id466335/index.html">Membuat Aplikasi Slack Menggunakan Fitur 8base</a></li>
<li><a href="../id466337/index.html">Apa warna fungsi Anda?</a></li>
<li><a href="../id466339/index.html">Bagaimana di Microsoft SQL Server untuk mendapatkan data dari Google Analytics menggunakan R</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>