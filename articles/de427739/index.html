<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😊 ✨ 🐦 DDD, Sechseckig, Zwiebel, Sauber, CQRS ... wie ich alles zusammenstelle 👨🏻‍✈️ 🧞 🐟</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel ist Teil der Chronik der Softwarearchitektur , einer Reihe von Artikeln zur Softwarearchitektur. In ihnen schreibe ich darüber, was ich...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>DDD, Sechseckig, Zwiebel, Sauber, CQRS ... wie ich alles zusammenstelle</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427739/"> <a href=""><img src="https://habrastorage.org/webt/mm/07/bx/mm07bx1u2dxlgab0prkzllunvf8.png"></a> <br><br>  Dieser Artikel ist Teil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Chronik der Softwarearchitektur</a> , einer Reihe von Artikeln zur Softwarearchitektur.  In ihnen schreibe ich darüber, was ich über Softwarearchitektur gelernt habe, was ich darüber denke und wie ich Wissen benutze.  Der Inhalt dieses Artikels ist möglicherweise sinnvoller, wenn Sie die vorherigen Artikel in der Reihe lesen. <br><br>  Nach meinem Universitätsabschluss begann ich als Highschool-Lehrer zu arbeiten, aber vor einigen Jahren kündigte ich und ging zu den Vollzeit-Softwareentwicklern. <br><br>  Seitdem hatte ich immer das Gefühl, dass ich die „verlorene“ Zeit wiederherstellen und so schnell wie möglich so viel wie möglich herausfinden muss.  Deshalb begann ich mich ein wenig mit Experimenten zu beschäftigen, viel zu lesen und zu schreiben, wobei ich besonders auf das Design und die Architektur der Software achtete.  Deshalb schreibe ich diese Artikel, um mir beim Studium zu helfen. <br><a name="habracut"></a><br>  In den letzten Artikeln habe ich über viele Konzepte und Prinzipien gesprochen, die ich gelernt habe, und ein wenig darüber, wie ich darüber nachdenke.  Aber ich stelle sie mir als Fragmente eines großen Puzzles vor. <br><br>  In diesem Artikel geht es darum, wie ich all diese Fragmente zusammengesetzt habe.  Ich denke, ich sollte ihnen einen Namen geben, also werde ich sie <b>explizite Architektur nennen</b> .  Darüber hinaus werden alle diese Konzepte <i>„im Kampf getestet“</i> und in der Produktion auf hochzuverlässigen Plattformen eingesetzt.  Eine davon ist eine SaaS-E-Commerce-Plattform mit Tausenden von Online-Shops auf der ganzen Welt, die andere ist eine Handelsplattform, die in zwei Ländern mit einem Nachrichtenbus betrieben wird, der mehr als 20 Millionen Nachrichten pro Monat verarbeitet. <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Grundlegende Blöcke des Systems</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Werkzeuge</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verbinden von Tools und Bereitstellungsmechanismen mit dem Anwendungskern</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ports</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Primär- oder Steueradapter</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sekundäre oder verwaltete Adapter</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kontrollinversion</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Organisation des Anwendungskerns</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anwendungsebene</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Domänenebene</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Domänendienste</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Domänenmodell</a> </li></ul></li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Komponenten</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Komponententrennung</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auslöselogik in anderen Komponenten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Daten von anderen Komponenten abrufen</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gemeinsamer Datenspeicher für Komponenten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Separate Datenspeicherung für die Komponente</a> </li></ul></li></ul></li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kontrollfluss</a> </li></ul><br><a name="1"></a><h1>  Grundlegende Blöcke des Systems </h1><br>  Beginnen wir mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abrufen der EBI-</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ports &amp; Adapter-</a> Architekturen.  Beide trennen klar den internen und externen Code der Anwendung sowie die Adapter zum Verbinden des internen und externen Codes. <br><br>  Darüber hinaus definiert die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ports &amp; Adapter-</a> Architektur explizit die drei grundlegenden Codeblöcke im System: <br><br><ul><li>  Auf diese Weise können Sie die <b>Benutzeroberfläche</b> unabhängig von ihrem Typ ausführen. </li><li>  Systemgeschäftslogik oder <b>Anwendungskern</b> .  Es wird von der Benutzeroberfläche verwendet, um echte Transaktionen durchzuführen. </li><li>  Der <b>Infrastrukturcode</b> , der den Kern unserer Anwendung mit Tools wie der Datenbank, der Suchmaschine oder APIs von Drittanbietern verbindet. </li></ul><br> <a href=""><img src="https://habrastorage.org/webt/7q/gt/h5/7qgth5e95mntgholpnrryv4zbm4.png"></a> <br><br>  Der Kern der Anwendung ist das Wichtigste, worüber man nachdenken muss.  Mit diesem Code können Sie echte Aktionen im System ausführen, dh dies ist unsere Anwendung.  Es können mehrere Benutzeroberflächen (eine progressive Webanwendung, eine mobile Anwendung, eine CLI, eine API usw.) damit arbeiten, alles läuft auf einem Kern. <br><br>  Wie Sie sich vorstellen können, geht ein typischer Ausführungsfluss vom Code in der Benutzeroberfläche über den Anwendungskern zum Infrastrukturcode zurück zum Anwendungskern und schließlich wird die Antwort an die Benutzeroberfläche gesendet. <br><br> <a href=""><img src="https://habrastorage.org/webt/vn/7q/5u/vn7q5usrs1m2ftgkfmzagymrlfw.png"></a> <br><br><a name="2"></a><h1>  Die Werkzeuge </h1><br>  Weit entfernt vom wichtigsten Kernel-Code gibt es immer noch Tools, die die Anwendung verwendet.  Zum Beispiel die Datenbankmaschine, die Suchmaschine, der Webserver und die CLI-Konsole (obwohl die beiden letzteren auch Übermittlungsmechanismen sind). <br><br> <a href=""><img src="https://habrastorage.org/webt/_o/aj/rn/_oajrnom8cuphtclxgw-m-sgars.png"></a> <br><br>  Es erscheint seltsam, die CLI-Konsole im selben Themenbereich wie das DBMS zu platzieren, da sie einen anderen Zweck hat.  Tatsächlich sind beide Tools von der Anwendung verwendet.  Der Hauptunterschied besteht darin, dass die CLI-Konsole und der Webserver <b>die Anwendung anweisen, etwas zu tun</b> . Der DBMS-Kernel <b>empfängt</b> im Gegenteil <b>Befehle von der Anwendung</b> .  Dies ist ein sehr wichtiger Unterschied, da dies einen großen Einfluss darauf hat, wie wir Code schreiben, um diese Tools mit dem Anwendungskern zu verbinden. <br><br><a name="3"></a><h1>  Verbinden von Tools und Bereitstellungsmechanismen mit dem Anwendungskern </h1><br>  Codeblöcke, die Tools mit dem Anwendungskern verbinden, werden als Adapter ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ports &amp; Adapter-Architektur</a> ) bezeichnet.  Sie ermöglichen es der Geschäftslogik, mit einem bestimmten Tool zu interagieren und umgekehrt. <br><br>  Adapter, die die Anwendung anweisen, etwas zu tun, werden als <b>Primär- oder Steueradapter bezeichnet</b> , während Adapter, die die Anwendung anweisen, etwas zu tun, als <b>sekundäre oder verwaltete Adapter bezeichnet werden</b> . <br><br><a name="4"></a><h2>  Ports </h2><br>  Diese <i>Adapter</i> werden jedoch nicht zufällig erstellt, sondern entsprechen einem bestimmten Einstiegspunkt im <i><b>Port</b></i> des Anwendungskerns.  Ein Port ist <b>nichts anderes als eine Spezifikation,</b> wie das Tool den Anwendungskern verwenden kann oder umgekehrt.  In den meisten Sprachen und in seiner einfachsten Form wird dieser Port eine Schnittstelle sein, aber tatsächlich kann er aus mehreren Schnittstellen und DTO bestehen. <br><br>  Es ist wichtig zu beachten, dass sich <b>Ports (Schnittstellen) innerhalb der Geschäftslogik</b> und Adapter außerhalb befinden.  Damit diese Vorlage ordnungsgemäß funktioniert, ist es äußerst wichtig, Ports entsprechend den Anforderungen des Anwendungskerns zu erstellen und nicht nur die Tool-APIs nachzuahmen. <br><br><a name="5"></a><h2>  Primär- oder Steueradapter </h2><br>  Primär- oder Steueradapter <b>wickeln sich um einen Port</b> und teilen dem Anwendungskern mit, was zu tun ist.  <b>Sie wandeln alle Daten aus dem Übermittlungsmechanismus in Methodenaufrufe im Anwendungskern um.</b> <br><br> <a href=""><img src="https://habrastorage.org/webt/p3/6x/rc/p36xrcnsvtfgxpmnpb2f48vtguw.png"></a> <br><br>  Mit anderen Worten, unsere Steuerungsadapter sind Controller oder Konsolenbefehle. Sie sind in ihren Konstruktor mit einem Objekt eingebettet, dessen Klasse die Schnittstelle (Port) implementiert, die ein Controller- oder Konsolenbefehl benötigt. <br><br>  In einem spezifischeren Beispiel kann der Port die Dienstschnittstelle oder die Repository-Schnittstelle sein, die der Controller benötigt.  Eine bestimmte Implementierung eines Dienstes, Repositorys oder einer Anforderung wird dann implementiert und in der Steuerung verwendet. <br><br>  Darüber hinaus kann der Port ein Befehlsbus oder eine Abfragebusschnittstelle sein.  In diesem Fall wird eine bestimmte Implementierung des Befehls- oder Anforderungsbusses in die Steuerung eingegeben, die dann einen Befehl oder eine Anforderung erstellt und an den entsprechenden Bus weiterleitet. <br><br><a name="6"></a><h2>  Sekundäre oder verwaltete Adapter </h2><br>  Im Gegensatz zu Steueradaptern, die einen Port <b>umschließen,</b> implementieren <b>verwaltete Adapter</b> einen Port und eine Schnittstelle und geben dann den Anwendungskern ein, in dem der Port benötigt wird (mit Typ). <br><br> <a href=""><img src="https://habrastorage.org/webt/rw/hz/bo/rwhzboewldt79asfbycnq9pwii0.png"></a> <br><br>  Zum Beispiel haben wir eine native Anwendung, die Daten speichern muss.  Wir erstellen eine Persistenzschnittstelle mit einer Methode zum <i>Speichern eines</i> Datenarrays und einer Methode zum <i>Löschen einer</i> Zeile in einer Tabelle anhand ihrer ID.  Von nun an benötigen wir im Konstruktor überall dort, wo die Anwendung Daten speichern oder löschen muss, ein Objekt, das die von uns definierte Persistenzschnittstelle implementiert. <br><br>  Erstellen Sie nun einen MySQL-spezifischen Adapter, der diese Schnittstelle implementiert.  Es wird Methoden zum Speichern des Arrays und zum Löschen der Zeile in der Tabelle geben, und wir werden es überall dort einführen, wo die Persistenzschnittstelle erforderlich ist. <br><br>  Wenn wir uns irgendwann dazu entschließen, den Datenbankanbieter beispielsweise auf PostgreSQL oder MongoDB zu ändern, müssen wir nur einen neuen Adapter erstellen, der die für PostgreSQL spezifische Persistenzschnittstelle implementiert, und anstelle des alten einen neuen Adapter einführen. <br><br><a name="7"></a><h2>  Kontrollinversion </h2><br>  Ein charakteristisches Merkmal dieser Vorlage ist, dass die Adapter von einem bestimmten Tool und einem bestimmten Port abhängen (durch Implementierung einer Schnittstelle).  Unsere Geschäftslogik hängt jedoch nur vom Port (Schnittstelle) ab, der den Anforderungen der Geschäftslogik entspricht und nicht von einem bestimmten Adapter oder Tool abhängt. <br><br> <a href=""><img src="https://habrastorage.org/webt/lz/8c/8m/lz8c8mla7fg4vuq9piocz1rb4ko.png"></a> <br><br>  Dies bedeutet, dass die Abhängigkeiten auf das Zentrum gerichtet sind, dh es gibt eine <b>Umkehrung des Steuerprinzips auf architektonischer Ebene</b> . <br><br>  Auch hier ist <b>es unbedingt erforderlich, dass die Ports gemäß den Anforderungen des Anwendungskerns erstellt werden und nicht nur die Tool-APIs nachahmen</b> . <br><br><a name="8"></a><h1>  Organisation des Anwendungskerns </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Onion-Architektur</a> nimmt die DDD-Schichten auf und integriert sie in die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Port- und Adapterarchitektur</a> .  Diese Ebenen sollen der Geschäftslogik, dem Inneren des „Sechsecks“ von Ports und Adaptern, Ordnung verleihen.  Nach wie vor ist die Richtung der Abhängigkeiten zur Mitte gerichtet. <br><br><a name="9"></a><h2>  Anwendungsschicht (Anwendungsschicht) </h2><br>  Anwendungsfälle sind Prozesse, die über eine oder mehrere Benutzeroberflächen im Kernel gestartet werden können.  Beispielsweise kann ein CMS eine Benutzeroberfläche für reguläre Benutzer, eine andere unabhängige Benutzeroberfläche für CMS-Administratoren, eine andere CLI und eine Web-API haben.  Diese Benutzeroberflächen (Anwendungen) können eindeutige oder häufige Anwendungsfälle auslösen. <br><br>  Anwendungsfälle werden auf Anwendungsebene definiert - der ersten Ebene von DDD und der Onion-Architektur. <br><br> <a href=""><img src="https://habrastorage.org/webt/en/x2/97/enx297n0fviyyevojd6u3y_mx3q.png"></a> <br><br>  Diese Schicht enthält Anwendungsdienste (und ihre Schnittstellen) als erstklassige Objekte sowie Port- und Adapterschnittstellen (Ports), einschließlich ORM-Schnittstellen, Suchmaschinenschnittstellen, Messaging-Schnittstellen usw. In dem Fall, in dem wir sie verwenden Der Befehlsbus und / oder der Anforderungsbus sind auf dieser Ebene die entsprechenden Befehls- und Anforderungshandler. <br><br>  Anwendungsdienste und / oder Befehlshandler enthalten die Bereitstellungslogik eines Anwendungsfalls, eines Geschäftsprozesses.  Ihre Rolle ist in der Regel wie folgt: <br><br><ol><li>  Verwenden Sie das Repository, um nach einer oder mehreren Entitäten zu suchen. </li><li>  Bitten Sie diese Entitäten, eine Domänenlogik auszuführen. </li><li>  Verwenden Sie den Speicher, um Entitäten erneut zu speichern und Datenänderungen effektiv zu speichern. </li></ol><br>  Befehlshandler können auf zwei Arten verwendet werden: <br><br><ol><li>  Sie können Logik zum Ausführen eines Anwendungsfalls enthalten. </li><li>  Sie können als einfache Teile einer Verbindung in unserer Architektur verwendet werden, die einen Befehl erhalten und einfach die im Anwendungsdienst vorhandene Logik aufrufen. </li></ol><br>  Welcher Ansatz verwendet werden soll, hängt vom Kontext ab, zum Beispiel: <br><br><ul><li>  Wir haben bereits Anwendungsdienste und jetzt wird der Befehlsbus hinzugefügt? </li><li>  Können Sie mit dem Befehlsbus eine Klasse / Methode als Handler angeben oder müssen Sie vorhandene Klassen oder Schnittstellen erweitern oder implementieren? </li></ul><br>  Diese Ebene enthält auch auslösende <b>Anwendungsereignisse</b> , die ein Ergebnis eines Anwendungsfalls darstellen.  Diese Ereignisse lösen eine Logik aus, die ein Nebeneffekt eines Anwendungsfalls ist, z. B. das Senden von E-Mails, das Benachrichtigen einer Drittanbieter-API, das Senden einer Push-Benachrichtigung oder sogar das Starten eines anderen Anwendungsfalls, der zu einer anderen Komponente der Anwendung gehört. <br><br><a name="10"></a><h2>  Domänenebene </h2><br>  Weiter innen gibt es eine Domain-Ebene.  Objekte auf dieser Ebene enthalten Daten und Logik zum Verwalten dieser Daten, die für die Domäne selbst spezifisch und unabhängig von den Geschäftsprozessen sind, die diese Logik auslösen.  Sie sind unabhängig und kennen die Anwendungsebene überhaupt nicht. <br><br> <a href=""><img src="https://habrastorage.org/webt/sm/tl/z2/smtlz2wmhuiysntbvasfqotc7zs.png"></a> <br><br><a name="11"></a><h3>  Domänendienste </h3><br>  Wie oben erwähnt, ist die Rolle des Anwendungsdienstes: <br><br><ol><li>  Verwenden Sie das Repository, um nach einer oder mehreren Entitäten zu suchen. </li><li>  Bitten Sie diese Entitäten, eine Domänenlogik auszuführen. </li><li>  Verwenden Sie den Speicher, um Entitäten erneut zu speichern und Datenänderungen effektiv zu speichern. </li></ol><br>  Manchmal stoßen wir jedoch auf eine Domänenlogik, die verschiedene Entitäten desselben oder unterschiedlichen Typs umfasst, und diese Domänenlogik gehört nicht zu den Entitäten selbst, dh die Logik liegt nicht in ihrer direkten Verantwortung. <br><br>  Daher besteht unsere erste Reaktion möglicherweise darin, diese Logik außerhalb der Entitäten im Anwendungsdienst zu platzieren.  Dies bedeutet jedoch, dass in anderen Fällen die Domänenlogik nicht wiederverwendet wird: Die Domänenlogik muss außerhalb der Anwendungsebene bleiben! <br><br>  Die Lösung besteht darin, einen Domänendienst zu erstellen, dessen Aufgabe darin besteht, eine Reihe von Entitäten abzurufen und eine Geschäftslogik darauf auszuführen.  Ein Domänendienst gehört zu einer Domänenebene und weiß daher nichts über Klassen auf Anwendungsebene, wie z. B. Anwendungsdienste oder Repositorys.  Andererseits kann es andere Domänendienste und natürlich Domänenmodellobjekte verwenden. <br><br><a name="12"></a><h3>  Domänenmodell </h3><br>  Im Zentrum steht das Domain-Modell.  Es hängt von nichts außerhalb dieses Kreises ab und enthält Geschäftsobjekte, die etwas in der Domäne darstellen.  Beispiele für solche Objekte sind in erster Linie Entitäten sowie Wertobjekte, Aufzählungen und alle im Domänenmodell verwendeten Objekte. <br><br>  Domänenereignisse werden auch im Domänenmodell gespeichert.  Wenn sich ein bestimmter Datensatz ändert, werden diese Ereignisse ausgelöst, die neue Werte der geänderten Eigenschaften enthalten.  Diese Ereignisse sind beispielsweise ideal für die Verwendung im Event-Sourcing-Modul. <br><br><a name="13"></a><h1>  Komponenten </h1><br>  Bisher haben wir Code in Schichten isoliert, aber dies ist eine zu detaillierte Code-Isolierung.  Ebenso wichtig ist es, das Bild allgemeiner zu betrachten.  Wir sprechen über die Aufteilung des Codes in Subdomänen und <i><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verwandte Kontexte</a></b></i> gemäß den Ideen von Robert Martin, die in <i><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">schreiender Architektur</a></b></i> ausgedrückt werden [das heißt, die Architektur sollte über die Anwendung selbst "schreien" und nicht darüber, welche Frameworks sie verwendet - ca.  trans.].  Sie sprechen über das Organisieren von Paketen nach Funktion oder Komponente, nicht nach Ebene, und Simon Brown hat dies in seinem Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Komponentenpakete und Testen gemäß Architektur“</a> in seinem Blog recht gut erklärt: <br><br> <a href=""><img src="https://habrastorage.org/webt/mf/n5/un/mfn5unjrsm8lmkufaoj55mfyqk0.png"></a> <br><br>  Ich bin ein Befürworter der Organisation von Komponentenpaketen und möchte das Diagramm von Simon Brown schamlos wie folgt ändern: <br><br> <a href=""><img src="https://habrastorage.org/webt/xn/ng/nd/xnngndzw3fq5rcvzvitudp-kpns.png"></a> <br><br>  Diese Abschnitte des Codes sind für alle zuvor beschriebenen Ebenen übergreifend, und dies sind die <i><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Komponenten</a></b></i> unserer Anwendung.  Beispiele für Komponenten sind Abrechnung, Benutzer, Überprüfung oder Konto, sie sind jedoch immer einer Domäne zugeordnet.  Eingeschränkte Kontexte wie Autorisierung und / oder Authentifizierung sollten als externe Tools betrachtet werden, für die wir einen Adapter erstellen und uns hinter einem Port verstecken. <br><br> <a href=""><img src="https://habrastorage.org/webt/9v/kd/ou/9vkdouyaegscibkngn0ui0ltbko.png"></a> <br><br><a name="14"></a><h2>  Komponententrennung </h2><br>  Genau wie bei feinkörnigen Codeeinheiten (Klassen, Schnittstellen, Eigenschaften, Mixins usw.) profitieren große Einheiten (Komponenten) von einer schwachen Kopplung und einer engen Konnektivität. <br><br>  Um Klassen zu trennen, verwenden wir die Abhängigkeitsinjektion, führen Abhängigkeiten in die Klasse ein, anstatt sie innerhalb der Klasse zu erstellen, und invertieren die Abhängigkeiten, wodurch die Klasse von Abstraktionen (Schnittstellen und / oder abstrakten Klassen) anstelle bestimmter Klassen abhängig wird.  Dies bedeutet, dass die abhängige Klasse nichts über die spezifische Klasse weiß, die sie verwenden wird, und keinen Verweis auf den vollständigen Namen der Klassen hat, von denen sie abhängt. <br><br>  In ähnlicher Weise weiß bei vollständig getrennten Komponenten jede Komponente nichts über eine andere Komponente.  Mit anderen Worten, es gibt keine Verknüpfung zu einem feinkörnigen Codeblock einer anderen Komponente, auch nicht zur Schnittstelle!  Dies bedeutet, dass Abhängigkeitsinjektion und Abhängigkeitsinversion nicht ausreichen, um Komponenten zu trennen. Wir benötigen eine Art Architekturkonstruktion.  Ereignisse, ein gemeinsamer Kern, eventuelle Konsistenz und sogar ein Erkennungsdienst können erforderlich sein! <br><br> <a href=""><img src="https://habrastorage.org/webt/wp/gk/2w/wpgk2wxy5fgyjtrwuzctapvv19y.png"></a> <br><br><a name="15"></a><h3>  Auslöselogik in anderen Komponenten </h3><br>  Wenn eine unserer Komponenten (Komponente B) etwas tun muss, wenn in einer anderen Komponente (Komponente A) etwas anderes passiert, können wir nicht einfach einen direkten Aufruf von Komponente A an die Klasse / Methode von Komponente B durchführen, weil dann wird A mit B verbunden. <br><br>  Wir können jedoch den Ereignismanager verwenden, um das Anwendungsereignis auszulösen, das an alle Komponenten gesendet wird, die es abhören, einschließlich B, und der Ereignis-Listener in B löst die gewünschte Aktion aus.  Dies bedeutet, dass Komponente A vom Ereignismanager abhängt, jedoch von Komponente B getrennt ist. <br><br>  Wenn das Ereignis selbst in A "lebt", bedeutet dies, dass B über die Existenz von A Bescheid weiß und damit verbunden ist.  Um diese Abhängigkeit zu beseitigen, können wir eine Bibliothek mit einer Reihe von Funktionen des Anwendungskerns erstellen, die von allen Komponenten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gemeinsam genutzt</a> werden - einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gemeinsamen Kern</a> .  Dies bedeutet, dass beide Komponenten vom gemeinsamen Kern abhängen, aber voneinander getrennt sind.  Ein gemeinsamer Kern enthält Funktionen wie Anwendungs- und Domänenereignisse, kann jedoch auch Spezifikationsobjekte und alles enthalten, was für die Freigabe sinnvoll ist.  Gleichzeitig sollte es eine Mindestgröße haben, da sich alle Änderungen im gemeinsamen Kernel auf alle Anwendungskomponenten auswirken.  Wenn wir ein polyglottes System haben, beispielsweise ein Ökosystem von Mikrodiensten in verschiedenen Sprachen, sollte der gemeinsame Kern nicht von der Sprache abhängen, damit alle Komponenten ihn verstehen.  Anstelle eines gemeinsamen Kernels mit einer Ereignisklasse enthält er beispielsweise eine Beschreibung des Ereignisses (dh einen Namen, Eigenschaften, möglicherweise sogar Methoden, obwohl sie im Spezifikationsobjekt nützlicher wären) in einer universellen Sprache wie JSON, damit alle Komponenten / Mikrodienste es interpretieren können und vielleicht sogar automatisch ihre eigenen spezifischen Implementierungen generieren. <br><br>  Dieser Ansatz funktioniert sowohl in monolithischen als auch in verteilten Anwendungen wie Mikroservice-Ökosystemen.  Wenn Ereignisse jedoch nur asynchron übermittelt werden können, reicht dieser Ansatz nicht für Kontexte aus, in denen die Triggerlogik in anderen Komponenten sofort funktionieren sollte!  Hier muss Komponente A einen direkten HTTP-Aufruf an Komponente B durchführen. In diesem Fall benötigen wir einen Erkennungsdienst, um die Komponenten zu trennen.  Komponente A fragt sie, wohin sie die Anforderung senden soll, um die gewünschte Aktion einzuleiten.  Alternativ können Sie eine Anforderung an den Erkennungsdienst senden, der diese an den entsprechenden Dienst weiterleitet und schließlich eine Antwort an den Anforderer zurückgibt.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dieser Ansatz ordnet Komponenten einem Erkennungsdienst zu, ordnet sie jedoch nicht miteinander zu. </font></font><br><br><a name="16"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Daten von anderen Komponenten abrufen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aus meiner Sicht darf die Komponente keine Daten ändern, die sie nicht „besitzt“, kann jedoch Daten anfordern und verwenden. </font></font><br><br><a name="17"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gemeinsamer Datenspeicher für Komponenten </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Komponente Daten verwenden muss, die zu einer anderen Komponente gehören (z. B. muss die Abrechnungskomponente den Namen des Kunden verwenden, der zur Kontenkomponente gehört), enthält sie das Anforderungsobjekt für den Datenspeicher. </font><font style="vertical-align: inherit;">Das heißt, die Abrechnungskomponente kann über jeden Datensatz Bescheid wissen, muss jedoch schreibgeschützte Daten aus anderen Ländern verwenden.</font></font><br><br><a name="18"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Separate Datenspeicherung für die Komponente </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Fall wird dieselbe Vorlage angewendet, die Datenspeicherebene wird jedoch komplizierter. </font><font style="vertical-align: inherit;">Das Vorhandensein von Komponenten mit einem eigenen Data Warehouse bedeutet, dass jedes Data Warehouse Folgendes enthält:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ein Datensatz, den eine Komponente besitzt und ändern kann, wodurch sie zur einzigen Quelle der Wahrheit wird. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Dataset, das eine Kopie der Daten anderer Komponenten ist, die nicht selbst geändert werden können, die jedoch für die Funktionalität der Komponente erforderlich sind. </font><font style="vertical-align: inherit;">Diese Daten sollten aktualisiert werden, wenn sie sich in der Eigentümerkomponente ändern.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jede Komponente erstellt eine lokale Kopie der benötigten Daten von anderen Komponenten, die bei Bedarf verwendet werden. </font><font style="vertical-align: inherit;">Wenn sich Daten in der Komponente ändern, zu der sie gehören, löst diese Eigentümerkomponente ein Domänenereignis aus, das Datenänderungen enthält. </font><font style="vertical-align: inherit;">Komponenten, die eine Kopie dieser Daten enthalten, hören dieses Domänenereignis ab und aktualisieren ihre lokale Kopie entsprechend.</font></font><br><br><a name="19"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kontrollfluss </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie oben erwähnt, geht der Kontrollfluss vom Benutzer zum Anwendungskern, zu den Infrastruktur-Tools und dann wieder zum Anwendungskern - und zurück zum Benutzer. </font><font style="vertical-align: inherit;">Aber wie genau arbeiten die Klassen zusammen? </font><font style="vertical-align: inherit;">Wer hängt von wem ab? </font><font style="vertical-align: inherit;">Wie komponieren wir sie? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie Onkel Bob werde ich in meinem Artikel über saubere Architektur versuchen, den Ablauf der UMLish-Schemaverwaltung zu erklären ...</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ohne Befehls- / Anforderungsbus </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir den Befehlsbus nicht verwenden, hängen die Controller entweder vom Anwendungsdienst oder vom Abfrageobjekt ab. </font></font><br><br> <sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[Nachtrag 18.11.2017] Ich habe das DTO, mit dem ich Daten aus der Anfrage zurückgebe, vollständig übersprungen und es jetzt hinzugefügt. Dank </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MorphineAdministered</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , das </font><font style="vertical-align: inherit;">ein Leerzeichen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anzeigte</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></sup> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In der obigen Abbildung verwenden wir die Schnittstelle für den Anwendungsdienst, obwohl wir sagen können, dass sie nicht wirklich benötigt wird, da der Anwendungsdienst Teil unseres Anwendungscodes ist. Wir wollen die Implementierung jedoch nicht ändern, obwohl wir ein vollständiges Refactoring durchführen können.</font></font><br> <a href=""><img src="https://habrastorage.org/webt/hg/ak/_p/hgak_pjjk5jb-5klihtccnlb7dy.png"></a> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Abfrageobjekt enthält eine optimierte Abfrage, die einfach einige Rohdaten zurückgibt, die dem Benutzer angezeigt werden. Diese Daten werden an das DTO zurückgegeben, das in das ViewModel eingebettet ist. Dieses ViewModel verfügt möglicherweise über eine Ansichtslogik und wird zum Auffüllen der Ansicht verwendet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf der anderen Seite enthält der Anwendungsdienst eine Anwendungsfalllogik, die ausgelöst wird, wenn wir etwas auf dem System tun und nicht nur einige Daten anzeigen möchten. Der Anwendungsdienst hängt von Repositorys ab, die Entitäten zurückgeben, die die zu initiierende Logik enthalten. Es kann auch vom Domänendienst abhängen, den Domänenprozess über mehrere Entitäten hinweg zu koordinieren. Dies ist jedoch ein seltener Fall.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach dem Parsen des Anwendungsfalls kann der Anwendungsdienst das gesamte System benachrichtigen, dass ein Anwendungsfall aufgetreten ist. Anschließend hängt es vom Ereignis-Dispatcher ab, das Ereignis auszulösen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist interessant festzustellen, dass wir Schnittstellen sowohl auf der Persistenz-Engine als auch auf Repositorys hosten. </font><font style="vertical-align: inherit;">Dies mag überflüssig erscheinen, dient jedoch unterschiedlichen Zwecken:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Persistenzschnittstelle ist eine Abstraktionsschicht über ORM, sodass wir ORM austauschen können, ohne den Anwendungskern zu ändern. </font></font></li><li>       persistence-. ,     MySQL  MongoDB.    persistence-    ,         ORM,       .   ,    ,      ,        ,       ,   ,    MongoDB  SQL. </li></ul><br><h2> C  / </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn unsere Anwendung den Befehls- / Anforderungsbus verwendet, bleibt das Diagramm nahezu unverändert, außer dass die Steuerung jetzt vom Bus sowie von Befehlen oder Anforderungen abhängt. Hier wird eine Instanz eines Befehls oder einer Anforderung erstellt und an den Bus übergeben, der den geeigneten Handler zum Empfangen und Verarbeiten des Befehls findet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der folgenden Abbildung verwendet der Befehlshandler den Anwendungsdienst. Dies ist jedoch nicht immer erforderlich, da der Handler in den meisten Fällen die gesamte Logik des Anwendungsfalls enthält. Alles, was wir tun müssen, ist, die Logik aus dem Handler in einen separaten Anwendungsdienst zu extrahieren, wenn wir dieselbe Logik in einem anderen Handler wiederverwenden müssen. </font></font><br><br> <sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[Nachtrag 18.11.2017] Ich habe das DTO, mit dem ich Daten aus der Anfrage zurückgebe, vollständig übersprungen und es jetzt hinzugefügt. Vielen Dank</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MorphineAdministered</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , das </font><font style="vertical-align: inherit;">ein Leerzeichen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anzeigt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font></sup> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Möglicherweise haben Sie bemerkt, dass es keine Abhängigkeiten zwischen Bus, Befehl, Anforderung und Handlern gibt. </font><font style="vertical-align: inherit;">Tatsächlich müssen sie nicht voneinander wissen, um eine gute Trennung zu gewährleisten. </font><font style="vertical-align: inherit;">Das Verfahren zum Weiterleiten des Busses an einen bestimmten Handler zum Verarbeiten eines Befehls oder einer Anforderung wird in einer einfachen Konfiguration konfiguriert. </font><font style="vertical-align: inherit;">In beiden Fällen zeigen alle Pfeile - Abhängigkeiten, die die Kernelgrenze der Anwendung überschreiten - nach innen. </font><font style="vertical-align: inherit;">Wie bereits erläutert, ist dies die Grundregel der Ports &amp; Adapter-, Zwiebel- und Clean-Architektur.</font></font><br> <a href=""><img src="https://habrastorage.org/webt/dh/vh/c1/dhvhc1qxek9af6wc2ztmfqq4m4u.png"></a> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br> <a href=""><img src="https://habrastorage.org/webt/la/3y/qs/la3yqsseqajawy91dvvrzcgzuku.png"></a> <br><br><h1>  Fazit </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wie immer besteht das Ziel darin, eine getrennte Codebasis mit hoher Konnektivität zu erhalten, in der Sie einfach, schnell und sicher Änderungen vornehmen können. </font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pläne sind nutzlos, aber Planung ist alles. </font><font style="vertical-align: inherit;">- </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eisenhower</font></font></i> </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Infografik ist eine Konzeptkarte. </font><font style="vertical-align: inherit;">Wenn Sie all diese Konzepte kennen und verstehen, können Sie eine gesunde Architektur und eine funktionsfähige Anwendung planen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Allerdings:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Karte ist kein Gebiet. </font><font style="vertical-align: inherit;">- </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alfred Korzybsky</font></font></i> </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit anderen Worten, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dies sind nur Empfehlungen! </font><font style="vertical-align: inherit;">Eine Anwendung ist ein Gebiet, eine Realität, ein spezifischer Anwendungsfall, in dem wir unser Wissen anwenden müssen, und sie bestimmt, wie die reale Architektur aussehen wird! </font></font></b> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir müssen all diese Muster verstehen, aber auch immer darüber nachdenken und verstehen, was genau unsere Anwendung benötigt und wie weit wir gehen können, um Trennung und Verbundenheit zu erreichen. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Entscheidung hängt von vielen Faktoren ab, die von den funktionalen Anforderungen des Projekts über den Zeitpunkt der Anwendungsentwicklung, die Lebensdauer, die Erfahrung des Entwicklungsteams usw. reichen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So stelle ich mir das alles vor. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Ideen werden im nächsten Artikel ausführlicher behandelt: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">„Mehr als nur konzentrische Schichten</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">“</font></a></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de427739/">https://habr.com/ru/post/de427739/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de427729/index.html">Wie konfiguriere ich die Firewall auf einem Server mit Zimbra?</a></li>
<li><a href="../de427731/index.html">Linus Torvalds ist nach der Veröffentlichung der Kernel-Version 4.19 wieder in Betrieb</a></li>
<li><a href="../de427733/index.html">Cyberpunk 2000: Deus Ex-Erstellungstools</a></li>
<li><a href="../de427735/index.html">Analyse des Spiels von Classmates bei Joker 2018</a></li>
<li><a href="../de427737/index.html">Reise in das Land der Riesen: ONYX BOOX Gulliver Review</a></li>
<li><a href="../de427741/index.html">Codegenerator für Laravel - für OAS-Eingabe, für JSON-API-Ausgabe</a></li>
<li><a href="../de427743/index.html">Witzig und seltsam: Wir haben Suchanfragen zusammengestellt, die uns gefallen</a></li>
<li><a href="../de427745/index.html">Tipps und Tricks von Kubernetes: Zugriff auf Entwickler-Websites</a></li>
<li><a href="../de427747/index.html">Wer ein unbemanntes Auto vernichten soll: Ergebnisse des Moral Machine-Experiments</a></li>
<li><a href="../de427749/index.html">Apple und Samsung haben zum ersten Mal eine Geldstrafe wegen Verlangsamung alter Telefone verhängt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>