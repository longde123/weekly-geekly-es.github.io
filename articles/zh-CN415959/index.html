<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎖️ 📫 🧠 当我们编写移动PvP射击游戏的网络代码时：客户端上的播放器同步 🤲🏻 🍮 👚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在上一篇文章中，我们回顾了新项目中使用的技术-移动设备的快速射击游戏。 现在，我想分享如何安排未来游戏的网络代码的客户端部分，我们遇到的困难以及如何解决它们。 




 通常，在过去20年中创建快速多人游戏的方法并没有太大变化。 网络代码体系结构中可以区分几种方法： 



1. 错误地计算了服务...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>当我们编写移动PvP射击游戏的网络代码时：客户端上的播放器同步</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/415959/"> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">上</a>一篇文章中，我们回顾了新项目中使用的技术-移动设备的快速射击游戏。 现在，我想分享如何安排未来游戏的网络代码的客户端部分，我们遇到的困难以及如何解决它们。 <br><br><img src="https://habrastorage.org/webt/va/gz/nl/vagznl64ylol9qhxysj5ti1akpy.jpeg"><br><a name="habracut"></a><br><br> 通常，在过去20年中创建快速多人游戏的方法并没有太大变化。 网络代码体系结构中可以区分几种方法： <br><br><ol><li> 错误地计算了服务器上的世界状态，并在客户端上显示了结果，而没有对本地玩家的预测，并且可能会丢失玩家的输入（输入）。 顺便说一下，这种方法已在我们开发中的其他项目中使用-您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>阅读有关方法。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">锁步</a> </li><li> 在没有确定性逻辑的情况下将世界状态与本地玩家的预测同步。 </li><li> 具有完全确定性逻辑的输入同步和本地播放器的预测。 </li></ol><br> 特殊之处在于，在射手中，最重要的是控制的响应能力-玩家按下按钮（或移动操纵杆），并希望立即看到其动作的结果。 首先，由于此类游戏的世界状态变化非常快，因此有必要立即对此情况做出响应。 <br><br> 因此，没有本地参与者动作（预测）的预测机制的方法不适合该项目，因此我们确定了一种在没有确定逻辑的情况下同步世界状态的方法。 <br><br>  <b>该方法的优势：</b>与交换输入时的同步方法相比，实现的复杂性更低。 <br>  <b>减：</b>将整个世界的状态发送给客户端时的流量增加。 我们必须应用几种不同的流量优化技术，才能使游戏在移动网络上稳定运行。 <br><br>  ECS是游戏架构的核心，我们已经<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">讨论过了</a> 。 这种体系结构使您可以方便地存储有关游戏世界的数据，进行序列化，复制和通过网络传输。 并且还要在客户端和服务器上执行相同的代码。 <br><br> 游戏世界的模拟以固定的每秒30滴答的频率进行。 这样您可以减少玩家输入的延迟，并且几乎不使用插值来直观地显示世界状况。 但是，在开发这样的系统时，应考虑一个重大缺陷：为了使本地玩家的预测系统正常工作，客户端必须以与服务器相同的频率模拟世界。 我们花了很多时间来针对目标设备进行足够优化的仿真。 <br><br><h2> 本地玩家动作预测机制（预测） </h2><br> 由于客户端和服务器上都执行相同的系统，因此基于ECS实施客户端预测机制。 但是，不是所有系统都在客户端上执行，而是仅由负责本地播放器且不需要其他播放器相关数据的系统执行。 <br><br> 客户端和服务器上运行的系统列表示例： <br><br><img src="https://habrastorage.org/webt/sm/jl/wc/smjlwcvyu5mv2omhgnggu9zbbnc.png"><br><br> 目前，我们在客户端上运行着大约30个提供玩家预测的系统，在服务器上运行着大约80个系统。 但是我们不会预测诸如造成伤害，使用技能或治疗盟友之类的事情。 这些机制有两个问题： <br><br><ol><li> 客户对于进入其他玩家一无所知，并且预测诸如损坏或恢复之类的事情几乎总是会与服务器上的数据产生偏差。 </li><li> 由一个玩家在本地创建新实体（射击，炮弹，独特能力）会带来与服务器上创建的实体匹配的问题。 </li></ol><br> 对于这样的技工，滞后以其他方式对玩家隐藏。 <br><br>  <i>范例：我们立即从射击中获得击中的效果，只有在收到服务器确认击中的确认后，我们才会更新敌人的生命。</i> <br><br><h2> 项目中网络代码的总体方案 </h2><br><br><img src="https://habrastorage.org/webt/so/vq/gw/sovqgwxy7gc2rxtsqedxdlkpdew.png"><br> 客户端和服务器通过刻度号同步时间。 由于网络上的数据传输会花费一些时间，因此客户端始终比服务器领先<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RTT</a> +服务器上输入缓冲区大小的一半。 上图显示了客户端发送的订单号20（a）的输入。 同时，在服务器上处理订单号15（b）。 当客户端的输入到达服务器时，刻度号20将在服务器上处理。 <br><br> 整个过程包括以下步骤：客户端将玩家的输入发送到服务器（a）→在HRTT +输入缓冲区大小（b）之后，服务器上将处理此输入→服务器将生成的世界状态发送给客户端（s）→客户端将确认的世界状态应用于服务器时间RTT +输入缓冲区大小+游戏状态插值缓冲区大小（d）。 <br><br> 客户从服务器（d）收到新的确认的世界状态后，他需要完成对帐过程。 事实是，客户仅根据本地玩家的输入进行世界预测。 他不知道其他玩家的输入。 并且在计算服务器上的世界状态时，玩家可能处于与客户端预测的状态不同的状态。 当玩家被震惊或杀死时，可能会发生这种情况。 <br><br> 批准过程包括两个部分： <br><br><ol><li> 从服务器收到的滴答N的世界预测状态的比较。 比较中仅涉及与本地播放器有关的数据。 世界其他地方的数据始终是从服务器状态获取的，并不参与协调。 </li><li> 在比较期间，可能会发生两种情况： </li></ol><br>  -如果世界的预测状态与服务器确认的状态一致，则客户端使用本地玩家的预测数据和世界其他地区的新数据，继续以正常模式模拟世界； <br>  -如果预测状态不匹配，则客户端将使用服务器的整个世界状态以及客户端输入的历史记录，并重新计算玩家世界的新预测状态。 <br><br><div class="spoiler">  <b class="spoiler_title">在代码中，它看起来像这样：</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-function">GameState </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reconcile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> currentTick, ServerGameStateData serverStateData, GameState currentState, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> playerID</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> serverState = serverStateData.GameState; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> serverTick = serverState.Time; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> predictedState = _localStateHistory.Get(serverTick); <span class="hljs-comment"><span class="hljs-comment">//if predicted state matches server last state use server predicted state with predicted player if (_gameStateComparer.IsSame(predictedState, serverState, playerID)) { _tempState.Copy(serverState); _gameStateCopier.CopyPlayerEntities(currentState, _tempState, playerID); return _localStateHistory.Put(_tempState); // replace predicted state with correct server state } //if predicted state doesn't match server state, reapply local inputs to server state var last = _localStateHistory.Put(serverState); // replace wrong predicted state with correct server state for (var i = serverTick; i &lt; currentTick; i++) { last = _prediction.Predict(last); // resimulate all wrong states } return last; }</span></span></code> </pre> <br></div></div><br> 两个世界状态的比较仅针对那些与本地玩家有关并参与预测系统的数据进行。 数据通过玩家ID进行采样。 <br><br><div class="spoiler">  <b class="spoiler_title">比较方法：</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsSame</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState s1, GameState s2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> avatarId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1 == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; s2 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> || s1 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; s2 == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1 == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; s2 == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> entity1 = s1.WorldState[avatarId]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> entity2 = s2.WorldState[avatarId]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entity1 == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; entity2 == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entity1 == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || entity2 == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1.Time != s2.Time) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1.WorldState.Transform[avatarId] != s2.WorldState.Transform[avatarId]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s1Weapon <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> s1.WorldState.Weapon) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1Weapon.Value.Owner.Id != avatarId) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s2Weapon = s2.WorldState.Weapon[s1Weapon.Key]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1Weapon.Value != s2Weapon) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s1Ammo = s1.WorldState.WeaponAmmo[s1Weapon.Key]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s2Ammo = s2.WorldState.WeaponAmmo[s1Weapon.Key]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1Ammo != s2Ammo) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s1Reload = s1.WorldState.WeaponReloading[s1Weapon.Key]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s2Reload = s2.WorldState.WeaponReloading[s1Weapon.Key]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1Reload != s2Reload) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entity1.Aiming != entity2.Aiming) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entity1.ChangeWeapon != entity2.ChangeWeapon) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br></div></div><br> 特定组件的比较运算符与整个EC结构一起生成，由代码生成器专门编写。 例如，我将给出Transform组件比较运算符的生成代码： <br><br><div class="spoiler">  <b class="spoiler_title">代号</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> ==(Transform a, Transform b) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)a == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; (<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)b == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)a == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; (<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)b != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)a != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; (<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)b == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.Abs(a.Angle - b.Angle) &gt; <span class="hljs-number"><span class="hljs-number">0.01f</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.Abs(a.Position.x - b.Position.x) &gt; <span class="hljs-number"><span class="hljs-number">0.01f</span></span> || Math.Abs(a.Position.y - b.Position.y) &gt; <span class="hljs-number"><span class="hljs-number">0.01f</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br></div></div><br> 应该注意的是，我们的浮点值与较高的误差进行了比较。 这样做是为了减少客户端和服务器之间的不同步量。 对于播放器而言，这种错误将是不可见的，但这会大大节省系统的计算资源。 <br><br> 协调机制的复杂性在于，如果客户端和服务器状态发生错误同步（错误预测），则需要重复模拟所有预测的客户端状态，直到服务器在一帧中的当前滴答声为止，这些预测的客户端状态都没有服务器的确认。 根据玩家的ping，这可能是5到20个模拟滴答声。 我们必须极大地优化仿真代码以适应时间范围：30 fps。 <br><br> 要完成批准过程，必须在客户端上存储两种类型的数据： <br><br><ol><li> 预测玩家状态的历史。 </li><li> 和历史的输入。 </li></ol><br> 为此，我们使用循环缓冲区。 缓冲区大小为32个刻度。 以30 HZ的频率提供的时间大约为1秒。 客户端可以安全地继续使用预测机制，而无需从服务器接收新数据，直到填充此缓冲区为止。 如果客户端与服务器之间的时间差开始超过一秒，则客户端将被迫断开连接并尝试重新连接。 如果世界各州之间存在差异，则由于协调过程的成本，我们会有这样的缓冲区大小。 但是，如果客户端和服务器之间的差异超过一秒，则执行到服务器的完全重新连接会更便宜。 <br><br><h2> 滞后时间减少 </h2><br> 上图显示，在游戏中，数据传输方案中有两个缓冲区： <br><br><ul><li> 服务器上的输入缓冲区； </li><li> 客户端上的世界状态缓冲区。 </li></ul><br> 这些缓冲区的目的是相同的-补偿网络跳跃（抖动）。 事实是网络上的数据包传输不均匀。 并且由于网络引擎以30 HZ的固定频率运行，因此必须以相同的频率将数据提供给引擎。 在下一个数据包到达接收者之前，我们没有机会“等待”几毫秒。 我们将缓冲区用于输入数据和世界状态，以便有时间进行抖动补偿。 如果其中一个数据包丢失，我们还可以使用gamestate缓冲区进行插值。 <br><br> 在游戏开始时，客户端只有在从服务器接收到多个世界状态并且游戏状态缓冲区已满后，才开始与服务器同步。 通常，此缓冲区的大小为3个刻度（100毫秒）。 <br><br> 同时，当客户端与服务器同步时，客户端将在服务器时间之前“运行”服务器上输入缓冲区的值。 即 客户端本身控制着它距离服务器多远。 输入缓冲区的起始大小也等于3个刻度（100毫秒）。 <br><br> 最初，我们将这些缓冲区的大小实现为常量。 即 无论抖动是否确实存在于网络上，都存在200毫秒（输入缓冲区大小+游戏状态缓冲区大小）的固定延迟来更新数据。 如果再加上200毫秒左右的移动设备上的平均估计ping，那么在客户端上使用输入与从服务器确认应用之间的实际延迟为400毫秒！ <br><br> 这不适合我们。 <br><br> 事实是，某些系统仅在服务器上运行-例如，计算玩家的HP。 在这种延迟下，玩家射击，并且只有在400毫秒之后才能看到他如何杀死对手。 如果这种情况发生在运动中，那么通常玩家会设法跑到墙后或躲进掩护中并且已经死在那里。 团队内部的游戏测试表明，这种延迟完全破坏了整个游戏过程。 <br><br> 解决此问题的方法是实现输入缓冲区和游戏状态的动态大小： <br><ul><li> 对于游戏状态缓冲区，客户端始终知道当前缓冲区的内容。 在计算下一个滴答时，客户端检查缓冲区中已经有多少个状态。 </li><li> 对于输入缓冲区-服务器除了游戏状态外，还开始向客户端发送特定客户端的输入缓冲区当前填充值。 客户端依次分析这两个值。 </li></ul><br> 游戏状态缓冲区大小调整算法大致如下： <br><br><ol><li> 客户端会考虑一段时间内缓冲区大小的平均值和方差。 </li><li> 如果方差在正常范围内（即，在给定的时间段内，缓冲区的填充和读取没有大的跳跃），则客户端会检查该时间段内平均缓冲区大小的值。 </li><li> 如果平均缓冲区填充量大于上限条件（也就是说，缓冲区填充量将超过要求的上限），则客户端将通过执行附加的模拟刻度来“减小”缓冲区的大小。 </li><li> 如果平均缓冲区填充量小于下边界条件（也就是说，在客户端开始读取缓冲区之前缓冲区没有足够的时间填充）-在这种情况下，客户端通过跳过模拟的一滴答声来“增加”缓冲区的大小。 </li><li> 在方差高于正常值的情况下，我们不能依赖这些数据，因为 给定时间段内的网络激增太大。 然后，客户端将丢弃所有当前数据，并再次开始收集统计信息。 </li></ol><br><h2> 服务器延迟补偿 </h2><br> 由于客户端会延迟（滞后）从服务器接收世界更新，因此玩家看到的世界与服务器上存在的世界有些不同。 玩家将看到自己在现在以及过去的世界中。 在服务器上，整个世界一次存在。 <br><br><img src="https://habrastorage.org/webt/jo/ca/5d/joca5d_dhigvw1i9gjlpcd-tgqa.png"><br> 因此，情况是玩家在本地射击位于另一位置服务器上的目标。 <br><br> 为了补偿延迟，我们使用服务器上的时间倒带。 操作算法大致如下： <br><br><ol><li> 具有每个输入的客户端还向服务器发送滴答时间，在滴答时间中他可以看到世界的其他地方。 </li><li> 服务器会验证此时间：是置信区间中当前时间与客户世界的可见时间之间的差。 </li><li> 如果时间有效，服务器将在当前时间离开玩家，世界其他地区会回滚到玩家看到的状态并计算射击结果。 </li><li> 如果有玩家命中，则在当前服务器时间内造成伤害。 </li></ol><br> 服务器上的倒带时间的工作方式如下：世界历史（在ECS中）和物理历史（在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Volatile Physics</a>引擎的支持下）存储在北部。 在计算射门次数时，玩家的数据取自当前的世界状况，其余的玩家则取自历史记录。 <br><br><div class="spoiler">  <b class="spoiler_title">镜头验证系统的代码如下所示：</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState gs</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shotPair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> gs.WorldState.Shot) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shot = shotPair.Value; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shooter = gs.WorldState[shotPair.Key]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shooterTransform = shooter.Transform; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> weaponStats = gs.WorldState.WeaponStats[shot.WeaponId]; <span class="hljs-comment"><span class="hljs-comment">// DeltaTime shouldn't exceed physics history size var shootDeltaTime = (int) (gs.Time - shot.ShotPlayerWorldTime); if (shootDeltaTime &gt; PhysicsWorld.HistoryLength) { continue; } // Get the world at the time of shooting. var oldState = _immutableHistory.Get(shot.ShotPlayerWorldTime); var potentialTarget = oldState.WorldState[shot.Target.Id]; var hitTargetId = _singleShotValidator.ValidateTargetAvailabilityInLine(oldState, potentialTarget, shooter, shootDeltaTime, weaponStats.ShotDistance, shooter.Transform.Angle.GetDirection()); if (hitTargetId != 0) { gs.WorldState.CreateEntity().AddDamage(gs.WorldState[hitTargetId], shooter, weaponStats.ShotDamage); } } }</span></span></code> </pre> <br></div></div><br> 该方法的一个重大缺点是，我们信任客户所看到的有关滴答声时间的数据。 潜在地，玩家可以通过人为地增加ping来获得优势。 因为 玩家的ping越多，过去的射击就越远。 <br><br><h2> 我们遇到的一些问题 </h2><br> 在实施该网络引擎的过程中，我们遇到了许多问题，其中一些问题值得单独撰写，但是在这里，我将仅涉及其中一些问题。 <br><br><h4> 在预测系统中模拟整个世界并进行复制 </h4><br> 最初，ECS中的所有系统只有一种方法：void Execute（GameState gs）。 在这种方法中，通常处理与所有玩家有关的组件。 <br><br><div class="spoiler">  <b class="spoiler_title">初始实现中的运动系统示例：</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MovementSystem</span></span> : <span class="hljs-title"><span class="hljs-title">ISystem</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState gs</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> movementPair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> gs.WorldState.Movement) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> transform = gs.WorldState.Transform[movementPair.Key]; transform.Position += movementPair.Value.Velocity * GameState.TickDuration; } } }</code> </pre> <br></div></div><br> 但是在本地玩家预测系统中，我们只需要处理与特定玩家相关的组件。 最初，我们使用copy来实现。 <br><br> 预测过程如下： <br><br><ol><li> 游戏状态的副本已创建。 </li><li> 副本已提供给ECS输入。 </li><li>  ECS中模拟了整个世界。 </li><li> 从新接收到的游戏状态复制了与本地玩家有关的所有数据。 </li></ol><br><div class="spoiler">  <b class="spoiler_title">预测方法如下所示：</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PredictNewState</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState state</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newState = _stateHistory.Get(state.Tick+<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> input = _inputHistory.Get(state.Tick); newState.Copy(state); _tempGameState.Copy(state); _ecsExecutor.Execute(_tempGameState, input); _playerEntitiesCopier.Copy(_tempGameState, newState); }</code> </pre> <br></div></div><br> 此实现中存在两个问题： <br><br><ol><li> 因为 我们使用类而不是结构-复制对于我们来说是一项昂贵的操作（在iPhone 5S上约为0.1-0.15毫秒）。 </li><li> 整个世界的模拟也要花费很多时间（在iPhone 5S上约为1.5-2毫秒）。 </li></ol><br> 如果我们考虑到在协调过程中有必要在一帧中重新计算5至15个世界状态，那么采用这种实施方式，一切都将非常缓慢。 <br><br> 解决方案非常简单：学会部分模拟世界，即仅模拟特定玩家。 我们重写了所有系统，以便您可以转移玩家的ID并仅模拟他。 <br><br><div class="spoiler">  <b class="spoiler_title">更改后的运动系统示例：</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MovementSystem</span></span> : <span class="hljs-title"><span class="hljs-title">ISystem</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState gs</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> movementPair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> gs.WorldState.Movement) { Move(gs.WorldState.Transform[movementPair.Key], movementPair.Value); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecutePlayer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState gs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> playerId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> movement = gs.WorldState.Movement[playerId]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(movement != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Move(gs.WorldState.Transform[playerId], movement); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Move</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Transform transform, Movement movement</span></span></span><span class="hljs-function">)</span></span> { transform.Position += movement.Velocity * GameState.TickDuration; } }</code> </pre> <br></div></div><br> 进行更改后，我们可以消除预测系统中不必要的副本，并减少匹配系统的负担。 <br><br><div class="spoiler">  <b class="spoiler_title">代码：</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PredictNewState</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState state, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> playerId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newState = _stateHistory.Get(state.Tick+<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> input = _inputHistory.Get(state.Tick); newState.Copy(state); _ecsExecutor.Execute(newState, input, playerId); }</code> </pre> <br></div></div><br><h4> 在预测系统中创建和删除实体 </h4><br> 在我们的系统中，服务器和客户端上的实体匹配通过整数标识符（id）进行。 对于所有实体，我们使用标识符的端到端编号，每个新实体的值都为id = oldID + 1。 <br><br> 这种方法的实现非常方便，但是它有一个明显的缺点：在客户端和服务器上创建新实体的顺序可能不同，结果，实体的标识符也会不同。 <br><br> 当我们实施一个预测球员投篮的系统时，这个问题就很明显了。 与我们一起拍摄的每个镜头都是具有镜头组成部分的单独实体。 对于每个客户，预测系统中镜头实体的ID是连续的。 但是，如果同时有其他玩家射击，则服务器上所有射击的ID与客户端不同。 <br><br> 服务器上的镜头以不同的顺序创建： <br><br><img src="https://habrastorage.org/webt/gl/dg/fy/gldgfykw7m30fuwspkra-xytgqe.png"><br><br> 对于射击，我们根据游戏的游戏功能来规避此限制。 镜头是快活的实体，在创建后一秒钟之内就会在系统中被破坏。 在客户端上，我们突出显示了一个单独的ID范围，这些ID不会与服务器ID相交，并且不再考虑协调系统中的镜头。 即 始终仅根据预测系统在游戏中绘制本地玩家的镜头，而不会考虑来自服务器的数据。 <br><br> 使用这种方法，玩家不会在屏幕上看到伪像（删除，重新创建，回滚镜头），并且与服务器的差异很小，并且不会整体上影响游戏性。 <br><br> 这种方法可以解决拍摄问题，但不能解决在客户端整体上创建实体的整个问题。 我们仍在研究可能的方法来解决客户端和服务器上已创建对象的比较。 <br><br> 还应注意，此问题仅涉及新实体（具有新ID）的创建。 在已创建的实体上添加和删除组件不会出现问题：组件没有标识符，每个实体只能有一个特定类型的组件。 因此，我们通常在服务器上创建实体，而在预测系统中，我们仅添加/删除组件。 <br><br> 总之，我想说的是，实现多人游戏的任务并不是最简单，最快的，但是有关如何执行此操作的信息很多。 <br><br><h2> 读什么 </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">快速游戏中的多人游戏</a> -翻译<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">快节奏多人游戏（第一部分）：简介</a> （在我看来，这是有关游戏中网络交互的关于Habré的最佳文章）。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GDC Vault守望先锋游戏玩法架构和Netcode-</a>与GDC 17进行的关于守望先锋中的ECS和网络代码的讲座（不幸的是，访问是付费的）。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GDC Vault：16毫秒内8帧：《真人快打》和《不公正2》中的回滚网络</a> -如何在格斗游戏中完成。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">源多人网络</a> -多人如何在《反恐精英》中工作。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Gaffer on Games</a>通常与游戏中的网络代码有关。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">游戏引擎中的UDP</a> 。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GDC保险柜：我为您提供了第一个网络联系</a> -在Halo：Reach中多人游戏的工作方式。 </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN415959/">https://habr.com/ru/post/zh-CN415959/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN415947/index.html">旋转过程中通过激光辐射进行处理的光纤安装误差补偿系统</a></li>
<li><a href="../zh-CN415949/index.html">高采矿：保护PoW区块链免受“ 51％攻击”的最新选择</a></li>
<li><a href="../zh-CN415951/index.html">Mitap Sberbank和IBM在HyperLedger Fabric上</a></li>
<li><a href="../zh-CN415953/index.html">血腥的企业如何赢得开源：BPMS之战</a></li>
<li><a href="../zh-CN415957/index.html">我们需要更多的背包：XD Design的Bobby XL</a></li>
<li><a href="../zh-CN415961/index.html">俄罗斯分布式存储。 运作方式</a></li>
<li><a href="../zh-CN415963/index.html">朴素贝叶斯，或数学如何允许您过滤垃圾邮件</a></li>
<li><a href="../zh-CN415965/index.html">7月阅读内容：针对数字专业人士的19本新书</a></li>
<li><a href="../zh-CN415967/index.html">SolidFire-用于存储**仇恨仇恨的存储</a></li>
<li><a href="../zh-CN415969/index.html">HyperX Pulsefire Surge RGB-天生的杀手er</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>