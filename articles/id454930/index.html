<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ§’ğŸ» ğŸ¤±ğŸ¼ âšœï¸ Pengumpulan sampah di V8: cara kerja Orinoco GC baru ğŸ¤·ğŸ½ âœ‹ğŸ¾ ğŸ¤½ğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sejujurnya, ini adalah salah satu artikel paling brutal yang saya baca baru-baru ini: ada banyak tentang kematian di usia muda, tentang penganiayaan d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengumpulan sampah di V8: cara kerja Orinoco GC baru</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/454930/">  Sejujurnya, ini adalah salah satu artikel paling brutal yang saya baca baru-baru ini: ada banyak tentang kematian di usia muda, tentang penganiayaan dari satu bidang memori ke bidang lain dan tentang perjuangan keras untuk produktivitas.  Secara umum, selamat datang di kat - ada terjemahan dari artikel yang bagus oleh Peter Marshall tentang cara pengumpulan sampah di V8 hari ini. <br><br><img src="https://habrastorage.org/webt/s1/vj/i4/s1vji4ia58-4d6fppntreacevai.jpeg"><a name="habracut"></a><br><br>  Selama beberapa tahun terakhir, pendekatan pengumpulan sampah di V8 telah banyak berubah.  Sebagai bagian dari proyek Orinoco, ia telah beralih dari pendekatan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">stop-the-world yang</a> konsisten ke pendekatan paralel dan kompetitif dengan penambahan mundur. <br><br>  Catatan: jika Anda lebih suka menonton laporan daripada membaca artikel, Anda bisa melakukannya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Jika tidak, baca terus. <br><br>  Setiap pengumpul sampah memiliki serangkaian tugas yang perlu dilakukan secara berkala: <br><br><ol><li>  Temukan benda hidup / mati dalam memori. <br></li><li>  Menggunakan kembali memori yang ditempati benda mati. <br></li><li>  Memori compact / defragment (opsional). <br></li></ol><br>  Tugas-tugas ini dapat dilakukan secara berurutan, atau Anda dapat bergantian.  Cara termudah adalah menghentikan eksekusi JavaScript dan melakukan semuanya secara berurutan di utas utama.  Namun, ini dapat menyebabkan penundaan, yang kita bicarakan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">posting</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebelumnya</a> , serta penurunan kinerja keseluruhan program. <br><br><h2>  GC Utama (mark-compact penuh) </h2><br>  GC utama mengumpulkan sampah dari seluruh tumpukan. <br><img src="https://habrastorage.org/webt/ap/4a/ew/ap4aewr_soaajwsy8pw7ybdn2qo.png"><br>  <i><font color="gray">Pembersihan sampah dilakukan dalam tiga tahap: pelabelan, pembuangan, dan pemadatan</font></i> <br><br><h3>  Menandai </h3><br>  Menentukan objek dari mana Anda dapat membebaskan memori adalah bagian penting dari pengumpul sampah.  Dia menganggap objek hidup berdasarkan informasi tentang jangkauannya.  Ini berarti bahwa setiap objek yang dirujuk dari runtime saat ini harus disimpan dalam memori, dan semua objek yang tidak dapat diakses dapat dirakit oleh GC. <br><br>  Menandai adalah proses menemukan objek yang dapat dijangkau.  GC memiliki satu set pointer yang mulai dicari, yang disebut root set.  Set ini mencakup objek dari tumpukan eksekusi saat ini dan objek global.  Dimulai dengan set ini, GC mengikuti setiap penunjuk ke objek JavaScript dan menandai masing-masing sebagai dapat dijangkau, setelah itu bergerak ke penunjuk dari objek ke objek lain dan mengulangi proses ini secara berulang hingga setiap objek yang dapat dijangkau ditandai. <br><br><h3>  Pembuangan </h3><br>  Pembuangan adalah proses di mana area memori yang tersisa dari benda mati dimasukkan ke dalam daftar yang disebut daftar bebas.  Setelah proses penandaan selesai, GC menemukan area tersebut dan menambahkannya ke daftar yang sesuai.  Daftar bebas berbeda satu sama lain dalam ukuran memori yang disimpan di dalamnya, yang memungkinkan Anda untuk dengan cepat menemukan yang tepat.  Selanjutnya, ketika kita ingin mengalokasikan memori, kita akan melihat di salah satu daftar dan menemukan bagian dengan ukuran yang sesuai. <br><br><h3>  Seal </h3><br>  Juga, GC utama terkadang membuat keputusan tentang pembersihan / pemadatan beberapa halaman memori berdasarkan perkiraan heuristiknya sendiri berdasarkan tingkat fragmentasi halaman.  Anda dapat menganggap pemadatan sebagai analog defragmentasi hard drive pada PC lama.  Kami menyalin objek yang masih hidup ke halaman lain yang belum dikompres (di sini hanya menggunakan daftar gratis).  Dengan demikian kita dapat menggunakan kembali potongan-potongan kecil memori yang tersebar yang tersisa dari benda mati. <br><br>  Salah satu kelemahan dari GC yang menyalin objek yang masih hidup adalah bahwa ketika Anda membuat banyak objek berumur panjang, Anda harus membayar harga tinggi untuk menyalinnya.  Karena alasan ini, hanya beberapa halaman memori yang sangat terfragmentasi yang dikompres, sedangkan sisanya dibuang, yang tidak memerlukan penyalinan benda yang masih hidup. <br><br><h3>  Perangkat pembangkit memori </h3><br>  Tumpukan di V8 dipecah menjadi daerah yang disebut generasi.  Ada generasi muda (yang pada gilirannya dibagi menjadi generasi "palungan" dan "menengah") dan generasi tua.  Objek yang dibuat ditempatkan di "palungan".  Selanjutnya, jika mereka selamat dari pengumpulan sampah berikutnya, mereka tetap berada di generasi yang lebih muda, tetapi masuk ke dalam kategori "perantara".  Jika mereka bertahan hidup setelah kebaktian berikutnya, mereka ditempatkan di generasi yang lebih tua. <br><img src="https://habrastorage.org/webt/bl/jl/qc/bljlqc2s8amymre3zunoc1lgngi.png"><br>  <i><font color="gray">Sekelompok V8 dipecah menjadi beberapa generasi.</font></i>  <i><font color="gray">Benda bergerak dari muda ke tua jika mereka selamat dari pengumpulan sampah</font></i> <br><br>  Dalam pengumpulan sampah, ada istilah penting "hipotesis generasi".  Secara sederhana, ini berarti bahwa sebagian besar benda "mati muda."  Dengan kata lain, sebagian besar objek dibuat dan mati segera dari sudut pandang GC.  Dan pernyataan ini berlaku tidak hanya untuk JavaScript, tetapi untuk sebagian besar bahasa pemrograman dinamis. <br><br>  Organisasi tumpukan di V8 didasarkan pada hipotesis di atas.  Sebagai contoh, pada pandangan pertama, mungkin tampak berlawanan dengan intuisi bahwa GC memadatkan / memindahkan objek yang selamat dari pengumpulan sampah, karena menyalin objek adalah operasi yang cukup mahal untuk dilakukan selama pengumpulan sampah.  Tetapi, berdasarkan hipotesis generasi, kita tahu bahwa sangat sedikit objek yang akan selamat dari prosedur ini.  Jadi, jika Anda hanya memindahkan objek yang masih hidup, semua yang tidak dipindahkan dapat secara otomatis dianggap sampah.  Ini berarti bahwa harga yang kami bayar untuk penyalinan sebanding dengan jumlah objek yang bertahan, dan tidak semua dibuat. <br><br><h2>  Auxiliary GC (pemulung) </h2><br>  Sebenarnya ada dua pemulung di V8.  Main (mark-compact) mengumpulkan sampah dengan cukup efisien dari seluruh tumpukan, sedangkan yang kedua mengumpulkan sampah hanya dalam memori yang masih muda, karena hipotesis generasi memberi tahu kita bahwa upaya pengumpulan sampah utama harus diarahkan ke sana. <br><br>  Prinsip pengoperasian GC bantu adalah bahwa objek yang bertahan selalu pindah ke halaman memori baru.  Dalam V8, memori muda dibagi menjadi dua bagian.  Seseorang selalu bebas untuk membiarkan benda yang masih hidup dipindahkan ke dalamnya, dan selama perakitan, daerah yang awalnya kosong ini disebut To-space.  Area tempat penyalinan disebut Dari-ruang.  Dalam kasus terburuk, setiap objek dapat bertahan, dan kemudian Anda harus menyalinnya semua. <br><br>  Untuk jenis perakitan ini, ada satu set pointer terpisah yang merujuk dari memori lama ke muda.  Dan alih-alih memindai seluruh tumpukan, kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penghalang tulis</a> untuk mempertahankan set ini.  Jadi, menggabungkan set ini dengan tumpukan dan objek global, kami mendapatkan semua tautan di memori muda tanpa harus memindai semua objek dari memori lama. <br><br>  Saat menyalin objek dari Dari ruang ke Ke ruang, semua objek yang bertahan hidup ditempatkan di bagian memori yang berkelanjutan.  Dengan demikian, adalah mungkin untuk menghilangkan fragmentasi - celah memori yang tersisa dari benda mati.  Setelah transfer selesai, Ke-ruang menjadi Dari-ruang, dan sebaliknya.  Segera setelah GC menyelesaikan tugasnya, memori untuk objek baru akan dialokasikan mulai dari alamat bebas pertama di Dari-ruang. <br><img src="https://habrastorage.org/webt/jt/yl/43/jtyl43bxlb-u7n8cgp3spapeksm.png"><br>  <i><font color="gray">Pemulung memindahkan objek yang masih hidup ke halaman memori baru</font></i> <i><br></i> <br>  Jika Anda hanya menggunakan strategi ini dan tidak memindahkan objek dari memori muda, maka memori akan berakhir dengan cepat.  Oleh karena itu, objek yang selamat dari dua koleksi sampah dipindahkan ke memori lama. <br><br>  Langkah terakhir adalah memperbarui pointer ke objek yang telah dipindahkan.  Setiap objek yang disalin meninggalkan alamat aslinya, meninggalkan alamat penerusan, yang diperlukan untuk menemukan objek asli di masa depan. <br><img src="https://habrastorage.org/webt/ld/kv/oo/ldkvoorwihux9nfklfxk2p3fbos.png"><br>  <i><font color="gray">Pemulung mentransfer objek "perantara" ke memori lama, dan objek dari "palungan" - ke halaman baru</font></i> <br><br>  Dengan demikian, pengumpulan sampah di memori muda terdiri dari tiga langkah: menandai objek, menyalinnya, memperbarui pointer. <br><br><h2>  Orinoco </h2><br>  Sebagian besar algoritma ini dijelaskan dalam berbagai sumber dan sering digunakan dalam lingkungan runtime yang mendukung pengumpulan sampah otomatis.  Tetapi GC di V8 telah datang jauh sebelum menjadi alat yang benar-benar modern.  Salah satu metrik signifikan yang menggambarkan kinerjanya adalah seberapa sering dan berapa lama utas utama berhenti sementara pengumpul sampah menjalankan fungsinya.  Untuk pembuat stop-the-world klasik, kali ini meninggalkan bekas pada pengalaman menggunakan halaman karena keterlambatan, kualitas rendering yang buruk dan peningkatan waktu respons. <br><img src="https://habrastorage.org/webt/za/ct/gv/zactgvbniosnjhuqfmuvbeazggs.png"><br>  <i><font color="gray">Logo Orinoco GC V8</font></i> <br><br>  Orinoco adalah nama kode GC yang menggunakan teknik pengumpulan sampah paralel, inkremental, dan kompetitif yang canggih.  Ada beberapa istilah yang memiliki makna khusus dalam konteks GC, jadi mari kita memberikan definisi mereka terlebih dahulu. <br><br><h3>  Paralelisme </h3><br>  Paralelisme adalah ketika utas utama dan tambahan melakukan kira-kira jumlah pekerjaan yang sama per unit waktu.  Ini masih merupakan pendekatan stop-the-world, tetapi durasi jeda dalam kasus ini dibagi dengan jumlah utas yang berpartisipasi dalam pekerjaan (dikurangi biaya sinkronisasi). <br><br>  Ini adalah yang paling sederhana dari tiga teknik.  Tumpukan tidak berubah karena JavaScript tidak dijalankan, sehingga cukup untuk utas mempertahankan sinkronisasi akses ke objek. <br><img src="https://habrastorage.org/webt/1s/1z/sl/1s1zsldqhz08kn8nciao0dooadi.png"><br>  <i><font color="gray">Utas utama dan tambahan bekerja pada tugas yang sama pada saat yang sama</font></i> <br><br><h3>  Inkrementalitas </h3><br>  Inkrementalitas adalah ketika utas utama melakukan sejumlah kecil pekerjaan sebentar-sebentar.  Alih-alih pengumpulan sampah lengkap, tugas-tugas kecil untuk pengumpulan parsial dilakukan. <br><br>  Ini adalah tugas yang lebih sulit, karena JavaScript berjalan di antara rakitan tambahan, yang berarti bahwa heap state berubah, yang pada gilirannya dapat membatalkan sebagian pekerjaan yang dilakukan pada iterasi sebelumnya. <br><br>  Seperti dapat dilihat dari diagram, pendekatan ini tidak mengurangi jumlah total pekerjaan (dan, sebagai aturan, bahkan meningkatkannya), tetapi mendistribusikan pekerjaan ini tepat waktu.  Oleh karena itu, ini adalah cara yang baik untuk menyelesaikan salah satu tugas utama - mengurangi waktu respons arus utama. <br>  Dengan membiarkan JavaScript berjalan dengan sedikit gangguan dalam pengumpulan sampah, aplikasi dapat terus menjadi responsif: menanggapi input pengguna dan memperbarui animasi. <br><img src="https://habrastorage.org/webt/mc/yi/t7/mcyit7ystjkd8iddxxfj8zqhruw.png"><br>  <i><font color="gray">Area kecil GC berfungsi di utas utama</font></i> <br><br><h3>  Daya saing </h3><br>  Persaingan adalah ketika utas utama menjalankan JavaScript terus menerus dan utas tambahan mengumpulkan sampah di latar belakang.  Ini adalah yang paling sulit dari tiga teknik: heap dapat berubah kapan saja, membatalkan pekerjaan yang dilakukan oleh GC sebelumnya. <br><br>  Selain itu, ada juga balapan baca / tulis, karena aliran bantu dan utama secara bersamaan membaca atau memodifikasi objek yang sama. <br><img src="https://habrastorage.org/webt/bm/uh/9y/bmuh9y_1linhkt6v4rthj1xky3g.png"><br>  <i><font color="gray">Perakitan berlangsung sepenuhnya di latar belakang, utas utama saat ini dapat menjalankan JavaScript</font></i> <br><br><h2>  Status GC di V8 </h2><br><h3>  Memulung </h3><br>  V8 mendistribusikan pekerjaan pengumpulan sampah di antara thread tambahan di memori muda (scavenging).  Setiap utas menerima satu set petunjuk, yang mengikuti itu memindahkan semua objek hidup ke ruang. <br><br>  Saat memindahkan objek ke ruang, utas perlu disinkronkan melalui operasi baca / tulis / bandingkan atom untuk menghindari situasi di mana, misalnya, utas lain telah mendeteksi objek yang sama, tetapi mengikuti jalur yang berbeda, dan juga mencoba untuk memindahkannya. <br><br>  Thread yang memindahkan objek ke To-space kemudian kembali dan meninggalkan pointer penerusan sehingga utas lain yang menemukan objek ini dapat mengikuti alamat yang benar.  Untuk alokasi memori yang cepat dan bebas sinkronisasi untuk objek yang bertahan, utas menggunakan buffer lokal utas. <br><img src="https://habrastorage.org/webt/jy/hj/cf/jyhjcfoy8qok8juwfddy6cczslu.png"><br>  <i><font color="gray">Perakitan paralel mendistribusikan kerja antara beberapa utas bantu dan utas utama</font></i> <br><br><h3>  Core gc </h3><br>  GC utama di V8 dimulai dengan menandai objek.  Segera setelah tumpukan mencapai batas tertentu (dihitung secara dinamis), penanda kompetitif memulai pekerjaan mereka.  Setiap aliran menerima satu set petunjuk, dan, mengikuti mereka, mereka menandai setiap objek yang ditemukan dapat dijangkau. <br><br>  Pelabelan kompetitif terjadi sepenuhnya di latar belakang saat JavaScript berjalan di utas utama.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hambatan tulis</a> digunakan untuk melacak tautan baru antara objek yang dibuat dalam JavaScript saat utas menandai. <br><br><img src="https://habrastorage.org/webt/er/bi/-l/erbi-lduzw0biseu7gysr416fuq.png"><br>  <i><font color="gray">GC Utama menggunakan pelabelan kompetitif, pembuangan, dan pemadatan paralel dan pembaruan pointer</font></i> <br><br>  Pada akhir pelabelan kompetitif, utas utama melakukan langkah cepat untuk mengakhiri pelabelan.  Selama ini, eksekusi JavaScript di utas utama dijeda. <br><br>  Set root dipindai lagi untuk memastikan bahwa semua objek hidup ditandai, dan kemudian kompresi memori dan pembaruan pointer dimulai pada beberapa utas. <br>  Tidak semua halaman di memori lama dipadatkan - mereka yang tidak akan dipindai ke area memori yang dibebaskan (sweeping) untuk daftar mereka dalam daftar bebas. <br><br>  Selama jeda ini, tugas sweeping mulai, yang bekerja secara kompetitif dengan tugas-tugas kompresi memori dan utas utama dan dapat berlanjut bahkan ketika JavaScript dijalankan di utas utama. <br><br><h2>  GC waktu idle </h2><br>  Pengembang JavaScript tidak memiliki akses ke GC - ini adalah bagian dari lingkungan implementasi.  Dan meskipun kode JS tidak dapat menggunakan GC secara langsung, V8 menyediakan akses ke lingkungan yang menyematkan engine. <br><br>  GC dapat mengirim tugas (tugas idle) yang dapat dilakukan "di waktu luang Anda" dan yang merupakan bagian dari pekerjaan yang harus tetap dilakukan.  Lingkungan seperti Chrome, tempat mesin tertanam, mungkin memiliki gagasan tentang apa yang harus dipertimbangkan sebagai waktu luang.  Misalnya, di Chrome, pada kecepatan bingkai 60 frame per detik, browser memiliki sekitar 16,6 ms untuk membuat bingkai animasi. <br><br>  Jika pekerjaan animasi selesai lebih awal, di waktu luang Anda, sebelum frame berikutnya, Chrome dapat melakukan beberapa tugas yang diterima dari GC. <br><img src="https://habrastorage.org/webt/la/-i/bi/la-ibisn9rw6ulv6djzufbu-tt0.png"><br>  <i><font color="gray">GC menggunakan waktu bebas aliran utama untuk melakukan pra-pembersihan</font></i> <br><br>  Detail dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">publikasi kami di Idle-time GC</a> . <br><br><h2>  Ringkasan </h2><br>  GC di V8 telah berkembang jauh sejak diperkenalkan.  Menambahkan teknik paralel, inkremental, dan kompetitif memerlukan waktu beberapa tahun, tetapi terbayar, memungkinkan Anda untuk melakukan sebagian besar pekerjaan di latar belakang. <br><br>  Semua yang terkait dengan jeda dari aliran utama, waktu respons, dan pemuatan halaman telah meningkat secara signifikan, yang memungkinkan membuat animasi, pengguliran, dan interaksi pengguna pada halaman menjadi lebih lancar.  Kolektor paralel memungkinkan untuk mengurangi waktu pemrosesan total memori muda sebesar 20-50%, tergantung pada beban. <br><br>  Idle-time GC mengurangi ukuran tumpukan yang digunakan untuk Gmail sebesar 45%.  Pelabelan dan pembuangan kompetitif (sweeping) dapat mengurangi durasi jeda GC di game WebGL yang berat hingga 50%. <br><br>  Namun, pekerjaannya belum selesai.  Mengurangi jeda tetap merupakan tugas penting untuk menyederhanakan kehidupan pengguna web, dan kami sedang mencari kemungkinan menggunakan teknik yang lebih maju untuk mencapai tujuan. <br><br>  Selain itu, Blink (renderer di Chrome) juga dilengkapi dengan pelumas, dan kami sedang berupaya meningkatkan interaksi antara kedua GC, serta menggunakan teknik Orinoco di Oilpan. <br><br>  Sebagian besar pengembang JavaScript tidak perlu memikirkan cara kerja GC, tetapi beberapa pemahaman tentang hal ini dapat membantu Anda membuat keputusan terbaik terkait penggunaan memori dan pola pemrograman.  Sebagai contoh, mengingat struktur generasi dari tumpukan V8, objek yang hidup rendah sebenarnya cukup murah dari sudut pandang GC, karena kami membayar terutama untuk objek yang selamat.  Dan pola-pola semacam ini bukan hanya karakteristik JavaScript, tetapi juga banyak bahasa dengan dukungan untuk pengumpulan sampah. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id454930/">https://habr.com/ru/post/id454930/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id454920/index.html">Kinerja Ujung Depan: Parsing Metrik Penting</a></li>
<li><a href="../id454922/index.html">Kisah tentang pelanggan asing dan fitur-fitur mereka bekerja di Rusia setelah UU PD</a></li>
<li><a href="../id454924/index.html">Pengaturan Otentikasi di Veeam Backup untuk Microsoft Office 365 v3</a></li>
<li><a href="../id454926/index.html">Semua yang Anda ketahui tentang word2vec tidak benar</a></li>
<li><a href="../id454928/index.html">Cara untuk Memintas Layar Kunci Windows pada Sesi RDP</a></li>
<li><a href="../id454936/index.html">Vivaldi: Pemblokiran iklan harus menjadi pilihan pengguna</a></li>
<li><a href="../id454938/index.html">Pengembangan intinya sendiri untuk ditanamkan dalam sistem prosesor berbasis FPGA</a></li>
<li><a href="../id454940/index.html">Asuransi kesehatan perjalanan: petunjuk terperinci</a></li>
<li><a href="../id454944/index.html">Cara kerja format JPEG</a></li>
<li><a href="../id454946/index.html">Negara global: mengapa dan bagaimana cara menghindarinya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>