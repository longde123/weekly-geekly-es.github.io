<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👷🏼 🎍 🌓 使用寄存器进行类型安全的工作，而在C ++ 17中没有开销：基于值的元编程 💪🏼 🧑🏾‍🤝‍🧑🏼 👨🏾‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="C ++由于其严格的类型输入，可以在编译阶段为程序员提供帮助。 该中心上已经有很多文章描述了如何使用类型来实现此目标，这很好。 但是我所读的书都有一个缺陷。 与微控制器编程领域中熟悉的++方法和使用CMSIS的C方法进行比较： 


some_stream.set (Direction::to_pe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用寄存器进行类型安全的工作，而在C ++ 17中没有开销：基于值的元编程</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483378/"><p>  C ++由于其严格的类型输入，可以在编译阶段为程序员提供帮助。 该中心上已经有很多文章描述了如何使用类型来实现此目标，这很好。 但是我所读的书都有一个缺陷。 与微控制器编程领域中熟悉的++方法和使用CMSIS的C方法进行比较： </p><br><pre><code class="cpp hljs">some_stream.<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> (Direction::to_periph) SOME_STREAM-&gt;CR |= DMA_SxCR_DIR_0 .inc_memory() | DMA_SxCR_MINC_Msk .size_memory (DataSize::word16) | DMA_SxCR_MSIZE_0 .size_periph (DataSize::word16) | DMA_SxCR_PSIZE_0 .enable_transfer_complete_interrupt(); | DMA_SxCR_TCIE_Msk;</code> </pre> <br><p> 显而易见，C ++方法更具可读性，并且由于每个函数都具有一种特定的类型，因此不会出错。  C语言方法不检查数据的有效性，而是由程序员负责。 通常，仅在调试期间才识别错误。 但是c ++方法不是免费的。 实际上，每个函数都有自己的寄存器访问权限，而在C语言中，由于这些都是常量，因此在编译阶段首先从所有参数中收集掩码，然后将其立即写入寄存器。 接下来，我将描述如何在最小化案例访问的情况下将类型安全性与++相结合。 您会发现它比听起来简单得多。 </p><a name="habracut"></a><br><p> 首先，我将举例说明我的外观。 希望这与已经熟悉的C ++方法没有太大区别。 </p><br><pre> <code class="cpp hljs">some_stream.<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>( dma_stream::direction::to_periph , dma_stream::inc_memory , dma_stream::memory_size::byte16 , dma_stream::periph_size::byte16 , dma_stream::transfer_complete_interrupt::enable );</code> </pre> <br><p>  set方法中的每个参数都是单独的类型，您可以通过该类型了解要在哪个寄存器中写入该值，这意味着在编译过程中可以优化对寄存器的访问。 该方法是可变参数的，因此可以有任意数量的参数，但是必须检查所有参数都属于该外围设备。 </p><br><p> 早些时候，对于我来说，这项任务似乎相当复杂，直到我<a href="https://youtu.be/ZUmc45Njs9U" rel="nofollow">观看了有关基于价值的元编程的视频</a> 。 通过这种元编程方法，您可以像编写普通代码一样编写通用算法。 在本文中，我将仅提供解决问题的最必要视频，其中有更多通用的算法。 </p><br><p> 我将以抽象方式解决此问题，而不是针对特定外围设备。 因此，有几个寄存器字段，我将有条件地将它们写为枚举。 </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enum1</span></span></span><span class="hljs-class"> {</span></span> _0, _1, _2, _3 }; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enum2</span></span></span><span class="hljs-class"> {</span></span> _0, _1, _2, _3 }; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enum3</span></span></span><span class="hljs-class"> {</span></span> _0, _1, _2, _3, _4 }; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enum4</span></span></span><span class="hljs-class"> {</span></span> _0, _1, _2, _3 };</code> </pre> <br><p> 前三个与一个外围有关，第四个与另一个外围有关。 因此，如果将第四枚举的值输入到第一外围的方法中，则应该存在编译错误，最好是可以理解的。 同样，前2个列表将与一个寄存器相关，第三个列表与另一个相关。 </p><br><p> 由于枚举的值除实际值外不存储任何内容，因此需要另外一种类型，该类型将存储例如掩码，以确定将该枚举写入寄存器的哪一部分。 </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enum1_traits</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> mask = <span class="hljs-number"><span class="hljs-number">0b00111</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enum2_traits</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> mask = <span class="hljs-number"><span class="hljs-number">0b11000</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enum3_traits</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> mask = <span class="hljs-number"><span class="hljs-number">0b00111</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enum4_traits</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> mask = <span class="hljs-number"><span class="hljs-number">0b00111</span></span>; };</code> </pre> <br><p> 仍然可以连接这两种类型。 在这里，该<a href="https://en.cppreference.com/w/cpp/types/type_identity" rel="nofollow">芯片已经对20种标准</a>有用，但它是微不足道的，您可以自己实现。 </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_identity</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = T; }; <span class="hljs-comment"><span class="hljs-comment">//    constexpr auto some_type = type_identity&lt;Some_type&gt;{}; //      using some_type_t = typename decltype(some_type)::type; #define TYPE(type_identity) typename decltype(type_identity)::type</span></span></code> </pre> <br><p> 最重要的是，您可以使用任何类型的值并将其作为参数传递给函数。 这是基于值的元编程方法的主要组成部分，在这种方法中，您应该尝试将类型信息传递给值，而不是作为模板参数。 在这里，我定义了一个宏，但是在c ++中我是它们的对手。 但是他允许进一步写作。 接下来，我将为一个函数和另一个宏提供链接枚举及其属性，该宏可以减少复制粘贴的数量。 </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">traits</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(type_identity&lt;Enum1&gt;)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type_identity&lt;Enum1_traits&gt;{}; } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAKE_TRAITS_WITH_MASK(enum, mask_) struct enum##_traits { \ static constexpr std::size_t mask = mask_; \ }; \ constexpr auto traits(type_identity</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;enum&gt;) { \ return type_identity&lt;enum##_traits&gt;{}; \ }</span></span></span></span></code> </pre> <br><p> 必须将字段与相应的寄存器关联。 我通过继承选择关系，因为该标准已经具有元函数<code>std::is_base_of</code> ，它将允许您以通用形式定义字段与寄存器之间的关系。 您不能从枚举继承，因此我们从其属性继承。 </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Register1</span></span></span><span class="hljs-class"> :</span></span> Enum1_traits, Enum2_traits { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> offset = <span class="hljs-number"><span class="hljs-number">0x0</span></span>; };</code> </pre> <br><p> 寄存器所在的地址存储为从外围开始的偏移量。 </p><br><p> 在描述外围之前，有必要讨论基于值的元编程中的类型列表。 这是一个相当简单的结构，允许您保存几种类型并按值传递它们。 有点像<code>type_identity</code> ，但是有一些类型。 </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ts</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_pack</span></span></span><span class="hljs-class">{</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> empty_pack = type_pack&lt;&gt;;</code> </pre> <br><p> 您可以为此列表实现许多constexpr函数。 与著名的Alexandrescu类型列表（Loki库）相比，它们的实现更容易理解。 以下是示例。 </p><br><p> 外设的第二个重要属性应该是将其定位在特定地址（在微控制器中）并动态传递该地址以进行测试的能力。 因此，外围设备的结构将是样板，并且将在值字段中存储外围设备的特定地址的类型作为参数。  template参数将由构造函数确定。 好了，前面提到的set方法。 </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Address</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Periph1</span></span></span><span class="hljs-class"> {</span></span> Periph1(Address) {} <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> registers = type_pack&lt;Register1, Register2&gt;{}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ts</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">set</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ts</span></span></span><span class="hljs-class">...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class">) {</span></span> ::<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(registers, Address::value, args...); } };</code> </pre> <br><p>  set方法所做的全部工作就是调用一个自由函数，并向其中传递通用算法所需的所有信息。 </p><br><p> 我将举例说明为外围设备提供地址的类型。 </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    struct Address { static constexpr std::size_t value = SOME_PERIPH_BASE; }; //    ,    struct Address { static inline std::size_t value; template&lt;class Pointer&gt; Address(Pointer address) { value = reinterpret_cast&lt;std::size_t&gt;(address); } };</span></span></code> </pre> <br><p> 准备了通用算法的所有信息，仍要执行。 我将给出此功能的文字。 </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Registers</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Args</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">set</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_pack</span></span></span><span class="hljs-class">&lt;Registers...&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">registers</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> address, Args...args) { <span class="hljs-comment"><span class="hljs-comment">//       ,  value based  constexpr auto args_traits = make_type_pack(traits(type_identity&lt;Args&gt;{})...); //              static_assert(all_of(args_traits, [](auto arg){ return (std::is_base_of_v&lt;TYPE(arg), Registers&gt; || ...); }), "one of arguments in set method don`t belong to periph type"); //   ,      constexpr auto registers_for_write = filter(registers, [](auto reg){ return any_of(args_traits, [](auto arg){ //       o  reg? return std::is_base_of_v&lt;TYPE(arg), TYPE(reg)&gt;; }); }); //           foreach(registers_for_write, [=](auto reg){ auto value = register_value(reg, args...); auto offset = decltype(reg)::type::offset; write(address + offset, value); }); };</span></span></code> </pre> <br><p> 实现将参数（特定的寄存器字段）转换为<code>type_pack</code>函数非常简单。 让我提醒您，模板类型列表的省略号显示了用逗号分隔的类型列表。 </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ts</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">make_type_pack</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_identity</span></span></span><span class="hljs-class">&lt;Ts&gt;...) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type_pack&lt;Ts...&gt;{}; }</code> </pre> <br><p> 为了验证所有参数都与传输的寄存器有关，并因此与特定的外设有关，有必要实现all_of算法。 与标准库类似，该算法接收类型列表和谓词函数作为输入。 我们使用lambda作为函数。 </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ts</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">all_of</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_pack</span></span></span><span class="hljs-class">&lt;Ts...&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (f(type_identity&lt;Ts&gt;{}) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ...); }</code> </pre> <br><p> 在这里，第一次使用<a href="https://ru.cppreference.com/w/cpp/language/fold" rel="nofollow">17标准</a>的<a href="https://ru.cppreference.com/w/cpp/language/fold" rel="nofollow">扫描表达式</a> 。 正是这种创新极大地简化了喜欢元编程的人们的生活。 在此示例中，函数f应用于列表Ts中的每个类型，将其转换为<code>type_identity</code> ，并且每个调用的结果由I收集。 </p><br><p> 在<code>static_assert</code>内部，将应用此算法。 包装在<code>type_identity</code>中的<code>type_identity</code>传递给lambda。 在lambda内部，使用了标准的元函数std :: is_base_of，但是由于可以有多个寄存器，因此将根据OR逻辑使用扫描表达式对每个寄存器执行该表达式。 结果，如果至少有一个参数的属性对于至少一个寄存器不是基本的，则<code>static assert</code>将起作用并显示一条明确的错误消息。 很容易理解错误的出处（将错误的参数传递给<code>set</code>方法）并进行修复。 </p><br><p> 稍后将需要的<code>any_of</code>算法的实现非常相似： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ts</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">any_of</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_pack</span></span></span><span class="hljs-class">&lt;Ts...&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (f(type_identity&lt;Ts&gt;{}) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> ...); }</code> </pre> <br><p> 通用算法的下一个任务是确定需要写入哪些寄存器。 为此，请过滤寄存器的初始列表，并仅保留函数中包含参数的那些寄存器。 我们需要一个<code>filter</code>算法，该算法采用原始的<code>type_pack</code> ，对列表中的每种类型应用谓词函数，如果谓词返回true，则将其添加到新列表中。 </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ts</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">filter</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_pack</span></span></span><span class="hljs-class">&lt;Ts...&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> filter_one = [](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> v, <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> f) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> T = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(v)::type; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f(v))</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">return</span></span></span><span class="hljs-function"> type_pack&lt;T&gt;</span></span>{}; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> empty_pack{}; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (empty_pack{} + ... + filter_one(type_identity&lt;Ts&gt;{}, f)); }</code> </pre> <br><p> 首先，描述了一个lambda，该lambda在一种类型上执行谓词的功能，如果谓词返回true，则返回<code>type_pack</code>如果谓词返回<code>false</code>则返回空的<code>type_pack</code> 。 最后一个优点的另一个新功能在这里有帮助-constexpr if。 其实质是在结果代码中只有一个if分支，第二个抛出。 而且由于不同的类型在不同的分支中返回，如果没有constexpr，将出现编译错误。 再次感谢<code>type_pack</code>表达式，对列表中每种类型执行此lambda的结果被合并为一个结果<code>type_pack</code> 。  <code>type_pack</code>的加法运算符没有足够的重载。 它的实现也很简单： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ts</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Us</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class">+ (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_pack</span></span></span><span class="hljs-class">&lt;Ts...&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_pack</span></span></span><span class="hljs-class">&lt;Us...&gt;) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type_pack&lt;Ts..., Us...&gt;{}; }</code> </pre> <br><p> 将新算法应用于寄存器列表时，新列表仅保留那些应写入传输参数的寄存器。 </p><br><p> 下一个需要的算法是<code>foreach</code> 。 它只是将一个函数应用于列表中的每种类型，将其包装在<code>type_identity</code> 。 在此，扫描表达式中使用了逗号运算符，该运算符执行逗号描述的所有动作并返回上一个动作的结果。 </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ts</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foreach</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_pack</span></span></span><span class="hljs-class">&lt;Ts...&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">) {</span></span> (f(type_identity&lt;Ts&gt;{}), ...); }</code> </pre> <br><p> 该功能使您可以访问要写入的每个寄存器。  lambda计算要写入寄存器的值，确定要写入的地址，然后直接写入寄存器。 </p><br><p> 为了计算一个寄存器的值，需要计算该寄存器所属的每个自变量的值，然后将结果通过“或”进行组合。 </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Register</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Args</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> register_value(type_identity&lt;Register&gt; reg, Args...args) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (arg_value(reg, args) | ...); }</code> </pre> <br><p> 只能为继承该寄存器的参数执行特定字段值的计算。 对于自变量，我们从其属性中提取掩码，并确定寄存器中值与掩码之间的偏移量。 </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Register</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arg</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> arg_value(type_identity&lt;Register&gt;, Arg arg) { <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> arg_traits = traits(type_identity&lt;Arg&gt;{}); <span class="hljs-comment"><span class="hljs-comment">//   ,     if constexpr (not std::is_base_of_v&lt;TYPE(arg_traits), Register&gt;) return 0; constexpr auto mask = decltype(arg_traits)::type::mask; constexpr auto arg_shift = shift(mask); return static_cast&lt;std::size_t&gt;(arg) &lt;&lt; arg_shift; }</span></span></code> </pre> <br><p> 您可以自己编写用于确定遮罩偏移的算法，但是我使用了现有的内置函数。 </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shift</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mask)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> __builtin_ffs(mask) - <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><p> 保留将值写入特定地址的最后一个函数。 </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> address, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ *<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>*&gt;(address) |= v; }</code> </pre> <br><p> 为了测试任务，编写了一个小测试： </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ,    volatile std::size_t arr[3]; int main() { //     ( ) //   ,         auto address = Address{arr}; auto mock_periph = Periph1{address}; //  1      //  3       3 //  4      //     0b00011001 (25) //    0b00000100 (4) mock_periph.set(Enum1::_1, Enum2::_3, Enum3::_4); // all ok // mock_periph.set(Enum4::_0); // must be compilation error }</span></span></code> </pre> <br><p> 这里所写的一切都被组合在一起并<a href="https://godbolt.org/z/9KTJLN" rel="nofollow">编成了螺栓</a> 。 那里的任何人都可以尝试这种方法。 可以看到目标已实现：没有不必要的内存访问。 在编译阶段计算需要写入寄存器的值： </p><br><pre> <code class="cpp hljs">main: mov QWORD PTR Address::value[rip], OFFSET FLAT:arr <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> QWORD PTR arr[rip], <span class="hljs-number"><span class="hljs-number">25</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> QWORD PTR arr[rip+<span class="hljs-number"><span class="hljs-number">8</span></span>], <span class="hljs-number"><span class="hljs-number">4</span></span> mov eax, <span class="hljs-number"><span class="hljs-number">0</span></span> ret</code> </pre> <br><hr><br><p>  PS： <br> 感谢大家的评论，感谢他们，我对方法进行了一些修改。 您可以在<a href="https://godbolt.org/z/d6xt_A" rel="nofollow">此处</a>看到新选项<a href="https://godbolt.org/z/d6xt_A" rel="nofollow">。</a> </p><br><ul><li> 删除辅助类型* _traits，可以直接在列表中保存掩码。 <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enum1</span></span></span><span class="hljs-class"> {</span></span> _0, _1, _2, _3, mask = <span class="hljs-number"><span class="hljs-number">0b00111</span></span> };</code> </pre> </li><li> 现在不通过继承进行带有参数的寄存器连接，因为它是一个静态寄存器字段 <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> params = type_pack&lt;Enum1, Enum2&gt;{};</code> </pre> </li><li> 由于连接不再通过继承进行，因此我不得不编写contains函数： <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ts</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">contains</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_pack</span></span></span><span class="hljs-class">&lt;Ts...&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_identity</span></span></span><span class="hljs-class">&lt;T&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">v</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((type_identity&lt;Ts&gt;{} == v) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> ...); }</code> </pre> </li><li> 没有多余的类型，所有宏都消失了 </li><li> 我通过模板参数将参数传递给方法，以在constexpr上下文中使用它们 </li><li> 现在在set方法中，constexpr逻辑与记录本身的逻辑明显分开 <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>...args&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> values_for_write = extract(registers, args...); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [value, offset] : values_for_write) { write(Address::value + offset, value); } }</code> </pre> </li><li> 提取函数在constexpr中分配一个值数组，以写入寄存器。 它的实现与先前的set函数非常相似，不同之处在于它不直接写入寄存器。 </li><li> 我必须添加另一个根据lambda函数将type_pack转换为数组的元函数。 <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ts</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">to_array</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_pack</span></span></span><span class="hljs-class">&lt;Ts...&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pack</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>{f(type_identity&lt;Ts&gt;{})...}; }</code> </pre> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN483378/">https://habr.com/ru/post/zh-CN483378/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN483366/index.html">互联网历史记录：网络</a></li>
<li><a href="../zh-CN483368/index.html">为Linux创建x86_64 ELF文件打包器</a></li>
<li><a href="../zh-CN483372/index.html">如何使用GPU在笔记本电脑上训练DeepPavlov神经网络</a></li>
<li><a href="../zh-CN483374/index.html">REST API建议-Java和Spring中的Web服务设计示例</a></li>
<li><a href="../zh-CN483376/index.html">在黑洞的表面</a></li>
<li><a href="../zh-CN483380/index.html">微服务：如何遵守合同</a></li>
<li><a href="../zh-CN483382/index.html">卡利Linux 2020.1</a></li>
<li><a href="../zh-CN483384/index.html">我们最经常误以为是IT词典的哪些英语单词</a></li>
<li><a href="../zh-CN483386/index.html">银河系即将来临的银河碰撞已经孕育了新星</a></li>
<li><a href="../zh-CN483388/index.html">我的女朋友和第一个电子游戏。 统一开发。 第二部分</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>