<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëäüèæ üëµüèΩ üöö Tipos dependentes de Haskell: por que o futuro do desenvolvimento de software üôâ üëè üë©üèΩ‚Äç‚öñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Na Serokell, n√£o estamos apenas envolvidos em projetos comerciais, mas tamb√©m nos esfor√ßamos para mudar o mundo para melhor. Por exemplo, estamos trab...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tipos dependentes de Haskell: por que o futuro do desenvolvimento de software</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485174/"><p><img src="https://habrastorage.org/getpro/habr/post_images/fce/995/232/fce99523266b5bc548c3d1730c70b885.jpg"></p><br><p> Na Serokell, n√£o estamos apenas envolvidos em projetos comerciais, mas tamb√©m nos esfor√ßamos para mudar o mundo para melhor.  Por exemplo, estamos trabalhando para melhorar a principal ferramenta de todos os haskelistas - o Glasgow Haskell Compiler (GHC).  Nosso foco foi expandir o sistema de tipos sob a influ√™ncia do trabalho de Richard Eisenberg, <a href="https://github.com/goldfirere/thesis/blob/master/built/thesis.pdf" rel="nofollow">"Tipos Dependentes em Haskell: Teoria e Pr√°tica"</a> . </p><br><p>  Em <a href="https://serokell.io/blog/why-dependent-haskell" rel="nofollow">nosso blog,</a> Vladislav j√° falou sobre o porqu√™ de Haskell n√£o ter tipos dependentes e como planejamos adicion√°-los.  Decidimos traduzir este post para o russo para que o maior n√∫mero poss√≠vel de desenvolvedores pudesse usar tipos dependentes e dar uma contribui√ß√£o adicional ao desenvolvimento do Haskell como idioma. </p><a name="habracut"></a><br><h1 id="tekuschee-polozhenie-del">  Situa√ß√£o atual </h1><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6d3/260/bba/6d3260bbad59d047ba6f10b1fffd5383.jpg" alt="Algoritmo de sele√ß√£o de linguagem de programa√ß√£o"></p><br><p>  Tipos dependentes s√£o o que mais sinto falta em Haskell.  Vamos discutir o porqu√™.  Do c√≥digo que queremos: </p><br><ul><li>  desempenho, ou seja, velocidade de execu√ß√£o e baixo consumo de mem√≥ria; </li><li>  manutenibilidade e facilidade de entendimento; </li><li>  corre√ß√£o garantida pelo m√©todo de compila√ß√£o. </li></ul><br><p>  Com as tecnologias existentes, raramente √© poss√≠vel atingir as tr√™s caracter√≠sticas, mas com suporte para os tipos dependentes de Haskell, a tarefa √© simplificada. </p><br><h2 id="standartnyy-haskell-ergonomika--proizvoditelnost">  Padr√£o Haskell: Ergonomia + Desempenho </h2><br><p>  Haskell √© baseado em um sistema simples: um c√°lculo lambda polim√≥rfico com c√°lculos pregui√ßosos, tipos de dados alg√©bricos e classes de tipos.  √â essa combina√ß√£o de recursos de linguagem que nos permite escrever um c√≥digo elegante, suportado e ao mesmo tempo produtivo.  Para fundamentar essa afirma√ß√£o, comparamos brevemente o Haskell com os idiomas mais populares. </p><br><p>  Idiomas com acesso inseguro √† mem√≥ria, como C, levam a erros e vulnerabilidades mais graves (por exemplo, estouros de buffer, vazamentos de mem√≥ria).  √Äs vezes, essas linguagens s√£o necess√°rias, mas na maioria das vezes o uso delas √© uma id√©ia mais ou menos. </p><br><p>  Os idiomas de acesso seguro √† mem√≥ria formam dois grupos: aqueles que dependem do coletor de lixo e Rust.  A ferrugem parece ser √∫nica ao oferecer <a href="https://pcwalton.github.io/2013/05/20/safe-manual-memory-management.html" rel="nofollow">acesso seguro √† mem√≥ria sem coleta de lixo</a> .  Tamb√©m n√£o h√° mais suporte ao Cyclone e outras linguagens de pesquisa neste grupo.  Mas, diferentemente deles, o Rust est√° a caminho da popularidade.  A desvantagem √© que, apesar da seguran√ßa, o gerenciamento de mem√≥ria do Rust n√£o √© trivial e manual.  Em aplicativos que podem permitir o uso do coletor de lixo, √© melhor gastar o tempo dos desenvolvedores em outras tarefas. </p><br><p>  Existem idiomas restantes nos coletores de lixo, que ser√£o divididos em duas categorias com base no sistema de tipos. </p><br><p>  Linguagens dinamicamente tipadas (ou melhor, <a href="https://existentialtype.wordpress.com/2011/03/19/dynamic-languages-are-static-languages/" rel="nofollow">monotipadas</a> ), como JavaScript ou Clojure, n√£o fornecem an√°lise est√°tica e, portanto, n√£o podem fornecer o mesmo n√≠vel de confian√ßa na corre√ß√£o do c√≥digo (e n√£o, os testes n√£o podem substituir os tipos - voc√™ precisa de ambos) !). </p><br><p>  Linguagens de tipo est√°tico, como Java ou Go, geralmente t√™m um sistema de tipo muito limitado.  Isso for√ßa os programadores a escrever c√≥digo redundante e colocar recursos de linguagem inseguros.  Por exemplo, a falta de tipos gen√©ricos no Go for√ßa o uso da <a href="https://tour.golang.org/methods/14" rel="nofollow">interface {}</a> e a <a href="https://golang.org/ref/spec" rel="nofollow">convers√£o de tipos de tempo de execu√ß√£o</a> .  Tamb√©m n√£o h√° separa√ß√£o entre c√°lculos com efeitos colaterais (entrada, sa√≠da) e c√°lculos puros. </p><br><p>  Por fim, entre os idiomas com acesso seguro √† mem√≥ria, um coletor de lixo e um poderoso sistema de tipos, Haskell se destaca pela pregui√ßa.  <a href="https://augustss.blogspot.com/2011/05/more-points-for-lazy-evaluation-in.html" rel="nofollow">A computa√ß√£o pregui√ßosa √©</a> extremamente √∫til para escrever c√≥digo modular e compost√°vel.  Eles possibilitam decompor em defini√ß√µes auxiliares qualquer parte das express√µes, incluindo constru√ß√µes que definem um fluxo de controle. </p><br><p>  Haskell parece ser uma linguagem quase perfeita at√© voc√™ perceber at√© que ponto est√° liberando todo o seu potencial em termos de verifica√ß√£o est√°tica em compara√ß√£o com ferramentas de prova de teoremas, como a <a href="https://agda.readthedocs.io/en/latest/" rel="nofollow">Agda</a> . </p><br><p> Como um exemplo simples de onde o sistema do tipo Haskell n√£o √© poderoso o suficiente, considere o operador de <a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html" rel="nofollow">indexa√ß√£o de lista</a> da <code>Prelude</code> (ou a <a href="http://hackage.haskell.org/package/primitive-0.6.4.0/docs/Data-Primitive-Array.html" rel="nofollow">indexa√ß√£o de uma matriz</a> de um pacote <code>primitive</code> ): </p><br><pre> <code class="haskell hljs">(!!) :: [a] -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; a indexArray :: <span class="hljs-type"><span class="hljs-type">Array</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; a</code> </pre> <br><p>  Nada nessas assinaturas de tipo reflete o requisito de que o √≠ndice seja n√£o negativo e menor que o comprimento da cole√ß√£o.  Para software com requisitos de alta confiabilidade, isso √© inaceit√°vel. </p><br><h2 id="agda-ergonomika--korrektnost">  Agda: ergonomia + corre√ß√£o </h2><br><p>  Os meios de prova de teoremas (por exemplo, <a href="https://coq.inria.fr/" rel="nofollow">Coq</a> ) s√£o ferramentas de software que permitem o uso de um computador para desenvolver provas formais de teoremas matem√°ticos.  Para um matem√°tico, usar essas ferramentas √© como escrever evid√™ncias no papel.  A diferen√ßa no rigor sem precedentes exigido por um computador para estabelecer a validade de tais evid√™ncias. </p><br><p>  Para o programador, no entanto, os meios de provar os teoremas n√£o s√£o t√£o diferentes do compilador para a linguagem de programa√ß√£o esot√©rica com um sistema de tipos incr√≠vel (e possivelmente um ambiente de desenvolvimento integrado) e tudo med√≠ocre (ou at√© ausente).  Um meio de provar teoremas √©, de fato, linguagens de programa√ß√£o, cujos autores passaram o tempo todo desenvolvendo um sistema de digita√ß√£o e esqueceram que os programas ainda precisam ser executados. </p><br><p>  O sonho acalentado de desenvolvedores de software verificados √© um meio de provar teoremas, o que seria uma boa linguagem de programa√ß√£o com gerador de c√≥digo e tempo de execu√ß√£o de alta qualidade.  Nesta dire√ß√£o, incluindo os criadores de <a href="https://www.idris-lang.org/" rel="nofollow">Idris</a> experimentaram.  Mas essa √© uma linguagem com c√°lculos rigorosos (energ√©ticos) e sua implementa√ß√£o no momento n√£o √© est√°vel. </p><br><p>  Entre todos os meios de provar os teoremas, os Agda Haskellists s√£o os que mais gostam.  De muitas maneiras, √© semelhante ao Haskell, mas com um sistema de tipos mais poderoso.  N√≥s da Serokell o usamos para provar as v√°rias propriedades de nossos programas.  Minha colega Dania Rogozin escreveu uma <a href="https://serokell.io/blog/2018/11/14/logical-background" rel="nofollow">s√©rie de artigos</a> sobre isso. </p><br><p>  Aqui est√° um tipo de fun√ß√£o de <a href="" rel="nofollow">pesquisa</a> semelhante ao operador Haskell <code>(!!)</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">lookup</span></span> : ‚àÄ (xs : <span class="hljs-type"><span class="hljs-type">List</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span>) ‚Üí <span class="hljs-type"><span class="hljs-type">Fin</span></span> (length xs) ‚Üí <span class="hljs-type"><span class="hljs-type">A</span></span></code> </pre> <br><p>  O primeiro par√¢metro aqui √© do tipo <code>List A</code> , que corresponde a <code>[a]</code> em Haskell.  No entanto, <code>xs</code> o nome <code>xs</code> para fazer refer√™ncia ao restante da assinatura de tipo.  Em Haskell, podemos acessar argumentos da fun√ß√£o apenas no corpo da fun√ß√£o no n√≠vel do termo: </p><br><pre> <code class="haskell hljs">(!!) :: [a] -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; a <span class="hljs-comment"><span class="hljs-comment">--   xs  (!!) = \xs i -&gt; ... --   xs </span></span></code> </pre> <br><p>  Mas no Agda, podemos nos referir a esse valor <code>xs</code> no n√≠vel de tipo, o que fazemos no segundo par√¢metro de <code>lookup</code> , <code>Fin (length xs)</code> .  Uma fun√ß√£o que se refere ao seu par√¢metro no n√≠vel de tipo √© chamada de <em>fun√ß√£o dependente</em> e √© um exemplo de tipos dependentes. </p><br><p>  O segundo par√¢metro na <code>lookup</code> √© do tipo <code>Fin n</code> para <code>n ~ length xs</code> .  Um valor do tipo <code>Fin n</code> corresponde a um n√∫mero no intervalo <code>[0, n)</code> ; portanto, <code>Fin (length xs)</code> √© um n√∫mero n√£o negativo menor que o comprimento da lista de entrada.  √â exatamente isso que precisamos para apresentar um √≠ndice v√°lido de um item da lista.  Grosso modo, a <code>lookup ["x","y","z"] 2</code> passar√° na verifica√ß√£o de tipo, mas a <code>lookup ["x","y","z"] 42</code> falhar√°. </p><br><p>  Quando se trata de executar programas Agda, podemos compil√°-los no Haskell usando o <a href="http://wiki.portal.chalmers.se/agda/pmwiki.php%3Fn%3DDocs.MAlonzo" rel="nofollow">back-end</a> do MAlonzo.  Mas o desempenho do c√≥digo gerado ser√° insatisfat√≥rio.  Isso n√£o √© culpa de MAlonzo: ele precisa inserir numerosos <code>unsafeCoerce</code> para que o GHC <code>unsafeCoerce</code> c√≥digo j√° verificado pela Agda.  Mas o mesmo <code>unsafeCoerce</code> <a href="https://dspace.library.uu.nl/bitstream/handle/1874/357868/3800296.pdf" rel="nofollow">reduz o desempenho</a> <em>(ap√≥s a discuss√£o deste artigo, constatou-se que problemas de desempenho podem ter sido causados ‚Äã‚Äãpor outros motivos - nota do autor)</em> . </p><br><p>  Isso nos coloca em uma posi√ß√£o dif√≠cil: precisamos usar o Agda para modelagem e verifica√ß√£o formal e, em seguida, reimplementar a mesma funcionalidade no Haskell.  Com essa organiza√ß√£o de fluxos de trabalho, nosso c√≥digo Agda atua como uma especifica√ß√£o verificada por computador.  Isso √© melhor do que a especifica√ß√£o em linguagem natural, mas longe do ideal.  O objetivo √© que, se o c√≥digo for compilado, ele funcionar√° de acordo com a especifica√ß√£o. </p><br><h2 id="haskell-s-rasshireniyami-korrektnost--proizvoditelnost">  Haskell com extens√µes: corre√ß√£o + desempenho </h2><br><p><img src="https://habrastorage.org/getpro/habr/post_images/954/0e8/735/9540e8735ab539e67787046735ee5789.jpg"></p><br><p>  Visando garantias est√°ticas de idiomas com tipos dependentes, o GHC percorreu um longo caminho.  Foram adicionadas extens√µes para aumentar a expressividade do sistema de tipos.  Comecei a usar o Haskell quando o GHC 7.4 era a vers√£o mais recente do compilador.  Mesmo assim, ele tinha as principais extens√µes para programa√ß√£o avan√ßada em n√≠vel de tipo: <code>RankNTypes</code> , <code>GADTs</code> , <code>TypeFamilies</code> , <code>DataKinds</code> e <code>PolyKinds</code> . </p><br><p>  No entanto, ainda n√£o existem tipos dependentes completos em Haskell: nem fun√ß√µes dependentes (tipos)) nem pares dependentes (tipos Œ£).  Por outro lado, pelo menos temos uma codifica√ß√£o para eles! </p><br><p>  As pr√°ticas atuais s√£o as seguintes: </p><br><ul><li>  codificar fun√ß√µes no n√≠vel de tipo como fam√≠lias de tipos particulares, </li><li>  use a funcionaliza√ß√£o para habilitar fun√ß√µes n√£o saturadas, </li><li>  colmatar a lacuna entre termos e tipos usando tipos √∫nicos. </li></ul><br><p>  Isso leva a uma quantidade significativa de c√≥digo redundante, mas a biblioteca de <code>singletons</code> automatiza sua gera√ß√£o atrav√©s do Template Haskell. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/003/56f/e2a/00356fe2af43f034df850dbb556fb82f.jpg"></p><br><p>  Portanto, o mais ousado e decisivo pode codificar tipos dependentes no Haskell agora.  Como demonstra√ß√£o, aqui est√° uma implementa√ß√£o da fun√ß√£o de <code>lookup</code> semelhante √† variante no Agda: </p><br><pre> <code class="haskell hljs"><span class="hljs-meta"><span class="hljs-meta">{-# OPTIONS -Wall -Wno-unticked-promoted-constructors -Wno-missing-signatures #-}</span></span> <span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE LambdaCase, DataKinds, PolyKinds, TypeFamilies, GADTs, ScopedTypeVariables, EmptyCase, UndecidableInstances, TypeSynonymInstances, FlexibleInstances, TypeApplications, TemplateHaskell #-}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> ListLookup <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Singletons.TH <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Singletons.Prelude singletons [d| data N = Z | SN len :: [a] -&gt; N len [] = Z len (<span class="hljs-title"><span class="hljs-title">_</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) = S (<span class="hljs-title"><span class="hljs-title">len</span></span> <span class="hljs-title"><span class="hljs-title">xs</span></span>) |] data Fin n where FZ :: Fin (<span class="hljs-type"><span class="hljs-type">S</span></span> <span class="hljs-title"><span class="hljs-title">n</span></span>) FS :: Fin n -&gt; Fin (<span class="hljs-type"><span class="hljs-type">S</span></span> <span class="hljs-title"><span class="hljs-title">n</span></span>) lookupS :: SingKind a =&gt; SList (<span class="hljs-title"><span class="hljs-title">xs</span></span> :: [<span class="hljs-title"><span class="hljs-title">a</span></span>]) -&gt; Fin (<span class="hljs-type"><span class="hljs-type">Len</span></span> <span class="hljs-title"><span class="hljs-title">xs</span></span>) -&gt; Demote a lookupS SNil = \case{} lookupS (<span class="hljs-type"><span class="hljs-type">SCons</span></span> <span class="hljs-title"><span class="hljs-title">x</span></span> <span class="hljs-title"><span class="hljs-title">xs</span></span>) = \case FZ -&gt; fromSing x FS i' -&gt; lookupS xs i'</code> </pre> <br><p>  E aqui est√° uma sess√£o do GHCi mostrando que as pesquisas de fato rejeitam √≠ndices muito grandes: </p><br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">GHCi</span></span>, version <span class="hljs-number"><span class="hljs-number">8.6</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span>: http://www.haskell.org/ghc/ :? for help [<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-type"><span class="hljs-type">Compiling</span></span> <span class="hljs-type"><span class="hljs-type">ListLookup</span></span> ( <span class="hljs-type"><span class="hljs-type">ListLookup</span></span>.hs, interpreted ) <span class="hljs-type"><span class="hljs-type">Ok</span></span>, one <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> loaded. *ListLookup&gt; :set -XTypeApplications -XDataKinds *ListLookup&gt; lookupS (<span class="hljs-title"><span class="hljs-title">sing</span></span> @["<span class="hljs-title"><span class="hljs-title">x</span></span>", "<span class="hljs-title"><span class="hljs-title">y</span></span>", "<span class="hljs-title"><span class="hljs-title">z</span></span>"]) FZ "x" *ListLookup&gt; lookupS (<span class="hljs-title"><span class="hljs-title">sing</span></span> @["<span class="hljs-title"><span class="hljs-title">x</span></span>", "<span class="hljs-title"><span class="hljs-title">y</span></span>", "<span class="hljs-title"><span class="hljs-title">z</span></span>"]) (<span class="hljs-type"><span class="hljs-type">FS</span></span> <span class="hljs-type"><span class="hljs-type">FZ</span></span>) "y" *ListLookup&gt; lookupS (<span class="hljs-title"><span class="hljs-title">sing</span></span> @["<span class="hljs-title"><span class="hljs-title">x</span></span>", "<span class="hljs-title"><span class="hljs-title">y</span></span>", "<span class="hljs-title"><span class="hljs-title">z</span></span>"]) (<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> <span class="hljs-type"><span class="hljs-type">FZ</span></span>)) "z" *ListLookup&gt; lookupS (<span class="hljs-title"><span class="hljs-title">sing</span></span> @["<span class="hljs-title"><span class="hljs-title">x</span></span>", "<span class="hljs-title"><span class="hljs-title">y</span></span>", "<span class="hljs-title"><span class="hljs-title">z</span></span>"]) (<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> <span class="hljs-type"><span class="hljs-type">FZ</span></span>))) &lt;interactive&gt;:5:34: error: ‚Ä¢ Couldn't match type ''S n0' with ''Z' Expected type: Fin (<span class="hljs-type"><span class="hljs-type">Len</span></span> '["<span class="hljs-title"><span class="hljs-title">x</span></span>", "<span class="hljs-title"><span class="hljs-title">y</span></span>", "<span class="hljs-title"><span class="hljs-title">z</span></span>"]) Actual type: Fin ('<span class="hljs-type"><span class="hljs-type">S</span></span> ('<span class="hljs-type"><span class="hljs-type">S</span></span> ('<span class="hljs-type"><span class="hljs-type">S</span></span> ('<span class="hljs-type"><span class="hljs-type">S</span></span> <span class="hljs-title"><span class="hljs-title">n0</span></span>)))) ‚Ä¢ In the second argument of 'lookupS', namely '(<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> <span class="hljs-type"><span class="hljs-type">FZ</span></span>)))' In the expression: lookupS (<span class="hljs-title"><span class="hljs-title">sing</span></span> @["<span class="hljs-title"><span class="hljs-title">x</span></span>", "<span class="hljs-title"><span class="hljs-title">y</span></span>", "<span class="hljs-title"><span class="hljs-title">z</span></span>"]) (<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> <span class="hljs-type"><span class="hljs-type">FZ</span></span>))) In an equation for 'it': it = lookupS (<span class="hljs-title"><span class="hljs-title">sing</span></span> @["<span class="hljs-title"><span class="hljs-title">x</span></span>", "<span class="hljs-title"><span class="hljs-title">y</span></span>", "<span class="hljs-title"><span class="hljs-title">z</span></span>"]) (<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> <span class="hljs-type"><span class="hljs-type">FZ</span></span>)))</code> </pre> <br><p>  Este exemplo mostra que viabilidade n√£o significa pr√°tico.  Fico feliz que Haskell tenha recursos de linguagem para implementar <code>lookupS</code> , mas ao mesmo tempo estou preocupado com a complexidade desnecess√°ria que surge.  Fora dos projetos de pesquisa, eu n√£o recomendaria esse estilo de c√≥digo. </p><br><p>  Nesse caso em particular, podemos obter o mesmo resultado com menos complexidade usando vetores indexados por comprimento.  No entanto, a tradu√ß√£o direta de c√≥digo da Agda revela melhor os problemas que voc√™ precisa ter em outras circunst√¢ncias. </p><br><p>  Aqui est√£o alguns deles: </p><br><ul><li>  A rela√ß√£o de digita√ß√£o <code>a :: t</code> rela√ß√£o de destino do formul√°rio <code>t :: k</code> diferentes.  <code>5 :: Integer</code> √© verdadeiro em termos, mas n√£o em tipos.  <code>"hi" :: Symbol</code> √© verdadeiro em tipos, mas n√£o em termos.  Isso requer que a <code>Demote</code> tipos <code>Demote</code> para mapear visualiza√ß√µes e tipos. </li><li>  A biblioteca padr√£o usa <code>Int</code> como uma representa√ß√£o dos √≠ndices da lista (e os <code>singletons</code> usam <code>Nat</code> em defini√ß√µes elevadas).  <code>Int</code> e <code>Nat</code> s√£o tipos n√£o indutivos.  Apesar de serem mais eficientes do que a codifica√ß√£o un√°ria de n√∫meros naturais, eles n√£o funcionam muito bem com defini√ß√µes indutivas, como <code>Fin</code> ou <code>lookupS</code> .  Por esse motivo, redefinimos o <code>length</code> como <code>len</code> . </li><li>  Haskell n√£o possui mecanismos internos para elevar fun√ß√µes ao n√≠vel de tipos.  <code>singletons</code> codificam como fam√≠lias de tipo privado e aplica a funcionaliza√ß√£o para contornar a falta de uso parcial de fam√≠lias de tipo.  Essa codifica√ß√£o √© complicada.  Al√©m disso, tivemos que colocar a defini√ß√£o de <code>len</code> em uma cita√ß√£o de Template Haskell para que os <code>singletons</code> gerassem seu equivalente em n√≠vel de tipo, <code>Len</code> . </li><li>  N√£o h√° fun√ß√µes dependentes internas.  √â preciso usar <a href="https://repository.brynmawr.edu/cgi/viewcontent.cgi%3Farticle%3D1009%26context%3Dcompsci_pubs" rel="nofollow">tipos de unidades</a> para preencher a lacuna entre termos e tipos.  Em vez da lista usual, passamos o <code>SList</code> para a entrada <code>lookupS</code> .  Portanto, devemos ter em mente v√°rias defini√ß√µes de listas de uma s√≥ vez.  Isso tamb√©m gera sobrecarga durante a execu√ß√£o do programa.  Surgem devido √† convers√£o entre valores comuns e valores de tipos de unidade ( <code>toSing</code> , <code>fromSing</code> ) e devido √† transfer√™ncia do procedimento de convers√£o (restri√ß√£o <code>SingKind</code> ). </li></ul><br><p>  Inconveni√™ncia √© o menor problema.  Pior, esses recursos de idioma n√£o s√£o confi√°veis.  Por exemplo, relatei o problema <a href="https://gitlab.haskell.org/ghc/ghc/issues/12564" rel="nofollow">n¬∫ 12564</a> em 2016 e tamb√©m o <a href="https://gitlab.haskell.org/ghc/ghc/issues/12088" rel="nofollow">n√∫mero 12088 do</a> mesmo ano.  Ambos os problemas impedem a implementa√ß√£o de programas mais avan√ßados do que exemplos de livros did√°ticos (como listas de indexa√ß√£o).  Esses bugs do GHC ainda n√£o foram corrigidos, e a raz√£o, ao que me parece, √© que os desenvolvedores simplesmente n√£o t√™m tempo suficiente.  O n√∫mero de pessoas que trabalham ativamente no GHC √© surpreendentemente pequeno, ent√£o algumas coisas n√£o acontecem. </p><br><h2 id="rezyume">  Sum√°rio </h2><br><p>  Mencionei anteriormente que queremos todas as tr√™s propriedades do c√≥digo, ent√£o aqui est√° uma tabela que ilustra o estado atual das coisas: </p><br><div class="scrollable-table"><table><thead><tr><th></th><th>  Standard Haskell </th><th>  Agda </th><th>  Haskell com extens√µes </th></tr></thead><tbody><tr><td>  Ergonomia e manuten√ß√£o </td><td>  + </td><td>  + </td><td>  - </td></tr><tr><td>  Desempenho </td><td>  + </td><td>  - </td><td>  + </td></tr><tr><td>  Corre√ß√£o garantida pelo m√©todo de desenho </td><td>  - </td><td>  + </td><td>  + </td></tr></tbody></table></div><br><h1 id="svetloe-buduschee">  Futuro brilhante </h1><br><p>  Das tr√™s op√ß√µes dispon√≠veis, cada uma tem suas desvantagens.  No entanto, podemos corrigi-los: </p><br><ul><li>  Pegue o Haskell padr√£o e adicione tipos dependentes diretamente, em vez de codifica√ß√£o inconveniente via <code>singletons</code> .  (Mais f√°cil dizer do que fazer.) </li><li>  Leve o Agda e implemente um gerador de c√≥digo eficiente e RTS para ele.  (Mais f√°cil dizer do que fazer.) </li><li>  Leve Haskell com extens√µes, corrija bugs e continue adicionando novas extens√µes para simplificar a codifica√ß√£o dos tipos dependentes.  (Mais f√°cil dizer do que fazer.) </li></ul><br><p>  A boa not√≠cia √© que todas as tr√™s op√ß√µes convergem em um ponto (em certo sentido).  Imagine a menor extens√£o do Haskell padr√£o que adiciona tipos dependentes e, portanto, permite garantir a corre√ß√£o do c√≥digo pela maneira como ele √© escrito.  O c√≥digo Agda pode ser compilado (transposto) para esse idioma sem um <code>unsafeCoerce</code> .  E Haskell com extens√µes √©, em certo sentido, um prot√≥tipo inacabado dessa linguagem.  Algo precisa ser melhorado e algo precisa ser removido, mas, no final, alcan√ßaremos o resultado desejado. </p><br><h2 id="izbavlenie-ot-singletons">  Livre de <code>singletons</code> </h2><br><p>  Um bom indicador de progresso √© a simplifica√ß√£o da biblioteca de <code>singletons</code> .  Como os tipos dependentes s√£o implementados no Haskell, as solu√ß√µes alternativas e o tratamento especial de casos especiais implementados em <code>singletons</code> n√£o s√£o mais necess√°rios.  Por fim, a necessidade deste pacote desaparecer√° completamente.  Por exemplo, em 2016, usando a extens√£o <code>-XTypeInType</code> <a href="https://github.com/goldfirere/singletons/pull/148/files" rel="nofollow">removi o KProxy</a> do <code>SingKind</code> e <code>SomeSing</code> .  Essa altera√ß√£o foi poss√≠vel atrav√©s da uni√£o de tipos e tipos.  Compare defini√ß√µes antigas e novas: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">kparam</span></span></span><span class="hljs-class"> ~ '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KProxy</span></span></span><span class="hljs-class">) =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SingKind</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">kparam</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KProxy</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DemoteRep</span></span></span><span class="hljs-class"> kparam :: * fromSing :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SingKind</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DemoteRep</span></span></span><span class="hljs-class"> kparam toSing :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DemoteRep</span></span></span><span class="hljs-class"> kparam -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> kparam </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DemoteRep</span></span></span><span class="hljs-class"> ('</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KProxy</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KProxy</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">kproxy</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KProxy</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sing</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> ('</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KProxy</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KProxy</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  Nas defini√ß√µes antigas, <code>k</code> ocorre exclusivamente nas posi√ß√µes de exibi√ß√£o, √† direita das anota√ß√µes no formato <code>t :: k</code> .  Usamos <code>kparam :: KProxy k</code> para transferir <code>k</code> para tipos. </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SingKind</span></span></span><span class="hljs-class"> k </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DemoteRep</span></span></span><span class="hljs-class"> k :: * fromSing :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SingKind</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DemoteRep</span></span></span><span class="hljs-class"> k toSing :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DemoteRep</span></span></span><span class="hljs-class"> k -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> k </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DemoteRep</span></span></span><span class="hljs-class"> k </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> k where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sing</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> k</span></span></code> </pre> <br><p>  Nas novas defini√ß√µes, <code>k</code> se move livremente entre as posi√ß√µes de visualiza√ß√£o e digita√ß√£o, portanto n√£o precisamos mais do <code>KProxy</code> .  O motivo √© que, come√ßando com o GHC 8.0, tipos e tipos se enquadram na mesma categoria sint√°tica. </p><br><p>  Existem tr√™s mundos completamente separados no Haskell padr√£o: termos, tipos e visualiza√ß√µes.  Se voc√™ olhar o c√≥digo fonte do GHC 7.10, poder√° ver um <a href="" rel="nofollow">analisador</a> separado para exibi√ß√µes e uma <a href="" rel="nofollow">verifica√ß√£o</a> separada.  O GHC 8.0 n√£o os possui mais: o <a href="" rel="nofollow">analisador</a> e a <a href="" rel="nofollow">valida√ß√£o</a> de tipos e visualiza√ß√µes s√£o comuns. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d01/37e/387/d0137e3870470beb4b2aee56240926cf.jpg"></p><br><p>  No Haskell com extens√µes, view √© apenas a fun√ß√£o do tipo: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">f</span></span> :: <span class="hljs-type"><span class="hljs-type">T</span></span> z -&gt; ... <span class="hljs-comment"><span class="hljs-comment">-- 'z'   g :: T (a :: z) -&gt; ... -- 'z'   h :: T z -&gt; T (a :: z) -&gt; ... -- 'z'   ,  </span></span></code> </pre> <br><p>  No GHC 8.0-8.4, ainda havia algumas diferen√ßas entre a resolu√ß√£o de nomes em tipos e tipos.  Mas eu os minimizei para o GHC 8.6: criei a extens√£o <code>StarIsType</code> e introduzi a funcionalidade <code>PolyKinds</code> no <code>PolyKinds</code> .  As diferen√ßas restantes, eu <a href="https://github.com/ghc/ghc/commit/8df24474d0194d28b8273c1539af05793156e23f" rel="nofollow">fiz um aviso</a> ao GHC 8.8 e <a href="https://github.com/ghc/ghc/commit/5bc195b1fe788e9a900a15fbe473967850517c3e" rel="nofollow">completamente eliminado</a> no GHC 8.10 </p><br><p>  Qual √© o pr√≥ximo passo?  Vamos dar uma olhada no <code>SingKind</code> na vers√£o mais recente dos <code>singletons</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SingKind</span></span></span><span class="hljs-class"> k </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> k = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class">) | r -&gt; k fromSing :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sing</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> k toSing :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> k -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> k</span></span></code> </pre> <br><p>  A <code>Demote</code> tipo <code>Demote</code> necess√°ria para considerar as discrep√¢ncias entre a rela√ß√£o de digita√ß√£o <code>a :: t</code> rela√ß√£o de destino do formul√°rio <code>t :: k</code> .  Na maioria das vezes (para tipos de dados alg√©bricos), o <code>Demote</code> √© um mapeamento de identidade: </p><br><ul><li> <code>type Demote Bool = Bool</code> </li> <li> <code>type Demote [a] = [Demote a]</code> </li> <li> <code>type Demote (Either ab) = Either (Demote a) (Demote b)</code> </li> </ul><br><p>  Portanto, <code>Demote (Either [Bool] Bool) = Either [Bool] Bool</code> .  Essa observa√ß√£o nos leva a fazer a seguinte simplifica√ß√£o: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SingKind</span></span></span><span class="hljs-class"> k </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> fromSing :: <span class="hljs-type"><span class="hljs-type">Sing</span></span> (a :: k) -&gt; k toSing :: k -&gt; <span class="hljs-type"><span class="hljs-type">SomeSing</span></span> k</code> </pre> <br><p>  <code>Demote</code> n√£o <code>Demote</code> necess√°rio!  E, de fato, isso funcionaria com os tipos de dados <code>Either [Bool] Bool</code> e outros alg√©bricos.  Na pr√°tica, no entanto, estamos lidando com tipos de dados n√£o alg√©bricos: <code>Integer,</code> <code>Natural</code> , <code>Char</code> , <code>Text</code> e assim por diante.  Se usadas como esp√©cies, elas n√£o s√£o preenchidas: <code>1 :: Natural</code> √© verdade no n√≠vel dos termos, mas n√£o no n√≠vel dos tipos.  Por isso, estamos lidando com essas defini√ß√µes: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nat</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Natural</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Symbol</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Text</span></span></span></span></code> </pre> <br><p>  A solu√ß√£o para esse problema √© gerar tipos primitivos.  Por exemplo, o <code>Text</code> definido assim: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- | A space efficient, packed, unboxed Unicode text type. data Text = Text {-# UNPACK #-} !Array -- payload (Word16 elements) {-# UNPACK #-} !Int -- offset (units of Word16, not Char) {-# UNPACK #-} !Int -- length (units of Word16, not Char) data Array = Array ByteArray# data Int = I# Int#</span></span></code> </pre> <br><p>  Se <code>ByteArray#</code> corretamente <code>ByteArray#</code> e <code>Int#</code> ao n√≠vel dos tipos, podemos usar <code>Text</code> vez de <code>Symbol</code> .  Ao fazer o mesmo com o <code>Natural</code> e possivelmente com outros tipos, voc√™ pode se livrar do <code>Demote</code> , certo? </p><br><p>  Infelizmente, n√£o √© assim.  Acima, fechei os olhos para o tipo de dados mais importante: fun√ß√µes.  Eles tamb√©m t√™m uma inst√¢ncia especial de <code>Demote</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k1</span></span></span><span class="hljs-class"> ~&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k2</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> k1 -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> k2 </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> a ~&gt; b = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TyFun</span></span></span><span class="hljs-class"> ab -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TyFun</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span></span></code> </pre> <br><p>  <code>~&gt;</code> este √© um tipo com o qual as fun√ß√µes em n√≠vel de tipo s√£o codificadas em singletons com base nas fam√≠lias de tipos particulares e na <a href="https://typesandkinds.wordpress.com/2013/04/01/defunctionalization-for-the-win/" rel="nofollow">funcionalidade</a> . </p><br><p>  A princ√≠pio, pode parecer uma boa id√©ia combinar <code>~&gt;</code> e <code>-&gt;</code> , pois ambos significam o tipo (tipo) da fun√ß√£o.  O problema √© que <code>-&gt;</code> na posi√ß√£o de tipo e <code>-&gt;</code> na posi√ß√£o de visualiza√ß√£o significam coisas diferentes.  No n√≠vel do termo, todas as fun√ß√µes de <code>a</code> a <code>b</code> s√£o do tipo <code>a -&gt; b</code> .  No n√≠vel de tipo, apenas os <em>construtores</em> de <code>a</code> a <code>b</code> s√£o do tipo <code>a -&gt; b</code> , mas n√£o s√£o sin√¥nimos de tipos nem fam√≠lias de tipos.  Para deduzir tipos, o GHC assume que <code>f ~ g</code> e <code>a ~ b</code> seguem de <code>fa ~ gb</code> , o que √© verdadeiro para construtores, mas n√£o para fun√ß√µes - √© por isso que h√° uma restri√ß√£o. </p><br><p>  Portanto, para elevar as fun√ß√µes ao n√≠vel dos tipos, mas para preservar a infer√™ncia de tipos, teremos que mover os construtores para um tipo separado.  N√≥s chamamos de <code>a :-&gt; b</code> , pois ser√° realmente verdade que <code>f ~ g</code> e <code>a ~ b</code> seguem de <code>fa ~ gb</code> .  Outras fun√ß√µes ainda ser√£o do tipo <code>a -&gt; b</code> .  Por exemplo, <code>Just :: a :-&gt; Maybe a</code> , mas ao mesmo tempo <code>isJust :: Maybe a -&gt; Bool</code> . </p><br><p>  Quando o <code>Demote</code> terminar, o √∫ltimo passo √© se livrar do pr√≥prio <code>Sing</code> .  Para fazer isso, precisamos de um novo quantificador, um h√≠brido entre <code>forall</code> e <code>-&gt;</code> .  Vamos dar uma olhada na fun√ß√£o isJust: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">isJust</span></span> :: <span class="hljs-keyword"><span class="hljs-keyword">forall</span></span> a. <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> isJust = \x -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">False</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> _ -&gt; <span class="hljs-type"><span class="hljs-type">True</span></span></code> </pre> <br><p>  A fun√ß√£o <code>isJust</code> parametrizada com o tipo <code>a</code> e, em seguida, com o valor <code>x :: Maybe a</code> .  Esses dois par√¢metros t√™m propriedades diferentes: </p><br><ul><li>  Explicita√ß√£o.  Na <code>isJust (Just "hello")</code> , passamos <code>x = Just "hello"</code> explicitamente, e <code>a = String</code> √© implicitamente emitida pelo compilador.  No Haskell moderno, tamb√©m podemos for√ßar a passagem expl√≠cita de ambos os par√¢metros: <code>isJust @String (Just "hello")</code> . </li><li>  Relev√¢ncia  O valor passado para a entrada para <code>isJust</code> no c√≥digo tamb√©m ser√° transmitido durante a execu√ß√£o do programa: executamos um padr√£o correspondente a <code>case</code> e <code>case</code> para verificar se √© <code>Nothing</code> ou <code>Just</code> .  Portanto, o valor √© considerado relevante.  Mas seu tipo √© apagado e n√£o pode ser comparado com o padr√£o: a fun√ß√£o manipula <code>Maybe Int</code> , <code>Maybe String</code> , <code>Maybe Bool</code> , etc.  Portanto, √© considerado irrelevante.  Essa propriedade tamb√©m √© chamada de parametridade. </li><li>  V√≠cio.  Em todos os <code>forall a. t</code>  <code>forall a. t</code> , o tipo <code>t</code> pode se referir a <code>a</code> e, portanto, depende do particular passado <code>a</code> .  Por exemplo, <code>isJust @String</code> √© do tipo <code>Maybe String -&gt; Bool</code> e <code>isJust @Int</code> √© do tipo <code>Maybe Int -&gt; Bool</code> .  Isso significa que <code>forall</code> √© um quantificador dependente.  Observe a diferen√ßa com o par√¢metro value: n√£o importa se chamamos <code>isJust Nothing</code> ou <code>isJust (Just ‚Ä¶)</code> , o tipo de resultado √© sempre <code>Bool</code> .  Portanto, <code>-&gt;</code> √© um quantificador independente. </li></ul><br><p>  Para eliminar <code>Sing</code> , precisamos de um quantificador expl√≠cito e relevante, como <code>a -&gt; b</code> , e ao mesmo tempo dependente, como <code>forall (a :: k). t</code>  <code>forall (a :: k). t</code> .  Denote-o como <code>foreach (a :: k) -&gt; t</code> .  Para <code>SingI</code> , tamb√©m introduzimos um quantificador dependente impl√≠cito relevante, <code>foreach (a :: k). t</code>  <code>foreach (a :: k). t</code> .  Como resultado, <code>singletons</code> n√£o ser√£o necess√°rios, pois acabamos de adicionar fun√ß√µes dependentes ao idioma. </p><br><h2 id="kratkiy-vzglyad-na-haskell-s-zavisimymi-tipami">  Uma breve olhada em Haskell com tipos dependentes </h2><br><p>  Com o aumento das fun√ß√µes no n√≠vel dos tipos e no quantificador <code>foreach</code> , podemos reescrever as <code>lookupS</code> seguinte maneira: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">N</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Z</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SN</span></span></span><span class="hljs-class"> len :: [a] -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">N</span></span></span><span class="hljs-class"> len [] = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Z</span></span></span><span class="hljs-class"> len (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_</span></span></span><span class="hljs-class">:</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xs</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">len</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xs</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fin</span></span></span><span class="hljs-class"> n where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FZ</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fin</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">n</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FS</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fin</span></span></span><span class="hljs-class"> n -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fin</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">n</span></span></span><span class="hljs-class">) lookupS :: foreach (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xs</span></span></span><span class="hljs-class"> :: [</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">]) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fin</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">len</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xs</span></span></span><span class="hljs-class">) -&gt; a lookupS [] = \case{} lookupS (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">:</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xs</span></span></span><span class="hljs-class">) = \case </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FZ</span></span></span><span class="hljs-class"> -&gt; x </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FS</span></span></span><span class="hljs-class"> i' -&gt; lookupS xs i'</span></span></code> </pre> <br><p>  Em suma, o c√≥digo n√£o o fez, mas os <code>singletons</code> muito bons em ocultar c√≥digos redundantes.  No entanto, o novo c√≥digo √© muito mais simples: n√£o h√° mais <code>SingKind</code> , <code>SList</code> , <code>SNil</code> , <code>SNil</code> , <code>SCons</code> , <code>fromSing</code> .  N√£o h√° uso do <code>TemplateHaskell</code> , pois agora podemos chamar a fun√ß√£o <code>len</code> diretamente em vez de criar a fam√≠lia de tipos <code>Len</code> .  O desempenho tamb√©m ser√° melhor, pois voc√™ n√£o precisa mais converter <code>fromSing</code> . </p><br><p>  Ainda precisamos redefinir o <code>length</code> como <code>len</code> para retornar um <code>N</code> definido indutivamente em vez de <code>Int</code> .  Talvez esse problema n√£o deva ser considerado na estrutura da adi√ß√£o de tipos dependentes ao Haskell, porque o Agda tamb√©m usa um <code>N</code> definido indutivamente na fun√ß√£o de <code>lookup</code> . </p><br><p>  Em alguns aspectos, Haskell com tipos dependentes √© ainda mais simples que o Haskell padr√£o.  Ainda assim, em termos, tipos e tipos s√£o combinados em uma linguagem √∫nica e uniforme.  Posso facilmente imaginar escrever c√≥digo nesse estilo em um projeto comercial para provar formalmente a corre√ß√£o dos principais componentes dos aplicativos.  Muitas bibliotecas Haskell podem fornecer interfaces mais seguras sem a complexidade dos <code>singletons</code> . </p><br><p>  Isso n√£o ser√° f√°cil de conseguir.  Temos muitos problemas de engenharia que afetam todos os componentes do GHC: um analisador, resolu√ß√£o de nomes, verifica√ß√£o de tipo e at√© o idioma principal.  Tudo precisar√° ser modificado ou completamente redesenhado. </p><br><hr><br><h1 id="tezaurus">  Thesaurus </h1><br><div class="scrollable-table"><table><tbody><tr><td>  <strong>Prazo</strong> <br></td><td>  <strong>Tradu√ß√£o</strong> <br></td><td>  <strong>Explica√ß√£o</strong> <br></td></tr><tr><td> correct by construction <br></td><td> ,       <br></td><td>  ,         (,   ),   . <br></td></tr><tr><td> memory unsafe <br></td><td>      <br></td><td>         ,    . <br></td></tr><tr><td> unityped <br></td><td>  <br></td><td> ,   Bob Harper     ,    .           . <br></td></tr><tr><td> boilerplate <br></td><td>   <br></td><td>       ,    -   . <br></td></tr><tr><td> generics <br></td><td>   <br></td><td>       . ,     ¬´¬ª  ¬´¬ª,     ,    &lt;&gt;  &lt;&gt;. <br></td></tr><tr><td> runtime cast <br></td><td>     <br></td><td>              . <br></td></tr><tr><td> effectful computation <br></td><td>     <br></td><td> ,          . <br></td></tr><tr><td> composable <br></td><td>  <br></td><td>  ,          . <br></td></tr><tr><td> control structures <br></td><td> ,    <br></td><td>  ,       . <br></td></tr><tr><td> proof assistant <br></td><td>    <br></td><td>       . <br></td></tr><tr><td> strict (eager) evaluation <br></td><td>  ()  <br></td><td>   ,         . <br></td></tr><tr><td> backend <br></td><td>  <br></td><td>  ,         . <br></td></tr><tr><td> singleton type <br></td><td>   <br></td><td> ,   ,       . <br></td></tr><tr><td> promoted definitions <br></td><td>   <br></td><td>    ,         . <br></td></tr></tbody></table></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt485174/">https://habr.com/ru/post/pt485174/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt485158/index.html">Nikolay Vavilov. O homem que queria alimentar o mundo inteiro e morreu de fome em uma cela de pris√£o</a></li>
<li><a href="../pt485160/index.html">O que eu estou no ACID ou em uma perspectiva diferente</a></li>
<li><a href="../pt485162/index.html">Como os coment√°rios do c√≥digo evolu√≠ram da d√©cada de 1940 para 2020</a></li>
<li><a href="../pt485164/index.html">Transformadores e √≥dio em Vancouver: como o anti-pl√°gio monta o NeurIPS-2019</a></li>
<li><a href="../pt485172/index.html">Problemas de arquitetura em grandes projetos</a></li>
<li><a href="../pt485176/index.html">Seis esquemas para ajudar a explicar os conceitos de gerenciamento de produtos</a></li>
<li><a href="../pt485178/index.html">Metodologia para reconstru√ß√£o de edif√≠cios perdidos a partir de fotografias</a></li>
<li><a href="../pt485180/index.html">Precisamos de um lago de dados? O que fazer com o data warehouse?</a></li>
<li><a href="../pt485182/index.html">Sennheiser em 2020 - fones de ouvido sem fio atualizados para o anivers√°rio</a></li>
<li><a href="../pt485184/index.html">Resultados da vota√ß√£o com guias</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>