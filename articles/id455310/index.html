<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙎🏼 🚶🏿 🆓 Serangan pada saluran bypass: sekarang tidak hanya PC tetapi juga smartphone sedang diserang (tinjauan analitik) 🎩 🤼 🍑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Meskipun perangkat seluler semakin banyak diminati, dan serangan pada saluran pintas memori cache (selanjutnya disebut serangan cache) adalah cara yan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Serangan pada saluran bypass: sekarang tidak hanya PC tetapi juga smartphone sedang diserang (tinjauan analitik)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455310/"><p>  Meskipun perangkat seluler semakin banyak diminati, dan serangan pada saluran pintas memori cache (selanjutnya disebut serangan cache) adalah cara yang ampuh untuk memecahkan elektronik mikroprosesor modern, hingga 2016 hanya ada beberapa publikasi tentang penerapan serangan ini ke smartphone .  Selain itu, publikasi awal ini terbatas pada mempertimbangkan serangan pada tabel AES dan tidak menyentuh metode serangan internuklear yang lebih modern: Prime + Probe [6], Flush + Reload [6], Pengusiran + Reload [7], Flush + Flush [8], Rowhammer [ 9].  Selain itu, hingga 2016, diyakini bahwa serangan cache nuklir hanya dapat dilakukan pada platform Intel dan AMD, tetapi baru-baru ini juga telah dilakukan untuk platform ARM (pada ponsel cerdas dan perangkat seluler lainnya).  [6] </p><br><p>  Dalam beberapa tahun terakhir, ada lonjakan minat dari para pakar keamanan siber - untuk melakukan cache serangan pada smartphone.  Artikel ini adalah tinjauan analitik dari penemuan utama di area ini untuk periode 2015 hingga 2017. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">- Sejarah saluran memotong</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">- Mengapa serangan cache pada ARM sangat unik</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">- Varietas serangan cache</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">- - Mengusir + Waktu</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">- - Prime + Probe</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">- - Flush + Reload</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">- - Gusur + Muat Ulang</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">- - Siram + Siram</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">- - AnC</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">- Efek Rowhammer</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">- Deduplikasi memori sistem</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">- Pseudo-isolasi kernel dari sistem operasi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">- Saluran tersembunyi internasional dan interprocessor</a> </p><br><p><img src="https://habrastorage.org/webt/ys/jo/7g/ysjo7gybyvqu-okdlkrkilqrnrw.jpeg"></p><a name="habracut"></a><br><p>  Mengenai serangan cache pada tabel AES, meskipun telah diketahui selama beberapa waktu bahwa serangan ini <em>mungkin terjadi</em> , implementasi tabel AES yang rentan masih digunakan sebagai standar de facto;  termasuk dalam perangkat kripto tertanam modern, seperti kartu SIM.  Misalnya, jaringan 3G / 4G menggunakan algoritma otentikasi AES MILENAGE.  Komprominya memungkinkan Anda untuk mengkloning kartu USIM dan menguping pembicaraan.  T.O.  serangan cache pada saluran bypass relevan untuk kartu SIM (digunakan untuk mengakses jaringan 2G) dan kartu USIM (digunakan untuk mengakses jaringan 3G / 4G).  Pada 2015, "serangan daya diferensial" (DPA) dideskripsikan - serangan yang memulihkan kunci enkripsi (digunakan oleh algoritma MILENAGE) dan rahasia kartu USIM lainnya hanya dalam beberapa menit.  [3] </p><br><a name="a1"></a><br><h1 id="istoriya-obhodnyh-kanalov">  Sejarah saluran pintas </h1><br><ul><li>  Ketika perangkat lunak menjadi lebih kompleks dan dengan meningkatnya jumlah perlindungan perangkat lunak tingkat lanjut, peretasan sistem pada tingkat perangkat keras, khususnya penggunaan serangan cache melalui saluran bypass, menjadi alternatif yang semakin menarik.  Serangan-serangan ini didasarkan pada kerentanan yang ditemukan dalam arsitektur prosesor-memori.  [4] </li><li>  Pada tahun 1985, teknologi membaca informasi dari tampilan video diperkenalkan - dengan mengukur interferensi elektromagnetik yang disebabkan oleh mereka [10].  Berdasarkan teknologi ini, pada tahun 2014 dikembangkan suatu keylogger - dibangun berdasarkan smartphone dan antena radio.  [12] </li><li>  Pada tahun 1996, ditunjukkan bahwa dengan secara hati-hati mengukur jumlah waktu yang dihabiskan untuk melakukan operasi dengan kunci privat, berbagai sistem kriptografi, seperti DES cipher, dapat diretas.  Pada tahun 2016, serangan terhadap saluran bypass pada perangkat enkripsi menggunakan kriptografi elips canggih pertama kali ditunjukkan;  selama serangan, kunci dekripsi rahasia diekstraksi dari perangkat target yang terletak di ruangan lain.  [13] </li><li>  Pada tahun 1997, "metode distorsi diferensial" (DFA) diperkenalkan - serangan yang menggunakan berbagai model kegagalan mikro, serta berbagai metode cryptanalysis;  untuk mengembalikan pengaturan rahasia dari kartu pintar dan perangkat lain yang dilindungi dari akses tidak sah.  [11] Memiliki akses fisik ke perangkat, Anda dapat mengubah tegangan suplai, frekuensi sinyal clock;  atau kondisi lingkungan (suhu, dll.) - untuk membuat kerusakan kartu pintar.  Selain itu, kerusakan peralatan dapat dipicu - bahkan oleh intervensi perangkat lunak saja;  dan karena itu dapat dilakukan dalam mode akses jarak jauh. </li><li>  Pada tahun 2014, serangan terhadap bypass cache didemonstrasikan;  serangan ini menggunakan kebocoran informasi yang disebabkan oleh perbedaan waktu akses ke data, tergantung pada apakah mereka ada dalam cache atau tidak;  dengan demikian  serangan ini memperjelas data yang digunakan kode yang sedang diselidiki ini.  Selama serangan ini, pemulihan penuh kunci AES telah ditunjukkan.  [9] Beberapa saat kemudian, pada tahun 2015, ditunjukkan bahwa saluran bypass cache dapat digunakan tidak hanya untuk menyerang sistem kriptografi, tetapi juga untuk mengumpulkan informasi tentang penekanan tombol.  [14] </li><li>  Pada tahun 2014, ditunjukkan bahwa mengakses sel memori yang sama pada frekuensi tinggi dapat memicu perpindahan bit spontan dalam chip DRAM (efek Rowhammer).  [9] Karena DRAM berskala ke ukuran terkecil, mencegah gangguan listrik antar sel tidak mudah.  Itu sebabnya aktivasi jalur tertentu dari memori mengarah ke distorsi data di jalur yang berdekatan. </li><li>  Pada 2015, itu menunjukkan bahwa efek Rowhammer dapat digunakan untuk meningkatkan hak istimewa ke superuser.  [15] Pada tahun yang sama, ditunjukkan bahwa perpindahan bit secara spontan dapat dipicu bahkan oleh kode Java yang diunggah ke situs web.  [7] Awalnya, skenario ini hanya diterapkan untuk sistem Intel dan AMD menggunakan modul DDR3 dan DDR4.  [16, 17] Namun, pada 2016, serangan ini juga diperagakan di platform ARM.  [1] Pada tahun yang sama, terlihat bahwa serangan cache juga dapat digunakan untuk memantau aktivitas cache di TrustZone.  [1] </li><li>  Pada 2016, "reverse engineering" dilakukan untuk fungsi pengalamatan DRAM yang biasa digunakan dalam smartphone modern.  Akibatnya, cara-cara tambahan untuk mengalihkan bit ditemukan yang tersedia untuk implementasi pada jutaan perangkat Android, tanpa perlu bekerja dalam mode istimewa.  [1] </li><li>  Pada 2016, serangan pada level terakhir dari cache prosesor ARM diperlihatkan untuk pertama kalinya.  Serangan ini dapat diimplementasikan untuk serangan cache inter-proses dan nuklir di saluran bypass.  [1] </li></ul><br><a name="a2"></a><br><h1 id="chem-tak-unikalny-kesh-ataki-na-arm">  Mengapa serangan cache pada ARM sangat unik </h1><br><ul><li>  Metode serangan seperti Flush + Reload dan Flush + Flush - gunakan instruksi reset clflush x86 unprivileged untuk menghapus baris data dari cache.  Namun, dengan pengecualian prosesor ARMv8-A, platform ARM tidak memiliki instruksi pengaturan ulang cache yang tidak tertutup;  dan karenanya, pada 2016, metode ekstrusi cache tidak langsung diusulkan menggunakan efek Rowhammer.  [1] </li><li>  Untuk melakukan serangan cache yang berhasil, informasi seperti waktu siklus yang tepat untuk mengakses sel memori diperlukan.  Serangan cache awal menggunakan penghitung kinerja sistem untuk tujuan ini, tetapi metode ini tidak efisien, karena penghitung ini pada prosesor ARM hanya tersedia dalam mode istimewa.  Namun, pada tahun 2016, tiga sumber sinkronisasi alternatif diusulkan, termasuk yang tersedia dalam mode tidakrivil.  [1] Salah satunya adalah peluncuran aliran sinkronisasi paralel, yang terus-menerus menambah variabel global.  Dengan membaca nilai variabel ini, penyerang dapat mengukur waktu siklus mengakses sel memori. </li><li>  Selain itu, yang disebut.  kebijakan substitusi pseudo-acak, sebagai hasilnya crowding out dari cache kurang dapat diprediksi dibandingkan pada prosesor Intel dan AMD.  Namun demikian, pada tahun 2016 serangan cache yang efektif diperlihatkan bahkan dalam kondisi bising seperti itu - untuk tiga smartphone: "OnePlus One" (menggunakan "Snapdragon 801 SoC" dengan prosesor "Krait 400" dari arsitektur ARMv7-A), "Alcatel One Touch Pop 2 "(menggunakan" Snapdragon 410 SoC "dengan prosesor" CortexA53 "dari arsitektur ARMv8-A)," Samsung Galaxy S6 "(menggunakan" Samsung Exynos 7 Octa 7420 SoC "dengan dua kelompok prosesor" ARMv8-A ").  [1] </li></ul><br><a name="a3"></a><br><h1 id="raznovidnosti-kesh-atak">  Varietas serangan cache </h1><br><ul><li>  Secara umum, serangan cache pada saluran bypass dapat dibagi menjadi tiga tahap: 1) identifikasi sinyal mikroarsitektur "merembes" dari sistem elektronik "bocor";  Contoh tipikal dari sinyal mikroarsitektur yang bocor adalah konsumsi daya dan radiasi elektromagnetik dari sirkuit terpadu.  [2, 3];  2) pemantauan dan analisis sinyal ini selama operasi sistem;  3) identifikasi perbedaan pola sinyal mikroarsitektur.  [2] <a name="a31"></a></li><li>  <strong>Gusur + Waktu.</strong>  Ide dasarnya adalah untuk menentukan cache mana yang mengatur program korban mengakses.  Algoritma: 1) mengukur waktu pelaksanaan program korban;  2) memindahkan bagian tertentu dari cache;  3) mengukur waktu pelaksanaan program korban lagi.  Menggunakan perbedaan waktu antara dua dimensi, Anda dapat menentukan berapa banyak waktu bagian tertentu dari cache digunakan oleh korban saat runtime.  Pada tahun 2010, jenis serangan yang kuat berdasarkan Evict + Time ditunjukkan - terhadap AES pada OpenSSL;  tanpa perlu teks terbuka dan terenkripsi.  [18, 19] <a name="a32"></a></li><li>  <strong>Prime + Probe.</strong>  Metode ini - seperti yang sebelumnya - memungkinkan penyerang untuk menentukan cache yang mengatur program korban mengakses.  Algoritma: 1) mengisi bagian tertentu dari cache;  2) mentransfer kendali ke program korban;  3) tentukan bagian mana dari cache penuh yang masih menjadi milik kami.  Ini dapat dilakukan dengan mengukur waktu akses ke alamat yang digunakan penyerang untuk mengisi cache di tahap pertama.  T.O.  jika program korban menggunakan alamat yang dipetakan ke area cache yang sama dengan penyerang, maka itu akan memaksa data penyerang keluar dari cache;  dan penyerang dapat melacak ini di tahap ketiga.  Pada [19], serangan menggunakan mekanisme ini ditunjukkan - pada OpenSSL AES dan Linux dm-crypt.  Pada 2015 [20] diperlihatkan bagaimana, menggunakan Prime + Probe, Anda dapat memasang saluran rahasia internuclear dan antar-mesin, dan kemudian menyerang ElGamal di GnuPG.  Pada tahun yang sama, serangan sukses terhadap implementasi OpenSSL AES di cloud ditunjukkan.  [21] <a name="a33"></a></li><li>  <strong>Siram + Muat Ulang.</strong>  Pada 2011 [22] ditunjukkan bagaimana clflush dapat digunakan untuk menyerang AES.  Clflush digunakan untuk mendorong sel memori yang dilacak keluar dari cache;  diikuti dengan memeriksa apakah sel ini dimuat ulang ke dalam cache setelah program korban mengeksekusi sejumlah kecil instruksi.  Algoritma: 1) Proyeksikan biner (misalnya, objek bersama) ke dalam ruang alamatnya (menggunakan panggilan sistem yang sesuai, seperti mmap);  2) mengusir garis cache (kode atau data) dari cache;  3) mentransfer kendali ke program korban;  4) periksa apakah garis cache ini (dari klausa 2) diambil oleh program korban (pemeriksaan ini dilakukan dengan mengukur waktu akses ke sel memori).  Pada tahun 2014, pemulihan penuh kunci rahasia AES di mesin virtual VMWare ditunjukkan melalui serangan cache Flush + Reload.  [23] Pada tahun yang sama, menggunakan serangan yang sama, pemulihan kunci rahasia dari algoritma OpenSSL ECDSA (algoritma tanda tangan digital berdasarkan kurva eliptik) ditunjukkan.  [24] Pada 2015, melalui serangan Flush + Reload, mekanisme sistem "deduplikasi memori" terganggu;  sebagai hasilnya, kemungkinan komunikasi yang tidak sah antara mesin virtual yang berjalan pada mesin fisik umum.  [25] Pada tahun yang sama, diperlihatkan cara menggunakan Flush + Reload untuk mendapatkan informasi tentang perpustakaan kriptografi mana yang digunakan oleh berbagai mesin virtual yang berjalan pada mesin fisik umum.  [26] Pada 2015, ditunjukkan juga bahwa selain menyerang sistem kriptografi, metode Flush + Reload juga dapat digunakan untuk keylogger.  [14] <a name="a34"></a></li><li>  <strong>Gusur + Muat Ulang.</strong>  Itu diperkenalkan pada 2015 [14].  Menggunakan Flush + Reload untuk ekstrusi - bukan instruksi ekstrusi.  Meskipun serangan ini tidak masuk akal untuk x86 (karena clflush tidak memerlukan hak istimewa), itu sangat relevan untuk prosesor ARM (karena instruksi semacam itu hanya tersedia dalam mode istimewa).  Inti dari Evict + Reload adalah bahwa untuk memeras sel yang diinginkan dari cache, kami mengisi cache dengan sejumlah besar alamat yang saling berhubungan, sebagai akibatnya mekanisme yang bertanggung jawab untuk crowding out memutuskan untuk memeras sel cache yang kita butuhkan.  Selain itu, pada tahun 2016, ditunjukkan bahwa strategi preemptive yang efisien dan cepat dapat memulai perpindahan bit spontan di baris yang berdekatan dari modul DRAM (sebagai hasil dari beberapa akses ke jalur memori yang sama) menggunakan applet yang ditulis dalam JavaScript.  [24] Demikianlah  serangan cache tidak lagi tergantung pada instruksi flushing cache istimewa seperti clflush. <a name="a35"></a></li><li>  <strong>Siram + Siram.</strong>  Serangan Flush + Reload dan Prime + Probe menyebabkan banyak akses cache, durasinya dapat diukur (melalui penghitung kinerja sistem).  Serangan Flush + Flush, diperkenalkan pada tahun 2015, tepatnya didasarkan pada pengamatan ini.  [8] Serangannya hampir sama dengan Flush + Reload.  Objek file biner atau split dipetakan ke ruang alamat penyerang.  Sel memori dipaksa keluar dari cache, dan kontrol ditransfer ke program korban.  Namun, alih-alih tahap reboot, di mana sel yang kita amati sedang diakses, itu lagi digantikan;  tanpa menyebabkan kesalahan, dibandingkan dengan Flush + Reload atau Prime + Probe.  T.O.  Sangat mudah untuk mengetahui apakah lokasi memori di-cache atau tidak. <a name="a36"></a></li><li>  <strong>AnC.</strong>  Ini adalah modifikasi yang lebih baru dari serangan cache "Evict + Time", diperkenalkan pada 2017.  [4] Fitur khas AnC adalah bahwa serangan cache ini bergantung pada analisis tabel halaman yang di-cache, yang digunakan di sebagian besar prosesor modern (Intel, AMD, ARM).  [4] Saat ini, inti dari setiap prosesor adalah "unit manajemen memori" (MMU), yang menyederhanakan pengelolaan memori fisik yang tersedia - melalui virtualisasi;  untuk penggunaan selanjutnya oleh beberapa proses.  MMU menggunakan struktur data "halaman tabel" untuk memetakan sel memori virtual dan fisik.  Page Tables adalah target yang menarik untuk serangan perangkat keras.  Misalnya, perpindahan spontan hanya satu bit (disebabkan oleh efek Rowhammer) di "tabel halaman" - mungkin cukup bagi penyerang untuk mendapatkan kendali atas alamat fisik memori yang tidak boleh ia dapatkan aksesnya;  dan ini mungkin cukup untuk mendapatkan hak pengguna super.  [4] </li></ul><br><a name="a4"></a><br><h1 id="effekt-rowhammer">  Efek Rowhammer </h1><br><ul><li>  Sebuah chip DRAM terpisah memiliki kapasitas kecil, dan oleh karena itu beberapa sirkuit mikro dihubungkan bersama pada satu papan - untuk membentuk apa yang disebut  Seri DRAM.  Satu modul memori DRAM dapat berisi satu atau lebih baris DRAM.  Chip DRAM terdiri dari susunan sel dua dimensi.  Setiap sel DRAM adalah kapasitor;  0 dan 1 adalah kondisi kapasitor yang terisi atau kosong.  Setiap sel dalam grid terhubung ke sel tetangga dengan kawat.  Jika ada sel yang diaktifkan, maka tegangan diterapkan ke kapasitornya, dan ke semua kapasitor lainnya dari baris yang sama.  Karena sel-sel memori menjadi lebih kecil dan lebih kecil dan lebih dekat satu sama lain seiring kemajuan teknologi, gangguan yang disebabkan oleh aktivasi jalur memori sangat sering mempengaruhi muatan kapasitor dari saluran yang berdekatan.  Pada tahun 2014, ditunjukkan [9] bahwa akses yang sering ke sel memori DRAM yang sama mengarah ke efek Rowhammer - perpindahan bit spontan.  Efek ini dapat digunakan untuk meningkatkan hak istimewa (misalnya, untuk keluar dari sandbox keamanan [15]);  itu dapat diimplementasikan, antara lain, sebagai hasil dari eksekusi kode JavaScript tidakrivatif yang terletak di situs web. </li><li>  Untuk "menyumbat" sel memori tertentu, penyerang perlu menemukan dua alamat di bank DRAM yang sama - tetapi pada baris yang berbeda.  Bit alamat tertentu digunakan untuk memilih jalur, saluran, dan tepi lokasi memori.  Namun, bagaimana fungsi pengambilan sampel bekerja tidak didokumentasikan.  Oleh karena itu, pada tahun 2015 [27] mekanisme diperkenalkan untuk otomatisasi lengkap dari rekayasa balik fungsi yang sesuai;  menggunakan fakta bahwa "konflik string" menyebabkan peningkatan waktu akses ke memori.  Inti dari pendekatan yang digunakan adalah untuk mencari alamat yang dipetakan ke bank DRAM yang sama, tetapi pada jalur yang berbeda;  dengan berulang kali mengukur waktu akses ke dua alamat acak.  Untuk beberapa pasang alamat, waktu akses lebih lama daripada yang lain - ini berarti mereka termasuk dalam jalur yang berbeda, tetapi dari bank yang sama.  Kemudian alamat ini dikelompokkan ke dalam set yang memiliki saluran, jalur, dan bank yang sama.  Alamat yang diidentifikasi ini kemudian digunakan untuk merekonstruksi fungsi pengalamatan - dengan menghasilkan semua fungsi linier dan menerapkannya ke semua alamat dari subset yang dipilih secara sewenang-wenang.  T.O.  karena ruang pencariannya kecil, brute force brute force sangat efektif di sini.  [1] </li><li>  Implementasi pertama serangan menggunakan efek Rowhammer bergantung pada metode probabilistik (karena itu sistem crash yang tidak direncanakan dapat terjadi selama serangan);  atau fungsi manajemen memori khusus: deduplikasi memori, paravirtualisasi MMU, antarmuka pagemap.  Namun, fungsi tersebut pada perangkat modern tidak tersedia sama sekali atau dinonaktifkan karena alasan keamanan.  [30] </li><li>  Oleh karena itu, pada tahun 2016, serangan Drammer diperkenalkan - bebas dari kelemahan dan keterbatasan yang tercantum.  Ini hanya bergantung pada kemampuan sistem operasi modern saat ini, yang tersedia tanpa hak pengguna super.  Secara khusus, perilaku yang dapat diprediksi dari subsistem distribusi memori fisik.  Prediktabilitas ini digunakan untuk mencapai distribusi memori fisik (di mana data sensitif akan diproses, seperti tabel halaman memori) di lokasi yang rentan dari memori fisik yang dipilih oleh penyerang.  Teknik yang sesuai dari "memijat ingatan" disebut Phys Feng Shui.  Untuk menunjukkan operabilitas serangan Drammer, implementasi exploit disediakan yang memberikan akses ke direktori root untuk perangkat Android.  Eksploitasi ini dapat diluncurkan oleh aplikasi apa pun tanpa izin khusus;  dan tanpa mengeksploitasi kerentanan perangkat lunak apa pun.  [30] </li><li>  T.O.    Drammer  ,      Rowhammer       (   Intel  AMD),      (  ARM-);   ,           . [30] </li><li>  2016     « » Flip Feng Shui (FFS) –     Rowhammer,            ;       ;         .     FFS    ,    Ubuntu/Debian. [31] </li><li>  2017   ,   MLC NAND  -,      SSD-, –   ,   Rowhammer.            .      –    . [5] </li></ul><br><a name="a5"></a><br><h1 id="dedublikaciya-sistemnoy-pamyati">    </h1><br><ul><li>   -          ;       .      ,    ;          .  [1] </li><li>   ( ) –    ,      ,             .          (      –   ,     ).   ,        –         ,        .                  –      .  [1] </li><li>   –          ;        Windows 8.1  10.          –    ,     «  ».       –          .      ,        ,      .  ,      « »,         ,     . ,      ,      ,       . [35] </li><li>  2016   ,          –        .      . -,  ,        , –       ;        (,  64- ). -,  ,      ,      ,         . -,  ,            ,     -  –         . [35] </li><li>           ,    JavaScript-    Microsoft Edge –            .            ;      .  ,    - ngnix  ,      ,     :             ,      . [35] </li><li> ..           .      ,    ,          . [35] </li></ul><br><a name="a6"></a><br><h1 id="psevdoizolyaciya-yadra-operacionnoy-sistemy">     </h1><br><ul><li> ASLR (   )    (    )       .   «»       ,     .  ,    « »   ,                .      ,     ASLR – -  . [33] </li><li>   2016       ASLR      32-  64-  Linux,      « ».      ,          ,     –      .        . .. ASLR     . [33] </li><li>      ASLR –      ,     ,   .. «- » (ROP).  ,   ,      ,  ,        .           . [37] </li><li>   2017      KAISER,    ,          .     ,     , –      ,     . [37]  , KAISER      BTB (  ),   2016 . [36] </li><li>  2016        (BTB). BTB-   30    .       -,    BTB, –     .       ,    30- ,    –        .     ,        ,      . BTB-         .          ,   Intel Skylake (Intel Skylake i7-6700K),         .     . [36] </li><li>   2017   ,  ,              -     . [34] </li></ul><br><a name="a7"></a><br><h1 id="mezhyadernye-i-mezhprocessornye-skrytye-kanaly">      </h1><br><ul><li>       .    -        –    ,     .   ,              . [29] </li><li> -        - –   ;  Flush+Reload, Evict+Reload  Flush+Flush.             -    .      «»    « ».    Android     ,        , –        ;     (.  [28]). ..     . </li><li>       ,         -  .      –        . ,  -    ,   ,   ,  .  [1]     ;      ;   « »  « »,      ;     .  -  TCP   . </li><li>  2017          ,    SSH,      (45 /);               .   SSH-,    ,   ,    telnet-. [29] </li><li>  2015           ,         .              –       (    ,       ),                .            . [32] </li><li>      ,       .     . -,            ;       ,      ; ..        ,      . -,         (       ). [32] </li><li> ,       ,               (16 ).  ,   « »   Intel Xeon (    8 )  12,5/.         5   4 . [32] </li><li>   2015          ,           .  ,            ,            –        . [32] </li><li>  2016         Android,    250  ,  -    .  [1] </li></ul><br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text"><p> <strong>1.</strong> <em>Moritz Lipp, Daniel Gruss.</em>  ARMageddon: Serangan Cache pada Perangkat Seluler // Prosiding Simposium Keamanan USENIX ke-25.  2016. hlm.  549-564. <br>  <strong>2.</strong> <em>Robert Callan.</em>  Metodologi Praktis untuk Mengukur Sinyal Saluran Samping Yang Tersedia untuk Penyerang untuk Acara Tingkat Instruksi // Simposium Internasional IEEE / ACM Tahunan ke-47 tentang Mikroarsitektur (MICRO), Halaman 242-254, Desember 2014. <br>  <strong>3.</strong> <em>Junrong Liu.</em>  Tweak Kecil Tidak Membantu: Analisis Daya Diferensial Implementasi MILENAGE dalam Kartu USIM 3G / 4G.  BlackHat 2015. <br>  <strong>4.</strong> <em>Herbert Bos, Ben Gras.</em>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cache Tabel Teknik Perangkat Keras Terbalik Menggunakan Serangan Sisi-Saluran pada MMU</a> .  2017 <br>  <strong>5.</strong> <em>Yu Cai, Saugata Ghose.</em>  Kerentanan dalam Pemrograman Memori Flash NAND MLC: Analisis Eksperimental, Eksploitasi, dan Teknik Mitigasi // Simposium IEEE ke-23 tentang Arsitektur Komputer Kinerja Tinggi, sesi Industri, Februari 2017. <br>  <strong>6.</strong> <em>Falkner Katrina.</em>  Flush + Reload: Resolusi Tinggi, Kebisingan Rendah, Serangan Sisi-Saluran Cache L3 // Prosiding Simposium Keamanan USENIX ke-23.  2014. hlm.  719-732. <br>  <strong>7.</strong> <em>Gruss Daniel, Maurice Clementine M angard, Stefan.</em>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rowhammer.js: Serangan Kesalahan yang Diinduksi Perangkat Lunak Jarak Jauh dalam JavaScript</a> .  2016 <br>  <strong>8.</strong> <em>Gruss Daniel, Wagner Klaus.</em>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Flush + Flush: Serangan Cache Tingkat Terakhir Yang Lebih Siluman</a> .  2015 <br>  <strong>9.</strong> <em>Kim Yoongu, Daly Ross.</em>  Membalik Bit dalam Memori Tanpa Mengakses Mereka: Studi Eksperimental Kesalahan Gangguan DRAM // Proses dari Simposium Internasional Tahunan ke-41 tentang Arsitektur Komputer.  Piscataway, NJ, USA: IEEE Press, 2012 (ISCA '14). <br>  <strong>10.</strong> <em>Eck Wim.</em>  Radiasi elektromagnetik dari unit tampilan video: Risiko menguping?  // Komputer dan Keamanan.  Tidak.  4, 1985. hlm.  269-286. <br>  <strong>11.</strong> <em>Biham Eli, Shamir Adi.</em>  Analisis Kesalahan Diferensial Cryptosystem Key Rahasia // Kemajuan dalam Cryptology - CRYPTO '97 Bd.  1294. <br>  <strong>12.</strong> <em>Callan Robert, Zajic Alenka.</em>  Metodologi Praktis untuk Mengukur Sinyal Saluran Samping Yang Tersedia untuk Penyerang untuk Acara Tingkat Instruksi // Proses Prosiding Simposium Internasional IEEE / ACM Tahunan ke-47 tentang Mikroarsitektur.  2014. hlm.  242–254. <br>  <strong>13.</strong> <em>Genkin Daniel.</em>  Ekstraksi kunci ECDH melalui serangan elektromagnetik bandwidth rendah pada PC // Cryptology ePrint Archive, Report 2016/129. <br>  <strong>14.</strong> <em>Gruss Daniel.</em>  Serangan template cache: Mengotomatiskan serangan pada cache tingkat terakhir inklusif // Prosiding Simposium Keamanan USENIX ke-24.  2015. hal.  897–912. <br>  <strong>15.</strong> <em>Mark Seaborn.</em>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memanfaatkan bug rowhammer DRAM untuk mendapatkan hak istimewa kernel</a> .  2015 <br>  <strong>16.</strong> <em>Gruss Daniel.</em>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bitham bit Rowhammer di Skylake dengan DDR4</a> .  2016 <br>  <strong>17.</strong> <em>Mark Lanteigne.</em>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana Rowhammer Dapat Digunakan untuk Mengeksploitasi Kelemahan Kelemahan pada Perangkat Keras Komputer</a> .  2016 <br>  <strong>18.</strong> <em>Osvik Dag, Shamir Adi.</em>  Serangan Cache dan Penanggulangan: Kasus AES // Topik dalam Kriptologi.  2005. pp.  1-20. <br>  <strong>19.</strong> <em>Tromer Eran, Osvik Dag.</em>  Serangan cache yang efisien pada AES, dan tindakan pencegahan // Journal of Cryptology.  23 (1), 2010. hlm.  37-71. <br>  <strong>20.</strong> <em>Liu Fangfei, Yarom, Yuval.</em>  Serangan saluran samping cache tingkat terakhir bersifat praktis // Prosiding Simposium IEEE tentang Keamanan dan Privasi Bd.  2015. hal.  605-622. <br>  <strong>21.</strong> <em>Eisenbarth Thomas.</em>  Serangan Cache Bersama yang Berfungsi di Seluruh Cores dan Menentang VM Sandboxing - dan Aplikasinya untuk AES // IEEE Simposium tentang Keamanan dan Privasi.  2015 <br>  <strong>22.</strong> <em>Gullasch David, Bangerter Endre.</em>  Permainan cache - Membawa serangan cache berbasis akses pada AES untuk berlatih // Prosiding Simposium IEEE tentang Keamanan dan Privasi.  2011. hlm.  490-505. <br>  <strong>23.</strong> <em>Irazoqui Gorka, Inci Mehmet.</em>  Tunggu sebentar!  Serangan lintas-VM yang cepat pada AES // Catatan Kuliah di Ilmu Komputer Bd.  2014. hlm.  299-319. <br>  <strong>24.</strong> <em>Yarom Yuval, Benger Naomi.</em>  Memulihkan OpenSSL ECDSA Nonces Menggunakan Flush + Reload Cache Attack saluran-saluran // Cryptology ePrint Archive, Report 2014/140 (2014). <br>  <strong>25.</strong> <em>Gulmezoglu Berk, Inci Mehmet.</em>  Flush Lebih Cepat dan Lebih Realistis + Muat Ulang Serangan pada AES // Prosiding lokakarya internasional ke-6 tentang Analisis Saluran Samping Konstruktif dan Desain Aman.  2015. hal.  111-126. <br>  <strong>26.</strong> <em>Irazoqui Gorka, Inc. Mehmet.</em>  Kenalilah Tetangga Anda: Deteksi Perpustakaan Crypto di Cloud // Prosiding Teknologi Peningkatan Privasi.  2015. hal.  25-40. <br>  <strong>27.</strong> <em>Pessl Peter, Gruss Daniel.</em>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Reverse Engineering Intel DRAM Addressing and Exploitation</a> .  2015 <br>  <strong>28.</strong> <em>Marforio Claudio, Ritzdorf Hubert.</em>  Analisis komunikasi antara aplikasi yang berkolusi pada smartphone modern // Proses Konferensi Aplikasi Keamanan Komputer Tahunan ke-28.  2012. hal.  51-60. <br>  <strong>29.</strong> <em>Clementine Maurice, Manuel Webe.</em>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Halo dari Sisi Lain: SSH atas Saluran Terselubung Cache Kuat di Awan</a> .  2017 <br>  <strong>30.</strong> <em>Victor van der Veen, Lindorfer.</em>  Drammer: Serangan Rowhammer yang Deterministik pada Platform Seluler // Proses Konferensi ACM SIGSAC 2016 tentang Keamanan Komputer dan Komunikasi.  2016. hlm.  1675-1689. <br>  <strong>31.</strong> <em>Kaveh Razavi, Ben Gras.</em>  Flip Feng Shui: Memalu Jarum di Stack Perangkat Lunak // Prosiding Simposium Keamanan USENIX ke-25.  2016. hlm.  1-18. <br>  <strong>32.</strong> <em>Ramya Jayaram Masti, Devendra Rai.</em>  Saluran Terselubung Termal pada Platform Multi-inti // Prosiding Simposium Keamanan USENIX ke-24.  2015. hal.  865-880. <br>  <strong>33.</strong> <em>Angelos Oikonomopoulos.</em>  Lubang-lubang Poking dalam Menyembunyikan Informasi // Prosiding Simposium Keamanan USENIX ke-25.  2016. hlm.  121-138. <br>  <strong>34.</strong> <em>Koen Koning.</em>  Tidak Perlu Disembunyikan: Melindungi Daerah Aman di Perangkat Keras Komoditas // Prosiding Konferensi Eropa Keduabelas tentang Sistem Komputer.  2017. hlm.  437-452. <br>  <strong>35.</strong> <em>Erik Bosman.</em>  Dedup Est Machina: Deduplikasi Memori sebagai Vektor Eksploitasi Tingkat Lanjut // Prosiding Simposium IEEE tentang Keamanan dan Privasi.  2016. hlm.  987-1004. <br>  <strong>36.</strong> <em>Evtyushkin, D., Ponomarev, D.</em> Melompati ASLR: Menyerang prediktor cabang untuk mem-bypass ASLR // Prosiding Simposium Internasional ke-49 tentang Mikroarsitektur.  2016. hlm.  1-13. <br>  <strong>37.</strong> <em>Daniel Gruss, Moritz Lipp.</em>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">KASLR is Dead: Long Live KASLR</a> .  2017 </p></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id455310/">https://habr.com/ru/post/id455310/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id455292/index.html">Cara 4 kali meningkatkan runtime perangkat dengan self-powered</a></li>
<li><a href="../id455294/index.html">Panduan: bagaimana memilih sepeda listrik menggunakan Twitter sebagai contoh - berbicara tentang bingkai</a></li>
<li><a href="../id455302/index.html">Kerangka API Golang</a></li>
<li><a href="../id455306/index.html">Jawaban atas pertanyaan Anda tentang mengapa Anda memerlukan penerbit untuk menerbitkan buku</a></li>
<li><a href="../id455308/index.html">Tempat yang menjanjikan</a></li>
<li><a href="../id455312/index.html">Satu-bit penambah penuh pada chip yang tidak biasa</a></li>
<li><a href="../id455314/index.html">Apa itu jaringan layanan</a></li>
<li><a href="../id455316/index.html">Kami memodifikasi tumpukan Bluetooth untuk meningkatkan suara pada headphone tanpa codec AAC, aptX dan LDAC</a></li>
<li><a href="../id455318/index.html">Apa saja area aplikasi pencetakan 3D?</a></li>
<li><a href="../id455319/index.html">Artis 3D alur kerja. Bagaimana tidak menenggelamkan banyak informasi. Bagian 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>