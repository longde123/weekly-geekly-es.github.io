<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎤 🗼 ➿ 10 ++ cara untuk bekerja dengan register perangkat keras di C ++ (misalnya, IAR dan Cortex M) 👧 ✋ 🔎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Fig. I. Kiyko 

 Kesehatan yang baik untuk semua! 

 Anda mungkin ingat anekdot berjanggut, dan mungkin kisah nyata tentang bagaimana seorang siswa di...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>10 ++ cara untuk bekerja dengan register perangkat keras di C ++ (misalnya, IAR dan Cortex M)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459204/"><img src="https://habrastorage.org/webt/fd/id/cl/fdidclwtjklierjxrqybnqmttui.jpeg" alt="Memilih jalur teraman"><br>  <sub><b>Fig.</b></sub>  <sub><b>I. Kiyko</b></sub> <br><br>  Kesehatan yang baik untuk semua! <br><br>  Anda mungkin ingat anekdot berjanggut, dan mungkin kisah nyata tentang bagaimana seorang siswa ditanyai tentang cara mengukur ketinggian bangunan menggunakan barometer.  Siswa tersebut mengutip, menurut pendapat saya, sekitar 20 atau 30 cara, tanpa menyebutkan langsung (melalui perbedaan tekanan) yang diharapkan oleh guru. <br><br>  Dalam nada yang kira-kira sama, saya ingin terus membahas penggunaan C ++ untuk mikrokontroler dan mempertimbangkan cara-cara bekerja dengan register menggunakan C ++.  Dan saya ingin mencatat bahwa untuk mencapai akses yang aman ke register tidak akan ada cara mudah.  Saya akan mencoba menunjukkan semua pro dan kontra dari metode ini.  Jika Anda tahu lebih banyak cara, lemparkan ke dalam komentar.  Jadi mari kita mulai: <br><a name="habracut"></a><br><h3>  Metode 1. Jelas dan jelas bukan yang terbaik </h3><br>  Metode yang paling umum, yang juga digunakan dalam C ++, adalah dengan menggunakan deskripsi struktur register dari file header dari pabrikan.  Untuk demonstrasi, saya akan mengambil dua register port A (ODR - register data output dan IDR - input data register) dari mikrokontroler STM32F411, sehingga saya dapat melakukan "menyulam" "Hello world" - mengedipkan LED. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ GPIOA-&gt;ODR ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) ; GPIOA-&gt;IDR ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) ; <span class="hljs-comment"><span class="hljs-comment">//,      }</span></span></code> </pre> <br>  Mari kita lihat apa yang terjadi di sini dan bagaimana desain ini bekerja.  Header mikroprosesor berisi struktur <code>GPIO_TypeDef</code> dan definisi pointer ke struktur <code>GPIOA</code> ini.  Ini terlihat seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> __IO <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> MODER; <span class="hljs-comment"><span class="hljs-comment">//port mode register, Address offset: 0x00 __IO uint32_t OTYPER; //port output type register, Address offset: 0x04 __IO uint32_t OSPEEDR; //port output speed register, Address offset: 0x08 __IO uint32_t PUPDR; //port pull-up/pull-down register, Address offset: 0x0C __IO uint32_t IDR; //port input data register, Address offset: 0x10 __IO uint32_t ODR; //port output data register, Address offset: 0x14 __IO uint32_t BSRR; //port bit set/reset register, Address offset: 0x18 __IO uint32_t LCKR; //port configuration lock register, Address offset: 0x1C __IO uint32_t AFR[2]; //alternate function registers, Address offset: 0x20-0x24 } GPIO_TypeDef; #define PERIPH_BASE 0x40000000U //Peripheral base address in the alias region #define AHB1PERIPH_BASE (PERIPH_BASE + 0x00020000U) #define GPIOA_BASE (AHB1PERIPH_BASE + 0x0000U) #define GPIOA ((GPIO_TypeDef *) GPIOA_BASE)</span></span></code> </pre><br>  Untuk membuatnya dalam kata-kata manusia yang sederhana, maka seluruh struktur tipe <code>GPIO_TypeDef</code> "meletakkan" di alamat <code>GPIOA_BASE</code> , dan ketika Anda merujuk ke bidang tertentu dari struktur, Anda pada dasarnya merujuk ke alamat struktur ini + mengimbangi ke elemen struktur ini.  Jika Anda menghapus <code>#define GPIOA</code> , maka kode akan terlihat seperti ini: <br><br><pre> <code class="cpp hljs">((GPIO_TypeDef *) GPIOA_BASE)-&gt;ODR ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) ; ((GPIO_TypeDef *) GPIOA_BASE)-&gt;IDR ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) ; <span class="hljs-comment"><span class="hljs-comment">//</span></span></code> </pre><br>  Sehubungan dengan bahasa pemrograman C ++, alamat integer dikonversi ke tipe pointer ke struktur <code>GPIO_TypeDef</code> .  Tetapi dalam C ++, ketika menggunakan konversi C, kompiler mencoba untuk melakukan konversi dalam urutan berikut: <br><br><ul><li>  const_cast </li><li>  static_cast </li><li>  static_cast di sebelah const_cast, </li><li>  reinterpret_cast </li><li>  reinterpret_cast di sebelah const_cast </li></ul><br>  yaitu  jika kompiler tidak dapat mengonversi jenis menggunakan const_cast, ia mencoba menerapkan static_cast dan sebagainya.  Akibatnya, panggilan: <br><br><pre> <code class="cpp hljs">((GPIO_TypeDef *) GPIOA_BASE)-&gt;ODR ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) ;</code> </pre> <br>  tidak ada yang seperti: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;GPIO_TypeDef *&gt; (GPIOA_BASE)-&gt;ODR ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) ;</code> </pre> <br>  Bahkan, untuk aplikasi C ++, akan benar untuk "menarik" struktur ke alamat seperti ini: <br><br><pre> <code class="cpp hljs">GPIO_TypeDef * GPIOA{<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;GPIO_TypeDef *&gt;(GPIOA_BASE)} ;</code> </pre> <br>  Bagaimanapun, karena konversi tipe, ada minus besar untuk pendekatan ini untuk C ++.  Ini terdiri dalam kenyataan bahwa <code>reinterpret_cast</code> tidak dapat digunakan baik dalam konstruktor dan fungsi <code>constexpr</code> , maupun dalam parameter template, dan ini secara signifikan mengurangi penggunaan fitur C ++ untuk mikrokontroler. <br>  Saya akan menjelaskan ini dengan contoh.  Adalah mungkin untuk melakukannya: <br><br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b; } ; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;Test* mystruct&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Geta</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mystruct-&gt;a; } Test test{<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Geta&lt;&amp;test&gt;() ; }</code> </pre><br>  Tapi Anda belum bisa melakukan ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;GPIO_TypeDef * mystruct&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">volatile</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetIdr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mystruct-&gt;IDR; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//GPIOA  reinterpret_cast&lt;GPIO_TypeDef *&gt; (GPIOA_BASE) //  ,        GetIdr&lt;GPIOA&gt;() ; // } //      : struct Port { constexpr Port(GPIO_TypeDef * ptr): port(*ptr) {} GPIO_TypeDef &amp; port ; } //  GPIOA  reinterpret_cast,   //  constexpr      constexpr Port portA{GPIOA}; //   </span></span></code> </pre><br>  Dengan demikian, penggunaan langsung dari pendekatan ini membebankan batasan yang signifikan pada penggunaan C ++.  Kami tidak akan dapat menemukan objek yang ingin menggunakan <code>GPIOA</code> di ROM menggunakan alat bahasa, dan kami tidak akan dapat mengambil keuntungan dari pemrograman program untuk objek seperti itu. <br>  Selain itu, secara umum, metode ini tidak aman (seperti yang dikatakan oleh mitra Barat kami).  Bagaimanapun, sangat mungkin untuk membuat beberapa NON-FUN <br>  Sehubungan dengan hal di atas, kami merangkum: <br><blockquote><h4>  Pro </h4><br><ul><li>  Judul dari pabrikan digunakan (diperiksa, tidak ada kesalahan) </li><li>  Tidak ada gerakan dan biaya tambahan, yang Anda ambil dan gunakan </li><li>  Kemudahan penggunaan </li><li>  Semua orang tahu dan mengerti metode ini. </li><li>  Tanpa overhead </li></ul><br><h4>  Cons </h4><br><ul><li>  Penggunaan metaprogramming terbatas </li><li>  Ketidakmampuan untuk digunakan dalam konstruktor constexpr </li><li>  Saat menggunakan pembungkus di kelas, konsumsi tambahan RAM adalah penunjuk ke objek struktur ini </li><li>  Kamu bisa bikin bodoh </li></ul></blockquote>  Sekarang mari kita lihat metode nomor 2 <br><br><h3>  Metode 2. Brutal </h3><br>  Jelas bahwa setiap programmer embed mengingat alamat semua register untuk semua mikrokontroler, sehingga Anda dapat selalu menggunakan metode berikut, yang mengikuti dari yang pertama: <br><br><pre> <code class="cpp hljs">*<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *&gt;(GpioaOdrAddr) ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt;<span class="hljs-number"><span class="hljs-number">5</span></span>) ; *<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *&gt;(GpioaIdrAddr) ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt;<span class="hljs-number"><span class="hljs-number">5</span></span>) ; <span class="hljs-comment"><span class="hljs-comment">//</span></span></code> </pre> <br>  Di mana saja dalam program ini, Anda selalu dapat memanggil konversi ke alamat register <code>volatile uint32_t</code> dan menginstal setidaknya sesuatu di sana. <br>  Terutama tidak ada nilai tambah di sini, tetapi untuk minus yang ada ditambahkan ketidaknyamanan untuk digunakan dan kebutuhan untuk menulis alamat masing-masing register dalam file terpisah sendiri.  Oleh karena itu, kita beralih ke metode nomor 3. <br><br><h3>  Metode 3. Jelas dan jelas lebih benar </h3><br>  Jika akses ke register terjadi melalui bidang struktur, maka alih-alih pointer ke objek struktur, Anda bisa menggunakan alamat struktur integer.  Alamat struktur ada di file header dari pabrikan (misalnya, GPIOA_BASE untuk GPIOA), jadi Anda tidak perlu mengingatnya, tetapi Anda bisa menggunakannya dalam template dan ekspresi constexpr, lalu "overlay" struktur ke alamat ini. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> pinNum&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pin</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Registers = GPIO_TypeDef ; __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Toggle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     addr Registers *GpioPort{reinterpret_cast&lt;Registers*&gt;(addr)}; GpioPort-&gt;ODR ^= (1 &lt;&lt; pinNum) ; } }; int main() { using Led1 = Pin&lt;GPIOA_BASE, 5&gt; ; Led1::Toggle() ; }</span></span></code> </pre><br>  Tidak ada minus khusus, dari sudut pandang saya.  Pada prinsipnya, opsi bekerja.  Tapi tetap saja, mari kita lihat cara lain. <br><br><h3>  Metode 4. Bungkus Eksoteris </h3><br>  Untuk penikmat kode yang dapat dimengerti, Anda dapat membuat pembungkus atas register sehingga nyaman untuk mengaksesnya dan terlihat “cantik”, membuat konstruktor, mendefinisikan kembali operator: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Register</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Register</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> addr)</span></span></span><span class="hljs-function"> : ptr</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *&gt;(addr) } { } __forceinline <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> Register&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>^=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> right) { *ptr ^= right; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *ptr; <span class="hljs-comment"><span class="hljs-comment">//    }; int main() { Register Odr{GpioaOdrAddr}; Odr ^= (1 &lt;&lt; 5); Register Idr{GpioaIdrAddr}; Idr ^= (1 &lt;&lt; 5); // }</span></span></code> </pre><br>  Seperti yang Anda lihat, sekali lagi Anda harus mengingat alamat integer dari semua register, atau mengaturnya di suatu tempat, dan Anda juga harus menyimpan pointer ke alamat register.  Tetapi apa yang tidak terlalu baik lagi, <code>reinterpret_cast</code> terjadi lagi di konstruktor <br>  Beberapa kelemahan, dan pada kenyataan bahwa dalam versi pertama dan kedua ada ditambahkan kebutuhan untuk setiap register yang digunakan untuk menyimpan pointer ke 4 byte dalam RAM.  Secara umum, bukan opsi.  Kami melihat yang berikut ini. <br><br><h3>  Metode 4,5.  Bungkus Eksoteris dengan Pola </h3><br>  Kami menambahkan butiran metaprogramming, tetapi tidak ada banyak manfaat dari ini.  Metode ini berbeda dari yang sebelumnya hanya dalam hal alamat ditransfer bukan ke konstruktor, tetapi dalam parameter templat, kami menyimpan sedikit pada register ketika meneruskan alamat ke konstruktor, itu sudah baik: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Register</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Register() : ptr{<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *&gt;(addr)} { } __forceinline <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> Register &amp;<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>^=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> right) { *ptr ^= right; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *ptr; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> GpioaOdr = Register&lt;GpioaOdrAddr&gt;; GpioaOdr Odr; Odr ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> GpioaIdr = Register&lt;GpioaIdrAddr&gt;; GpioaIdr Idr; Idr ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-comment"><span class="hljs-comment">// }</span></span></code> </pre><br>  Jadi, penggaruk yang sama, tampilan samping. <br><br><h3>  Metode 5. Masuk akal </h3><br>  Jelas, Anda harus menyingkirkan pointer, jadi mari kita lakukan hal yang sama, tetapi hapus pointer yang tidak perlu dari kelas. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Register</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: __forceinline Register &amp;<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>^=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> right) { *<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *&gt;(addr) ^= right; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } }; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> GpioaOdr = Register&lt;GpioaOdrAddr&gt;; GpioaOdr Odr; Odr ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> GpioaIdr = Register&lt;GpioaIdrAddr&gt;; GpioaIdr Idr; Idr ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-comment"><span class="hljs-comment">//</span></span></code> </pre><br>  Anda bisa tinggal di sini dan berpikir sedikit.  Metode ini segera memecahkan 2 masalah yang sebelumnya diwarisi dari metode pertama.  Pertama, sekarang saya bisa menggunakan pointer ke objek <code>Register</code> di template, dan kedua, saya bisa meneruskannya ke konstruktor <code>constexrp</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;Register * <span class="hljs-keyword"><span class="hljs-keyword">register</span></span>&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Xor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mask)</span></span></span><span class="hljs-function"> </span></span>{ *<span class="hljs-keyword"><span class="hljs-keyword">register</span></span> ^= mask ; } Register&lt;GpioaOdrAddr&gt; GpioaOdr; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Xor&lt;&amp;GpioaOdr&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) ; <span class="hljs-comment"><span class="hljs-comment">//  } //   struct Port { constexpr Port(Register&amp; ref): register(ref) {} Register &amp; register ; } constexpr Port portA{GpioaOdr};</span></span></code> </pre><br>  Tentu saja, perlu lagi, baik memiliki memori eidetik untuk alamat register, atau untuk secara manual menentukan semua alamat register di suatu tempat dalam file terpisah ... <br><blockquote><h4>  Pro </h4><br><ul><li>  Kemudahan penggunaan </li><li>  Kemampuan untuk menggunakan metaprogramming </li><li>  Kemampuan untuk digunakan dalam konstruktor constexpr </li></ul><br><h4>  Cons </h4><br><ul><li>  File header yang diverifikasi dari produsen tidak digunakan </li><li>  Anda harus mengatur sendiri semua alamat register </li><li>  Anda perlu membuat objek Daftar kelas </li><li>  Kamu bisa bikin bodoh </li></ul></blockquote><br>  Bagus, tapi masih banyak kekurangan ... <br><br><h3>  Metode 6. Lebih cerdas daripada masuk akal </h3><br>  Pada metode sebelumnya, untuk mengakses register itu perlu untuk membuat objek register ini, ini adalah pemborosan RAM dan ROM, jadi kami melakukan pembungkus dengan metode statis. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Register</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Xor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mask)</span></span></span><span class="hljs-function"> </span></span>{ *<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *&gt;(addr) ^= mask; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> Case6 ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Odr = Register&lt;GpioaOdrAddr&gt;; Odr::Xor(<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Idr = Register&lt;GpioaIdrAddr&gt;; Idr::Xor(<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-comment"><span class="hljs-comment">// }</span></span></code> </pre><br>  Satu tambah ditambahkan <br><blockquote><ul><li>  Tanpa overhead.  Kode ringkas cepat, sama seperti pada opsi 1 (Saat menggunakan pembungkus di kelas, tidak ada biaya RAM tambahan, karena objek tidak dibuat, tetapi metode statis digunakan tanpa membuat objek) </li></ul></blockquote>  Silakan ... <br><br><h3>  Metode 7. Hapus kebodohan </h3><br>  Jelas, saya selalu melakukan NON-LUCU dalam kode dan menulis sesuatu ke dalam register, yang sebenarnya tidak dimaksudkan untuk ditulis.  Tidak apa-apa, tentu saja, tetapi KEBODOHAN harus dilarang.  Mari kita dilarang melakukan omong kosong.  Untuk melakukan ini, kami memperkenalkan struktur tambahan: <br><br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WriteReg</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReadReg</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReadWriteReg</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> WriteReg, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ReadReg {};</code> </pre> <br>  Sekarang kita dapat mengatur register untuk ditulis, dan register itu hanya baca: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> RegisterType&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Register</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//       WriteReg,    // ,  ,       __forceinline template &lt;typename T = RegisterType, class = typename std::enable_if_t&lt;std::is_base_of&lt;WriteReg, T&gt;::value&gt;&gt; Register &amp;operator^=(const uint32_t right) { *reinterpret_cast&lt;volatile uint32_t *&gt;(addr) ^= right; return *this; } };</span></span></code> </pre><br>  Sekarang mari kita coba untuk mengkompilasi pengujian kami dan melihat bahwa tes tidak dikompilasi, karena operator <code>^=</code> untuk register <code>Idr</code> tidak ada: <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> GpioaOdr = Register&lt;GpioaOdrAddr, WriteReg&gt; ; GpioaOdr Odr ; Odr ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> GpioaIdr = Register&lt;GpioaIdrAddr, ReadReg&gt; ; GpioaIdr Idr ; Idr ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) ; <span class="hljs-comment"><span class="hljs-comment">//,  Idr    }</span></span></code> </pre> <br>  Jadi, sekarang ada lebih banyak ... <br><blockquote><h4>  Pro </h4><br><ul><li>  Kemudahan penggunaan </li><li>  Kemampuan untuk menggunakan metaprogramming </li><li>  Kemampuan untuk digunakan dalam konstruktor constexpr </li><li>  Kode ringkas cepat, sama seperti pada opsi 1 </li><li>  Saat menggunakan pembungkus di kelas, tidak ada biaya RAM tambahan, karena objek tidak dibuat, tetapi metode statis digunakan tanpa membuat objek </li><li>  Anda tidak bisa melakukan kebodohan </li></ul><br><h4>  Cons </h4><br><ul><li>  File header yang diverifikasi dari produsen tidak digunakan </li><li>  Anda harus mengatur sendiri semua alamat register </li><li>  Anda perlu membuat objek Daftar kelas </li></ul></blockquote><br>  Jadi mari kita hilangkan kesempatan untuk membuat kelas untuk menabung lebih banyak <br><br><h3>  Metode 8. Tanpa NONSENSE dan tanpa objek kelas </h3><br>  Kode segera: <br><br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WriteReg</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReadReg</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReadWriteReg</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> WriteReg, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ReadReg {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Register</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: __forceinline <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T1 = T, class = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_base_of&lt;WriteReg, T1&gt;::value&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Xor(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> mask) { *<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*&gt;(addr) ^= mask; } }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> main { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> GpioaOdr = Register&lt;GpioaOdrAddr, WriteReg&gt; ; GpioaOdr::Xor(<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> GpioaIdr = Register&lt;GpioaIdrAddr, ReadReg&gt; ; GpioaIdr::Xor(<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) ; <span class="hljs-comment"><span class="hljs-comment">//,  Idr    }</span></span></code> </pre><br>  Kami menambahkan satu lagi plus, kami tidak membuat objek.  Tapi lanjutkan, kita masih punya kontra <br><br><h3>  Metode 9. Metode 8 dengan integrasi struktur </h3><br>  Dalam metode sebelumnya, hanya case yang didefinisikan.  Tetapi dalam metode 1, semua register digabungkan ke dalam struktur sehingga Anda dapat dengan mudah mengaksesnya dengan modul.  Ayo lakukan ... <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> Case9 { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WriteReg</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReadReg</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReadWriteReg</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> WriteReg, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ReadReg {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Register</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: __forceinline <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T1 = T, class = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_base_of&lt;WriteReg, T1&gt;::value&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Xor(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> mask) { *<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*&gt;(addr) ^= mask; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Gpio</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Moder = Register&lt;addr, ReadWriteReg&gt;; <span class="hljs-comment"><span class="hljs-comment">//      using Otyper = Register&lt;addr + OtyperShift, ReadWriteReg&gt; ; using Ospeedr = Register&lt;addr + OspeedrShift,ReadWriteReg&gt; ; using Pupdr = Register&lt;addr + PupdrShift,ReadWriteReg&gt; ; using Idr = Register&lt;addr + IdrShift, ReadReg&gt; ; using Odr = Register&lt;addr + OdrShift, WriteReg&gt; ; }; int main() { using Gpioa = Gpio&lt;GPIOA_BASE&gt; ; Gpioa::Odr::Xor(1 &lt;&lt; 5) ; Gpioa::Idr::Xor((1 &lt;&lt; 5) ); //,  Idr    }</span></span></code> </pre><br>  Di sini kekurangannya adalah bahwa struktur harus didaftarkan kembali, dan offset semua register harus diingat dan ditentukan di suatu tempat.  Akan lebih baik jika offset ditetapkan oleh kompiler, dan bukan oleh orangnya, tetapi ini nanti, tetapi untuk saat ini kami akan mempertimbangkan metode menarik lain yang disarankan oleh rekan saya. <br><br><h3>  Metode 10. Bungkus register melalui pointer ke anggota struktur </h3><br>  Di sini kita menggunakan konsep seperti itu sebagai penunjuk ke anggota struktur dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">akses ke sana</a> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RegisterStructWrapper</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: __forceinline <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> P&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Xor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PT::*member, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mask)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;T*&gt;(addr)-&gt;*member ^= mask ; <span class="hljs-comment"><span class="hljs-comment">//   ,     . } } ; using GpioaWrapper = RegisterStructWrapper&lt;GPIOA_BASE, GPIO_TypeDef&gt; ; int main() { GpioaWrapper::Xor(&amp;GPIO_TypeDef::ODR, (1 &lt;&lt; 5)) ; GpioaWrapper::Xor(&amp;GPIO_TypeDef::IDR, (1 &lt;&lt; 5)) ; // return 0 ; }</span></span></code> </pre><br><blockquote><h4>  Pro </h4><br><ul><li>  Kemudahan penggunaan </li><li>  Kemampuan untuk menggunakan metaprogramming </li><li>  Kemampuan untuk digunakan dalam konstruktor constexpr </li><li>  Kode ringkas cepat, sama seperti pada opsi 1 </li><li>  Saat menggunakan pembungkus di kelas, tidak ada biaya RAM tambahan, karena objek tidak dibuat, tetapi metode statis digunakan tanpa membuat objek </li><li>  File header yang diverifikasi dari pabrik digunakan. </li><li>  Tidak perlu mengatur sendiri semua alamat register </li><li>  Tidak perlu membuat objek Daftar kelas </li></ul><br><h4>  Cons </h4><br><ul><li>  Anda dapat membuat Foolishness dan bahkan berspekulasi pada kelengkapan kode </li></ul></blockquote><br><h3>  Metode 10.5.  Gabungkan Metode 9 dan 10 </h3><br>  Untuk mengetahui pergeseran register relatif terhadap awal struktur, Anda dapat menggunakan pointer ke anggota struktur: <code>volatile uint32_t T::*member</code> , ia akan mengembalikan offset anggota struktur relatif ke permulaan dalam byte.  Misalnya, kami memiliki struktur <code>GPIO_TypeDef</code> , maka alamat <code>&amp;GPIO_TypeDef::ODR</code> akan menjadi 0x14. <br>  Kami mengalahkan peluang ini dan menghitung alamat register dari metode 9, menggunakan kompiler: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WriteReg</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReadReg</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReadWriteReg</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> WriteReg, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ReadReg {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> T::*member, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> RegType&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Register</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: __forceinline <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T1 = RegType, class = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_base_of&lt;WriteReg, T1&gt;::value&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Xor(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> mask) { <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;T*&gt;(addr)-&gt;*member ^= mask ; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Gpio</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Moder = Register&lt;addr, GPIO_TypeDef, &amp;GPIO_TypeDef::ODR, ReadWriteReg&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Otyper = Register&lt;addr, GPIO_TypeDef, &amp;GPIO_TypeDef::OTYPER, ReadWriteReg&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Ospeedr = Register&lt;addr, GPIO_TypeDef, &amp;GPIO_TypeDef::OSPEEDR, ReadWriteReg&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pupdr = Register&lt;addr, GPIO_TypeDef, &amp;GPIO_TypeDef::PUPDR, ReadWriteReg&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Idr = Register&lt;addr, GPIO_TypeDef, &amp;GPIO_TypeDef::IDR, ReadReg&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Odr = Register&lt;addr, GPIO_TypeDef, &amp;GPIO_TypeDef::ODR, WriteReg&gt;; } ;</code> </pre> <br>  Anda dapat bekerja dengan register secara lebih eksotis: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> Case11 ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Gpioa = Gpio&lt;GPIOA_BASE, GPIO_TypeDef&gt; ; Gpioa::Odr::Xor(<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) ; <span class="hljs-comment"><span class="hljs-comment">//Gpioa::Idr::Xor((1 &lt;&lt; 5) ); //,  Idr   </span></span></code> </pre> <br>  Jelas, di sini semua struktur harus ditulis ulang lagi.  Ini dapat dilakukan secara otomatis, dengan beberapa skrip di Phyton, pada input seperti stm32f411xe.h pada output file Anda dengan struktur untuk digunakan dalam C ++. <br>  Bagaimanapun, ada beberapa cara berbeda yang dapat bekerja dalam proyek tertentu. <br><br><h3>  Bonus  Kami memperkenalkan ekstensi bahasa dan kode parsim menggunakan Phyton </h3><br>  Masalah bekerja dengan register di C ++ telah ada selama beberapa waktu.  Orang menyelesaikannya dengan cara yang berbeda.  Tentu saja akan lebih bagus jika bahasa tersebut mendukung sesuatu seperti mengganti nama kelas pada waktu kompilasi.  Nah, katakanlah, bagaimana jika seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;classname = [PortName]&gt; class Gpio[Portname] { __forceinline <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Xor(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> mask) { GPIO[PortName]-&gt;ODR ^= mask ; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> GpioA = Gpio&lt;<span class="hljs-string"><span class="hljs-string">"A"</span></span>&gt; ; GpioA::Xor(<span class="hljs-number"><span class="hljs-number">5</span></span>) ; }</code> </pre><br>  Namun sayangnya bahasa ini tidak mendukung.  Oleh karena itu, solusi yang digunakan orang adalah parsing code menggunakan Python.  Yaitu  beberapa ekstensi bahasa diperkenalkan.  Kode, menggunakan ekstensi ini, diumpankan ke pengurai Python, yang menerjemahkannya ke dalam kode C ++.  Kode seperti ini terlihat seperti ini: (contoh diambil dari perpustakaan modm; <a href="">berikut adalah sumber lengkapnya</a> ): <br><br><pre> <code class="cpp hljs">%% <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> port = gpio[<span class="hljs-string"><span class="hljs-string">"port"</span></span>] | upper %% <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> reg = <span class="hljs-string"><span class="hljs-string">"GPIO"</span></span> ~ port %% <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> pin = gpio[<span class="hljs-string"><span class="hljs-string">"pin"</span></span>] class Gpio{{ port ~ pin }} : <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Gpio { __forceinline <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Xor() { GPIO{{port}}-&gt;ODR ^= <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; {{pin}} ; } } <span class="hljs-comment"><span class="hljs-comment">//        class Gpio5 : public Gpio { __forceinline inline static void Xor() { GPIO-&gt;ODR ^= 1 &lt;&lt; 5 ; } } //     using Led = Gpio5; Led::Xor();</span></span></code> </pre><br><br><h3>  Perbarui: Bonus.  File dan parser SVD di Phyton </h3><br>  Lupa menambahkan opsi lain.  ARM merilis file deskripsi register untuk setiap produsen SVD.  Dari mana Anda kemudian dapat menghasilkan file C ++ dengan deskripsi register.  Paul Osborne telah mengompilasi semua file ini di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> .  Dia juga menulis skrip Python untuk mengurai mereka. <br><br>  Itu saja ... imajinasiku habis.  Jika Anda masih punya ide, silakan saja.  Contoh dengan semua metode ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini.</a> <br><br><h4>  Referensi </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Akses Register Typesafe di C ++</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Membuat hal-hal melakukan hal -Aksesoris hardware dari C ++</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Membuat sesuatu berfungsi - Bagian 3</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Membuat hal-hal dilakukan- Struktur overlay</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id459204/">https://habr.com/ru/post/id459204/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id459184/index.html">Keterampilan Persatuan Dasar</a></li>
<li><a href="../id459188/index.html">Debian 10 Buster dan Linux 5.2 Dirilis</a></li>
<li><a href="../id459194/index.html">Bagaimana kami berteman dengan SCSS dengan Variabel CSS menggunakan Tema UI Kit</a></li>
<li><a href="../id459196/index.html">Dari monolit ke tim modular</a></li>
<li><a href="../id459198/index.html">Analisis kinerja kueri di ClickHouse. Laporan Yandex</a></li>
<li><a href="../id459206/index.html">9 tahun dalam monolit di Node.JS</a></li>
<li><a href="../id459208/index.html">Berjalan dengan prostesis: Simulasi Nekstgen tentang gerakan manusia menggunakan otot, tulang, dan jaringan saraf</a></li>
<li><a href="../id459212/index.html">Implementasi properti di C ++</a></li>
<li><a href="../id459214/index.html">Toleransi kesalahan dalam penyimpanan Qsan</a></li>
<li><a href="../id459216/index.html">Struktur data B-tree</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>