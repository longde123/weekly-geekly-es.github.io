<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔖 🤚 🍁 Testserver für das Entwicklungsteam 🕎 🏂🏿 🗜️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! In diesem Artikel möchte ich die Erfahrungen mit der Bereitstellung eines Testservers für das Entwicklungsteam teilen. Kurz die Essenz des...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Testserver für das Entwicklungsteam</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426319/">  Hallo Habr!  In diesem Artikel möchte ich die Erfahrungen mit der Bereitstellung eines Testservers für das Entwicklungsteam teilen.  Kurz die Essenz des Problems - es gibt ein Entwicklungsteam und mehrere Projekte in PHP.  Während es nur wenige von uns gab und das Projekt im Wesentlichen eines war, verwendeten wir 1 Testserver. Um dem Kunden die Aufgabe zu zeigen, „spaltete“ der Entwickler den Server für eine bestimmte Zeit.  Wenn es nicht rechtzeitig „Fenster“ gab, mussten wir warten.  Im Laufe der Zeit nahmen das Team und die Komplexität der Aufgaben zu, die Überprüfungszeit und die Geschäftigkeit des Testservers nahmen zu, was sich negativ auf die Vorlaufzeit und den Bonus auswirkte.  Deshalb musste ich nach einer Lösung suchen und sie ist unter dem Schnitt. <br><a name="habracut"></a><br><h3>  Einführung </h3><br>  Was war: <br><br><ol><li>  Ein Testserver </li><li>  Gitlab und Redmine auf einem anderen Server </li><li>  Wunsch, ein Problem zu lösen </li></ol><br>  Alle Server befinden sich in unserem lokalen Netzwerk, der Testserver ist von außen nicht zugänglich. <br><br>  Was war erforderlich: <br><br><ol><li>  Möglichkeit, mehrere Projekte / Zweige gleichzeitig zu testen </li><li>  Der Entwickler kann zum Server gehen, ihn einrichten und nichts von anderen trennen </li><li>  Alles sollte so bequem wie möglich sein und auf einer Taste erledigt werden, vorzugsweise von Gitlab (CI / CD). </li></ol><br><h3>  Entscheidungsmöglichkeiten </h3><br><h4>  1. Ein Server, viele Hosts </h4><br>  Die einfachste Option.  Wir verwenden denselben Testserver. Nur der Entwickler muss für jeden Zweig / jedes Projekt einen Host erstellen und ihn der Konfiguration von nginx / apache2 hinzufügen. <br><br>  Vorteile: <br><br><ol><li>  Schnell und jeder versteht </li><li>  Kann automatisieren </li></ol><br>  Nachteile: <br><br><ol><li>  Klausel 2 der Anforderungen ist nicht erfüllt - der Entwickler kann mit der Aktualisierung der Datenbank beginnen und unter bestimmten Umständen alles eingeben (Hi Andrey!) </li><li>  Ziemlich komplexe Automatisierung mit einer Reihe von Konfigurationsdateien </li></ol><br><h4>  2. An jeden Entwickler auf dem Server! </h4><br>  Ordnen Sie jedem Server zu, und der Entwickler ist für seine Wirtschaftlichkeit verantwortlich. <br><br>  Vorteile: <br><br><ol><li>  Der Entwickler kann den Server vollständig an Ihr Projekt anpassen </li></ol><br>  Nachteile: <br><br><ol><li>  Ziffer 2 der Anforderungen ist nicht erfüllt </li><li>  Teuer und Ressourcen können einfach untätig bleiben, während die Entwicklung läuft, und nicht testen </li><li>  Die Automatisierung ist aufgrund unterschiedlicher Server noch komplizierter als in Punkt 1 </li></ol><br><h4>  3. Containerisierung - Docker, Kubernetes </h4><br>  Diese Technologie dringt zunehmend in unser Leben ein.  Zu Hause benutze ich Docker schon lange für meine Projekte. <br><blockquote>  Docker ist eine Software zur Automatisierung der Bereitstellung und Verwaltung von Anwendungen in einer Virtualisierungsumgebung auf Betriebssystemebene.  Ermöglicht das "Packen" der Anwendung mit all ihren Umgebungen und Abhängigkeiten in einen Container, der auf jedes Linux-System mit Unterstützung von cgroups im Kernel portiert werden kann, und bietet außerdem eine Containerverwaltungsumgebung. </blockquote>  Vorteile: <br><br><ol><li>  Ein Server wird verwendet </li><li>  Alle Anforderungen sind erfüllt. </li></ol><br>  Nachteile: <br><br><ol><li>  Bilder und Behälter nehmen manchmal viel Platz ein. Sie müssen die bereits veralteten Kronen reinigen, um Platz freizugeben. </li></ol><br><h3>  Docker-Implementierung </h3><br>  Bei der Verwendung von gitlab, AutoDevOps, fielen mir sehr oft die Einstellungen von kubernetes auf.  Außerdem erzählen bärtige Männer in verschiedenen Meetups, wie cool sie mit Kubernetes arbeiten.  Aus diesem Grund wurde beschlossen, den Cluster in seinen Einrichtungen bereitzustellen. Der Server wurde angefordert (und Sie können den Test nicht berühren, die Leute testen dort), und er wurde gestartet. <br><br>  Da ich Erfahrung mit kubernetes 0 habe, wurde alles gemäß dem Handbuch durchgeführt, um zu verstehen, wie all diese Cluster funktionieren.  Nach einiger Zeit gelang es mir, den Cluster zu erhöhen, aber dann gab es Probleme mit Zertifikaten, Schlüsseln und tatsächlich mit der Schwierigkeit der Bereitstellung.  Ich brauchte eine einfachere Lösung, um meinen Kollegen den Umgang damit beizubringen (zum Beispiel möchte ich nicht denselben Urlaub auf Skype verbringen und bei der Einrichtung helfen).  Deshalb wurde kubernetes allein gelassen.  Docker selbst blieb und es war notwendig, eine Lösung für das Container-Routing zu finden.  Da sie an verschiedenen Ports abgeholt werden könnten, könnte derselbe Nginx für die interne Umleitung verwendet werden.  Dies wird als Reverse-Proxy-Server bezeichnet. <br><blockquote>  Ein Reverse-Proxy-Server ist eine Art Proxy-Server, der Client-Anforderungen von einem externen Netzwerk an einen oder mehrere Server weiterleitet, die sich logisch im internen Netzwerk befinden.  Gleichzeitig sieht es für den Client so aus, als ob sich die angeforderten Ressourcen direkt auf dem Proxyserver befinden. </blockquote><h4>  Reverse Proxy </h4><br>  Um das Rad nicht neu zu erfinden, suchte ich nach vorgefertigten Lösungen.  Und es wurde gefunden - das ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Traefik</a> . <br><br>  Træfik ist ein moderner HTTP-Reverse-Proxy und Load Balancer, der die Bereitstellung von Microservices vereinfacht.  Træfik lässt sich in vorhandene Infrastrukturkomponenten (Docker, Schwarmmodus, Kubernetes, Marathon, Konsul, usw., Rancher, Amazon ECS usw.) integrieren und wird automatisch und dynamisch konfiguriert.  Um mit Docker arbeiten zu können, müssen Sie nur den Socket angeben und fertig. Dann findet Træfik selbst alle Container und leitet sie weiter (weitere Informationen finden Sie unter „Packen von Anwendungen in Docker“). <br><br><div class="spoiler">  <b class="spoiler_title">Træfik Containerkonfiguration</b> <div class="spoiler_text">  Ich starte es über docker-compose.yml <br><br><pre><code class="hljs delphi">version: <span class="hljs-string"><span class="hljs-string">'3'</span></span> services: traefik: image: traefik:latest # The official Traefik docker image command: --api --docker # Enables the web UI <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> tells Træfik <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> listen <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> docker ports: - <span class="hljs-number"><span class="hljs-number">443</span></span>:<span class="hljs-number"><span class="hljs-number">443</span></span> - <span class="hljs-number"><span class="hljs-number">80</span></span>:<span class="hljs-number"><span class="hljs-number">80</span></span> # The HTTP port - <span class="hljs-number"><span class="hljs-number">8080</span></span>:<span class="hljs-number"><span class="hljs-number">8080</span></span> # The Web UI (enabled by --api) volumes: - /<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/run/docker.sock:/<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/run/docker.sock # So that Traefik can listen <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the Docker events - /opt/traefik/traefik.toml:/traefik.toml - /opt/traefik/certs/:/certs/ networks: - proxy container_name: traefik restart: always networks: proxy: <span class="hljs-keyword"><span class="hljs-keyword">external</span></span>: true</code> </pre> <br></div></div><br>  Hier informieren wir den Proxy, dass wir die Ports 80, 443 und 8080 (das Webface des Proxys) abhören, den Docker-Socket, die Konfigurationsdatei und den Zertifikatordner bereitstellen müssen.  Um die Benennung von Testseiten zu vereinfachen, haben wir beschlossen, eine lokale Domänenzone * .test zu erstellen.  Wenn der Benutzer auf eine Site darauf zugreift, gelangt er zu unserem Testserver.  Daher sind die Zertifikate im Ordner "traefik" selbstsigniert, unterstützen jedoch "Let's Encrypt". <br><br>  Zertifikatserstellung <br><br><pre> <code class="bash hljs">openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout domain.key -out domain.crt</code> </pre> <br>  Bevor Sie beginnen, müssen Sie im Docker ein Proxy-Netzwerk erstellen (Sie können es selbst benennen). <br><br><pre> <code class="bash hljs">docker network create proxy</code> </pre> <br>  Dies wird das Netzwerk für die Verbindung von Traefik mit Containern von PHP-Sites sein.  Daher geben wir es im Netzwerkparameter des Dienstes und in den Netzwerken der gesamten Datei an, indem wir im Parameter external: true angeben. <br><br><div class="spoiler">  <b class="spoiler_title">Traefik.toml-Datei</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">debug</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> logLevel = "DEBUG" defaultEntryPoints = ["https","http"] #  insecureSkipVerify = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> #   [entryPoints] [entryPoints.http] address = ":80" [entryPoints.https] address = ":443" [entryPoints.https.tls] [docker] endpoint = "unix:///var/run/docker.sock" <span class="hljs-keyword"><span class="hljs-keyword">domain</span></span> = "docker.localhost" watch = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> exposedbydefault = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span></code> </pre> <br></div></div><br>  Hier ist alles ganz einfach - wir geben die Einstiegspunkte für den http- und https-Verkehr an. Vergessen Sie nicht, unsicher zu setzen. SkipVerify = true, wenn die Zertifikate lokal sind.  Im Abschnitt entryPoints.https.tls können Sie keine Zertifikate angeben. Anschließend ersetzt traefik das Zertifikat. <br><br>  Sie können den Dienst starten <br><br><pre> <code class="bash hljs">docker-compose up -d</code> </pre> <br>  Wenn Sie zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">site.test</a> gehen, wird ein 404-Fehler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">angezeigt</a> , da diese Domain an keinen Container gebunden ist. <br><br><h4>  Wir packen Anwendungen in Docker </h4><br>  Jetzt müssen Sie den Container mit der Anwendung konfigurieren, nämlich: <br><br>  1. Geben Sie ein Proxy-Netzwerk in den Netzwerken an <br>  2. Fügen Sie Etiketten mit Traefik-Konfiguration hinzu <br><br>  Unten finden Sie die Konfiguration einer der Anwendungen <br><br><div class="spoiler">  <b class="spoiler_title">docker-compose.yml-Anwendungen</b> <div class="spoiler_text"><pre> <code class="hljs kotlin">version: <span class="hljs-string"><span class="hljs-string">'3'</span></span> services: app: build: <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>/docker/php #   restart: always working_dir: /<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/www/html/<span class="hljs-keyword"><span class="hljs-keyword">public</span></span> volumes: - ./:/<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/www/html #    - /home/develop/site-files/f:/<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/www/html/<span class="hljs-keyword"><span class="hljs-keyword">public</span></span>/f #       links: - mailcatcher - memcached - mysql labels: - traefik.enabled=<span class="hljs-literal"><span class="hljs-literal">true</span></span> - traefik.frontend.rule=Host:TEST_DOMAIN,crm.TEST_DOMAIN,bonus.TEST_DOMAIN - traefik.docker.network=proxy - traefik.port=<span class="hljs-number"><span class="hljs-number">443</span></span> - traefik.protocol=https networks: - proxy - <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> mailcatcher: image: schickling/mailcatcher:latest restart: always memcached: image: memcached restart: always mysql: image: mysql:<span class="hljs-number"><span class="hljs-number">5.7</span></span> restart: always command: --max_allowed_packet=<span class="hljs-number"><span class="hljs-number">902505856</span></span> --sql-mode=<span class="hljs-string"><span class="hljs-string">""</span></span> environment: MYSQL_ROOT_PASSWORD: <span class="hljs-number"><span class="hljs-number">12345</span></span> MYSQL_DATABASE: site volumes: - ./<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>/cache/mysql-db:/<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/lib/mysql #      phpmyadmin: image: phpmyadmin/phpmyadmin restart: always links: - mysql environment: MYSQL_USERNAME: root MYSQL_ROOT_PASSWORD: <span class="hljs-number"><span class="hljs-number">12345</span></span> PMA_ARBITRARY: <span class="hljs-number"><span class="hljs-number">1</span></span> PMA_HOST: mysql_1 labels: - traefik.enabled=<span class="hljs-literal"><span class="hljs-literal">true</span></span> - traefik.frontend.rule=Host:pma.TEST_DOMAIN - traefik.docker.network=proxy - traefik.port=<span class="hljs-number"><span class="hljs-number">80</span></span> - traefik.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>.protocol=http networks: - proxy - <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> networks: proxy: <span class="hljs-keyword"><span class="hljs-keyword">external</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre><br></div></div><br>  Im App-Dienst müssen Sie im Netzwerkbereich Proxy und Standard angeben. Dies bedeutet, dass es in zwei Netzwerken verfügbar ist. Wie aus der Konfiguration hervorgeht, leite ich keine Ports nach außen weiter, alles geht im Netzwerk. <br><br>  Konfigurieren Sie als Nächstes die Beschriftungen <br><br><pre> <code class="hljs 1c"> - traefik.enabled=true <span class="hljs-meta"><span class="hljs-meta"># traefik </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta">   - traefik.frontend.rule=Host:TEST_DOMAIN,crm.TEST_DOMAIN,bonus.TEST_DOMAIN #  </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta">  traefik     - traefik.docker.network=proxy # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta">  - traefik.port=443 #, </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta">    ssl   80   http - traefik.protocol=https #  #  phpmyadmin   http </span></span></code> </pre><br>  Geben Sie im Abschnitt Allgemeine Netzwerke external: true an <br><br>  Die Konstante TEST_DOMAIN muss durch eine Domäne ersetzt werden, z. B. site.test <br><br>  Starten Sie die Anwendung <br><br><pre> <code class="bash hljs">docker-compose up -d</code> </pre> <br>  Wenn Sie nun zu den Domains site.test, crm.site.test, Bonus.site.test gehen, können Sie die Arbeitswebsite sehen.  Und auf der Domain pma.site.test gibt es phpmyadmin für die bequeme Arbeit mit der Datenbank. <br><br><h4>  Konfigurieren Sie GitLab </h4><br>  Wir erstellen einen Task-Handler, für den wir ausführen <br><br><pre> <code class="bash hljs">gitlab-runner register</code> </pre> <br>  Wir geben die gitlab-URL, das Token und die Ausführung der Aufgabe an (Executoren).  Da sich mein Test und mein Gitlab auf verschiedenen Servern befinden, wähle ich ssh executor aus.  Sie müssen die Serveradresse und das Login / Passwort für die Verbindung über ssh angeben. <br><br>  Runner kann an ein oder mehrere Projekte angehängt werden.  Da meine Arbeitslogik überall gleich ist, wurde ein gemeinsamer Läufer erstellt (für alle Projekte gleich). <br>  Der letzte Schliff ist das Erstellen einer CI-Konfigurationsdatei <br><br><div class="spoiler">  <b class="spoiler_title">.gitlab-ci.yml</b> <div class="spoiler_text"><pre> <code class="hljs smalltalk">stages: - build - clear #  develop build_develop: stage: build #   build tags: #     - ssh-develop environment: # ,       -   name: review/<span class="hljs-string"><span class="hljs-string">$C</span></span>I_BUILD_REF_NAME #  url: https://site<span class="hljs-string"><span class="hljs-string">$C</span></span>I_PIPELINE_ID.test <span class="hljs-symbol"><span class="hljs-symbol">#url</span></span>     on_stop: clear when: manual script: - cd ../ &amp;&amp; cp -r <span class="hljs-string"><span class="hljs-string">$C</span></span>I_PROJECT_NAME <span class="hljs-string"><span class="hljs-string">$C</span></span>I_PIPELINE_ID &amp;&amp; cd <span class="hljs-string"><span class="hljs-string">$C</span></span>I_PIPELINE_ID #     - cp -r /home/develop/site-files/.ssh data/docker/php/.ssh #  ssh - sed -i -e <span class="hljs-comment"><span class="hljs-comment">"s/TEST_DOMAIN/site$CI_PIPELINE_ID.test/g"</span></span> docker-compose.yml #   - docker-compose down #   - docker-compose up -d --build #  - script -q -c <span class="hljs-comment"><span class="hljs-comment">"docker exec -it ${CI_PIPELINE_ID}_app_1 bash -c \"</span></span>cd ../ &amp;&amp; php composer.phar install --prefer-dist \<span class="hljs-comment"><span class="hljs-comment">""</span></span> #   - script -q -c <span class="hljs-comment"><span class="hljs-comment">"docker exec -it ${CI_PIPELINE_ID}_app_1 bash -c \"</span></span>cd ../ &amp;&amp; php composer.phar first-install <span class="hljs-string"><span class="hljs-string">$C</span></span>I_PIPELINE_ID\<span class="hljs-comment"><span class="hljs-comment">""</span></span> #     #  production build_prod: stage: build tags: - ssh-develop environment: name: review/<span class="hljs-string"><span class="hljs-string">$C</span></span>I_BUILD_REF_NAME url: https://site<span class="hljs-string"><span class="hljs-string">$C</span></span>I_PIPELINE_ID.test on_stop: clear when: manual script: - cd ../ &amp;&amp; cp -r <span class="hljs-string"><span class="hljs-string">$C</span></span>I_PROJECT_NAME <span class="hljs-string"><span class="hljs-string">$C</span></span>I_PIPELINE_ID &amp;&amp; cd <span class="hljs-string"><span class="hljs-string">$C</span></span>I_PIPELINE_ID - cp -r /home/develop/site-files/.ssh data/docker/php/.ssh #  ssh - docker-compose down - docker-compose up -d --build - script -q -c <span class="hljs-comment"><span class="hljs-comment">"docker exec -it ${CI_PIPELINE_ID}_app_1 bash -c \"</span></span>cd ../ &amp;&amp; php composer.phar install --prefer-dist --no-dev\<span class="hljs-comment"><span class="hljs-comment">""</span></span> - script -q -c <span class="hljs-comment"><span class="hljs-comment">"docker exec -it ${CI_PIPELINE_ID}_app_1 bash -c \"</span></span>cd ../ &amp;&amp; php composer.phar first-install <span class="hljs-string"><span class="hljs-string">$C</span></span>I_PIPELINE_ID\<span class="hljs-comment"><span class="hljs-comment">""</span></span> clear: stage: clear tags: - ssh-develop environment: name: review/<span class="hljs-string"><span class="hljs-string">$C</span></span>I_BUILD_REF_NAME action: stop script: - cd ../ &amp;&amp; cd <span class="hljs-string"><span class="hljs-string">$C</span></span>I_PIPELINE_ID &amp;&amp; docker-compose down &amp;&amp; cd ../ &amp;&amp; echo password | sudo -<span class="hljs-type"><span class="hljs-type">S</span></span> rm -rf <span class="hljs-string"><span class="hljs-string">$C</span></span>I_PIPELINE_ID #       when: manual</code> </pre><br></div></div><br>  In dieser Konfiguration werden 2 Stufen beschrieben - Erstellen und Löschen.  Die Erstellungsphase hat zwei Optionen - build_develop und build_prod <br><br><img src="https://habrastorage.org/webt/yz/ut/dy/yzutdyyknwjgwbcg4-kj2ssv-f8.png"><br><br>  Gitlab erstellt ein verständliches Prozessablaufdiagramm.  In meinem Beispiel werden alle Prozesse manuell gestartet (wenn: manueller Parameter).  Dies geschieht, damit der Entwickler nach der Bereitstellung der Testwebsite seine Änderungen in den Container ziehen kann, ohne den gesamten Container neu zu erstellen.  Ein weiterer Grund ist der Domänenname - Site $ CI_PIPELINE_ID.test, wobei CI_PIPELINE_ID die Nummer des Prozesses ist, der die Assembly gestartet hat.  Das heißt, sie haben die Site mit der Domain site123.test zur Überprüfung eingereicht, und um heiße Änderungen vorzunehmen, schüttet der Entwickler die Änderungen sofort in den Container. <br><br>  Eine kleine Funktion von ssh executor.  Bei Verbindung mit dem Server wird ein Ordner des Formulars erstellt. <br><br><pre> <code class="bash hljs">/home//builds/_runner/0/_/_</code> </pre> <br>  Daher wurde eine Zeile hinzugefügt <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ../ &amp;&amp; cp -r <span class="hljs-variable"><span class="hljs-variable">$CI_PROJECT_NAME</span></span> <span class="hljs-variable"><span class="hljs-variable">$CI_PIPELINE_ID</span></span> &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> <span class="hljs-variable"><span class="hljs-variable">$CI_PIPELINE_ID</span></span></code> </pre> <br>  Darin gehen wir zum obigen Ordner und kopieren das Projekt in den Ordner mit der Prozessnummer.  Sie können also mehrere Zweige eines Projekts bereitstellen.  In den Einstellungen des Handlers müssen Sie jedoch die Option Für aktuelle Projekte sperren aktivieren, damit der Handler nicht versucht, mehrere Zweige gleichzeitig zu erweitern. <br><br>  Die Löschphase stoppt die Container und löscht den Ordner. Möglicherweise benötigen Sie Root-Rechte. Daher verwenden wir das Echo-Passwort |  sudo -S rm wobei Passwort Ihr Passwort ist. <br><br><h4>  Müllabfuhr </h4><br>  Von Zeit zu Zeit müssen Sie nicht verwendete Container entfernen, um keinen Platz zu beanspruchen. Dazu hängt ein Skript mit solchen Inhalten in der Krone <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash #   : docker ps --filter status=dead --filter status=exited -aq | xargs -r docker rm -v #   : yes | docker container prune #    : yes | docker image prune #    : yes | docker volume prune</span></span></code> </pre> <br>  einmal am Tag durchgeführt. <br><br><h3>  Fazit </h3><br>  Diese Lösung hat uns geholfen, das Testen und Freigeben neuer Funktionen erheblich zu optimieren.  Konstruktionskritisch wird akzeptiert, um Fragen zu beantworten. <br><br><h3>  Bonus </h3><br>  Um nicht jedes Mal Bilder aus der Docker-Datei zu erfassen, können Sie diese in der lokalen Docker-Registrierung speichern. <br><br><div class="spoiler">  <b class="spoiler_title">Datei docker-compose.yml</b> <div class="spoiler_text"><pre> <code class="hljs powershell">registry: restart: always image: registry:<span class="hljs-number"><span class="hljs-number">2</span></span> ports: - <span class="hljs-number"><span class="hljs-number">5000</span></span>:<span class="hljs-number"><span class="hljs-number">5000</span></span> volumes: - /opt/docker<span class="hljs-literal"><span class="hljs-literal">-registry</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>:/var/lib/registry <span class="hljs-comment"><span class="hljs-comment">#    </span></span></code> </pre><br></div></div><br>  Diese Option verwendet keine Authentifizierung. Dies ist kein sicherer Weg (!!!), eignet sich jedoch zum Speichern nicht kritischer Bilder. <br><br>  Sie können gitlab für die Anzeige konfigurieren <br><br><pre> <code class="bash hljs"> gitlab_rails[<span class="hljs-string"><span class="hljs-string">'registry_enabled'</span></span>] = <span class="hljs-literal"><span class="hljs-literal">true</span></span> gitlab_rails[<span class="hljs-string"><span class="hljs-string">'registry_host'</span></span>] = <span class="hljs-string"><span class="hljs-string">"registry.test"</span></span> gitlab_rails[<span class="hljs-string"><span class="hljs-string">'registry_port'</span></span>] = <span class="hljs-string"><span class="hljs-string">"5000"</span></span></code> </pre><br>  Danach erscheint eine Liste von Bildern in gitlab <br><br><img src="https://habrastorage.org/webt/lu/hn/8i/luhn8ilow44doqm5btrtafgv-hq.png"></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de426319/">https://habr.com/ru/post/de426319/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426305/index.html">Arbeite mit Charakterstatus. Einheitsexperimente</a></li>
<li><a href="../de426311/index.html">BLACK HAT USA Konferenz. Botnet von einer Million Browsern. Teil 2</a></li>
<li><a href="../de426313/index.html">Neues Microsoft Learn</a></li>
<li><a href="../de426315/index.html">Wie kann man mit dem unsichtbaren Internet Python-Freunde finden? Die Grundlagen der Entwicklung von I2P-Anwendungen in Python und Asyncio</a></li>
<li><a href="../de426317/index.html">1155 vs 2011. Einige alte Leute ziehen in die Schlacht</a></li>
<li><a href="../de426323/index.html">Ein Versuch, einen Roboterkoffer mit einem begrenzten Budget herzustellen. Glasmatte und Epoxid</a></li>
<li><a href="../de426325/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 12: Netzwerksicherheit, Teil 1</a></li>
<li><a href="../de426327/index.html">Was ist neu in Windows 10 Oktober 2018 Update</a></li>
<li><a href="../de426331/index.html">Sicherheitslücke in PlayStation 4 - Der Zeichensatz in der Nachricht für den Benutzer aus der Ferne verwandelt die Konsole in fast einen "Baustein".</a></li>
<li><a href="../de426333/index.html">Microsoft hat MS-DOS 1.25- und 2.0-Code unter der MIT-Lizenz veröffentlicht</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>