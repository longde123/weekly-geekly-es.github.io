<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧛🏻 🈴 🍀 Por que o Kubernetes é tão complicado com repositórios? 👩🏻‍🚒 🔓 🥨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quando os orquestradores de contêineres como o Kubernetes chegaram, a abordagem para desenvolver e implantar aplicativos mudou drasticamente. Aparecer...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Por que o Kubernetes é tão complicado com repositórios?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/441222/"><p><img src="https://habrastorage.org/webt/3w/v4/sh/3wv4sha9sfamx7elh4imtocvesm.jpeg"></p><br><p>  Quando os orquestradores de contêineres como o Kubernetes chegaram, a abordagem para desenvolver e implantar aplicativos mudou drasticamente.  Apareceram microsserviços e, para o desenvolvedor, a lógica do aplicativo não está mais conectada à infraestrutura: crie aplicativos para você e ofereça novas funções. </p><br><p>  O Kubernetes abstrai dos computadores físicos que controla.  Diga a ele quanta memória e capacidade de processamento você precisa - e você obterá tudo.  Infraestrutura?  Não, não ouvi. </p><br><p>  Gerenciar imagens do Docker, Kubernetes e aplicativos o torna portátil.  Tendo desenvolvido aplicativos de contêiner com o Kubernetes, você pode implantá-los em qualquer lugar: em uma nuvem aberta, localmente ou em um ambiente híbrido - sem alterar o código. </p><br><p>  Adoramos o Kubernetes por escalabilidade, portabilidade e capacidade de gerenciamento, mas ele não armazena o estado.  Mas temos quase todos os aplicativos com estado, ou seja, eles precisam de armazenamento externo. </p><a name="habracut"></a><br><p>  Kubernetes tem uma arquitetura muito dinâmica.  Os contêineres são criados e destruídos, dependendo da carga e das instruções dos desenvolvedores.  Vagens e recipientes são auto-reparáveis ​​e replicáveis.  Eles são essencialmente efêmeros. </p><br><p>  <strong>O armazenamento externo é muito difícil para essa variabilidade.</strong>  <strong>Não obedece às regras da criação e destruição dinâmicas.</strong> </p><br><p> Só é necessário implantar um aplicativo com estado em outra infraestrutura: em outra nuvem, local ou em um modelo híbrido - como ele tem problemas de portabilidade.  O armazenamento externo pode ser vinculado a uma nuvem específica. </p><br><p>  Mas somente nesses depósitos de aplicativos em nuvem o próprio diabo quebrará a perna.  E vá entender os significados fictícios e os significados da <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">terminologia</a></strong> de <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">armazenamento no Kubernetes</a></strong> .  E existem repositórios próprios da Kubernetes, plataformas de código aberto, serviços gerenciados ou pagos ... </p><br><p>  Aqui estão alguns exemplos <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">de armazenamento em nuvem CNCF</a></strong> : </p><br><p><img src="https://habrastorage.org/webt/cm/wl/ov/cmwlovlr6qt3qcicg0sm5acufvw.png"></p><br><p>  Parece que implantou o banco de dados no Kubernetes - você só precisa selecionar a solução apropriada, empacotá-lo em um contêiner para trabalhar no disco local e implantá-lo no cluster como a próxima carga de trabalho.  Mas o banco de dados tem suas próprias peculiaridades, portanto, pensar não é um gelo. </p><br><p>  Contêineres - eles são tão pavimentados que não preservam seu estado.  Por isso é tão fácil começar e parar.  E como não há nada para salvar e transferir, o cluster não se preocupa com as operações de leitura e cópia. </p><br><p>  Você precisará armazenar o estado no banco de dados.  Se um banco de dados implantado em um cluster em um contêiner não migra para lugar nenhum e não inicia com muita frequência, a física do armazenamento de dados entra em jogo.  Idealmente, os contêineres que usam dados devem estar no mesmo ambiente que o banco de dados. </p><br><p>  Em alguns casos, o banco de dados, é claro, pode ser implantado em um contêiner.  Em um ambiente de teste ou em tarefas em que há poucos dados, os bancos de dados vivem confortavelmente em clusters. </p><br><p>  <strong>A produção geralmente requer armazenamento externo.</strong> </p><br><p>  O Kubernetes se comunica com o repositório através de interfaces do plano de controle.  Eles vinculam o Kubernetes ao armazenamento externo.  O armazenamento externo anexado ao Kubernetes é chamado de plugins de volume.  Com eles, você pode abstrair o armazenamento e transferir o armazenamento. </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Os plug-ins de volume costumavam ser criados</a></strong> , vinculados, compilados e entregues usando a base de código do Kubernetes.  Isso limitou muito os desenvolvedores e exigiu manutenção adicional: se você deseja adicionar novos repositórios, altere a base de código do Kubernetes. </p><br><p>  Agora implante plugins de volume no cluster - não quero.  E você não precisa se aprofundar na base de código.  Agradecimentos a CSI e Flexvolume. </p><br><p><img src="https://habrastorage.org/webt/ug/r7/m4/ugr7m4uco1skczyasqf7xf3op3y.png"></p><br><h3 id="sobstvennoe-hranilische-kubernetes">  Armazenamento nativo do Kubernetes </h3><br><p>  Como o Kubernetes resolve problemas de armazenamento?  Existem várias soluções: opções efêmeras, armazenamento persistente em volumes persistentes, consultas de Reivindicação de Volume Persistente, classes de armazenamento ou StatefulSets.  Vá descobrir isso, em geral. </p><br><p>  Volumes Persistentes (PV) são unidades de armazenamento preparadas pelo administrador.  Eles não dependem de lares e de suas vidas fugazes. </p><br><p>  Reivindicação de volume persistente (PVC) são solicitações de armazenamento, ou seja, PV.  Com o PVC, você pode vincular o armazenamento a um nó, e este nó o utilizará. </p><br><p>  Você pode trabalhar com armazenamento estaticamente ou dinamicamente. </p><br><p>  Com uma abordagem estática, o administrador prepara PVs que devem ser veiculados antes, antes de solicitações, e esses PVs são vinculados manualmente a pods específicos usando PVCs explícitos. </p><br><p>  Na prática, PVs especialmente definidos não são compatíveis com a estrutura portátil do Kubernetes - o armazenamento depende do ambiente, como o AWS EBS ou uma unidade permanente GCE.  Para ligar manualmente, você precisa apontar para um repositório específico no arquivo YAML. </p><br><p>  A abordagem estática geralmente contradiz a filosofia do Kubernetes: CPUs e memória não são alocadas antecipadamente e não estão vinculadas a pods ou contêineres.  Eles são emitidos dinamicamente. </p><br><p>  Para provisionamento dinâmico, usamos classes de armazenamento.  O administrador do cluster não precisa criar o PV antecipadamente.  Ele cria vários perfis de armazenamento, como modelos.  Quando um desenvolvedor faz uma solicitação de PVC, no momento da solicitação, um desses padrões é criado e anexado à lareira. </p><br><p><img src="https://habrastorage.org/webt/id/9q/mj/id9qmjxqf7tqnki0xc_1a710seg.png"></p><br><p>  Portanto, nos termos mais gerais, o Kubernetes trabalha com armazenamento externo.  Existem muitas outras opções. </p><br><h3 id="csi--container-storage-interface">  CSI - Interface de armazenamento de contêineres </h3><br><p>  Existe uma coisa - <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Interface de Armazenamento de Contêiner</a></strong> .  O CSI foi criado pelo grupo de trabalho do cofre do CNCF, que decidiu definir uma interface de armazenamento de contêiner padrão para que os drivers do cofre trabalhassem com qualquer orquestra. </p><br><p>  As especificações da CSI já estão adaptadas para o Kubernetes e existem vários <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">plugins de driver</a></strong> para implantações no cluster Kubernetes.  Você deve acessar o repositório através de um driver de volume compatível com CSI - use o <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tipo de</a></strong> volume <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">csi</a></strong> no Kubernetes. </p><br><p>  Com o CSI, o armazenamento pode ser considerado outra carga de trabalho para conteinerização e implantação no cluster Kubernetes. </p><br><p>  Para mais detalhes, ouça <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Jie Yu falar sobre CSI em nosso podcast</a></strong> . </p><br><h3 id="opensors-proekty">  Projetos de código aberto </h3><br><p>  As ferramentas e os projetos das tecnologias em nuvem se multiplicam rapidamente, e uma boa parte dos projetos de código aberto - o que é lógico - resolve um dos principais problemas de produção: trabalhar com armazenamento na arquitetura em nuvem. </p><br><p>  Os mais populares deles são Ceph e Rook. </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O Ceph</a></strong> é um cluster de armazenamento distribuído gerenciado dinamicamente com escala horizontal.  O Ceph fornece uma abstração lógica para recursos de armazenamento.  Não possui um único ponto de falha, gerencia a si próprio e trabalha com base em software.  O Ceph fornece interfaces para armazenar blocos, objetos e arquivos simultaneamente para um único cluster de armazenamento. </p><br><p>  O Ceph possui uma arquitetura muito complexa com os algoritmos RADOS, librados, RADOSGW, RDB, CRUSH e vários componentes (monitores, OSD, MDS).  Não vamos nos aprofundar na arquitetura, basta entender que o Ceph é um cluster de armazenamento distribuído que simplifica a escalabilidade, elimina um único ponto de falha sem sacrificar o desempenho e fornece um único armazenamento com acesso a objetos, blocos e arquivos. </p><br><p>  Naturalmente, o Ceph é adaptado para a nuvem.  Você pode implantar um cluster Ceph de maneiras diferentes, por exemplo, usando Ansible ou em um cluster Kubernetes por meio de CSI e PVC. </p><br><p><img src="https://habrastorage.org/webt/g9/kn/ft/g9knft3jj1y3hw8u2v-4jzoa26k.png"><br>  <em>Arquitetura Ceph</em> </p><br><p>  Rook é outro projeto interessante e popular.  Ele combina o Kubernetes com sua computação e o Ceph com seus repositórios em um cluster. </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Rook</a></strong> é um orquestrador de armazenamento em nuvem que complementa o Kubernetes.  Eles empacotam o Ceph em contêineres e usam a lógica de gerenciamento de cluster para uma operação confiável do Ceph no Kubernetes.  O Rook automatiza a implantação, autoinicialização, ajuste, dimensionamento, reequilíbrio - em geral, tudo o que o administrador do cluster faz. </p><br><p>  Com o Rook, um cluster Ceph pode ser implantado no yaml, como o Kubernetes.  Neste arquivo, o administrador descreve o que ele precisa no cluster.  Rook inicia um cluster e começa a monitorar ativamente.  Isso é algo como um operador ou controlador - garante que todos os requisitos do yaml sejam atendidos.  Rook funciona com ciclos de sincronização - ele vê o estado e executa uma ação se houver desvios. </p><br><p>  Ele não tem seu estado permanente e não precisa ser controlado.  Está no espírito de Kubernetes. </p><br><p><img src="https://habrastorage.org/webt/ep/qx/qk/epqxqk5iecbwcekk88ac8tjxih4.png"></p><br><p>  Rook, combinando Ceph e Kubernetes, é uma das soluções de armazenamento em nuvem mais populares: 4.000 estrelas no Github, 16,3 milhões de downloads e mais de cem colaboradores. <br>  O projeto Rook já foi aceito no CNCF <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">e</a></strong> , <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">recentemente, acabou em uma incubadora</a></strong> . </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bassam Tabara</a></strong> lhe dirá mais sobre Rook <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">em nosso episódio do repositório Kubernetes</a></strong> . <br>  Se o aplicativo tiver um problema, você precisará descobrir os requisitos e criar um sistema ou usar as ferramentas necessárias.  Isso também se aplica ao armazenamento em nuvem.  E embora o problema não seja dos simples, as ferramentas e abordagens ficaram aquém.  A tecnologia em nuvem continua a evoluir e novas soluções certamente nos aguardam. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt441222/">https://habr.com/ru/post/pt441222/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt441212/index.html">Trabalhar com proteção de informações criptográficas e portadores de chaves de hardware no Linux</a></li>
<li><a href="../pt441214/index.html">Guia do Usuário Kibana. Visualização. Parte 1</a></li>
<li><a href="../pt441216/index.html">Espelho preto ou anúncio Picooc?</a></li>
<li><a href="../pt441218/index.html">OpenAI Gym + ROS + Gazebo: treinando um robô autônomo em casa. Parte 1</a></li>
<li><a href="../pt441220/index.html">Análise de recentes ataques em massa com captura de DNS</a></li>
<li><a href="../pt441224/index.html">Crie um exemplo do ARCore de faces aumentadas no Unity</a></li>
<li><a href="../pt441226/index.html">A Forbes publicou uma lista das empresas russas de Internet mais caras em 2019</a></li>
<li><a href="../pt441234/index.html">Efeitos de filtragem SVG. Parte 6. Criando texturas com feTurbulence</a></li>
<li><a href="../pt441236/index.html">Habraiting 2018: os melhores materiais para 2018</a></li>
<li><a href="../pt441238/index.html">Programação de inglês</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>