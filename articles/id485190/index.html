<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ“† â†ªï¸ ğŸ¤¸ğŸ» Andrew Eun "Gairah Belajar Mesin." Terjemahan bab 47-58 â˜ ï¸ ğŸ¤œğŸ½ ğŸ‘©ğŸ¾â€ğŸ¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ini adalah artikel kedua dengan terjemahan setiap bab dari buku Andrew Un, Passion for Machine Learning. Anda dapat membaca terjemahan dari bab-bab se...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Andrew Eun "Gairah Belajar Mesin." Terjemahan bab 47-58</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485190/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/4t/87/qr/4t87qrmbsuxfltahjbm9iunonx4.png"></div><br><br>  Ini adalah artikel kedua dengan terjemahan setiap bab dari buku Andrew Un, Passion for Machine Learning.  Anda dapat membaca terjemahan dari bab-bab sebelumnya di <a href="https://habr.com/ru/post/485070/">sini</a> . <br><br>  Artikel ini akan fokus pada pembelajaran mendalam end-to-end, serta penulis buku akan berbagi beberapa cara menganalisis kesalahan algoritma pembelajaran. <br><a name="habracut"></a><br><h1>  Pembelajaran mendalam end-to-end </h1><br><hr><h3>  <font color="#548dd4">Bab 47. Pertumbuhan pembelajaran ujung ke ujung</font> </h3><hr><br>  Misalkan Anda ingin membuat sistem untuk memeriksa ulasan produk di Internet, yang secara otomatis akan memberi tahu Anda jika penulis review menyukai produk ini atau tidak.  Misalnya, Anda berharap untuk mengenali ulasan berikut ini sebagai sangat positif: <br><br><ul><li>  "Ini pel luar biasa!" </li></ul><br>  dan berikut ini sangat negatif: <br><br><ul><li>  "Pel ini berkualitas buruk, maaf soal pembelian" </li></ul><br>  Masalah mengenali opini positif dan negatif disebut "klasifikasi suasana hati".  Untuk membuat sistem ini, Anda dapat membangun "jalur pipa" dari dua komponen: <br><br><ol><li>  <b>Parser</b> : <b>Suatu</b> sistem yang membubuhi keterangan teks dengan informasi, mengidentifikasi kata-kata yang paling penting.  <sup>1</sup> Misalnya, Anda dapat menggunakan parser untuk menunjukkan semua kata sifat dan kata benda.  Oleh karena itu, Anda akan menerima teks beranotasi berikut: <br><br><ul><li>  Ini pel luar biasa! </li></ul><br><blockquote>  <sup>1</sup> Sebenarnya, parser membuat anotasi teks jauh lebih kaya daripada yang dijelaskan, tetapi deskripsi yang disederhanakan ini akan cukup untuk menjelaskan pembelajaran mendalam dari ujung ke ujung. </blockquote><br></li><li>  <b>Sentiment Classifier</b> : algoritma pembelajaran yang mengambil input teks beranotasi dan memprediksi mood umumnya.  Anotasi Parser dapat sangat membantu algoritme ini: dengan memberi bobot lebih pada kata sifat, algoritme Anda dapat dengan cepat diingat dengan memproses kata-kata penting seperti "luar biasa" dan mengabaikan kata-kata yang kurang penting seperti "ini." </li></ol><br>  Kami dapat memvisualisasikan saluran pipa ini dari dua komponen sebagai berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zt/3f/wy/zt3fwy4_ibclomuquousi_mxe4m.png"></div><br><br>  Baru-baru ini, ada kecenderungan untuk mengganti pipa dengan algoritma pembelajaran tunggal.  Algoritme pembelajaran ujung-ke-ujung untuk tugas ini hanya akan mengambil teks asli dan mentah, "Ini pel yang hebat!" <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5l/eo/qv/5leoqvedvmnp8dr7fab15gz3n_e.png"></div><br><br>  Jaringan saraf umumnya digunakan dalam sistem pembelajaran ujung ke ujung.  Istilah "pass-through" mengacu pada fakta bahwa kami meminta algoritma pembelajaran untuk langsung dari input ke hasil yang diinginkan.  Artinya, algoritma pembelajaran secara langsung menghubungkan "ujung input" dari sistem dengan "ujung keluaran". <br><br>  Dalam tugas di mana ada banyak data, sistem end-to-end sangat sukses.  Tetapi mereka tidak selalu merupakan pilihan yang baik.  Beberapa bab berikutnya akan memberikan lebih banyak contoh sistem lintas sektoral, serta kiat tentang kapan dan kapan tidak menggunakannya. <br><br><hr><h3>  <font color="#548dd4">Bab 48. Contoh-Contoh Selanjutnya dari Pembelajaran Lintas Sektoral</font> </h3><hr><br>  Bayangkan Anda ingin membuat sistem pengenalan ucapan.  Anda dapat membangun sistem tiga komponen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tx/ja/3g/txja3gpoqs8svx3z_roiwe6800g.png"></div><br><br>  Komponen bekerja sebagai berikut: <br><br><ol><li>  Fungsi komputasi: mengambil fitur yang dirancang secara manual, seperti MFCC ( <a href="https://en.wikipedia.org/wiki/Mel-frequency_cepstrum">Koefisien cepstrum frekuensi-Mel</a> ), yang mencoba menangkap konten pernyataan sambil mengabaikan properti yang kurang penting seperti pitch dalam dinamika. </li><li>  Pengenalan Fonem: Beberapa ahli bahasa percaya bahwa ada unit dasar suara yang disebut "fonem".  Misalnya, bunyi awal "k" di "keep" adalah fonem yang sama dengan bunyi "c" di "cake".  Sistem ini berusaha mengenali fonem individu dalam rekaman audio. </li><li>  End Recognizer: mengambil urutan fonem yang dikenali dan mencoba menghubungkannya bersama-sama menjadi catatan keluaran. </li></ol><br>  Berbeda dengan "jalur pipa" ini, sistem end-to-end dapat menerima rekaman audio pada input dan akan mencoba untuk langsung mentransfernya ke rekaman output: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xp/eh/kp/xpehkpiky2bfr3fhrxsfvveefpc.png"></div><br><br>  Sejauh ini, kami telah menggambarkan hanya "konveyor" linear sepenuhnya dari pembelajaran mesin: output ditransmisikan secara berurutan dari satu tahap ke tahap lainnya.  Tetapi konveyor bisa lebih kompleks.  Misalnya, berikut adalah arsitektur sederhana untuk kendaraan tak berawak: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wd/gf/zq/wdgfzqzrwvhrhebzqvtx1fih-gu.png"></div><br><br>  Konveyor ini mencakup tiga komponen: satu mendeteksi mobil lain menggunakan gambar kamera, yang kedua mendeteksi pejalan kaki, dan akhirnya, komponen terakhir menghitung jalur mobil kami untuk menghindari tabrakan dengan mobil lain dan pejalan kaki. <br><br>  Tidak semua komponen dalam pipa ini akan dilatih.  Misalnya, literatur tentang "merencanakan pergerakan robot" menjelaskan banyak algoritma untuk perhitungan akhir jalur mobil.  Banyak dari algoritma ini tidak memerlukan pelatihan. <br><br>  Sebaliknya, pendekatan ujung-ke-ujung mungkin mencoba menerima pembacaan sensor dan secara langsung memutar setir ke arah yang benar: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/iy/5x/rw/iy5xrwykphbakzznhiqd0la0mzw.png"></div><br><br>  Meskipun pelatihan ujung ke ujung telah menghasilkan banyak keberhasilan, ini tidak selalu merupakan pendekatan terbaik.  Misalnya, pengenalan ucapan ujung ke ujung bekerja dengan baik.  Tetapi saya skeptis dengan pelatihan lintas cara mengemudi otonom untuk sistem tak berawak.  Beberapa bab berikutnya menjelaskan alasannya. <br><br><hr><h3>  <font color="#548dd4">Bab 49. Pelatihan lintas sektor: pro dan kontra</font> </h3><hr><br>  Pertimbangkan contoh sebelumnya dari pipa pengenalan suara: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tx/ja/3g/txja3gpoqs8svx3z_roiwe6800g.png"></div><br><br>  Banyak bagiannya dirancang "secara manual": <br><br><ul><li>  MFCC adalah serangkaian fitur audio yang dirancang khusus.  Dan meskipun mereka memberikan ringkasan yang masuk akal dari semua audio yang diterima pada input, mereka juga menyederhanakan sinyal yang masuk dengan membuang beberapa informasi. </li><li>  Fonem adalah penemuan ahli bahasa.  Mereka adalah representasi yang tidak sempurna dari suara-suara ucapan.  Karena fonem adalah pendekatan yang buruk terhadap kenyataan, suatu algoritma yang menggunakan fonem untuk mewakili ucapan akan membatasi efektivitas seluruh sistem pengenalan wicara. </li></ul><br><ul><li>  Tanda-tanda MFCC kuat untuk properti bicara tertentu yang tidak mempengaruhi konten, seperti nada suara pembicara.  Dengan demikian, mereka membantu menyederhanakan tugas untuk algoritma pembelajaran. </li><li>  Sejauh fonem merupakan representasi wicara yang masuk akal, mereka juga dapat membantu algoritma pembelajaran memahami komponen suara dasar dan, karenanya, meningkatkan efektivitasnya. </li></ul><br>  Memiliki lebih banyak komponen yang dirancang tangan paling sering memungkinkan sistem pengenalan ucapan untuk belajar dari lebih sedikit data.  Pengetahuan yang diperoleh "secara manual" menggunakan MFCC dan fonem "melengkapi" pengetahuan yang diperoleh algoritma kami dari data.  Ketika kita memiliki sedikit data, pengetahuan ini berguna. <br><br>  Sekarang pertimbangkan sistem end-to-end: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xp/eh/kp/xpehkpiky2bfr3fhrxsfvveefpc.png"></div><br><br>  Sistem ini tidak memiliki cukup pengetahuan yang diperoleh "secara manual".  Oleh karena itu, ketika set pelatihan kecil, sistem ini dapat bekerja lebih buruk daripada conveyor yang dirancang secara manual. <br><br>  Namun, ketika set pelatihan besar, tidak ada batasan karena penggunaan MFCC atau fonem.  Jika algoritma pembelajaran adalah jaringan saraf yang cukup besar, dan jika dilatih pada set pelatihan yang cukup besar, ia memiliki potensi besar, dan mungkin bahkan mendekati tingkat kesalahan optimal. <br><br>  Sistem ujung-ke-ujung cenderung berhasil ketika ada banyak data yang ditandai untuk kedua ujungnya - "ujung input" dan "ujung keluaran".  Dalam contoh ini, kita membutuhkan seperangkat pasangan yang besar (audio dan transkripsi).  Ketika data semacam ini tidak tersedia bagi Anda, dekati melalui pembelajaran dengan sangat hati-hati. <br><br>  Jika Anda mengerjakan tugas pembelajaran mesin di mana set pelatihan sangat kecil, maka sebagian besar informasi yang akan tersedia untuk algoritme Anda akan diperoleh berkat pengertian manusiawi Anda, yaitu.  dari komponen yang dirancang secara manual. <br><br>  Jika Anda memilih untuk tidak menggunakan sistem end-to-end, Anda perlu memutuskan langkah apa yang akan ada dalam pipa Anda dan bagaimana mereka harus cocok bersama.  Dalam bab selanjutnya, kami akan menawarkan beberapa ide untuk merancang sistem seperti itu. <br><br><hr><h3>  <font color="#548dd4">Bab 50. Pemilihan Komponen Pipa: Ketersediaan Data</font> </h3><hr><br>  Ketika Anda membangun konveyor yang bukan sistem ujung ke ujung, komponen konveyor mana yang akan menjadi pilihan yang baik?  Bagaimana Anda mendesain conveyor akan sangat mempengaruhi kinerja sistem secara keseluruhan.  Salah satu faktor penting adalah kemampuan untuk dengan mudah mengumpulkan data untuk melatih setiap komponen. <br><br>  Sebagai contoh, pertimbangkan arsitektur mengemudi otonom ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wd/gf/zq/wdgfzqzrwvhrhebzqvtx1fih-gu.png"></div><br><br>  Anda dapat menggunakan algoritma pembelajaran mesin untuk mendeteksi mobil dan pejalan kaki.  Selain itu, tidak sulit bagi mereka untuk mengumpulkan data: ada banyak set data visi komputer siap pakai dengan sejumlah besar mobil dan pejalan kaki yang ditandai.  Anda juga dapat menggunakan crowdsourcing (seperti Amazon Mechanical Turk) untuk mendapatkan dataset yang lebih besar.  Oleh karena itu, akan relatif mudah untuk mengumpulkan data pelatihan untuk membuat detektor mobil dan detektor pejalan kaki. <br><br>  Sebaliknya, pertimbangkan sistem end-to-end yang bersih: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/iy/5x/rw/iy5xrwykphbakzznhiqd0la0mzw.png"></div><br><br>  Untuk melatih sistem ini, kita membutuhkan sejumlah besar elemen yang sudah dipetakan (image = setir berputar ke arah yang benar).  Ini adalah tugas yang sangat memakan waktu dan mahal.  Untuk mengumpulkan data seperti itu, orang perlu mengendarai mobil dan merekam data tentang setiap belokan setir.  Anda akan membutuhkan seluruh armada mobil yang dilengkapi khusus dan sejumlah besar jam kerja untuk mencakup berbagai situasi seluas mungkin.  Ini membuat sistem ujung ke ujung sangat sulit untuk dipelajari.  Jauh lebih mudah untuk mengambil serangkaian besar gambar mobil dan pejalan kaki berlabel. <br><br>  Dalam arti yang lebih umum, jika ada banyak data yang tersedia untuk pelatihan modul konveyor â€œperantaraâ€ (seperti detektor mobil atau detektor pejalan kaki), maka Anda perlu berpikir tentang menggunakan konveyor yang terdiri dari beberapa komponen.  Metode ini mungkin bekerja lebih baik, karena  Anda dapat menggunakan semua data yang tersedia untuk pelatihan modul perantara. <br><br>  Sampai ada lebih banyak data untuk model ujung ke ujung, saya percaya pendekatan tradisional jauh lebih menjanjikan untuk pengendaraan mandiri: arsitekturnya lebih cocok dengan ketersediaan data saat ini. <br><br><hr><h3>  <font color="#548dd4">Bab 51. Memilih komponen konveyor: kesederhanaan tugas</font> </h3><hr><br>  Selain ketersediaan data, Anda juga harus mempertimbangkan faktor kedua ketika memilih komponen pipa: seberapa sederhana tugas yang diselesaikan masing-masing komponen?  Anda harus mencoba memilih komponen konveyor agar mudah dibangun atau mudah dipelajari.  Tetapi apa artinya komponen mudah dipelajari? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fc/bg/fy/fcbgfyb4ggr4u6m79xy01h6gtqa.png"></div><br><br>  Pertimbangkan tugas-tugas pembelajaran mesin berikut, yang tercantum dalam urutan kompleksitas yang semakin meningkat: <br><br><ol><li>  Definisi overexposed gambar yang disajikan (seperti pada contoh di atas). </li><li>  Menentukan apakah suatu gambar diambil di dalam atau di luar ruangan. </li><li>  Menentukan apakah ada kucing di gambar. </li><li>  Menentukan apakah ada kucing dalam gambar dengan bulu hitam dan putih. </li><li>  Penentuan apakah ada kucing siam dalam gambar (jenis kucing tertentu). </li></ol><br>  Untuk masing-masing masalah klasifikasi biner ini, Anda perlu mendapatkan gambar pada input dan output 0 atau 1. Tetapi tugas-tugas yang tercantum sebelumnya dalam daftar tampaknya jaringan saraf menjadi "lebih mudah" untuk dipelajari.  Anda dapat melatih algoritme untuk tugas yang lebih sederhana dengan contoh pelatihan yang lebih sedikit. <br><br>  Pada tahap pembelajaran mesin saat ini, tidak ada definisi formal yang baik tentang apa yang membuat satu tugas mudah atau sulit.  <sup>2</sup> Dengan pertumbuhan pembelajaran yang mendalam dan jaringan saraf multilayer, kami terkadang menyebut masalah itu mudah jika dapat diselesaikan dengan langkah-langkah perhitungan yang lebih sedikit (misalnya, menggunakan jaringan saraf dengan beberapa lapisan), dan kami menyebut tugas itu sulit jika membutuhkan lebih banyak langkah komputasi (yang sesuai dengan jaringan saraf yang dalam).  Tetapi ini adalah definisi informal. <br><blockquote>  <sup>2</sup> Dalam teori informasi algoritmik, terdapat konsep kompleksitas Kolmogorov, yang menyatakan bahwa kompleksitas fungsi yang dipelajari adalah panjang dari program komputer terpendek yang dapat menghasilkan fungsi ini.  Konsep teoretis ini telah menemukan beberapa aplikasi praktis dalam AI. </blockquote><br>  Jika Anda memiliki peluang untuk memecah tugas yang kompleks menjadi subtugas yang lebih sederhana, maka dengan menyandikan setiap subtugas secara akurat, Anda akan memberikan algoritma pengetahuan yang lebih penting yang dapat membantunya menyelesaikan seluruh masalah dengan lebih efisien. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cm/cm/so/cmcmsoncvrly_eqnmdswoqxyqcc.png"></div><br><br>  Bayangkan Anda sedang merancang pendeteksi kucing siam.  Berikut adalah arsitektur ujung ke ujung yang bersih: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3g/ex/em/3gexemhnlou8qon3qwpprhtcidm.png"></div><br><br>  Sebaliknya, Anda dapat menggunakan konveyor dua komponen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k7/uj/oa/k7ujoa1l7cdhtrc809rhrqixfxa.png"></div><br><br>  Pada langkah pertama (detektor kucing), semua kucing dalam gambar akan dikenali. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9q/a4/wu/9qa4wugiqcvqysomntw52alpy8q.png"></div><br><br>  Kemudian, pada langkah kedua, gambar yang dipangkas dari masing-masing kucing yang terdeteksi, satu per satu, dipindahkan ke penggolong breed.  Dan akhirnya, jika ada kucing yang terdeteksi adalah kucing siam, kita mendapatkan "1" di output. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ns/oj/ii/nsojiirbbbuni7qkmrokqmuksfm.png"></div><br><br>  Dibandingkan dengan mengajarkan classifier murni pass-through yang hanya menggunakan tag 0/1, masing-masing dari dua komponen dalam pipa (detektor kucing dan klasifikasi breed) tampaknya lebih mudah dipelajari dan membutuhkan data yang jauh lebih sedikit.  <sup>3</sup> <br><blockquote>  <sup>3</sup> Jika Anda terbiasa dengan algoritma deteksi objek yang benar-benar digunakan dalam praktik, Anda akan memahami bahwa mereka dilatih tidak hanya dengan label gambar 0/1.  Sebaliknya, mereka dilatih menggunakan kerangka kerja terbatas yang disediakan sebagai bagian dari data pelatihan.  Diskusi mereka berada di luar cakupan bab ini. </blockquote><br>  Dan contoh terakhir, mari kita ingat kembali pipa untuk tugas mengemudi otonom: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wd/gf/zq/wdgfzqzrwvhrhebzqvtx1fih-gu.png"></div><br><br>  Menggunakan konveyor ini, Anda memberi tahu algoritma bahwa ada tiga langkah kunci dalam mengendarai mobil: <br><br><ul><li>  Kenali mobil lain. </li><li>  Kenali pejalan kaki. </li><li>  Rencanakan arah pergerakan selanjutnya. </li></ul><br>  Masing-masing langkah ini adalah tugas yang lebih sederhana dan dapat dilatih tentang data yang lebih sedikit dibandingkan dengan pendekatan lintas sektoral. <br><br>  Akibatnya, ketika memutuskan apa yang harus menjadi komponen dari pipeline, cobalah untuk membangun pipeline di mana setiap komponen adalah fungsi yang relatif â€œsederhanaâ€ yang hanya dapat dilatih pada sejumlah kecil data. <br><br><hr><h3>  <font color="#548dd4">Bab 52. Belajar dengan informasi mendalam</font> </h3><hr><br>  Algoritma klasifikasi gambar mengambil input gambar X dan menghasilkan integer, yang merupakan label untuk kategori objek.  Dapatkah Algoritma bukannya menghasilkan seluruh kalimat yang menggambarkan gambar? <br><br>  Sebagai contoh: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/12/z6/-v/12z6-votwnq7mu2j9rwukqce52k.png"></div><br><br>  Y = "Sebuah bus kuning melaju di jalan di tengah-tengah pohon dan rumput hijau." <br><br>  Aplikasi tradisional mengajar dengan guru melibatkan kehadiran fungsi yang terlatih h: X â†’ Y, di mana output (y) biasanya diwakili oleh bilangan bulat atau bilangan alami.  Sebagai contoh: <br><br><div class="scrollable-table"><table><tbody><tr><th>  Tantangan </th><th>  X </th><th>  Y </th></tr><tr><td>  <b>Antispam</b> </td><td>  Email </td><td>  Spam / Bukan Spam (0/1) </td></tr><tr><td>  <b>Pengenalan gambar</b> </td><td>  Gambar </td><td>  Label integer </td></tr><tr><td>  <b>Prakiraan Harga Real Estat</b> </td><td>  Karakteristik rumah </td><td>  Harga dalam dolar </td></tr><tr><td>  <b>Rekomendasi produk</b> </td><td>  Spesifikasi produk dan pelanggan </td><td>  Probabilitas pembelian </td></tr></tbody></table></div><br><br>  Salah satu hal yang paling menarik tentang pembelajaran mendalam lintas bidang adalah memungkinkan kita untuk secara langsung belajar Y, yang jauh lebih rumit daripada angka.  Dalam contoh dengan tugas deskripsi gambar yang disebutkan di atas, Anda dapat menerapkan beberapa gambar (x) ke input jaringan saraf dan mendapatkan deskripsi langsung (y) pada output. <br><br>  Berikut ini beberapa contohnya: <br><br><div class="scrollable-table"><table><tbody><tr><th>  Tantangan </th><th>  X </th><th>  Y </th><th>  Kutipan dari kantor </th></tr><tr><td>  <b>Deskripsi Gambar</b> </td><td>  Gambar </td><td>  Teks </td><td>  Mao dan lainnya, 2014 </td></tr><tr><td>  <b>Terjemahan mesin</b> </td><td>  Teks bahasa inggris </td><td>  Teks Perancis </td><td>  Suskever dan lainnya, 2014 </td></tr><tr><td>  <b>Jawaban atas pertanyaan</b> </td><td>  Pasangkan (teks + pertanyaan) </td><td>  Jawab pertanyaannya </td><td>  Bordes dan lainnya, 2015 </td></tr><tr><td>  <b>Pengenalan ucapan</b> </td><td>  Audio </td><td>  Transkripsi </td><td>  Hannun dan lainnya, 2015 </td></tr><tr><td>  <b>Text-to-speech</b> </td><td>  Tag Teks </td><td>  Audio </td><td>  Van der Oord et al., 2016 </td></tr></tbody></table></div><br><br>  Ini adalah tren yang berkembang dalam pembelajaran mendalam: ketika Anda memiliki pasangan berlabel (input, output) yang benar, Anda kadang-kadang dapat memilih pelatihan ujung ke ujung, bahkan jika outputnya berupa kalimat, gambar, audio atau output lainnya yang membawa lebih banyak informasi, dari sekedar nomor tag. <br><br><h1>  Analisis kesalahan parsial </h1><hr><h3>  <font color="#548dd4">Bab 53. Analisis kesalahan dalam bagian-bagian</font> </h3><hr><br>  Misalkan sistem Anda dibangun menggunakan pipa pembelajaran mesin yang canggih, dan Anda ingin meningkatkan efisiensi sistem.  Bagian mana dari conveyor yang harus Anda tingkatkan?  Dengan mengaitkan kesalahan pada bagian-bagian tertentu dari pipa, Anda dapat memutuskan bagaimana memprioritaskan pekerjaan Anda. <br><br>  Mari kita gunakan contoh penggolong kucing Siam: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k7/uj/oa/k7ujoa1l7cdhtrc809rhrqixfxa.png"></div><br><br>  Bagian pertama, detektor kucing, mendeteksi kucing dan memotong mereka dari seluruh gambar.  Bagian kedua, penggolong jenis kucing, memutuskan apakah kucing ini adalah kucing siam.  Anda dapat menghabiskan waktu bertahun-tahun bekerja untuk memperbaiki salah satu dari dua komponen conveyor ini.  Bagaimana Anda memutuskan komponen mana yang menjadi fokus? <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Melakukan analisis kesalahan di bagian-bagian, Anda dapat mencoba untuk menghubungkan setiap kesalahan algoritma ke salah satu dari dua bagian dari pipa (dan kadang-kadang keduanya sekaligus). </font><font style="vertical-align: inherit;">Sebagai contoh, algoritma salah mengklasifikasikan gambar ini sebagai tidak mengandung kucing siam (y = 0), meskipun label yang benar adalah y = 1.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hj/ju/2g/hjju2gw3fble1fcgc8fblrenkms.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita periksa secara manual apa yang dilakukan algoritma di masing-masing dari dua langkah. </font><font style="vertical-align: inherit;">Misalkan pendeteksi kucing siam mendeteksi kucing sebagai berikut:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/oe/0l/rx/oe0lrx5ysvmznqkmbl83m_k_46g.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini berarti bahwa classifier breed kucing akan mendapatkan gambar ini: </font></font><br><br><img src="https://habrastorage.org/webt/ft/wm/vs/ftwmvsdrnvpp2f9vrds36flldzo.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Classifier breed mengklasifikasikan gambar ini dengan benar karena tidak mengandung kucing siam. Jadi, penggolong turunan kucing tidak bersalah: ia menerima banyak batu di pintu masuk dan memberikan tanda yang sangat masuk akal y = 0. Bahkan, seseorang yang mengklasifikasikan gambar yang dipangkas di atas juga akan memprediksi y = 0. Dengan demikian, Anda dapat dengan jelas mengaitkan kesalahan ini dengan detektor kucing. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di sisi lain, jika detektor kucing menampilkan kotak pembatas berikut:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/oz/qu/no/ozqunon7ny51kw1ukglsfl3hjj8.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maka Anda akan menyimpulkan bahwa detektor kucing melakukan tugasnya dengan benar, dan kesalahan terjadi karena penggolong berkembang biak. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Misalkan Anda telah melewati 100 gambar yang salah diklasifikasi dari sampel validasi dan menemukan bahwa 90 kesalahan terkait dengan detektor kucing, dan hanya 10 kesalahan yang terkait dengan klasifikasi pembiakan kucing. Anda dapat menyimpulkan dengan aman bahwa Anda harus lebih fokus pada peningkatan detektor kucing. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain itu, Anda juga berhasil menemukan 90 contoh di mana detektor kucing mengeluarkan kotak pembatas yang salah. Anda dapat menggunakan 90 contoh ini untuk </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">analisis yang </font><font style="vertical-align: inherit;">lebih dalam </font><font style="vertical-align: inherit;">tentang kesalahan pendeteksi kucing untuk melihat bagaimana memperbaikinya.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deskripsi kami tentang cara mengaitkan kesalahan ke satu bagian dari pipa sejauh ini bersifat informal: Anda melihat output dari setiap bagian dan melihat apakah Anda dapat memutuskan mana yang membuat kesalahan. </font><font style="vertical-align: inherit;">Metode informal ini mungkin cukup. </font><font style="vertical-align: inherit;">Namun di bab selanjutnya, Anda juga akan melihat cara yang lebih formal untuk menghubungkan kesalahan.</font></font><br><br><hr><h3> <font color="#548dd4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bab 54. Atribusi kesalahan ke bagian tertentu</font></font></font> </h3><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mari kita lanjutkan dengan contoh kita: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k7/uj/oa/k7ujoa1l7cdhtrc809rhrqixfxa.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Misalkan detektor kucing menghasilkan kotak pembatas ini: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bc/_d/8k/bc_d8kmcijt314qterhumctdyyq.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi, classifier breed menerima gambar yang dipangkas ini, setelah itu dikeluarkan secara salah y = 0, yaitu </font><font style="vertical-align: inherit;">bahwa tidak ada kucing di gambar.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/71/mu/ld/71muldvuqnfx0cd_a6bpo41xzvc.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Detektor kucing melakukan pekerjaan yang buruk. </font><font style="vertical-align: inherit;">Sementara orang yang terlatih tidak diragukan lagi akan dapat mengenali kucing siam dalam gambar yang dipotong ini. </font><font style="vertical-align: inherit;">Oleh karena itu, kami mengaitkan kesalahan ini dengan detektor kucing, atau klasifikasi breed, atau keduanya? </font><font style="vertical-align: inherit;">Tidak jelas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika jumlah kasus kontroversial semacam itu kecil, kami dapat membuat keputusan apa pun dan mendapatkan hasil yang serupa. </font><font style="vertical-align: inherit;">Tapi di sini ada tes yang lebih formal, yang memungkinkan kita untuk lebih akurat menghubungkan kesalahan ke satu bagian:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ganti output detektor kucing dengan bingkai yang ditandai secara manual. </font></font><br><img src="https://habrastorage.org/webt/np/8f/zy/np8fzyx2lfbh1cdbd-o7iiykpvq.png"></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lewati gambar yang dipangkas yang sesuai melalui klasifikasi breed. </font><font style="vertical-align: inherit;">Jika penggolong breed masih tidak mengklasifikasikan gambar dengan benar, atribut kesalahan ke penggolong breed. </font><font style="vertical-align: inherit;">Kalau tidak, atribut kesalahan ke detektor kucing.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan kata lain, lakukan percobaan di mana Anda mengirimkan data ideal ke input dari rock classifier. </font><font style="vertical-align: inherit;">Dalam hal ini, 2 opsi dimungkinkan:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bahkan dengan kerangka yang ideal, penggolong berkembang biak keliru y = 0. Dalam hal ini, penggolong tidak diragukan lagi yang harus disalahkan. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah menerima kerangka yang ideal, penggolong berkembang biak dengan benar y = 1. Ini menunjukkan bahwa jika hanya detektor kucing yang menghasilkan kotak pembatas yang lebih sempurna, maka kesimpulan umum sistem akan benar. </font><font style="vertical-align: inherit;">Jadi, kami mengaitkan kesalahan dengan detektor kucing.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah melakukan analisis gambar yang salah klasifikasi dari sampel validasi, kini Anda dapat dengan jelas mengaitkan setiap kesalahan dengan satu komponen. </font><font style="vertical-align: inherit;">Ini memungkinkan Anda untuk memperkirakan proporsi kesalahan yang terkait dengan setiap komponen pipa, dan, karenanya, memutuskan apa yang menjadi fokus perhatian Anda.</font></font><br><br><hr><h3> <font color="#548dd4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bab 55. Kasus Utama Kesalahan Mengaitkan</font></font></font> </h3><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berikut adalah langkah-langkah umum untuk mengaitkan kesalahan. </font><font style="vertical-align: inherit;">Misalkan pipa memiliki tiga tahap A, B dan C, di mana A diumpankan langsung ke B dan B diumpankan langsung ke C.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ok/tz/0i/oktz0iqvw81g6gbnxdwvehsmo50.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Untuk setiap kesalahan yang dibuat sistem pada sampel validasi: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cobalah untuk secara manual mengganti output tahap A dengan output "ideal" (yaitu, kotak ikatan "ideal" untuk kucing) dan lanjutkan dengan sisa conveyor B, C dengan output seperti itu. </font><font style="vertical-align: inherit;">Jika algoritma sekarang menghasilkan hasil yang benar, ini menunjukkan bahwa hanya tahap A yang harus meningkatkan output sendiri agar seluruh algoritma bekerja dengan benar. </font><font style="vertical-align: inherit;">Dengan demikian, Anda dapat menghubungkan kesalahan ini ke komponen A. Jika tidak, lanjutkan ke langkah 2.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coba ganti secara manual output tahap B dengan output "sempurna". </font><font style="vertical-align: inherit;">Jika keseluruhan algoritma mulai bekerja dengan benar, maka atribut kesalahan ke komponen B. Jika tidak, lanjutkan ke langkah 3.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mengaitkan kesalahan ke komponen C. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lihatlah contoh yang lebih kompleks: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wd/gf/zq/wdgfzqzrwvhrhebzqvtx1fih-gu.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Drone Anda menggunakan conveyor ini. </font><font style="vertical-align: inherit;">Bagaimana, menggunakan analisis kesalahan sedikit demi sedikit, untuk menentukan komponen mana yang menjadi fokus? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda dapat menandai komponen sebagai berikut:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A. Kenali mobil. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> B. Kenali pejalan kaki. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C. Rencanakan jalannya. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengikuti prosedur yang dijelaskan di atas, anggaplah Anda menguji mobil Anda di tempat latihan tertutup dan temukan suatu kasus di mana mobil memilih manuver ke arah yang lebih tajam daripada yang dilakukan oleh pengemudi berpengalaman. </font><font style="vertical-align: inherit;">Dalam dunia mengemudi tanpa awak, peristiwa semacam itu biasanya disebut skrip. </font><font style="vertical-align: inherit;">Dalam hal ini:</font></font><br><br><ol><li>      A ( )  Â«Â»  (..     ).     B  C   ,    C ( )  Â«Â»   A.        ,    ,     A   ,     .        A.     2. </li><li>      B ( )  Â«Â» .      ,      B.     3. </li><li>    C. </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komponen pipa pembelajaran mesin harus disusun sesuai dengan grafik asiklik terarah (DAG), yang berarti bahwa Anda harus dapat menghitungnya dalam urutan tetap dari kiri ke kanan, dan komponen yang lebih baru hanya bergantung pada output dari komponen sebelumnya. </font><font style="vertical-align: inherit;">Selama </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">susunan komponen dalam urutan A â†’ B â†’ C sesuai dengan urutan DAG, analisis kesalahan akan dilanjutkan dengan benar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda bisa mendapatkan hasil yang sedikit berbeda jika Anda menukar A dan B:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A. Kenali pejalan kaki (sebelumnya dikenal sebagai mobil) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> B. Mengenali mobil (sebelumnya dikenal sebagai pejalan kaki) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C. Rencanakan jalur mobil Anda </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tetapi hasil analisis ini akan tetap benar dan memberikan panduan yang baik tentang apa yang harus Anda fokuskan. </font></font><br><br><hr><h3> <font color="#548dd4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bab 56. Analisis kesalahan dalam bagian-bagian dan perbandingan dengan efisiensi di tingkat manusia</font></font></font> </h3><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Melakukan analisis kesalahan dalam algoritma pembelajaran mirip dengan menggunakan ilmu data untuk menganalisis kesalahan sistem ML untuk mendapatkan ide tentang apa yang harus dilakukan selanjutnya. </font><font style="vertical-align: inherit;">Dalam kebanyakan kasus, analisis kesalahan sedikit demi sedikit akan memberi tahu kita komponen mana yang layak untuk ditingkatkan di atas segalanya.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Katakanlah Anda memiliki beberapa dataset tentang pelanggan yang membeli sesuatu di situs web. Seorang ilmuwan data dapat menganalisis data dengan berbagai cara. Dia dapat membuat banyak kesimpulan berbeda tentang apakah situs harus menaikkan harga, tentang nilai pelanggan yang diperoleh melalui berbagai kampanye pemasaran dan sebagainya. Tidak ada satu pun cara "benar" untuk menganalisis set data, ada banyak ide berguna yang mungkin muncul. Demikian pula, tidak ada satu cara "benar" untuk menganalisis kesalahan. Dalam bab-bab ini, Anda mempelajari beberapa pola desain paling umum untuk mendapatkan informasi yang berguna tentang sistem ML Anda, tetapi Anda juga dapat dengan bebas bereksperimen dengan metode analisis kesalahan lainnya.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kembali ke aplikasi kendaraan tak berawak, di mana algoritma deteksi mobil menampilkan lokasi (dan mungkin kecepatan) mobil terdekat, algoritma deteksi pejalan kaki menampilkan lokasi pejalan kaki terdekat, dan kedua output ini akhirnya digunakan untuk merencanakan jalur untuk mobil. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wd/gf/zq/wdgfzqzrwvhrhebzqvtx1fih-gu.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Untuk men-debug pipa ini dan tidak secara ketat mengikuti prosedur yang Anda lihat di bab sebelumnya, Anda bisa mengajukan pertanyaan berikut: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seberapa jauh algoritma pengenalan mobil dari efisiensi manusia dalam memecahkan masalah yang sama? </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seberapa jauh algoritma pengenalan pejalan kaki dari kinerja manusia dalam memecahkan masalah yang sama? </font></font></li><li>         ?      ,       ,          (      ).  ,    Â« Â»    ,        ? </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda menemukan bahwa salah satu komponen sistem jauh dari efisiensi manusia, maka Anda akan memiliki peluang yang baik untuk fokus pada peningkatan efektivitas komponen ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Banyak proses analisis kesalahan berfungsi lebih baik ketika kami mencoba mengotomatisasi sesuatu yang dapat dilakukan seseorang, jadi kami membandingkan hasilnya dengan hasil seseorang. Sebagian besar contoh kami sebelumnya memiliki asumsi implisit ini. Jika Anda sedang membangun sistem ML di mana keluar akhir atau beberapa komponen perantara melakukan hal-hal yang bahkan orang tidak dapat melakukannya dengan baik, maka beberapa prosedur ini tidak akan berlaku.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ini adalah keuntungan lain dari menyelesaikan masalah yang dapat diselesaikan orang - Anda memiliki alat analisis kesalahan yang lebih kuat, dan karenanya, Anda dapat lebih memprioritaskan pekerjaan tim Anda secara lebih efisien. </font></font><br><br><hr><h3> <font color="#548dd4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bab 57. Deteksi Kesalahan dalam Pipeline ML</font></font></font> </h3><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana jika masing-masing komponen konveyor ML Anda menunjukkan efisiensi di tingkat manusia atau sedikit lebih rendah, tetapi konveyor umum jauh tidak sesuai dengan tingkat manusia? </font><font style="vertical-align: inherit;">Biasanya ini berarti bahwa conveyor memiliki kekurangan dan perlu dirancang ulang. </font><font style="vertical-align: inherit;">Analisis kesalahan juga dapat membantu Anda mengetahui apakah pipa Anda perlu dirancang ulang.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wd/gf/zq/wdgfzqzrwvhrhebzqvtx1fih-gu.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam bab sebelumnya, kami mengajukan pertanyaan: apakah masing-masing dari tiga komponen menunjukkan efisiensi pada tingkat manusia? </font><font style="vertical-align: inherit;">Misalkan jawaban untuk ketiga pertanyaan itu adalah ya. </font><font style="vertical-align: inherit;">Lalu:</font></font><br><br><ol><li> ,  ,   ()           . </li><li> ,  ,   ()           . </li><li> ,   ,     ,    ,      ,                (     ). </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun demikian, kendaraan Anda yang tak berawak berhasil mengemudi secara signifikan lebih buruk daripada seseorang. Artinya, orang yang memiliki akses ke gambar dari kamera dapat merencanakan jalur mobil jauh lebih baik. Kesimpulan apa yang bisa Anda buat? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Satu-satunya kesimpulan yang mungkin adalah bahwa saluran pipa ML Anda tidak dirancang dengan benar. Dalam hal ini, komponen yang merencanakan jalur mobil berfungsi dengan baik serta memungkinkan data masuk yang tidak mengandung informasi yang cukup. Anda harus bertanya pada diri sendiri informasi lain apa yang tidak ada dalam output dari dua komponen sebelumnya yang diperlukan untuk perencanaan jalur mobil yang sangat baik. Dengan kata lain, informasi apa yang digunakan oleh pengemudi berpengalaman?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Misalkan Anda mengerti bahwa pengemudi manusia juga perlu melihat marka jalan. Ini menunjukkan bahwa Anda harus merekayasa balik pipa sebagai berikut: </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></sup> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ms/qa/wy/msqawygb_nyn4twj9cnbbiqlad0.png"></div><br><blockquote> <sup>4</sup>       ,     ,         .       Â«Task simplicityÂ»,    51,            ,          .     Â«  Â»    â€”               ,        /  . </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pada akhirnya, jika Anda berpikir bahwa saluran pipa Anda secara keseluruhan tidak akan dapat mencapai efisiensi manusia, bahkan jika setiap komponen individu memiliki efisiensi di tingkat manusia (ingat bahwa Anda membandingkan dengan orang yang memiliki data input yang sama dengan komponen) , maka konveyor tersebut memiliki kelemahan dan harus dirancang ulang. </font></font><br><br><h1>  Kesimpulan </h1><hr><h3> <font color="#548dd4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bab 58. Bangun Tim Super, Bagikan Pengetahuan Ini dengan Kawan-kawan</font></font></font> </h3><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selamat telah menyelesaikan buku ini! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam bab 2, kami berbicara tentang bagaimana buku ini dapat membantu Anda menjadi superhero di tim Anda.</font></font><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ms/8d/ta/ms8dta_asiaioa6tttb3dsl4syo.png"></div><br><br>  Satu-satunya hal yang bisa lebih baik daripada menjadi pahlawan super adalah menjadi bagian dari tim pahlawan super.  Saya harap Anda berbagi salinan buku ini dengan teman dan rekan setim Anda dan membantu menciptakan pahlawan super lainnya! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id485190/">https://habr.com/ru/post/id485190/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id485178/index.html">Metodologi untuk rekonstruksi bangunan yang hilang dari foto</a></li>
<li><a href="../id485180/index.html">Apakah kita memerlukan data lake? Apa yang harus dilakukan dengan data warehouse?</a></li>
<li><a href="../id485182/index.html">Sennheiser pada tahun 2020 - headphone nirkabel yang diperbarui untuk peringatan tersebut</a></li>
<li><a href="../id485184/index.html">Hasil Jajak Pendapat Tab</a></li>
<li><a href="../id485186/index.html">Startup bernilai trilyun dolar atau bagaimana perusahaan Valley paling sukses dilahirkan</a></li>
<li><a href="../id485194/index.html">Pohon segmen: cepat dan mudah</a></li>
<li><a href="../id485196/index.html">AvitoTech On Tour: Pergi dan berhadapan rapat di Kazan</a></li>
<li><a href="../id485198/index.html">Cara lain untuk mengukur kinerja metode aplikasi .NET</a></li>
<li><a href="../id485200/index.html">Mess pada awalnya: post-mortem pada kecepatan peluncuran aplikasi iOS</a></li>
<li><a href="../id485202/index.html">Sistem Penindasan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>