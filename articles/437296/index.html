<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëãüèø üññüèΩ üë©‚Äçüöí ¬øPor qu√© la gente no usa m√©todos formales? üïû ‚ô£Ô∏è ‚òπÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En Software Exchange Stack Exchange, vi esta pregunta : "¬øQu√© est√° deteniendo la adopci√≥n generalizada de m√©todos formales?" La pregunta se cerr√≥ como...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¬øPor qu√© la gente no usa m√©todos formales?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437296/"> En Software Exchange Stack Exchange, vi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esta pregunta</a> : "¬øQu√© est√° deteniendo la adopci√≥n generalizada de m√©todos formales?"  La pregunta se cerr√≥ como sesgada, y la mayor√≠a de las respuestas fueron comentarios como "¬°Demasiado caro!"  o "¬°Un sitio no es un avi√≥n!"  En cierto modo, esto es cierto, pero no explica mucho.  Escrib√≠ este art√≠culo para dar una imagen hist√≥rica m√°s amplia de los m√©todos formales (FM), por qu√© no se usan realmente y qu√© estamos haciendo para corregir la situaci√≥n. <br><br>  Antes de comenzar, debe formular algunas condiciones.  De hecho, no hay muchos m√©todos formales: solo unos <abbr title="TLA + es uno de los lenguajes de especificaci√≥n m√°s populares, y todos los expertos de TLA + se adaptar√°n a un gran autob√∫s escolar">pocos grupos peque√±os</abbr> .  Esto significa que diferentes grupos usan los t√©rminos de manera diferente.  En t√©rminos generales, hay dos grupos de m√©todos formales: la <b>especificaci√≥n formal</b> estudia la redacci√≥n de especificaciones precisas y sin ambig√ºedades, y la <b>verificaci√≥n formal</b> estudia los m√©todos de prueba.  Esto incluye tanto el c√≥digo como los sistemas abstractos.  No solo usamos diferentes t√©rminos para el c√≥digo y los sistemas, a menudo usamos diferentes herramientas para verificarlos.  Para hacer las cosas a√∫n m√°s confusas, si alguien dice que est√° creando una especificaci√≥n formal, esto <i>generalmente</i> significa verificaci√≥n del dise√±o.  Y si alguien dice que est√° haciendo una verificaci√≥n formal, esto <i>generalmente se</i> refiere a la verificaci√≥n del c√≥digo. <br><a name="habracut"></a><br>  Para mayor claridad, dividimos la <b>verificaci√≥n de verificaci√≥n de c√≥digo</b> (CV) y la <b>verificaci√≥n de dise√±o</b> (DV) y, de manera similar, dividimos las especificaciones en CS y DS.  Dichos t√©rminos no se usan com√∫nmente en la amplia comunidad de FM.  Comencemos con CS y CV, luego pasemos a DS y DV. <br><br>  Adem√°s, es posible la <b>verificaci√≥n parcial</b> , donde solo se <b>verifica</b> un subconjunto de la especificaci√≥n, o <b>la verificaci√≥n completa</b> .  Esta puede ser la diferencia entre las pruebas de las acusaciones de que "el sistema nunca falla y no acepta la contrase√±a incorrecta" o "el sistema nunca falla y bloquea la cuenta si ingresa la contrase√±a incorrecta tres veces".  B√°sicamente, asumiremos que estamos haciendo una verificaci√≥n completa. <br><br>  Tambi√©n debe aclarar el tipo de software que estamos formalizando.  La mayor√≠a de las personas identifican impl√≠citamente programas <b>altamente confiables</b> como dispositivos m√©dicos y aviones.  La gente asume que los m√©todos formales son ampliamente utilizados para ellos, pero no son necesarios para el resto.  Esto es demasiado <i>optimista</i> : el software m√°s confiable no utiliza m√©todos formales.  En cambio, nos centraremos en el software "regular". <br><br>  Finalmente, el descargo de responsabilidad: no soy un historiador profesional, y aunque intent√© verificar cuidadosamente la informaci√≥n, puede haber errores en el art√≠culo.  Adem√°s, me especializo en especificaciones formales (DS y DV), por lo que hay m√°s posibilidades de error cuando hablo de la verificaci√≥n del c√≥digo.  Si ves, escr√≠beme, lo arreglar√© (y una cosa m√°s: gano dinero de seminarios sobre TLA + y Alloy, por lo tanto, soy muy parcial hacia estos idiomas; trato de ser lo m√°s objetivo posible, pero entiendes: sesgo es sesgo). <br><br><h1>  Programaci√≥n formal </h1><br><h2>  Obteniendo especificaci√≥n </h2><br>  Antes de probar la exactitud del c√≥digo, debe obtener el est√°ndar de verdad.  Esto significa alguna <b>especificaci√≥n de</b> lo que debe hacer el c√≥digo.  Debemos saber con certeza que el resultado coincide con la especificaci√≥n.  No es suficiente decir que la lista est√° "ordenada": no sabemos qu√© estamos ordenando, qu√© criterios usamos e incluso qu√© queremos decir con "ordenar".  En cambio, podemos decir: "La lista de enteros <code>l</code> <i>ordenada en orden ascendente</i> para cualquiera de los dos √≠ndices i y j, si <code>i &lt; j</code> , entonces <code>l[i] &lt;= l[j]</code> ". <br><br>  Las especificaciones del c√≥digo se dividen en tres tipos principales: <br><br><ol><li>  El primero es escribir declaraciones independientes del c√≥digo.  Escribimos nuestra funci√≥n de clasificaci√≥n, y en un archivo separado escribimos el teorema "esto devuelve listas ordenadas".  Esta es la forma m√°s antigua de especificaci√≥n, pero Isabelle y ACL2 a√∫n funcionan de esta manera (ML fue inventado espec√≠ficamente para ayudar a escribir tales especificaciones). <br></li><li>  El segundo implementa especificaciones en el c√≥digo en forma de precondiciones y poscondiciones, declaraciones e invariantes.  Puede agregar una condici√≥n posterior a la funci√≥n que "el valor de retorno es una lista ordenada".  Las especificaciones basadas en reclamos se formalizaron inicialmente como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la l√≥gica de Hoar</a> .  Aparecieron por primera vez en el lenguaje de programaci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Euclid</a> a principios de la d√©cada de 1970 (no est√° claro qui√©n comenz√≥ a usarlos: Euclid o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SPV</a> , pero hasta donde s√©, Euclid se present√≥ al p√∫blico antes).  Este estilo tambi√©n se llama <b>programaci√≥n de contratos</b> , la forma de verificaci√≥n m√°s popular en la industria moderna (aqu√≠, los contratos se usan como especificaciones de c√≥digo). <br></li><li>  Finalmente, hay sistemas de tipos.  Por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">correspondencia de Curry - Howard,</a> cualquier teorema matem√°tico o prueba puede codificarse como un tipo dependiente.  Definiremos el tipo de listas ordenadas y declararemos el tipo <code>[Int] -&gt; Sorted [Int]</code> para la funci√≥n. </li></ol><br>  En <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Let's Prove Leftpad,</a> puedes ver c√≥mo se ve.  HOL4 e Isabelle son buenos ejemplos de las especificaciones del "teorema independiente", SPARK y Dafny son las especificaciones de la "declaraci√≥n anidada", y Coq y Agda son el "tipo dependiente". <br><br>  Si observa detenidamente, estas tres formas de especificaci√≥n de c√≥digo se comparan con las tres √°reas principales de validaci√≥n autom√°tica: pruebas, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">contratos</a> y tipos.  Esto no es una coincidencia.  La correcci√≥n es un amplio rango, y la verificaci√≥n formal es uno de sus extremos.  A medida que disminuye el rigor (y el esfuerzo) de la verificaci√≥n, obtenemos verificaciones m√°s simples y m√°s estrechas, ya sea limitando el espacio de estado en estudio, utilizando tipos m√°s d√©biles o verificando la fuerza en tiempo de ejecuci√≥n.  Entonces, cualquier medio de especificaci√≥n completa se convierte en un medio de especificaci√≥n parcial, y viceversa: muchos consideran a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cleanroom una</a> t√©cnica de verificaci√≥n formal, donde una revisi√≥n de c√≥digo va mucho m√°s all√° de las capacidades humanas. <br><br><h3>  ¬øQu√© especificaciones son correctas? </h3><br>  La verificaci√≥n verifica que el c√≥digo se ajusta a la especificaci√≥n.  Surge la pregunta: ¬øc√≥mo sabemos que tenemos la especificaci√≥n correcta?  Encontrar la especificaci√≥n correcta es uno de los mayores problemas en los m√©todos formales.  Esta es tambi√©n una de las principales objeciones a ellos.  Pero los esc√©pticos aqu√≠ no quieren decir <i>exactamente</i> lo que los especialistas formales tienen en mente. <br><br>  Cuando los extra√±os preguntan: "¬øC√≥mo se obtienen las especificaciones correctas?" Por lo <i>general,</i> piensan en la <b>validaci√≥n</b> , es decir, especificaciones que no cumplen con los requisitos del cliente.  Si demuestra formalmente que su c√≥digo clasifica la lista, y el cliente realmente quiere Uber para sopas (tm), solo pas√≥ un mont√≥n de tiempo.  Por ejemplo, solo las iteraciones r√°pidas y los ciclos de retroalimentaci√≥n cortos pueden confirmar sus requisitos. <br><br>  Es cierto que la verificaci√≥n del c√≥digo no lo valida.  Pero hay dos problemas con este argumento.  La primera es que la etapa de aplicar m√©todos formales simplemente se pospone, pero no desaparece por completo.  Despu√©s de todas estas iteraciones r√°pidas, probablemente ya tenga una idea de lo que quiere el cliente.  Y <i>luego</i> comienzas la verificaci√≥n del c√≥digo.  En segundo lugar, aunque no sabemos exactamente qu√© quiere el cliente, podemos suponer lo que definitivamente <i>no</i> quiere.  Por ejemplo, para bloquear accidentalmente el software.  No necesitan agujeros de seguridad.  Todos est√°n de acuerdo con esto: al final, nadie dice que debe omitir las pruebas unitarias durante las iteraciones.  As√≠ que al menos aseg√∫rese de que su sistema de control de versiones no elimine datos de usuario aleatorios (nota: no piense que estoy amargado o algo as√≠). <br><br>  El problema para encontrar la especificaci√≥n correcta es m√°s fundamental: a <i>menudo no sabemos qu√© escribir all√≠</i> .  Pensamos en nuestros requisitos en t√©rminos humanos, no matem√°ticos.  Si digo: "El programa debe distinguir los √°rboles de los p√°jaros", ¬øde qu√© se trata?  Puedo explic√°rselo a una persona mostr√°ndole un mont√≥n de im√°genes de √°rboles y p√°jaros, pero estos son solo ejemplos concretos, no una descripci√≥n de la <i>idea</i> .  De hecho, para traducir esto en una especificaci√≥n formal, es necesario formalizar los conceptos humanos, y este es un problema grave. <br><br>  No me malinterpretes.  Las especificaciones relevantes se pueden definir aqu√≠, y los expertos hacen esto todo el tiempo.  Pero escribir las especificaciones apropiadas es una habilidad que necesita ser desarrollada, as√≠ como habilidades de programaci√≥n.  Esta es la raz√≥n por la cual muchos de los √©xitos recientes de la verificaci√≥n de c√≥digo se explican por un mapeo claro de lo que queremos en lo que podemos expresar.  Por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CompCert</a> es un compilador de C. verificado formalmente. La especificaci√≥n es: "Evitar errores de compilaci√≥n". <br><br>  Pero todo esto no tiene nada que ver con la verificaci√≥n.  Cuando tiene una especificaci√≥n, a√∫n necesita demostrar que el c√≥digo coincide. <br><br><h3>  Prueba de especificaci√≥n </h3><br>  La primera herramienta de verificaci√≥n de c√≥digo es el m√©todo "piense por qu√© esto es cierto" al estilo Dijkstra, que es principalmente para ALGOL.  Por ejemplo, puedo "probar" la correcci√≥n de la clasificaci√≥n por el m√©todo de inserci√≥n de la siguiente manera: <br><br><ol><li>  <i>La opci√≥n b√°sica</i> : si agrega un elemento a la lista vac√≠a, ser√° el √∫nico elemento, por lo que se ordenar√°. <br></li><li>  Si tenemos una lista ordenada con k elementos y agregamos un elemento, entonces insertamos el elemento para que quede despu√©s de todos los n√∫meros m√°s peque√±os y antes de todos los n√∫meros m√°s grandes.  Esto significa que la lista todav√≠a est√° ordenada. <br></li><li>  Por inducci√≥n, la ordenaci√≥n por inserci√≥n ordenar√° toda la lista. </li></ol><br>  Obviamente, en realidad, la prueba se ver√° m√°s rigurosa, pero esta es una idea general.  Dijkstra y otros utilizaron este estilo para demostrar la exactitud de muchos algoritmos, incluidos muchos de los conceptos b√°sicos de concurrencia.  Este es tambi√©n el estilo con el que se asocian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">las palabras de Knuth</a> : "Cuidado con los errores en este c√≥digo;  Solo prob√© que era correcto, pero no lo empec√© ".  Puede arruinar f√°cilmente una prueba matem√°tica para que nadie se d√© cuenta.  Seg√∫n algunas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">estimaciones</a> , aproximadamente el 20% de la evidencia matem√°tica publicada contiene errores.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://web.archive.org/web/20140630071239/">Peter Guttmann</a> tiene un excelente ensayo sobre la evidencia de la salud de un programa rid√≠culo, donde toneladas de c√≥digo "probado" caen inmediatamente si los ejecuta. <br><br>  Al mismo tiempo, estudiamos formas de probar autom√°ticamente teoremas matem√°ticos.  El primer <b>programa para probar los teoremas</b> se public√≥ en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1967</a> .  A <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">principios de</a> la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">d√©cada de 1970,</a> tales programas comenzaron a usarse para probar el c√≥digo Pascal, y a mediados de la d√©cada aparecieron los idiomas formales especiales.  El programador formula algunas propiedades del c√≥digo y luego crea una prueba verificable de que el c√≥digo tiene estas propiedades.  Los primeros programas para probar teoremas simplemente ayudaron a las personas a verificar las pruebas, mientras que las herramientas m√°s sofisticadas pod√≠an probar de forma independiente partes del teorema. <br><br>  Lo que lleva al siguiente problema. <br><br><h3>  Es dif√≠cil obtener evidencia </h3><br>  La evidencia es dif√≠cil, y es un trabajo muy desagradable.  Es dif√≠cil dejar la programaci√≥n e ir al circo.  ¬°Sorprendentemente, las pruebas formales de c√≥digo son a menudo m√°s estrictas que las pruebas escritas por la mayor√≠a de los matem√°ticos!  La matem√°tica es una actividad muy creativa, donde la respuesta al teorema es v√°lida solo si la muestra.  La creatividad va mal con el formalismo y las computadoras. <br><br>  Tome el mismo ejemplo de clasificaci√≥n de inserci√≥n donde aplicamos la inducci√≥n.  Cualquier matem√°tico comprender√° de inmediato qu√© es la inducci√≥n, c√≥mo funciona en general y c√≥mo funciona en este caso.  Pero en el programa para probar los teoremas todo debe ser estrictamente formalizado.  Lo mismo ocurre con la prueba por contradicci√≥n, la prueba por contraposici√≥n, etc. Adem√°s, todos los supuestos deben formalizarse, incluso aquellos en los que la mayor√≠a de los matem√°ticos no se molestan con la prueba.  Por ejemplo, <code>a + (b + c) = (a + b) + c</code> .  El programa para verificar teoremas a priori no sabe que esto es cierto.  Tienes que demostrarlo (dif√≠cil), o declararlo como verdad de acuerdo con la ley asociativa de adici√≥n (peligroso), o comprar una biblioteca de teoremas de alguien que ya ha podido demostrarlo (costoso).  Los primeros programas de prueba de teoremas compitieron en el n√∫mero de t√°cticas de prueba incorporadas y bibliotecas de teoremas relacionadas.  Uno de los primeros programas SPADE extendidos present√≥ la biblioteca aritm√©tica completa como la principal ventaja. <br><br>  A continuaci√≥n, debe obtener la prueba en s√≠.  Puede confiar esto al programa o escribirlo usted mismo.  Por lo general, la definici√≥n autom√°tica de evidencia no es decidible.  Para casos extremadamente estrechos, como la l√≥gica proposicional o la verificaci√≥n de tipo HM, es "solo" NP-completo.  De hecho, nosotros mismos escribimos la mayor parte de la evidencia, y la computadora verifica su correcci√≥n.  Esto significa que necesita saber bien: <br><br><ul><li>  matematicas <br></li><li>  ciencias de la computaci√≥n; <br></li><li>  el √°rea en la que trabaja: compiladores, hardware, etc. <br></li><li>  los matices de su programa y especializaci√≥n; <br></li><li>  Los matices del programa para probar los teoremas que utiliza, que en s√≠ mismo es una especialidad completa. </li></ul><br>  Peor a√∫n, los palos espec√≠ficos de la computadora se ponen en las ruedas.  ¬øRecuerdas que dije que era peligroso asumir una ley de adici√≥n asociativa?  Algunos idiomas no lo cumplen.  Por ejemplo, en C ++ <code>INT_MAX. ((-1) + INT_MAX) + 1</code>  <code>INT_MAX. ((-1) + INT_MAX) + 1</code> es <code>INT_MAX. -1 + (INT_MAX + 1)</code>  <code>INT_MAX. -1 + (INT_MAX + 1)</code> , que es indetectable.  Suponiendo una adici√≥n asociativa en C ++, su prueba ser√° incorrecta y el c√≥digo se romper√°.  Debe evitar esta declaraci√≥n o demostrar que nunca se producir√° un desbordamiento de su fragmento en particular. <br><br>  Puede decir que la suma indefinida es un error, pero necesita usar un lenguaje con enteros no relacionados.  Pero la mayor√≠a de los idiomas tienen caracter√≠sticas espec√≠ficas que interfieren con la evidencia.  Toma el siguiente c√≥digo: <br><br><pre> <code class="plaintext hljs">a = true; b = false; f(a); assert a;</code> </pre> <br>  ¬øEs este siempre el caso?  No es un hecho  Quiz√°s <code>f</code> cambie <code>a</code> .  Tal vez cambie el flujo paralelo.  Quiz√°s a <code>b</code> asignado un alias <code>a</code> , por lo que cambiarlo tambi√©n cambiar√° <code>a</code> (nota: los alias hacen que sea tan dif√≠cil escribir evidencia de que John C. Reynolds tuvo que crear una <b>l√≥gica de separaci√≥n</b> completamente nueva para tratar este problema).  Si algo as√≠ es posible en su idioma, entonces debe demostrar claramente que esto no sucede aqu√≠.  El c√≥digo limpio ayudar√° aqu√≠, en otro caso, puede destruir la prueba, ya que obliga al uso de funciones de recursi√≥n y de orden superior.  Por cierto, ambos son la base para escribir buenos programas funcionales.  ¬°Lo que es bueno para la programaci√≥n es malo para la prueba!  (Nota: en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esta conferencia,</a> Edmund Clark enumer√≥ algunas propiedades que son dif√≠ciles de verificar: "puntos flotantes, cadenas, tipos definidos por el usuario, procedimientos, concurrencia, plantillas universales, almacenamiento, bibliotecas ..."). <br><br>  Los verificadores formales tienen un dilema: cuanto m√°s expresivo es el lenguaje, m√°s dif√≠cil es probar algo.  Pero cuanto menos expresivo es el lenguaje, m√°s dif√≠cil es escribir sobre √©l.  Los primeros lenguajes formales de trabajo eran subconjuntos muy limitados de lenguajes m√°s expresivos: ACL2 era un subconjunto de Lisp, Euclid era un subconjunto de Pascal, etc. Y nada de lo que hemos discutido hasta ahora en realidad prueba programas reales, estos son solo intentos de acercamiento a escribir evidencia. <br><br>  La evidencia es dif√≠cil.  Pero se est√° volviendo m√°s f√°cil.  Los investigadores en este campo agregan nuevas heur√≠sticas, bibliotecas de teoremas, componentes probados previamente, etc. El progreso t√©cnico tambi√©n ayuda: mientras m√°s r√°pidas sean las computadoras, m√°s r√°pida ser√° la b√∫squeda. <br><br><h3>  Revoluci√≥n SMT </h3><br>  Una de las innovaciones a mediados de la d√©cada de 2000 fue la inclusi√≥n de solucionadores SMT en programas para probar teoremas.  En t√©rminos generales, un solucionador SMT puede convertir (algunos) teoremas matem√°ticos en problemas de cumplimiento de restricciones.  Esto convierte una tarea creativa en una computacional.  Es posible que a√∫n necesite proporcionarle problemas intermedios (lemas) como pasos en el teorema, pero esto es mejor que probarlo todo usted mismo.  Los primeros solucionadores SMT aparecieron alrededor de 2004, primero como proyectos acad√©micos.  Un par de a√±os despu√©s, Microsoft Research lanz√≥ el Z3, un solucionador SMT est√°ndar.  La gran ventaja del Z3 fue que se volvi√≥ mucho m√°s conveniente de usar que otros SMT, que, francamente, no dijeron casi nada.  Microsoft Research lo utiliz√≥ internamente para ayudar a probar las propiedades del kernel de Windows, por lo que no se limitaron a una experiencia de usuario m√≠nima. <br><br>  SMT golpe√≥ a la comunidad FM en voz baja porque de repente hizo trivial muchas pruebas simples y le permiti√≥ abordar problemas muy complejos.  Por lo tanto, las personas podr√≠an trabajar en lenguajes m√°s expresivos, ya que ahora los problemas de las declaraciones expresivas comenzaron a resolverse.  Un progreso incre√≠ble es evidente en el proyecto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">IronFleet</a> : usando los mejores solucionadores SMT y un lenguaje de verificaci√≥n avanzado, ¬°Microsoft pudo escribir 5,000 l√≠neas de c√≥digo Dafny probado en solo 3.7 a√±os-hombre!  Este es un ritmo incre√≠blemente r√°pido: <i>hasta cuatro l√≠neas completas por d√≠a</i> (nota: el registro anterior pertenec√≠a a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">seL4</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cuyos</a> desarrolladores escribieron <i>dos l√≠neas por d√≠a en C.</i> <br><br>  La evidencia es dif√≠cil. <br><br><h3>  ¬øPor qu√© se necesita esto? </h3><br>  Es hora de dar un paso atr√°s y preguntar: "¬øCu√°l es el punto?"  Estamos tratando de demostrar que alg√∫n programa cumple con algunas especificaciones.  La correcci√≥n es un rango.  Hay dos partes para la verificaci√≥n: cu√°n objetivamente "correcto" es su programa y cu√°n cuidadosamente verific√≥ la correcci√≥n.  Obviamente, cuanto m√°s verificado, mejor, pero la verificaci√≥n vale la pena el tiempo y el dinero.  Si tenemos varias restricciones (rendimiento, tiempo de comercializaci√≥n, costo, etc.), una validaci√≥n completa no es necesariamente la mejor opci√≥n.  Entonces surge la pregunta, ¬øcu√°l es la verificaci√≥n m√≠nima que necesitamos y cu√°nto cuesta?  En la mayor√≠a de los casos, por ejemplo, 90% o 95% o 99% de correcci√≥n es suficiente para usted.  ¬øQuiz√°s deber√≠a dedicar tiempo a mejorar la interfaz, en lugar de verificar el 1% restante? <br><br>  Entonces la pregunta: "¬øEs un cheque del 90/95/99% mucho m√°s barato que el 100%?"  La respuesta es si.  Es bastante c√≥modo decir que la base del c√≥digo, que probamos y escribimos bien, <i>es b√°sicamente</i> correcta, excepto por algunas correcciones en la producci√≥n, e incluso escribimos m√°s de cuatro l√≠neas de c√≥digo por d√≠a.  De hecho, la gran mayor√≠a de las fallas en los sistemas distribuidos podr√≠an haberse evitado con pruebas un poco m√°s exhaustivas.  Y es solo una extensi√≥n de las pruebas, sin mencionar las pruebas difusas, basadas en propiedades o pruebas de modelos.  Puede obtener un resultado realmente sobresaliente con estos simples trucos sin tener que obtener una prueba completa. <br><br>  ¬øQu√© pasa si escribir y probar no proporcionan una verificaci√≥n suficiente?  Todav√≠a es mucho m√°s f√°cil cambiar del 90% al 99% que del 99% al 100%.  Como se mencion√≥ anteriormente, Cleanroom es una pr√°ctica para desarrolladores que incluye documentaci√≥n exhaustiva, an√°lisis exhaustivo del flujo y amplias revisiones de c√≥digo.  Sin evidencia, sin verificaci√≥n formal, ni siquiera pruebas unitarias.  Pero una Sala Limpia adecuadamente organizada reduce la densidad de defectos a menos de 1 error por 1000 l√≠neas de c√≥digo en la producci√≥n (nota: cifras del estudio de Stavley en <i>Programaci√≥n hacia un defecto cero</i> &gt; pero siempre sea <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esc√©ptico y verifique la fuente</a> ).  La programaci√≥n de salas limpias no ralentiza el ritmo de desarrollo, y ciertamente va m√°s r√°pido que 4 l√≠neas por d√≠a.  Y Cleanroom en s√≠ es solo uno de los muchos m√©todos de desarrollo de software altamente confiables que se encuentran entre el desarrollo habitual y la verificaci√≥n del c√≥digo.  No necesita una verificaci√≥n completa para escribir un buen software o incluso casi perfecto.  Hay momentos en que se necesita, pero para la mayor√≠a de las industrias es una p√©rdida de dinero. <br><br>  Sin embargo, esto no significa que los m√©todos formales sean generalmente poco econ√≥micos.  Muchos de los m√©todos altamente confiables mencionados anteriormente se basan en escribir especificaciones de c√≥digo que usted no prueba formalmente.  En t√©rminos de verificaci√≥n, hay dos formas comunes en que la industria se beneficia.  Primero, la verificaci√≥n del dise√±o en lugar del c√≥digo, que discutiremos m√°s adelante.  En segundo lugar, una verificaci√≥n parcial del c√≥digo, que consideraremos ahora. <br><br><h2>  Verificaci√≥n parcial de c√≥digo </h2><br>  Para las tareas cotidianas, es demasiado costoso hacer una verificaci√≥n completa.  ¬øQu√© tal parcial?  Despu√©s de todo, puede beneficiarse de la prueba de algunas propiedades de fragmentos de c√≥digo individuales.  En lugar de demostrar que mi funci√≥n siempre ordena los n√∫meros correctamente, al menos puedo demostrar que no se repite para siempre y nunca se sale del rango.  Esta tambi√©n es informaci√≥n muy √∫til.  Entonces, incluso la evidencia m√°s simple para los programas en C es una excelente manera <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de eliminar una gran parte del comportamiento indefinido</a> . <br><br>  El problema es la <i>accesibilidad</i> .       ,     .             ,          ,    .             ,   C  Java.      . , SPARK    Ada,        SPARK       Ada.      . <br><br>         .      ‚Äî  :    ,  <i>tail</i>   tail,    ,    <code>[a] -&gt; [a]</code> .      Rust      Pony     .     SPARK  Frama-C ,    <i></i>  .         ,      :     ,    . ,    ,  Rust  Haskell,      . <br><br><h1>   </h1><br>         .        ,       ,  .    ,    <b> </b> :  - ,    ,  ,  ,      . <br><br>    ,     ,  .        - ,  -   .     , ,   ,     ,     ,             .        ,      , ,  ,    <abbr title="       ,   ,  &nbsp;‚Äî ,    ">  </abbr> .           ,    .      ,         ,    . <br><br>  ,      ¬´  ,             ¬ª.   ,   ,   .    ?     -  ?         ?         ¬´    ¬ª     : <br><br><ul><li>      , <i>   </i> ?      <i></i>  ? <br></li><li>   ?  ?      ?      ? <br></li><li>          ?      ,    ?    ¬´¬ª     ,     ? <br></li><li>  ,       ?   ? <br></li><li>     ?    ¬´  ¬ª      ? <br></li><li>   GDPR? <br></li><li>      . </li></ul><br>          .      ,    ,           ,      .      ,    ,      ,  . <br><br>  ,        ,   <b> </b>   .       ,    ,         (:         <b></b> ).         (DL),      ( ,    ;    ¬´ ¬ª,          ). <br><br> ,   DL  VDM   1972 .          .  DL     ,      (CVL).  ,   DL    ,  CVL ‚Äî   .        ,  DL     .  ,      DL: <br><br><table><tbody><tr><th>  Idioma </th><th>   </th><th>  </th></tr><tr><td> Z </td><td> - </td><td>   </td></tr><tr><td> Promela </td><td>  </td><td> CSP </td></tr><tr><td> SDL </td><td>  </td><td> - </td></tr><tr><td>    </td><td>  </td><td>  </td></tr><tr><td>    </td><td>  </td><td>  </td></tr></tbody></table><br>  DL      ,            .  ,   .   ,  DL       .      Praxis ( Altran),   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¬´--¬ª</a> ‚Äî  Z-   SPARK ‚Äî     .     ,           . <br><br>     Alloy   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a>  Chord,     -. AWS   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">35-  </a> ,   TLA+.   ,     ,        . <br><br>          -    .       ,        ,   .      ,    ,        .      .    -  DL,      ,     ,   . <br><br>  ,       ,    ‚Äî   . <br><br><h2>   </h2><br>      ,    ,  .  ,      :   <b>  </b> (model checker).   ,   ,        ,      .    ,     (:        ,  JMBC,         ,   ). <br><br>     . -,    ,      . -,   <i></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">escriba evidencia, por lo que la barrera de entrada es mucho m√°s baja. Tercero, si el dise√±o est√° roto, al verificar el modelo se obtendr√° un contraejemplo expl√≠cito. Esto </font><font style="vertical-align: inherit;">hace </font><font style="vertical-align: inherit;">que </font><font style="vertical-align: inherit;">sea </font><font style="vertical-align: inherit;">mucho </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√°s</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> f√°cil corregir el error, especialmente si se requieren 35 pasos para reproducirlo. Intenta encontrarlo t√∫ mismo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hay un par de inconvenientes. En primer lugar, estas herramientas no son tan poderosas. En particular, puede encontrar </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ilimitado</font></font></b> (unbounded) ,      . ,     :        .        ‚Ä¶ ,   ,      .            ,       ,    . <br><br>    ‚Äî <b>   </b> (state-space explosion). ,     ,        ,       .        ,   <code>(4*3)! / (4!)^3 = 34 650</code>   ().         ,       4 300 000.     ,      .    ,       !     ,      .         ,     ,    . <br><br>              :     .       ‚Äî ¬´ ¬ª  ,       .  (  )    .             AWS      . <br><br>       ,            (:   ,  ¬´ ¬ª ‚Äî   ).         ,       ,      . <br><br><h3>     </h3><br>  ,     ,   ,     .      ?   DV  .   ‚Äî   ,    ‚Äî  :     . <br><br>     ,  <i> ‚Äî   </i> .   DL      ,             (:      <b></b> ;   .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> ; ,     (    )  <b></b> :      ). <br><br>       ,          .       , , ,     . <br><br> ,    ,     - .   ,  ,    (, , TDD)      .   ,           ,   . <br><br>         ,   :  TDD ,      TDD,  Haskell ,          . <br><br>   ,  Agile     ,       .  .    ,   ,   Agile,  FM.      ,          .   ,      <i></i>   ,       . <br><br>        ,     ,    . <br><br><h1>  Resumen </h1><br>   ‚Äî  .      ,       SMT-    .  -   , ,    . <br><br>    ,        . ,   .       -      ,      .  ,       . <br><br> ,     ,      .   ,   ,    ¬´ ‚Äî    ¬ª.   ,   -  . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/437296/">https://habr.com/ru/post/437296/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../437280/index.html">F√°cil log√≠stica de bricolaje</a></li>
<li><a href="../437282/index.html">Una introducci√≥n a Kubernetes para usuarios de VMware. Parte 2. Practica</a></li>
<li><a href="../437284/index.html">Profesiones de zool√≥gicos relacionadas con la industria del audio.</a></li>
<li><a href="../437286/index.html">Intento .NET Core + Kubernetes + appmetrics + prometheus + grafana + jobs + cheques de salud</a></li>
<li><a href="../437292/index.html">¬øPor qu√© el modelo tradicional de tienda minorista ya est√° muerto?</a></li>
<li><a href="../437298/index.html">Sobre un chico</a></li>
<li><a href="../437300/index.html">10 habilidades y conocimientos necesarios para un desarrollador principiante de iOS</a></li>
<li><a href="../437304/index.html">C√≥mo comprar papas si eres dalt√≥nico</a></li>
<li><a href="../437306/index.html">Habilidades no obvias requeridas por el gerente de producto</a></li>
<li><a href="../437308/index.html">Ciclo de lecciones de SDL 2.0: Lecci√≥n 4 - Manejo de eventos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>