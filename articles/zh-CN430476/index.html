<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🏫 🍚 🎎 NCBI基因组工作台：濒危研究 👱 🏦 👊🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="现代计算机技术，技术和软件解决方案-所有这些都极大地促进和加速了各种科学研究的实施。 通常，计算机仿真是检验许多理论的唯一方法。 科学软件具有自己的特点。 例如，此类软件通常会经过非常全面的测试，但记录不充分。 但是，软件是人们编写的，人们会犯错误。 科学程序中的错误可能会对整个研究产生怀疑。 本文...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>NCBI基因组工作台：濒危研究</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/430476/"><img src="https://habrastorage.org/getpro/habr/post_images/9ce/9dc/792/9ce9dc792e9661eba72b3692521754be.png" align="left"> 现代计算机技术，技术和软件解决方案-所有这些都极大地促进和加速了各种科学研究的实施。 通常，计算机仿真是检验许多理论的唯一方法。 科学软件具有自己的特点。 例如，此类软件通常会经过非常全面的测试，但记录不充分。 但是，软件是人们编写的，人们会犯错误。 科学程序中的错误可能会对整个研究产生怀疑。 本文将列出在NCBI Genome Workbench软件包的代码中发现的许多问题。 <br><a name="habracut"></a><br><h2> 引言 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NCBI基因组工作台</a>为研究人员提供了广泛的工具，用于研究和分析遗传数据。 用户可以研究和比较来自多个来源的数据，包括NCBI（国家生物技术信息中心）数据库或他们自己的个人数据。 <br><br> 如前所述，单元测试通常涵盖科学软件。 检查该项目时，分析中排除了包含测试文件的85个目录。 这大约是一千个文件。 也许这是由于需要测试用于各种研究而发明的各种复杂算法。 但是其余代码（不是测试代码）的质量却没有我们想要的那么高。 但是，就像在尚未考虑引入静态代码分析工具的任何项目中一样：)。 <br><br> 静态代码分析器为C / C ++ / C＃/ Java- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PVS-Studio</a>提供了用于代码审查（或研究）的数据。 <br><br><h2> 只有两个数字会破坏您的项目 </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dad/9f3/20b/dad9f320b84473428205cc1227a20fe6.png"></div><br><br> 基于我们的错误数据库，当前有超过一万两千个示例被选择，我们注意到并描述了编写导致大量错误的代码的特定模式。 例如，我们进行了以下研究： <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">最后一行的效果</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">C / C ++世界上最危险的函数</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">C / C ++中的逻辑表达式。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">专业人士有多错误</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">邪恶生活在比较功能中</a> 。 </li></ol><br> 该项目标志着新模式描述的开始。 我们正在谈论变量名称中的数字<b>1</b>和<b>2</b> ，例如<i>file1</i>和<i>file2</i>等。 容易混淆两个这样的变量。 这是代码中拼写错误的一种特殊情况，但是一个这样的错误导致人们希望使用同名变量，它们之间的区别仅在于名称末尾的数字1和2。 <br><br> 展望未来，我会说上面列出的所有研究都已在该项目的代码D中得到确认。 <br><br> 考虑Genome Workbench项目的第一个示例： <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V501</a>在“ ||”的左侧和右侧有相同的子表达式“（！Loc1.IsInt（）&amp;&amp;！Loc1.IsWhole（））” 操作员。  nw_aligner.cpp 480 <br><br><pre><code class="cpp hljs">CRef&lt;CSeq_align&gt; CNWAligner::Run(CScope &amp;scope, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CSeq_loc &amp;loc1, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CSeq_loc &amp;loc2, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> trim_end_gaps) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((!loc1.IsInt() &amp;&amp; !loc1.IsWhole()) || (!loc1.IsInt() &amp;&amp; !loc1.IsWhole())) { NCBI_THROW(CException, eUnknown, <span class="hljs-string"><span class="hljs-string">"Only whole and interval locations supported"</span></span>); } .... }</code> </pre> <br> 我们看到两个名为<i>loc1</i>和<i>loc2的</i>变量。 代码中还有一个错误：未使用<i>loc2</i>变量，因为代替了它，再次使用了<i>loc1</i> 。 <br><br> 另一个例子： <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V560</a>条件表达式的一部分始终为false：s1.IsSet（）。  valid_biosource.cpp 3073 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s_PCRPrimerSetLess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> CPCRPrimerSet&amp; s1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> CPCRPrimerSet&amp; s2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!s1.IsSet() &amp;&amp; s1.IsSet()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1.IsSet() &amp;&amp; !s2.IsSet()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!s1.IsSet() &amp;&amp; !s2.IsSet()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1.Get().size() &lt; s2.Get().size()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1.Get().size() &gt; s2.Get().size()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ..... }</code> </pre> <br> 代码的第一行将变量<i>s1</i>和<i>s2</i>混合在一起。 根据名称，这是一个比较功能。 但是这种错误可能随处可见，因为通过命名变量<i>Number 1</i>和<i>Number 2</i> ，程序员几乎肯定会在将来犯一个错误。 并且在函数中使用此类名称的次数越多，出错的可能性就越高。 <br><br><h2> 其他错别字和复制粘贴 </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d5/d9f/f6b/6d5d9ff6bf8083922701b25273fa50b2.png"></div><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V501</a> '！='运算符左右两侧有相同的子表达式：bd.bit_.bits [i]！= Bd.bit_.bits [i] bm.h 296 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compare_state</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> iterator_base&amp; ib)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;block_type_ == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bd.bit_.ptr != ib_db.bit_.ptr) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bd.bit_.idx != ib_db.bit_.idx) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bd.bit_.cnt != ib_db.bit_.cnt) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bd.bit_.pos != ib_db.bit_.pos) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bd.bit_.cnt; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bd.bit_.bits[i] != bd.bit_.bits[i]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } .... }</code> </pre> <br> 我相信经过所有检查之后， <i>bd.bit_</i>和<i>ib_db.bit_对象</i>的<i>位数组</i>的大小是相等的。 因此，该代码的作者编写了一个循环来对位数组进行元素比较，但以其中一个比较对象的名称打错了<i>字</i> 。 结果，在某些情况下，被比较的对象可能被错误地认为是相等的。 <br><br> 这个例子值得“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">邪恶生活在比较功能中</a> ”一文。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V501</a>在“ ||”的左侧和右侧有相同的子表达式“ CFieldHandler :: QualifierNamesAreEquivalent（字段，kFieldTypeSeqId）” 操作员。  field_handler.cpp 152 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CFieldHandlerFactory::s_IsSequenceIDField(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; field) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( CFieldHandler::QualifierNamesAreEquivalent(field, kFieldTypeSeqId) || CFieldHandler::QualifierNamesAreEquivalent(field, kFieldTypeSeqId)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br> 最有可能的检查是多余的。 我没有在代码变量中找到类似于<i>kFieldTypeSeqId的</i>变量。 但是，由于使用“ ||”运算符，可能会导致额外的函数调用，从而降低性能。 <br><br> 另外两个带有分析仪警告的相同类型的场所，需要进行验证： <br><br><ul><li>  V501在'&amp;&amp;'运算符的左侧和右侧有相同的子表达式'uf-&gt; GetData（）。IsBool（）'。  variant_utils.cpp 1711 </li><li>  V501在'&amp;&amp;'运算符的左侧和右侧有相同的子表达式'uf-&gt; GetData（）。IsBool（）'。  variant_utils.cpp 1735 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V766</a>已经添加了具有相同键“ kArgRemote”的项目。  blast_args.cpp 3262 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CBlastAppArgs::x_IssueWarningsForIgnoredOptions(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CArgs&amp; args) { <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; can_override; .... can_override.insert(kArgOutputFormat); can_override.insert(kArgNumDescriptions); can_override.insert(kArgNumAlignments); can_override.insert(kArgMaxTargetSequences); can_override.insert(kArgRemote); <span class="hljs-comment"><span class="hljs-comment">// &lt;= can_override.insert(kArgNumThreads); can_override.insert(kArgInputSearchStrategy); can_override.insert(kArgRemote); // &lt;= can_override.insert("remote_verbose"); can_override.insert("verbose"); .... }</span></span></code> </pre> <br> 分析仪检测到向<i>设置的</i>容器添加了两个相同的值。 回想一下，该容器仅存储唯一值，因此不会向其添加重复项。 <br><br> 类似于上述代码的代码通常是使用copy-paste方法编写的。 可能仅仅是一个额外的值，或者也许作者在复制时忘记重命名其中一个变量。 当您删除一个额外的<i>插入</i>调用时<i>，</i>代码会稍作优化，但这并不重要。 更重要的是，由于集合中缺少元素，可能会在这里隐藏严重错误。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V523'then</a> '语句等效于后续代码片段。  vcf_reader.cpp 1105 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CVcfReader::xAssignFeatureLocationSet(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data.m_SetType == CVcfData::ST_ALL_DEL) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data.m_strRef.size() == <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//deletion of a single base pFeat-&gt;SetLocation().SetPnt().SetPoint(data.m_iPos-1); pFeat-&gt;SetLocation().SetPnt().SetId(*pId); } else { pFeat-&gt;SetLocation().SetInt().SetFrom(data.m_iPos-1); //-1 for 0-based, //another -1 for inclusive end-point ( ie [], not [) ) pFeat-&gt;SetLocation().SetInt().SetTo( data.m_iPos -1 + data.m_strRef.length() - 1); pFeat-&gt;SetLocation().SetInt().SetId(*pId); } return true; } //default: For MNV's we will use the single starting point //NB: For references of size &gt;=2, this location will not //match the reference allele. Future Variation-ref //normalization code will address these issues, //and obviate the need for this code altogether. if (data.m_strRef.size() == 1) { //deletion of a single base pFeat-&gt;SetLocation().SetPnt().SetPoint(data.m_iPos-1); pFeat-&gt;SetLocation().SetPnt().SetId(*pId); } else { pFeat-&gt;SetLocation().SetInt().SetFrom(data.m_iPos-1); pFeat-&gt;SetLocation().SetInt().SetTo( data.m_iPos -1 + data.m_strRef.length() - 1); pFeat-&gt;SetLocation().SetInt().SetId(*pId); } return true; }</span></span></code> </pre> <br> 该函数包含大型且完全相同的代码片段。 但是，它们包含各种附带的注释。 该代码的编写不是最佳，令人困惑的，并且可能包含错误。 <br><br> 带有if-else语句的可疑场所的完整列表如下所示： <br><br><ul><li>  V523'then'语句等效于'else'语句。 第2142章 </li><li>  V523'then'语句等效于后续代码片段。  odbc.c 379 </li><li>  V523'then'语句等效于后续代码片段。  odbc.c 1414 </li><li>  V523'then'语句等效于'else'语句。  seqdbvol.cpp 1922年 </li><li>  V523'then'语句等效于'else'语句。  seqdb_demo.cpp 466 </li><li>  V523'then'语句等效于后续代码片段。  blast_engine.c 1917年 </li><li>  V523'then'语句等效于'else'语句。  blast_filter.c 420 </li><li>  V523'then'语句等效于'else'语句。  blast_parameters.c 636 </li><li>  V523'then'语句等效于'else'语句。 第684章 </li><li>  V523'then'语句等效于'else'语句。  bme.cpp 333 </li><li>  V523'then'语句等效于'else'语句。  gme.cpp 484 </li></ul><br><h2>  / *具有安全性的最好是书呆子* / </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/914/df5/670/914df5670813e7eb410e446f60a0ed5e.png"></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V597</a>编译器可以删除“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">内存集</a> ”函数调用，该函数调用用于刷新“ passwd_buf”缓冲区。  memset_s（）函数应用于擦除私有数据。 第366章 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Crypt a given password using schema required for NTLMv1 authentication * @param passwd clear text domain password * @param challenge challenge data given by server * @param flags NTLM flags from server side * @param answer buffer where to store crypted password */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tds_answer_challenge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAX_PW_SZ 14 .... </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (ntlm_v == 1) { .... </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* with security is best be pedantic */</span></span></span><span class="hljs-meta"> memset(hash, 0, sizeof(hash)); memset(passwd_buf, 0, sizeof(passwd_buf)); memset(ntlm2_challenge, 0, sizeof(ntlm2_challenge)); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { .... } }</span></span></code> </pre> <br> 您可能已经猜到了，在节标题中使用了关于代码安全性的有趣注释。 <br><br> 简而言之，由于不再使用刷新缓冲区，因此编译器将删除<i>memset</i>函数。 而且像<i>hash</i>或<i>passwd_buf</i>这样的数据实际上不会为零。 有关此非显而易见的编译器机制的更多信息，请参见文章“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">安全清除私有数据</a> ”。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V597</a>编译器可以删除“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">内存集</a> ”函数调用，该函数调用用于刷新“答案”对象。  memset_s（）函数应用于擦除私有数据。 第561章 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> TDSRET </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tds7_send_auth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">/* for security reason clear structure */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;answer, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(TDSANSWER)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tds_flush_packet(tds); }</code> </pre> <br> 那不是唯一评论“安全”的例子。 从评论来看，可以假设安全性对于该项目确实非常重要。 因此，我附上已发现问题的整个非小清单： <br><br><ul><li>  V597编译器可能会删除“ memset”函数调用，该函数调用用于刷新“堆”对象。  memset_s（）函数应用于擦除私有数据。  ncbi_heapmgr.c 1300 </li><li>  V597编译器可以删除“内存集”函数调用，该函数调用用于刷新“上下文”对象。  memset_s（）函数应用于擦除私有数据。 第167章 </li><li>  V597编译器可以删除“内存集”函数调用，该函数调用用于刷新“ ks”对象。  memset_s（）函数应用于擦除私有数据。 挑战c 339 </li><li>  V597编译器可以删除“内存集”函数调用，该函数调用用于刷新“ md5_ctx”对象。  memset_s（）函数应用于擦除私有数据。 第353章 </li><li>  V597编译器可以删除“内存集”函数调用，该函数调用用于刷新“哈希”缓冲区。  memset_s（）函数应用于擦除私有数据。  Challenge.c 365 </li><li>  V597编译器可以删除“内存集”函数调用，该函数调用用于刷新“ ks”对象。  memset_s（）函数应用于擦除私有数据。 挑战c 406 </li><li>  V597编译器可以删除“内存集”函数调用，该函数调用用于刷新“ ntlm_v2_response”对象。  memset_s（）函数应用于擦除私有数据。  login.c 795 </li><li>  V597编译器可以删除“内存集”函数调用，该函数调用用于刷新“答案”对象。  memset_s（）函数应用于擦除私有数据。  login.c 801 </li><li>  V597编译器可以删除“内存集”函数调用，该函数调用用于刷新“数据包”缓冲区。  memset_s（）函数应用于擦除私有数据。 数值c 256 </li><li>  V597编译器可以删除“内存集”函数调用，该函数调用用于刷新“数据包”缓冲区。  memset_s（）函数应用于擦除私有数据。 数字c 110 </li><li>  V597编译器可能会删除“ memset”函数调用，该函数调用用于刷新“ pwd”缓冲区。  memset_s（）函数应用于擦除私有数据。  getpassarg.c 50 </li><li>  V597编译器可以删除“内存集”函数调用，该函数调用用于刷新“上下文”对象。  memset_s（）函数应用于擦除私有数据。 挑战c 188 </li><li>  V597编译器可能会删除“ memset”函数调用，该函数调用用于刷新“ buf”缓冲区。  memset_s（）函数应用于擦除私有数据。 第243章 </li><li>  V597编译器可以删除“内存集”函数调用，该函数调用用于刷新“ ntlm_v2_hash”缓冲区。  memset_s（）函数应用于擦除私有数据。 挑战c 309 </li><li>  V597编译器可以删除“内存集”函数调用，该函数调用用于刷新“ md5_ctx”对象。  memset_s（）函数应用于擦除私有数据。 挑战c 354 </li><li>  V597编译器可以删除“内存集”函数调用，该函数调用用于刷新“ passwd_buf”缓冲区。  memset_s（）函数应用于擦除私有数据。 挑战c 380 </li><li>  V597编译器可以删除“内存集”函数调用，该函数调用用于刷新“ ks”对象。  memset_s（）函数应用于擦除私有数据。 第393章 </li><li>  V597编译器可以删除“内存集”函数调用，该函数调用用于刷新“哈希”缓冲区。  memset_s（）函数应用于擦除私有数据。 挑战c 394 </li><li>  V597编译器可以删除“内存集”函数调用，该函数调用用于刷新“ ntlm2_challenge”缓冲区。  memset_s（）函数应用于擦除私有数据。 挑战c 395 </li><li>  V597编译器可以删除“内存集”函数调用，该函数调用用于刷新“ ks”对象。  memset_s（）函数应用于擦除私有数据。 挑战c 419 </li><li>  V597编译器可以删除“内存集”函数调用，该函数调用用于刷新“ ntlm_v2_response”对象。  memset_s（）函数应用于擦除私有数据。 第556章 </li></ul><br><h2> 可疑周期 </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ac/c77/124/8acc77124e5a13a1d25926c95d9eb2cf.png"></div><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V534</a>可能在“ for”运算符内比较了错误的变量。 考虑查看“ i”。  taxFormat.cpp 569 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CTaxFormat::x_LoadTaxTree(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; alignTaxids.size(); i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tax_id = alignTaxids[i]; .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; taxInfo.seqInfoList.size(); j++) { SSeqInfo* seqInfo = taxInfo.seqInfoList[j]; seqInfo-&gt;taxid = newTaxid; } .... } .... }</code> </pre> <br> 我认为，在内部循环的条件下，变量是<i>我</i>随机获得的。 相反，应该使用变量<i>j</i> 。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V535</a>变量“ i”用于该循环和外部循环。 检查行：302、309。sls_alp.cpp 309 <br><br><pre> <code class="cpp hljs">alp::~alp() { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(d_alp_states) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;=d_nalp;i++) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { if(i&lt;=d_alp_states-&gt;d_dim) { if(d_alp_states-&gt;d_elem[i]) { for(i=0;i&lt;=d_nalp;i++) // &lt;= { .... .... }</span></span></code> </pre> <br> 两个嵌套的相同循环（其中还重置了全局计数器）看起来非常可疑。 开发人员应检查此处发生的情况。 <br><br><h2> 数组索引异常 </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a8/136/5b2/4a81365b2534c606f6d12df389841299.png"></div><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V520</a>数组索引表达式'[-i2，-k]'中的逗号运算符'，'。  nw_spliced_aligner16.cpp 564 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CSplicedAligner16::x_DoBackTrace ( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Uint2* backtrace_matrix, CNWAligner::SAlignInOut* data, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i_global_max, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j_global_max) { .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(intron_length &lt; m_IntronMinSize || (Key &amp; donor) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { Key = backtrace_matrix[--i2, --k]; ++intron_length; data-&gt;m_transcript.push_back(eTS_Intron); } .... }</code> </pre> <br> 我必须马上说，似乎没有错误（目前，大声笑）。 考虑以下行： <br><br><pre> <code class="cpp hljs">Key = backtrace_matrix[--i2, --k];</code> </pre> <br> 单词“矩阵”和双索引可能暗示该数组是二维的，但不是二维的。 这是指向整数数组的常规指针。 但是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V520</a>诊断程序并没有出现。 程序员对于如何索引二维数组确实感到困惑。 <br><br> 在这种情况下，作者只是决定保存一行代码，尽管他可以这样写： <br><br><pre> <code class="cpp hljs">--i2; Key = backtrace_matrix[--k];</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V661</a>可疑表达式'A [B == C]'。 可能是“ A [B] == C”。  ncbi_service_connector.c 180 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> EHTTP_HeaderParse </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s_ParseHeader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* header, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">sscanf</span></span>(header, <span class="hljs-string"><span class="hljs-string">"%u.%u.%u.%u%n"</span></span>, &amp;i1, &amp;i2, &amp;i3, &amp;i4, &amp;n) &lt; <span class="hljs-number"><span class="hljs-number">4</span></span> || <span class="hljs-built_in"><span class="hljs-built_in">sscanf</span></span>(header + n, <span class="hljs-string"><span class="hljs-string">"%hu%x%n"</span></span>, &amp;uuu-&gt;port, &amp;tkt, &amp;m) &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> || (header[m += n] &amp;&amp; !(header[m] == <span class="hljs-string"><span class="hljs-string">'$'</span></span>) &amp;&amp; !<span class="hljs-built_in"><span class="hljs-built_in">isspace</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)((header + m) [header[m] == <span class="hljs-string"><span class="hljs-string">'$'</span></span>])))) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span><span class="hljs-comment"><span class="hljs-comment">/*failed - unreadable connection info*/</span></span>; } .... }</code> </pre> <br> 我花了很长时间试图了解正在发生的事情的另一个代码示例：D.  <i>isspace（）</i>函数检查索引为<i>m</i>的字符，但是如果此字符为'$'，则索引为<i>m +1</i>的字符<i>将</i>传递给该函数。 此外，与“ $”的比较已经提前。 也许这里没有错误，但是绝对可以更清楚地重写代码。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V557</a>阵列可能超限。  “行”索引指向数组边界之外。  aln_reader.cpp 412 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CAlnReader::x_IsGap(TNumrow row, TSeqPos pos, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; residue) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_MiddleSections.size() == <span class="hljs-number"><span class="hljs-number">0</span></span>) { x_CalculateMiddleSections(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (row &gt; m_MiddleSections.size()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pos &lt; m_MiddleSections[row].first) { .... } .... }</code> </pre> <br> 这里有一个严重的错误。 正确的<i>行</i>索引检查应如下所示： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (row &gt;= m_MiddleSections.size()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br> 否则，可以访问<i>MiddleSections</i>向量外部的数据。 <br><br> 还有更多这样的地方： <br><br><ul><li>  V557阵列可能超限。  “ i”索引指向数组界限之外。  resource_pool.hpp 388 </li><li>  V557阵列可能超限。  “行”索引指向数组边界之外。  aln_reader.cpp 418 </li><li>  V557阵列可能超限。  “ fmt_idx”索引指向数组界限之外。  seq_writer.cpp 384 </li><li>  V557阵列可能超限。  “ fmt_idx”索引指向数组界限之外。  blastdb_formatter.cpp 183 </li><li>  V557阵列可能超限。  'num'索引指向数组边界之外。  newcleanupp.cpp 13035 </li></ul><br><h2> 如何获得对功能的不信任 </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/147/029/c18/147029c18e4ccacc04f11f688084034f.png"></div><br><br>  V570'm_onClickFunction'变量被分配给它自己。  alngraphic.hpp 103 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetOnClickFunctionName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> onClickFunction)</span></span></span><span class="hljs-function"> </span></span>{ m_onClickFunction = m_onClickFunction; }</code> </pre> <br> 甚至没有什么可评论的。 您只能同情单击某物，单击某物但没有任何变化的人。 <br><br> 将变量分配给自己的另外两种情况将产生一个列表： <br><br><ul><li>  V570将'iter-&gt; level'变量分配给它自己。  align_format_util.cpp 189 </li><li>  V570将'd_elements_values [ind]'变量分配给它自己。  sls_alp_data.cpp 1416 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V763</a>参数“ w1”在使用前总是在功能体中重写。  bmfunc.h 5363 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// Bit COUNT functor template&lt;typename W&gt; struct bit_COUNT { W operator()(W w1, W w2) { w1 = 0; BM_INCWORD_BITCOUNT(w1, w2); return w1; } };</span></span></code> </pre> <br> 在进入函数后立即磨损参数的函数可能会误导使用它的开发人员。 该代码应仔细检查。 <br><br><h2> 类设计错误 </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/033/e75/06c/033e7506c36604696731f73024f57c78.png"></div><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V688'm_qsrc</a> '函数参数具有与类成员之一相同的名称，这可能导致混淆。 第873章 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CElementaryMatching</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CObject { .... ISequenceSource * m_qsrc; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x_CreateIndex</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ISequenceSource *m_qsrc, EIndexMode index_more, ....)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x_CreateRemapData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ISequenceSource *m_qsrc, EIndexMode mode)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x_LoadRemapData</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ISequenceSource *m_qsrc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; sdb)</span></span></span></span>; .... };</code> </pre> <br> 立即有3个类函数包含名称与类字段一致的参数。 这可能导致函数体出错：程序员可能会认为他正在与一个类成员一起工作，实际上是在更改局部变量的值。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V614使用了</a>未初始化的变量'm_BitSet'。  SnpBitAttributes.hpp 187 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// SNP bit attribute container. class CSnpBitAttributes { public: .... private: /// Internal storage for bits. Uint8 m_BitSet; }; inline CSnpBitAttributes::CSnpBitAttributes(Uint8 bits) : m_BitSet(bits) { } inline CSnpBitAttributes::CSnpBitAttributes(const vector&lt;char&gt;&amp; octet_string) { auto count = sizeof(m_BitSet); auto byte = octet_string.end(); do m_BitSet = (m_BitSet &lt;&lt; 8) | *--byte; while (--count &gt; 0); }</span></span></code> </pre> <br> 构造函数之一可<i>随意</i>使用<i>m_BitSet</i>变量。 事实是该变量未初始化。 其“垃圾”值在循环的第一次迭代中使用，此后发生初始化。 这是一个非常严重的错误，导致未定义的程序行为。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V603</a>对象已创建，但未被使用。 如果要调用构造函数，则应使用“ this-&gt; SIntervalComparisonResult :: SIntervalComparisonResult（....）”。  compare_feats.hpp 100 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//This struct keeps the result of comparison of two exons struct SIntervalComparisonResult : CObject { public: SIntervalComparisonResult(unsigned pos1, unsigned pos2, FCompareLocs result, int pos_comparison = 0) : m_exon_ordinal1(pos1), m_exon_ordinal2(pos2), m_result(result), m_position_comparison(pos_comparison) {} SIntervalComparisonResult() { SIntervalComparisonResult(0, 0, fCmp_Unknown, 0); } .... };</span></span></code> </pre> <br> 很久以前，在检查项目时我没有遇到这样的错误。 但是问题仍然存在。 错误是，以这种方式调用参数化构造函数会创建并删除一个临时对象。 并且类字段保持未初始化。 应该通过初始化列表调用另一个构造函数（请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Delegating构造函数</a> ）。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V591</a>非无效函数应返回一个值。 第266章 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// Recursive assignment CBioNode&amp; operator=(const CBioNode&amp; tree) { TParent::operator=(tree); TBioTree* pt = (TBioTree*)tree.GetParentTree(); SetParentTree(pt); }</span></span></code> </pre> <br> 分析器认为该行在重载语句中丢失： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V670</a>未初始化的类成员'm_OutBlobIdOrData'用于初始化'm_StdOut'成员。 请记住，成员是按照类内声明的顺序进行初始化的。  remote_app.hpp 215 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NCBI_XCONNECT_EXPORT</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CRemoteAppResult</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: CRemoteAppResult(CNetCacheAPI::TInstance netcache_api, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> max_inline_size = kMaxBlobInlineSize) : m_NetCacheAPI(netcache_api), m_RetCode(<span class="hljs-number"><span class="hljs-number">-1</span></span>), m_StdOut(netcache_api, m_OutBlobIdOrData, m_OutBlobSize), m_OutBlobSize(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_StdErr(netcache_api, m_ErrBlobIdOrData, m_ErrBlobSize), m_ErrBlobSize(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_StorageType(eBlobStorage), m_MaxInlineSize(max_inline_size) { } .... };</code> </pre> <br> 系统会立即对此代码段发出3个分析器警告。 类字段的初始化不是按照它们在初始化列表中列出的顺序进行，而是按照它们在类中声明的方式进行。 导致此错误的经典原因是，并非所有程序员都记得或知道此规则。 在这里和初始化列表中的顺序是错误的。 人们会感觉到字段列表是以随机顺序输入的。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V746</a>对象切片。 应该通过引用而不是值来捕获异常。 钴cpp 247 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CMultiAligner::SetQueries(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; CRef&lt;objects::CBioseq&gt; &gt;&amp; queries) { .... <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { seq_loc-&gt;SetId(*it-&gt;GetSeqId()); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (objects::CObjMgrException e) { NCBI_THROW(CMultiAlignerException, eInvalidInput, (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>)<span class="hljs-string"><span class="hljs-string">"Missing seq-id in bioseq. "</span></span> + e.GetMsg()); } m_tQueries.push_back(seq_loc); .... }</code> </pre> <br> 由于创建新对象，按值捕获异常可能导致丢失有关该异常的某些信息。 通过引用捕获异常会更好，更安全。 <br><br> 类似的地方： <br><br><ul><li>  V746对象切片。 应该通过引用而不是值来捕获异常。  agp_validate_reader.cpp 562 </li><li>  V746对象切片。 应该通过引用而不是值来捕获异常。  aln_build_app.cpp 320 </li><li>  V746对象切片。 应该通过引用而不是值来捕获异常。  458第458章 </li><li>  V746对象切片。 应该通过引用而不是值来捕获异常。 钴cpp 691 </li><li>  V746对象切片。 应该通过引用而不是值来捕获异常。 钴cpp 719 </li><li>  V746对象切片。 应该通过引用而不是值来捕获异常。 钴cpp 728 </li><li>  V746对象切片。 应该通过引用而不是值来捕获异常。 钴cpp 732 </li></ul><br><h2> 关于无法访问的代码和其他代码执行问题 </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d1/8f5/263/1d18f52633776adc7ca32f92446c4b9f.png"></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V779</a>检测到无法访问的代码。 可能存在错误。  merge_tree_core.cpp 627 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CMergeTree::x_FindBefores_Up_Iter(....) { .... FirstFrame-&gt;Curr = StartCurr; FirstFrame-&gt;Returned = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; FirstFrame-&gt;VisitCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; FrameStack.push_back(FirstFrame); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!FrameStack.empty()) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Rel == CEquivRange::eAfter) { Frame-&gt;Returned = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; FrameStack.pop_back(); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Rel == CEquivRange::eBefore) { .... <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Frame-&gt;VisitCount == <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } } Frame-&gt;Returned = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">// &lt;= FrameStack.pop_back(); continue; } // end stack loop FirstFrame-&gt;ChildFrames.clear(); return FirstFrame-&gt;Returned; }</span></span></code> </pre> <br> 编写条件语句的代码，以便代码的绝对所有分支都以<i>continue</i>语句结尾。 这导致在<i>while循环中</i>形成几行无法访问的代码。 这些行看起来非常可疑。 最有可能的是，此问题在重构代码后出现，现在需要仔细的代码审查。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V519</a>连续两次给'interval_width'变量赋值两次。 也许这是一个错误。 检查行：454、456。aln_writer.cpp 456 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CAlnWriter::AddGaps(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(exon_chunk-&gt;Which()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CSpliced_exon_chunk::e_Match: interval_width = exon_chunk-&gt;GetMatch(); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CSpliced_exon_chunk::e_Mismatch: interval_width = exon_chunk-&gt;GetMismatch(); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CSpliced_exon_chunk::e_Diag: interval_width = exon_chunk-&gt;GetDiag(); genomic_string.append(....); product_string.append(....); genomic_pos += interval_width; product_pos += interval_width/res_width; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; .... } .... }</code> </pre> <br> 变量<i>interval_width被</i>多次覆盖，因为 在<i>case</i>分支中没有<i>break</i>语句。 虽然是经典的，但是却是一个非常糟糕的错误。 <br><br> 其他一些可疑的地方： <br><br><ul><li>  V779检测到无法访问的代码。 可能存在错误。  dbapi_driver_utils.cpp 351 </li><li>  V779检测到无法访问的代码。 可能存在错误。 网络780 </li><li>  V779检测到无法访问的代码。 可能存在错误。  bcp.c 1495 </li><li>  V779检测到无法访问的代码。 可能存在错误。  remote_blast.cpp 1470 </li><li>  V779检测到无法访问的代码。 可能存在错误。  remote_blast.cpp 1522 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V571</a>定期检查。  “ if（m_QueryOpts-&gt; filtering_options）”条件已经在第703行中进行了验证。blast_options_local_priv.hpp 713 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CBlastOptionsLocal::SetFilterString(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* f) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_QueryOpts-&gt;filtering_options) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { SBlastFilterOptions* old_opts = m_QueryOpts-&gt;filtering_options; m_QueryOpts-&gt;filtering_options = NULL; SBlastFilterOptionsMerge(&amp;(m_QueryOpts-&gt;filtering_options), old_opts, new_opts); old_opts = SBlastFilterOptionsFree(old_opts); new_opts = SBlastFilterOptionsFree(new_opts); } else { if (m_QueryOpts-&gt;filtering_options) // &lt;= m_QueryOpts-&gt;filtering_options = SBlastFilterOptionsFree(m_QueryOpts-&gt;filtering_options); m_QueryOpts-&gt;filtering_options = new_opts; new_opts = NULL; } .... }</span></span></code> </pre> <br> 显然， <i>else</i>分支需要重写。 我有一些想使用<i>m_QueryOpts-&gt; filtering_options</i>指针的<i>想法</i> ，但是代码仍然在某种程度上令人困惑。 我呼吁代码的作者。 <br><br> 好吧，这个问题并不孤单： <br><br><ul><li>  V571定期检查。  “ if（睡眠时间）”条件已在第205行中得到验证。request_control.cpp 208 </li><li>  V571定期检查。  “ if（assignValue.empty（））”条件已在第712行中得到验证。classstr.cpp 718 </li></ul><br><h2> 数据读取错误 </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/761/548/f6b/761548f6b44470fe7b64db8ce0b0eb11.png"></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V739</a> EOF不应与“ char”类型的值进行比较。  “ linestring [0]”应为“ int”类型。 第3509章 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> EBool </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s_AfrpInitLineData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( .... </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* linestring = readfunc (pfile); .... </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">while</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (linestring != </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">NULL</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;&amp; linestring [</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">] != EOF) { s_TrimSpace (&amp;linestring); .... } .... }</span></span></span></span></code> </pre> <br> 计划与EOF比较的<i>字符</i>不应存储在<i>char</i>变量中。 否则，存在值0xFF（255）的字符将变为-1并以与文件末尾（EOF）相同的方式进行解释的风险。 同样（以防万一）值得检查<i>readfunc</i>函数的实现。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V663</a>可能出现无限循环。  'cin.eof（）'条件不足以使它脱离循环。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">考虑将'cin.fail（）'函数调用添加到条件表达式中。</font><font style="vertical-align: inherit;">ncbicgi.cpp 1564</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::istream CNcbiIstream; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CCgiRequest::Serialize(CNcbiOstream&amp; os) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... CNcbiIstream* istrm = GetInputStream(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (istrm) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">1024</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!istrm-&gt;eof()) { istrm-&gt;read(buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(buf)); os.write(buf, istrm-&gt;gcount()); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分析仪检测到潜在错误，由于该错误可能发生无限循环。</font><font style="vertical-align: inherit;">如果在读取数据时发生故障，则调用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eof（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数</font><font style="vertical-align: inherit;">将始终返回</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">false</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">为了在这种情况下完成循环，必须对</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fail（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数返回的值进行额外检查</font><font style="vertical-align: inherit;">。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 杂项错误 </font></font></h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/132/51d/701/13251d701a22cae67c852d1bed7d33a5.png"></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V502</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也许'？：'运算符的工作方式与预期的不同。</font><font style="vertical-align: inherit;">'？：'运算符的优先级低于'&amp;&amp;'运算符。</font><font style="vertical-align: inherit;">ncbi_connutil.c 1135</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x_ClientAddress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* client_host, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/*bool*/</span></span></span></span><span class="hljs-function"><span class="hljs-params"> local_host)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((client_host == c &amp;&amp; x_IsSufficientAddress(client_host)) || !(ip = *c &amp;&amp; !local_host ? SOCK_gethostbyname(c) : SOCK_GetLocalHostAddress(eDefault)) || SOCK_ntoa(ip, addr, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(addr)) != <span class="hljs-number"><span class="hljs-number">0</span></span> || !(s = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*) <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(client_host) + <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(addr) + <span class="hljs-number"><span class="hljs-number">3</span></span>))) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> client_host<span class="hljs-comment"><span class="hljs-comment">/*least we can do :-/*/</span></span>; } .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 注意表达式： </font></font><br><br><pre> <code class="cpp hljs">!local_host ? SOCK_gethostbyname(c) : SOCK_GetLocalHostAddress(eDefault)</code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 它不是按程序员期望的那样计算的，因为整个表达式如下所示： </font></font><br><br><pre> <code class="cpp hljs">ip = *c &amp;&amp; !local_host ? SOCK_gethostbyname(c) : SOCK_GetLocalHostAddress(...)</code> </pre> <br><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&amp;&amp;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">运算符的优先级</font><font style="vertical-align: inherit;">高于</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">？：</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">因此，代码无法按预期执行。</font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V561</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给“ seq”变量赋值可能比重新声明它更好。</font><font style="vertical-align: inherit;">先前的声明：validator.cpp，第490行。validator.cpp492</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CValidator::IsSeqLocCorrectlyOrdered(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CSeq_loc&amp; loc, CScope&amp; scope) { CBioseq_Handle seq; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { CBioseq_Handle seq = scope.GetBioseqHandle(loc); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (CObjMgrException&amp; ) { <span class="hljs-comment"><span class="hljs-comment">// no way to tell return true; } catch (const exception&amp; ) { // no way to tell return true; } if (seq &amp;&amp; seq.GetInst_Topology() == CSeq_inst::eTopology_circular) { // no way to check if topology is circular return true; } return CheckConsecutiveIntervals(loc, scope, x_IsCorrectlyOrdered); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于程序员</font><font style="vertical-align: inherit;">在try / catch部分中</font><font style="vertical-align: inherit;">声明了一个新的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seq</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变量</font><font style="vertical-align: inherit;">，因此另一个</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seq</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变量</font><font style="vertical-align: inherit;">仍未初始化，在下面的代码中使用。</font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V562</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将布尔类型值与0进行比较是奇怪的：（（（status）＆0x7f）== 0）！= 0. ncbi_process.cpp 111</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CProcess::CExitInfo::IsExited(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { EXIT_INFO_CHECK; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state != eExitInfo_Terminated) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(NCBI_OS_UNIX) return WIFEXITED(status) != 0; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">elif</span></span></span><span class="hljs-meta"> defined(NCBI_OS_MSWIN) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// The process always terminates with exit code return true; #endif }</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 一切都没有预兆，但事实证明WIFEXITED是一个宏大的开头： </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (((status) &amp; <span class="hljs-number"><span class="hljs-number">0x7f</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) != <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事实证明，该函数返回相反的值。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在代码中，还有另一个这样的函数，它发出警告：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V562将布尔类型值与0进行比较是奇怪的。ncbi_process.cpp 126 </font></font></li></ul><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V595</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在针对nullptr对其进行验证之前，已使用了'dst_len'指针。</font><font style="vertical-align: inherit;">检查行：309、315。zlib.cpp 309</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CZipCompression::CompressBuffer( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* src_buf, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> src_len, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* dst_buf, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> dst_size, <span class="hljs-comment"><span class="hljs-comment">/* out */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>* dst_len) { *dst_len = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Check parameters if (!src_len &amp;&amp; !F_ISSET(fAllowEmptyData)) { src_buf = NULL; } if (!src_buf || !dst_buf || !dst_len) { SetError(Z_STREAM_ERROR, "bad argument"); ERR_COMPRESS(48, FormatErrorMessage("CZipCompression::CompressBuffer")); return false; } .... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dst_len</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指针</font><font style="vertical-align: inherit;">在函数的最开始处</font><i><font style="vertical-align: inherit;">被</font></i><font style="vertical-align: inherit;">取消引用，同时进一步检查代码是否等于零。</font><font style="vertical-align: inherit;">如果</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dst_len</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指针</font><font style="vertical-align: inherit;">为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nullptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则代码中发生错误，导致未定义的行为</font><font style="vertical-align: inherit;">。</font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V590</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">考虑检查'ch！='\ 0'&amp;&amp; ch =='''表达式。</font><font style="vertical-align: inherit;">表达式过多或打印错误。</font><font style="vertical-align: inherit;">cleanup_utils.cpp 580</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Asn2gnbkCompressSpaces</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; val)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ch != <span class="hljs-string"><span class="hljs-string">'\0'</span></span> &amp;&amp; ch == <span class="hljs-string"><span class="hljs-string">' '</span></span>) { ptr++; ch = *ptr; } .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">停止循环的条件仅取决于字符</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ch是否为</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">空格。</font><font style="vertical-align: inherit;">该表达式可以简化为以下形式：</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ch == <span class="hljs-string"><span class="hljs-string">' '</span></span>) { .... }</code> </pre> <br><h2> 结论 </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在科学研究中使用计算机程序可以帮助并且将有助于发现。</font><font style="vertical-align: inherit;">我们希望不要因为错别字而错过特别重要的内容。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我邀请NCBI Genome Workbench项目的开发人员与我们联系，我们将提供由PVS-Studio分析仪发布的完整报告。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">希望这个小小的代码研究可以帮助修复许多错误，并总体上提高项目的可靠性。</font><font style="vertical-align: inherit;">如果尚未在项目代码上运行PVS-Studio，请尝试这样做。</font><font style="vertical-align: inherit;">您可能会喜欢它:)。</font></font><br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您想与说英语的读者分享这篇文章，请使用以下链接：Svyatoslav Razmyslov。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NCBI基因组工作台：受威胁的科学研究</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN430476/">https://habr.com/ru/post/zh-CN430476/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN430466/index.html">迷你AI杯＃3：编写顶级机器人</a></li>
<li><a href="../zh-CN430468/index.html">提高公民意识</a></li>
<li><a href="../zh-CN430470/index.html">为什么要保持客户帐户的背景-诚实而有利可图</a></li>
<li><a href="../zh-CN430472/index.html">DIY无缝DECT网络</a></li>
<li><a href="../zh-CN430474/index.html">CephFS和GlusterFS</a></li>
<li><a href="../zh-CN430478/index.html">加密货币市场的交易机器人。 从哪里开始？</a></li>
<li><a href="../zh-CN430480/index.html">当我们在NASA太空应用程序挑战黑客马拉松上编写应用程序时</a></li>
<li><a href="../zh-CN430482/index.html">东西方文化中的装甲主题</a></li>
<li><a href="../zh-CN430484/index.html">典型的NGFW实施方案</a></li>
<li><a href="../zh-CN430486/index.html">自由职业者的生活：从开发人员到技术撰稿人</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>