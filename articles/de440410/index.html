<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍💻 🖐🏾 👩‍👦 Auswählen, Zwischenspeichern und Anzeigen von Fotos auf der Karte 🎁 👋🏿 ⛎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel habe ich beschlossen zu beschreiben, wie die Funktionalität zum Auswählen und Anzeigen von Fotos an einem bestimmten Ort auf der Kar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Auswählen, Zwischenspeichern und Anzeigen von Fotos auf der Karte</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440410/"><p>  In diesem Artikel habe ich beschlossen zu beschreiben, wie die Funktionalität zum Auswählen und Anzeigen von Fotos an einem bestimmten Ort auf der Karte in unserem Fotoservice <em>gfranq.com implementiert wurde</em> .  Der Fotoservice funktioniert jetzt nicht. </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/storage2/709/48a/e52/70948ae52bacb687d1b882fa7405bed5.jpg"></div><p></p><br><p>  Da wir viele Fotos in unserem Service hatten und jedes Mal, wenn die Änderungen im Ansichtsfenster zu ressourcenintensiv waren, Anfragen an die Datenbank sendeten, war es logisch, die Karte in mehrere Bereiche zu unterteilen, die Informationen zu den abgerufenen Daten enthalten.  Aus offensichtlichen Gründen haben diese Bereiche eine rechteckige Form (obwohl auch ein sechseckiges Gitter berücksichtigt wurde).  Da die Bereiche in großem Maßstab sphärischer werden, wurden auch Elemente der sphärischen Geometrie und Werkzeuge dafür berücksichtigt. </p><br><p>  In diesem Artikel wurden folgende Probleme angesprochen: </p><br><ul><li>  Speichern und Abrufen von Fotos aus der Datenbank und Zwischenspeichern auf dem Server (SQL, C #, ASP.NET). </li><li>  Laden Sie die erforderlichen Fotos auf der Clientseite herunter und speichern Sie sie im Client-Cache (JavaScript). </li><li>  Neuberechnung von Fotos, die ausgeblendet oder angezeigt werden müssen, wenn sich das Ansichtsfenster ändert. </li><li>  Elemente der sphärischen Geometrie. </li></ul><a name="habracut"></a><br><h2 id="contents">  Inhalt </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Serverteil</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eingebaute Geotypen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Normale Auswahl</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zusätzliche Hash-Tabelle verwenden</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zwischenspeichern von Fotos für den Multithread-Zugriff</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Client-Seite</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Karte initialisieren</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bestimmen der Geolokalisierung mit HTML5</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ermitteln der Geolokalisierung anhand von Informationen vom Server</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Berechnung teilweise sichtbarer rechteckiger Flächen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Berechnung der Größe von Caching-Bereichen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwenden der Verzögerung beim Neuzeichnen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Berechnung von Koordinaten und Hashes von teilweise sichtbaren Bereichen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Neuzeichnen der angezeigten Fotos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entfernung auf der Karte</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fazit</a> </li></ul><br><h2 id="server-part">  Serverteil </h2><br><p>  Die folgenden Methoden zum Auswählen und Speichern von Geoinformationen in der Datenbank wurden entwickelt: </p><br><ul><li>  Integrierter Geografiedatentyp von SQL Server. </li><li>  Normale Auswahl mit Einschränkungen. </li><li>  Zusätzliche Tabellen verwenden. </li></ul><br><p>  Ferner werden diese Verfahren ausführlich beschrieben. </p><br><h3 id="built-in-geotypes">  Eingebaute Geotypen </h3><br><p> Bekanntlich unterstützt SQL Server 2008 Geografie- und Geometriedatentypen, mit denen geografische (auf der Kugel) und geometrische (auf der Ebene) Informationen wie Punkte, Linien, Polygone <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">usw. angegeben werden können.</a>  .  Um alle Fotos abzurufen, die von einem Rechteck mit den Koordinaten ( <code>lngMin</code> <code>latMin</code> ) und ( <code>latMax</code> <code>lngMax</code> ) eingeschlossen sind, können Sie die folgende Abfrage verwenden: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> @h geography; <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> @p geography; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> @rect = geography::STGeomFromText(<span class="hljs-string"><span class="hljs-string">'POLYGON((lngMin latMin, lngMax latMin, lngMax latMax, lngMin latMax, lngMin latMin))'</span></span>, <span class="hljs-number"><span class="hljs-number">4326</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> TOP @cound <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, image75Path, geoTag.Lat <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Lat, geoTag.Long <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Lng, popularity, width, height <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Photo <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span>(IX_Photo_geoTag)) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> @rect.STContains(geoTag) = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> popularity <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span></code> </pre> <br><p>  Beachten Sie, dass das Polygon gegen den Uhrzeigersinn ausgerichtet ist und der durch die Koordinaten definierte räumliche Index <code>IX_Photo_geoTag</code> verwendet wird (außerdem werden räumliche Indizes mithilfe von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">B-Bäumen erstellt</a> ). </p><br><p>  Es stellte sich jedoch heraus, dass räumliche Indizes in Microsoft SQL Server 2008 nicht funktionieren, wenn die Spalte mit Geotypen <code>NULL</code> Werte akzeptieren kann und ein zusammengesetzter Index keine Spalte mit dem Geografiedatentyp enthalten kann. Diese Frage wurde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in Stackoverflow erörtert</a> .  Aus diesem Grund wird die Leistung solcher Abfragen (ohne Indizes) sehr gering. </p><br><p>  Die folgenden Ansätze können dieses Problem lösen: </p><br><ul><li>  Da <code>NULL</code> Werte nicht verwendet werden können, sind die Standardwerte für diese Spalte Koordinaten (0, 0), die auf einen Ort im Atlantik in der Nähe von Afrika verweisen (Ausgangspunkt für die Messung von Längen- und Breitengraden).  An diesem Ort und in der Nähe können sich jedoch die realen Punkte befinden, und die Fotos, die nicht von der Karte stammen, sollten ignoriert werden.  Wenn Sie den Nullpunkt (0, 0) in den äußersten Nordpunkt (0, 90) ändern, ist alles viel besser, da der 90. Breitengrad auf den Rand der Karte zeigt und Sie diesen Wert beim Erstellen des Gitters ignorieren sollten (d. H. bis zum Breitengrad 89 aufbauen). </li><li>  Verwenden von SQL Server 2012 oder höher und Ändern der Kompatibilitätsstufe der Datenbank auf 110 oder höher durch Ausführen von <code>ALTER DATABASE database_name SET COMPATIBILITY_LEVEL = 110</code> .  In dieser Version von SQL Server wurde der Fehler mit <code>NULL</code> Werten von Geotypen behoben und die Unterstützung von Polygonen mit unterschiedlichen Ausrichtungen (gegen den Uhrzeigersinn und im Uhrzeigersinn) hinzugefügt. </li></ul><br><p>  Trotz der großen Möglichkeiten von Geotypen (mit denen Sie nicht nur eine einfache Auswahl wie oben gezeigt treffen können, sondern auch Entfernungen und verschiedene Polygone verwenden können) haben wir sie in unserem Projekt nicht verwendet. </p><br><h3 id="normal-selection">  Normale Auswahl </h3><br><p>  Verwenden Sie die folgende Abfrage, um Fotos aus dem durch Koordinaten ( <code>lngMin</code> <code>latMin</code> ) und ( <code>latMax</code> <code>lngMax</code> ) begrenzten Bereich auszuwählen: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> TOP @<span class="hljs-keyword"><span class="hljs-keyword">Count</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">url</span></span>, ... <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Photo <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> latitude &gt; @latMin <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> longitude &gt; @lngMin <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> latitude &lt; @latMax <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> longitude &lt; @lngMax <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> popularity <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span></code> </pre> <br><p>  Beachten Sie, dass Sie in diesem Fall (im Gegensatz zur ersten Methode) beliebige Indizes für <code>latitude</code> und <code>longitude</code> erstellen können, da ein gewöhnlicher Float-Datentyp verwendet wird.  Diese Auswahl enthält jedoch 4 Vergleichsoperationen. </p><br><h3 id="using-additional-hash-table">  Zusätzliche Hash-Tabelle verwenden </h3><br><p>  Die optimalste Lösung für das Problem der Auswahl von Fotos aus bestimmten Bereichen besteht darin, zusätzliche Tabellen- <code>Zooms</code> zu erstellen, in denen Zeichenfolgen gespeichert sind, die für jeden Zoom Hashes von Bereichen enthalten, wie unten gezeigt. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/storage2/dd2/696/223/dd269622322fa5b688101ba38ef68f10.png"></div><br><p>  Die folgende SQL-Abfrage kann verwendet werden ( <code>zn</code> - aktuelle <code>zn</code> ): </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">hash</span></span> <span class="hljs-built_in"><span class="hljs-built_in">float</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">hash</span></span> = (@latMin + <span class="hljs-number"><span class="hljs-number">90</span></span>) + (@lngMin + <span class="hljs-number"><span class="hljs-number">180</span></span>) * <span class="hljs-number"><span class="hljs-number">180</span></span> + (@latMax + <span class="hljs-number"><span class="hljs-number">90</span></span>) * <span class="hljs-number"><span class="hljs-number">64800</span></span> + (@lngMax + <span class="hljs-number"><span class="hljs-number">180</span></span>) * <span class="hljs-number"><span class="hljs-number">11664000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> TOP @<span class="hljs-keyword"><span class="hljs-keyword">Count</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">url</span></span>, ... <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Photo <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> = (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Zooms <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> zn = @<span class="hljs-keyword"><span class="hljs-keyword">hash</span></span>)</code> </pre> <br><p>  Der Nachteil dieses Ansatzes besteht darin, dass die zusätzliche Tabelle zusätzlichen Speicherplatz belegt. </p><br><p>  Trotz der Vorteile der letzteren Methode haben wir die zweite Methode ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">normale Auswahl</a> ) auf dem Server verwendet, da sie eine gute Leistung zeigte. </p><br><h3 id="caching-photos-for-multi-threaded-access">  Zwischenspeichern von Fotos für den Multithread-Zugriff </h3><br><p>  Nach dem Extrahieren der Informationen aus der Datenbank auf die eine oder andere Weise werden Fotos mithilfe eines Synchronisierungsobjekts in den Server-Cache gestellt, um Multithreading wie folgt zu unterstützen: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> SyncObject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>(); ... List&lt;Photo&gt; photos = (List&lt;Photo&gt;)CachedAreas[hash]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (photos == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Use lock to avoid extracting from and adding to the cache more than once. lock (SyncObject) { photos = (List&lt;Photo&gt;)CachedAreas[hash]; if (photos == null) { photos = PhotoList.GetAllFromRect(latMin, lngMin, latMax, lngMax, count); // Adding information about photos to the cache with a storage time of 2 minutes with a high storage priority. CachedAreas.Add(hash, photos, null, DateTime.Now.AddSeconds(120), Cache.NoSlidingExpiration, CacheItemPriority.High, null); } } } // Further usage of CachedAreas[hash]</span></span></code> </pre> <br><p>  In diesem Abschnitt wurden die Serverfunktionen zum Abrufen und Speichern von Fotos aus der Datenbank beschrieben.  Im nächsten Abschnitt wird beschrieben, was auf der Clientseite im Browser geschieht. </p><br><h2 id="client-side">  Client-Seite </h2><br><p>  Zur Visualisierung der Karte und der Fotos wurde die Google Maps-API verwendet.  Zunächst muss die Benutzerkarte an einen bestimmten Ort verschoben werden, der der geografischen Position der Fotos entspricht. </p><br><h3 id="initializing-the-map">  Karte initialisieren </h3><br><p>  Es gibt zwei Möglichkeiten, die Geolokalisierung beim Initialisieren der Karte zu bestimmen: Verwenden Sie die Funktionen von HTML5 oder verwenden Sie vorberechnete Koordinaten für Regionen. </p><br><h4 id="determining-the-geolocation-using-html5">  Bestimmen der Geolokalisierung mit HTML5 </h4><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">detectRegion</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (navigator.geolocation) { navigator.geolocation.getCurrentPosition(success); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { map.setZoom(defaultZoom); map.setCenter(defaultPoint); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">success</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">position</span></span></span><span class="hljs-function">) </span></span>{ ... map.setZoom(defaultZoom); map.setCenter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> google.maps.LatLng(position.coords.latitude, position.coords.longitude)); }</code> </pre> <br><p>  Der Nachteil dieses Ansatzes besteht darin, dass nicht alle Browser diese Funktionalität von HTML5 unterstützen und der Benutzer möglicherweise keinen Zugriff auf Geoinformationen auf seinem Gerät zulässt. </p><br><h4 id="determining-the-geolocation-using-information-from-the-server">  Ermitteln der Geolokalisierung anhand von Informationen vom Server </h4><br><p>  Die Karte wird im folgenden Abschnitt des Quellcodes initialisiert, wobei <code>bounds</code> die Koordinaten der vom Server zurückgegebenen Region (besiedeltes Gebiet, Region oder Land) sind.  Die ungefähre <code>getZoomFromBounds</code> wird in der Funktion <code>getZoomFromBounds</code> (aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stackoverflow entnommen</a> ) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">berechnet</a> . </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> northEast = bounds.getNorthEast(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> southWest = bounds.getSouthWest(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myOptions = { <span class="hljs-attr"><span class="hljs-attr">zoom</span></span>: getZoomFromBounds(northEast, southWest), <span class="hljs-attr"><span class="hljs-attr">center</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> google.maps.LatLng((northEast.lat() + southWest.lat()) / <span class="hljs-number"><span class="hljs-number">2</span></span>, (northEast.lng() + southWest.lng()) / <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-attr"><span class="hljs-attr">mapTypeId</span></span>: google.maps.MapTypeId.ROADMAP, <span class="hljs-attr"><span class="hljs-attr">minZoom</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">maxZoom</span></span>: <span class="hljs-number"><span class="hljs-number">19</span></span> } map = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> google.maps.Map(<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">"map_canvas"</span></span>), myOptions);</code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getZoomFromBounds</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ne, sw</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> GLOBE_WIDTH = <span class="hljs-number"><span class="hljs-number">256</span></span>; <span class="hljs-comment"><span class="hljs-comment">// a constant in Google's map projection var west = sw.lng(); var east = ne.lng(); var angle = east - west; if (angle &lt; 0) { angle += 360; } return Math.round(Math.log($('#map_canvas').width() * 360 / angle / GLOBE_WIDTH) / Math.LN2); }</span></span></code> </pre> <br><p>  Auf dem Server werden die Regionen abhängig von der IP-Adresse des Benutzers berechnet.  Um alle Koordinaten der Grenzen für jede Region zu aggregieren, wurde die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Google-Geokodierungs-API</a> verwendet, obwohl es nicht legitim ist, solche Informationen offline zu verwenden.  Darüber hinaus gibt es ein Limit von 2500 Anfragen pro Tag.  Für jede Stadt, Region und jedes Land aus unserer Datenbank wurde eine Abfrage generiert, die die erforderlichen Grenzen des <code>viewport</code> und der <code>bounds</code> zurückgab.  Sie unterscheiden sich nur für große Bereiche, die nicht vollständig in das Ansichtsfenster passen.  Wenn der Server einen Fehler zurückgegeben hat, wurden andere Abfragen verwendet, in denen die Muttersprache dieser Region oder Englisch verwendet wurde, der Teil {Bestückter Bereich} entfernt wurde usw. <code>http://maps.googleapis.com/maps/api/geocode/xml?address={Country},{Region},{Populated area}&amp;sensor=false</code> </p><br><p>  Beispiel für die folgende Abfrage: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://maps.googleapis.com/maps/api/geocode/xml?address=Russia, Ivanovo% 20 area, Ivanovo &amp; sensor = false</a> </p><br><div class="spoiler">  <b class="spoiler_title">Die folgenden Koordinaten werden zurückgegeben (Fragment)</b> <div class="spoiler_text"><pre> <code class="html hljs xml">... <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">location</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lat</span></span></span><span class="hljs-tag">&gt;</span></span>56.9951313<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lat</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lng</span></span></span><span class="hljs-tag">&gt;</span></span>40.9796047<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lng</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">location</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">location_type</span></span></span><span class="hljs-tag">&gt;</span></span>APPROXIMATE<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">location_type</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">viewport</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">southwest</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lat</span></span></span><span class="hljs-tag">&gt;</span></span>56.9420231<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lat</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lng</span></span></span><span class="hljs-tag">&gt;</span></span>40.8765941<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lng</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">southwest</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">northeast</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lat</span></span></span><span class="hljs-tag">&gt;</span></span>57.0703221<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lat</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lng</span></span></span><span class="hljs-tag">&gt;</span></span>41.0876169<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lng</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">northeast</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">viewport</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bounds</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">southwest</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lat</span></span></span><span class="hljs-tag">&gt;</span></span>56.9420231<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lat</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lng</span></span></span><span class="hljs-tag">&gt;</span></span>40.8765941<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lng</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">southwest</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">northeast</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lat</span></span></span><span class="hljs-tag">&gt;</span></span>57.0703221<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lat</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lng</span></span></span><span class="hljs-tag">&gt;</span></span>41.0876169<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lng</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">northeast</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bounds</span></span></span><span class="hljs-tag">&gt;</span></span> ...</code> </pre> </div></div><br><h3 id="calculating-partially-visible-rectangular-areas">  Berechnung teilweise sichtbarer rechteckiger Flächen </h3><br><h4 id="calculating-the-size-of-caching-areas">  Berechnung der Größe von Caching-Bereichen </h4><br><p>  Wie bereits erwähnt, werden alle Fotos sowohl auf der Client- als auch auf der Serverseite von rechteckigen Bereichen zwischengespeichert, deren Startpunkt ein beliebiger Punkt ist (in unserem Fall der Punkt mit den Koordinaten (0, 0)), und die Größe wird abhängig berechnet auf der aktuellen Zoomstufe wie folgt: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// The initial window at which initMapSizeLat and initMapSizeLng were calculated var initDefaultDimX = 1000, var initDefaultDimY = 800; // The current default viewport which depends on the size of the areas. var currentDefaultDimX = 1080, var currentDefaultDimY = 500; var initMapSizeLat = 0.0003019; var initMapSizeLng = 0.00067055; // The coefficient of size reduction (increase). var initRatio = 0.75; // To calculate the size of the smallest caching area, the map was zoomed in to the maximum zoom level // Ie initMapSizeLat and initMapSizeLng were calculated empirically. var initZoomSize = new google.maps.Size( initMapSizeLat / initDefaultDimX * currentDefaultDimX * initRatio, initMapSizeLng / initDefaultDimY * currentDefaultDimY * initRatio); // All subsequent sizes of areas can be calculated based only on the smallest area (by multiplying each size by 2, because with increasing the zoom level by 1, the linear dimensions increase by 2 times, and the quadratic dimensions increase by 4 times). function initZoomSizes() { zoomSizes = []; var coef = 1; for (var i = 21; i &gt;= 0; i--) { zoomSizes[i] = new google.maps.Size(initZoomSize.width * coef, initZoomSize.height * coef); coef *= 2; } }</span></span></code> </pre> <br><p>  Somit beträgt die Größe des rechteckigen Bereichs bei jeder <code>0.75^2=0.5625</code> gegenüber der Größe des aktuellen Ansichtsfensters, wenn er eine Breite von 1080 Pixel und eine Höhe von 500 Pixel hat. </p><br><h4 id="using-delay-when-redrawing">  Verwenden der Verzögerung beim Neuzeichnen </h4><br><p>  Da das Neuzeichnen aller Fotos auf der Karte kein schneller Vorgang ist (wie später gezeigt wird), haben wir uns entschlossen, dies nach der Benutzereingabe mit einiger Verzögerung zu tun: </p><br><pre> <code class="javascript hljs">google.maps.event.addListener(map, <span class="hljs-string"><span class="hljs-string">'bounds_changed'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (boundsChangedInverval != <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>) clearInterval(boundsChangedInverval); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> zoom = map.getZoom(); boundsChangedInverval = setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ boundsChanged(); }, prevZoom === zoom ? moveUpdateDelay : zoomUpdateDelay); prevZoom = zoom; });</code> </pre> <br><h4 id="calculating-coordinates-and-hashes-of-partially-visible-areas">  Berechnung von Koordinaten und Hashes von teilweise sichtbaren Bereichen </h4><br><p>  Die Berechnung der Koordinaten und Hashes aller Rechtecke, die das sichtbare Fenster mit Koordinaten ( <code>latMin</code> , <code>lngMin</code> ) und Dimensionen überlappen, die mit dem zuvor beschriebenen Algorithmus berechnet wurden, erfolgt wie folgt: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/storage2/d8f/63a/bd7/d8f63abd76978f82b66bd0cc5a06311e.png"></div><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = zoomSizes[zoom]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> beginLat = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor((latMin - initPoint.x) / s.width) * s.width + initPoint.x; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> beginLng = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor((lngMin - initPoint.y) / s.height) * s.height + initPoint.y; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lat = beginLat; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lng = beginLng; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lngMax &lt;= beginLng) beginLng = beginLng - <span class="hljs-number"><span class="hljs-number">360</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (lat &lt;= maxlat) { lng = beginLng; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (lng &lt;= maxLng) { <span class="hljs-comment"><span class="hljs-comment">// lat and normalizeLng(lng) coordinates are the coordinates of the overlapping rectangles. // Longitude normalization is used because the right boundary can be greater than 180 or the left boundary can be less than -180. loadIfNeeded(lat, normalizeLng(lng)); lng += s.height; } lat += s.width; } function normalizeLng(lng) { var rtn = lng % 360; if (rtn &lt;= 0) rtn += 360; if (rtn &gt; 180) rtn -= 360; return rtn; }</span></span></code> </pre> <br><p>  Danach wird für jeden Bereich die folgende Funktion aufgerufen, die bei Bedarf die Anfrage an den Server sendet.  Die Formel der Hash-Berechnung gibt für jeden Bereich einen eindeutigen Wert zurück, da der Startpunkt und die Abmessungen festgelegt sind. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadIfNeeded</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">lat, lng</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hash = calculateHash(lat, lng, zoom); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(hash <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> items)) { <span class="hljs-comment"><span class="hljs-comment">// Send a query to the database and put this cell in the client cache. } else { // Do nothing. } } function calculateHash(lat, lng, zoom) { // lat: [-90..90] // lng: [-180..180] return (lat + 90) + ((lng + 180) * 180) + (zoom * 64800); }</span></span></code> </pre> <br><h3 id="redrawing-the-displayed-photos">  Neuzeichnen der angezeigten Fotos </h3><br><p>  Nachdem alle Fotos heruntergeladen oder aus dem Cache extrahiert wurden, müssen einige neu gezeichnet werden.  Bei einer großen Anzahl von Fotos oder Markierungen an einem Ort sollten einige davon ausgeblendet sein, aber dann wird unklar, wie viele Fotos sich an diesem Ort befinden.  Um dieses Problem zu lösen, haben wir uns entschieden, zwei Arten von Markierungen zu unterstützen: Markierungen, die Fotos anzeigen, und Markierungen, die anzeigen, dass sich an dieser Stelle Fotos befinden.  Wenn außerdem alle Markierungen ausgeblendet werden, wenn die Grenzen geändert und dann erneut angezeigt werden, kann der Benutzer ein Flackern bemerken.  Um diese Probleme zu lösen, wurde der folgende Algorithmus entwickelt: </p><br><ol><li>  Extrahieren aller sichtbaren Fotos aus dem Client-Cache in das Array <code>visMarks</code> .  Die Berechnung dieser Flächen mit Fotos wurde oben beschrieben. </li><li>  Sortieren der empfangenen Marker nach Beliebtheit. </li><li>  Suchen überlappender Marker mithilfe von <code>markerSize</code> , <code>SmallMarkerSize</code> , <code>minPhotoDistRatio</code> und <code>pixelDistance</code> . </li><li>  Erstellen von Arrays mit großen Markern mit <code>maxBigVisPhotosCount</code> und kleinen Markern mit <code>maxSmlVisPhotosCount</code> . </li><li>  Definieren Sie alte Marker, die ausgeblendet werden sollen, und fügen Sie sie mithilfe von <code>refreshMarkerArrays</code> zu <code>smlMarksToHide</code> und <code>bigMarksToHide</code> <code>refreshMarkerArrays</code> . </li><li>  Aktualisieren der Sichtbarkeit und des <code>zIndex</code> für neue Markierungen, die mit <code>updateMarkersVis</code> angezeigt werden <code>updateMarkersVis</code> . </li><li>  Hinzufügen von Fotos, die zum aktuellen Zeitpunkt sichtbar wurden, zum Feed mit <code>addPhotoToRibbon</code> . </li></ol><br><div class="spoiler">  <b class="spoiler_title">Algorithmus zur Neuberechnung sichtbarer Marker</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">redraw</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ isRedrawing = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> visMarker; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> visMarks = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> visBigMarks2; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> visSmlMarks2; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bigMarksToHide = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> smlMarksToHide = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> photo; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i, j; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bounds = map.getBounds(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> northEast = bounds.getNorthEast(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> southWest = bounds.getSouthWest(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> latMin = southWest.lat(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lngMin = southWest.lng(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> latMax = northEast.lat(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lngMax = northEast.lng(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ratio = (latMax - latMin) / $(<span class="hljs-string"><span class="hljs-string">"#map_canvas"</span></span>).height(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> zoom = map.getZoom(); visMarks = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = zoomSizes[zoom]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> beginLat = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor((latMin - initPoint.x) / s.width) * s.width + initPoint.x; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> beginLng = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor((lngMin - initPoint.y) / s.height) * s.height + initPoint.y; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lat = beginLat; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lng = beginLng; i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lngMax &lt;= beginLng) beginLng = beginLng - <span class="hljs-number"><span class="hljs-number">360</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Extracting all visible markers. while (lat &lt;= latMax) { lng = beginLng; while (lng &lt;= lngMax) { var hash = calcHash(lat, normLng(lng), zoom); if (!(hash in curItems)) { } else { var item = curItems[hash]; for (photo in item.photos) { if (bounds.contains(item.photos[photo].latLng)) { visMarks[i] = item.photos[photo]; visMarks[i].overlapCount = 0; i++; } } } k++; lng += s.height; } lat += s.width; } // Sorting markers by popularity. visMarks.sort(function (a, b) { if (b.priority !== a.priority) { return b.priority - a.priority; } else if (b.popularity !== a.popularity) { return b.popularity - a.popularity; } else { return b.id - a.id; } }); // Finding overlapping markers and markers that exceed a certain specified number. var curInd; var contains; var contains2; var dist; visBigMarks2 = []; visSmlMarks2 = []; for (i = 0; i &lt; visMarks.length; i++) { contains = false; contains2 = false; visMarker = visMarks[i]; for (j = 0; j &lt; visBigMarks2.length; j++) { dist = pixelDistance(visMarker.latLng, visBigMarks2[j].latLng, zoom); if (dist &lt;= markerSize * minPhotoDistRatio) { contains = true; if (contains &amp;&amp; contains2) break; } if (dist &lt;= (markerSize + smallMarkerSize) / 2) { contains2 = true; if (contains &amp;&amp; contains2) break; } } if (!contains) { if (visBigMarks2.length &lt; maxBigVisPhotosCount) { smlMarksToHide[smlMarksToHide.length] = visMarker; visBigMarks2[visBigMarks2.length] = visMarker; } } else { bigMarksToHide[bigMarksToHide.length] = visMarker; if (!contains2 &amp;&amp; visSmlMarks2.length &lt; maxSmlVisPhotosCount) { visSmlMarks2[visSmlMarks2.length] = visMarker; } else { visBigMarks2[j].overlapCount++; } } } // Adding markers that should be hidden to smlMarksToHide and bigMarksToHide. refreshMarkerArrays(visibleSmallMarkers, visSmlMarks2, smlMarksToHide); refreshMarkerArrays(visibleBigMarkers, visBigMarks2, bigMarksToHide); // Hiding invisible markers and displaying visible markers when zIndex changes. var curZInd = maxBigVisPhotosCount + 1; curZInd = updateMarkersVis(visBigMarks2, bigMarksToHide, true, curZInd); curZInd = 0; curZInd = updateMarkersVis(visSmlMarks2, smlMarksToHide, false, curZInd); visibleBigMarkers = visBigMarks2; visibleSmallMarkers = visSmlMarks2; // Adding visible photos to the feed. trPhotosOnMap.innerHTML = ''; for (var marker in visBigMarks2) { addPhotoToRibbon(visBigMarks2[marker]); } isRedrawing = false; } function refreshMarkerArrays(oldArr, newArr, toHide) { for (var j = 0; j &lt; oldArr.length; j++) { contains = false; var visMarker = oldArr[j]; for (i = 0; i &lt; newArr.length; i++) { if (newArr[i].id === visMarker.id) { contains = true; break; } } if (!contains) { toHide[toHide.length] = visMarker; } } } function updateMarkersVis(showArr, hideArr, big, curZInd) { var marker; var bounds = map.getBounds(); for (var i = 0; i &lt; showArr.length; i++) { var photo = showArr[i]; if (big) { marker = photo.bigMarker; $('#divOvlpCount' + photo.id).html(photo.overlapCount); } else { marker = photo.smlMarker; } marker.setZIndex(++curZInd); if (marker.getMap() === null) { marker.setMap(map); } } for (i = 0; i &lt; hideArr.length; i++) { marker = big ? hideArr[i].bigMarker : hideArr[i].smlMarker; if (marker.getMap() !== null) { marker.setMap(null); marker.setZIndex(0); if (!bounds.contains(hideArr[i].latLng)) hideArr[i].priority = 0; } } return curZInd; } function addPhotoToRibbon(marker) { var td = createColumn(marker); if (isLatLngValid(marker.latLng)) { trPhotosOnMap.appendChild(td); } else { trPhotosNotOnMap.appendChild(td); if (photoViewMode == 'user') { var img = $("#photo" + marker.id).children()[0]; $('#photo' + marker.id).draggable({ helper: 'clone', appendTo: $('#map_canvas'), stop: function (e) { var mapBoundingRect = document.getElementById("map_canvas").getBoundingClientRect(); var point = new google.maps.Point(e.pageX - mapBoundingRect.left, e.pageY - mapBoundingRect.top); var latLng = overlay.getProjection().fromContainerPixelToLatLng(point); marker.latLng = latLng; marker.priority = ++curPriority; placeMarker(marker); }, containment: 'parent', distance: 5 }); } } }</span></span></code> </pre> </div></div><br><h4 id="distance-on-the-map">  Entfernung auf der Karte </h4><br><p>  Um den Abstand zwischen zwei Punkten auf der Karte in <em>Pixel</em> zu berechnen, wird die folgende Funktion verwendet: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Offset = <span class="hljs-number"><span class="hljs-number">268435456</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Radius = <span class="hljs-number"><span class="hljs-number">85445659.4471</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pixelDistance</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">latLng1, latLng2, zoom</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x1 = lonToX(latLng1.lng()); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y1 = latToY(latLng1.lat()); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x2 = lonToX(latLng2.lng()); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y2 = latToY(latLng2.lat()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)) &gt;&gt; (<span class="hljs-number"><span class="hljs-number">21</span></span> - zoom); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lonToX</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">lng</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(Offset + Radius * lng * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI / <span class="hljs-number"><span class="hljs-number">180</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">latToY</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">lat</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(Offset - Radius * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.log((<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.sin(lat * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI / <span class="hljs-number"><span class="hljs-number">180</span></span>)) / (<span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.sin(lat * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI / <span class="hljs-number"><span class="hljs-number">180</span></span>))) / <span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre> <br><p>  Diese Funktion wurde auch beim Stackoverflow gefunden. </p><br><p>  Um die Markierungen wie Kreise mit Fotos aussehen zu lassen (wie vkontakte), wurde das Plugin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RichMarker</a> verwendet und dem div-Element ein beliebiger Stil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hinzugefügt</a> . </p><br><h2 id="conclusion">  Fazit </h2><br><p>  Es stellte sich heraus, dass wir, um Fotos schnell und korrekt auf der Karte anzuzeigen, interessante und nicht triviale Probleme im Zusammenhang mit Caching und sphärischer Geometrie lösen mussten.  Trotz der Tatsache, dass nicht alle beschriebenen Methoden tatsächlich in unserem Projekt verwendet wurden, wurde keine Zeit verschwendet, da die Erfahrungen, die wir sammeln, in anderen Projekten nützlich sein können und auch für diejenigen nützlich sein können, die diesen Artikel gelesen und verstanden haben. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de440410/">https://habr.com/ru/post/de440410/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de440394/index.html">Eskalation von PostgreSQL-Berechtigungen - CVE-2018-10915-Analyse</a></li>
<li><a href="../de440398/index.html">Geschichte der Teilnahme (und des Sieges) am russischen AI Cup 2018 - CodeBall</a></li>
<li><a href="../de440400/index.html">Apache Kafka + Spring Boot: Hallo, Microservices</a></li>
<li><a href="../de440402/index.html">SearchFace-Entwickler über Algorithmusfunktionen</a></li>
<li><a href="../de440404/index.html">"Informationsarchitektur": Mitap in OZON</a></li>
<li><a href="../de440412/index.html">Zimbra Collaboration Suite und MS Exchange in derselben Domäne</a></li>
<li><a href="../de440414/index.html">Über Linter, Codequalität, Qualität im Allgemeinen und Qualitätsmanagement</a></li>
<li><a href="../de440416/index.html">Kolonie. Kapitel 25: Ausgehen</a></li>
<li><a href="../de440420/index.html">Willkommen zum Devleads Meetup am 21. Februar</a></li>
<li><a href="../de440422/index.html">Wenn Sie für die Qualität des Geschenks verantwortlich sind. Die Geschichte eines Blockchain-Experiments</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>