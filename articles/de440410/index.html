<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèΩ‚Äçüíª üñêüèæ üë©‚Äçüë¶ Ausw√§hlen, Zwischenspeichern und Anzeigen von Fotos auf der Karte üéÅ üëãüèø ‚õé</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel habe ich beschlossen zu beschreiben, wie die Funktionalit√§t zum Ausw√§hlen und Anzeigen von Fotos an einem bestimmten Ort auf der Kar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ausw√§hlen, Zwischenspeichern und Anzeigen von Fotos auf der Karte</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440410/"><p>  In diesem Artikel habe ich beschlossen zu beschreiben, wie die Funktionalit√§t zum Ausw√§hlen und Anzeigen von Fotos an einem bestimmten Ort auf der Karte in unserem Fotoservice <em>gfranq.com implementiert wurde</em> .  Der Fotoservice funktioniert jetzt nicht. </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/storage2/709/48a/e52/70948ae52bacb687d1b882fa7405bed5.jpg"></div><p></p><br><p>  Da wir viele Fotos in unserem Service hatten und jedes Mal, wenn die √Ñnderungen im Ansichtsfenster zu ressourcenintensiv waren, Anfragen an die Datenbank sendeten, war es logisch, die Karte in mehrere Bereiche zu unterteilen, die Informationen zu den abgerufenen Daten enthalten.  Aus offensichtlichen Gr√ºnden haben diese Bereiche eine rechteckige Form (obwohl auch ein sechseckiges Gitter ber√ºcksichtigt wurde).  Da die Bereiche in gro√üem Ma√üstab sph√§rischer werden, wurden auch Elemente der sph√§rischen Geometrie und Werkzeuge daf√ºr ber√ºcksichtigt. </p><br><p>  In diesem Artikel wurden folgende Probleme angesprochen: </p><br><ul><li>  Speichern und Abrufen von Fotos aus der Datenbank und Zwischenspeichern auf dem Server (SQL, C #, ASP.NET). </li><li>  Laden Sie die erforderlichen Fotos auf der Clientseite herunter und speichern Sie sie im Client-Cache (JavaScript). </li><li>  Neuberechnung von Fotos, die ausgeblendet oder angezeigt werden m√ºssen, wenn sich das Ansichtsfenster √§ndert. </li><li>  Elemente der sph√§rischen Geometrie. </li></ul><a name="habracut"></a><br><h2 id="contents">  Inhalt </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Serverteil</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eingebaute Geotypen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Normale Auswahl</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zus√§tzliche Hash-Tabelle verwenden</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zwischenspeichern von Fotos f√ºr den Multithread-Zugriff</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Client-Seite</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Karte initialisieren</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bestimmen der Geolokalisierung mit HTML5</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ermitteln der Geolokalisierung anhand von Informationen vom Server</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Berechnung teilweise sichtbarer rechteckiger Fl√§chen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Berechnung der Gr√∂√üe von Caching-Bereichen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwenden der Verz√∂gerung beim Neuzeichnen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Berechnung von Koordinaten und Hashes von teilweise sichtbaren Bereichen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Neuzeichnen der angezeigten Fotos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entfernung auf der Karte</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fazit</a> </li></ul><br><h2 id="server-part">  Serverteil </h2><br><p>  Die folgenden Methoden zum Ausw√§hlen und Speichern von Geoinformationen in der Datenbank wurden entwickelt: </p><br><ul><li>  Integrierter Geografiedatentyp von SQL Server. </li><li>  Normale Auswahl mit Einschr√§nkungen. </li><li>  Zus√§tzliche Tabellen verwenden. </li></ul><br><p>  Ferner werden diese Verfahren ausf√ºhrlich beschrieben. </p><br><h3 id="built-in-geotypes">  Eingebaute Geotypen </h3><br><p> Bekanntlich unterst√ºtzt SQL Server 2008 Geografie- und Geometriedatentypen, mit denen geografische (auf der Kugel) und geometrische (auf der Ebene) Informationen wie Punkte, Linien, Polygone <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">usw. angegeben werden k√∂nnen.</a>  .  Um alle Fotos abzurufen, die von einem Rechteck mit den Koordinaten ( <code>lngMin</code> <code>latMin</code> ) und ( <code>latMax</code> <code>lngMax</code> ) eingeschlossen sind, k√∂nnen Sie die folgende Abfrage verwenden: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> @h geography; <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> @p geography; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> @rect = geography::STGeomFromText(<span class="hljs-string"><span class="hljs-string">'POLYGON((lngMin latMin, lngMax latMin, lngMax latMax, lngMin latMax, lngMin latMin))'</span></span>, <span class="hljs-number"><span class="hljs-number">4326</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> TOP @cound <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, image75Path, geoTag.Lat <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Lat, geoTag.Long <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Lng, popularity, width, height <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Photo <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span>(IX_Photo_geoTag)) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> @rect.STContains(geoTag) = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> popularity <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span></code> </pre> <br><p>  Beachten Sie, dass das Polygon gegen den Uhrzeigersinn ausgerichtet ist und der durch die Koordinaten definierte r√§umliche Index <code>IX_Photo_geoTag</code> verwendet wird (au√üerdem werden r√§umliche Indizes mithilfe von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">B-B√§umen erstellt</a> ). </p><br><p>  Es stellte sich jedoch heraus, dass r√§umliche Indizes in Microsoft SQL Server 2008 nicht funktionieren, wenn die Spalte mit Geotypen <code>NULL</code> Werte akzeptieren kann und ein zusammengesetzter Index keine Spalte mit dem Geografiedatentyp enthalten kann. Diese Frage wurde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in Stackoverflow er√∂rtert</a> .  Aus diesem Grund wird die Leistung solcher Abfragen (ohne Indizes) sehr gering. </p><br><p>  Die folgenden Ans√§tze k√∂nnen dieses Problem l√∂sen: </p><br><ul><li>  Da <code>NULL</code> Werte nicht verwendet werden k√∂nnen, sind die Standardwerte f√ºr diese Spalte Koordinaten (0, 0), die auf einen Ort im Atlantik in der N√§he von Afrika verweisen (Ausgangspunkt f√ºr die Messung von L√§ngen- und Breitengraden).  An diesem Ort und in der N√§he k√∂nnen sich jedoch die realen Punkte befinden, und die Fotos, die nicht von der Karte stammen, sollten ignoriert werden.  Wenn Sie den Nullpunkt (0, 0) in den √§u√üersten Nordpunkt (0, 90) √§ndern, ist alles viel besser, da der 90. Breitengrad auf den Rand der Karte zeigt und Sie diesen Wert beim Erstellen des Gitters ignorieren sollten (d. H. bis zum Breitengrad 89 aufbauen). </li><li>  Verwenden von SQL Server 2012 oder h√∂her und √Ñndern der Kompatibilit√§tsstufe der Datenbank auf 110 oder h√∂her durch Ausf√ºhren von <code>ALTER DATABASE database_name SET COMPATIBILITY_LEVEL = 110</code> .  In dieser Version von SQL Server wurde der Fehler mit <code>NULL</code> Werten von Geotypen behoben und die Unterst√ºtzung von Polygonen mit unterschiedlichen Ausrichtungen (gegen den Uhrzeigersinn und im Uhrzeigersinn) hinzugef√ºgt. </li></ul><br><p>  Trotz der gro√üen M√∂glichkeiten von Geotypen (mit denen Sie nicht nur eine einfache Auswahl wie oben gezeigt treffen k√∂nnen, sondern auch Entfernungen und verschiedene Polygone verwenden k√∂nnen) haben wir sie in unserem Projekt nicht verwendet. </p><br><h3 id="normal-selection">  Normale Auswahl </h3><br><p>  Verwenden Sie die folgende Abfrage, um Fotos aus dem durch Koordinaten ( <code>lngMin</code> <code>latMin</code> ) und ( <code>latMax</code> <code>lngMax</code> ) begrenzten Bereich auszuw√§hlen: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> TOP @<span class="hljs-keyword"><span class="hljs-keyword">Count</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">url</span></span>, ... <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Photo <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> latitude &gt; @latMin <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> longitude &gt; @lngMin <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> latitude &lt; @latMax <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> longitude &lt; @lngMax <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> popularity <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span></code> </pre> <br><p>  Beachten Sie, dass Sie in diesem Fall (im Gegensatz zur ersten Methode) beliebige Indizes f√ºr <code>latitude</code> und <code>longitude</code> erstellen k√∂nnen, da ein gew√∂hnlicher Float-Datentyp verwendet wird.  Diese Auswahl enth√§lt jedoch 4 Vergleichsoperationen. </p><br><h3 id="using-additional-hash-table">  Zus√§tzliche Hash-Tabelle verwenden </h3><br><p>  Die optimalste L√∂sung f√ºr das Problem der Auswahl von Fotos aus bestimmten Bereichen besteht darin, zus√§tzliche Tabellen- <code>Zooms</code> zu erstellen, in denen Zeichenfolgen gespeichert sind, die f√ºr jeden Zoom Hashes von Bereichen enthalten, wie unten gezeigt. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/storage2/dd2/696/223/dd269622322fa5b688101ba38ef68f10.png"></div><br><p>  Die folgende SQL-Abfrage kann verwendet werden ( <code>zn</code> - aktuelle <code>zn</code> ): </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">hash</span></span> <span class="hljs-built_in"><span class="hljs-built_in">float</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">hash</span></span> = (@latMin + <span class="hljs-number"><span class="hljs-number">90</span></span>) + (@lngMin + <span class="hljs-number"><span class="hljs-number">180</span></span>) * <span class="hljs-number"><span class="hljs-number">180</span></span> + (@latMax + <span class="hljs-number"><span class="hljs-number">90</span></span>) * <span class="hljs-number"><span class="hljs-number">64800</span></span> + (@lngMax + <span class="hljs-number"><span class="hljs-number">180</span></span>) * <span class="hljs-number"><span class="hljs-number">11664000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> TOP @<span class="hljs-keyword"><span class="hljs-keyword">Count</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">url</span></span>, ... <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Photo <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> = (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Zooms <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> zn = @<span class="hljs-keyword"><span class="hljs-keyword">hash</span></span>)</code> </pre> <br><p>  Der Nachteil dieses Ansatzes besteht darin, dass die zus√§tzliche Tabelle zus√§tzlichen Speicherplatz belegt. </p><br><p>  Trotz der Vorteile der letzteren Methode haben wir die zweite Methode ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">normale Auswahl</a> ) auf dem Server verwendet, da sie eine gute Leistung zeigte. </p><br><h3 id="caching-photos-for-multi-threaded-access">  Zwischenspeichern von Fotos f√ºr den Multithread-Zugriff </h3><br><p>  Nach dem Extrahieren der Informationen aus der Datenbank auf die eine oder andere Weise werden Fotos mithilfe eines Synchronisierungsobjekts in den Server-Cache gestellt, um Multithreading wie folgt zu unterst√ºtzen: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> SyncObject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>(); ... List&lt;Photo&gt; photos = (List&lt;Photo&gt;)CachedAreas[hash]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (photos == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Use lock to avoid extracting from and adding to the cache more than once. lock (SyncObject) { photos = (List&lt;Photo&gt;)CachedAreas[hash]; if (photos == null) { photos = PhotoList.GetAllFromRect(latMin, lngMin, latMax, lngMax, count); // Adding information about photos to the cache with a storage time of 2 minutes with a high storage priority. CachedAreas.Add(hash, photos, null, DateTime.Now.AddSeconds(120), Cache.NoSlidingExpiration, CacheItemPriority.High, null); } } } // Further usage of CachedAreas[hash]</span></span></code> </pre> <br><p>  In diesem Abschnitt wurden die Serverfunktionen zum Abrufen und Speichern von Fotos aus der Datenbank beschrieben.  Im n√§chsten Abschnitt wird beschrieben, was auf der Clientseite im Browser geschieht. </p><br><h2 id="client-side">  Client-Seite </h2><br><p>  Zur Visualisierung der Karte und der Fotos wurde die Google Maps-API verwendet.  Zun√§chst muss die Benutzerkarte an einen bestimmten Ort verschoben werden, der der geografischen Position der Fotos entspricht. </p><br><h3 id="initializing-the-map">  Karte initialisieren </h3><br><p>  Es gibt zwei M√∂glichkeiten, die Geolokalisierung beim Initialisieren der Karte zu bestimmen: Verwenden Sie die Funktionen von HTML5 oder verwenden Sie vorberechnete Koordinaten f√ºr Regionen. </p><br><h4 id="determining-the-geolocation-using-html5">  Bestimmen der Geolokalisierung mit HTML5 </h4><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">detectRegion</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (navigator.geolocation) { navigator.geolocation.getCurrentPosition(success); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { map.setZoom(defaultZoom); map.setCenter(defaultPoint); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">success</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">position</span></span></span><span class="hljs-function">) </span></span>{ ... map.setZoom(defaultZoom); map.setCenter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> google.maps.LatLng(position.coords.latitude, position.coords.longitude)); }</code> </pre> <br><p>  Der Nachteil dieses Ansatzes besteht darin, dass nicht alle Browser diese Funktionalit√§t von HTML5 unterst√ºtzen und der Benutzer m√∂glicherweise keinen Zugriff auf Geoinformationen auf seinem Ger√§t zul√§sst. </p><br><h4 id="determining-the-geolocation-using-information-from-the-server">  Ermitteln der Geolokalisierung anhand von Informationen vom Server </h4><br><p>  Die Karte wird im folgenden Abschnitt des Quellcodes initialisiert, wobei <code>bounds</code> die Koordinaten der vom Server zur√ºckgegebenen Region (besiedeltes Gebiet, Region oder Land) sind.  Die ungef√§hre <code>getZoomFromBounds</code> wird in der Funktion <code>getZoomFromBounds</code> (aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stackoverflow entnommen</a> ) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">berechnet</a> . </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> northEast = bounds.getNorthEast(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> southWest = bounds.getSouthWest(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myOptions = { <span class="hljs-attr"><span class="hljs-attr">zoom</span></span>: getZoomFromBounds(northEast, southWest), <span class="hljs-attr"><span class="hljs-attr">center</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> google.maps.LatLng((northEast.lat() + southWest.lat()) / <span class="hljs-number"><span class="hljs-number">2</span></span>, (northEast.lng() + southWest.lng()) / <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-attr"><span class="hljs-attr">mapTypeId</span></span>: google.maps.MapTypeId.ROADMAP, <span class="hljs-attr"><span class="hljs-attr">minZoom</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">maxZoom</span></span>: <span class="hljs-number"><span class="hljs-number">19</span></span> } map = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> google.maps.Map(<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">"map_canvas"</span></span>), myOptions);</code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getZoomFromBounds</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ne, sw</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> GLOBE_WIDTH = <span class="hljs-number"><span class="hljs-number">256</span></span>; <span class="hljs-comment"><span class="hljs-comment">// a constant in Google's map projection var west = sw.lng(); var east = ne.lng(); var angle = east - west; if (angle &lt; 0) { angle += 360; } return Math.round(Math.log($('#map_canvas').width() * 360 / angle / GLOBE_WIDTH) / Math.LN2); }</span></span></code> </pre> <br><p>  Auf dem Server werden die Regionen abh√§ngig von der IP-Adresse des Benutzers berechnet.  Um alle Koordinaten der Grenzen f√ºr jede Region zu aggregieren, wurde die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Google-Geokodierungs-API</a> verwendet, obwohl es nicht legitim ist, solche Informationen offline zu verwenden.  Dar√ºber hinaus gibt es ein Limit von 2500 Anfragen pro Tag.  F√ºr jede Stadt, Region und jedes Land aus unserer Datenbank wurde eine Abfrage generiert, die die erforderlichen Grenzen des <code>viewport</code> und der <code>bounds</code> zur√ºckgab.  Sie unterscheiden sich nur f√ºr gro√üe Bereiche, die nicht vollst√§ndig in das Ansichtsfenster passen.  Wenn der Server einen Fehler zur√ºckgegeben hat, wurden andere Abfragen verwendet, in denen die Muttersprache dieser Region oder Englisch verwendet wurde, der Teil {Best√ºckter Bereich} entfernt wurde usw. <code>http://maps.googleapis.com/maps/api/geocode/xml?address={Country},{Region},{Populated area}&amp;sensor=false</code> </p><br><p>  Beispiel f√ºr die folgende Abfrage: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://maps.googleapis.com/maps/api/geocode/xml?address=Russia, Ivanovo% 20 area, Ivanovo &amp; sensor = false</a> </p><br><div class="spoiler">  <b class="spoiler_title">Die folgenden Koordinaten werden zur√ºckgegeben (Fragment)</b> <div class="spoiler_text"><pre> <code class="html hljs xml">... <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">location</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lat</span></span></span><span class="hljs-tag">&gt;</span></span>56.9951313<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lat</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lng</span></span></span><span class="hljs-tag">&gt;</span></span>40.9796047<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lng</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">location</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">location_type</span></span></span><span class="hljs-tag">&gt;</span></span>APPROXIMATE<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">location_type</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">viewport</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">southwest</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lat</span></span></span><span class="hljs-tag">&gt;</span></span>56.9420231<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lat</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lng</span></span></span><span class="hljs-tag">&gt;</span></span>40.8765941<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lng</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">southwest</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">northeast</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lat</span></span></span><span class="hljs-tag">&gt;</span></span>57.0703221<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lat</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lng</span></span></span><span class="hljs-tag">&gt;</span></span>41.0876169<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lng</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">northeast</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">viewport</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bounds</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">southwest</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lat</span></span></span><span class="hljs-tag">&gt;</span></span>56.9420231<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lat</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lng</span></span></span><span class="hljs-tag">&gt;</span></span>40.8765941<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lng</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">southwest</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">northeast</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lat</span></span></span><span class="hljs-tag">&gt;</span></span>57.0703221<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lat</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lng</span></span></span><span class="hljs-tag">&gt;</span></span>41.0876169<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lng</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">northeast</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bounds</span></span></span><span class="hljs-tag">&gt;</span></span> ...</code> </pre> </div></div><br><h3 id="calculating-partially-visible-rectangular-areas">  Berechnung teilweise sichtbarer rechteckiger Fl√§chen </h3><br><h4 id="calculating-the-size-of-caching-areas">  Berechnung der Gr√∂√üe von Caching-Bereichen </h4><br><p>  Wie bereits erw√§hnt, werden alle Fotos sowohl auf der Client- als auch auf der Serverseite von rechteckigen Bereichen zwischengespeichert, deren Startpunkt ein beliebiger Punkt ist (in unserem Fall der Punkt mit den Koordinaten (0, 0)), und die Gr√∂√üe wird abh√§ngig berechnet auf der aktuellen Zoomstufe wie folgt: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// The initial window at which initMapSizeLat and initMapSizeLng were calculated var initDefaultDimX = 1000, var initDefaultDimY = 800; // The current default viewport which depends on the size of the areas. var currentDefaultDimX = 1080, var currentDefaultDimY = 500; var initMapSizeLat = 0.0003019; var initMapSizeLng = 0.00067055; // The coefficient of size reduction (increase). var initRatio = 0.75; // To calculate the size of the smallest caching area, the map was zoomed in to the maximum zoom level // Ie initMapSizeLat and initMapSizeLng were calculated empirically. var initZoomSize = new google.maps.Size( initMapSizeLat / initDefaultDimX * currentDefaultDimX * initRatio, initMapSizeLng / initDefaultDimY * currentDefaultDimY * initRatio); // All subsequent sizes of areas can be calculated based only on the smallest area (by multiplying each size by 2, because with increasing the zoom level by 1, the linear dimensions increase by 2 times, and the quadratic dimensions increase by 4 times). function initZoomSizes() { zoomSizes = []; var coef = 1; for (var i = 21; i &gt;= 0; i--) { zoomSizes[i] = new google.maps.Size(initZoomSize.width * coef, initZoomSize.height * coef); coef *= 2; } }</span></span></code> </pre> <br><p>  Somit betr√§gt die Gr√∂√üe des rechteckigen Bereichs bei jeder <code>0.75^2=0.5625</code> gegen√ºber der Gr√∂√üe des aktuellen Ansichtsfensters, wenn er eine Breite von 1080 Pixel und eine H√∂he von 500 Pixel hat. </p><br><h4 id="using-delay-when-redrawing">  Verwenden der Verz√∂gerung beim Neuzeichnen </h4><br><p>  Da das Neuzeichnen aller Fotos auf der Karte kein schneller Vorgang ist (wie sp√§ter gezeigt wird), haben wir uns entschlossen, dies nach der Benutzereingabe mit einiger Verz√∂gerung zu tun: </p><br><pre> <code class="javascript hljs">google.maps.event.addListener(map, <span class="hljs-string"><span class="hljs-string">'bounds_changed'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (boundsChangedInverval != <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>) clearInterval(boundsChangedInverval); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> zoom = map.getZoom(); boundsChangedInverval = setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ boundsChanged(); }, prevZoom === zoom ? moveUpdateDelay : zoomUpdateDelay); prevZoom = zoom; });</code> </pre> <br><h4 id="calculating-coordinates-and-hashes-of-partially-visible-areas">  Berechnung von Koordinaten und Hashes von teilweise sichtbaren Bereichen </h4><br><p>  Die Berechnung der Koordinaten und Hashes aller Rechtecke, die das sichtbare Fenster mit Koordinaten ( <code>latMin</code> , <code>lngMin</code> ) und Dimensionen √ºberlappen, die mit dem zuvor beschriebenen Algorithmus berechnet wurden, erfolgt wie folgt: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/storage2/d8f/63a/bd7/d8f63abd76978f82b66bd0cc5a06311e.png"></div><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = zoomSizes[zoom]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> beginLat = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor((latMin - initPoint.x) / s.width) * s.width + initPoint.x; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> beginLng = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor((lngMin - initPoint.y) / s.height) * s.height + initPoint.y; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lat = beginLat; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lng = beginLng; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lngMax &lt;= beginLng) beginLng = beginLng - <span class="hljs-number"><span class="hljs-number">360</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (lat &lt;= maxlat) { lng = beginLng; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (lng &lt;= maxLng) { <span class="hljs-comment"><span class="hljs-comment">// lat and normalizeLng(lng) coordinates are the coordinates of the overlapping rectangles. // Longitude normalization is used because the right boundary can be greater than 180 or the left boundary can be less than -180. loadIfNeeded(lat, normalizeLng(lng)); lng += s.height; } lat += s.width; } function normalizeLng(lng) { var rtn = lng % 360; if (rtn &lt;= 0) rtn += 360; if (rtn &gt; 180) rtn -= 360; return rtn; }</span></span></code> </pre> <br><p>  Danach wird f√ºr jeden Bereich die folgende Funktion aufgerufen, die bei Bedarf die Anfrage an den Server sendet.  Die Formel der Hash-Berechnung gibt f√ºr jeden Bereich einen eindeutigen Wert zur√ºck, da der Startpunkt und die Abmessungen festgelegt sind. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadIfNeeded</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">lat, lng</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hash = calculateHash(lat, lng, zoom); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(hash <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> items)) { <span class="hljs-comment"><span class="hljs-comment">// Send a query to the database and put this cell in the client cache. } else { // Do nothing. } } function calculateHash(lat, lng, zoom) { // lat: [-90..90] // lng: [-180..180] return (lat + 90) + ((lng + 180) * 180) + (zoom * 64800); }</span></span></code> </pre> <br><h3 id="redrawing-the-displayed-photos">  Neuzeichnen der angezeigten Fotos </h3><br><p>  Nachdem alle Fotos heruntergeladen oder aus dem Cache extrahiert wurden, m√ºssen einige neu gezeichnet werden.  Bei einer gro√üen Anzahl von Fotos oder Markierungen an einem Ort sollten einige davon ausgeblendet sein, aber dann wird unklar, wie viele Fotos sich an diesem Ort befinden.  Um dieses Problem zu l√∂sen, haben wir uns entschieden, zwei Arten von Markierungen zu unterst√ºtzen: Markierungen, die Fotos anzeigen, und Markierungen, die anzeigen, dass sich an dieser Stelle Fotos befinden.  Wenn au√üerdem alle Markierungen ausgeblendet werden, wenn die Grenzen ge√§ndert und dann erneut angezeigt werden, kann der Benutzer ein Flackern bemerken.  Um diese Probleme zu l√∂sen, wurde der folgende Algorithmus entwickelt: </p><br><ol><li>  Extrahieren aller sichtbaren Fotos aus dem Client-Cache in das Array <code>visMarks</code> .  Die Berechnung dieser Fl√§chen mit Fotos wurde oben beschrieben. </li><li>  Sortieren der empfangenen Marker nach Beliebtheit. </li><li>  Suchen √ºberlappender Marker mithilfe von <code>markerSize</code> , <code>SmallMarkerSize</code> , <code>minPhotoDistRatio</code> und <code>pixelDistance</code> . </li><li>  Erstellen von Arrays mit gro√üen Markern mit <code>maxBigVisPhotosCount</code> und kleinen Markern mit <code>maxSmlVisPhotosCount</code> . </li><li>  Definieren Sie alte Marker, die ausgeblendet werden sollen, und f√ºgen Sie sie mithilfe von <code>refreshMarkerArrays</code> zu <code>smlMarksToHide</code> und <code>bigMarksToHide</code> <code>refreshMarkerArrays</code> . </li><li>  Aktualisieren der Sichtbarkeit und des <code>zIndex</code> f√ºr neue Markierungen, die mit <code>updateMarkersVis</code> angezeigt werden <code>updateMarkersVis</code> . </li><li>  Hinzuf√ºgen von Fotos, die zum aktuellen Zeitpunkt sichtbar wurden, zum Feed mit <code>addPhotoToRibbon</code> . </li></ol><br><div class="spoiler">  <b class="spoiler_title">Algorithmus zur Neuberechnung sichtbarer Marker</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">redraw</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ isRedrawing = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> visMarker; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> visMarks = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> visBigMarks2; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> visSmlMarks2; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bigMarksToHide = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> smlMarksToHide = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> photo; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i, j; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bounds = map.getBounds(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> northEast = bounds.getNorthEast(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> southWest = bounds.getSouthWest(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> latMin = southWest.lat(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lngMin = southWest.lng(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> latMax = northEast.lat(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lngMax = northEast.lng(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ratio = (latMax - latMin) / $(<span class="hljs-string"><span class="hljs-string">"#map_canvas"</span></span>).height(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> zoom = map.getZoom(); visMarks = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = zoomSizes[zoom]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> beginLat = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor((latMin - initPoint.x) / s.width) * s.width + initPoint.x; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> beginLng = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor((lngMin - initPoint.y) / s.height) * s.height + initPoint.y; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lat = beginLat; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lng = beginLng; i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lngMax &lt;= beginLng) beginLng = beginLng - <span class="hljs-number"><span class="hljs-number">360</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Extracting all visible markers. while (lat &lt;= latMax) { lng = beginLng; while (lng &lt;= lngMax) { var hash = calcHash(lat, normLng(lng), zoom); if (!(hash in curItems)) { } else { var item = curItems[hash]; for (photo in item.photos) { if (bounds.contains(item.photos[photo].latLng)) { visMarks[i] = item.photos[photo]; visMarks[i].overlapCount = 0; i++; } } } k++; lng += s.height; } lat += s.width; } // Sorting markers by popularity. visMarks.sort(function (a, b) { if (b.priority !== a.priority) { return b.priority - a.priority; } else if (b.popularity !== a.popularity) { return b.popularity - a.popularity; } else { return b.id - a.id; } }); // Finding overlapping markers and markers that exceed a certain specified number. var curInd; var contains; var contains2; var dist; visBigMarks2 = []; visSmlMarks2 = []; for (i = 0; i &lt; visMarks.length; i++) { contains = false; contains2 = false; visMarker = visMarks[i]; for (j = 0; j &lt; visBigMarks2.length; j++) { dist = pixelDistance(visMarker.latLng, visBigMarks2[j].latLng, zoom); if (dist &lt;= markerSize * minPhotoDistRatio) { contains = true; if (contains &amp;&amp; contains2) break; } if (dist &lt;= (markerSize + smallMarkerSize) / 2) { contains2 = true; if (contains &amp;&amp; contains2) break; } } if (!contains) { if (visBigMarks2.length &lt; maxBigVisPhotosCount) { smlMarksToHide[smlMarksToHide.length] = visMarker; visBigMarks2[visBigMarks2.length] = visMarker; } } else { bigMarksToHide[bigMarksToHide.length] = visMarker; if (!contains2 &amp;&amp; visSmlMarks2.length &lt; maxSmlVisPhotosCount) { visSmlMarks2[visSmlMarks2.length] = visMarker; } else { visBigMarks2[j].overlapCount++; } } } // Adding markers that should be hidden to smlMarksToHide and bigMarksToHide. refreshMarkerArrays(visibleSmallMarkers, visSmlMarks2, smlMarksToHide); refreshMarkerArrays(visibleBigMarkers, visBigMarks2, bigMarksToHide); // Hiding invisible markers and displaying visible markers when zIndex changes. var curZInd = maxBigVisPhotosCount + 1; curZInd = updateMarkersVis(visBigMarks2, bigMarksToHide, true, curZInd); curZInd = 0; curZInd = updateMarkersVis(visSmlMarks2, smlMarksToHide, false, curZInd); visibleBigMarkers = visBigMarks2; visibleSmallMarkers = visSmlMarks2; // Adding visible photos to the feed. trPhotosOnMap.innerHTML = ''; for (var marker in visBigMarks2) { addPhotoToRibbon(visBigMarks2[marker]); } isRedrawing = false; } function refreshMarkerArrays(oldArr, newArr, toHide) { for (var j = 0; j &lt; oldArr.length; j++) { contains = false; var visMarker = oldArr[j]; for (i = 0; i &lt; newArr.length; i++) { if (newArr[i].id === visMarker.id) { contains = true; break; } } if (!contains) { toHide[toHide.length] = visMarker; } } } function updateMarkersVis(showArr, hideArr, big, curZInd) { var marker; var bounds = map.getBounds(); for (var i = 0; i &lt; showArr.length; i++) { var photo = showArr[i]; if (big) { marker = photo.bigMarker; $('#divOvlpCount' + photo.id).html(photo.overlapCount); } else { marker = photo.smlMarker; } marker.setZIndex(++curZInd); if (marker.getMap() === null) { marker.setMap(map); } } for (i = 0; i &lt; hideArr.length; i++) { marker = big ? hideArr[i].bigMarker : hideArr[i].smlMarker; if (marker.getMap() !== null) { marker.setMap(null); marker.setZIndex(0); if (!bounds.contains(hideArr[i].latLng)) hideArr[i].priority = 0; } } return curZInd; } function addPhotoToRibbon(marker) { var td = createColumn(marker); if (isLatLngValid(marker.latLng)) { trPhotosOnMap.appendChild(td); } else { trPhotosNotOnMap.appendChild(td); if (photoViewMode == 'user') { var img = $("#photo" + marker.id).children()[0]; $('#photo' + marker.id).draggable({ helper: 'clone', appendTo: $('#map_canvas'), stop: function (e) { var mapBoundingRect = document.getElementById("map_canvas").getBoundingClientRect(); var point = new google.maps.Point(e.pageX - mapBoundingRect.left, e.pageY - mapBoundingRect.top); var latLng = overlay.getProjection().fromContainerPixelToLatLng(point); marker.latLng = latLng; marker.priority = ++curPriority; placeMarker(marker); }, containment: 'parent', distance: 5 }); } } }</span></span></code> </pre> </div></div><br><h4 id="distance-on-the-map">  Entfernung auf der Karte </h4><br><p>  Um den Abstand zwischen zwei Punkten auf der Karte in <em>Pixel</em> zu berechnen, wird die folgende Funktion verwendet: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Offset = <span class="hljs-number"><span class="hljs-number">268435456</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Radius = <span class="hljs-number"><span class="hljs-number">85445659.4471</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pixelDistance</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">latLng1, latLng2, zoom</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x1 = lonToX(latLng1.lng()); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y1 = latToY(latLng1.lat()); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x2 = lonToX(latLng2.lng()); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y2 = latToY(latLng2.lat()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)) &gt;&gt; (<span class="hljs-number"><span class="hljs-number">21</span></span> - zoom); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lonToX</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">lng</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(Offset + Radius * lng * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI / <span class="hljs-number"><span class="hljs-number">180</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">latToY</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">lat</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(Offset - Radius * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.log((<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.sin(lat * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI / <span class="hljs-number"><span class="hljs-number">180</span></span>)) / (<span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.sin(lat * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI / <span class="hljs-number"><span class="hljs-number">180</span></span>))) / <span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre> <br><p>  Diese Funktion wurde auch beim Stackoverflow gefunden. </p><br><p>  Um die Markierungen wie Kreise mit Fotos aussehen zu lassen (wie vkontakte), wurde das Plugin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RichMarker</a> verwendet und dem div-Element ein beliebiger Stil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hinzugef√ºgt</a> . </p><br><h2 id="conclusion">  Fazit </h2><br><p>  Es stellte sich heraus, dass wir, um Fotos schnell und korrekt auf der Karte anzuzeigen, interessante und nicht triviale Probleme im Zusammenhang mit Caching und sph√§rischer Geometrie l√∂sen mussten.  Trotz der Tatsache, dass nicht alle beschriebenen Methoden tats√§chlich in unserem Projekt verwendet wurden, wurde keine Zeit verschwendet, da die Erfahrungen, die wir sammeln, in anderen Projekten n√ºtzlich sein k√∂nnen und auch f√ºr diejenigen n√ºtzlich sein k√∂nnen, die diesen Artikel gelesen und verstanden haben. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de440410/">https://habr.com/ru/post/de440410/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de440394/index.html">Eskalation von PostgreSQL-Berechtigungen - CVE-2018-10915-Analyse</a></li>
<li><a href="../de440398/index.html">Geschichte der Teilnahme (und des Sieges) am russischen AI Cup 2018 - CodeBall</a></li>
<li><a href="../de440400/index.html">Apache Kafka + Spring Boot: Hallo, Microservices</a></li>
<li><a href="../de440402/index.html">SearchFace-Entwickler √ºber Algorithmusfunktionen</a></li>
<li><a href="../de440404/index.html">"Informationsarchitektur": Mitap in OZON</a></li>
<li><a href="../de440412/index.html">Zimbra Collaboration Suite und MS Exchange in derselben Dom√§ne</a></li>
<li><a href="../de440414/index.html">√úber Linter, Codequalit√§t, Qualit√§t im Allgemeinen und Qualit√§tsmanagement</a></li>
<li><a href="../de440416/index.html">Kolonie. Kapitel 25: Ausgehen</a></li>
<li><a href="../de440420/index.html">Willkommen zum Devleads Meetup am 21. Februar</a></li>
<li><a href="../de440422/index.html">Wenn Sie f√ºr die Qualit√§t des Geschenks verantwortlich sind. Die Geschichte eines Blockchain-Experiments</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>