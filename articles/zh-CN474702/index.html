<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍💼 🥋 ♓️ 从EcmaScript角度进行功能编程。 纯函数，λ，抗扰度 🚸 🤧 🍢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！ 

 今天，我们将开始讨论一个非常重要的主题-函数式编程。 FP在现代Web开发中的重要性很难高估。 任何大型现代项目的体系结构都包括用户定义的功能库，并且在任何级别的面试中，FI都将存在强制性问题。 

 函数式编程简介 
 函数式编程（FP）是通过编写一组函数来组织代码的方式。 

 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>从EcmaScript角度进行功能编程。 纯函数，λ，抗扰度</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474702/">哈Ha！ <br><br> 今天，我们将开始讨论一个非常重要的主题-函数式编程。  FP在现代Web开发中的重要性很难高估。 任何大型现代项目的体系结构都包括用户定义的功能库，并且在任何级别的面试中，FI都将存在强制性问题。 <br><br><h2> 函数式编程简介 </h2><br>  <b>函数式编程（FP）</b>是通过编写一组函数来组织代码的方式。 <br><br>  EcmaScript是一种多范式编程语言，它实现了一种功能范式。 这意味着ES中的函数是数据，可以传递给函数，从函数返回并可以接受函数本身。 即  ES中的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">函数</a>是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一流的函数</a> 。 <br><br> 从此得出以下定义： <br><br>  <b>功能参数（funarg）</b> -参数值为函数的参数。 <br><br>  <b>高阶函数（FWP，高阶函数，hof）</b>是接受函数作为参数的函数。 <br><br>  <b>具有函数值的函数（函数值函数）</b> -返回函数的函数。 <br><br> 所有这些类型的功能有条件地组合到第一类的功能中，并且根据上述定义，在ES中，所有功能都是第一类的对象。 <br><a name="habracut"></a><br><h3> 纯函数-函数式编程的理想选择 </h3><br>  <b>纯函数（PF）</b> -始终返回预测结果。 <br>  PF特性： <br><br><ul><li>  PF执行的结果仅取决于传递的参数和实现PF的算法 </li><li> 不要使用全局值 </li><li> 不要修改外部值或传递的参数 </li><li> 不要将数据写入文件，数据库或其他任何地方 </li></ul><br> 一个纯函数的例子： <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> add = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x,y</span></span></span><span class="hljs-function">) =&gt;</span></span> x+y;</code> </pre> <br> 函数杂质的一个很好的例子是： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> first; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> second; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span>; first = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ++a; } second = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> --a; } a = <span class="hljs-number"><span class="hljs-number">2</span></span>; first();<span class="hljs-comment"><span class="hljs-comment">//3 } testFn(); first();//4 second();//3</span></span></code> </pre><br> 试想一下，为该示例编写测试有多复杂，并且为纯函数简化了多少！ <br><br> 不纯功能的特点是时变的外部状态使代码的维护，理解和测试变得复杂。 <br><br> 相反，纯函数总是可读，可测试的，简化了计算的并行化，并且易于重用。 <br><br> 我想您注意到在纯函数示例中，我切换到了ES6语法。 这是故意进行的。 该函数语法称为“箭头函数”，但实际上它是很久以前发明的数学抽象的实现。 关于它进一步。 <br><br><h3>  Lambda-函数 </h3><br> 这就是这种箭头形式的数学和其他编程语言所称的形式。 函数式编程与mat紧密相关。 分析，所以不要惊讶。 <br><br>  Lambda演算一词最早是在1930年代由Alonzo Church引入的。 本质上，lambda演算只不过是描述数学方程式的形式。 更多细节<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里</a> 。 <br><br> 在ES中，lambda函数通常实现闭包： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> add = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> y =&gt; x + y;</code> </pre><br> 简短而简洁。  add函数是一个lambda，它接受参数x，将其存储在闭包中并返回一个函数。 <br><br> 与以下代码进行比较： <br><br><pre> <code class="javascript hljs">funtion add(x) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">y</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y; } }</code> </pre><br> 显然，第一种选择看起来更好。 <br><br><h3> 豁免权 </h3><br>  <b>不可变（不可变，抗扰性）</b>是创建后状态无法更改的对象。 对此类对象进行任何修改的结果将始终是新对象，而旧对象将不会更改。 <br><br> 不变性是函数式编程的黄金圣杯。 <br><br> 考虑一个例子： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> impureAddProp = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">key, value, object</span></span></span><span class="hljs-function">) =&gt;</span></span> { object[key] = value;<span class="hljs-comment"><span class="hljs-comment">//   }; const User= { name: 'Alex' }; impureAddProp ('isAdmin', true, User);</span></span></code> </pre><br> 如您所见，在此示例中，我们通过向User对象添加属性来对其进行了突变。 现在，用户对象是impureAddProp函数和其他会使它变异的函数的一种“共享状态”。 这种方法很难测试，因为 更改与共享状态交互的任何功能时，应始终牢记其他功能中可能存在的错误。 <br><br> 从函数式编程的角度来看，这是正确的： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pureAddProp = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">key, value, object</span></span></span><span class="hljs-function">) =&gt;</span></span> ({ ...object, [key]: value }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> User= { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Alex'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Admin= pureAddProp (<span class="hljs-string"><span class="hljs-string">'isAdmin'</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, User);</code> </pre><br> 因此，User对象将保持不变。 我们正在修改数据的副本，这始终是安全的。 <br><br><h2> 结论 </h2><br> 今天，我们研究了几个重要的理论概念。 我们熟悉纯函数，记录函数的lambda形式以及fp中不变性的概念。 但是，本文只是一种介绍。 功能编程的主要思想，技术和“硬性部分”将在以下文章中介绍。 <br><br> 函数式编程是由许多库实现的。 这是lambda，lodash和其他许多东西。 当然，在实际项目中，您将使用它们。 在任何库的内部，仍然会有相同的本机javascript，因此在以下文章中，我们将分析FP，并在本机JS上实现其所有概念。 <br><br><h2> 后记 </h2><br> 开始写文章时，我想到了以下计划： <br><br><ul><li> 撰写有趣的英语文章的翻译 </li><li> 突出显示JS中的几个相关领域（关键概念，根据EcmaScript规范，模式，功能编程的OOP）。 </li></ul><br> 迄今为止，已经写了三个方面的头条： <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">this和EcmaScript中的ScopeChain-</a>在这里，我描述了规范的关键概念，例如执行上下文，this关键字和ScopeChain上下文属性（作用域链）。 在这个方向的框架内，我有关词法环境和闭包的文章今天已按字面意义发表。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">EcmaScript对OOP的一般理论的看法</a> -这里描述了静态类输入和动态原型组织之间的区别，分解了委托模型和Duck类型 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">现代JavaScript中的优雅模式（Bill Sourour编译系列在该周期中）</a> -这是两种在某些情况下有用的模式。 我在模式方面的方法非常简单：最好了解尽可能多的模式，因为 迟早派上用场 </li></ol><br> 现在轮到函数式编程了。 将来，我将在所有这些领域的后续文章中写文章。 例如，以下文章将介绍OOP的关键概念：封装，抽象，杂质（和笔触），接口等。...我还打算讨论如何在幕后实现ES中的OOP。 关于[[Prototype]]，[[Class]]的属性等等。 讨论v8如何创建实体以及类，函数的实例。 <br><br> 评论中提出了很多问题，所以我想解释一下我为文章设定的目标。 我不写教程也不审查文档。 我认为这没有任何意义。 我不建议您使用某些工具或模式，它们的选择完全取决于您。 <br><br> 在文章中，我要么回顾这些概念，告诉它们如何在幕后安排（我认为，这可以增进对我们所写内容的理解，以及我们为什么以这种方式进行书写），或者我在谈论一些开阔视野的事情。 我认为这非常重要。 看一下Yandex或Edadil之类的公司，他们不断谈论某种新颖的想法。 这些都是react中的位图，那么vue应用程序几乎完全在es6类上。 大多数Web开发人员永远都不会想到这样的事情。 这需要广阔的前景。 <br><br> 我本人就是以这种方式研究和研究网络的 阅读完教程或扩展坞后，我将尝试了解所描述的工具如何在后台运行，以了解其内部机制。 <br><br> 直到以后的文章，朋友们！ </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN474702/">https://habr.com/ru/post/zh-CN474702/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN474692/index.html">Kubernetes开发的Skaffold审查</a></li>
<li><a href="../zh-CN474694/index.html">我们如何选择和扭曲性能测试框架</a></li>
<li><a href="../zh-CN474696/index.html">石油行业或Rosneft的门票要求进行地震挑战</a></li>
<li><a href="../zh-CN474698/index.html">在用户界面中使用模式窗口</a></li>
<li><a href="../zh-CN474700/index.html">云智能家居。 第2部分：云服务</a></li>
<li><a href="../zh-CN474704/index.html">花花公子访谈：史蒂夫·乔布斯，第2部分</a></li>
<li><a href="../zh-CN474706/index.html">TextRadar模糊搜索算法-基本方法</a></li>
<li><a href="../zh-CN474708/index.html">互联网比以往任何时候都更加分散：每天有超过一百万的新用户在哪里“来”？ 第一部分</a></li>
<li><a href="../zh-CN474710/index.html">c.tech：前端聚会＃2</a></li>
<li><a href="../zh-CN474712/index.html">Udalenka在IT中的个人经验</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>