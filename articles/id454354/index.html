<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêö üé´ üßëüèæ Magang di JetBrains dan bagaimana saya hampir berhasil melakukannya üßëüèø‚Äçü§ù‚Äçüßëüèª ‚õëÔ∏è üêÇ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Seperti banyak pengembang muda, ketika ada keinginan untuk mencari pekerjaan / magang, saya melihat ke arah perusahaan IT keren. 

 Baru-baru ini saya...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Magang di JetBrains dan bagaimana saya hampir berhasil melakukannya</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454354/"><img src="https://habrastorage.org/getpro/habr/post_images/d42/5b8/da4/d425b8da4aec5f7359e39503e9f1d700.jpg" alt="gambar"><br><br>  Seperti banyak pengembang muda, ketika ada keinginan untuk mencari pekerjaan / magang, saya melihat ke arah perusahaan IT keren. <br><br>  Baru-baru ini saya mencoba masuk ke jajaran JetBrains dan di bawah potongan saya siap untuk berbagi pengalaman saya. <br><a name="habracut"></a><br><h3>  Mengapa ‚Äúhampir‚Äù berhasil? </h3><br>  Tentunya Anda segera memiliki pertanyaan seperti itu. <br><br>  Menurut pendapat saya, saya memiliki resume yang baik dengan banyak prestasi dan keterampilan yang baik, yang telah saya tingkatkan 8-9 tahun terakhir hari demi hari. <br><br>  Saya menyelesaikan tugas tes (dan sepertinya baik bagi saya), sebelumnya mengunjungi kantor JB, yang berlokasi di kota saya, berbicara dengan HH dan beberapa pengembang perusahaan, dan sebagai hasilnya ditolak magang tanpa komentar. <br><br>  Kemungkinan besar, alasannya terletak pada kenyataan bahwa JetBrains memilih siswa secara eksklusif untuk magang, dan saat ini saya baru saja lulus dari kelas 11 dan lulus ujian satu demi satu. <br><br>  Nah, ini adalah kesempatan untuk setahun penuh untuk menarik diri dan melamar tahun depan. <br><br><h3>  Analisis tugas tes </h3><br>  Tenggat waktu untuk mengirimkan aplikasi untuk magang dan menguji tugas ujian sudah berakhir, yang berarti bahwa setiap orang yang menyelesaikannya, termasuk saya, dapat memposting analisis tugas ini sehingga tahun depan setiap siswa yang tertarik dapat membiasakan diri dengan perkiraan tingkat tugas sebelum memulai magang JB, dengan yang harus dia hadapi dan dalam hal ini untuk menarik ilmunya. <br><br>  Saya melamar magang dengan tim pengembangan debugger Corotin untuk Kotlin. <br><br>  Tugas tim ini selama magang bagi mereka yang berhasil tahun ini adalah menyelesaikan bagian debugger ini dan integrasinya dengan IDE. <br><br>  Tugas itu sedikit diharapkan - untuk menulis debugger untuk PL kecil. <br><br>  Saya tidak akan mengatakan bahwa itu rumit, justru sebaliknya.  Tidak memerlukan pengetahuan mendalam tentang teori membangun penerjemah dan keterampilan yang keren.  Namun demikian, mereka yang melamar magang di bidang ini setidaknya harus memiliki dasar-dasar ini dan mengatasi tugas ini tanpa masalah.  Saya terkejut ketika saya memutuskan untuk mencari di github untuk kata kunci dari solusi "pesaing" saya dan menemukan 1-2 lebih atau kurang solusi yang tampak bekerja terhadap sekitar 6-7 repositori kosong atau dengan beberapa keping kode setelah orang menyerah.  Mungkin saya terlihat buruk, tetapi hasilnya tidak menyenangkan saya.  Jika posting ini akan dibaca oleh orang-orang yang meninggalkan tugas ini - tidak perlu melakukan ini di masa depan.  Dalam kasus yang ekstrim, itu cukup untuk duduk di tugas selama beberapa hari dan saya yakin Anda akan menghadapinya. <br><br><div class="spoiler">  <b class="spoiler_title">Teks dari pencarian itu sendiri</b> <div class="spoiler_text">  Tujuan: mengimplementasikan eksekusi kode langkah-demi-langkah untuk bahasa pemrograman sepele Guu. <br><br>  Perhatian: dalam uraian di bawah ini, beberapa poin penting sengaja dihilangkan.  Sebagai aturan, mereka tetap pada kebijaksanaan Anda.  Jika benar-benar tidak dapat dipahami, kirim surat ke (di sini adalah surat yang saya putuskan untuk dihapus). <br><br>  Program Guu terdiri dari serangkaian prosedur.  Setiap prosedur dimulai dengan sub baris (subname) dan berakhir dengan deklarasi prosedur lain (atau akhir file jika prosedur dalam file adalah yang terakhir).  Eksekusi dimulai dengan sub main. <br><br>  Tubuh prosedur adalah seperangkat instruksi, yang masing-masingnya berada pada baris terpisah.  Tab atau spasi yang tidak signifikan dapat terjadi di awal baris.  Baris kosong diabaikan.  Tidak ada komentar tentang Guu. <br><br>  Guu hanya memiliki tiga operator: - set (varname) (nilai baru) - pengaturan nilai integer baru untuk variabel.  - panggilan (nama panggilan) - panggilan prosedur.  Panggilan bisa bersifat rekursif.  - print (varname) - cetak nilai variabel di layar. <br><br>  Variabel dalam Guu memiliki cakupan global.  Program di bawah ini akan menampilkan garis a = 2. <br><br>  sub utama <br>  atur 1 <br>  panggil foo <br>  cetak a <br><br>  sub foo <br>  atur 2 <br><br>  Dan di sini adalah program paling sederhana dengan rekursi tak terbatas: <br><br>  sub utama <br>  panggilan utama <br><br>  Anda perlu menulis juru bahasa selangkah demi selangkah untuk Guu.  Ketika mulai, debugger harus berhenti pada baris dengan instruksi pertama di sub main dan menunggu perintah dari pengguna.  Minimum yang diperlukan perintah debugger: <br><br>  i - masuk ke, debugger masuk ke dalam panggilan (subname). <br>  o - melangkahi, debugger tidak masuk ke dalam panggilan. <br>  trace - print stack trace trace dengan nomor baris mulai dari ... <br>  var - mencetak nilai semua variabel yang dideklarasikan. <br><br>  Format komunikasi pengguna dengan debugger diserahkan kepada kebijaksanaan di atas.  Anda dapat memilih antarmuka minimalis seperti GDB atau konsol atau UI grafis.  Nama-nama perintah debugger dapat diubah jika diinginkan. <br><br>  Untuk mengatasi masalah ini, Anda dapat menggunakan bahasa pemrograman apa pun dari TIOBE TOP 50 dan kompiler / juru bahasa sumber terbuka. <br><br>  Saat mengevaluasi pekerjaan akan dievaluasi: <br><br>  Kinerja keseluruhan program; <br>  Kualitas kode sumber dan ketersediaan tes; <br>  Mudah untuk memperluas fungsionalitas (misalnya, dukungan untuk pernyataan bahasa baru atau instruksi debugger). <br>  Solusi dengan instruksi untuk membangunnya harus dipublikasikan ke repositori Git (misalnya, di GitHub atau BitBucket).  Dalam respons Anda perlu menentukan tautan ke repositori.  Tautan ke repositori GitHub pribadi juga cocok, hanya Anda yang perlu menambahkan saya ke dalamnya. <br></div></div><br>  Saya menulis dalam C ++, Java dan Object Pascal. <br><br>  Pada awalnya ada pemikiran untuk menulis semuanya di MPS saya yang sama, tapi saya pikir tidak akan nyaman untuk memeriksa karyawan JB, dan saya menyerahkan aplikasi 2 hari sebelum penutupan pengajuan (ujian semua sama ...), dan sudah malam di luar jendela - saya memutuskan untuk segera menulis semuanya dalam bahasa yang lebih terkenal. <br><br>  Menurut pendapat saya, Pascal paling cocok untuk memecahkan masalah, setidaknya karena penerapan string yang paling nyaman ... <br><br>  Setidaknya untukku.  Selain itu, ada di TIOBE TOP 50, jadi saya berani meluncurkan IDE, yaitu Lazarus, karena  dia tidak komersial :) dan mulai menyelesaikan masalah. <br><br>  Terlepas dari kenyataan bahwa mereka memberi JB sebanyak 7 hari, saya butuh sekitar satu jam untuk menyelesaikan proyek, dan proyek itu ternyata sekitar 500 baris kode. <br><br><h3>  Di mana untuk memulai? </h3><br>  Pertama-tama, Anda perlu membayangkan bagaimana debugging kode akan bekerja pada akhirnya. <br><br>  Kita perlu mengimplementasikan eksekusi kode langkah-demi-langkah - itu berarti setiap instruksi harus disajikan dalam bentuk struktur / kelas dan, secara umum, instruksi akan terlihat seperti daftar kelas-kelas ini atau, seperti dalam implementasi saya, merujuk satu sama lain membentuk urutan (saya akan menuliskan mengapa saya melakukannya nanti). <br><br>  Untuk mendapatkan urutan ini, debugger kami perlu memproses kode dalam bahasa yang diusulkan, yang berarti kita juga perlu mengimplementasikan parser kecil, serta analisis sintaksis dan semantik kode. <br><br>  Mari kita mulai dengan implementasi parser.  Karena  Karena bahasa Guu terdiri dari satu set token, dipisahkan oleh spasi, logis untuk menulis tokenizer kecil dan sederhana terlebih dahulu: <br><br><pre><code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">; tokenNum: word)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p: word; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> s := Trim(s); s := StringReplace(s, <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>, [rfReplaceAll]); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> tokenNum &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> p := Pos(<span class="hljs-string"><span class="hljs-string">' '</span></span>, s); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> p &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Delete(s, <span class="hljs-number"><span class="hljs-number">1</span></span>, p) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> s := <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; dec(tokenNum); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; p := Pos(<span class="hljs-string"><span class="hljs-string">' '</span></span>, s); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> p &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Delete(s, p, Length(s)); Result := s; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Selanjutnya, nyatakan enum dari token: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TGuuToken = (opSub, opSet, opCall, opPrint, opUnknown); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GuuToken: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[opSub..opPrint] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> = ( <span class="hljs-string"><span class="hljs-string">'sub'</span></span>, <span class="hljs-string"><span class="hljs-string">'set'</span></span>, <span class="hljs-string"><span class="hljs-string">'call'</span></span>, <span class="hljs-string"><span class="hljs-string">'print'</span></span> );</code> </pre><br>  Dan kelas instruksi itu sendiri, di mana kita akan mengurai baris kode: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TGuuOp = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> OpType : TGuuToken; OpArgs : TStringList; OpLine : Cardinal; OpUnChangedLine: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; NextOp : TGuuOp; OpReg : Pointer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Step</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StepInto: boolean; CallBacks: TList; Trace: TStringList)</span></span></span><span class="hljs-function">:</span></span> TGuuOp; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LineNum: Cardinal; Line:</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Dalam OpType instruksi akan disimpan, di OpArgs - sisa konstruksi. <br>  OpLine, OpUnChangedLine - informasi untuk debugger. <br><br>  NextOp adalah pointer ke pernyataan selanjutnya.  Jika sama dengan nil (nol dalam Pascal), maka tidak ada instruksi lebih lanjut dan Anda perlu menyelesaikan kode atau kembali melalui tumpukan panggilan balik. <br><br>  OpReg adalah register-pointer kecil, yang nantinya akan digunakan untuk optimasi kecil dari eksekusi kode. <br><br>  Setelah deklarasi kelas ditulis - saya memutuskan bahwa solusi yang paling ringkas dan indah adalah menambahkan parser dan sedikit penguraian dalam konstruktornya, yang saya lakukan selanjutnya: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TGuuOp</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LineNum: Cardinal; Line:</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-comment"><span class="hljs-comment">(* * That method parse code line. *)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; w: word; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span> Create; OpArgs := TStringList.Create; OpLine := LineNum; OpUnChangedLine := Line; NextOp := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; OpReg := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; s := GetToken(Line, <span class="hljs-number"><span class="hljs-number">1</span></span>); OpType := TGuuToken(AnsiIndexStr(s, GuuToken)); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OpType <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> opSub : <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">// sub &lt;name&gt; s := GetToken(Line, 2); if Length(s) &gt; 0 then OpArgs.Add(s) else begin writeln('[Syntax error]: Invalid construction "sub" at line ', OpLine, '.'); halt; end; if Length(GetToken(Line, 3)) &gt; 0 then begin writeln('[Syntax error]: Invalid construction "', Line, '" at line ', OpLine, '.'); halt; end; end; opSet : begin // set &lt;var&gt; &lt;value&gt; OpArgs.Add(GetToken(Line, 2)); OpArgs.Add(GetToken(Line, 3)); w := 1; while w &lt; Length(OpArgs[1]) + 1 do begin if not (OpArgs[1][w] in ['0'..'9']) then begin writeln('[Syntax error]: Invalid variable assigment "', Line, '" at line ', OpLine, '.'); halt; end; inc(w); end; if (Length(OpArgs[0]) = 0) or (Length(OpArgs[1]) = 0) or (Length(GetToken(Line, 4)) &gt; 0) then begin writeln('[Syntax error]: Invalid construction "', Line, '" at line ', OpLine, '.'); halt; end end; opCall : begin // call &lt;name&gt; s := GetToken(Line, 2); if Length(s) &gt; 0 then OpArgs.Add(s) else begin writeln('[Syntax error]: Invalid construction "call" at line ', OpLine, '.'); halt; end; if Length(GetToken(Line, 3)) &gt; 0 then begin writeln('[Syntax error]: Invalid construction "', Line, '" at line ', OpLine, '.'); halt; end; end; opPrint: begin // print &lt;var&gt; s := GetToken(Line, 2); if Length(s) &gt; 0 then OpArgs.Add(s) else begin writeln('[Syntax error]: Invalid construction "print" at line ', OpLine, '.'); halt; end; if Length(GetToken(Line, 3)) &gt; 0 then begin writeln('[Syntax error]: Invalid construction "', Line, '" at line ', OpLine, '.'); halt; end; end; else begin writeln('[Syntax error]: Invalid token "', s, '" at line ', OpLine, '.'); halt; end; end; end; destructor TGuuOp.Destroy; begin FreeAndNil(OpArgs); inherited; end;</span></span></code> </pre><br>  Di sini kita pada dasarnya memeriksa awal konstruksi (mis. Kata pertama), dan kemudian melihat token yang tersisa dan nomor mereka.  Jika ada yang salah dengan kode, kami menampilkan kesalahan. <br><br>  Dalam potongan kode utama, kita cukup membaca kode di TStringList dari file, memanggil konstruktor TGuuOp baris demi baris, dan menyimpan pointer ke instance kelas di GuuOps: TList. <br><br>  Pengumuman: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> LabelNames: TStringList; GuuOps, GuuVars: TList; SubMain: TGuuOp = <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>;</code> </pre><br>  Bersama-sama dengan parsing kode, alangkah baiknya melakukan beberapa tindakan lagi: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParseNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LineNum: Cardinal; Line: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-comment"><span class="hljs-comment">(* * Parsing code lines and define variables and labels. *)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Op: TGuuOp; GV: TGuuVar; c: cardinal; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Trim(Line) &lt;&gt; <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Op := TGuuOp.Create(LineNum, Line); GuuOps.Add(Op); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Op.OpType <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> opSet: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">// define variable and/or optimisation var calling GV := nil; c := 0; while c &lt; GuuVars.Count do begin if TGuuVar(GuuVars[c]).gvName = Op.OpArgs[0] then begin GV := TGuuVar(GuuVars[c]); break; end; inc(c); end; if GV = nil then begin GV := TGuuVar.Create(Op.OpArgs[0]); GuuVars.Add(GV); end; Op.OpReg := GV; end; opSub: begin // Check for label dublicade declaration if Op.OpArgs[0] = 'main' then SubMain := Op; if LabelNames.IndexOf(Op.OpArgs[0]) &lt;&gt; -1 then begin writeln('[Error]: Dublicate sub "', Op.OpArgs[0], '" declaration at line ', Op.OpLine, '.'); halt; end else LabelNames.Add(Op.OpArgs[0]); end; end; end; end;</span></span></code> </pre><br>  Pada tahap ini, Anda dapat memeriksa titik masuk pada saat redefinisi dan mengingat OpReg - Saya menggunakannya untuk menyimpan pointer ke variabel Guu. <br><br>  Berbicara tentang variabel, saya mengambil sepotong kecil kode ini ke unit yang terpisah: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">unit</span></span> uVars; <span class="hljs-meta"><span class="hljs-meta">{$mode objfpc}</span></span><span class="hljs-meta"><span class="hljs-meta">{$H+}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> Classes, SysUtils; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TGuuVar = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> gvName: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; gvVal: variant; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VarName: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">implementation</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TGuuVar</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VarName: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span> Create; gvName := VarName; gvVal := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre><br>  Sekarang kita telah mem-parsing kode yang tampaknya benar dalam sintaksis.  Masih menganalisa dan Anda dapat mulai melakukan hal yang paling penting - debugging. <br><br>  Selanjutnya, Anda perlu menerapkan analisis semantik kecil dan secara bersamaan menyiapkan semuanya untuk eksekusi kode dan debugging: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckSemantic</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-comment"><span class="hljs-comment">(* * Semantic analyse and calls optimisation. *)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c, x: cardinal; op: TGuuOp; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> GuuOps.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TGuuOp(GuuOps[<span class="hljs-number"><span class="hljs-number">0</span></span>]).OpType &lt;&gt; opSub <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> writeln(<span class="hljs-string"><span class="hljs-string">'[Error]: Operation outside sub at line '</span></span>, TGuuOp(GuuOps[<span class="hljs-number"><span class="hljs-number">0</span></span>]).OpLine, <span class="hljs-string"><span class="hljs-string">'.'</span></span>); halt; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; c := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> c &lt; GuuOps.Count <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TGuuOp(GuuOps[c]).OpType <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> opSub:; opCall: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> TGuuOp(GuuOps[c - <span class="hljs-number"><span class="hljs-number">1</span></span>]).NextOp := TGuuOp(GuuOps[c]); x := <span class="hljs-number"><span class="hljs-number">0</span></span>; op := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> x &lt; GuuOps.Count <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TGuuOp(GuuOps[x]).OpType = opSub <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TGuuOp(GuuOps[x]).OpArgs[<span class="hljs-number"><span class="hljs-number">0</span></span>] = TGuuOp(GuuOps[c]).OpArgs[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> op := TGuuOp(GuuOps[x]); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; inc(x); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> op &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> TGuuOp(GuuOps[c]).OpReg := op <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> writeln(<span class="hljs-string"><span class="hljs-string">'[Error]: Calling to not exist sub "'</span></span>, TGuuOp(GuuOps[c]).OpArgs[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-string"><span class="hljs-string">'" at line '</span></span>, TGuuOp(GuuOps[c]).OpLine, <span class="hljs-string"><span class="hljs-string">'.'</span></span>); halt; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; opPrint: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> TGuuOp(GuuOps[c - <span class="hljs-number"><span class="hljs-number">1</span></span>]).NextOp := TGuuOp(GuuOps[c]); x := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> x &lt; GuuVars.Count <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TGuuVar(GuuVars[x]).gvName = TGuuOp(GuuOps[c]).OpArgs[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> TGuuOp(GuuOps[c]).OpReg := TGuuVar(GuuVars[x]); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; inc(x); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TGuuOp(GuuOps[c]).OpReg = <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> writeln(<span class="hljs-string"><span class="hljs-string">'[Error]: Variable "'</span></span>, TGuuOp(GuuOps[c]).OpArgs[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-string"><span class="hljs-string">'" for print doesn''t exist at line '</span></span>, TGuuOp(GuuOps[c]).OpLine, <span class="hljs-string"><span class="hljs-string">'.'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> TGuuOp(GuuOps[c - <span class="hljs-number"><span class="hljs-number">1</span></span>]).NextOp := TGuuOp(GuuOps[c]); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; inc(c); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Di TGuuOp.NextOp dari setiap token, tulis pointer ke token berikutnya. <br>  Untuk opcode panggilan, kami melakukannya dengan rumit dan sederhana - di NextOp kami menulis sebuah pointer ke titik entri yang disebut. <br><br>  Kami juga memeriksa variabel output melalui pernyataan cetak ... <br><br>  Mungkin mereka tidak diumumkan sebelum kesimpulan? <br><br>  Sekarang Anda perlu mengimplementasikan eksekusi kode.  Kembali ke kelas TGuuOp dan terapkan metode Step: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TGuuOp</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Step</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StepInto: boolean; CallBacks: TList; Trace: TStringList)</span></span></span><span class="hljs-function">:</span></span> TGuuOp; <span class="hljs-comment"><span class="hljs-comment">(* * That method execute instruction. *)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Op: TGuuOp; CBSize: Cardinal; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OpType <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> opSub: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Trace.Add(<span class="hljs-string"><span class="hljs-string">'-&gt; Sub "'</span></span> + OpArgs[<span class="hljs-number"><span class="hljs-number">0</span></span>] + <span class="hljs-string"><span class="hljs-string">'"'</span></span>); Result := NextOp; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; opCall: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> StepInto <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> NextOp &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> CallBacks.Add(NextOp); Result := TGuuOp(OpReg); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Op := TGuuOp(OpReg); CBSize := CallBacks.Count; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((Op &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (CallBacks.Count &gt; CBSize)) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (Trace.Count &lt; STACK_SIZE) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Op = <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Op := TGuuOp(CallBacks[CallBacks.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]); CallBacks.Delete(CallBacks.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); Trace.Delete(Trace.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; Op := Op.Step(StepInto, CallBacks, Trace); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; Result := NextOp; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; opPrint: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> writeln(TGuuVar(OpReg).gvName, <span class="hljs-string"><span class="hljs-string">' = '</span></span>, TGuuVar(OpReg).gvVal); Result := NextOp; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; opSet: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> TGuuVar(OpReg).gvVal := OpArgs[<span class="hljs-number"><span class="hljs-number">1</span></span>]; Result := NextOp; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Untuk menghindari pelanggaran akses jika terjadi loop - lebih baik membatasi stack, yang saya lakukan. <br>  STACK_SIZE = 2048 yang konstan, yang dinyatakan di atas hanya bertanggung jawab untuk ini. <br><br>  Sekarang akhirnya saatnya untuk menulis kode utama debugger kami: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> code: TStringList; c: Cardinal; cmd: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; CallBacks: TList; Trace: TStringList; DebugMode: boolean = true; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ParamCount &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">// Initialisation if not FileExists(ParamStr(1)) then begin writeln('[Error]: Can''t open file "', ParamStr(1), '".'); halt; end; if ParamCount &gt; 1 then if LowerCase(ParamStr(2)) = '/run' then DebugMode := false; code := TStringList.Create; code.LoadFromFile(ParamStr(1)); GuuOps := TList.Create; GuuVars := TList.Create; // Parsing and preparing LabelNames := TStringList.Create; c := 0; while c &lt; code.Count do begin ParseNext(c + 1, Trim(code[c])); inc(c); end; FreeAndNil(LabelNames); CheckSemantic; if SubMain = nil then begin writeln('[Error]: Sub "main" doesn''t exist!'); halt; end; // Start code execution CurrentOp := SubMain; CallBacks := TList.Create; Trace := TStringList.Create; if DebugMode then begin //Out code and features ClrScr; writeln('Code for debugging:'); writeln('.....'); c := 0; while c &lt; code.Count do begin writeln(FillSpaces(IntToStr(c + 1), 4), '| ', code[c]); inc(c); end; writeln('"""""'); FreeAndNil(code); writeln(sLineBreak, 'Features:', sLineBreak, '* i - step into.', sLineBreak, '* o - step over.', sLineBreak, '* trace - print stack trace.', sLineBreak, '* var - print variables list.', sLineBreak, '* x - exit.', sLineBreak); // Execution loop while ((CurrentOp &lt;&gt; nil) or (CallBacks.Count &gt; 0)) and (Trace.Count &lt; STACK_SIZE) do begin write('Line ', CurrentOp.OpLine, ' ~&gt; '); readln(cmd); // Execute commands if cmd = 'i' then CurrentOp := CurrentOp.Step(true, CallBacks, Trace) else if cmd = 'o' then CurrentOp := CurrentOp.Step(false, CallBacks, Trace) else if cmd = 'trace' then begin writeln('| Trace:'); c := 0; while c &lt; Trace.Count do begin writeln('| ', Trace[c]); inc(c); end; writeln('| -&gt; Line ', CurrentOp.OpLine, ': "', CurrentOp.OpUnChangedLine, '".') end else if cmd = 'var' then begin writeln('| Variables list:'); c := 0; while c &lt; GuuVars.Count do begin writeln('| ', TGuuVar(GuuVars[c]).gvName, ' = ', TGuuVar(GuuVars[c]).gvVal); inc(c); end; end else if cmd = 'x' then halt; // Check for method end &amp; make callback if (CurrentOp = nil) and (CallBacks.Count &gt; 0) then begin CurrentOp := TGuuOp(CallBacks[CallBacks.Count - 1]); CallBacks.Delete(CallBacks.Count - 1); Trace.Delete(Trace.Count - 1); end; end; end else begin // Only run mode (/run) FreeAndNil(code); while ((CurrentOp &lt;&gt; nil) or (CallBacks.Count &gt; 0)) and (Trace.Count &lt; STACK_SIZE) do begin CurrentOp := CurrentOp.Step(false, CallBacks, Trace); if (CurrentOp = nil) and (CallBacks.Count &gt; 0) then begin CurrentOp := TGuuOp(CallBacks[CallBacks.Count - 1]); CallBacks.Delete(CallBacks.Count - 1); Trace.Delete(Trace.Count - 1); end; end; end; if Trace.Count &gt;= STACK_SIZE then writeln('[Runtime error]: Stack overflow!'); FreeAndNil(CallBacks); FreeAndNil(Trace); end else writeln( 'Guu debugger v1.0.', sLineBreak, 'Author: Pavel Shiryaev (@RoPi0n).', sLineBreak, 'Run: svmc guu_debugger.vmc &lt;guu source file&gt; [arg]', sLineBreak, 'Args:', sLineBreak, ' /run - Run Guu code.' ); end.</span></span></code> </pre><br>  Dengan kondisi pekerjaan, antarmuka dapat diimplementasikan sesuka Anda. <br><br>  Mungkin saja untuk mengimplementasikan UI sepenuhnya, mengacaukan SynEdit ke proyek, tetapi menurut saya itu adalah pekerjaan kosong yang tidak akan mencerminkan keterampilan, dan selain itu tidak akan dibayar :) <br><br>  Jadi saya membatasi diri pada UI konsol kecil. <br><br>  Kode di atas tidak rumit, sehingga Anda dapat meninggalkannya tanpa komentar.  Di dalamnya, kami mengambil TGuuOp siap pakai dan menyebutnya Langkah. <br><br>  Tangkapan layar dari masalah yang diselesaikan: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/33e/ad0/efa/33ead0efa3a07d77d1a6c07010847035.jpg" alt="gambar"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/3e1/7eb/41e/3e17eb41e99abece612f09b146464f67.jpg" alt="gambar"><br><br>  Keluaran Informasi Kesalahan: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/659/1c5/ea4/6591c5ea44e67f5068bd7fb0e9c2341e.jpg" alt="gambar"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/2a0/3f0/733/2a03f07336c5af1333f259d43e4a1396.jpg" alt="gambar"><br><br>  Tautan ke repositori solusi saya: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">klik</a> <br><br><h3>  Ringkasan </h3><br>  Tidak ada hasil tertentu.  Saya harus mencurahkan sebagian besar musim panas untuk liburan yang sibuk dan mencari universitas (tentu saja, jika saya lulus ujian dengan baik, tentu saja), alih-alih bekerja dan berlatih selama dua bulan di tim JetBrains. <br><br>  Mungkin tahun depan posting baru akan muncul di Habr√©, sudah menggambarkan proses magang di JB atau di perusahaan lain yang menarik bagi saya :) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id454354/">https://habr.com/ru/post/id454354/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id454336/index.html">Klien: - Berapa biaya salinan Facebook?</a></li>
<li><a href="../id454340/index.html">% tutnazvanievu% adalah universitas pertama di dunia tempat jetpack secara resmi dikembangkan</a></li>
<li><a href="../id454346/index.html">Algoritma Efisiensi: Tinjauan Kamera Pengintai Nobelik 2019</a></li>
<li><a href="../id454348/index.html">Mengelola Status dengan React Hooks - Tanpa Redux dan Context API</a></li>
<li><a href="../id454352/index.html">Ketidakpastian Matematika dalam Python</a></li>
<li><a href="../id454356/index.html">Habr Weekly # 3 / Runet vs TV, ARM vs Intel, penyatuan data negara, tanpa smartphone pada 2019, impian Soviet tentang masa depan</a></li>
<li><a href="../id454366/index.html">Victory at PHDays 9. Kami berbagi hacks kehidupan dalam tiga bagian. Bagian 2</a></li>
<li><a href="../id454368/index.html">Kompetisi Pengembang Plugin TeamCity</a></li>
<li><a href="../id454372/index.html">Berita mingguan: Huawei masih memiliki masalah, "telepon kuantum" di Federasi Rusia, ARM memiliki prosesor baru</a></li>
<li><a href="../id454374/index.html">Printer 3D polimer foto dari proyektor video rumahan membuat objek tanpa lapisan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>