<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëØ ü¶í ‚ÜïÔ∏è TelegramBot in der Wolfram Cloud üèÄ üë∞üèæ üëåüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 


 Die Zeit ist vergangen, in der jeder zweite Artikel √ºber Habrahabr dem Schreiben seines Telegrammbot gewidmet war. Au√üerdem verging ein...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>TelegramBot in der Wolfram Cloud</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/wolfram/blog/422517/"><h2 id="vvedenie">  Einf√ºhrung </h2><br><p>  Die Zeit ist vergangen, in der jeder zweite Artikel √ºber Habrahabr dem Schreiben seines Telegrammbot gewidmet war.  Au√üerdem verging eine Zeitspanne, in der der Bot ohne Schwierigkeiten auf Ihrem Computer oder Hosting in Russland platziert werden konnte.  Vor sechs Monaten startete mein Bot gerade auf einem Laptop und hatte keine Probleme mit der Verbindung zur API.  Aber jetzt, als ich dar√ºber nachdachte, ihn wieder zur Arbeit zu bringen, wurde mir klar, dass es nicht so einfach sein w√ºrde.  Ich wollte keinen Proxyserver suchen und konfigurieren, und noch mehr im Ausland.  Au√üerdem habe ich vorher den Bot in Wolfram Language geschrieben und hatte keine Ahnung, wie die Sprache mit Proxyservern funktioniert, da ich sie noch nicht verwendet habe.  Und dann kam eine gro√üartige Idee!  Verwenden Sie Wolfram Cloud.  In diesem Artikel m√∂chte ich zeigen, wie einfach die Registrierung ist, aber ohne SMS k√∂nnen Sie Ihren einfachen Telegramm-Bot starten, der in Wolfram Language geschrieben ist.  Von den Tools ben√∂tigen Sie nur einen Browser. </p><a name="habracut"></a><br><h2 id="nemnogo-pro-oblako-wolfram">  Ein bisschen √ºber die Wolfram-Wolke </h2><br><p>  Um auf die Cloud zugreifen zu k√∂nnen, m√ºssen Sie ein Wolfram-Konto erstellen.  Gehen Sie dazu zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://account.wolfram.com</a> und befolgen Sie die Anweisungen, nachdem Sie auf die Schaltfl√§che Create One geklickt haben. </p><br><p><img src="https://habrastorage.org/webt/rl/er/tc/rlertcegmrslt0ner2zebqfajts.png"></p><br><p>  Nach allen vorgenommenen Manipulationen werden auf der Hauptseite der Cloud unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.wolframcloud.com</a> alle Produkte und ihre Verwendungspl√§ne angezeigt.  Sie m√ºssen die Entwicklungsplattform ausw√§hlen und ein neues Notizbuch erstellen. </p><br><p><img src="https://habrastorage.org/webt/ji/nc/2i/jinc2iwgotacltqm6yh7n2gfboe.png"></p><br><p>  Der gesamte sp√§ter angegebene Code wird in diesem speziellen Cloud-Notizbuch ausgef√ºhrt. </p><br><h2 id="sovsem-nemnogo-o-telegramm-botah">  Ein bisschen √ºber Telegramm-Bots </h2><br><p>  Es gibt viele Artikel, die ihnen gewidmet sind.  Hier muss nur gesagt werden, dass der Bot vor dem Ausf√ºhren aller weiteren Aktionen auf die √ºbliche Weise erstellt werden muss.  Starten Sie einfach einen Chat mit dem @ BotFather-Bot und senden Sie ihm den folgenden Befehl: </p><br><pre><code class="plaintext hljs">/newbot</code> </pre> <br><p>  Dann m√ºssen Sie nur noch den Anweisungen folgen und den Namen und das Login eingeben.  Sein Name sei Wolfram Cloud Bot und login @ WolframCloud5973827Bot. </p><br><p><img src="https://habrastorage.org/webt/ne/s1/xx/nes1xxki5xcpaumq5f0e6ykboxa.gif"></p><br><h2 id="realizaciya-api">  API-Implementierung </h2><br><p>  Wir nutzen die Empfehlungen von @BotFather und untersuchen kurz die HTTP-API von Telegramm-Bots.  Die Implementierung der gesamten API lohnt sich noch nicht.  Um einen Bot zu schreiben, reicht nur ein kleiner Teil.  √úberpr√ºfen Sie, ob auf die API zugegriffen werden kann und der Bot mit dem oben angegebenen Token vorhanden ist.  Machen Sie dazu nur eine Zeile: </p><br><pre> <code class="plaintext hljs">URLExecute["https://api.telegram.org/bot753681357:AAFqdRFN_QoODJxsBy3VN2sVwWTPKJEqteY/getMe"]</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Out [..]: = ...</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">{"ok" -&gt; True, "result" -&gt; {"id" -&gt; 753681357, "is_bot" -&gt; True, "first_name" -&gt; "Wolfram Cloud Bot", "username" -&gt; "WolframCloud5973827Bot"}}</code> </pre> </div></div><br><p>  Der obige Befehl ist der einfachste Weg, eine HTTP-Anfrage von Wolfram Language aus zu stellen.  Aber lassen Sie es uns etwas komplizieren, damit es einfach ist, alle anderen API-Methoden zu implementieren.  Erstellen wir eine allgemeine Methode zum Ausf√ºhren einer API-Anforderung: </p><br><pre> <code class="plaintext hljs">TelegramBot::usage = "TelegramBot[token]"; $telegramAPI = "https://api.telegram.org"; telegramExecute[ TelegramBot[token_String], method_String, parameters: {(_String -&gt; _)...}: {} ] := Module[{ request, requestURL, requestRules, requestBody, response, responseBody }, requestURL = URLBuild[{$telegramAPI, "bot" &lt;&gt; token, method}]; requestRules = DeleteCases[parameters, _[_String, Automatic | Null | None]]; requestBody = ImportString[ExportString[requestRules, "JSON"], "Text"]; request = HTTPRequest[requestURL, &lt;| Method -&gt; "POST", "ContentType" -&gt; "application/json; charset=utf-8", "Body" -&gt; requestBody |&gt;]; response = URLRead[request]; responseBody = response["Body"]; Return[ImportString[responseBody, "RawJSON"]] ]</code> </pre> <br><p>  √úberpr√ºfen Sie, ob dies mit der oben bereits getesteten Methode funktioniert: </p><br><pre> <code class="plaintext hljs">token = "753681357:AAFqdRFN_QoODJxsBy3VN2sVwWTPKJEqteY"; bot = TelegramBot[token]; telegramExecute[bot, "getMe"]</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Out [..]: = ...</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">&lt;|"ok" -&gt; True, "result" -&gt; &lt;|"id" -&gt; 753681357, "is_bot" -&gt; True, "first_name" -&gt; "Wolfram Cloud Bot", "username" -&gt; "WolframCloud5973827Bot"|&gt;|&gt;</code> </pre> </div></div><br><p>  Gro√üartig.  Erstellen wir eine separate Funktion zum Durchf√ºhren einer Bot-Pr√ºfung: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">getMe</a> - bot Informationen </li></ul><br><pre> <code class="plaintext hljs">getMe::usage="getMe[bot]"; TelegramBot /: getMe[bot_TelegramBot] := telegramExecute[bot, "getMe"] getMe[bot]</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Out [..]: = ...</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">&lt;|"ok" -&gt; True, "result" -&gt; &lt;|"id" -&gt; 753681357, "is_bot" -&gt; True, "first_name" -&gt; "Wolfram Cloud Bot", "username" -&gt; "WolframCloud5973827Bot"|&gt;|&gt;</code> </pre> </div></div><br><p>  In √§hnlicher Weise m√ºssen nun die grundlegenden Methoden hinzugef√ºgt werden, die zum Erstellen eines Bots in der Cloud erforderlich sind: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">getUpdates</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ruft</a> die neuesten Nachrichten ab, die an den Bot geschrieben wurden </li></ul><br><pre> <code class="plaintext hljs">getUpdates::usage = "getUpdates[bot, opts]"; Options[getUpdates] = { "offset" -&gt; Automatic, "limit" -&gt; Automatic, "timeout" -&gt; Automatic, "allowed_updates" -&gt; Automatic }; TelegramBot /: getUpdates[bot_TelegramBot, opts: OptionsPattern[getUpdates]] := telegramExecute[bot, "getUpdates", Flatten[{opts}]]</code> </pre> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">setWebhook</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Legt</a> die Serveradresse f√ºr die Verarbeitung von Updates fest </li></ul><br><pre> <code class="plaintext hljs">setWebhook::usage = "setWebhook[bot, url, opts]"; Options[setWebhook] = { "certificate" -&gt; Automatic, "max_connections" -&gt; Automatic, "allowed_updates" -&gt; Automatic }; TelegramBot /: setWebhook[bot_TelegramBot, url_String, opts: OptionsPattern[setWebhook]] := telegramExecute[bot, "setWebhook", Join[{"url" -&gt; url}, Flatten[{opts}]]]</code> </pre> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">deleteWebhook</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entfernt</a> einen Handler </li></ul><br><pre> <code class="plaintext hljs">deleteWebhook::usage = "deleteWebhook[bot]"; TelegramBot /: deleteWebhook[bot_TelegramBot] := telegramExecute[bot, "deleteWebhook"]</code> </pre> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">getWebhookInfo</a> - Informationen zum Handler </li></ul><br><pre> <code class="plaintext hljs">getWebhookInfo::usage = "getWebhookInfo[bot]"; TelegramBot /: getWebhookInfo[bot_TelegramBot] := telegramExecute[bot, "getWebhookInfo"]</code> </pre> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sendMessage</a> - Senden Sie eine Chat-Nachricht </li></ul><br><pre> <code class="plaintext hljs">sendMessage::usage = "sendMessage[bot, chat, text]"; Options[sendMessage] = { "parse_mode" -&gt; Automatic, "disable_web_page_preview" -&gt; Automatic, "disable_notification" -&gt; Automatic, "reply_to_message_id" -&gt; Automatic, "reply_markup" -&gt; Automatic }; TelegramBot /: sendMessage[bot_TelegramBot, chat_Integer, text_String, opts: OptionsPattern[sendMessage]] := telegramExecute[ bot, "sendMessage", Join[{"chat_id" -&gt; chat, "text" -&gt; text}, Flatten[{opts}]] ]</code> </pre> <br><p>  Die Mindestversion der API ist bereit.  Lassen Sie uns √ºberpr√ºfen, wie das Senden einer Nachricht und das Empfangen von Updates funktioniert.  Erstellen Sie dazu einen Chat mit unserem Bot.  Wenn der Bot erstellt wird, wird die erste Nachricht mit dem Text / start gesendet.  Mal sehen, ob es in die Liste der Updates aufgenommen wurde: </p><br><pre> <code class="plaintext hljs">updates = getUpdates[bot]</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Out [..]: = ...</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">&lt;|"ok" -&gt; True, "result" -&gt; {&lt;|"update_id" -&gt; 570790461, "message" -&gt; &lt;|"message_id" -&gt; 1, "from" -&gt; &lt;|"id" -&gt; 490138492, "is_bot" -&gt; False, "first_name" -&gt; "Kirill", "last_name" -&gt; "Belov", "username" -&gt; "KirillBelovTest"|&gt;, "chat" -&gt; &lt;|"id" -&gt; 490138492, "first_name" -&gt; "Kirill", "last_name" -&gt; "Belov", "username" -&gt; "KirillBelovTest", "type" -&gt; "private"|&gt;, "date" -&gt; 1542182547, "text" -&gt; "/start", "entities" -&gt; {&lt;|"offset" -&gt; 0, "length" -&gt; 6, "type" -&gt; "bot_command"|&gt;}|&gt;|&gt;}|&gt;</code> </pre> </div></div><br><p>  Sie k√∂nnen die neuesten Aktualisierungsdaten wie folgt aus der Liste der Aktualisierungen abrufen: </p><br><pre> <code class="plaintext hljs">lastUpdate = updates["result"][[-1]]</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Out [..]: = ...</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">&lt;|"update_id" -&gt; 570790461, "message" -&gt; &lt;|"message_id" -&gt; 1, "from" -&gt; &lt;|"id" -&gt; 490138492, "is_bot" -&gt; False, "first_name" -&gt; "Kirill", "last_name" -&gt; "Belov", "username" -&gt; "KirillBelovTest"|&gt;, "chat" -&gt; &lt;|"id" -&gt; 490138492, "first_name" -&gt; "Kirill", "last_name" -&gt; "Belov", "username" -&gt; "KirillBelovTest", "type" -&gt; "private"|&gt;, "date" -&gt; 1542182547, "text" -&gt; "/start", "entities" -&gt; {&lt;|"offset" -&gt; 0, "length" -&gt; 6, "type" -&gt; "bot_command"|&gt;}|&gt;|&gt;</code> </pre> </div></div><br><p>  Und so erhalten Sie den Chat, aus dem die Nachricht stammt, und den Nachrichtentext selbst: </p><br><pre> <code class="plaintext hljs">chat = lastUpdate["message", "chat", "id"] text = lastUpdate["message", "text"]</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Out [..]: = ...</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">490138492 /start</code> </pre> </div></div><br><p>  Wie Sie dem Ergebnis entnehmen k√∂nnen, ist alles vorhanden.  Jetzt senden wir mit sendMessage eine Nachricht im Namen des Bots. </p><br><pre> <code class="plaintext hljs">sendMessage[bot, chat, "hello"]</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Out [..]: = ...</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">&lt;|"ok" -&gt; True, "result" -&gt; &lt;|"message_id" -&gt; 2, "from" -&gt; &lt;|"id" -&gt; 753681357, "is_bot" -&gt; True, "first_name" -&gt; "Wolfram Cloud Bot", "username" -&gt; "WolframCloud5973827Bot"|&gt;, "chat" -&gt; &lt;|"id" -&gt; 490138492, "first_name" -&gt; "Kirill", "last_name" -&gt; "Belov", "username" -&gt; "KirillBelovTest", "type" -&gt; "private"|&gt;, "date" -&gt; 1542182601, "text" -&gt; "hello"|&gt;| &gt;</code> </pre> </div></div><br><p><img src="https://habrastorage.org/webt/df/-j/gd/df-jgdfzo0uejbmzxxbuja3koou.gif"></p><br><p>  Im Allgemeinen reicht dieser Funktionsumfang bereits aus.  Die Verwendung der Methode getUpdates ist jedoch nicht sehr praktisch.  Sie m√ºssen einen Weg finden, um Nachrichten mit Webhook zu verarbeiten. </p><br><h2 id="sozdanie-webhook">  Webhook erstellen </h2><br><p>  Wolram Langauge hat eine spezielle Art von Funktion, die mit APIFunction erstellt wird.  Hier ist ein Beispiel f√ºr eines davon: </p><br><pre> <code class="plaintext hljs">apiFunc = APIFunction[{"n" -&gt; "Integer"}, Plot[Sin[#n * x], {x, -2Pi, 2Pi}]&amp;, "PNG"]; apiFunc[{"n"-&gt;3}]</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Out [..]: = ...</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/tg/jk/vj/tgjkvjwyaje9k8yfqfspnpnwwpi.png"></p></div></div><br><p>  Diese Funktionen wurden speziell f√ºr die Bereitstellung in der Cloud entwickelt.  Diese Funktion akzeptiert einen Anforderungsparameter als Eingabe.  Um es in der Cloud bereitzustellen, √ºbertragen Sie einfach die Funktion selbst auf CloudDeploy. </p><br><pre> <code class="plaintext hljs">apiObject = CloudDeploy[apiFunc, "Deploy/apiObject"]</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Out [..]: = ...</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">CloudObject[https://www.wolframcloud.com/objects/kirillbelovtest/apiObject]</code> </pre> </div></div><br><p>  Dann k√∂nnen Sie dem Link im Browser folgen und einen Abfrageparameter hinzuf√ºgen: </p><br><p><img src="https://habrastorage.org/webt/__/th/nt/__thntqsmtke_w8lx_ysyiqagey.gif"></p><br><p>  Die obige Funktion hat die Anforderungsparameter behandelt.  Sie m√ºssen also dieselbe Funktion erstellen, um den Text der HTTP-Anforderung zu verarbeiten, die vom Telegrammbot in Form eines Aktualisierungsobjekts kommt.  Um die Adresse zu generieren, verwenden wir ein Token, um Zugriff auf das Cloud-Objekt zu erhalten, was schwieriger war.  Es muss auch angegeben werden, dass das Objekt √∂ffentlich zug√§nglich ist, da sonst Telegramme nicht zum Webhook gelangen k√∂nnen. </p><br><pre> <code class="plaintext hljs">deployWebhook[bot_TelegramBot, handler_] := CloudDeploy[APIFunction[{}, handler[HTTPRequestData["Body"]] &amp;], "Deploy/Webhooks/" &lt;&gt; Hash[bot, "SHA", "HexString"], Permissions -&gt; "Public" ]</code> </pre> <br><p>  Handler ist ein weiterer Funktionshandler.  Lassen Sie den Handler die Zeichenfolge des Anforderungshauptteils in eine Zuordnung verwandeln, von dort die Chat-ID abrufen und das Wort "Hallo" zur√ºcksenden. </p><br><pre> <code class="plaintext hljs">handlerHello[bot_TelegramBot][body_String] := Block[{json = ImportString[body, "RawJSON"], chat}, chat = json["message", "chat", "id"]; sendMessage[bot, chat, "hello"]; ]</code> </pre> <br><p>  Stellen Sie nun den Funky in der Cloud bereit. </p><br><pre> <code class="plaintext hljs">webhookObject = deployWebhook[bot, handlerHello[bot]]</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Out [..]: = ...</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">CloudObject[https://www.wolframcloud.com/objects/kirillbelovtest/Deploy/Webhooks/b9bd74f89348faecd6b683ba02637dd4d4028a28]</code> </pre> </div></div><br><p>  Der letzte Schritt besteht darin, die Adresse dieses Objekts an den Telegrammbot zu √ºbertragen. </p><br><pre> <code class="plaintext hljs">setWebhook[bot, webhookObject[[1]]]</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Out [..]: = ...</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">&lt;|"ok" -&gt; True, "result" -&gt; True, "description" -&gt; "Webhook was set"|&gt;</code> </pre> </div></div><br><p>  Jetzt schreiben wir etwas f√ºr den Bot und sehen, was darin steht: </p><br><p><img src="https://habrastorage.org/webt/3l/ft/by/3lftbys5dvmtauvrmvom1wtggtc.gif"></p><br><p>  Der Dialog kann als g√ºltig angesehen werden.  Um die Logik eines vorhandenen Handlers zu √§ndern, stellen Sie das Cloud-Objekt einfach erneut bereit.  Gleichzeitig m√ºssen Sie den Webhook f√ºr den Bot nicht mehr installieren. </p><br><h2 id="logika-otvetov">  Logik der Antworten </h2><br><p>  Dies ist der letzte Teil beim Erstellen eines Bots in der Wolfram-Cloud.  Auf die gleiche Weise k√∂nnen Sie die Logik komplizieren und neue API-Methoden hinzuf√ºgen.  Nun zum Dialog selbst.  Angenommen, der Bot gibt nach dem Senden des Befehls / start eine Antwort "Hallo" zur√ºck und √§ndert die Tastatur des Benutzers.  Es bleiben nur zwei Tasten auf der Tastatur: "Hallo" und "Wer bist du?"  Wir realisieren den Dialog in Form eines Vereins.  Die Schl√ºssel sind die Befehle, die der Benutzer an den Bot sendet.  Die Schl√ºsselwerte sind die Bot-Antwort selbst und die neue Tastatur.  In diesem Fall sollten viele Tasten und Kn√∂pfe genau √ºbereinstimmen.  Andernfalls kann es vorkommen, dass der Bot nicht wei√ü, was er antworten soll.  In solchen F√§llen k√∂nnen Sie nat√ºrlich eine Standardantwort hinzuf√ºgen. </p><br><pre> <code class="plaintext hljs">keyboard[buttons : {__String}] := {"keyboard" -&gt; {Table[{"text" -&gt; button}, {button, buttons}]}, "resize_keyboard" -&gt; True} $answers = &lt;| (*user_text-&gt;&lt;|"answer"-&gt;bot_text,"keyboard"-&gt;next_text|&gt;*) "/start"-&gt;&lt;|"answer"-&gt;"","keyboard"-&gt; keyboard[{""," ?"}]|&gt;, ""-&gt;&lt;|"answer"-&gt;" ?", "keyboard" -&gt; keyboard[{" ?"}]|&gt; , " ?"-&gt;&lt;|"answer"-&gt;"", "keyboard" -&gt; keyboard[{""}]|&gt; , " ?"-&gt;&lt;|"answer"-&gt;"   Wolfram Language   ", "keyboard"-&gt;keyboard[{" ?"," ?"}]|&gt; , " ?"-&gt;&lt;|"answer"-&gt;"   :\nhttps://habr.com/post/422517/", "keyboard"-&gt;keyboard[{""," ?"}]|&gt; , " ?"-&gt;&lt;|"answer"-&gt;"  :\n@KirillBelovTest", "keyboard"-&gt;keyboard[{" ?",""}]|&gt; , ""-&gt;&lt;|"answer"-&gt;"", "keyboard"-&gt;keyboard[{""," ?"}]|&gt; |&gt;; answer[text_String] /; KeyExistsQ[$answers, text] := $answers[text]</code> </pre> <br><p>  Erstellen Sie nun einen Handler: </p><br><pre> <code class="plaintext hljs">handlerAbout[bot_TelegramBot][body_String] := Block[{json = ImportString[body, "RawJSON"], chat, text}, chat = json["message", "chat", "id"]; text = json["message", "text"]; sendMessage[bot, chat, answer[text]["answer"], "reply_markup" -&gt; answer[text]["keyboard"]]; ]</code> </pre> <br><p>  Und stellen Sie das Cloud-Objekt erneut bereit: </p><br><pre> <code class="plaintext hljs">deployWebhook[bot, handlerAbout[bot]];</code> </pre> <br><p>  Lassen Sie uns √ºberpr√ºfen, was im Chat mit dem Bot passiert ist.  Aber zuerst l√∂schen wir den Nachrichtenverlauf: </p><br><p><img src="https://habrastorage.org/webt/ar/rr/j0/arrrj0gaxdyrhcysog_vxleb4hw.gif"></p><br><h2 id="rasshirenie-funkcionalnosti">  Funktionserweiterung </h2><br><p>  Bisher gibt es keine grunds√§tzlichen Unterschiede zu der Vielzahl der vorhandenen Bots.  Vielleicht macht es auch keinen Sinn, es zu trinken?  Die Bedeutung aller oben geleisteten Arbeit wird sein, wenn Sie verstehen, was die Vorteile eines solchen Bots sind!  Immerhin kann er alle Funktionen von Wolfram Language und Wolrfam Cloud nutzen.  Muss der Roboter Gleichungen l√∂sen?  Es ist sehr einfach!  Sie m√ºssen nur die Antwort neu definieren! </p><br><pre> <code class="plaintext hljs">answer[text_String]["keyboard"] /; StringContainsQ[text, "  "] := Automatic answer[text_String]["answer"] /; StringContainsQ[text, "  "] := ToString[Flatten[Block[{args = StringSplit[text, "  "]}, Solve[ToExpression[args[[1]]], ToExpression[args[[2]]]] ]]] deployWebhook[bot, handlerAbout[bot]];</code> </pre> <br><p><img src="https://habrastorage.org/webt/ei/wc/ex/eiwcexe7iqdlhdtolosjrialh8q.gif"></p><br><p>  Wenn jemand zus√§tzlich Interesse an den Funktionen der Cloud hat, finden Sie hier eine gute Beschreibung ihrer Funktionalit√§t. </p><br><h2 id="ogranicheniya">  Einschr√§nkungen </h2><br><p>  Wolfram Cloud ist eine Plattform, auf der Sie die Wolfram-Sprache kostenlos verwenden k√∂nnen, w√§hrend das Hauptprodukt von Wolfram Research, Mathematica, Geld kostet.  Dementsprechend gibt es Einschr√§nkungen bei der Verwendung und meiner Meinung nach sind sie sehr stark.  Bei Verwendung der kostenlosen Version der Entwicklungsplattform erh√§lt ein Benutzer 1000 Cloud-Credits pro Monat.  Jeder Cloud-Kredit gibt Zeit, um einen anderen Typ zu berechnen.  Da der Artikel √ºber CloudDeploy + APIFunction spricht, verbrauchen solche in der Cloud gespeicherten Objekte 1 Guthaben in 0,1 Sekunden Rechenzeit.  Es ist leicht zu berechnen, dass der Benutzer nur 1 Minute und 40 Sekunden Serverzeit f√ºr den Betrieb seiner Anwendung (in diesem Fall des Bots) kostenlos erh√§lt.  Ich habe hier nichts hinzuzuf√ºgen - es ist sehr, sehr klein.  Das Hauptaugenmerk liegt auf Benutzern, die unabh√§ngig in der Entwicklungsplattform mit einem Browser arbeiten.  In diesem Modus gibt es keine zeitlichen Beschr√§nkungen, sondern nur nach der Dauer der Sitzung und den zugewiesenen Ressourcen.  Bei dieser Verwendung ist die Entwicklungsplattform fast eine vollst√§ndige Mathematica, erfordert jedoch keine Installation und Lizenz. </p><br><p>  ‚Üí <a href="">Artikel und Code in Wolfram Cloud</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de422517/">https://habr.com/ru/post/de422517/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de422507/index.html">PHP 7.3. Was gibt's Neues</a></li>
<li><a href="../de422509/index.html">Zusammenfassung des Buches "Never Eat Alone"</a></li>
<li><a href="../de422511/index.html">Laden von Daten in Splunk: Universal Forwarder vs Heavy Forwarder. Was ist der Unterschied?</a></li>
<li><a href="../de422513/index.html">7 Tipps, wie Sie einen Testerkollegen im Urlaub nicht ver√§rgern k√∂nnen</a></li>
<li><a href="../de422515/index.html">Zwei Apache Ignite Mitaps und In-Memory Computing Webinar im September</a></li>
<li><a href="../de422519/index.html">Freebie Distribution: Nicht bremsende Threads in Java. Projektwebstuhl</a></li>
<li><a href="../de422521/index.html">Vorahnung des Unvermeidlichen</a></li>
<li><a href="../de422525/index.html">"Die Matrix der Freundschaft." Der √§lteste soziale Graph f√ºr den kleinsten</a></li>
<li><a href="../de422527/index.html">PostgreSQL News Digest. Ausgabe 10</a></li>
<li><a href="../de422529/index.html">Group-IB-Spezialkurs: ‚ÄûSicherheit mobiler Anwendungen‚Äú</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>