<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçá üéå üå∂Ô∏è Conversaciones sobre programaci√≥n funcional en C ++ Siberia 2019 üí´ ü§¥üèΩ üèá</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola a todos! 


 Recientemente, se celebr√≥ en Novosibirsk el pr√≥ximo C ++ Siberia 2019. La conferencia tuvo un ambiente acogedor y muchos buenos info...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Conversaciones sobre programaci√≥n funcional en C ++ Siberia 2019</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/444212/"><p>  Hola a todos! </p><br><p>  Recientemente, se celebr√≥ en Novosibirsk el pr√≥ximo C ++ Siberia 2019. La conferencia tuvo un ambiente acogedor y muchos buenos informes.  Aprovech√© esta oportunidad para hablar con dos de nuestros oradores, a quienes pronto podr√°n ver en Mosc√∫. </p><br><p><img width="100" align="left" src="https://habrastorage.org/webt/yk/tc/m6/yktcm6h7qrfisa5rcudmirsl6ys.jpeg">  <strong>Ivan Chukic</strong> es uno de los desarrolladores de KDE, profesor e investigador del dise√±o de lenguajes de programaci√≥n en la Universidad de Belgrado. <br clear="all"></p><br><p><img width="100" align="left" src="https://habrastorage.org/webt/21/vg/0y/21vg0ybouvc_hip9zys9-dkznew.jpeg">  <strong>Alexander Granin</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">graninas</a> ) es un conocido orador y desarrollador especializado en FP, el organizador de la comunidad de FP Novosibirsk LambdaNsk. <br clear="all"></p><br><p><img src="https://habrastorage.org/webt/fj/9f/nr/fj9fnrzzgxrmy9ur1vpzyjuyyau.png"></p><a name="habracut"></a><br><p>  <strong>Sergey:</strong> Hola a todos, vamos a conocernos.  Alexander es un orador principal en este C ++ Siberia, e Ivan fue un orador principal el a√±o pasado.  Hablemos de programaci√≥n funcional.  Por lo que recuerdo, FP en C ++ fue el tema de su discurso principal anterior, Ivan ... </p><br><p>  <strong>Ivan:</strong> No del todo, pero parcialmente, s√≠. </p><br><p>  <strong>Sergey:</strong> Y el tema del informe de Alexander es sobre la programaci√≥n funcional.  Por lo tanto, prepar√© un par de preguntas y la primera: ¬øc√≥mo se determina la FA? </p><br><p>  <strong>Alexander:</strong> No creo que haya una definici√≥n "correcta" de FP, pero hablando de m√≠ personalmente, FP es algo con una composici√≥n funcional y funciones de primera clase. </p><br><p>  <strong>Ivan:</strong> Estoy de acuerdo, pero agregar√≠a m√°s funciones de un orden superior, aquellas que pueden tomar otras funciones como argumentos y devolverlas como resultado. </p><br><p>  <strong>Sergey</strong> : Enlace a una funci√≥n en C, ¬øse considera? </p><br><p>  <strong>Ivan:</strong> No, C no es un lenguaje de programaci√≥n funcional :-) </p><br><p>  <strong>Sergey:</strong> Dime por qu√©? </p><br><p>  <strong>Ivan:</strong> Debido a que no puede crear una nueva funci√≥n a partir de una combinaci√≥n de punteros de funci√≥n, solo puede apuntar a los existentes.  Por supuesto, si no se usaron algunos hacks de ensamblador. </p><br><p>  <strong>Sergey:</strong> Genial, ¬°ahora tengo una respuesta oficial!  Las personas constantemente hacen esta pregunta por qu√© C no es un lenguaje de programaci√≥n funcional, porque hay funciones completas all√≠.  Y aqu√≠ es por qu√© C ++ es un lenguaje funcional, m√°s comprensible ... </p><br><p>  <strong>Alexander:</strong> No dir√≠a que C ++ es un lenguaje de programaci√≥n realmente funcional, admite un mont√≥n de paradigmas vertidos en un lenguaje. </p><br><p>  <strong>Sergey: Quiero</strong> decir, C ++ admite el paradigma funcional, por supuesto.  Por cierto, ¬øpor qu√©?  ¬øLo admite porque puedes manipular funciones de orden superior? </p><br><p>  <strong>Ivan:</strong> Bueno, me parece que siempre ha sido as√≠, porque incluso en C ++ 98, las funciones de orden superior ya existen, incluso en STL.  Este no es el lenguaje funcional m√°s conveniente: hay lenguajes que implementan FP y mejores.  Pero para mis necesidades siempre ha sido bastante funcional. </p><br><p>  <strong>Sergey:</strong> Pero desde este lugar con m√°s detalle.  ¬øQu√© tipo de necesidades tienes? </p><br><p> <strong>Ivan:</strong> es complicado.  Vamos, cuenta una historia.  Cuando estaba en la universidad, pasamos por LISP, y todos odiaban este LISP porque es feo.  Pero lo que entend√≠ de esto es c√≥mo simular construcciones C directamente en c√≥digo LISP.  Y luego, un d√≠a, sali√≥ una nueva versi√≥n de Java, que se lanz√≥ para cosas como el <code>foreach</code> incorporado, y pens√©: wow, necesitas un nuevo compilador, una nueva versi√≥n del lenguaje y todo eso es nuevo solo para implementar algo que hice en la universidad en LISP , que generalmente ni siquiera admite bucles.  En ese momento, me di cuenta de que FP es algo bastante bueno para construir abstracciones de alto nivel, y es por eso que uso C ++ funcional en 2019. </p><br><p>  <strong>Sergey:</strong> De hecho, usas el FP para un dise√±o de alto nivel. </p><br><p>  <strong>Ivan:</strong> Exactamente. </p><br><p>  <strong>Alexander:</strong> En este momento no trabajo en C ++, pero no me negar√≠a a usarlo para manipular datos, esto es mucho m√°s agradable que en el enfoque imperativo.  Incluso en comparaci√≥n con OOP, en contraste con √©l, solo las transformaciones son aceptables aqu√≠, y esto es conveniente. </p><br><p>  <strong>Sergey:</strong> Bueno, puedes usar FP no solo con C ++, ¬øverdad?  Bien, entonces la siguiente pregunta: ¬øqu√© parte de C ++ est√°s usando?  Si solo los problemas de dise√±o son importantes, puede elegir solo la parte que vaya bien con el FP, la que realmente usa. </p><br><p>  <strong>Ivan:</strong> Estas definitivamente ser√°n funciones lambda.  Y a√∫n m√°s importante: plantillas, porque le permiten pasar otras funciones como argumentos y todo lo dem√°s, y las lambdas son solo una buena sintaxis para escribir objetos funcionales. </p><br><p>  <strong>Sergey:</strong> S√≠, ya nos dimos cuenta de que realmente te gustan las lambdas :-) </p><br><p>  <strong>Ivan:</strong> No es que <em>realmente</em> les hayan gustado, pero esto es claramente lo mejor que ten√≠amos en C ++ 98, es m√°s conveniente trabajar con ellos. </p><br><p>  <strong>Alexander:</strong> S√≠, tambi√©n me gustan las lambdas: esta caracter√≠stica es tan universal que solo se puede escribir en ellas.  Esto es algo as√≠ como un combinador universal que le permite construir cualquier l√≥gica, tal vez no tan hermosa como en otros idiomas, pero no menos √∫til. </p><br><p>  <strong>Sergey:</strong> Ivan, notaste aqu√≠ que hay est√°ndares anteriores a C ++ 11, por ejemplo, C ++ 03, que es muy com√∫n, y ya hay caracter√≠sticas funcionales all√≠.  Y hay m√°s caracter√≠sticas funcionales en los nuevos est√°ndares ... ¬øEs posible decir que C ++ se est√° moviendo hacia el FP?  ¬øContinuar√° o se detendr√° este movimiento?  ¬øY entonces a qu√© conducir√°? </p><br><p>  <strong>Ivan:</strong> Hay un buen informe de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Simon Peython Jones</a> sobre los lenguajes de programaci√≥n en general, y all√≠ dibuj√≥ un gr√°fico que muestra muchos idiomas seguros y los idiomas utilizados.  Haskell comenz√≥ su historia como un lenguaje completamente seguro con el que no se puede hacer nada, porque no hay E / S y nada en absoluto.  SPJ clasific√≥ el lenguaje C y los lenguajes ensambladores como aquellos que son muy √∫tiles, pero al mismo tiempo extremadamente inseguros.  Desde entonces, Haskell ha comenzado a avanzar hacia una mayor seguridad.  Por otro lado, esas caracter√≠sticas que aparecen en C ++: parecen aumentar principalmente la seguridad para que pueda escribir programas correctos de manera m√°s simple.  Dio la casualidad de que la mayor√≠a de estas cosas provienen de lenguajes de programaci√≥n funcionales. </p><br><p>  <strong>Sergey:</strong> ¬øPor qu√© piensas eso?  ¬øDebido a la naturaleza de la FA? </p><br><p>  <strong>Ivan:</strong> S√≠, tal vez por naturaleza ... pero no estoy seguro. </p><br><p>  <strong>Alexander:</strong> Creo que la FA cautiva a todos simplemente porque estamos cansados ‚Äã‚Äãde luchar con plantillas, reorganizar bytes, con alg√∫n tipo de heces de bajo nivel; queremos algo digno de aplicar nuestra propia inteligencia. </p><br><p>  <strong>Sergey:</strong> Es decir, ¬øpara ti esto es una especie de ejercicio intelectual? </p><br><p>  <strong>Alexander:</strong> S√≠, as√≠. </p><br><p>  <strong>Sergey:</strong> entiendo.  Cu√°nto m√°s interesante es para un desarrollador pensar en abstracciones de alto nivel que implementar caracter√≠sticas est√∫pidas est√°ndar; esto es desagradable.  Entonces esta es la pregunta <strong>C:</strong> ¬øtiene alguna experiencia con la aplicaci√≥n pr√°ctica de FP en C ++?  ¬øAlg√∫n proyecto de producci√≥n? </p><br><p>  <strong>Ivan: por</strong> supuesto.  Uno de los proyectos m√°s grandes del mundo, KDE, tiene varias partes dentro de √©l que usan intensamente el estilo funcional.  Por supuesto, esta es una mezcla de, por as√≠ decirlo, C ++ m√°s tradicional orientado a objetos con un conjunto de conceptos funcionales.  Nunca iba a ser purista o algo as√≠.  Siempre trato de combinar lo mejor de diferentes mundos. </p><br><p>  <strong>Sergey:</strong> ¬øQu√© hay de Haskell o Scala?  Despu√©s de todo, son ampliamente utilizados en la producci√≥n.  ¬øQu√© le parece la idea de que Haskell ahora se considera el est√°ndar de un lenguaje funcional?  Esto es especialmente notado por los puristas. </p><br><p>  <strong>Ivan:</strong> S√≠, estoy de acuerdo en que Haskell hoy es sin√≥nimo de FP.  De hecho, cualquier caracter√≠stica de Haskell es percibida por las personas como algo relacionado con la PF.  Esto no es necesariamente cierto, pero creo que Haskell se ha convertido realmente en el lenguaje de programaci√≥n funcional acad√©mico m√°s popular.  S√© que varios bancos en Londres y el norte de Europa hacen un uso extensivo de Haskell, pero a√∫n as√≠ Scala es mucho m√°s popular en este momento. </p><br><p>  <strong>Alexander:</strong> Estoy de acuerdo en que Scala es m√°s popular, pero Haskell parece ser un lenguaje m√°s funcional, la mayor√≠a de sus caracter√≠sticas se implementan m√°s correctamente.  Es decir, cuando tienes curry que es f√°cil de hacer, cuando hay una manera f√°cil de hacer la composici√≥n, la programaci√≥n se vuelve f√°cil y simple, es como caminar por el bosque y disfrutar de las vistas. </p><br><p>  <strong>Ivan:</strong> Pero a veces hay osos en el bosque.  Si estas en Rusia. </p><br><p>  <strong>Sergey:</strong> ¬øCrees que C ++ est√° inspirado principalmente en Haskell?  ¬øVale la pena? </p><br><p>  <strong>Ivan:</strong> ¬øTe das cuenta de alg√∫n miembro espec√≠fico del comit√©?  :-) Alguien insinu√≥ que los conceptos aparecieron como resultado de la comprensi√≥n de las clases de clase, pero Bj√∂rn detuvo estos rumores e incluso escribi√≥ alg√∫n documento sobre c√≥mo los conceptos difieren de las clases de clase.  Desde mi punto de vista, difieren en todo, pero tienen un prop√≥sito.  Solo diferentes enfoques. </p><br><p>  <strong>Sergey:</strong> ¬øEl futuro / promesa est√° relacionado de alguna manera con FI?  Bartosh parece haber argumentado que estas son m√≥nadas mal implementadas. </p><br><p>  <strong>Ivan:</strong> Bueno, s√≠, se implementan como m√≥nadas, transmitiendo secuelas, pero no estoy seguro de qu√© es lo m√°s importante en este asunto. </p><br><p>  <strong>Sergey:</strong> ¬øNecesitamos soporte mejorado de m√≥nada en C ++? </p><br><p>  <strong>Alexander:</strong> Por supuesto, esta es la caracter√≠stica m√°s importante que puede convertir C ++ en un lenguaje realmente bueno. </p><br><p>  <strong>Ivan:</strong> Por cierto, ya que estamos en la conferencia, d√©jame hacerte una pregunta tambi√©n, Sergey.  Dijiste que las conferencias son un trabajo emocionante.  Comparta lo que es tan interesante al respecto, y ¬øme aconsejar√≠a a m√≠ o al camarada Granin organizar independientemente conferencias en otras partes del mundo? </p><br><p>  <strong>Sergey: La</strong> organizaci√≥n de conferencias es realmente genial, conoces a muchas personas interesantes, pero esto es solo la punta del iceberg.  Y all√° abajo: mucho trabajo, toda esta preparaci√≥n del sal√≥n, comida para los participantes, sin mencionar la b√∫squeda de oradores.  C ++ Rusia todav√≠a no es la conferencia m√°s famosa del mundo, y los oradores tienen que explicar que somos una conferencia nueva, que aqu√≠ est√°n sucediendo cosas interesantes.  Debe convencer al orador, especialmente a los famosos oradores estrella que no est√°n particularmente interesados ‚Äã‚Äãen volar a Rusia solo para ver un nuevo pa√≠s.  El trabajo organizativo es dif√≠cil, especialmente si trabajas en el trabajo principal.  Pero todo vale la pena comunic√°ndose con estas personas maravillosas.  Sin embargo, ahora he llegado al punto de que prefiero asistir a la conferencia de otra persona que a la m√≠a. </p><br><p>  <strong>Ivan:</strong> Es decir, sugieres asistir a conferencias, en lugar de hacerlas. </p><br><p>  <strong>Sergey:</strong> S√≠, si puedes evitar organizar una conferencia, deber√≠as arriesgarte.  Al organizar, una gran carga caer√° sobre usted, este es otro trabajo de 8 horas.  Personalmente, empiezo a trabajar 8 horas adicionales al d√≠a aproximadamente 3 meses antes de la conferencia.  Es divertido hacerlo ... pero espero que mi familia sea igual de divertida.  Gracias por preguntar! </p><br><p>  Y ahora, volviendo al tema.  Hablamos de programaci√≥n funcional, y casi me convenciste, en el sentido de que tus informes me convencieron.  Existe la sospecha de que el enfoque funcional en C ++ me ayudar√° con el subprocesamiento m√∫ltiple cuando necesito sincronizar diferentes cosas.  ¬øRealmente ayudar√°? </p><br><p>  <strong>Ivan: por</strong> supuesto. </p><br><p>  <strong>Alexander:</strong> A pesar del hecho de que tengo una experiencia limitada con subprocesos m√∫ltiples funcionales espec√≠ficamente en C ++, tengo que decir que cuando tienes un mundo de funciones puras, es mucho m√°s f√°cil hablar de ellas en un entorno multiproceso.  Si escribe l√≥gica, por ejemplo, competitiva, no tiene que pensar en sincronizar todas estas cosas, en mutexes, en secciones cr√≠ticas, en nada.  Todo esto simplemente desaparece, porque piensas en el c√≥digo como un c√≥digo secuencial regular, y todos los subprocesos m√∫ltiples y la sincronizaci√≥n est√°n ocultos en alg√∫n lugar dentro.  Hay muchos enfoques para la programaci√≥n multiproceso y funcional.  No estoy seguro de que esto suceda en absolutamente todos los enfoques, pero, por ejemplo, la memoria transaccional de software es un gran enfoque para reducir la complejidad en aplicaciones competitivas.  Lamentablemente, se trata de elegir los compromisos correctos. </p><br><p>  <strong>Ivan:</strong> Cuando el compilador hace todo el trabajo por ti, tienes que pagar con eficiencia. </p><br><p>  <strong>Alexander:</strong> Bueno, hay diferentes problemas.  Primero, debe comprender todas estas cosas como STM, y luego transmitir este conocimiento secreto a sus colegas.  Y luego hay errores en una implementaci√≥n particular y lugares que pueden funcionar mucho mejor cuando se usa el control manual de subprocesos.  Pero puede escribir m√°s r√°pido y m√°s f√°cil que con dicho control manual.  Ser√° m√°s lento de ejecutar, pero el c√≥digo tendr√° menos errores.  Por cierto, Ivan, ¬øqu√© opinas sobre qu√© tan bien este tema est√° bien cubierto en las conferencias? </p><br><p>  <strong>Ivan:</strong> Este tema est√° en auge.  En los √∫ltimos a√±os, todas las conferencias principales: CPPConf, C ++ Rusia, Meeting C ++, etc.  - Recib√≠ informes directamente en FP, o en estructuras de datos algebraicos, o algo as√≠.  A veces los oradores ni siquiera sospechan que en su informe hablan sobre alg√∫n concepto del FP.  En C ++, las cosas provienen de muchos lugares diferentes ... La gente generalmente no escribe en un solo idioma.  Imagine a Ivan Ivanov trabajando en un proyecto escrito en Erlang y C ++.  Entonces llega Tatyana Petrovna, y ella ya trabaja para Haskell con funciones puras y todo eso, toman sus mecanismos favoritos y los portan a C ++, y como resultado, una gran cantidad de personas de diferentes comunidades traen m√°s y m√°s cosas a C ++.  Todo esto sucede ante nuestros ojos.  Como m√≠nimo, esto sucede en la comunidad de desarrolladores de C ++, pero en cuanto a las compa√±√≠as de C ++, no estoy tan seguro.  Sin embargo, muchas personas en la comunidad C ++ ahora est√°n trabajando en conceptos funcionales. </p><br><p>  <strong>Alexander:</strong> ¬øEntend√≠ correctamente que muchos de los principales desarrolladores de C ++ estudian Haskell solo para comprender lo que est√° sucediendo con C ++? </p><br><p>  <strong>Ivan:</strong> No estoy seguro de que le ense√±en a Haskell por este motivo.  Creo que los desarrolladores de C ++ son muy ego√≠stas.  Aprendieron C ++ muy bien solo porque es complejo.  Y si quieres aprender algo realmente nuevo, tu camino obviamente no se encuentra en ning√∫n Java, que est√° especialmente creado para ser simple.  Debe buscar en el campo de los idiomas extra√±os e inusuales, los m√°s extra√±os, y Haskell estar√° autom√°ticamente entre las respuestas m√°s populares.  Una persona lo ve, entiende: oh, esto es algo m√°s complejo que C ++, necesita aprender.  Cuando estudi√© a Haskell, fue lo mismo conmigo, y tengo amigos que han seguido exactamente la misma l√≠nea de razonamiento. </p><br><p>  <strong>Alexander:</strong> Cuando Eric Nibler estuvo con nosotros en Siberia y mostr√≥ su biblioteca para rangos, a menudo se le pregunt√≥ cu√°l era la fuente de inspiraci√≥n.  √âl respondi√≥ que era Haskell.  Tal vez no se deben tomar todas las caracter√≠sticas seguidas, pero algunas son claramente necesarias en la comunidad. </p><br><p>  <strong>Ivan:</strong> Es un poco de evoluci√≥n.  Material gen√©tico.  Y Haskell tambi√©n se puede mejorar tomando algo de C ++.  La mayor√≠a de los idiomas est√°n experimentando tal evoluci√≥n.  Java intent√≥ adaptar LINQ de C # a s√≠ mismo, y los creadores de LINQ de C # se inspiraron en Haskell, etc.  Resulta una red tan hermosa y enredada de influencia mutua entre diferentes idiomas. </p><br><p>  <strong>Alexander:</strong> Sin embargo, ¬øC ++ sigue siendo un lenguaje de bajo nivel? </p><br><p>  <strong>Ivan:</strong> La mayor√≠a de la gente piensa que s√≠. </p><br><p>  <strong>Sergey:</strong> ¬øDe qu√© tipo de "bajo nivel" est√°s hablando? </p><br><p>  <strong>Ivan:</strong> Compilado en c√≥digo de bajo nivel.  Pero funciona con abstracciones de alto nivel.  Todo el punto y el prop√≥sito es que tales abstracciones no conducen a una sobrecarga innecesaria en t√©rminos de rendimiento.  C ++ deber√≠a generar c√≥digo a partir de sus abstracciones que no ser√≠an peores que las escritas a mano.  Al menos te√≥ricamente. </p><br><p>  <strong>Alexander:</strong> ¬øQu√© pasa si alguien rompe esta regla?  Por ejemplo, Rangos. </p><br><p>  <strong>Ivan: El</strong> rendimiento de la compilaci√≥n sufre, s√≠.  Todas las caracter√≠sticas nuevas, especialmente las caracter√≠sticas suministradas en las bibliotecas, aumentan el tiempo de compilaci√≥n.  Pero no hay raz√≥n para que los rangos sean lentos.  Si los rangos se est√°n desacelerando, entonces lo √∫nico que puede culpar aqu√≠ son los compiladores que no est√°n optimizados para este caso en particular. </p><br><p>  <strong>Sergey: los</strong> rangos en s√≠ mismos no est√°n frenando, pero los rangos est√°n en modo de depuraci√≥n: esta es la esencia de toda la discusi√≥n.  En el modo de lanzamiento, funcionan bien. </p><br><p>  <strong>Ivan:</strong> Esto es normal. </p><br><p>  <strong>Sergey:</strong> No todos est√°n de acuerdo con esto :-) </p><br><p>  <strong>Ivan:</strong> S√≠, lo s√© en la pr√°ctica.  En una compa√±√≠a, en su biblioteca m√°s utilizada ... No dir√© qu√© tipo de compa√±√≠a y biblioteca es ... hay algoritmos que son asint√≥ticamente significativamente m√°s lentos en modo de depuraci√≥n.  ¬øY qui√©n se quejar√° ahora de que los rangos est√°n haciendo lo mismo? </p><br><p>  <strong>Sergey:</strong> En el art√≠culo que estamos discutiendo, el punto no estaba en los rivales en s√≠ mismos, eran solo un ejemplo para el autor, que estaba furioso porque esta situaci√≥n se estaba convirtiendo en una tendencia y baja productividad en modo de depuraci√≥n.  En su √°rea tem√°tica, motores de juego, esto es simplemente inaceptable. </p><br><p>  <strong>Alexander: A</strong> estas personas no les gusta STL en absoluto, porque funciona m√°s lento de lo que necesitan.  Los rangos solo expanden la biblioteca en la misma direcci√≥n, y para ellos parece otra caracter√≠stica in√∫til que no pueden usar. </p><br><p>  <strong>Sergey: Los que</strong> odian odiar√°n. </p><br><p>  <strong>Ivan:</strong> Exactamente.  Por ejemplo, todos usan la clasificaci√≥n.  Solo imagine que no hay m√°s ordenaci√≥n en la biblioteca est√°ndar.  ¬øC√≥mo lo implementar√≠a? </p><br><p>  <strong>Sergey:</strong> Normalmente hago una pregunta as√≠ en una entrevista :-) Esta es una pregunta muy com√∫n. </p><br><p>  <strong>Ivan:</strong> S√≠, una pregunta frecuente es c√≥mo implementar la clasificaci√≥n.  Y luego habla sobre alguna versi√≥n b√°sica de clasificaci√≥n r√°pida, que en realidad no se usa en ning√∫n otro lugar del mundo, porque puede ser muy lenta en ciertos casos.  La biblioteca est√°ndar no permite su uso, ya que requiere un N log N garantizado, y la ordenaci√≥n r√°pida no puede.  En su mayor parte, puede, pero el est√°ndar en este lugar es muy estricto y no significa N log N acumulado, deber√≠a ser N log N puro, y ¬øc√≥mo implementar√° tal algoritmo?  Debe investigar, encontrar muchas optimizaciones diferentes para una ordenaci√≥n r√°pida y fusionarlas en un algoritmo, que consta de al menos tres algoritmos diferentes, como se hace en libstdc ++.  Este es el significado de las bibliotecas est√°ndar: no necesita saber todas estas cosas para programar.  No es necesario descubrir c√≥mo implementar todo de la manera m√°s eficiente, alguien m√°s ya se ha encargado de esto por usted.  Por lo tanto, no me gusta este enfoque cuando la gente dice: "STL es muy complicado, no lo usemos y escribamos todo desde cero manualmente". </p><br><p>  <strong>Sergey:</strong> Nos acercamos al final de la entrevista, as√≠ que la √∫ltima pregunta: ¬øc√≥mo te gusta en Rusia? </p><br><p>  <strong>Alexander: Se</strong> puso m√°s fr√≠o. </p><br><p>  <strong>Sergey: ¬ø</strong> Incluso para ti?  Eres local! </p><br><p>  <strong>Ivan:</strong> Pero para m√≠ hace mucho m√°s calor aqu√≠ de lo esperado. </p><br><p>  <strong>Sergey:</strong> Ahora es -16, y te dijimos que ser√° -40. </p><br><p>  <strong>Ivan: ¬°</strong> S√≠, lo prometiste!  Me prepar√© especialmente para menos cuarenta.  Y luego miro el term√≥metro, y all√≠ todo est√° m√°s y m√°s c√°lido. </p><br><p>  <strong>Sergey:</strong> Bueno, ahora solo nos encontraremos en C ++ Rusia 2019, ser√° en Mosc√∫ y habr√° una temperatura positiva.  Gracias por la entrevista y hasta pronto! </p><br><blockquote>  Minuto de publicidad.  Del 19 al 20 de abril, se llevar√° a cabo una conferencia de C ++ Rusia, en la que Ivan har√° una presentaci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Dise√±o de C ++ solo para movimiento"</a> , y Alexander hablar√° sobre analizadores mon√°dicos.  Adem√°s, Ivan realizar√° una de las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tres capacitaciones m√°s importantes</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Programaci√≥n funcional aplicada en C ++"</a> .  Queda un mes antes de la conferencia y el programa contin√∫a siendo refinado.  En el sitio web oficial puede ver qu√© informes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ya han ingresado al programa</a> y comprar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">boletos</a> .  Tenga en cuenta que hay diferentes tipos de boletos, y elegir el correcto puede ahorrar mucho. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/444212/">https://habr.com/ru/post/444212/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../444198/index.html">Dropbox limita la sincronizaci√≥n: ahora solo 3 dispositivos</a></li>
<li><a href="../444200/index.html">Sesi√≥n de resoluci√≥n de problemas</a></li>
<li><a href="../444204/index.html">Introducci√≥n de pruebas en Python. Parte 3</a></li>
<li><a href="../444206/index.html">27 de marzo, Mosc√∫ - JavaScript MeetUP</a></li>
<li><a href="../444208/index.html">¬øPor qu√© las empresas necesitan un buen c√≥digo?</a></li>
<li><a href="../444214/index.html">C√≥mo Kiwi.com prueba 1000 proyectos de Python</a></li>
<li><a href="../444216/index.html">Moscow Python Conf ++ en tres d√≠as: ¬øde qu√© hablar√° Bobuk y qui√©n actuar√° en salas paralelas en este momento?</a></li>
<li><a href="../444220/index.html">C√≥mo prueba Kiwi 1000 proyectos de Python</a></li>
<li><a href="../444222/index.html">Alrededor de los enemigos. C√≥mo planificar tu trabajo paranoico</a></li>
<li><a href="../444226/index.html">@Pythonetc compilaci√≥n febrero 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>