<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíµ üññüèø üëêüèæ Almacenamiento a largo plazo de m√©tricas Prometheus (Alexey Palazhchenko, Percona) ü§±üèΩ üë®üèª‚Äç‚úàÔ∏è üë©‚Äç‚ù§Ô∏è‚Äçüë©</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En poco tiempo, Prometheus se ha convertido en una de las herramientas de monitoreo m√°s populares. Gracias, en particular, y la alta velocidad de su t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Almacenamiento a largo plazo de m√©tricas Prometheus (Alexey Palazhchenko, Percona)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441136/"><p>  En poco tiempo, Prometheus se ha convertido en una de las herramientas de monitoreo m√°s populares.  Gracias, en particular, y la alta velocidad de su trabajo.  Su almacenamiento local es ideal para el almacenamiento a corto plazo de m√©tricas y para trabajar con ellas.  A veces, desea mantener las m√©tricas distribuidas durante meses y a√±os, cortando autom√°ticamente los datos antiguos, pero sin cambiar la interfaz para trabajar con ellos. </p><br><p>  Justo sobre esto, la decodificaci√≥n del informe de Alexey Palazhchenko en RootConf 2018. En el informe: Prometheus, Local Storage TSDB, Remote Storage Prometheus, PromQL, TSDB, Clickhouse, PromHouse, un poco InfluxDB. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/LXllYmb0RTk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  A qui√©n le importa, por favor, debajo del gato. </p><a name="habracut"></a><br><p>  Amigos!  Hola a todos!  Me llamo Alexey Palazhchenko.  Yo trabajo en Percona.  Me gustar√≠a informarle sobre el almacenamiento a largo plazo de m√©tricas en Prometheus. </p><br><p><img src="https://habrastorage.org/webt/rw/vv/4v/rwvv4v4zpjhn5tlmrclgeii9mkq.png"></p><br><p>  Trabajo en Percona y hago un producto llamado monitoreo y gesti√≥n de percona.  Esta es la soluci√≥n en caja que nuestros clientes se propusieron.  PMM es completamente de c√≥digo abierto.  Consiste en Prometheus, Grafana para gr√°ficos, software de an√°lisis de consultas personalizado y nuestro propio contenedor que le permite administrar algo.  Por ejemplo, puede agregar un objetivo de raspado a Prometheus.  Estas son nuevas fuentes de donde tomar√° m√©tricas sin tener que ingresar manualmente un contenedor o m√°quina virtual y editar el archivo de configuraci√≥n. </p><br><p>  Es importante entender que estos no son SaaS.  No tenemos producci√≥n.  Nuestra producci√≥n se ubica con nuestros clientes.  Experimentar con eso no es muy bueno.  Tenemos lo m√°s cercano que podr√≠a llamarse producci√≥n: esto es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://pmmdemo.percona.com/</a> .  En el momento del informe, pmmdemo.percona.com tuvo que cerrarse debido a GDPR. </p><br><p>  Entregamos PMM a los clientes: una soluci√≥n en caja: un contenedor acoplable o una m√°quina virtual.  A todos les gusta Prometeo.  Algunas personas que miran a Prometheus por primera vez se encuentran con un modelo pull.  Para principiantes, esto es inconveniente.  Generalmente una gran conversaci√≥n separada.  Puede discutir sobre los m√©todos de extracci√≥n o inserci√≥n.  En promedio, esto es casi lo mismo. </p><br><p>  Algunas cosas en Prometeo son muy geniales. </p><br><ul><li><p>  El lenguaje de consulta de Prometheus es realmente una cosa genial que no tiene an√°logo en ning√∫n lado. </p><br></li><li><p>  Lo segundo que te gusta es el descubrimiento de servicios.  Si tiene alg√∫n tipo de infraestructura din√°mica, kubernetes, autom√°ticamente no necesita agregar todos los objetivos para monitorear con sus manos.  Si es est√°tico, esto tambi√©n se puede hacer de manera bastante simple.  Necesita usar el archivo de configuraci√≥n. </p><br></li></ul><br><p>  A los clientes de Prometheus les gusta.  Quieren mantener las m√©tricas cada vez m√°s.  Alguien usa Prometheus solo para monitoreo operativo.  Pero alguien quiere mantener las m√©tricas por m√°s tiempo, observar la din√°mica, comparar con los gr√°ficos de hace un a√±o.  Sin embargo, el objetivo del almacenamiento a largo plazo de las m√©tricas no es el objetivo del proyecto Prometheus.  Inicialmente, se cre√≥ para almacenar m√©tricas por un corto tiempo.  SoundCloud almacena m√©tricas en solo unos d√≠as.  Hay mecanismos en Prometeo que le permiten hacer esto por m√°s tiempo, pero est√°n dispuestos un poco al costado.  Por lo tanto, podemos tomar una decisi√≥n para el ecosistema Prometheus sin cambiar el n√∫cleo del sistema en s√≠.  Con base en ellos, podemos tomar nuestra propia decisi√≥n dentro del mismo ecosistema. </p><br><p><img src="https://habrastorage.org/webt/ws/1n/7k/ws1n7kpa7ohpkxwpxuli5dcpwuc.png"></p><br><p>  Este no es un informe sobre soluciones preparadas.  Este es un informe sobre nuestra experiencia, sobre nuestro dolor, sobre nuestros intentos.  Si esperaba que despu√©s de este informe descargue el repositorio o el contenedor acoplable, lo ejecute y funcionar√°, entonces no es as√≠.  Pero al mismo tiempo est√° lo suficientemente cerca de serlo.  Tenemos algunas bases.  Todos son de c√≥digo abierto.  Puedes intentarlo.  Todav√≠a no est√°n listos para la producci√≥n.  Pero con la informaci√≥n que se encuentra en este informe, puede comprender por qu√©, entonces, ¬øqu√© se puede hacer mejor?  Puede tomar su propia decisi√≥n que m√°s le convenga. </p><br><p><img src="https://habrastorage.org/webt/ej/4j/sm/ej4jsmldkwk-bsme40kqehzilqc.png"></p><br><p>  ¬øC√≥mo se almacenan las m√©tricas en Prometheus?  Hay almacenamiento local.  Hay almacenamiento remoto.  Estos son en realidad dos mundos diferentes.  Se cruzan d√©bilmente.  Por lo tanto, el informe tambi√©n se divide en 2 partes. </p><br><p><img src="https://habrastorage.org/webt/jm/ic/81/jmic81mrsu49j-zxv6spn9aopac.png"></p><br><p>  Si estuvo en un informe anterior en la sala principal, donde hubo una buena introducci√≥n en Prometheus, sabr√° que el almacenamiento local es una biblioteca separada llamada TSDB.  TSDB no tiene nada que ver con OpenTSDB.  TSDB es un paquete Go separado que puede usar desde su programa Go.  En el nivel de biblioteca TSDB, no hay cliente o servidor. </p><br><p>  Esta biblioteca est√° optimizada para trabajar con datos de series temporales.  Por ejemplo, TSDB tiene codificaci√≥n delta, que le permite almacenar no los n√∫meros en s√≠, sino los cambios entre estos n√∫meros.  Esto le permite almacenar 1 byte en lugar de 16 bytes.  1 byte por tiempo y 1 byte por valor.  Es decir, almacena en promedio 1 o 2 bytes precisamente debido a esta buena compresi√≥n. </p><br><p>  TSDB est√° optimizado para modelos pull.  Los datos solo se agregan all√≠.  Prometeo no puede escribir datos hist√≥ricos.  No hay API para esto.  El delta m√°ximo es de aproximadamente 5 minutos.  Si los datos son m√°s antiguos, no ser√°n aceptados. </p><br><p>  No hay una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">toma de muestras incorporada tsdb # 313</a> en TSDB.  Hay un tema abierto en el que hubo una discusi√≥n sobre el hecho de que, en general, hay proyectos que hacen algo a Prometheus y hay una disminuci√≥n de muestreo all√≠.  Hasta ahora, la soluci√≥n es que TSDB no agregar√° disminuci√≥n de muestreo. </p><br><p><img src="https://habrastorage.org/webt/5q/pb/vt/5qpbvtptau3gz7ygcxb9cl3nmzg.png"></p><br><p>  ¬øC√≥mo obtendr√≠amos datos de TSDB?  TSDB es una base de datos en disco.  Puede trabajar con √©l si est√° escribiendo un programa Go.  Pero si no escribe un programa en Go, entonces hay una API JSON que le permite realizar consultas de consulta.  Si alguna vez ha utilizado Prometheus y al menos una vez ha creado un gr√°fico, conoce la API de consulta est√°ndar, en la que hay un par√°metro de consulta en el que puede ejecutar cualquier consulta de PromQL y, opcionalmente, el tiempo.  Si no hay tiempo, se toma el tiempo actual. </p><br><p>  Se resalta una consulta espec√≠fica en la diapositiva, que rara vez se ve en la vida real.  Este es un truco.  Esto nos permite extraer todas las m√©tricas que tiene Prometheus.  Como funciona  A nivel de PromQL se dice que es imposible escribir una expresi√≥n que atrape todo el tiempo los n√∫meros de serie.  Esto est√° escrito directamente en las reglas.  Otra regla dice que no puede hacer una coincidencia en la que todos los valores est√©n vac√≠os.  Si simplemente escribe llaves, esto no funcionar√°.  Si escribe el nombre no es igual a nada (no es un valor vac√≠o), entonces no funcionar√°.  Pero este es un truco real que te permite hacer esto.  Sin embargo, ni siquiera est√° particularmente documentado.  Hay comentarios en el c√≥digo mismo de que esto funciona. </p><br><p>  La segunda consulta es query_range, que hace lo mismo, pero le devuelve datos en un rango y con alg√∫n paso.  B√°sicamente, realiza una consulta varias veces para cada paso desde el principio hasta el final.  Esta es la API utilizada para dibujar gr√°ficos.  La primera API se usa para obtener valores instant√°neos. </p><br><p><img src="https://habrastorage.org/webt/nc/cm/cs/nccmcsyofzxubtca8yoyas7p6ag.png"></p><br><p>  Tenemos una API para recuperar metadatos.  Si queremos obtener todos los nombres de las m√©tricas, hacemos una consulta como esta, donde match es una matriz de m√©tricas.  Puede haber varios argumentos, pero en este caso pasamos la misma coincidencia, que todo nos devuelve. </p><br><p>  La segunda meta API, que nos devuelve el valor de todas las etiquetas.  Si queremos ver una lista de todos los trabajos, en lugar de label_name escribimos el trabajo y obtenemos esta lista.  Estas API nos devuelven JSON. </p><br><p><img src="https://habrastorage.org/webt/qe/ku/j4/qekuj4lgm4zp-x07kvhoorux_w0.png"></p><br><p>  Hay otra API que devuelve todas las m√©tricas de Prometheus en un formato nativo de los exportadores.  El formato se llama expfmt.  En Prometheus, existe una API de federaci√≥n que le permite realizar dicha solicitud.  ¬øPara qu√© es esto?  La opci√≥n m√°s f√°cil, si tiene alg√∫n c√≥digo que ya funciona con expfmt, entonces no necesita volver a entrenarlo para que funcione con alguna API JSON personalizada.  Este formato es mucho m√°s f√°cil de transmitir, porque si tiene JSON en alg√∫n lugar en el nivel superior del objeto, la mayor√≠a de las veces necesita analizar este objeto como un todo.  Aqu√≠ se puede hacer l√≠nea por l√≠nea. </p><br><p>  Lo m√°s importante es que es una API separada.  Funciona igual que una exportaci√≥n real.  Puedes tomar el otro Prometeo para rasparlo.  Este es un trabajo regular con los par√°metros habituales.  Debe pasar el par√°metro: consulta url.  Si realiza una solicitud de rizo, obtendr√° lo mismo aqu√≠.  Obtenemos todas las m√©tricas para el valor de tiempo actual.  La √∫nica advertencia: debe establecer etiquetas de honor para que Prometheus, que eliminar√° otro Prometheus a trav√©s de esta API, no borre el valor del trabajo y la etiqueta de instancia.  Con esta API de federaci√≥n, puede cargar todos los datos de un Prometheus a otro. </p><br><p><img src="https://habrastorage.org/webt/64/lc/yy/64lcyynloe47gbkjlelzyddss60.png"></p><br><p>  ¬øC√≥mo se puede usar esto? </p><br><p>  Primero, lo m√°s importante que debes decir es que no necesitas hacer esto.  TSDB est√° optimizado para diferentes modos de funcionamiento.  Si tiene un Prometheus que raspa muchos datos, entonces hace muchas E / S.  Si usa la API de federaci√≥n, la cantidad de entrada y salida aumentar√° aproximadamente 2 veces.  Hay matices  Dependiendo de con qu√© frecuencia raspe en federar y con qu√© frecuencia raspe los objetivos.  Si no se ha cambiado el tiempo, esto realmente duplica la carga.  Por lo tanto, si desea escalar su Prometheus y habilitar la federaci√≥n, lo matar√°.  La carga se duplicar√°. </p><br><p>  Segundo momento  Saltar√° datos.  Obtendr√° un conflicto de datos.  Por qu√©  Esta API, como casi cualquier API en Prometheus, no es at√≥mica.  Si llegan nuevos datos, un nuevo scraping finalizar√° en el momento en que su solicitud de federaci√≥n a√∫n est√© en curso, puede obtener uno para una serie de tiempo y nuevos datos para otra.  Si se trata de una serie temporal no relacionada, generalmente no da miedo.  Pero si tiene un resumen o un histograma, que en el nivel de representaci√≥n est√° representado por varias m√©tricas b√°sicas, entonces habr√° inconsistencia entre ellas. </p><br><p><img src="https://habrastorage.org/webt/_0/5h/lk/_05hlkpn57b8klhjwborhup4bds.png"></p><br><p>  ¬øC√≥mo podemos resolver este problema at√≥mico?  Prometheus tiene reglas de grabaci√≥n que le permiten crear una nueva serie de tiempo a partir de una serie de tiempo existente.  Esto se puede hacer con menos frecuencia.  Esta es una forma de reducir el muestreo.  Por ejemplo, deseche el objetivo cada segundo, pero luego queremos hacer la agregaci√≥n node_cpu en un minuto.  Agrupar en Prometheus 2.0 le permite hacer estas agregaciones secuencialmente.  Las reglas que est√°n en el mismo grupo se ejecutan estrictamente secuencialmente.  En este punto, no hay problema de atomicidad, no hay problema de que los datos cambien en el proceso.  Pero esto no resuelve el problema del hecho de que es admisible alg√∫n otro dato que est√© l√≥gicamente conectado con esto, pero que no est√° conectado desde el punto de vista del modelo de datos.  No hay atomicidad pura todav√≠a.  Hay un problema abierto sobre este tema.  Puedes hacer instant√°neas.  Puede realizar una consulta de PromQL a la base de datos TSDB y descartar todas las muestras que sean inferiores a alg√∫n valor del tiempo que comenz√≥ en la evaluaci√≥n a partir de los valores obtenidos.  Esta ser√≠a la forma m√°s f√°cil, pero hasta ahora no se ha hecho. </p><br><p>  Es importante comprender que las reglas de registro deben realizarse en el Prometheus inferior y no en el que hace la federaci√≥n.  De lo contrario, omitir√° los picos, su monitoreo no funcionar√° correctamente. </p><br><p><img src="https://habrastorage.org/webt/kp/jf/hd/kpjfhdz8boamndunerhcx2vgebq.png"></p><br><p>  ¬øC√≥mo podemos usar esta combinaci√≥n de estas cosas para hacer un muestreo y almacenamiento a largo plazo? </p><br><p>  El primero  Acabamos de configurar la federaci√≥n y descargamos todos los datos de ese Prometheus.  Esta extra√±a expresi√≥n regular es como un zoidberg: en realidad es solo un colon.  Un asterisco a la izquierda y derecha del colon.  Usamos el nombre est√°ndar para las reglas de grabaci√≥n, que agrega dos puntos al medio.  Al dividir el nombre original, habr√° un nivel de agregaci√≥n a la izquierda y una funci√≥n a la derecha.  Una m√©trica normal de colon no.  Si hay dos puntos, entonces esta es una se√±al de que esto es agregaci√≥n.  Despu√©s de eso, usamos este nombre de m√©trica en nuestro gr√°fico.  Si queremos que nuestro horario, nuestro tablero en grafana trabaje con el Prometeo principal, y con aquellos que son m√°s altos, podemos usar la expresi√≥n <strong>o</strong> .  Tomamos una m√©trica u otra, dependiendo de cu√°l sea.  Podemos hacer trampa y usar el reetiquetado para cambiar el nombre de la nueva m√©trica al antiguo nombre.  Este es un enfoque bastante peligroso.  Puede deletrear archivos adjuntos regulares incorrectamente y tendr√° un conflicto de series de tiempo.  Prometeo escribir√° muchas advertencias en el registro.  Ver√° esto, pero encontrar la raz√≥n puede ser bastante dif√≠cil.  Pero si se hace con cuidado, por ejemplo, generando estas expresiones regulares mediante programaci√≥n, esto funcionar√°.  A continuaci√≥n, tendr√° un panel de control normal donde solo se utiliza node_cpu.  Dependiendo de qu√© Prometheus se use, recibir√° datos sin procesar o datos agregados. </p><br><p><img src="https://habrastorage.org/webt/hd/ft/1x/hdft1xwgw_61j7tab_3feehhsgy.png"></p><br><p>  Como dije, las reglas de grabaci√≥n se pueden generar de manera bastante simple.  Acabamos de obtener todas las series de tiempo a trav√©s de la API que ya mostr√©.  Creamos reglas y estas reglas deben usar las funciones y operadores correctos.  No es necesario usar la tasa con el medidor all√≠.  Esto no funcionar√° correctamente.  Debe usarse solo con conteo.  En el nivel donde trabaja, es posible que no tenga informaci√≥n sobre los tipos de datos.  Por ejemplo, si usa expfmt.  Hay informaci√≥n sobre los tipos.  Si la API JSON no est√° all√≠.  Como resultado, la expresi√≥n que genera autom√°ticamente puede no tener ning√∫n significado f√≠sico.  Por lo tanto, puede usar una lista blanca o una lista negra all√≠.  Dependiendo de esto, genere la regla que necesita o deseche las reglas que no tienen sentido.  Hay una herramienta de promtool que le permite verificar que las reglas que gener√≥, la configuraci√≥n que gener√≥, tiene sentido.  Tiene la sintaxis correcta. </p><br><p><img src="https://habrastorage.org/webt/om/wc/fv/omwcfvvh7mc8bky3zkble7vimqm.png"></p><br><p>  Si tenemos Grafana y hay varios Prometeo, necesitamos saber a qu√© Prometeo enviar la solicitud.  ¬øC√≥mo har√≠amos esto? </p><br><p>  Una forma es poner un proxy especial que mirar√° la hora en la solicitud, y dependiendo de esto, seleccione Prometheus.  Las consultas tienen una hora de inicio y una hora de finalizaci√≥n.  Dependiendo de esto, puedes hacer rutas con tus manos.  Se podr√≠a escribir alg√∫n tipo de programa que haga esto.  En la pr√°ctica, esto lo hace nginx con el m√≥dulo lua o un peque√±o programa. </p><br><p><img src="https://habrastorage.org/webt/ff/ve/vz/ffvevzimxzpnrjrqirbkuqssiqm.png"></p><br><p>  ¬øRealmente necesitamos una API?  ¬øPodemos trabajar con TSDB directamente?  Hay un matiz.  En primer lugar, si tratamos de usar TSDB, que Prometheus usa ahora, no podremos hacerlo.  Hay un archivo de bloqueo especial que evita esto.  Si escribimos c√≥digo que ignorar√° esto y tratamos de leer o escribir datos, tenemos la garant√≠a de da√±arlos.  Por otra parte, incluso la lectura.  Que se puede hacer  Podemos leer datos a trav√©s de la API y crear TSDB lado a lado.  Luego detenga Prometheus y reempl√°celo con TSDB.  Pero al mismo tiempo, podemos reducir el rendimiento si leemos todos los datos a trav√©s de la API.  Hablar√© de esto un poco m√°s tarde. </p><br><p>  La segunda opci√≥n.  Puede copiar (hacer una copia de seguridad) estos archivos, es decir, copiarlos tal cual.  S√≠, ser√°n da√±ados.  Cuando abra, recibir√° una advertencia de que los datos est√°n da√±ados.  Necesitan ser reparados.  Puede perder nuevos datos.  Pero no nos importa.  Queremos reducir el muestreo de datos antiguos.  La disminuci√≥n de resoluci√≥n se puede hacer usando PromQL.  Pero hay un matiz.  Es mucho m√°s dif√≠cil arrancarlo de Prometheus que TSDB.  Si est√° un poco familiarizado con Go y la gesti√≥n de dependencias, el proveedor PromQL es un gran problema.  No te aconsejar√≠a  Evita esto si es posible. </p><br><p><img src="https://habrastorage.org/webt/2z/ii/fs/2ziifscme6pqm1ppf1n9ripipuq.png"></p><br><p>  Pasamos a Almacenamiento Remoto.  ¬øAlguien ha trabajado con Almacenamiento remoto en Prometheus?  Unas pocas manos.  Almacenamiento remoto es una API que existe desde hace mucho tiempo.  Ahora en la versi√≥n 2.2 Almacenamiento remoto: marcado como experimental.  Adem√°s, se sabe que la API de almacenamiento remoto definitivamente cambiar√°. </p><br><p>  Almacenamiento remoto le permite trabajar solo con datos sin procesar.  No hay PromQL en la entrada o salida.  Cuando lees, no puedes usar toda la potencia de PromQL.  B√°sicamente, bombea todos los datos del Almacenamiento remoto que coinciden con la condici√≥n.  Adem√°s, PromQL ya funciona con ellos.  Esto tiene una sobrecarga bastante grande.  Necesita bombear muchos datos a trav√©s de la red.  Por lo tanto, en Prometheus 2.3, que a√∫n no se ha lanzado, pero ya se ha retrasado, se leer√° una pista.  Hablaremos de esto un poco m√°s tarde. </p><br><p>  Todav√≠a no hay API para metadatos.  No puede crear una API que devuelva todas las series temporales del Almacenamiento remoto.  Si realiza una solicitud a la API de Prometheus, no ir√° a Almacenamiento remoto.  Le devolver√° la serie de tiempo, que se encuentra en su base de datos local.  Si su base de datos local est√° deshabilitada, le devolver√° 0. Lo que puede ser un poco inesperado.  Ahora esta API usa ProtoBuf y definitivamente se cambiar√° a gRPC en el futuro.  Todav√≠a no lo han hecho, porque gRPC requiere HTTP2.  Y en la pr√°ctica tuvieron problemas con √©l. </p><br><p><img src="https://habrastorage.org/webt/lc/7v/ij/lc7vijvha-gtzs_oj74xszwk488.png"></p><br><p> La API de escritura se ve as√≠.  La solicitud tiene un conjunto de etiquetas.  El conjunto de etiquetas identifica de forma exclusiva las series temporales.  <code>__name__</code> es realmente solo una etiqueta con un nombre especial.  Y las muestras son un conjunto de tiempo y valores: int64 y float64.  Al grabar, el pedido no es importante.  Se supone que la base de datos que escribe esto en s√≠ misma har√° todo bien.  Prometheus puede hacer una optimizaci√≥n y no volver a ordenarla.  En consecuencia, una solicitud de escritura es solo una serie de tiempo. </p><br><p><img src="https://habrastorage.org/webt/xd/qr/ud/xdqrudjh5lpomcepkdmkjcfegt0.png"></p><br><p>  La configuraci√≥n de escritura tiene una configuraci√≥n bastante flexible.  Hay muchas opciones para configurar la concurrencia de escritura.  Lo que Prometeo llama fragmentos son esencialmente solicitudes competitivas.  Puede limitar el n√∫mero m√°ximo de muestras en una solicitud, el n√∫mero m√°ximo de solicitudes paralelas, el tiempo de espera, c√≥mo repetir, qu√© retroceso.  Para muchas bases de datos, 100 muestras a la vez, esto puede ser muy peque√±o.  Si usa ClickHouse, como lo hacemos nosotros, entonces, por supuesto, el valor debe aumentar considerablemente.  De lo contrario, ser√° muy ineficiente. </p><br><p><img src="https://habrastorage.org/webt/eb/gk/ew/ebgkewr7k-i2yho9mh7dbogcipm.png"></p><br><p>  La API de lectura remota se ve as√≠.  Es solo un rango de tiempo de principio a fin y un conjunto de partidos. </p><br><p><img src="https://habrastorage.org/webt/hv/kn/jo/hvknjowgf6h9pebjvvhbspe7jac.png"></p><br><p>  La coincidencia es esencialmente una colecci√≥n de pares de nombre y valor, una etiqueta regular y un tipo de condici√≥n.  En comparaci√≥n, hay igualdades, desigualdades o expresiones regulares.  Este es el selector habitual de series de tiempo que ve en PromQL.  No hay caracter√≠sticas aqu√≠. </p><br><p><img src="https://habrastorage.org/webt/ri/hu/ap/rihuap_py_s_hrp0oywqnyx6yee.png"></p><br><p>  La respuesta son algunas series de tiempo que coinciden con esta consulta.  Aqu√≠ las muestras deben clasificarse por tiempo.  Una vez m√°s, esto ayuda a Prometeo a ahorrar un poco de CPU, sin necesidad de ordenar.  Pero se supone que su base de datos deber√≠a hacer esto.  En la mayor√≠a de los casos, ser√° as√≠ porque, muy probablemente, habr√° un √≠ndice a tiempo. </p><br><p><img src="https://habrastorage.org/webt/zu/yd/fx/zuydfxti6mozpsz5v60f_i1laic.png"></p><br><p>  Prometheus 2.3 introdujo una pista de lectura.  Que es esto  Esta es una oportunidad para decirle a Prometheus qu√© funci√≥n interna que funciona con la serie de tiempo que se solicita se aplicar√°.  Esto puede ser una funci√≥n o un operador de agregaci√≥n.  Puede ser tasa.  Es decir, se llama func, pero de hecho puede ser una suma, que desde el punto de vista de PromQL en realidad no es una funci√≥n en absoluto.  Este es el operador.  Y un paso  En el ejemplo anterior, hubo una tasa de 1 minuto.  Aqu√≠ la tasa es una funci√≥n y un minuto en milisegundos como un paso.  Esta sugerencia puede ser ignorada por la base de datos remota.  Al mismo tiempo, no hay ninguna indicaci√≥n en la respuesta sobre si se ignor√≥ o no. </p><br><p><img src="https://habrastorage.org/webt/6_/ms/9_/6_ms9_zh9txqwdafxjoenbdn8so.png"></p><br><p>  ¬øCu√°l es la configuraci√≥n de lectura? </p><br><p>  En primer lugar, existe dicha configuraci√≥n required_matchers.  Esto le permite enviar una solicitud de Almacenamiento remoto que coincida con la expresi√≥n.  Para leer datos agregados del almacenamiento remoto, debe usar una consulta que contenga dos puntos. </p><br><p>  Hay una opci√≥n que le permite leer o no leer datos recientes del Almacenamiento remoto, que se encuentra en TSDB.  Por lo general, en la configuraci√≥n est√°ndar hay una peque√±a TSDB local que se escribe en el disco local.  Ella almacena all√≠ durante varias horas o varios d√≠as.  Los datos que usa ahora, que se usan para alertas, que se usan para construir el tablero, se leen solo desde la TSDB local.  Es r√°pido, pero no nos permite almacenar muchos datos. </p><br><p>  Los datos hist√≥ricos antiguos se leer√°n desde el almacenamiento remoto.  Esto deja en claro c√≥mo el almacenamiento local y el almacenamiento remoto se comunican entre s√≠.  No hay deduplicaci√≥n. </p><br><p>  Esencialmente lo que est√° pasando.  Los datos se toman del almacenamiento local, los datos se toman del almacenamiento remoto si read_recent est√° habilitado.  Simplemente se fusionan.  Parece que esto no es un problema.  Si se supone que no hemos disminuido la muestra de datos recientes, estos son exactamente los mismos datos, coinciden completamente con los datos locales, tendremos el doble de muestras, no deber√≠amos afectar ninguna funci√≥n.  En realidad no  Hay una funci√≥n irate () y un par para el indicador, que nos devuelve la diferencia entre los dos √∫ltimos valores.  Ella mira hacia atr√°s en el rango de tiempo indicado, pero solo usa los dos √∫ltimos valores.  Si tenemos los dos √∫ltimos valores tienen el mismo tiempo, entonces la diferencia ser√° cero.  Esto es un error y es casi imposible encontrarlo.  Fue reparado hace solo cuatro d√≠as.  Este es un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">boleto para</a> cualquier persona interesada. </p><br><p><img src="https://habrastorage.org/webt/-q/3w/dw/-q3wdw3czygpvkk009lrnhumska.png"></p><br><p>  Curiosamente, Prometheus ha implementado la lectura remota desde la versi√≥n 1.8.  Esta es la forma que le permite leer los datos del antiguo Prometheus cuando migra a la versi√≥n 2.x.  La forma oficial aconseja conectarlo como lectura remota.  Los datos se restar√°n seg√∫n sea necesario. </p><br><p>  La lectura remota se puede utilizar para enrutar consultas sin un proxy.  En una de las diapositivas anteriores, mostr√© que, dependiendo del tiempo, podemos hacer rutas en un Prometheus u otro.  Del mismo modo, podemos evitar esto.  Simplemente conecte el Prometheus a continuaci√≥n, que es de lectura remota, y los datos se leer√°n desde all√≠.  Pero hay una enmienda al hecho de que, por supuesto, se bombear√°n muchos datos.  Especialmente si no est√° utilizando la sugerencia de consulta. </p><br><p><img src="https://habrastorage.org/webt/gq/op/fz/gqopfzpgoe3kidpqufnedn5gfrk.png"></p><br><p>  ¬øPor qu√© clickhouse? </p><br><ul><li><p>  Para nuestra soluci√≥n de investigaci√≥n, elegimos ClickHouse, porque lo hemos estado buscando durante mucho tiempo.  Tenemos personas que se dedican constantemente al rendimiento de la base de datos, revisando constantemente nuevas bases de datos.  Nuestra empresa se dedica a bases de datos de c√≥digo abierto. </p><br></li><li><p>  Realmente nos gusta su rendimiento en bruto.  Su potencia en t√©rminos de CPU, tiempo, etc. es muy buena.  La mayor√≠a de estos sistemas hablan de escalabilidad infinita, pero hablan poco sobre la eficiencia para un solo servidor.  Muchos de nuestros clientes almacenan m√©tricas en un par de servidores. </p><br></li><li><p>  Replicaci√≥n incorporada, fragmentaci√≥n. </p><br></li><li><p>  GraphiteMergeTree es un motor especial para almacenar datos de grafito.  Al principio estaba muy interesado en nosotros. </p><br></li></ul><br><p><img src="https://habrastorage.org/webt/ot/nk/sn/otnksno5uhhcgn7j5-fp5xnxneq.png"></p><br><p>  El motor est√° dise√±ado para el rollup (adelgazamiento y agregaci√≥n / promedio) de datos de grafito. </p><br><p>  Graphite almacena los datos completos en ClickHouse, y puede recibirlos, y dice adem√°s que con el adelgazamiento GraphiteMergeTree se usa, MergeTree se usa sin adelgazamiento.  La sensaci√≥n es que los datos siempre est√°n llenos, no se sobrescriben, es solo una optimizaci√≥n de la lectura.  Pero en general no est√° mal.  Cuando hacemos la lectura, no bombeamos los datos, se agregan autom√°ticamente, obtenemos un poco de datos, esto es bueno.  La desventaja para nosotros es que todos los datos se almacenan. </p><br><p>  Me estaba preparando a principios de mes para el informe.  Alguien entra en un chat de telegramas y pregunta: "¬øMuestra de datos de GraphiteMergeTree"?  Ya escribo no.  La documentaci√≥n dice que no.  Pero la otra persona en el chat responde "s√≠, debe llamar a optimizar".  Corre, comprueba, s√≠, la verdad.  La documentaci√≥n es esencialmente un error.  Luego le√≠ el c√≥digo fuente, comprob√©, resulta que hay optimizar, optimizar final.  Optimizar final se cre√≥ originalmente espec√≠ficamente para GraphiteMergeTree.  En realidad, la toma de muestras lo hace.  Pero debe ser llamado con sus manos. </p><br><p>  GraphiteMergeTree tiene un modelo de datos diferente.  No tiene etiquetas.  Efectivamente escribirlo todo en nombre de las m√©tricas no funciona muy bien. </p><br><p>  Las m√©tricas de nombres se almacenan en una tabla.  El nombre de las m√©tricas tiene una longitud diferente.  Esto lleva al hecho de que si hacemos una b√∫squeda de √≠ndice por el nombre de la m√©trica, porque la longitud es diferente, este √≠ndice no ser√° tan efectivo como si este √≠ndice tuviera un valor de longitud fijo.  Porque necesitas hacer una b√∫squeda de archivos.  Es imposible especificar exactamente d√≥nde aterrizar para hacer una b√∫squeda binaria. </p><br><p><img src="https://habrastorage.org/webt/c3/v4/zf/c3v4zfriducmhoahjwujmp1zdga.png"></p><br><p>  Por lo tanto, hicieron su propio esquema.  La diapositiva muestra c√≥mo almacenamos series temporales en la base de datos.  La fecha que ClickHouse necesita es una huella digital.  Si observa las fuentes de Prometheus o TSDB, entonces sabe que la huella digital es esencialmente una suma de comprobaci√≥n r√°pida y corta de la serie de tiempo de nombre completo.  La huella digital es una combinaci√≥n de todas las etiquetas, claves y valores.  Un nombre es una etiqueta normal.  Usamos el mismo algoritmo para compatibilidad.  Debitar algo puede ser conveniente.  La huella digital es la misma y se puede verificar en TSDB y en nuestro almacenamiento que son iguales.  Las etiquetas se almacenan en un JSON especial, que permite a ClickHouse trabajar con sus funciones est√°ndar.  Este es JSON compacto sin espacios, con nombres ligeramente simplificados.  Esta tabla no se usa durante la operaci√≥n.  Siempre se almacena en la memoria de nuestra soluci√≥n real, que se llama PromHouse.  Se usa solo cuando iniciamos el servidor para averiguar qu√© series de tiempo son.  Ella es restada.  A medida que llegan nuevas series de tiempo, las grabamos all√≠.  Todas las instancias de PromHouse m√∫ltiples pueden leer la misma tabla.  ReplacingMergeTree nos dice que estas series de tiempo, hay varias instancias diferentes, escriben la misma serie de tiempo.  Ellos contendr√°n, y no habr√° ning√∫n problema aqu√≠. </p><br><p><img src="https://habrastorage.org/webt/ms/lg/1t/mslg1tnbc97nrlauwcr9ekj-p3k.png"></p><br><p>  Almacenamos muestras en una mesa separada de manera muy eficiente.  Con un valor de longitud fijo, esta huella digital es la misma, tiempo y valor.  Obtenemos 24 bytes por muestra.  Tiene una longitud estrictamente fija.  Cada columna se almacena por separado.  Una b√∫squeda de huellas digitales es efectiva porque sabemos que el tama√±o es fijo.  No hay tal problema como con GraphitmergeTree cuando es una cadena.  Utilizamos particiones personalizadas.  √çndice primario de huellas digitales y por tiempo. </p><br><p>  24 bytes es una versi√≥n simplificada.  De hecho, se comprime bien.  De hecho usa menos espacio.  En nuestras √∫ltimas pruebas, la relaci√≥n de compresi√≥n es de aproximadamente 1 a 42. </p><br><p><img src="https://habrastorage.org/webt/wu/5y/24/wu5y2499vjvrcm37ct1gudfrpym.png"></p><br><p>  ¬øC√≥mo podemos hacer un muestreo manual si tenemos GraphiteMergeTree, pero no es lo mismo que quisi√©ramos?  De hecho, podemos hacerlo a mano.  Como se hizo anteriormente, particionamiento, cuando no hab√≠a nada incorporado.  Hacemos una nueva mesa con nuestras manos.  Cuando nos llega una muestra de tiempo, determinamos a qu√© tabla estamos escribiendo. </p><br><p>  Seleccionamos el tiempo de la consulta de qu√© tabla leer.  Si la lectura ocurre en el borde, leemos varias tablas.  A continuaci√≥n tenemos estos datos.  Se podr√≠a usar la vista para esto.  Por ejemplo, cree una vista para varias tablas, lo que le permite leerse en una sola consulta.  Pero hay un error en ClickHouse: el predicado de la vista no se sustituye en las consultas.  Por lo tanto, si realiza una solicitud a la vista, se dirige a todas las tablas.  Vista que no podemos usar. </p><br><p>  ¬øC√≥mo hacemos la disminuci√≥n de muestras?  Creamos una tabla temporal.  Copie el inserto en datos seleccionados usando las funciones correctas. </p><br><p>  Hacemos renombrar que es at√≥mico bajo el bloqueo global.  Estamos cambiando el nombre de la tabla existente a la anterior.  Nuevo a existente.  Dejamos caer la vieja mesa.  Tenemos datos de 148 d√≠as ya de muestreo.  ¬øCu√°l es el problema aqu√≠?  Insertar en se ve hermosa.  De hecho, necesitamos aplicar las funciones correctas, la agregaci√≥n correcta para hacer.  En la pr√°ctica, esto no se puede hacer con una gran solicitud.  Incluso algunas solicitudes grandes no se pueden hacer.  Esto tiene que hacerse desde el c√≥digo.  El c√≥digo env√≠a una gran cantidad de solicitudes peque√±as.  Hicimos todo lo posible para hacer esto con solicitudes grandes, pero esto no es muy efectivo.  La disminuci√≥n de datos de un d√≠a hasta ahora lleva menos de un d√≠a.  Dependiendo de la cantidad de datos, puede llevar mucho tiempo. </p><br><p><img src="https://habrastorage.org/webt/7c/94/h4/7c94h4t2bbvk5x-3acoftonomxa.png"></p><br><p>  ClickHouse tendr√° actualizaci√≥n / eliminaci√≥n.  Eliminar ya tiene la primera versi√≥n.  Si la actualizaci√≥n / eliminaci√≥n funciona, nuestro esquema de datos de disminuci√≥n de muestreo puede simplificarse. </p><br><p>  En segundo lugar, ClickHouse tiene la tarea de hacer una compresi√≥n personalizada (delta, delta a delta).  Esto es lo que hace TSDB.  Esto es muy adecuado para datos de series temporales.  Esto es especialmente √∫til si podremos elegir el tipo de compresi√≥n dependiendo de los tipos de datos.  Por ejemplo, counter, que solo est√° creciendo; para esto, la compresi√≥n delta-delta es adecuada.  Un medidor que fluct√∫a alrededor de la magnitud, por lo que el delta funciona bien. </p><br><p><img src="https://habrastorage.org/webt/od/mv/hx/odmvhxcnnite5wum9k9gwfifbec.png"></p><br><p>  Hay otro almacenamiento que funciona.  Hay InfluxDB que funciona fuera de la caja.  Es costumbre rega√±arlo por la velocidad, pero lo que funciona de inmediato y no necesitas hacer nada es bueno. </p><br><p>  Hay OpenTSDB y Graphite, que es de solo escritura.  El adaptador est√°ndar de Prometheus realmente no funciona. </p><br><p>  Hay un CrateDB.  Hay un TimescaleDB que bifurca PostgreSQL para bases de datos de series temporales.  Dicen que funciona bien, pero nosotros mismos no lo hemos probado. </p><br><p>  Est√° Cortex, tambi√©n conocido como el proyecto Frankenstein.  Esto lo describe muy bien.  Estos son los chicos que intentan tomar una decisi√≥n basada en la federaci√≥n Prometheus.  Almacenan datos en S3. </p><br><p>  Hay Thanos </p><br><ul><li>  Tiene una arquitectura muy interesante.  Hay Prometheus que usa TSDB local.  Se crea un cl√∫ster entre ellos.  Al lado de cada Prometheus hay un sidecar especial, que acepta solicitudes a trav√©s de API de lectura remota y escritura remota.  Redirige estas solicitudes a Prometeo.  Prometheus puede usar sus API de lectura remota y escritura remota.  Todos los side-cars est√°n interconectados y entre maestros API personalizados a trav√©s de gRPC, la replicaci√≥n est√° disponible, hay un nuevo sombreado. </li><li>  Arquitectura sofisticada. </li><li>  Est√° bastante h√∫medo.  Hace un par de meses, se estaba cayendo a pedazos de media patada cuando comenz√≥. </li></ul><br><p><img src="https://habrastorage.org/webt/a9/rc/zm/a9rczmkse4viit4vvr4hgqfcuts.png"></p><br><p>  Usar el modelo de extracci√≥n no escribe muchos datos.  Debe esperar todo un a√±o para completar los datos anuales.  Estamos tratando de escribirlos de alguna manera all√≠. </p><br><p>  No hay escritura remota en Prometheus, por lo tanto, escribir muchos datos en la TSDB local no funcionar√°. </p><br><p>  El segundo problema  Si generamos datos para pruebas de estr√©s, a menudo se sacuden bien.  Por ejemplo, si tomamos datos existentes y generamos 100 instancias, y estos son los mismos datos, entonces el coeficiente de compresi√≥n ser√° tan hermoso que en realidad no suceder√°. </p><br><p><img src="https://habrastorage.org/webt/fy/mc/uk/fymcukkdoo3hi78gkw1eb2ipvsk.png"></p><br><p>  Escribimos un exportador falso que se parece a un exportador regular que Prometheus puede mantener unido: </p><br><ul><li>  Cuando llega la chatarra, se dirige a alg√∫n exportador ascendente.  Toma datos de ella. </li><li>  Genera muchas instancias.  Digamos que 1 es un scrapie, y obtenemos 100 en la salida. </li><li>  Cambia ligeramente los datos: m√°s menos 10% para el contador y el indicador. </li><li>  No cambia los valores simples 0 o 1. Porque si hay una m√©trica UP que responde, muestra si el servicio se est√° ejecutando: s√≠ - 1 o no - 0. Y no est√° muy claro qu√© significa 098 UP. </li><li>  No cambiamos los enteros por n√∫meros reales y viceversa. </li><li>  Solo da datos en el formato de expfmt habitual. </li></ul><br><p><img src="https://habrastorage.org/webt/c0/ja/hc/c0jahc5ryn-oxhwxnke_vaj1mia.png"></p><br><p>  Una herramienta de promload que carga datos.  Lectura de datos: </p><br><ul><li>  Puede leer archivos en su propio formato </li><li>  Tal vez de lectura remota </li><li>  Puede leer de alg√∫n exportador </li></ul><br><p>  Escribe en diferentes formatos.  Incluyendo en / dev / null, si queremos probar exactamente c√≥mo funciona la lectura r√°pidamente. </p><br><p>  Ahora es una herramienta de prueba de carga no solo para PromHouse, sino tambi√©n para cualquier soluci√≥n que use lectura remota o Prometheus. </p><br><p><img src="https://habrastorage.org/webt/qr/xa/-2/qrxa-2wg58troaskuqhqowwicq4.png"></p><br><p>  Queremos agregar el almacenamiento en cach√© de lectura, porque en nuestras pruebas el cuello de botella fue a menudo el exportador falso, que gener√≥ datos durante mucho tiempo.  Podr√≠amos guardarlos en cach√©.  Deja que sean irrealmente buenos.  Pero no vamos a frenar.  No tuvimos que esperar d√≠as para realizar pruebas de estr√©s. </p><br><p>  Alg√∫n tipo de filtrado sobre la marcha, alg√∫n tipo de modificaci√≥n sobre la marcha. </p><br><p>  Soporte nativo para TSDB.  Para trabajar con la base de datos en el disco, y no a trav√©s de la API. </p><br><p>  Centrarse en la precisi√≥n para la migraci√≥n.  Una vez pmmdemo.percona.com puso: conectado, recib√≠ todas las m√©tricas.  Si hace esto de forma nativa, Prometheus abre TSDB, levanta todas las series de tiempo del disco, levanta √≠ndices, luego se arrastra a archivos fragmentados y se da cuenta de que realmente existen.  En este punto, todo puede simplemente tumbarse. </p><br><p>  El enfoque ingenuo es tomar toda la serie temporal y leer los datos antiguos a los nuevos.  En ese momento se acostar√°.  Necesitas hacer lo contrario.  Primero debe obtener la lista de series de tiempo con algunas consultas con expresiones regulares.  Por ejemplo, una serie de tiempo que comienza en A. Luego, dame una serie de tiempo que comience en B. Luego c√°rgalas exactamente por m√©tricas, no por tiempo.  Esto es il√≥gico, pero as√≠ es como funciona.  Esto es un matiz si haces algo as√≠.  Si ves que OOM Killer sucedi√≥ all√≠, entonces sabr√°s que es por tu culpa. </p><br><p><img src="https://habrastorage.org/webt/mz/z9/kh/mzz9khnykox-3r2wlp_lpgphil4.png"></p><br><p>  Los resultados de las pruebas de carga, no habr√° gr√°ficos.  La prueba de carga lleva mucho tiempo y, desafortunadamente, debido a un error de configuraci√≥n, todo sali√≥ mal.  Por lo tanto, los resultados no funcionaron. </p><br><p>  Escribiremos en el blog de Percona cuando hagamos pruebas de carga. </p><br><p>  Puedo decir los resultados sin gr√°ficos.  La grabaci√≥n fue lineal.  La lectura salt√≥ y no fue muy r√°pido.  Leer los datos actuales no es muy importante para nosotros.  Se pueden acelerar mediante sugerencias de lectura.  Puede habilitar read_recent para mejorar la lectura.  Y para datos antiguos, esto funciona bien. </p><br><p><img src="https://habrastorage.org/webt/b6/7f/4w/b67f4wmgkuzi6zyqnitxlwuv2t8.png"></p><br><p>  La gente quiere almacenamiento a largo plazo.  Hay tal demanda.  Hablamos sobre PromHouse en PromCon.  All√≠ fue un tema muy candente.  Thanos se est√° desarrollando activamente. </p><br><p>  Ya es posible ahora.  Hay una soluci√≥n para esto.  Hay una API  Hay algunas integraciones.  Pero todo esto debe finalizarse con un archivo.  No hay soluciones listas para la producci√≥n. </p><br><p><img src="https://habrastorage.org/webt/ms/qk/ec/msqkechijgscjucb7sx8knkzwx0.png"></p><br><p>  Enlaces donde buscar.  El primer enlace es el repositorio PromHouse.  El segundo enlace es donde es probable que se mueva.  Ahora en un repositorio hay varias cosas diferentes?  No muy estrechamente relacionado.  Por lo tanto, deber√° transferirlos. </p><br><p>  Nuestro blog contendr√° informaci√≥n sobre el rendimiento y algunas novedades. </p><br><p>  Preguntas: </p><br><p>  Pregunta: ¬øHas revisado los rumores sobre InfluxDB? </p><br><p>  Respuesta: No fue muy bueno.  Se volvi√≥ mucho mejor.  Todas estas historias sobre el hecho de que InfluxDB es lento, se est√°n desmoronando, se trata de la versi√≥n anterior.  La versi√≥n actual es estable.  Yo no dir√≠a?  Que funciona r√°pido.  Pero funciona de manera estable.  Ventajas de InfluxDB en mi opini√≥n: </p><br><ul><li>  En primer lugar, no hay necesidad de hacer algo cerca, porque InfluxDB funciona de forma inmediata. </li><li>  En segundo lugar, en ClickHouse, como en otras soluciones basadas en bases de datos, pero no en TSDB, puede usar un lenguaje de consulta que le resulte m√°s familiar.  El lenguaje de consulta InfluxDB es similar a SQL.  Puede hacer an√°lisis en √©l, lo cual es dif√≠cil de hacer en PromQL.  Si usa TimeScaleDB, hay SQL real. </li></ul><br><p>  Pregunta: ¬øEl motor GraphiteMergeTree solo sirve para grabar trabajos?  Si queremos mostrar gr√°ficos, ¬øes necesario configurar Grafana en Graphite para mostrar el almacenamiento a largo plazo? </p><br><p>  Respuesta: s√≠.  La integraci√≥n que se encuentra en Prometheus funciona solo para la grabaci√≥n.  √âl solo escribe datos.  Entonces, desde Grafana, vas a Graphite. </p><br><p>  Pregunta: ¬øY pierde etiquetas cuando escribe? </p><br><p>  Respuesta: Hay una configuraci√≥n que dice qu√© hacer con ellos, c√≥mo insertarlos, d√≥nde insertarlos. </p><br><p>  Informaci√≥n de la audiencia: Avito dijo que est√°n escribiendo su soluci√≥n para grabaciones de Prometheus a Graphite. </p><br><p>  Pregunta: se lleg√≥ a la conclusi√≥n de que con la grabaci√≥n todo est√° bien en un servidor de almacenamiento a largo plazo. </p><br><p><img src="https://habrastorage.org/webt/mz/z9/kh/mzz9khnykox-3r2wlp_lpgphil4.png">     (5-  15-).   raid 6 sata      ? </p><br><p> :  PMM      ‚Äî  .   downsampling    c 14   1 .  ,       .          .    .     . </p><br><p> :   IOPS  ? </p><br><p> :     . </p><br><p> :      </p><br><p> :        .  ,        .  , ,  . </p><br><p> :     InfluxDB,        InfluxDB? </p><br><p> :    read_recent.    ,      remote storage.    InfluxDB .    .  read_recent ,   . </p><br><p> : ,     Prometheus.     InfluxDB. Grafana   Prometheus. Prometheus   PromQL     ,    InfluxDB? </p><br><p> : . </p><br><p> : Prometheus     InfluxDB      Grafana? </p><br><p> : .    Prometheus  2.2        ,    . </p><br><p> PS       : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">valyala</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">gecube</a> <br>   ,   . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/441136/">https://habr.com/ru/post/441136/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../441126/index.html">Falsos positivos en PVS-Studio: qu√© tan profundo es la madriguera del conejo</a></li>
<li><a href="../441128/index.html">La elecci√≥n correcta: un estudio pr√°ctico de las habilidades cognitivas de los simios antropoides</a></li>
<li><a href="../441130/index.html">Rendimiento equilibrado del sitio. Parte 1: estrategia</a></li>
<li><a href="../441132/index.html">Para que Roskomnadzor no venga REPENTINAMENTE</a></li>
<li><a href="../441134/index.html">Emociones, trabajo independiente.</a></li>
<li><a href="../441138/index.html">Soluciones de chat en tiempo real frente a plataformas de chat: haga su elecci√≥n</a></li>
<li><a href="../441140/index.html">Desarrollo de WebAssembly: rastrillo real y ejemplos</a></li>
<li><a href="../441142/index.html">12 puntos de crecimiento de conversi√≥n o contenido que realmente vende</a></li>
<li><a href="../441146/index.html">Redes inal√°mbricas industriales: ¬øcu√°l elegir?</a></li>
<li><a href="../441148/index.html">C√≥mo manejar los errores correctamente: el silencio no siempre es bueno</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>