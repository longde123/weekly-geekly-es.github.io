<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛔️ 👩🏿‍🤝‍👩🏽 ⛽️ 我们如何与EF 6 MSSQL和PostgresSQL交朋友 👨‍🌾 ▶️ ♒️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="曾几何时，有一个使用MSSQL DBMS的EF 6项目。 并且需要增加使用PostgreSQL的功能。 我们在这里没想到会出现问题，因为有大量关于此主题的文章，并且在论坛上您可以找到有关类似问题的讨论。 但是，实际上，并非所有事情都那么简单，在本文中，我们将讨论这种体验，在集成新提供程序时遇到的问题...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>我们如何与EF 6 MSSQL和PostgresSQL交朋友</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/crosstech/blog/445910/"><img src="https://habrastorage.org/webt/_a/jr/dp/_ajrdpk_rrdrsqmckt71xkfceve.jpeg" alt="图片"><br><br> 曾几何时，有一个使用MSSQL DBMS的EF 6项目。 并且需要增加使用PostgreSQL的功能。 我们在这里没想到会出现问题，因为有大量关于此主题的文章，并且在论坛上您可以找到有关类似问题的讨论。 但是，实际上，并非所有事情都那么简单，在本文中，我们将讨论这种体验，在集成新提供程序时遇到的问题以及我们选择的解决方案。 <br><a name="habracut"></a><br><h3> 介绍性 </h3><br> 我们有一个盒装产品，并且它已经建立了结构。 最初，它被配置为与一个DBMS-MSSQL一起使用。 该项目具有一个采用EF 6实施（代码优先方法）的数据访问层。 我们通过EF 6迁移进行迁移。 迁移是手动创建的。 数据库的初始安装是通过控制台应用程序进行的，其中连接字符串上的上下文已初始化，并作为参数传递： <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (args.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"No arguments in command line"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> connectionString = args[<span class="hljs-number"><span class="hljs-number">0</span></span>]; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Initializing dbcontext via </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{connectionString}</span></span></span><span class="hljs-string">"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> context = MyDbContext(connectionString)) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Database created"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { Console.WriteLine(e.Message); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>; } }</code> </pre> <br> 同时，在另一个项目中描述了EF基础结构和域域，该项目作为库连接到控制台应用程序。 基础结构项目中的上下文构造函数如下所示： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyDbContext</span></span> : <span class="hljs-title"><span class="hljs-title">IdentityDbContext</span></span>&lt;<span class="hljs-title"><span class="hljs-title">User</span></span>, <span class="hljs-title"><span class="hljs-title">Role</span></span>, <span class="hljs-title"><span class="hljs-title">Key</span></span>, <span class="hljs-title"><span class="hljs-title">UserLogin</span></span>, <span class="hljs-title"><span class="hljs-title">UserRole</span></span>, <span class="hljs-title"><span class="hljs-title">UserClaim</span></span>&gt;, <span class="hljs-title"><span class="hljs-title">IUnitOfWork</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyDbContext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> connectionString</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">connectionString</span></span></span><span class="hljs-function">)</span></span> { Database.SetInitializer(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DbInitializer()); Database.Initialize(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); } }</code> </pre><br><h3> 首次发射 </h3><br> 我们要做的第一件事是通过nuget将两个软件包连接到项目：Npgsql和EntityFramework6.Npgsql。 <br><br> 我们还在控制台应用程序的App.config中注册了Postgres的设置。 <br><br>  entityFramework部分将默认的postgres工厂指定为连接工厂： <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">entityFramework</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--&lt;defaultConnectionFactory type="System.Data.Entity.Infrastructure.SqlConnectionFactory, EntityFramework" /&gt;--&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">defaultConnectionFactory</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Npgsql.NpgsqlConnectionFactory, EntityFramework6.Npgsql"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">providers</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">provider</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">invariantName</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"System.Data.SqlClient"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"System.Data.Entity.SqlServer.SqlProviderServices, EntityFramework.SqlServer"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">provider</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">invariantName</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Npgsql"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Npgsql.NpgsqlServices, EntityFramework6.Npgsql"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">providers</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">entityFramework</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br> 在DbProviderFactories部分中，注册了新提供程序的工厂： <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">system.data</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">DbProviderFactories</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">add</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Npgsql Data Provider"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">invariant</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Npgsql"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">support</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"FF"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">description</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">".Net Framework Data Provider for Postgresql"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Npgsql.NpgsqlFactory, Npgsql"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">DbProviderFactories</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">system.data</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br> 并且，他们立即尝试通过在连接字符串中指定Postgres服务器的地址和服务器admin的凭据来初始化数据库。 结果是以下行： <br><blockquote>  “服务器=本地主机； 数据库= TestPostgresDB; 集成安全性=否； 用户ID = postgres； 密码= pa $$ w0rd” </blockquote> 不出所料，由于采用了手动EF迁移模式，初始化未通过，并且发生了与当前模型的数据库映像不匹配的错误。 为了避免使用新的提供程序创建主迁移并在Postgres上测试数据库初始化，我们对基础结构配置进行了一些调整。 <br><br> 首先，我们打开了“自动迁移”功能，这是一个开发人员对团队中的域模型和EF基础架构进行更改的有用选项： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Configuration</span></span> : <span class="hljs-title"><span class="hljs-title">DbMigrationsConfiguration</span></span>&lt;<span class="hljs-title"><span class="hljs-title">MyDbContext</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Configuration</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { AutomaticMigrationsEnabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; ContextKey = <span class="hljs-string"><span class="hljs-string">"Project.Infrastructure.MyDbContext"</span></span>; } }</code> </pre><br> 其次，我们在继承的类CreateDatabaseIfNotExists的重定义方法InitializeDatabase中指定了一个新的提供程序，在此我们开始迁移： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DbInitializer</span></span> : <span class="hljs-title"><span class="hljs-title">CreateDatabaseIfNotExists</span></span>&lt;<span class="hljs-title"><span class="hljs-title">MyDbContext</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeDatabase</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">MyDbContext context</span></span></span><span class="hljs-function">)</span></span> { DbMigrator dbMigrator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DbMigrator(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Configuration { <span class="hljs-comment"><span class="hljs-comment">//TargetDatabase = new DbConnectionInfo(context.Database.Connection.ConnectionString, "System.Data.SqlClient") TargetDatabase = new DbConnectionInfo(context.Database.Connection.ConnectionString, "Npgsql") }); // There some code for run migrations } }</span></span></code> </pre><br> 接下来，我们再次使用相同的连接字符串作为参数启动控制台应用程序。 这次，上下文的初始化没有错误，并且我们的域模型安全地适合了新的Postgres数据库。  “ __MigrationHistory”标签出现在新数据库中，其中有一个记录是第一次自动创建的迁移。 <br><br> 总结一下：我们能够将新的提供程序连接到现有项目而没有任何问题，但是同时更改了迁移机制的设置。 <br><br><h3> 开启手动迁移模式 </h3><br> 如上所述，启用自动迁移模式后，您的团队将失去在域和数据访问区域中的并行开发能力。 对于我们来说，这种选择是不可接受的。 因此，我们需要在项目中设置手动迁移模式。 <br><br> 首先，我们将AutomaticMigrationsEnabled字段返回为false。 然后有必要处理新迁移的创建。 我们知道，至少应将不同DBMS的迁移存储在不同的项目文件夹中。 因此，我们决定在名为PostgresMigrations的基础结构项目中创建一个用于Postgres迁移的新文件夹（为清楚起见，该文件夹具有MsSql迁移，我们将其重命名为MsSqlMigrations），然后将MsSql迁移配置文件复制到其中。 同时，我们没有将所有现有的MsSql迁移复制到PostgresSql。 首先，由于它们都包含MsSql提供程序的配置快照，因此，我们将无法在新的DBMS上使用它们。 其次，更改的历史记录对于新的DBMS而言并不重要，我们可以了解域模型状态的最新快照。 <br><br> 我们认为一切准备就绪，可以构成第一次迁移到Postgres的过程。 在自动迁移模式打开的情况下初始化上下文期间创建的数据库已删除。 并且，由于以下事实的指导：对于第一次迁移，您需要基于域模型的当前状态创建物理数据库，因此我们很高兴在Package Manager控制台中对Update-Database命令进行了评分，仅指定了连接字符串参数。 结果，我们收到与连接到DBMS有关的错误。 <br><br> 在进一步研究了Update-Database命令的工作原理之后，我们执行了以下操作： <br><br><ul><li> 在迁移配置设置中添加了以下代码： <br><br> 对于MsSql： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Configuration</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { AutomaticMigrationsEnabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; ContextKey = <span class="hljs-string"><span class="hljs-string">"Project.Infrastructure.MyDbContext"</span></span>; MigrationsDirectory = <span class="hljs-string"><span class="hljs-string">@"MsSqlMigrations"</span></span>; }</code> </pre><br> 对于Postgres： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Configuration</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { AutomaticMigrationsEnabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; ContextKey = <span class="hljs-string"><span class="hljs-string">"Project.Infrastructure.MyDbContext"</span></span>; MigrationsDirectory = <span class="hljs-string"><span class="hljs-string">@"PostgresMigrations"</span></span>; }</code> </pre></li><li> 指示了传递提供程序名称的Update-Database命令的必要参数 </li><li> 添加的参数指示包含ef基础结构描述的项目以及带有新提供程序的迁移配置的文件夹 </li></ul><br> 结果，我们得到了以下命令： <br><blockquote>  Update-Database -ProjectName“ Project.Infrastructure” -ConfigurationTypeName Project.Infrastructure.PostgresMigrations.Configuration -ConnectionString“服务器=本地主机； 数据库= TestPostgresDB; 集成安全性=否； 用户ID = postgres； 密码= pa $$ w0rd“ -ConnectionProviderName” Npgsql“ </blockquote> 执行完此命令后，我们可以使用相似的参数执行Add-Migration命令，并命名第一个迁移InitialCreate： <br><blockquote>  Add-Migration-名称“ InitialCreate” -ProjectName“ CrossTech.DSS.Infrastructure” -ConfigurationTypeName CrossTech.DSS.Infrastructure.PostgresMigrations.Configuration -ConnectionString“服务器=本地主机； 数据库= TestPostgresDB; 集成安全性=否； 用户ID = postgres； 密码= pa $$ w0rd“ -ConnectionProviderName” Npgsql“ </blockquote> 一个新文件出现在PostgresMigrations文件夹中：2017010120705068_InitialCreate.cs <br><br> 然后，我们删除了执行Update-Database命令后创建的数据库，并使用上面指示的连接字符串作为参数启动了控制台应用程序。 因此，我们已经在手动创建的迁移的基础上获得了数据库。 <br><br> 总结：我们能够以最小的努力为Postgres提供程序添加第一个迁移，并通过控制台应用程序初始化上下文，获得一个新数据库，第一次手动迁移的更改就进入了该数据库。 <br><br><h3> 在提供商之间切换 </h3><br> 我们还有一个悬而未决的问题：如何配置上下文初始化，以便可以在运行时访问特定的DBMS？ <br><br> 任务是，在上下文的初始化阶段，可以选择所需提供者的一个或另一个目标数据库。 由于反复尝试配置此开关，因此我们提出了一个如下所示的解决方案。 <br><br> 在app.config中项目的控制台应用程序中（如果不使用app.config，则不使用machine.config），我们添加带有提供程序和连接名称的新连接字符串，并在上下文构造函数中“删除”连接名称而不是连接字符串。 同时，我们通过DbConfiguration实例的单例将连接字符串本身连接到上下文。 我们将从DbConfiguration继承的类的实例作为参数传递。 <br><br> 结果继承的DbConfiguration类： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DbConfig</span></span> : <span class="hljs-title"><span class="hljs-title">DbConfiguration</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DbConfig</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> connectionName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> connectionString, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> provideName</span></span></span><span class="hljs-function">)</span></span> { ConfigurationManager.ConnectionStrings.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConnectionStringSettings(connectionName, connectionString, provideName)); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (connectionName) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"PostgresDbConnection"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SetDefaultConnectionFactory(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NpgsqlConnectionFactory()); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SetProviderServices(provideName, NpgsqlServices.Instance); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SetProviderFactory(provideName, NpgsqlFactory.Instance); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"MsSqlDbConnection"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SetDefaultConnectionFactory(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SqlConnectionFactory()); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SetProviderServices(provideName, SqlProviderServices.Instance); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SetProviderFactory(provideName, SqlClientFactory.Instance); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SetDefaultConnectionFactory(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SqlConnectionFactory()); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } }</code> </pre><br> 现在上下文初始化本身如下所示： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> connectionName = args[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> connectionString = args[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> provideName = args[<span class="hljs-number"><span class="hljs-number">2</span></span>]; DbConfiguration.SetConfiguration(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DbConfig(connectionName, connectionString, provideName)); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> context = MyDbContext(connectionName)) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Database created"</span></span>); }</code> </pre><br> 仔细跟踪的人可能会注意到他必须对代码进行另一处更改。 这是数据库初始化期间目标数据库的定义，该定义在前面介绍的InitializeDatabase方法中发生。 <br><br> 我们添加了一个简单的开关来确定特定提供程序的迁移配置： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DbInitializer</span></span> : <span class="hljs-title"><span class="hljs-title">CreateDatabaseIfNotExists</span></span>&lt;<span class="hljs-title"><span class="hljs-title">MyDbContext</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> _connectionName; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DbInitializer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> connectionName</span></span></span><span class="hljs-function">)</span></span> { _connectionName = connectionName; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeDatabase</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">MyDbContext context</span></span></span><span class="hljs-function">)</span></span> { DbMigrationsConfiguration&lt;MyDbContext&gt; config; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (_connectionName) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"PostgresDbConnection"</span></span>: config = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PostgresMigrations.Configuration(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"MsSqlDbConnection"</span></span>: config = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MsSqlMigrations.Configuration(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: config = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (config == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; config.TargetDatabase = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DbConnectionInfo(_connectionName); DbMigrator dbMigrator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DbMigrator(config); <span class="hljs-comment"><span class="hljs-comment">// There some code for run migrations } }</span></span></code> </pre><br> 上下文构造函数本身开始看起来像这样： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyDbContext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> connectionNameParam</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">connectionString</span></span></span><span class="hljs-function">)</span></span> { Database.SetInitializer(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DbInitializer(connectionName = connectionNameParam)); Database.Initialize(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); }</code> </pre><br> 接下来，我们启动了控制台应用程序，并将MsSql应用程序参数指定为DBMS提供程序。 我们为应用程序设置参数如下： <blockquote>  “ MsSqlDbConnection”“服务器=本地主机\ SQLEXPRESS; 数据库= TestMsSqlDB; 用户ID = sa； 密码= pa $$ w0rd“” System.Data.SqlClient“ </blockquote><br>  MsSql数据库创建没有错误。 <br><br> 然后我们指定了应用程序参数： <br><blockquote>  “ PostgresDbConnection”“服务器=本地主机； 数据库= TestPostgresDB; 集成安全性=否； 用户ID = postgres； 密码= pa $$ w0rd“” Npgsql“ </blockquote>  Postgres数据库也已创建，没有错误。 <br><br> 因此，还有一个小计-为了让EF为特定提供程序初始化数据库上下文，您需要在运行时： <br><br><ul><li>  “指示”向该提供者的迁移机制 </li><li> 在上下文初始化之前配置DBMS连接字符串 </li></ul><br><h3> 我们以团队的方式处理两个DBMS的迁移 </h3><br> 如我们所见，最有趣的部分开始于域中新变化的出现。 您需要考虑一个特定的提供程序为两个DBMS生成迁移。 <br><br> 因此，对于MSSQL Server，您需要执行顺序命令（对于Postgres，在创建第一个迁移时上述命令）： <br><br><ul><li> 根据上一个快照更新数据库 <br><blockquote>  Update-Database -ProjectName“ Project.Infrastructure” -ConfigurationTypeName Project.Infrastructure.MsSqlMigrations.Configuration -ConnectionString“服务器=本地主机； 数据库= TestMsSqlDB; 集成安全性=否； 用户ID = sa； 密码= pa $$ w0rd“ -ConnectionProviderName” System.Data.SqlClient“ </blockquote></li><li> 添加新的迁移 <br><blockquote>  Add-Migration-名称“ SomeMigrationName” -ProjectName“ Project.Infrastructure” -ConfigurationTypeName Project.Infrastructure.MsSqlMigrations.Configuration -ConnectionString“服务器=本地主机； 数据库= TestMsSqlDB; 集成安全性=否； 用户ID = sa； 密码= pa $$ w0rd“ -ConnectionProviderName” System.Data.SqlClient“ </blockquote></li></ul><br> 当开发人员并行地对域进行更改时，在版本控制系统中合并这些更改时会遇到多个冲突（为简单起见，我们将其称为git）。 这是由于以下事实：向EF的迁移是依次进行的。 而且，如果一位开发人员创建了迁移，那么另一位开发人员将无法成功地按顺序添加迁移。 每个后续迁移都存储有关前一个迁移的信息。 因此，在迁移到最后创建的模型快照时，有必要更新所谓的模型快照。 <br><br> 同时，解决团队中EF迁移的冲突归结为优先考虑特定开发人员变更的重要性。 并且其更改的优先级较高，应该首先将其填充到git中，并且根据约定的层次结构，其余开发人员需要执行以下操作： <br><br><ol><li> 删除创建的本地迁移 </li><li> 将更改从存储库移交给您自己，其他优先级高的同事已经在这里进行了迁移 </li><li> 创建本地迁移并将结果更改上传回git </li></ol><br> 据我们所熟悉的EF迁移机制，我们可以判断，所描述的团队开发方法是目前唯一的方法。 我们认为此解决方案并不理想，但它拥有生命权。 对于我们来说，寻找替代EF迁移机制的替代方案的问题已经迫在眉睫。 <br><br><h3> 总结 </h3><br> 与EF Migrations一起使用多个使用EF6的DBMS的工作是真实的，但是在此版本中，Microsoft的人员没有考虑使用版本控制系统进行团队并行工作的可能性。 <br><br> 市场上有许多可选的EF迁移解决方案（付费和免费）：DbUp，RoundhousE，ThinkingHome.Migrator，FluentMigrator等。 从评论来看，他们比EF迁移更像是开发人员。 <br><br> 幸运的是，我们现在有机会在项目中进行某种升级。 并且在不久的将来，我们将切换到EF Core。 我们权衡了EF核心迁移机制的利弊，得出的结论是，使用第三方解决方案（即Fluent Migrator）会更加方便。 <br><br> 我们希望您对我们的经验感兴趣。 准备接受评论并回答问题，欢迎光临！ </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN445910/">https://habr.com/ru/post/zh-CN445910/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN445898/index.html">关于新想法，狭窄观点和口口相传</a></li>
<li><a href="../zh-CN445900/index.html">如何承受增加的系统负载：谈论“黑色星期五”的大规模准备工作</a></li>
<li><a href="../zh-CN445904/index.html">无穷类型和脑干</a></li>
<li><a href="../zh-CN445906/index.html">不要吃阿司匹林</a></li>
<li><a href="../zh-CN445908/index.html">Golang与数据库交互的演变</a></li>
<li><a href="../zh-CN445912/index.html">嗨，哈伯，我们是研华</a></li>
<li><a href="../zh-CN445914/index.html">Docker是玩具吗？ 还是真的如此？</a></li>
<li><a href="../zh-CN445918/index.html">RollerCoaster Tycoon成立20周年：游戏创造者访谈</a></li>
<li><a href="../zh-CN445920/index.html">直播：如何遏制大型团队的iOS开发</a></li>
<li><a href="../zh-CN445922/index.html">如果您可以阅读Habr，为什么还要观看在线广播</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>