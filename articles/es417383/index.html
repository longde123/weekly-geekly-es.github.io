<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游뱢 游 游늺 JavaScript ES6: Debilidades 游끠 游놊游낖 游땞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En junio de 2018, el est치ndar ECMAScript 2015 ( ES6 ) celebr칩 su tercer aniversario. En ES6, en primer lugar, han aparecido muchas caracter칤sticas nue...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript ES6: Debilidades</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/417383/">  En junio de 2018, el est치ndar ECMAScript 2015 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ES6</a> ) celebr칩 su tercer aniversario.  En ES6, en primer lugar, han aparecido muchas caracter칤sticas nuevas de JavaScript, y en segundo lugar, una nueva era de desarrollo del lenguaje comienza con este est치ndar.  Adem치s, esta fue la 칰ltima versi칩n a gran escala de JS, ya que ahora TC39 aplica el esquema para emitir peque침os n칰meros anuales del est치ndar, y no lo vuelve a sacar cada pocos a침os. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/ts/9f/9h/ts9f9hvjwknbldjzd40effqpdbs.jpeg"></a> <br><br>  Los 칰ltimos 4 a침os, ES6, con bastante justificaci칩n, ha atra칤do la atenci칩n universal.  El autor del material, cuya traducci칩n publicamos hoy, dice que todo este tiempo, gracias a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Babel</a> , escribi칩 todo el c칩digo utilizando la versi칩n moderna de las especificaciones JS.  칄l cree que ha pasado suficiente tiempo para analizar cr칤ticamente las nuevas caracter칤sticas de ES6.  En particular, est치 interesado en lo que us칩 durante alg칰n tiempo y luego dej칩 de usarlo porque empeor칩 su c칩digo. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Sobre las debilidades de JS</font> </h2><br>  Douglas Crockford, en su <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">libro</a> JavaScript: Fortalezas, tambi칠n escribi칩 sobre lo que puede considerarse debilidades del lenguaje.  Esto es algo que, en su opini칩n, no vale la pena usar.  Afortunadamente, entre las innovaciones de ES6 no hay nada tan desagradable como algunas de las viejas caracter칤sticas problem치ticas de JS, como el operador de igualdad laxa que realiza la conversi칩n de tipo impl칤cita, la funci칩n <code>eval()</code> y la instrucci칩n <code>with</code> .  Las nuevas caracter칤sticas de ES6 est치n dise침adas mucho mejor.  Sin embargo, hay algunas cosas en 칠l que evito.  Esas caracter칤sticas que est치n en mi lista de "debilidades" de JS est치n en esta lista por las siguientes razones: <br><br><ul><li>  Son, en esencia, "trampas".  Es decir, parece que est치n dise침ados para realizar ciertas acciones y, en la mayor칤a de los casos, funcionan seg칰n lo esperado.  Sin embargo, a veces se comportan inesperadamente, lo que puede conducir f치cilmente a errores. </li><li>  Aumentan el volumen del idioma a cambio de peque침os beneficios.  Tales oportunidades le dan al desarrollador algunas peque침as ventajas, pero requieren que alguien que est치 tratando de descifrar su c칩digo tenga conocimiento de ciertos mecanismos, generalmente ocultos en alg칰n lugar.  Esto es doblemente cierto para las capacidades de la API, cuando el uso de esta funci칩n significa que otro c칩digo que interact칰a con el c칩digo escrito por un determinado desarrollador debe conocer la aplicaci칩n de esta funci칩n de la API. </li></ul><br>  Ahora, guiados por estas consideraciones, hablemos de las debilidades de ES6. <br><br><h2>  <font color="#3AC1EF">Palabra clave const</font> </h2><br>  Antes de ES6, las variables en JavaScript pod칤an declararse utilizando la palabra clave <code>var</code> .  Adem치s, las variables no pod칤an declararse en absoluto, entonces, incluso si se usan en funciones, entran en el 치mbito global.  Las propiedades de los objetos pueden desempe침ar el papel de variables, y las funciones se declaran utilizando la palabra clave <code>function</code> .  La palabra clave <code>var</code> tiene ciertas caracter칤sticas. <br><br>  Por lo tanto, le permite crear variables que se agregan al objeto global, o aquellas cuyo alcance est치 limitado por las funciones.  Sin embargo, la palabra clave <code>var</code> no presta atenci칩n a los bloques de c칩digo.  Adem치s, puede hacer referencia a una variable declarada utilizando la palabra clave <code>var</code> en el c칩digo ubicado antes del comando para su declaraci칩n.  Este fen칩meno se conoce como elevar variables.  Estas caracter칤sticas, si no se tienen en cuenta, pueden provocar errores.  Para rectificar la situaci칩n, ES6 introdujo dos nuevas palabras clave para declarar variables: <code>let</code> y <code>const</code> .  Resolvieron los principales problemas <code>var</code> .  Es decir, estamos hablando del hecho de que las variables declaradas usando estas palabras clave tienen un alcance de bloque, como resultado, por ejemplo, una variable declarada en un bucle no es visible fuera de ella.  Adem치s, el uso de <code>let</code> y <code>const</code> no permite acceder a las variables antes de declararlas.  Esto dar치 como resultado un error de <code>ReferenceError</code> .  Este fue un gran paso adelante.  Sin embargo, la aparici칩n de dos nuevas palabras clave, as칤 como sus caracter칤sticas, generaron confusi칩n adicional. <br><br>  El valor de una variable (constante) declarada con la palabra clave <code>const</code> no se puede sobrescribir despu칠s de la declaraci칩n.  Esta es la 칰nica diferencia entre <code>const</code> y <code>let</code> .  Esta nueva oportunidad parece 칰til y realmente puede aportar alg칰n beneficio.  El problema es la palabra clave <code>const</code> s칤.  La forma en que se comportan las constantes declaradas al usarlo no corresponde a lo que la mayor칤a de los desarrolladores asocian con el concepto de "constante". <br><br><pre> <code class="hljs pgsql">const <span class="hljs-keyword"><span class="hljs-keyword">CONSTANT</span></span> = <span class="hljs-number"><span class="hljs-number">123</span></span>; //      "TypeError: invalid assignment to const `CONSTANT`" <span class="hljs-keyword"><span class="hljs-keyword">CONSTANT</span></span> = <span class="hljs-number"><span class="hljs-number">345</span></span>; const CONSTANT_ARR = [] CONSTANT_ARR.push(<span class="hljs-number"><span class="hljs-number">1</span></span>) //     [<span class="hljs-number"><span class="hljs-number">1</span></span>]  -    console.log(CONSTANT_ARR)</code> </pre> <br>  El uso de la palabra clave <code>const</code> evita que se escriba un nuevo valor en una constante, pero no hace que los objetos a los que hacen referencia tales constantes sean inmutables.  Esta caracter칤stica proporciona una protecci칩n deficiente contra cambios de valores cuando se trabaja con la mayor칤a de los tipos de datos.  Como resultado, debido al hecho de que el uso de <code>const</code> puede generar confusi칩n y al hecho de que si la palabra clave <code>let</code> est치 presente, la presencia de <code>const</code> parece redundante, decid칤 usar siempre <code>let</code> . <br><br><h2>  <font color="#3AC1EF">Cadenas de plantillas etiquetadas</font> </h2><br>  La palabra clave <code>const</code> es un ejemplo de c칩mo una especificaci칩n crea demasiadas formas de resolver muy pocos problemas.  En el caso de cadenas de plantillas etiquetadas, tenemos la situaci칩n opuesta.  El comit칠 TC39 consider칩 la sintaxis de tales cadenas como una forma de resolver la interpolaci칩n de cadenas y cadenas multil칤neas.  Luego decidieron ampliar esta oportunidad mediante el uso de macros. <br><br>  Si nunca antes ha visto cadenas de patrones etiquetados, tenga en cuenta que son un poco como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">decoradores de</a> cadenas.  Aqu칤 hay un ejemplo de c칩mo trabajar con ellos con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MDN</a> : <br><br><pre> <code class="hljs powershell">var person = <span class="hljs-string"><span class="hljs-string">'Mike'</span></span>; var age = <span class="hljs-number"><span class="hljs-number">28</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myTag</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(strings, personExp, ageExp)</span></span></span></span> { var str0 = strings[<span class="hljs-number"><span class="hljs-number">0</span></span>]; // <span class="hljs-string"><span class="hljs-string">"that "</span></span> var str1 = strings[<span class="hljs-number"><span class="hljs-number">1</span></span>]; // <span class="hljs-string"><span class="hljs-string">" is a "</span></span> //  (  ) //     , //  ,      . // var str2 = strings[<span class="hljs-number"><span class="hljs-number">2</span></span>]; var ageStr; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ageExp &gt; <span class="hljs-number"><span class="hljs-number">99</span></span>){   ageStr = <span class="hljs-string"><span class="hljs-string">'centenarian'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {   ageStr = <span class="hljs-string"><span class="hljs-string">'youngster'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str0 + personExp + str1 + ageStr; } var output = myTag`that <span class="hljs-variable"><span class="hljs-variable">$</span></span>{ person } is a <span class="hljs-variable"><span class="hljs-variable">$</span></span>{ age }`; console.log(output); // that Mike is a youngster</code> </pre> <br>  Las cadenas de plantillas etiquetadas no se pueden llamar completamente in칰tiles.  Aqu칤 hay una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">descripci칩n general de</a> algunos de sus usos.  Por ejemplo, son 칰tiles para borrar el c칩digo HTML.  Y, en este momento, su aplicaci칩n demuestra el enfoque m치s preciso en situaciones en las que necesita realizar la misma operaci칩n en todos los datos de entrada de una plantilla de cadena arbitraria.  Sin embargo, esto es relativamente raro, puede hacer lo mismo con la API adecuada (aunque dicha soluci칩n es m치s larga).  Y, para resolver la mayor칤a de los problemas, usar la API no ser치 peor que usar cadenas de plantillas etiquetadas.  Esta caracter칤stica no agrega nuevas caracter칤sticas al idioma.  Agrega nuevos enfoques para trabajar con datos que deber칤an ser familiares para aquellos que tienen que leer el c칩digo escrito utilizando cadenas de plantillas etiquetadas.  Y me esfuerzo por asegurarme de que mi c칩digo permanezca lo m치s limpio y comprensible posible. <br><br><h2>  <font color="#3AC1EF">Expresiones de asignaci칩n destructiva redise침adas</font> </h2><br>  Algunas caracter칤sticas del lenguaje se ven geniales cuando se usan para resolver tareas simples, sin embargo, cuando las tareas se vuelven m치s complejas, estas caracter칤sticas pueden salirse de control.  Por ejemplo, me gusta el operador condicional ternario: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> conferenceCost = isStudent ? <span class="hljs-number"><span class="hljs-number">50</span></span> : <span class="hljs-number"><span class="hljs-number">200</span></span></code> </pre> <br>  Sin embargo, el c칩digo escrito con su ayuda, se vuelve dif칤cil de entender si, usando este operador, comienza a usar construcciones anidadas: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> conferenceCost = isStudent ? hasDiscountCode ? <span class="hljs-number"><span class="hljs-number">25</span></span> : <span class="hljs-number"><span class="hljs-number">50</span></span> : hasDiscountCode ? <span class="hljs-number"><span class="hljs-number">100</span></span> : <span class="hljs-number"><span class="hljs-number">200</span></span>;</code> </pre> <br>  Lo mismo puede decirse de la asignaci칩n destructiva.  Este mecanismo le permite extraer los valores de variables de objetos o matrices: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> {a} = {<span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [b] = [<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a, b) <span class="hljs-comment"><span class="hljs-comment">// 2, 4</span></span></code> </pre> <br>  Adem치s, al usarlo, puede cambiar el nombre de las variables, obtener valores anidados, establecer valores predeterminados: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> {a: val1} = {a: <span class="hljs-number"><span class="hljs-number">2</span></span>, b: <span class="hljs-number"><span class="hljs-number">3</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [{b}] = [{a:<span class="hljs-number"><span class="hljs-number">3</span></span>, b:<span class="hljs-number"><span class="hljs-number">4</span></span>} , {<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>, d: <span class="hljs-number"><span class="hljs-number">6</span></span>}]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> {<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>=<span class="hljs-number"><span class="hljs-number">6</span></span>} = {a: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> {d=<span class="hljs-number"><span class="hljs-number">6</span></span>} = {a: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>}; console.log(val1, b, <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>, d) <span class="hljs-comment"><span class="hljs-comment">// 2, 4, 5, 6</span></span></code> </pre> <br>  Todo esto es maravilloso, hasta que se trata de construir expresiones complejas utilizando todas estas caracter칤sticas.  Por ejemplo, en la siguiente expresi칩n, se declaran 4 variables: <code>userName</code> , <code>eventType</code> , <code>eventDate</code> y <code>eventId</code> .  Sus valores se toman de diferentes lugares en la estructura del objeto <code>eventRecord</code> . <br><br><pre> <code class="hljs pgsql">let eventRecord = { <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: { <span class="hljs-type"><span class="hljs-type">name</span></span>: "Ben M", email: "ben@m.com" }, event: "logged in", metadata: { <span class="hljs-type"><span class="hljs-type">date</span></span>: "10-10-2017" }, id: "123" }; let { <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: { <span class="hljs-type"><span class="hljs-type">name</span></span>: userName = "Unknown" }, event: eventType = "Unknown Event", metadata: [<span class="hljs-type"><span class="hljs-type">date</span></span>: eventDate], id: eventId } = obj;</code> </pre> <br>  Comprender dicho c칩digo es casi imposible.  Este problema se puede resolver utilizando un c칩digo mucho m치s legible, si utiliza varias operaciones de desestructuraci칩n o las abandona por completo. <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> eventRecord = { user: { name: <span class="hljs-string"><span class="hljs-string">"Ben M"</span></span>, email: <span class="hljs-string"><span class="hljs-string">"ben@m.com"</span></span> }, <span class="hljs-keyword"><span class="hljs-keyword">event</span></span>: <span class="hljs-string"><span class="hljs-string">"logged in"</span></span>, metadata: { date: <span class="hljs-string"><span class="hljs-string">"10-10-2017"</span></span> }, id: <span class="hljs-string"><span class="hljs-string">"123"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> userName = eventRecord.user.userName || <span class="hljs-string"><span class="hljs-string">'Unknown'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> eventDate = eventRecord.metadata.date; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>:eventType=<span class="hljs-string"><span class="hljs-string">'UnknownEvent'</span></span>, id:eventId} = eventRecord;</code> </pre> <br>  No tengo una directriz clara que indique que la expresi칩n de la asignaci칩n destructiva necesita ser modificada.  Sin embargo, cada vez que miro una expresi칩n similar y no puedo entender instant치neamente qu칠 problema resuelve, qu칠 variables se usan en 칠l, entiendo que es hora de simplificar el c칩digo para mejorar su legibilidad. <br><br><h2>  <font color="#3AC1EF">Exportaci칩n predeterminada</font> </h2><br>  ES6 tiene una buena caracter칤stica.  Consiste en c칩mo sus desarrolladores abordaron la estandarizaci칩n de lo que se hizo anteriormente con la ayuda de varias bibliotecas, a menudo compitiendo entre s칤.  Entonces en la especificaci칩n aparecieron clases, promesas, m칩dulos.  Esto es todo lo que la comunidad de desarrolladores de JS usaba antes de ES6, encontr치ndolo en bibliotecas de terceros.  Por ejemplo, los m칩dulos ES6 son un excelente sustituto de lo que se extendi칩 a la guerra de formatos AMD / CommonJS y proporcionan una sintaxis conveniente para organizar las importaciones. <br><br>  Los m칩dulos ES6 admiten dos formas principales de exportar valores: exportaci칩n con nombre y exportaci칩n predeterminada, o exportaci칩n predeterminada: <br><br><pre> <code class="hljs vhdl">const mainValue = <span class="hljs-symbol"><span class="hljs-symbol">'This</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> export export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> mainValue export const secondaryValue = <span class="hljs-symbol"><span class="hljs-symbol">'This</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> a secondary value; export const secondaryValue2 = <span class="hljs-symbol"><span class="hljs-symbol">'This</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> another secondary value;</code> </pre> <br>  Un m칩dulo puede usar varios comandos de exportaci칩n con nombre, pero solo un comando de exportaci칩n predeterminado.  Al importar lo que se export칩 utilizando el comando de exportaci칩n predeterminado, en el archivo de importaci칩n, puede asignar cualquier nombre a lo que se exporta de forma predeterminada, ya que no se buscan nombres durante esta operaci칩n.  Al usar la exportaci칩n con nombre, debe usar los nombres de las variables de los archivos de exportaci칩n, aunque tambi칠n es posible cambiar el nombre. <br><br><pre> <code class="hljs pgsql">//   <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> renamedMainValue <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./the-above-example'</span></span>; //   <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {secondaryValue} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./the-above-example'</span></span>; //     <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {secondaryValue <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> otherValue} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./the-above-example'</span></span>;</code> </pre> <br>  La exportaci칩n predeterminada disfrut칩 de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una atenci칩n especial por parte de los desarrolladores del</a> est치ndar ES6, y crearon intencionalmente una sintaxis m치s simple.  Sin embargo, en la pr치ctica, pude descubrir que usar tecnolog칤a de exportaci칩n con nombre es preferible por las siguientes razones. <br><br><ol><li>  Cuando se usa la exportaci칩n con nombre, los nombres de las variables exportadas, por defecto, corresponden a los nombres de las variables importadas, lo que simplifica su b칰squeda de aquellos que no usan herramientas de desarrollo inteligentes. </li><li>  Cuando se usan exportaciones con nombre, los programadores que usan herramientas de desarrollo inteligente obtienen caracter칤sticas tan convenientes como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la importaci칩n autom치tica</a> . </li><li>  Las exportaciones con nombre le permiten exportar uniformemente desde los m칩dulos todo lo que desee, en las cantidades correctas.  La exportaci칩n predeterminada limita al desarrollador a exportar solo un valor 칰nico.  Como soluci칩n alternativa, puede aplicar la exportaci칩n de un objeto con varias propiedades.  Sin embargo, este enfoque pierde el valor del algoritmo de sacudidas de 치rboles utilizado para reducir el tama침o de las aplicaciones JS creadas por algo como webpack.  El uso exclusivo de m칩dulos con nombre con nombre simplifica el trabajo. </li></ol><br>  En general, se puede observar que nombrar entidades es una buena pr치ctica, ya que le permite identificarlas de manera 칰nica tanto en el c칩digo como en las conversaciones sobre este c칩digo.  Por eso uso la exportaci칩n con nombre. <br><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  Acaba de enterarse de las caracter칤sticas de ES6, que, seg칰n el autor de este material, no tienen 칠xito.  Quiz치s te unas a esta opini칩n, quiz치s no.  Cualquier lenguaje de programaci칩n es un sistema complejo, cuyas capacidades se pueden ver desde diferentes puntos de vista.  Sin embargo, esperamos que este art칤culo sea 칰til para todos aquellos que buscan escribir c칩digo claro y de alta calidad. <br><br>  <b>Estimados lectores!</b>  쮿ay algo en JavaScript moderno que intentes evitar? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/ri/aw/tq/riawtqey48mow3zanijqzhgifjg.jpeg"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es417383/">https://habr.com/ru/post/es417383/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es417369/index.html">15 herramientas para el arsenal de trabajo del gerente de producto</a></li>
<li><a href="../es417373/index.html">Almacenamiento ZFS, entornos de espera y prueba</a></li>
<li><a href="../es417375/index.html">15 m칠todos de elementos HTML que probablemente nunca has escuchado</a></li>
<li><a href="../es417377/index.html">Por qu칠 no deber칤as usar Google Cloud</a></li>
<li><a href="../es417379/index.html">Nuevo motor de cohete propulsor s칩lido para Vega-C y Ariane 6</a></li>
<li><a href="../es417385/index.html">C칩mo me mud칠 ... a casa, o mi respuesta al autor del art칤culo sobre "harina despiadada"</a></li>
<li><a href="../es417389/index.html">Efecto de lente de cambio de inclinaci칩n</a></li>
<li><a href="../es417391/index.html">Extensi칩n web entre navegadores para scripts personalizados Parte 4</a></li>
<li><a href="../es417393/index.html">C칩mo creamos un sistema que asigna descuentos a los clientes en funci칩n de las caracter칤sticas individuales</a></li>
<li><a href="../es417395/index.html">Pruebas de extremo a extremo: qu칠, por qu칠, por qu칠</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>