<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤸 📞 📏 JavaScript ES6: Debilidades 🏁 👴🏼 😔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En junio de 2018, el estándar ECMAScript 2015 ( ES6 ) celebró su tercer aniversario. En ES6, en primer lugar, han aparecido muchas características nue...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript ES6: Debilidades</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/417383/">  En junio de 2018, el estándar ECMAScript 2015 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ES6</a> ) celebró su tercer aniversario.  En ES6, en primer lugar, han aparecido muchas características nuevas de JavaScript, y en segundo lugar, una nueva era de desarrollo del lenguaje comienza con este estándar.  Además, esta fue la última versión a gran escala de JS, ya que ahora TC39 aplica el esquema para emitir pequeños números anuales del estándar, y no lo vuelve a sacar cada pocos años. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/ts/9f/9h/ts9f9hvjwknbldjzd40effqpdbs.jpeg"></a> <br><br>  Los últimos 4 años, ES6, con bastante justificación, ha atraído la atención universal.  El autor del material, cuya traducción publicamos hoy, dice que todo este tiempo, gracias a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Babel</a> , escribió todo el código utilizando la versión moderna de las especificaciones JS.  Él cree que ha pasado suficiente tiempo para analizar críticamente las nuevas características de ES6.  En particular, está interesado en lo que usó durante algún tiempo y luego dejó de usarlo porque empeoró su código. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Sobre las debilidades de JS</font> </h2><br>  Douglas Crockford, en su <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">libro</a> JavaScript: Fortalezas, también escribió sobre lo que puede considerarse debilidades del lenguaje.  Esto es algo que, en su opinión, no vale la pena usar.  Afortunadamente, entre las innovaciones de ES6 no hay nada tan desagradable como algunas de las viejas características problemáticas de JS, como el operador de igualdad laxa que realiza la conversión de tipo implícita, la función <code>eval()</code> y la instrucción <code>with</code> .  Las nuevas características de ES6 están diseñadas mucho mejor.  Sin embargo, hay algunas cosas en él que evito.  Esas características que están en mi lista de "debilidades" de JS están en esta lista por las siguientes razones: <br><br><ul><li>  Son, en esencia, "trampas".  Es decir, parece que están diseñados para realizar ciertas acciones y, en la mayoría de los casos, funcionan según lo esperado.  Sin embargo, a veces se comportan inesperadamente, lo que puede conducir fácilmente a errores. </li><li>  Aumentan el volumen del idioma a cambio de pequeños beneficios.  Tales oportunidades le dan al desarrollador algunas pequeñas ventajas, pero requieren que alguien que está tratando de descifrar su código tenga conocimiento de ciertos mecanismos, generalmente ocultos en algún lugar.  Esto es doblemente cierto para las capacidades de la API, cuando el uso de esta función significa que otro código que interactúa con el código escrito por un determinado desarrollador debe conocer la aplicación de esta función de la API. </li></ul><br>  Ahora, guiados por estas consideraciones, hablemos de las debilidades de ES6. <br><br><h2>  <font color="#3AC1EF">Palabra clave const</font> </h2><br>  Antes de ES6, las variables en JavaScript podían declararse utilizando la palabra clave <code>var</code> .  Además, las variables no podían declararse en absoluto, entonces, incluso si se usan en funciones, entran en el ámbito global.  Las propiedades de los objetos pueden desempeñar el papel de variables, y las funciones se declaran utilizando la palabra clave <code>function</code> .  La palabra clave <code>var</code> tiene ciertas características. <br><br>  Por lo tanto, le permite crear variables que se agregan al objeto global, o aquellas cuyo alcance está limitado por las funciones.  Sin embargo, la palabra clave <code>var</code> no presta atención a los bloques de código.  Además, puede hacer referencia a una variable declarada utilizando la palabra clave <code>var</code> en el código ubicado antes del comando para su declaración.  Este fenómeno se conoce como elevar variables.  Estas características, si no se tienen en cuenta, pueden provocar errores.  Para rectificar la situación, ES6 introdujo dos nuevas palabras clave para declarar variables: <code>let</code> y <code>const</code> .  Resolvieron los principales problemas <code>var</code> .  Es decir, estamos hablando del hecho de que las variables declaradas usando estas palabras clave tienen un alcance de bloque, como resultado, por ejemplo, una variable declarada en un bucle no es visible fuera de ella.  Además, el uso de <code>let</code> y <code>const</code> no permite acceder a las variables antes de declararlas.  Esto dará como resultado un error de <code>ReferenceError</code> .  Este fue un gran paso adelante.  Sin embargo, la aparición de dos nuevas palabras clave, así como sus características, generaron confusión adicional. <br><br>  El valor de una variable (constante) declarada con la palabra clave <code>const</code> no se puede sobrescribir después de la declaración.  Esta es la única diferencia entre <code>const</code> y <code>let</code> .  Esta nueva oportunidad parece útil y realmente puede aportar algún beneficio.  El problema es la palabra clave <code>const</code> sí.  La forma en que se comportan las constantes declaradas al usarlo no corresponde a lo que la mayoría de los desarrolladores asocian con el concepto de "constante". <br><br><pre> <code class="hljs pgsql">const <span class="hljs-keyword"><span class="hljs-keyword">CONSTANT</span></span> = <span class="hljs-number"><span class="hljs-number">123</span></span>; //      "TypeError: invalid assignment to const `CONSTANT`" <span class="hljs-keyword"><span class="hljs-keyword">CONSTANT</span></span> = <span class="hljs-number"><span class="hljs-number">345</span></span>; const CONSTANT_ARR = [] CONSTANT_ARR.push(<span class="hljs-number"><span class="hljs-number">1</span></span>) //     [<span class="hljs-number"><span class="hljs-number">1</span></span>]  -    console.log(CONSTANT_ARR)</code> </pre> <br>  El uso de la palabra clave <code>const</code> evita que se escriba un nuevo valor en una constante, pero no hace que los objetos a los que hacen referencia tales constantes sean inmutables.  Esta característica proporciona una protección deficiente contra cambios de valores cuando se trabaja con la mayoría de los tipos de datos.  Como resultado, debido al hecho de que el uso de <code>const</code> puede generar confusión y al hecho de que si la palabra clave <code>let</code> está presente, la presencia de <code>const</code> parece redundante, decidí usar siempre <code>let</code> . <br><br><h2>  <font color="#3AC1EF">Cadenas de plantillas etiquetadas</font> </h2><br>  La palabra clave <code>const</code> es un ejemplo de cómo una especificación crea demasiadas formas de resolver muy pocos problemas.  En el caso de cadenas de plantillas etiquetadas, tenemos la situación opuesta.  El comité TC39 consideró la sintaxis de tales cadenas como una forma de resolver la interpolación de cadenas y cadenas multilíneas.  Luego decidieron ampliar esta oportunidad mediante el uso de macros. <br><br>  Si nunca antes ha visto cadenas de patrones etiquetados, tenga en cuenta que son un poco como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">decoradores de</a> cadenas.  Aquí hay un ejemplo de cómo trabajar con ellos con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MDN</a> : <br><br><pre> <code class="hljs powershell">var person = <span class="hljs-string"><span class="hljs-string">'Mike'</span></span>; var age = <span class="hljs-number"><span class="hljs-number">28</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myTag</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(strings, personExp, ageExp)</span></span></span></span> { var str0 = strings[<span class="hljs-number"><span class="hljs-number">0</span></span>]; // <span class="hljs-string"><span class="hljs-string">"that "</span></span> var str1 = strings[<span class="hljs-number"><span class="hljs-number">1</span></span>]; // <span class="hljs-string"><span class="hljs-string">" is a "</span></span> //  (  ) //     , //  ,      . // var str2 = strings[<span class="hljs-number"><span class="hljs-number">2</span></span>]; var ageStr; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ageExp &gt; <span class="hljs-number"><span class="hljs-number">99</span></span>){   ageStr = <span class="hljs-string"><span class="hljs-string">'centenarian'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {   ageStr = <span class="hljs-string"><span class="hljs-string">'youngster'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str0 + personExp + str1 + ageStr; } var output = myTag`that <span class="hljs-variable"><span class="hljs-variable">$</span></span>{ person } is a <span class="hljs-variable"><span class="hljs-variable">$</span></span>{ age }`; console.log(output); // that Mike is a youngster</code> </pre> <br>  Las cadenas de plantillas etiquetadas no se pueden llamar completamente inútiles.  Aquí hay una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">descripción general de</a> algunos de sus usos.  Por ejemplo, son útiles para borrar el código HTML.  Y, en este momento, su aplicación demuestra el enfoque más preciso en situaciones en las que necesita realizar la misma operación en todos los datos de entrada de una plantilla de cadena arbitraria.  Sin embargo, esto es relativamente raro, puede hacer lo mismo con la API adecuada (aunque dicha solución es más larga).  Y, para resolver la mayoría de los problemas, usar la API no será peor que usar cadenas de plantillas etiquetadas.  Esta característica no agrega nuevas características al idioma.  Agrega nuevos enfoques para trabajar con datos que deberían ser familiares para aquellos que tienen que leer el código escrito utilizando cadenas de plantillas etiquetadas.  Y me esfuerzo por asegurarme de que mi código permanezca lo más limpio y comprensible posible. <br><br><h2>  <font color="#3AC1EF">Expresiones de asignación destructiva rediseñadas</font> </h2><br>  Algunas características del lenguaje se ven geniales cuando se usan para resolver tareas simples, sin embargo, cuando las tareas se vuelven más complejas, estas características pueden salirse de control.  Por ejemplo, me gusta el operador condicional ternario: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> conferenceCost = isStudent ? <span class="hljs-number"><span class="hljs-number">50</span></span> : <span class="hljs-number"><span class="hljs-number">200</span></span></code> </pre> <br>  Sin embargo, el código escrito con su ayuda, se vuelve difícil de entender si, usando este operador, comienza a usar construcciones anidadas: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> conferenceCost = isStudent ? hasDiscountCode ? <span class="hljs-number"><span class="hljs-number">25</span></span> : <span class="hljs-number"><span class="hljs-number">50</span></span> : hasDiscountCode ? <span class="hljs-number"><span class="hljs-number">100</span></span> : <span class="hljs-number"><span class="hljs-number">200</span></span>;</code> </pre> <br>  Lo mismo puede decirse de la asignación destructiva.  Este mecanismo le permite extraer los valores de variables de objetos o matrices: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> {a} = {<span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [b] = [<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a, b) <span class="hljs-comment"><span class="hljs-comment">// 2, 4</span></span></code> </pre> <br>  Además, al usarlo, puede cambiar el nombre de las variables, obtener valores anidados, establecer valores predeterminados: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> {a: val1} = {a: <span class="hljs-number"><span class="hljs-number">2</span></span>, b: <span class="hljs-number"><span class="hljs-number">3</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [{b}] = [{a:<span class="hljs-number"><span class="hljs-number">3</span></span>, b:<span class="hljs-number"><span class="hljs-number">4</span></span>} , {<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>, d: <span class="hljs-number"><span class="hljs-number">6</span></span>}]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> {<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>=<span class="hljs-number"><span class="hljs-number">6</span></span>} = {a: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> {d=<span class="hljs-number"><span class="hljs-number">6</span></span>} = {a: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>}; console.log(val1, b, <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>, d) <span class="hljs-comment"><span class="hljs-comment">// 2, 4, 5, 6</span></span></code> </pre> <br>  Todo esto es maravilloso, hasta que se trata de construir expresiones complejas utilizando todas estas características.  Por ejemplo, en la siguiente expresión, se declaran 4 variables: <code>userName</code> , <code>eventType</code> , <code>eventDate</code> y <code>eventId</code> .  Sus valores se toman de diferentes lugares en la estructura del objeto <code>eventRecord</code> . <br><br><pre> <code class="hljs pgsql">let eventRecord = { <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: { <span class="hljs-type"><span class="hljs-type">name</span></span>: "Ben M", email: "ben@m.com" }, event: "logged in", metadata: { <span class="hljs-type"><span class="hljs-type">date</span></span>: "10-10-2017" }, id: "123" }; let { <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: { <span class="hljs-type"><span class="hljs-type">name</span></span>: userName = "Unknown" }, event: eventType = "Unknown Event", metadata: [<span class="hljs-type"><span class="hljs-type">date</span></span>: eventDate], id: eventId } = obj;</code> </pre> <br>  Comprender dicho código es casi imposible.  Este problema se puede resolver utilizando un código mucho más legible, si utiliza varias operaciones de desestructuración o las abandona por completo. <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> eventRecord = { user: { name: <span class="hljs-string"><span class="hljs-string">"Ben M"</span></span>, email: <span class="hljs-string"><span class="hljs-string">"ben@m.com"</span></span> }, <span class="hljs-keyword"><span class="hljs-keyword">event</span></span>: <span class="hljs-string"><span class="hljs-string">"logged in"</span></span>, metadata: { date: <span class="hljs-string"><span class="hljs-string">"10-10-2017"</span></span> }, id: <span class="hljs-string"><span class="hljs-string">"123"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> userName = eventRecord.user.userName || <span class="hljs-string"><span class="hljs-string">'Unknown'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> eventDate = eventRecord.metadata.date; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>:eventType=<span class="hljs-string"><span class="hljs-string">'UnknownEvent'</span></span>, id:eventId} = eventRecord;</code> </pre> <br>  No tengo una directriz clara que indique que la expresión de la asignación destructiva necesita ser modificada.  Sin embargo, cada vez que miro una expresión similar y no puedo entender instantáneamente qué problema resuelve, qué variables se usan en él, entiendo que es hora de simplificar el código para mejorar su legibilidad. <br><br><h2>  <font color="#3AC1EF">Exportación predeterminada</font> </h2><br>  ES6 tiene una buena característica.  Consiste en cómo sus desarrolladores abordaron la estandarización de lo que se hizo anteriormente con la ayuda de varias bibliotecas, a menudo compitiendo entre sí.  Entonces en la especificación aparecieron clases, promesas, módulos.  Esto es todo lo que la comunidad de desarrolladores de JS usaba antes de ES6, encontrándolo en bibliotecas de terceros.  Por ejemplo, los módulos ES6 son un excelente sustituto de lo que se extendió a la guerra de formatos AMD / CommonJS y proporcionan una sintaxis conveniente para organizar las importaciones. <br><br>  Los módulos ES6 admiten dos formas principales de exportar valores: exportación con nombre y exportación predeterminada, o exportación predeterminada: <br><br><pre> <code class="hljs vhdl">const mainValue = <span class="hljs-symbol"><span class="hljs-symbol">'This</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> export export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> mainValue export const secondaryValue = <span class="hljs-symbol"><span class="hljs-symbol">'This</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> a secondary value; export const secondaryValue2 = <span class="hljs-symbol"><span class="hljs-symbol">'This</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> another secondary value;</code> </pre> <br>  Un módulo puede usar varios comandos de exportación con nombre, pero solo un comando de exportación predeterminado.  Al importar lo que se exportó utilizando el comando de exportación predeterminado, en el archivo de importación, puede asignar cualquier nombre a lo que se exporta de forma predeterminada, ya que no se buscan nombres durante esta operación.  Al usar la exportación con nombre, debe usar los nombres de las variables de los archivos de exportación, aunque también es posible cambiar el nombre. <br><br><pre> <code class="hljs pgsql">//   <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> renamedMainValue <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./the-above-example'</span></span>; //   <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {secondaryValue} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./the-above-example'</span></span>; //     <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {secondaryValue <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> otherValue} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./the-above-example'</span></span>;</code> </pre> <br>  La exportación predeterminada disfrutó de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una atención especial por parte de los desarrolladores del</a> estándar ES6, y crearon intencionalmente una sintaxis más simple.  Sin embargo, en la práctica, pude descubrir que usar tecnología de exportación con nombre es preferible por las siguientes razones. <br><br><ol><li>  Cuando se usa la exportación con nombre, los nombres de las variables exportadas, por defecto, corresponden a los nombres de las variables importadas, lo que simplifica su búsqueda de aquellos que no usan herramientas de desarrollo inteligentes. </li><li>  Cuando se usan exportaciones con nombre, los programadores que usan herramientas de desarrollo inteligente obtienen características tan convenientes como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la importación automática</a> . </li><li>  Las exportaciones con nombre le permiten exportar uniformemente desde los módulos todo lo que desee, en las cantidades correctas.  La exportación predeterminada limita al desarrollador a exportar solo un valor único.  Como solución alternativa, puede aplicar la exportación de un objeto con varias propiedades.  Sin embargo, este enfoque pierde el valor del algoritmo de sacudidas de árboles utilizado para reducir el tamaño de las aplicaciones JS creadas por algo como webpack.  El uso exclusivo de módulos con nombre con nombre simplifica el trabajo. </li></ol><br>  En general, se puede observar que nombrar entidades es una buena práctica, ya que le permite identificarlas de manera única tanto en el código como en las conversaciones sobre este código.  Por eso uso la exportación con nombre. <br><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  Acaba de enterarse de las características de ES6, que, según el autor de este material, no tienen éxito.  Quizás te unas a esta opinión, quizás no.  Cualquier lenguaje de programación es un sistema complejo, cuyas capacidades se pueden ver desde diferentes puntos de vista.  Sin embargo, esperamos que este artículo sea útil para todos aquellos que buscan escribir código claro y de alta calidad. <br><br>  <b>Estimados lectores!</b>  ¿Hay algo en JavaScript moderno que intentes evitar? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/ri/aw/tq/riawtqey48mow3zanijqzhgifjg.jpeg"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es417383/">https://habr.com/ru/post/es417383/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es417369/index.html">15 herramientas para el arsenal de trabajo del gerente de producto</a></li>
<li><a href="../es417373/index.html">Almacenamiento ZFS, entornos de espera y prueba</a></li>
<li><a href="../es417375/index.html">15 métodos de elementos HTML que probablemente nunca has escuchado</a></li>
<li><a href="../es417377/index.html">Por qué no deberías usar Google Cloud</a></li>
<li><a href="../es417379/index.html">Nuevo motor de cohete propulsor sólido para Vega-C y Ariane 6</a></li>
<li><a href="../es417385/index.html">Cómo me mudé ... a casa, o mi respuesta al autor del artículo sobre "harina despiadada"</a></li>
<li><a href="../es417389/index.html">Efecto de lente de cambio de inclinación</a></li>
<li><a href="../es417391/index.html">Extensión web entre navegadores para scripts personalizados Parte 4</a></li>
<li><a href="../es417393/index.html">Cómo creamos un sistema que asigna descuentos a los clientes en función de las características individuales</a></li>
<li><a href="../es417395/index.html">Pruebas de extremo a extremo: qué, por qué, por qué</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>