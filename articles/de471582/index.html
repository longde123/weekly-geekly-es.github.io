<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úåüèø üåÅ üëêüèø Lokale Dateien beim Portieren einer Anwendung auf Kubernetes üë©‚Äçüè≠ üò¶ üë©üèΩ‚Äçü§ù‚Äçüë®üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beim Erstellen eines CI / CD-Prozesses mit Kubernetes tritt manchmal das Problem der Inkompatibilit√§t der Anforderungen der neuen Infrastruktur und de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lokale Dateien beim Portieren einer Anwendung auf Kubernetes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/471582/"><img src="https://habrastorage.org/webt/bx/1x/lp/bx1xlp1iax5bfqfwuggugmedkkq.png"><br><br>  Beim Erstellen eines CI / CD-Prozesses mit Kubernetes tritt manchmal das Problem der Inkompatibilit√§t der Anforderungen der neuen Infrastruktur und der darauf √ºbertragenen Anwendung auf.  Insbesondere in der Phase der Anwendungsassemblierung ist es wichtig, <i>ein</i> Image zu erhalten, das in <i>allen</i> Projektumgebungen und Clustern verwendet wird.  Dieses Prinzip liegt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nach Ansicht von Google</a> der korrekten Containerverwaltung zugrunde (unser Techdir hat wiederholt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dar√ºber gesprochen</a> ). <br><br>  Sie werden jedoch niemanden mit Situationen √ºberraschen, in denen ein vorgefertigtes Framework im Site-Code verwendet wird, dessen Verwendung den weiteren Betrieb einschr√§nkt.  Und wenn es in einer ‚Äûnormalen Umgebung‚Äú einfach ist, damit umzugehen, kann diese Art von Verhalten in Kubernetes ein Problem sein, insbesondere wenn Sie es zum ersten Mal antreffen.  Obwohl ein genialer Verstand in der Lage ist, Infrastrukturl√∂sungen anzubieten, die auf den ersten Blick offensichtlich und sogar recht gut erscheinen, ist es wichtig zu bedenken, dass die meisten Situationen <b>architektonisch gel√∂st</b> werden k√∂nnen und sollten. <br><br>  Lassen Sie uns die g√§ngigen Problemumgehungsl√∂sungen zum Speichern von Dateien analysieren, die zu unangenehmen Konsequenzen w√§hrend des Betriebs des Clusters f√ºhren k√∂nnen, und auf einen korrekteren Pfad verweisen. <a name="habracut"></a><br><br><h2>  Statische Speicherung </h2><br>  Betrachten Sie zur Veranschaulichung eine Webanwendung, die einen statischen Generator verwendet, um eine Reihe von Bildern, Stilen und mehr zu erhalten.  Das Yii PHP-Framework verf√ºgt beispielsweise √ºber einen integrierten Asset Manager, der eindeutige Verzeichnisnamen generiert.  Dementsprechend ist die Ausgabe eine Reihe von sich absichtlich nicht √ºberschneidenden Pfaden f√ºr die Standortstatik (dies wurde aus mehreren Gr√ºnden durchgef√ºhrt - zum Beispiel, um Duplikate zu vermeiden, wenn dieselbe Ressource mit vielen Komponenten verwendet wird).  Wenn Sie also zum ersten Mal auf das Webressourcenmodul zugreifen, werden sofort statische Daten mit einem gemeinsamen Stammverzeichnis erstellt und angeordnet (in der Tat h√§ufig Symlinks, aber dazu sp√§ter mehr), das f√ºr diese Bereitstellung eindeutig ist: <br><br><ul><li> <code>webroot/assets/2072c2df/css/‚Ä¶</code> </li> <li> <code>webroot/assets/2072c2df/images/‚Ä¶</code> </li> <li> <code>webroot/assets/2072c2df/js/‚Ä¶</code> </li> </ul><br>  Womit ist das in Bezug auf einen Cluster behaftet? <br><br><h3>  Einfachstes Beispiel </h3><br>  Nehmen wir einen ziemlich h√§ufigen Fall, in dem PHP mit Nginx konfrontiert ist, um Statiken zu verteilen und einfache Abfragen zu bearbeiten.  Der einfachste Weg ist die <i>Bereitstellung</i> mit zwei Containern: <br><br><pre> <code class="plaintext hljs">apiVersion: apps/v1 kind: Deployment metadata: name: site spec: selector: matchLabels: component: backend template: metadata: labels: component: backend spec: volumes: - name: nginx-config configMap: name: nginx-configmap containers: - name: php image: own-image-with-php-backend:v1.0 command: ["/usr/local/sbin/php-fpm","-F"] workingDir: /var/www - name: nginx image: nginx:1.16.0 command: ["/usr/sbin/nginx", "-g", "daemon off;"] volumeMounts: - name: nginx-config mountPath: /etc/nginx/conf.d/default.conf subPath: nginx.conf</code> </pre> <br>  In vereinfachter Form lautet die Nginx-Konfiguration wie folgt: <br><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: ConfigMap metadata: name: "nginx-configmap" data: nginx.conf: | server { listen 80; server_name _; charset utf-8; root /var/www; access_log /dev/stdout; error_log /dev/stderr; location / { index index.php; try_files $uri $uri/ /index.php?$args; } location ~ \.php$ { fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; include fastcgi_params; } }</code> </pre> <br>  Wenn Sie zum ersten Mal in einem Container mit PHP auf die Site zugreifen, werden Assets angezeigt.  Bei zwei Containern im selben Pod wei√ü nginx jedoch nichts √ºber diese statischen Dateien, die ihnen (je nach Konfiguration) √ºbergeben werden sollten.  Infolgedessen wird dem Client der Fehler 404 f√ºr alle Anforderungen an CSS- und JS-Dateien angezeigt. Die einfachste L√∂sung besteht darin, ein gemeinsames Verzeichnis f√ºr Container zu organisieren.  Eine primitive Option ist das generische <code>emptyDir</code> : <br><br><pre> <code class="plaintext hljs">apiVersion: apps/v1 kind: Deployment metadata: name: site spec: selector: matchLabels: component: backend template: metadata: labels: component: backend spec: volumes: - name: assets emptyDir: {} - name: nginx-config configMap: name: nginx-configmap containers: - name: php image: own-image-with-php-backend:v1.0 command: ["/usr/local/sbin/php-fpm","-F"] workingDir: /var/www volumeMounts: - name: assets mountPath: /var/www/assets - name: nginx image: nginx:1.16.0 command: ["/usr/sbin/nginx", "-g", "daemon off;"] volumeMounts: - name: assets mountPath: /var/www/assets - name: nginx-config mountPath: /etc/nginx/conf.d/default.conf subPath: nginx.conf</code> </pre> <br>  Jetzt werden die im Container generierten statischen Dateien von nginx korrekt angegeben.  Aber ich m√∂chte Sie daran erinnern, dass dies eine primitive L√∂sung ist, was bedeutet, dass sie alles andere als ideal ist und ihre eigenen Nuancen und M√§ngel aufweist, die nachstehend er√∂rtert werden. <br><br><h3>  Erweiterter Speicher </h3><br>  Stellen Sie sich nun eine Situation vor, in der ein Benutzer eine Site besuchte, eine Seite mit den im Container verf√ºgbaren Stilen lud und w√§hrend er diese Seite las, den Container erneut bereitstellten.  Das Asset-Verzeichnis ist leer geworden und erfordert eine Anforderung an PHP, um neue zu generieren.  Auch danach sind Links zu alten Statiken veraltet, was zu Fehlern bei der Anzeige von Statiken f√ºhrt. <br><br>  Dar√ºber hinaus haben wir h√∂chstwahrscheinlich ein mehr oder weniger geladenes Projekt, was bedeutet, dass eine Kopie der Anwendung nicht ausreicht: <br><br><ul><li>  Skalieren Sie die <i>Bereitstellung</i> auf zwei Replikate. </li><li>  Wenn Sie zum ersten Mal in einem Replikat auf die Site zugreifen, wurden Assets erstellt. </li><li>  Irgendwann entschied sich ingress (um die Last auszugleichen), eine Anfrage f√ºr ein zweites Replikat zu senden, und diese Assets sind noch nicht vorhanden.  Oder vielleicht sind sie nicht mehr da, weil wir <code>RollingUpdate</code> und derzeit eine Bereitstellung durchf√ºhren. </li></ul><br>  Im Allgemeinen ist das Ergebnis wieder ein Fehler. <br><br>  Um die alten Assets nicht zu verlieren, k√∂nnen Sie <code>emptyDir</code> in <code>hostPath</code> √§ndern und die Statik physisch zum Clusterknoten hinzuf√ºgen.  Dieser Ansatz ist schlecht, da wir mit unserer Anwendung tats√§chlich <b>an einen bestimmten Clusterknoten binden</b> m√ºssen, da das Verzeichnis beim Verschieben auf andere Knoten nicht die erforderlichen Dateien enth√§lt.  Oder es ist eine Hintergrundsynchronisation des Verzeichnisses zwischen Knoten erforderlich. <br><br>  Was sind die L√∂sungen? <br><br><ol><li>  Wenn Hardware und Ressourcen dies zulassen, k√∂nnen Sie mit <a href="">cephfs</a> ein <a href="">gleicherma√üen</a> zug√§ngliches Verzeichnis f√ºr die Anforderungen der Statik organisieren.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">In der offiziellen Dokumentation werden</a> SSDs, mindestens dreifache Replikation und eine robuste ‚Äûdicke‚Äú Verbindung zwischen Clusterknoten empfohlen. </li><li>  Eine weniger anspruchsvolle Option w√§re die Organisation eines NFS-Servers.  Dann m√ºssen Sie jedoch die m√∂gliche Verl√§ngerung der Antwortzeit auf die Verarbeitung von Anforderungen durch den Webserver ber√ºcksichtigen, und die Fehlertoleranz l√§sst zu w√ºnschen √ºbrig.  Die Folgen des Ausfalls sind katastrophal: Der Verlust des Reittiers zerst√∂rt den Cluster unter dem Ansturm der LA-Ladung, die in den Himmel rast, zu Tode. </li></ol><br>  Unter anderem ist f√ºr alle Optionen zum Erstellen eines dauerhaften Speichers eine <b>Hintergrundbereinigung</b> veralteter Dateigruppen erforderlich, die sich √ºber einen bestimmten Zeitraum angesammelt haben.  Vor Containern mit PHP k√∂nnen Sie <i>DaemonSet</i> aus dem Caching von <i>Nginx ablegen</i> , in dem Kopien von Assets f√ºr eine begrenzte Zeit gespeichert werden.  Dieses Verhalten kann einfach mithilfe von <code>proxy_cache</code> mit einer Speichertiefe in Tagen oder Gigabyte Festplattenspeicher konfiguriert werden. <br><br>  Die Kombination dieser Methode mit den oben genannten verteilten Dateisystemen bietet ein gro√ües Vorstellungsfeld, das nur das Budget und das technische Potenzial derjenigen einschr√§nkt, die sie implementieren und unterst√ºtzen.  Aus Erfahrung sagen wir, je einfacher das System ist, desto stabiler funktioniert es.  Durch das Hinzuf√ºgen solcher Schichten wird es viel schwieriger, die Infrastruktur zu warten, und gleichzeitig nimmt der Zeitaufwand f√ºr Diagnose und Wiederherstellung im Falle von Fehlern zu. <br><br><h3>  Empfehlung </h3><br>  Wenn Ihnen die Implementierung der vorgeschlagenen Speicheroptionen ebenfalls ungerechtfertigt erscheint (kompliziert, teuer ...), sollten Sie die Situation von der anderen Seite betrachten.  Wenn Sie sich mit der Architektur des Projekts <b>befassen</b> und <b>das Problem im Code</b> durch Verkn√ºpfen mit einer statischen Datenstruktur im Bild <b>beseitigen</b> , erhalten Sie eine eindeutige Definition des Inhalts oder des Verfahrens zum ‚ÄûAufw√§rmen‚Äú und / oder Vorkompilieren von Assets in der Phase der Bildzusammenstellung.  So erhalten wir f√ºr alle Umgebungen und Replikate der laufenden Anwendung ein absolut vorhersehbares Verhalten und denselben Satz von Dateien. <br><br>  Wenn wir zu einem bestimmten Beispiel mit dem Yii-Framework zur√ºckkehren und nicht auf dessen Struktur eingehen (was nicht der Zweck des Artikels ist), gen√ºgt es, auf zwei g√§ngige Ans√§tze hinzuweisen: <br><br><ol><li>  √Ñndern Sie den Prozess zum Zusammenstellen des Bildes so, dass Assets an einem vorhersehbaren Ort platziert werden.  Bieten / implementieren Sie also Erweiterungen wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">yii2-static-Assets</a> . </li><li>  Definieren Sie bestimmte Hashes f√ºr Asset-Verzeichnisse, wie beispielsweise in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieser Pr√§sentation beschrieben</a> (beginnend mit Folie 35).  √úbrigens empfiehlt der Autor des Berichts letztendlich (und nicht ohne Grund!) Nach dem Zusammenstellen der Assets auf dem Build-Server, sie in ein zentrales Repository (wie S3) hochzuladen, vor das das CDN gestellt wird. </li></ol><br><h2>  Herunterladbare Dateien </h2><br>  Ein weiterer Fall, der beim √úbertragen einer Anwendung auf einen Kubernetes-Cluster mit Sicherheit ausgel√∂st wird, ist das Speichern von Benutzerdateien im Dateisystem.  Zum Beispiel haben wir wieder eine PHP-Anwendung, die Dateien √ºber das Upload-Formular akzeptiert, dabei etwas mit ihnen macht und sie zur√ºckgibt. <br><br>  Der Ort, an dem diese Dateien in Kubernetes Realit√§ten abgelegt werden sollen, sollte allen Anwendungsreplikaten gemeinsam sein.  Abh√§ngig von der Komplexit√§t der Anwendung und der Notwendigkeit, die Persistenz dieser Dateien zu organisieren, kann ein solcher Ort die oben genannten Optionen f√ºr gemeinsam genutzte Ger√§te sein, aber wie wir sehen, haben sie ihre Nachteile. <br><br><h3>  Empfehlung </h3><br>  Eine L√∂sung besteht darin <b>, einen S3-kompatiblen Speicher zu verwenden</b> (selbst wenn es sich um eine selbst gehostete Kategorie wie minio handelt).  Der √úbergang zur Arbeit mit S3 erfordert √Ñnderungen <i>auf Codeebene</i> , und wir haben bereits <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">geschrieben,</a> wie der Inhalt im Frontend zur√ºckgegeben wird. <br><br><h2>  Benutzerdefinierte Sitzungen </h2><br>  Unabh√§ngig davon ist die Organisation der Speicherung von Benutzersitzungen zu beachten.  Oft sind dies auch Dateien auf der Festplatte, die im Kontext von Kubernetes zu st√§ndigen Autorisierungsanforderungen des Benutzers f√ºhren, wenn seine Anforderung in einen anderen Container f√§llt. <br><br>  Ein Teil des Problems wird gel√∂st, indem <code>stickySessions</code> on <code>stickySessions</code> <i>(die Funktion wird von allen g√§ngigen Ingress-Controllern unterst√ºtzt - weitere Informationen finden Sie</i> in <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unserem Test</a> ) unterst√ºtzt</i> wird, um den Benutzer mit der Anwendung an einen bestimmten Pod zu binden: <br><br><pre> <code class="plaintext hljs">apiVersion: networking.k8s.io/v1beta1 kind: Ingress metadata: name: nginx-test annotations: nginx.ingress.kubernetes.io/affinity: "cookie" nginx.ingress.kubernetes.io/session-cookie-name: "route" nginx.ingress.kubernetes.io/session-cookie-expires: "172800" nginx.ingress.kubernetes.io/session-cookie-max-age: "172800" spec: rules: - host: stickyingress.example.com http: paths: - backend: serviceName: http-svc servicePort: 80 path: /</code> </pre> <br>  Dies erspart Ihnen jedoch keine wiederholten Bereitstellungen. <br><br><h3>  Empfehlung </h3><br>  Ein korrekterer Weg w√§re, die Anwendung auf das <b>Speichern von Sitzungen in Memcached, Redis und √§hnlichen L√∂sungen zu √ºbertragen</b> - im Allgemeinen sollten Sie die Dateioptionen vollst√§ndig aufgeben. <br><br><h2>  Fazit </h2><br>  Die im Text ber√ºcksichtigten Infrastrukturl√∂sungen sind nur im Format tempor√§rer ‚ÄûKr√ºcken‚Äú anwendbar (was auf Englisch als Problemumgehung sch√∂ner klingt).  Sie k√∂nnen in den fr√ºhen Phasen der Anwendungsmigration zu Kubernetes relevant sein, sollten jedoch nicht "gerootet" werden. <br><br>  Der allgemein empfohlene Weg besteht darin, sie zugunsten einer architektonischen Verfeinerung der Anwendung gem√§√ü der bereits bekannten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">12-Faktor-App zu entfernen</a> .  Dies - die Anwendung in eine zustandslose Form zu bringen - bedeutet jedoch zwangsl√§ufig, dass √Ñnderungen im Code erforderlich sind, und es ist wichtig, ein Gleichgewicht zwischen den F√§higkeiten / Anforderungen des Unternehmens und den Aussichten f√ºr die Implementierung und Aufrechterhaltung des gew√§hlten Pfades zu finden. <br><br><h2>  PS </h2><br>  Lesen Sie auch in unserem Blog: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Proxing von Dateien aus AWS S3 mit Nginx-Tools</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">7 Best Practices f√ºr den Betrieb von Containern nach Google</a> "; </li><li>  ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">7 Prinzipien f√ºr das Entwerfen von containergest√ºtzten Anwendungen</a> ‚Äú <i>(von Red Hat)</i> ; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">7 fehlende Faktoren im 12-Faktor-App-Ansatz</a> ." </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de471582/">https://habr.com/ru/post/de471582/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de471570/index.html">√úberholte Smartphones: Gewinn oder T√§uschung?</a></li>
<li><a href="../de471572/index.html">Mehrere API-Anforderungen mit mergeMap und forkJoin anstelle von subscribe</a></li>
<li><a href="../de471574/index.html">Oracle Database 19c: Grundlegende Unterschiede zu fr√ºheren Versionen</a></li>
<li><a href="../de471576/index.html">Wie QS eine effektive Interaktion mit Entwicklern aufbaut. Ein m√∂glicher Weg</a></li>
<li><a href="../de471580/index.html">Konferenz f√ºr Plattformentwickler von Stripe, Intercom, JetBrains, Miro, ManyChat, Wrike, Targetprocess usw.</a></li>
<li><a href="../de471588/index.html">Industrielles Internet der Dinge: √úber erfolgreiche F√§lle sprechen</a></li>
<li><a href="../de471590/index.html">Die ersten sechs Monate als Teamleiter: Wie man nicht verr√ºckt wird, wenn alles schlecht zu sein scheint</a></li>
<li><a href="../de471592/index.html">MacOS 10.15 unterst√ºtzt keine 32-Bit-Apps mehr. Was kannst du tun</a></li>
<li><a href="../de471594/index.html">Beeline Kazakhstan und Slerm veranstalten vom 6. bis 7. November den Beeline DevOps Day in Almaty</a></li>
<li><a href="../de471596/index.html">MacOS 10.15 unterst√ºtzt keine 32-Bit-Anwendungen mehr. Was kannst du tun</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>