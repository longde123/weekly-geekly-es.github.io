<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíâ üöÜ üë©üèΩ‚ÄçüöÄ Crear un sistema de extensi√≥n en la biblioteca Qt - Parte 2 üßëüèæ‚Äçü§ù‚Äçüßëüèº ‚ôøÔ∏è üå≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Volviendo al primer art√≠culo, me gustar√≠a explicar d√≥nde surgi√≥ la necesidad de desarrollar un mecanismo de extensi√≥n con una interfaz gr√°fica (GUI) y...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Crear un sistema de extensi√≥n en la biblioteca Qt - Parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457744/"> Volviendo al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primer art√≠culo, me</a> gustar√≠a explicar d√≥nde surgi√≥ la necesidad de desarrollar un mecanismo de extensi√≥n con una interfaz gr√°fica (GUI) y explicar con m√°s detalle el mecanismo para crear complementos. <br><br>  Se recibi√≥ una asignaci√≥n para desarrollar software tecnol√≥gico para ajustar, regular, controlar, recopilar y analizar informaci√≥n de pistolas autopropulsadas (sistemas de control automatizados) del motor en el sistema operativo ruso.  Donde el intercambio entre las armas autopropulsadas y el programa tecnol√≥gico se realiza a trav√©s de la interfaz RS-232 o RS422, de acuerdo con un protocolo de intercambio especial. <br><br>  Despu√©s de revisar y analizar las capacidades de la lista de sistemas operativos rusos, se eligi√≥ el sistema operativo AstraLinux.  Este es un sistema de prop√≥sito especial basado en la distribuci√≥n de Debian, dise√±ado para proteger integralmente la informaci√≥n y construir sistemas automatizados seguros.  El sistema operativo Astra Linux se est√° desarrollando en dos versiones: Common Edition (gratuita, de uso general) y Special Edition (de pago, de prop√≥sito especial con un conjunto de algoritmos de protecci√≥n). <br>  Al desarrollar software, se utiliz√≥ la biblioteca Qt. <br><a name="habracut"></a><br>  El software consta de m√≥dulos funcionales, cada uno de los cuales le permite realizar un trabajo espec√≠fico en la configuraci√≥n del motor. <br><br>  El m√≥dulo funcional es un widget que consta de varios componentes visuales, gr√°ficos y tablas, donde los par√°metros del motor se muestran de forma f√°cil de usar. <br><br><img src="https://habrastorage.org/webt/vj/-a/qj/vj-aqjsytqmpwec1i1lqdxx_yxc.jpeg"><br>  <i>M√≥dulo funcional "Panel de control"</i> <br><br><img src="https://habrastorage.org/webt/au/wr/pt/auwrpt7gvp7trmajuxc6jfd5p4w.jpeg"><br>  <i>M√≥dulo funcional que le permite controlar din√°micamente valores de par√°metros dentro de l√≠mites aceptables</i> <br><br><img src="https://habrastorage.org/webt/a3/h-/9b/a3h-9b5zmpxihau19-a5kcxp5fm.jpeg"><br>  <i>M√≥dulo de funciones para configurar las caracter√≠sticas de las pistolas autopropulsadas</i> <br><br>  El software desarrollado (programa tecnol√≥gico) estaba destinado solo a un cierto tipo de motor.  Para un nuevo tipo de motor, fue necesario desarrollar un nuevo software, lo que condujo a un aumento significativo en los costos de mano de obra para el desarrollo, prueba, depuraci√≥n y, como resultado, retrasos en la implementaci√≥n de este software, a pesar de que dicho software ya estaba en demanda en la etapa de desarrollo de ACS. <br><br>  Para alejarse de esta costosa pr√°ctica de desarrollar software tecnol√≥gico, se decidi√≥ desarrollar un paquete de software que se adaptar√° a cualquier motor cuyo ACS admita el mismo protocolo de intercambio. <br><br>  El concepto en el desarrollo del paquete de software fue la posibilidad de ampliar la funcionalidad basada en tecnolog√≠a de complemento con soporte para m√≥dulos gr√°ficos. <br><br>  El paquete de software consta de tres partes principales: <br><br><ol><li>  N√∫cleo funcional del complejo </li><li>  Sistema de extensi√≥n del motor </li><li>  Conjunto de complementos </li></ol><br>  Las funciones principales incluyen garantizar un intercambio de datos confiable con ACS y realizar las siguientes tareas: <br><br><ul><li>  Comunicaci√≥n RS232 utilizando un protocolo especial. </li><li>  Monitoreo continuo de la lista de par√°metros del motor. </li><li>  Solicitud de cambio de par√°metro del motor </li><li>  Leer solicitudes de lectura del motor </li><li>  Mostrar par√°metros en forma de tabla </li><li>  Procesamiento de solicitudes desde extensiones (creando una nueva lista de monitoreo seg√∫n sea necesario, solicitudes de escritura y lectura √∫nicas) </li></ul><br>  Sistema de expansi√≥n con las siguientes funciones: <br><br><ul><li>  Buscar extensiones </li><li>  Obtener gr√°ficos de extensi√≥n </li><li>  Mostrar objetos de extensi√≥n </li><li>  La tarea de vincular solicitudes (se√±ales) de objetos al n√∫cleo del software </li></ul><br>  Cada complemento es una f√°brica de objetos, y la funci√≥n principal del complemento es crear un objeto gr√°fico. <br><br>  La tarea del sistema de extensi√≥n es obtener un objeto y asociarlo con el n√∫cleo del programa (usando interfaces bien conocidas), inicializar y activar el objeto. <br><br>  La conexi√≥n de los objetos con el n√∫cleo se produce mediante una clase virtual de interfaces.  Para desarrollar una nueva extensi√≥n, solo necesita conocer las interfaces que admite el n√∫cleo del programa de tecnolog√≠a.  La estructura del programa se presenta en la siguiente figura. <br><br><img src="https://habrastorage.org/webt/j2/mp/t0/j2mpt0susizvmrx8vwq8vy1gwxs.jpeg"><br><br>  Desarrollar una jerarqu√≠a de complementos. <br><br><img src="https://habrastorage.org/webt/sc/5-/qv/sc5-qvtudby49jtepinvw_8ihs0.jpeg"><br><br>  Considere la jerarqu√≠a del objeto gr√°fico creado por el complemento.  Dado que cuando trabaje con complementos, debe operar en objetos Qt, la clase principal, como en la biblioteca Qt, ser√° la clase QObject, que admite el mecanismo de ranura de se√±al Qt. <br><br>  La siguiente clase es QWidget: es necesario crear sus propios formularios gr√°ficos. <br><br>  A continuaci√≥n, necesita su propia clase de interfaces, interfaceWidget.  Para hacer esto, se crea una clase abstracta, que se heredar√° de QWidget.  En esta clase, se declaran interfaces (se√±ales, funciones, ranuras) que conectar√°n el proyecto principal y el objeto del complemento.  Una clase abstracta proporciona soporte de interfaz en el proyecto principal. <br><br>  La clase MyFormQt, que hereda de la clase de interfaz interfaceWidget y define las interfaces y en las que se desarrollan los gr√°ficos y la funcionalidad interna del m√≥dulo.  Gracias a este esquema de herencia, la clase MyFormQt admite la funcionalidad de la clase QWidget y las interfaces de comunicaci√≥n desarrolladas con el objeto principal de la aplicaci√≥n. <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** \class interfaceWidget \brief  ,      */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interfaceWidget</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QWidget { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">/// \brief  virtual ~interfaceWidget() = default; /// \brief    /// \param ba,     /// \param ok,    virtual void getByte(QByteArray ba, bool ok) = 0; /// \brief     /// \param ba,     virtual void getRetrieveDate(QByteArray ba, bool ok) = 0; /// \brief     /// \param fl,   virtual void successfullyWritten(bool fl) = 0; /// \brief      /// \param ok     /// \return        virtual QVector&lt;QString &gt; regParam(bool &amp;ok) = 0; signals: /// \brief       /// \param       virtual void signal_writeByteByName(QVector&lt;TVARPARAM &gt; vecParam) = 0; /// \brief      /// \param nameParam   virtual void signal_getByteByName(QVector&lt;QString &gt; nameParam) = 0; /// \brief      /// \param addr       /// \param ndata -    virtual void signal_getByteByAddress(quint32 addr, quint32 ndata) = 0; /// \brief       /// \param addr      /// \param ba    virtual void signal_writeByteByAddress(quint32 addr, QByteArray ba) = 0; /// \brief      /// \param fl, true  , false   virtual void signal_enableMonitoring(bool fl) = 0; };</span></span></code> </pre> <br>  Dicha jerarqu√≠a permite sortear el problema de la herencia en forma de diamante, al tiempo que mantiene el mecanismo de ranura de se√±al para el objeto creado, que es un punto importante en la tecnolog√≠a propuesta para el desarrollo de software tecnol√≥gico. <br><br>  Proceso de inicializaci√≥n e intercambio de datos: todo el proyecto se basa en un √°rea MDI; por lo tanto, todos los complementos se cargar√°n como una ventana MDI separada. <br><br>  El complemento de f√°brica crea un objeto de la clase MyFormQt, convierte el puntero al objeto creado en un puntero a QObject y lo pasa al programa tecnol√≥gico, donde el objeto se convierte mediante la operaci√≥n dynamic_cast a un objeto de la clase interfaceWidget, como resultado de lo cual tenemos acceso completo a la forma gr√°fica y las interfaces de este objeto . <br><br>  Funci√≥n de f√°brica (crear un objeto de funci√≥n gr√°fica en el complemento). <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//------------------------------------------------------------------ QObject *screenOnlinePlugin::getPluginWidget() { MyFormQt *screen = new MyFormQt(); return qobject_cast&lt;QObject *&gt;(screen); //    } //-------------------------------------------</span></span></code> </pre><br>  La funci√≥n de obtener e iniciar un objeto gr√°fico funcional en un programa tecnol√≥gico (n√∫cleo). <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//----------------------------------------------------------------- void PluginSystem::showPluginWidget(QString dirFabrica) { QMdiSubWindow *sWPS = new QMdiSubWindow; pQtTM-&gt;m_pma-&gt;addSubWindow(sWPS); sWPS-&gt;setAttribute(Qt::WA_DeleteOnClose, true); //--------  QPluginLoader loader(dirFabrica); //   QObject *pobj = qobject_cast&lt;QObject*&gt;(loader.instance()); if(!pobj) return; pluginInterface *fabrica = qobject_cast&lt;pluginInterface *&gt;(pobj); if(!fabric) return; QObject *ob = fabrica‚ÜígetPluginWidget(); //    if(!ob) return; interfaceWidget *interFaceW = dynamic_cast&lt;interfaceWidget *&gt;(ob); if(!interFaceW) return; delete fabrica; //   connect(interFaceW, SIGNAL(), this, SLOT()); sWPS-&gt;setWidget(interFaceW); sWPS-&gt;show(); //   QVector&lt;QString &gt; vecParam; vecParam = interFaceW‚ÜíregParam(paramOK); //   if(paramOK) regParamList(vecPlugin[i].namePlugin ,vecParam); } //--------------------------------------------------------------------------------</span></span></code> </pre><br>  Se coloca un objeto de la clase interfaceWidget (objeto de funci√≥n gr√°fica) en la ventana QmdiSubWindow creada, estableci√©ndolo as√≠ como hijo. <br><br>  Luego, conecte (conecte) las se√±ales y las ranuras del objeto con las se√±ales y las ranuras del n√∫cleo del programa tecnol√≥gico y la √∫ltima etapa de la visualizaci√≥n de la ventana utilizando el m√©todo show ().  Cuando cierre la ventana QmdiSubWindow, el objeto de la clase interfaceWidget tambi√©n se eliminar√°, porque la propiedad DeleteOnClose se configur√≥ de antemano para la subventana en la que se coloc√≥ el objeto. <br><br>  El intercambio de datos entre objetos gr√°ficos funcionales y un programa tecnol√≥gico se lleva a cabo mediante el c√°lculo de datos y dos modos: <br>  ‚Ä¢ Modo √∫nico (solicitud-respuesta); <br>  ‚Ä¢ Modo de monitoreo, recibimos datos constantemente con un per√≠odo determinado por el mecanismo de intercambio de datos con el dispositivo objetivo; <br><br>  <i>Marshaling es el proceso de convertir datos a un formato adecuado para almacenamiento o transmisi√≥n.</i>  <i>Se utiliza cuando la informaci√≥n necesita ser transferida entre diferentes partes de un programa o de un programa a otro.</i> <br><br>  En un solo modo, el usuario presiona un bot√≥n en un objeto de funci√≥n gr√°fica (widget) genera una se√±al que contiene una lista de par√°metros, cuyos datos deben leerse en el dispositivo de destino (ACS) y transferirse al objeto de funci√≥n gr√°fica.  El mecanismo de intercambio de datos en el programa principal procesa la se√±al y comienza a solicitar datos RS-232 de las armas autopropulsadas, los datos recibidos se empaquetan en QbyteArray y se env√≠an con una se√±al a un objeto gr√°fico.  El objeto tiene una lista de par√°metros solicitados y, por lo tanto, conoce sus tipos, desempaqueta los datos contenidos en QbyteArray y los muestra en forma de gr√°ficos y tablas y widgets gr√°ficos especializados (indicadores de flecha, indicadores digitales, botones retroiluminados, etc.). <br><br>  En el modo de supervisi√≥n, cuando se inicializa el complemento, el sistema solicita inmediatamente la lista de par√°metros necesarios para el complemento, y durante el monitoreo constante de sus par√°metros, lee par√°metros adicionales para el complemento y los entrega como un paquete de bytes en cada ciclo de intercambio de datos.  El per√≠odo del ciclo de intercambio de datos depende del n√∫mero de par√°metros solicitados. <br><br>  Por el momento, las pruebas est√°n en marcha y al mismo tiempo el desarrollo de grupos de complementos para diferentes tareas. <br><br>  Se ha creado una plantilla de complemento que acelera el proceso de desarrollo de nuevos complementos.  Al utilizar la plantilla de complemento para el desarrollo de un nuevo m√≥dulo funcional, es necesario crear una nueva forma gr√°fica e implementar algoritmos de procesamiento y visualizaci√≥n de datos. <br><br>  Se han desarrollado m√≥dulos de software de controlador f√≠sico para la interfaz cableada RS-232 y WIFI inal√°mbrico y Bluetooth. <br><br>  Hasta la fecha, el paquete de software funciona en modo de 2 canales, es decir, puede funcionar simult√°neamente con 2 pistolas autopropulsadas (este era el requisito del cliente).  Los m√≥dulos funcionales complementos est√°n conectados a cualquiera de los 2 canales por el usuario. <br><br>  Durante las pruebas, logramos lanzar simult√°neamente 12 complementos que fueron procesados ‚Äã‚Äãcon √©xito por el n√∫cleo.  E incluso 12 complementos no son el l√≠mite para este sistema.  Debido al sistema de doble b√∫fer Qt, el tiempo dedicado a dibujar complementos se reduce y evita que los complementos parpadeen, por lo que al aumentar el n√∫mero de complementos en el futuro, la carga principal solo recaer√° en el intercambio de datos a trav√©s de la interfaz RS-232.  Aunque la pr√°ctica muestra que durante la depuraci√≥n, el ajuste y las pruebas de un motor ACS, son suficientes 3-4 complementos que funcionan al mismo tiempo. <br><br>  Como resultado del trabajo, recibimos un paquete de software para el r√°pido desarrollo de programas tecnol√≥gicos destinados a afinar, poner en marcha y probar pistolas autopropulsadas para varios tipos de motores (sistemas mecatr√≥nicos). <br><br>  Se desarrollaron 2 conjuntos de complementos para diferentes tipos de motores. <br><br>  Al conectar un conjunto de complementos para un tipo espec√≠fico de pistolas autopropulsadas al paquete de software, obtenemos un programa multifuncional para configurar, poner en marcha y probar este tipo de pistolas autopropulsadas. <br><br><img src="https://habrastorage.org/webt/3g/4a/i1/3g4ai1ohrdvj0thcg-ix4uxgmwy.jpeg"><br><br>  En el futuro, planeamos escribir un art√≠culo sobre el desarrollo de nuestros propios widgets gr√°ficos, para tareas espec√≠ficas y un art√≠culo separado sobre el dise√±o de los objetos gr√°ficos. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/457744/">https://habr.com/ru/post/457744/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../457730/index.html">En la oficina hay una ilusi√≥n de control: no est√° en el control remoto. Conversaci√≥n con Devhab</a></li>
<li><a href="../457734/index.html">Comienza la revoluci√≥n del c√≥digo abierto en Italia</a></li>
<li><a href="../457736/index.html">"Las herramientas no son tan importantes como la capacidad de pensar sobre los sistemas que crean". Gran entrevista con Martin Kleppman</a></li>
<li><a href="../457738/index.html">C√≥mo implementamos SD-Access y por qu√© era necesario</a></li>
<li><a href="../457742/index.html">Autoescalado horizontal de hogares Kubernetes y Prometheus para alta disponibilidad y disponibilidad de infraestructura</a></li>
<li><a href="../457746/index.html">Meteorolog√≠a y vuelos</a></li>
<li><a href="../457750/index.html">Trabaja con JSON RPC en Symfony 4</a></li>
<li><a href="../457752/index.html">No rovers lunares ni bromistas. ¬øQu√© sabemos sobre los robots en Fukushima?</a></li>
<li><a href="../457754/index.html">Estado y asesinos en T</a></li>
<li><a href="../457756/index.html">El libro Kafka Streams en acci√≥n. Aplicaciones y microservicios en tiempo real ¬ª</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>