<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤˜ğŸ» ğŸ§•ğŸ» ğŸ‘¨ğŸ¿â€ğŸ“ Fantasi tentang masalah metaclasses di C # â­ï¸ ğŸ“ˆ ğŸ“€</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Programmer seperti saya, yang datang ke C # dengan pengalaman luas di Delphi, sering tidak memiliki apa yang disebut Delphi referensi kelas, dan dalam...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fantasi tentang masalah metaclasses di C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464141/"> Programmer seperti saya, yang datang ke C # dengan pengalaman luas di Delphi, sering tidak memiliki apa yang disebut Delphi referensi kelas, dan dalam karya teoretis, metaclass.  Beberapa kali di berbagai forum saya menemukan diskusi yang berlangsung sepanjang jalur yang sama.  Itu dimulai dengan pertanyaan dari seorang mantan lumba-lumba tentang bagaimana membuat metaclass di C #.  Sharpis tidak mengerti masalah ini, mencoba untuk menjelaskan jenis binatang apa ini - metaclass, lumba-lumba seperti yang bisa mereka jelaskan, tetapi penjelasannya singkat dan tidak lengkap, dan akibatnya, para penajam benar-benar bingung mengapa semua ini diperlukan.  Lagi pula, hal yang sama dapat dilakukan dengan bantuan pabrik refleksi dan kelas. <br><br>  Pada artikel ini, saya akan mencoba memberi tahu Anda apa itu metaclasses bagi mereka yang belum pernah melihatnya.  Selanjutnya, biarkan semua orang memutuskan sendiri apakah akan baik untuk memiliki hal seperti itu dalam bahasa, atau cukup refleksi.  Yang saya tulis di sini hanyalah fantasi tentang bagaimana jadinya jika ada benar-benar metaclasses di C #.  Semua contoh dalam artikel ini ditulis dalam versi hipotetis C # ini, tidak ada kompiler tunggal yang ada saat ini dapat mengkompilasi mereka. <br><a name="habracut"></a><br><h2>  Apa itu metaclass? </h2><br>  Jadi, apa itu metaclass?  Ini adalah tipe khusus yang berfungsi untuk menggambarkan tipe lainnya.  Ada sesuatu yang sangat mirip di C # - tipe Type.  Namun hanya serupa.  Nilai tipe Type dapat menggambarkan tipe apa pun, metaclass hanya bisa menggambarkan ahli waris dari kelas yang ditentukan ketika metaclass dideklarasikan. <br><br>  Untuk melakukan ini, versi hipotetis kami dari C # mendapatkan tipe Type &lt;T&gt;, yang merupakan penerus Type.  Tetapi Tipe &lt;T&gt; hanya cocok untuk menggambarkan tipe T atau turunannya. <br>  Saya akan menjelaskan ini dengan sebuah contoh: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A2</span></span> : <span class="hljs-title"><span class="hljs-title">A</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Type&lt;A&gt; ta; ta = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(A); <span class="hljs-comment"><span class="hljs-comment">//   ta = typeof(A2); //    ta = typeof(B); //   â€“ Type&lt;B&gt;   Type&lt;A&gt; ta = (Type&lt;A&gt;)typeof(B); //      -   Type tx = typeof(A); ta = tx; //   â€“    Type  Type&lt;A&gt; ta = (Type&lt;A&gt;)tx; //    Type&lt;B&gt; tb = (Type&lt;B&gt;)tx; //  } }</span></span></code> </pre> <br>  Contoh di atas adalah langkah pertama untuk munculnya metaclasses.  Jenis Jenis &lt;T&gt; memungkinkan Anda untuk membatasi jenis apa yang dapat dijelaskan oleh nilai yang sesuai.  Fitur ini mungkin terbukti berguna dalam dirinya sendiri, tetapi kemungkinan metaclasses tidak terbatas pada ini. <br><br><h2>  Metaclasses dan anggota kelas statis </h2><br>  Jika beberapa kelas X memiliki anggota statis, maka Tipe metaclass &lt;X&gt; mendapatkan anggota yang sama, tidak lagi statis, di mana Anda dapat mengakses anggota statis X. Mari kita jelaskan frasa membingungkan ini dengan sebuah contoh. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">X</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Type&lt;X&gt; tx = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(X); tx.DoSomething(); <span class="hljs-comment"><span class="hljs-comment">//   ,     X.DoSomething(); } }</span></span></code> </pre><br>  <i>Di sini, secara umum, muncul pertanyaan - bagaimana jika di kelas X metode statis dideklarasikan, set nama dan parameter yang bertepatan dengan set nama dan parameter salah satu metode dari kelas Type, pewarisnya adalah Type &lt;X&gt;?</i>  <i>Ada beberapa opsi yang cukup sederhana untuk menyelesaikan masalah ini, tetapi saya tidak akan membahasnya - untuk kesederhanaan kami percaya bahwa dalam bahasa fantasi konflik kami tidak ada nama ajaib.</i> <br><br>  Kode di atas untuk orang normal mana pun harus membingungkan - mengapa kita memerlukan variabel untuk memanggil metode jika kita dapat memanggil metode ini secara langsung?  Memang, dalam bentuk ini, peluang ini tidak berguna.  Tetapi manfaatnya datang ketika Anda menambahkan metode kelas untuk itu. <br><br><h2>  Metode kelas </h2><br>  Metode kelas adalah konstruk lain yang dimiliki Delphi, tetapi tidak ada dalam C #.  Ketika dideklarasikan, metode ini ditandai dengan kelas kata dan merupakan persilangan antara metode statis dan metode instance.  Seperti metode statis, mereka tidak terikat pada instance tertentu dan dapat dipanggil melalui nama kelas tanpa membuat instance.  Tapi, tidak seperti metode statis, mereka memiliki parameter implisit ini.  Hanya ini dalam kasus ini bukan turunan dari kelas, tetapi metaclass, yaitu  jika metode kelas dijelaskan dalam kelas X, maka parameter ini akan menjadi tipe Ketik &lt;X&gt;.  Dan Anda dapat menggunakannya seperti ini: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">X</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> class </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Report</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine($â€    {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Name}â€); } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Y</span></span> : <span class="hljs-title"><span class="hljs-title">X</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { X.Report() <span class="hljs-comment"><span class="hljs-comment">// : Â«    XÂ» Y.Report() // : Â«    YÂ» } }</span></span></code> </pre><br>  Fitur ini tidak terlalu mengesankan sejauh ini.  Tetapi berkat itu, metode kelas, tidak seperti metode statis, bisa virtual.  Lebih tepatnya, metode statis juga bisa dibuat virtual, tetapi tidak jelas apa yang harus dilakukan selanjutnya dengan virtualitas ini.  Tetapi dengan metode kelas, masalah seperti itu tidak muncul.  Pertimbangkan ini dengan sebuah contoh. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">X</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoReport</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(â€œ!â€); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Report</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { DoReport(); } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Y</span></span> : <span class="hljs-title"><span class="hljs-title">X</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoReport</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Consloe.WriteLine(â€œ!â€); } } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { X.Report() <span class="hljs-comment"><span class="hljs-comment">// : Â«!Â» Y.Report() // : ??? } }</span></span></code> </pre><br>  Dengan logika beberapa hal, saat memanggil Y.Laporan, "Sampai jumpa!" Harus ditampilkan.  Tetapi metode X.Report tidak memiliki informasi tentang dari mana kelas itu dipanggil, sehingga tidak dapat secara dinamis memilih antara X.DoReport dan Y.DoReport.  Akibatnya, X.Report akan selalu memanggil X.DoReport, bahkan jika Laporan dipanggil melalui Y. Tidak ada gunanya membuat metode DoReport virtual.  Oleh karena itu, C # tidak memungkinkan membuat metode statis virtual - akan mungkin menjadikannya virtual, tetapi Anda tidak akan mendapat manfaat dari keutamaan mereka. <br><br>  Hal lain adalah metode kelas.  Jika Laporan dalam contoh sebelumnya tidak statis, tetapi kelas, itu akan "tahu" kapan dipanggil melalui X, dan kapan melalui Y. Dengan demikian, kompiler dapat menghasilkan kode yang akan memilih DoReport yang diinginkan, dan panggilan ke Y.Report akan menghasilkan sampai pada kesimpulan "Sampai jumpa!". <br><br>  Fitur ini berguna dalam dirinya sendiri, tetapi menjadi lebih berguna jika Anda menambahkan kemampuan untuk memanggil variabel kelas melalui metaclasses.  Sesuatu seperti ini: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">X</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Report</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(â€œ!â€); } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Y</span></span> : <span class="hljs-title"><span class="hljs-title">X</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Report</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Consloe.WriteLine(â€œ!â€); } } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Type&lt;X&gt; tx = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(X); tx.Report() <span class="hljs-comment"><span class="hljs-comment">// : Â«!Â» tx = typeof(Y); tx.Report() // : Â«!Â» } }</span></span></code> </pre><br>  Untuk mencapai polimorfisme seperti itu tanpa metaclasses dan metode kelas virtual, untuk kelas X dan setiap turunannya harus menulis kelas bantu dengan metode virtual yang biasa.  Ini membutuhkan upaya yang jauh lebih besar, dan kontrol oleh kompiler tidak akan begitu lengkap, yang meningkatkan kemungkinan membuat kesalahan di suatu tempat.  Sementara itu, situasi ketika polimorfisme diperlukan pada level tipe, dan bukan pada level instance, ditemui secara teratur, dan jika bahasa mendukung polimorfisme seperti itu, ini adalah properti yang sangat berguna. <br><br><h2>  Konstruktor virtual </h2><br>  Jika metaclasses muncul dalam bahasa, maka konstruktor virtual perlu ditambahkan padanya.  Jika konstruktor virtual dideklarasikan dalam kelas, maka semua turunannya harus tumpang tindih, mis.  memiliki konstruktor Anda sendiri dengan set parameter yang sama, misalnya: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> { ... } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> : <span class="hljs-title"><span class="hljs-title">A</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">B</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y</span></span></span><span class="hljs-function">)</span></span> { } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">C</span></span> : <span class="hljs-title"><span class="hljs-title">A</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">C</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ... } }</code> </pre><br>  Dalam kode ini, kelas C tidak boleh dikompilasi, karena tidak memiliki konstruktor dengan parameter int x, int y, tetapi kelas B dikompilasi tanpa kesalahan. <br><br>  <i>Opsi lain dimungkinkan: jika konstruktor virtual leluhur tidak tumpang tindih dalam pewaris, kompiler secara otomatis tumpang tindih, seperti sekarang ini secara otomatis membuat konstruktor default.</i>  <i>Kedua pendekatan memiliki pro dan kontra yang jelas, tetapi ini tidak penting untuk gambaran keseluruhan.</i> <br><br>  Konstruktor virtual dapat digunakan di mana pun konstruktor biasa dapat digunakan.  Selain itu, jika kelas memiliki konstruktor virtual, metaclass-nya memiliki metode CreateInstance dengan set parameter yang sama dengan konstruktor, dan metode ini akan membuat instance kelas, seperti yang ditunjukkan pada contoh di bawah ini. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> { ... } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> : <span class="hljs-title"><span class="hljs-title">A</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">B</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y</span></span></span><span class="hljs-function">)</span></span> { } } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Type&lt;A&gt; ta = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(A); A a1 = ta.CreateInstance(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    A ta = typeof(B); A a2 = ta.CreateInstance(2, 7); //    B } }</span></span></code> </pre><br>  Dengan kata lain, kita mendapat kesempatan untuk membuat objek yang tipenya ditentukan pada saat run time.  Sekarang ini juga dapat dilakukan dengan menggunakan Activator.CreateInstance.  Tetapi metode ini bekerja melalui refleksi, sehingga kebenaran dari set parameter diperiksa hanya pada tahap eksekusi.  Tetapi jika kita memiliki metaclasses, maka kode dengan parameter yang salah tidak akan dikompilasi.  Selain itu, ketika menggunakan refleksi, kecepatan pekerjaan menyisakan banyak yang diinginkan, dan metaclasses memungkinkan Anda untuk meminimalkan biaya. <br><br><h2>  Kesimpulan </h2><br>  Saya selalu terkejut mengapa Halesberg, yang merupakan pengembang utama dari Delphi dan C #, tidak membuat metaclasses dalam C #, meskipun mereka membuktikan diri mereka dengan sangat baik di Delphi.  Mungkin intinya di sini adalah bahwa dalam Delphi (dalam versi-versi yang Halesberg lakukan) hampir tidak ada refleksi, dan tidak ada alternatif untuk metaclasses, yang tidak dapat dikatakan tentang C #.  Memang, semua contoh dari artikel ini tidak begitu sulit untuk diulang, hanya menggunakan alat-alat yang sudah ada dalam bahasa.  Tetapi semua ini akan bekerja lebih lambat dari pada metaclasses, dan kebenaran panggilan akan diperiksa saat runtime, bukan kompilasi.  Jadi pendapat pribadi saya adalah bahwa C # akan sangat bermanfaat jika metaclasses muncul di dalamnya. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id464141/">https://habr.com/ru/post/id464141/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id464127/index.html">Pengembangan favicon animasi</a></li>
<li><a href="../id464129/index.html">Inovasi JavaScript: hasil Google I / O 2019. Bagian 1</a></li>
<li><a href="../id464131/index.html">Inovasi JavaScript: hasil Google I / O 2019. Bagian 2</a></li>
<li><a href="../id464133/index.html">Performa bukan hanya tentang CPU: membuat profiler Anda sendiri untuk Python</a></li>
<li><a href="../id464137/index.html">Dukungan teknis Miran: cara kerjanya</a></li>
<li><a href="../id464143/index.html">Obat kanker pribadi. Bagaimana Gen Pasien Mempengaruhi Keberhasilan Perawatan</a></li>
<li><a href="../id464145/index.html">CMake: Kasus ketika Kualitas Proyek tidak dapat dimaafkan</a></li>
<li><a href="../id464147/index.html">CMake: kasus ketika proyek tidak termaafkan kualitas kodenya</a></li>
<li><a href="../id464149/index.html">Kisah monolit</a></li>
<li><a href="../id464151/index.html">Victor Vyalichkin: â€œKebebasan, kesetaraan, persaudaraan hanya ada di OpenStreetMap, di mana semuanya selalu terlihatâ€</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>