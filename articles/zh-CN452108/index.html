<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖐🏿 ♓️ 🕴🏽 Docker：无害建议 🙎🏻 🙏🏾 😊</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在我对Docker文章的评论：不好的建议中 ，有很多要求来解释为什么其中描述的Dockerfile如此可怕。 


 上一个系列的摘要 ：在紧迫的期限内有两名开发人员组成了Dockerfile。 在此过程中，Isper Igor Ivanovich来了。 生成的Dockerfile太糟糕了，以至于A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Docker：无害建议</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/452108/"><p> 在我对<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Docker</a>文章的评论<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">：不好的建议中</a> ，有很多要求来解释为什么其中描述的Dockerfile如此可怕。 </p><br><p>  <em>上一个系列的摘要</em> ：在紧迫的期限内有两名开发人员组成了Dockerfile。 在此过程中，Isper Igor Ivanovich来了。 生成的Dockerfile太糟糕了，以至于AI濒临心脏病发作。 </p><br><p><img src="https://habrastorage.org/webt/nl/uj/xm/nlujxmo7chgsgo7dti72jckbk04.jpeg"></p><br><p> 现在，让我们找出这个Dockerfile有什么问题。 </p><br><p> 因此，一周过去了。 </p><a name="habracut"></a><br><p>  Dev Petya与Ops Igor Ivanovich在饭厅见面，喝杯咖啡。 </p><br><p> 病人：伊戈尔·伊万诺维奇，你很忙吗？ 我想弄清楚我们在哪里搞砸了。 </p><br><p>  AI：这很好，您不会经常遇到对操作感兴趣的开发人员。 <br> 首先，让我们在一些事情上达成共识： </p><br><ol><li>  Docker意识形态：一个容器-一个过程。 </li><li> 容器越小越好。 </li><li> 使用的缓存越多越好。 </li></ol><br><p> 警：为什么一个容器中只有一个过程？ </p><br><p>  AI：Docker在容器启动时会使用pid 1监视进程的状态。如果进程终止，则Docker尝试重新启动容器。 假设您的容器中正在运行多个应用程序，或者主应用程序未使用pid 1启动。如果该进程终止，则Docker将不知道它。 </p><br><p> 如果没有其他问题，请显示您的Dockerfile。 </p><br><p>  Petya显示： </p><br><pre><code class="plaintext hljs">FROM ubuntu:latest #    COPY ./ /app WORKDIR /app #    RUN apt-get update #   RUN apt-get upgrade #    RUN apt-get -y install libpq-dev imagemagick gsfonts ruby-full ssh supervisor #  bundler RUN gem install bundler #  nodejs     RUN curl -sL https://deb.nodesource.com/setup_9.x | sudo bash - RUN apt-get install -y nodejs #   RUN bundle install --without development test --path vendor/bundle #     RUN rm -rf /usr/local/bundle/cache/*.gem RUN apt-get clean RUN rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/* RUN rake assets:precompile #  ,   ,    . CMD ["/app/init.sh"]</code> </pre> <br><p>  AI：哦，让我们按顺序整理一下。 让我们从第一行开始： </p><br><pre> <code class="plaintext hljs">FROM ubuntu:latest</code> </pre> <br><p> 您采用<code>latest</code>标签。 使用<code>latest</code>标签会导致不可预测的后果。 想象一下，映像维护者正在使用其他软件列表构建映像的新版本，该映像将获得最新标签。 最好的情况是，您的容器停止收集，最坏的情况下，您将捕获以前不存在的错误。 </p><br><p> 您使用具有很多不必要软件的完整操作系统拍摄图像，这会使容器膨胀。 软件越多，漏洞和漏洞就越多。 </p><br><p> 此外，图像越大，主机和注册表中占用的空间就越大（您是否将图像存储在某处）？ </p><br><p> 警：是的，当然，我们有一个注册表，您可以设置它。 </p><br><p>  II：那么，我在说什么？..哦，是的，卷...网络负载也在增长。 对于单个映像，这是不可见的，但是如果进行连续的组装，测试和部署，则可以看到。 而且，如果您在AWS上没有上帝的模式，您还将获得一个太空帐户。 </p><br><p> 因此，您需要选择最合适的映像，以及准确的版本和最低的软件。 例如，以： <code>FROM ruby:2.5.5-stretch</code> </p><br><p> 警：哦，我明白了。 以及如何以及在哪里看到可用的图像？ 如何理解我需要哪一个？ </p><br><p>  AI：通常，图像是从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Dockhub</a>拍摄的，不要与pornhub混淆：)。 通常有一个图像的几个程序集： <br>  <strong>高山（Alpine）</strong> ：映像是在仅5 MB的简约Linux映像上编译的。 它的缺点是：它是使用自己的libc实现构建的，其中的标准软件包不起作用。 查找并安装正确的软件包将花费大量时间。 <br>  <strong>Scratch</strong> ：基本图像，不用于构建其他图像。 它仅用于运行二进制的准备好的数据。 非常适合运行二进制应用程序，其中包括您需要的一切，例如go-applications。 <br> 基于任何操作系统，例如Ubuntu或Debian。 好吧，我认为这里不需要解释。 </p><br><p>  II：现在我们需要把所有多余的东西都放进去。 打包并清理缓存。 立即您可以进行<em>apt-get upgrade</em> 。 否则，对于每个组件，尽管具有基本图像的固定标签，仍将获得不同的图像。 更新映像中的程序包是维护人员的任务，它伴随着标签的更改。 </p><br><p> 警：是的，我尝试这样做，结果是这样的： </p><br><pre> <code class="plaintext hljs">WORKDIR /app COPY ./ /app RUN curl -sL https://deb.nodesource.com/setup_9.x | bash - \ &amp;&amp; apt-get -y install libpq-dev imagemagick gsfonts ruby-full ssh supervisor nodejs \ &amp;&amp; gem install bundler \ &amp;&amp; bundle install --without development test --path vendor/bundle RUN rm -rf /usr/local/bundle/cache/*.gem \ &amp;&amp; apt-get clean \ &amp;&amp; rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*</code> </pre> <br><p>  II：不错，但是还有一些工作要做。 看，这是以下命令： </p><br><pre> <code class="plaintext hljs">RUN rm -rf /usr/local/bundle/cache/*.gem \ &amp;&amp; apt-get clean \ &amp;&amp; rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*</code> </pre> <br><p>  ...不会从最终图像中删除数据，而只会创建一个没有此数据的附加图层。 正确的是： </p><br><pre> <code class="plaintext hljs">RUN curl -sL https://deb.nodesource.com/setup_9.x | bash - \ &amp;&amp; apt-get -y install libpq-dev imagemagick gsfonts nodejs \ &amp;&amp; gem install bundler \ &amp;&amp; bundle install --without development test --path vendor/bundle \ &amp;&amp; rm -rf /usr/local/bundle/cache/*.gem \ &amp;&amp; apt-get clean \ &amp;&amp; rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*</code> </pre> <br><p> 但这还不是全部。 露比，你那里有什么？ 这样就不必在开始时复制整个项目。 只需复制Gemfile和Gemfile.lock。 </p><br><p> 使用这种方法，仅在Gemfile或Gemfile.lock已更改的情况下，才对源的每次更改都不会执行捆绑包安装。 </p><br><p> 相同的方法适用于依赖管理器的其他语言，例如npm，pip，composer以及其他基于依赖列表文件的语言。 </p><br><p> 最后，还记得，在开始时我谈到了Docker意识形态“一个容器-一个进程”吗？ 这意味着不需要主管。 同样，出于相同的原因，请不要安装systemd。 实际上，Docker本身就是主管。 当您尝试在其中运行多个进程时，就像在一个主管进程中启动多个应用程序一样。 <br> 组装时，您将制作一个图像，然后运行所需数量的容器，以便每个进程具有一个进程。 </p><br><p> 但是稍后会更多。 </p><br><p> 警：似乎很明白。 看看会发生什么： </p><br><pre> <code class="plaintext hljs">FROM ruby:2.5.5-stretch WORKDIR /app COPY Gemfile* /app RUN curl -sL https://deb.nodesource.com/setup_9.x | bash - \ &amp;&amp; apt-get -y install libpq-dev imagemagick gsfonts nodejs \ &amp;&amp; gem install bundler \ &amp;&amp; bundle install --without development test --path vendor/bundle \ &amp;&amp; rm -rf /usr/local/bundle/cache/*.gem \ &amp;&amp; apt-get clean \ &amp;&amp; rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/* COPY . /app RUN rake assets:precompile CMD ["bundle”, “exec”, “passenger”, “start"]</code> </pre> <br><p> 容器启动时会重新定义守护程序吗？ </p><br><p>  AI：是的，没错。 顺便说一句，您可以同时使用CMD和ENTRYPOINT。 要了解有什么区别，这是您的作业。  Habré上有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一篇</a>关于该主题的好<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文章</a> 。 </p><br><p> 来吧 您下载了该文件以安装节点，但是不能保证它将具有所需的内容。 有必要添加验证。 例如，像这样： </p><br><pre> <code class="plaintext hljs">RUN curl -sL https://deb.nodesource.com/setup_9.x &gt; setup_9.x \ &amp;&amp; echo "958c9a95c4974c918dca773edf6d18b1d1a41434 setup_9.x" | sha1sum -c - \ &amp;&amp; bash setup_9.x \ &amp;&amp; rm -rf setup_9.x \ &amp;&amp; apt-get -y install libpq-dev imagemagick gsfonts nodejs \ &amp;&amp; gem install bundler \ &amp;&amp; bundle install --without development test --path vendor/bundle \ &amp;&amp; rm -rf /usr/local/bundle/cache/*.gem \ &amp;&amp; apt-get clean \ &amp;&amp; rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*</code> </pre> <br><p> 使用校验和，可以验证是否下载了正确的文件。 </p><br><p>  P：但是，如果文件更改，则程序集将无法工作。 </p><br><p>  II：是的，奇怪的是，这也是一个优点。 您会发现该文件已更改，并且您可以在那里看到更改的内容。 他们说，您永远不会知道，脚本会删除到达的所有内容或执行后门操作。 </p><br><p> 警：谢谢。 事实证明，最终的Dockerfile如下所示： </p><br><pre> <code class="plaintext hljs">FROM ruby:2.5.5-stretch WORKDIR /app COPY Gemfile* /app RUN curl -sL https://deb.nodesource.com/setup_9.x &gt; setup_9.x \ &amp;&amp; echo "958c9a95c4974c918dca773edf6d18b1d1a41434 setup_9.x" | sha1sum -c - \ &amp;&amp; bash setup_9.x \ &amp;&amp; rm -rf setup_9.x \ &amp;&amp; apt-get -y install libpq-dev imagemagick gsfonts nodejs \ &amp;&amp; gem install bundler \ &amp;&amp; bundle install --without development test --path vendor/bundle \ &amp;&amp; rm -rf /usr/local/bundle/cache/*.gem \ &amp;&amp; apt-get clean \ &amp;&amp; rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/* COPY . /app RUN rake assets:precompile CMD ["bundle”, “exec”, “passenger”, “start"]</code> </pre> <br><p> 警：伊戈尔·伊万诺维奇，谢谢你的帮助。 现在是我跑步的时候了，今天我需要再进行10次提交。 </p><br><p> 伊戈尔·伊万诺维奇（Igor Ivanovich）望着他匆匆忙忙的同事，,了一口浓咖啡。 在思考了99.9％的SLA和无错误的代码几秒钟后，他提出了一个问题。 </p><br><p>  AI：您将日志保存在哪里？ </p><br><p> 警：当然是在production.log中。 顺便说一句，是的，我们如何在没有ssh的情况下访问它们？ </p><br><p>  II：如果将它们保留在文件中，则已经为您发明了一种解决方案。  docker exec命令允许您执行容器中的任何命令。 例如，您可以将cat用作日志。 并使用<em>-it</em>开关并运行bash（如果<em>已将</em>其安装在容器中），您将获得对容器的交互式访问。 </p><br><p> 但是您不应该将日志存储在文件中。 至少，这导致了容器的不受控制的增长，但是没有人旋转原木。 所有日志都需要扔到stdout中。 在这里您已经可以使用<em>docker logs命令</em>查看它们。 </p><br><p> 警：伊戈尔·伊万诺维奇（Igor Ivanovich），但是可以将日志作为用户数据放入物理节点上的挂载目录中吗？ </p><br><p>  AI：最好不要忘记删除下载到节点磁盘的数据。 使用日志，这也是可能的，只记得设置好轮换即可。 <br> 所有您可以运行。 </p><br><p> 警：伊戈尔·伊万诺维奇（Igor Ivanovich），但建议您阅读些什么？ </p><br><p>  AI：首先，请阅读<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Docker开发人员</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">建议</a> ，几乎没有人比他们更了解Docker。 </p><br><p> 如果您想练习，请<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">集中精力</a> 。 毕竟，没有实践的理论就死了。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN452108/">https://habr.com/ru/post/zh-CN452108/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN452092/index.html">应用程序内更新：加快Android应用程序更新</a></li>
<li><a href="../zh-CN452094/index.html">.NET：用于处理多线程和异步的工具。 第一部分</a></li>
<li><a href="../zh-CN452098/index.html">前端开发人员Habr的日志：重构和反思</a></li>
<li><a href="../zh-CN452102/index.html">适合喜欢无人机的人的照片游戏：简要介绍AirSelfie 2</a></li>
<li><a href="../zh-CN452106/index.html">我们邀请演讲者参加2019年6月16日举行的夏季DIY会议</a></li>
<li><a href="../zh-CN452110/index.html">使用Ansible自动更换磁盘</a></li>
<li><a href="../zh-CN452112/index.html">客户关系管理++</a></li>
<li><a href="../zh-CN452114/index.html">HolyJS 2019：SEMrush汇报（第1部分）</a></li>
<li><a href="../zh-CN452116/index.html">PostgreSQL中的索引-8（RUM）</a></li>
<li><a href="../zh-CN452118/index.html">科学家打破了伏尼契神秘手稿的密码</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>