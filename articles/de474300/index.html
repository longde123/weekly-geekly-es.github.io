<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>„äóÔ∏è ‚òÆÔ∏è üëµüèª Zuverl√§ssiges, sicheres und vielseitiges Backup f√ºr U2F üßö üåì üë®üèø‚Äçüöí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich mag die Sicherheitsstufe von U2F sehr, aber neben der Sicherheit m√ºssen Sie einen Wiederherstellungsplan in Betracht ziehen. Der Verlust des Zugri...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Zuverl√§ssiges, sicheres und vielseitiges Backup f√ºr U2F</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474300/">  Ich mag die Sicherheitsstufe von U2F sehr, aber neben der Sicherheit m√ºssen Sie einen Wiederherstellungsplan in Betracht ziehen.  Der Verlust des Zugriffs auf Ihre wichtigsten Konten, wenn mit dem Haupt-U2F-Token etwas passiert, ist ein ernstes Problem.  Gleichzeitig m√∂chte ich vermeiden, ein Backup zu verwenden, das die von U2F bereitgestellte Sicherheit gef√§hrdet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ede/ae9/0a7/edeae90a73189ed879d63056d56afda5.jpg" alt="yubikey"></div><br><h2>  Beliebte Sicherungsmethoden </h2><br>  Bisher war es eine gute Praxis, ein zweites unabh√§ngiges U2F-Token f√ºr die Sicherung aufzubewahren.  Dieses Token muss manuell zu jedem Dienst hinzugef√ºgt und an einem "sicheren" Ort gespeichert werden.  Eine andere g√§ngige Praxis ist die Verwendung der Nicht-U2F-Methode als Backup (OTP, Wiederherstellungscodes).  Ehrlich gesagt lassen beide Methoden zu w√ºnschen √ºbrig. <br><a name="habracut"></a><br><h3>  Unabh√§ngiges U2F-Token </h3><br>  Dies bedeutet, dass ich jedes Mal, wenn ich mich bei einem neuen Dienst anmelde, meine beiden Token hinzuf√ºgen muss.  Diese Tatsache wirft eine Reihe von Problemen auf: <br><br><ul><li>  Ein Backup-Token sollte ziemlich leicht zug√§nglich sein.  Trotz der Tatsache, dass ich es nicht an einem Schl√ºsselbund mitnehmen werde, sollte ich in der Lage sein, schnell darauf zuzugreifen, sodass ich mir kaum etwas Besseres einfallen lassen kann, als es zu Hause zu behalten.  Wie real es ist, selbst wenn ein Safe benutzt wird, k√∂nnen Sie lange sprechen; </li><li>  Wenn ich mich unterwegs f√ºr einen Dienst registrieren muss, kann ich kein Backup-Token hinzuf√ºgen.  Sie m√ºssen also versuchen, sich daran zu erinnern, dass Sie es sp√§ter hinzuf√ºgen m√ºssen. Bis dies geschieht, gibt es keine Sicherung.  Im schlimmsten Fall kann ich ihn v√∂llig vergessen; </li><li>  Wenn ich zu Hause bin, befinden sich meine beiden Token am selben Ort.  Diese Sicherungsmethode ist alles andere als ideal: Beide Token sind m√∂glicherweise aufgrund eines Vorfalls nicht verf√ºgbar (zerst√∂rt oder gestohlen). </li><li>  Die Tatsache, dass das Backup-Token zu Hause gespeichert ist, liegt auf der Hand.  Wenn jemand wirklich zu meinem Token kommen m√∂chte, wei√ü er bereits, wo er danach suchen muss. </li><li>  Nicht universelle Methode: Nicht bei allen Diensten k√∂nnen Sie Ihrem Konto mehr als einen Schl√ºssel hinzuf√ºgen. </li></ul><br>  Meiner Meinung nach ist diese ‚Äûbeispielhafte Praxis‚Äú nicht sehr zuverl√§ssig und ziemlich belastend.  Schauen wir uns eine andere g√§ngige Praxis an. <br><br><h3>  Nicht-U2F-Methode als Backup </h3><br>  OTP: <br><br><ul><li>  Die Verwendung von OTP als Backup ist besser als die Verwendung als Hauptmethode von 2FA, aber die Tatsache, dass OTP vorhanden ist, er√∂ffnet irgendwie einen zus√§tzlichen Angriffsvektor. </li><li>  Telefone fallen aus, gehen verloren und werden gestohlen. Wenn nach dem Verlust die M√∂glichkeit besteht, dass sie in die H√§nde von Fremden gelangen, m√ºssen Sie diese Sicherung auf allen Konten manuell abrufen. </li><li>  Ich habe immer ein Telefon <b>und ein</b> U2F-Token bei mir, daher ist eine solche Sicherungsmethode alles andere als ideal: Die Wahrscheinlichkeit, beide sofort zu verlieren, ist viel h√∂her als wenn die Sicherung separat gespeichert w√ºrde.  Dieser Punkt kann jedoch leicht kompensiert werden, indem beispielsweise Authy verwendet wird, das die verschl√ºsselte Sicherung auf seinem Server speichert. </li><li>  Nicht universelle Methode: Leider gibt es eine ausreichende Anzahl von Diensten, die nur benutzerdefinierte Anwendungen anbieten und Standard-TOTP nicht unterst√ºtzen. </li></ul><br>  Wiederherstellungscodes: <br><br><ul><li>  Wiederherstellungscodes m√ºssen an einem sicheren Ort aufbewahrt werden.  Auch dieser ‚Äûsichere Ort‚Äú wird h√∂chstwahrscheinlich mein Zuhause sein, mit fast den gleichen Problemen wie ein separater U2F-Token. </li><li>  Wieder eine nicht universelle Methode: Jeder Dienst hat seinen eigenen Ansatz f√ºr die Sicherung </li></ul><br>  Zusammenfassend sind alle diese Methoden nicht universell, belastend und nicht zu sicher. <br><br><h2>  Die beste Sicherungsmethode </h2><br>  Nachdem ich den aktuellen Stand ausreichend kritisiert habe, werde ich endlich sagen, was ich wirklich will.  Ich m√∂chte wirklich zwei U2F-Token haben: Prim√§r- und Backup-Token, aber sie m√ºssen auf eine bestimmte Weise konfiguriert werden: <br><br><ul><li>  Wenn ich das Haupttoken auf einem Ger√§t registriere, wird das Sicherungstoken f√ºr diesen Dienst automatisch betriebsbereit. </li><li>  Sobald ich f√ºr einen Dienst ein Sicherungstoken verwende, ist das Haupttoken f√ºr diesen Dienst ung√ºltig. </li></ul><br>  Bevor wir die technische Machbarkeit in U2F diskutieren, werde ich erkl√§ren, warum es gro√üartig ist und wie ich es verwende. <br><br><h3>  Warum ist es toll? </h3><br>  Wenn wir uns die Kritik an dem oben beschriebenen unabh√§ngigen Backup-Token ansehen, k√∂nnen wir sehen, dass alle M√§ngel dieser Methode beseitigt sind: <br><br><ul><li>  Das Backup-Token sollte nicht mehr leicht zug√§nglich sein.  Extreme Beispiele k√∂nnen sein: Ziegelstein in einer Mauer oder anderthalb Meter in einem Garten oder anderswo.  Kein Scherz, ich bin ziemlich bereit daf√ºr; </li><li>  Unabh√§ngig davon, wo ich mich befinde, muss ich nichts tun, um diesem Dienst ein Sicherungstoken hinzuzuf√ºgen, wenn ich mich f√ºr einen Dienst anmelde.  Ich benutze nur mein Haupt-Token und bin beruhigt, weil ich wei√ü, dass ich ein Backup habe. </li><li>  F√ºr Au√üenstehende ist v√∂llig unklar, wo sich mein Backup-Token befindet.  Selbst wenn man wei√ü, dass es existiert, macht es kaum Sinn, es selbst zu finden. </li><li>  Es ist sicher genug.  Selbst wenn meinem Haupttoken etwas Schlimmes passiert, ist es sehr unwahrscheinlich, dass derselbe Vorfall das Sicherungstoken beeinflusst. </li><li>  Es ist universell.  Diese Sicherungsmethode funktioniert f√ºr alle Dienste, die U2F unterst√ºtzen, unabh√§ngig davon, was dieser Dienst sonst noch unterst√ºtzt. </li></ul><br>  Und wenn mit dem Haupt-Token wirklich etwas Schlimmes passiert, mache ich Folgendes: <br><br><ul><li>  Ich grabe ein Backup-Token aus / unklar; </li><li>  Authentifizieren Sie sich bei allen meinen Diensten mit U2F und l√∂schen Sie dabei das Haupttoken. </li><li>  Ich bestelle ein neues Paar Token und f√ºge nach Erhalt allen Diensten ein neues Haupt-Token hinzu und widerrufe das alte. </li></ul><br>  Zumindest f√ºr mich pers√∂nlich ist diese Strategie ein gro√üartiger Kompromiss f√ºr ein hohes Ma√ü an Sicherheit und eine einfache Sicherungslast.  Es ist sicherer und zuverl√§ssiger als jede andere Methode. <br><br><h2>  Implementierung </h2><br><h3>  U2F-Protokoll√ºbersicht </h3><br>  Bevor wir √ºber die Implementierung sprechen k√∂nnen, m√ºssen wir auf einer bestimmten Ebene verstehen, wie U2F funktioniert.  Die meisten Hersteller implementieren es wie folgt (nicht alle der folgenden Elemente sind im Standard enthalten; einige Dinge sind Implementierungsdetails, aber die meisten vorhandenen Implementierungen funktionieren meines Wissens genau so): <br><br>  <code>device_secret</code> im U2F-Token zusammen mit einem 32-Bit- <code>counter</code> programmiert, der nur inkrementiert werden kann.  Wenn wir ein U2F-Token f√ºr einen Dienst registrieren, geschieht Folgendes: <br><br><ul><li>  Der Browser sendet die <code>AppID</code> (tats√§chlich den Dom√§nennamen) an das U2F-Ger√§t. </li><li>  Das Ger√§t generiert eine Zufallszahl ( <code>nonce</code> ), kombiniert sie mit der <code>AppID</code> , leitet sie mithilfe von <code>device_secret</code> als Schl√ºssel durch HMAC-SHA256 und der resultierende Hash wird zum privaten Schl√ºssel f√ºr diesen bestimmten Dienst: <code>service_private_key</code> ; </li><li>  Aus <code>service_private_key</code> wird der √∂ffentliche Schl√ºssel <code>service_public_key</code> generiert. </li><li>  Das Ger√§t nimmt die <code>AppID</code> erneut, kombiniert sie mit <code>service_private_key</code> und leitet sie erneut mit <code>device_secret</code> als Schl√ºssel durch den HMAC-SHA256.  Das Ergebnis ( <code>MAC</code> ) wird zusammen mit der zuvor generierten <code>nonce</code> zu <code>key_handle</code> . </li><li>  Das Ger√§t sendet <code>key_handle</code> und <code>service_public_key</code> zur√ºck an den Browser, und der Browser leitet an den Dienst weiter, der diese Daten f√ºr zuk√ºnftige Authentifizierungen speichert. </li></ul><br>  Die nachfolgende Authentifizierung erfolgt wie folgt: <br><br><ul><li>  Der Dienst generiert eine <code>challenge</code> (zuf√§llig generierte Daten) und sendet sie zusammen mit <code>key_handle</code> (bestehend aus <code>nonce</code> und <code>MAC</code> ) an den Browser.  Der Browser √ºbergibt dies alles zusammen mit der <code>AppID</code> (d. H. <code>AppID</code> Dom√§nennamen) an das Ger√§t. </li><li>  Das Ger√§t mit <code>nonce</code> und <code>AppID</code> generiert <code>service_private_key</code> auf dieselbe Weise, wie es bei der Registrierung generiert wurde. </li><li>  Das Ger√§t generiert einen <code>MAC</code> auf die gleiche Weise wie bei der Registrierung. Durch den Vergleich mit dem vom Browser empfangenen <code>MAC</code> <code>nonce</code> sichergestellt, dass <code>nonce</code> nicht ersetzt wird. Daher ist <code>service_private_key</code> zuverl√§ssig. </li><li>  Das Ger√§t erh√∂ht den <code>counter</code> . </li><li>  Das Ger√§t signiert die <code>AppID</code> , <code>AppID</code> und den <code>counter</code> mit <code>service_private_key</code> und sendet die resultierende Signatur ( <code>signature</code> ) und den <code>counter</code> Browser, der diese Daten weiter an den Dienst √ºbertr√§gt. </li><li>  Der Dienst √ºberpr√ºft die <code>signature</code> mit dem <code>service_public_key</code> , den er nach der Registrierung hat.  Au√üerdem √ºberpr√ºfen die meisten Dienste, ob der <code>counter</code> gr√∂√üer als der vorherige Wert ist (wenn dies nicht die erste Authentifizierung ist).  Der Zweck dieses Tests besteht darin, das Klonen von U2F-Ger√§ten unzug√§nglich zu machen.  Wenn die <code>signature</code> √ºbereinstimmt und der <code>counter</code> gr√∂√üer als der vorherige Wert ist, wird die Authentifizierung als erfolgreich abgeschlossen betrachtet, und der Dienst speichert den neuen <code>counter</code> . </li></ul><br>  Lassen Sie uns nun die Details skizzieren, die in direktem Zusammenhang mit der Diskussion stehen. <br><br><h3>  Details von Interesse </h3><br>  Das erste ist, dass das Ger√§t nicht f√ºr jeden Dienst <code>service_private_key</code> speichert, <code>service_private_key</code> jedes Mal mit HMAC-SHA256 <code>service_private_key</code> anzeigt.  Dies ist f√ºr uns sehr wichtig: Es ist offensichtlich, dass, wenn jedes Ger√§t eindeutige Schl√ºssel f√ºr jeden Dienst separat speichern w√ºrde, sich nur dieses Ger√§t anschlie√üend authentifizieren k√∂nnte. <br><br>  <i>Dies ist √ºbrigens keine Anforderung von U2F: U2F gibt nicht an, wie Schl√ºssel gespeichert werden sollen, und einige fr√ºhe Implementierungen von U2F haben tats√§chlich Schl√ºssel f√ºr jeden Dienst separat gespeichert.</i>  <i>Dieser Ansatz hat den Nachteil, dass die Anzahl der Dienste, f√ºr die das Ger√§t verwendet werden kann, begrenzt ist.</i>  <i>Die Ableitung von <code>service_private_key</code> beseitigt diesen Nachteil.</i> <br><br>  Und zweitens verf√ºgt das Ger√§t √ºber einen <code>counter</code> , um das Klonen zu verhindern. <br><br>  Auf den ersten Blick scheint es, dass dieser <code>counter</code> es uns nicht erlaubt, die diskutierte Sicherungsstrategie umzusetzen (zumindest schien es mir, als ich versuchte, eine L√∂sung zu finden), aber tats√§chlich hilft er uns nur!  Ich werde es jetzt erkl√§ren. <br><br><h3>  Hauptidee </h3><br>  Die Idee ist folgende: Programmieren Sie in der Produktionsphase zwei Token so, dass beide dasselbe <code>device_secret</code> , aber das Backup-Token muss korrigiert werden: Anstatt den <code>counter</code> in seiner reinen Form zu verwenden (wie es normale Token tun), sollte es hinzugef√ºgt werden eine gro√üe Konstante zu <code>counter</code> .  Zum Beispiel die H√§lfte des 32-Bit-Bereichs, d.h.  ungef√§hr <code>2 000 000 000</code> , es sieht vern√ºnftig aus: Es ist unwahrscheinlich, dass ich in meinem ganzen Leben so viele Authentifizierungen ersch√∂pfen werde. <br><br>  Das ist alles.  Einfach und effektiv. <br><br>  Nachdem zwei Token auf diese Weise programmiert wurden, verstecke ich das Backup-Token an einem <i>wirklich</i> schwer erreichbaren Ort und ber√ºhre es nie.  Wenn etwas Schreckliches passiert und ich den Zugriff auf das Haupttoken verliere, komme ich immer noch zum Sicherungstoken und kann es sofort f√ºr alle Dienste verwenden, bei denen ich das Haupttoken registriert habe, weil  Das Backup hat das gleiche <code>device_secret</code> und sein <code>counter</code> beginnt mit einer wirklich gro√üen Zahl, die ich f√ºr den Rest meines Lebens nicht bekomme. <br><br>  <b>Ich mache auch darauf</b> aufmerksam, dass <b>ich nicht vorschlage, Token geklont zu machen</b> .  Zwei Token haben, obwohl sie dasselbe <code>device_secret</code> haben, unterschiedliche Z√§hler, und nach dem Programmieren von <code>device_secret</code> sollte es keine M√∂glichkeit geben, sie vom Ger√§t zur√ºckzubekommen oder auf andere Weise einen Klon zu erstellen. <br><br><h3>  Ein Hinweis zum Z√§hler </h3><br>  Ein aufmerksamer Leser kann feststellen, dass das folgende Sicherheitsproblem vorliegt: Was passiert, wenn ein Angreifer Zugriff auf das Haupttoken erh√§lt und auf irgendeine Weise 2.000.000.000 Authentifizierungen initiiert?  Dann erh√§lt er Zugriff auf den Dienst, auch nachdem das Sicherungstoken f√ºr diesen Dienst verwendet wurde. <br><br>  Gl√ºcklicherweise hat dieses Problem eine einfache L√∂sung.  In jedem Fall muss der Z√§hler in Hardware implementiert sein (vermutlich auf einem Kryptoprozessor), und f√ºr eine sichere Implementierung muss dieser Hardwarez√§hler einen Bereich von weniger als 32 Bit haben.  Beim <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ATECC508A k√∂nnen</a> Z√§hler beispielsweise nur bis 2097151 z√§hlen. Wenn Sie also die dem Z√§hler hinzugef√ºgte Konstante auf einen Wert setzen, der gr√∂√üer als der Maximalwert des Z√§hlers ist, k√∂nnen Sie sicher sein, dass das Haupttoken niemals zum Z√§hler im Sicherungstoken z√§hlen kann. <br><br>  Zur Verdeutlichung: Nehmen wir an, unser U2F-Token verwendet ATECC508A und bezeichnet den Z√§hler im ATECC508A als <code>hw_counter</code> .  Dann: <br><br><ul><li>  Im <code>hw_counter</code> wir f√ºr Berechnungen: <code>hw_counter</code> ; </li><li>  Im Backup-Token verwenden wir f√ºr Berechnungen: <code>hw_counter + 2000000000</code> . </li></ul><br>  Bitte beachten Sie, dass wir den echten <code>hw_counter</code> im <code>hw_counter</code> nicht √§ndern.  es z√§hlt immer noch von 0 bis 2097151. Stattdessen lesen wir jedes Mal, wenn wir den <code>hw_counter</code> m√ºssen, <code>hw_counter</code> von ATECC508A, addieren dann unsere Konstante und geben sie zur√ºck (f√ºr weitere Berechnungen f√ºr U2F). <br><br>  Somit betr√§gt der Bereich der Z√§hlerwerte im Haupttoken [0, 2097151], w√§hrend der Bereich der Z√§hlerwerte im Sicherungstoken [2000000000, 2002097151] betr√§gt.  Die Tatsache, dass sich diese Bereiche nicht √ºberschneiden, stellt sicher, dass das Haupttoken bei Verwendung der Sicherung gel√∂scht wird (wenn der Dienst einen <code>counter</code> ; die von mir √ºberpr√ºften Hauptdienste verwenden ihn). <br><br><h3>  Tats√§chliche Umsetzung </h3><br>  Keiner der mir bekannten Hersteller von U2F-Token unterst√ºtzt heute die erforderliche Anpassung.  Gl√ºcklicherweise gibt es eine Open-Source-Implementierung des U2F-Tokens: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SoloKeys</a> . <br><br>  Ich habe meinen urspr√ºnglichen Artikel (auf Englisch) vor einem Jahr geschrieben, und dieser Teil ist etwas veraltet: Dann befand sich SoloKeys im Prototyping-Stadium und ich habe die vorherige Iteration des Projekts verwendet: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">u2f-zero</a> .  Daher werde ich diesen Teil jetzt nicht √ºbersetzen, da der einzige Weg, ein u2f-zero-Ger√§t zu erhalten, darin besteht, es selbst zu l√∂ten, und es ist kaum ratsam, dies zu tun (obwohl es Anweisungen auf dem Github gibt). <br><br>  Trotzdem sind alle Details der notwendigen Modifikation von u2f-zero im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Originalartikel angegeben</a> . <br><br>  Wenn meine H√§nde die Solokeys erreichen, schreibe ich Anweisungen f√ºr deren √Ñnderung. <br><br>  Auf die eine oder andere Weise ist dies die einzige M√∂glichkeit, die ich heute kenne, um ein funktionierendes U2F-Token mit einer zuverl√§ssigen Sicherung zu erhalten.  Das √úberpr√ºfen mehrerer Dienste (mindestens Google und Github) hat gezeigt, dass dies funktioniert: Durch Registrieren des Haupttokens im Dienst k√∂nnen wir auch die Sicherung verwenden, und nach der ersten Verwendung der Sicherung funktioniert das Haupttoken nicht mehr.  Awwwwwww.  &lt;3 <br><br><h3>  Warnung </h3><br>  Trotz der Tatsache, dass diese Backup-Strategie cool ist, bin ich mir ihrer spezifischen Implementierung durch u2f-zero oder solokey nicht so sicher.  Dieser Weg ist der einzige Weg, um das zu bekommen, was Sie wollen, also bin ich diesen Weg gegangen;  Unter der Annahme, dass der Angreifer physischen Zugriff auf das U2F-Ger√§t erh√§lt, bin ich mir nicht sicher, ob das Hacken des Ger√§ts (d. <code>device_secret</code> das <code>device_secret</code> von <code>device_secret</code> ) so schwierig sein wird wie bei Yubikey oder anderen gro√üen Herstellern.  Die Autoren von solokey behaupten, dass ‚Äûdas Sicherheitsniveau das gleiche ist wie bei einem modernen Autoschl√ºssel‚Äú, aber ich habe keine Untersuchungen durchgef√ºhrt, um dies zu best√§tigen. <br><br>  Um ehrlich zu sein, mache ich mir dar√ºber jedoch keine gro√üen Sorgen.  Wenn ein Angreifer einfach einen Token stiehlt, ohne ihn zur√ºckgeben zu wollen, spielt die Komplexit√§t des Brechens keine Rolle, weil  Ein Angreifer kann dieses Token einfach verwenden, um auf ein Konto zuzugreifen, und beispielsweise dieses Token einfach widerrufen und ein weiteres hinzuf√ºgen.  Daf√ºr muss ich jedoch auch andere ernsthafte Sicherheitsprobleme haben.  U2F-Token ist nur der zweite Faktor. <br><br>  Das einzige Szenario, in dem Solokey m√∂glicherweise weniger sicher ist als etwas anderes, ist, wenn ein Angreifer versucht, f√ºr einen kurzen Zeitraum auf das Ger√§t zuzugreifen, <code>device_secret</code> von ihm <code>device_secret</code> und das Ger√§t unsichtbar an mich zur√ºckzugeben.  Dazu muss er den Inhalt des Flash-Mikrocontrollers (oder des RAM zum richtigen Zeitpunkt) lesen, was nicht sehr trivial ist. <br><br>  Unter Ber√ºcksichtigung aller Faktoren glaube ich, dass eine zuverl√§ssige Sicherung f√ºr mich pers√∂nlich viel wichtiger ist als eine hochsichere Hardware-Implementierung eines U2F-Ger√§ts.  Die Wahrscheinlichkeit von Problemen mit einer solchen sicheren Implementierung und das Fehlen einer guten Sicherung ist h√∂her als die Wahrscheinlichkeit von Problemen mit u2f-zero (solokey) und Sicherung. <br><br><h2>  Fazit </h2><br>  Die in Betracht gezogene Sicherungsstrategie √ºbertrifft die Alternativen in allen Dimensionen: Sie ist universell, sicherer und zuverl√§ssiger als alle anderen Methoden. <br><br>  Ich w√ºrde mich freuen, wenn mindestens einer der Haupthersteller dies in seinen Produkten umsetzt, aber es gibt noch keine Gewissheit.  Ein Mitarbeiter von Yubico, James A., sagte mir sogar, dass die Implementierung des Backups nach Bedarf mit der Art und Weise, wie U2F entworfen wurde, nicht m√∂glich sei. Nachdem ich die Implementierungsdetails dargelegt hatte, reagierte es einfach nicht mehr. <br><br>  Zum Gl√ºck war dies nicht so unm√∂glich, wie Yubico glaubt. <br><br><hr><br>  <i>Mein Originalartikel auf Englisch: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zuverl√§ssige, sichere und universelle Sicherung f√ºr U2F-Token</a> .</i>  <i>Weil</i>  <i>Der Autor des Originalartikels bin ich selbst. Mit Ihrer Erlaubnis habe ich diesen Artikel nicht in die Kategorie ‚Äû√úbersetzung‚Äú eingeordnet</i> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de474300/">https://habr.com/ru/post/de474300/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de474284/index.html">Nicht nur Futures und Optionen: Welche anderen sekund√§ren Finanzinstrumente gibt es an B√∂rsen und nicht nur</a></li>
<li><a href="../de474286/index.html">Detaillierte Analyse der Simplex-Methode</a></li>
<li><a href="../de474292/index.html">JavaFX-Tutorial: Erste Schritte</a></li>
<li><a href="../de474294/index.html">Bin√§rkompatibilit√§t: jetzt oder nie</a></li>
<li><a href="../de474298/index.html">Implementieren eines P2P-Gateways von Karte zu Karte</a></li>
<li><a href="../de474302/index.html">So schreiben Sie ein effektives Anwendungsbenutzbarkeitstestskript</a></li>
<li><a href="../de474306/index.html">√Ñndern Sie die Stile f√ºr Zeigen, Fokussieren und aktiven Status.</a></li>
<li><a href="../de474308/index.html">In Python geschriebene Typen f√ºr HTTP-APIs: Instagram-Erfahrung</a></li>
<li><a href="../de474310/index.html">Gibt es Zufallszahlen in CSS?</a></li>
<li><a href="../de474312/index.html">Installieren der GUI unter Windows Server Core</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>