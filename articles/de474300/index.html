<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>㊗️ ☮️ 👵🏻 Zuverlässiges, sicheres und vielseitiges Backup für U2F 🧚 🌓 👨🏿‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich mag die Sicherheitsstufe von U2F sehr, aber neben der Sicherheit müssen Sie einen Wiederherstellungsplan in Betracht ziehen. Der Verlust des Zugri...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Zuverlässiges, sicheres und vielseitiges Backup für U2F</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474300/">  Ich mag die Sicherheitsstufe von U2F sehr, aber neben der Sicherheit müssen Sie einen Wiederherstellungsplan in Betracht ziehen.  Der Verlust des Zugriffs auf Ihre wichtigsten Konten, wenn mit dem Haupt-U2F-Token etwas passiert, ist ein ernstes Problem.  Gleichzeitig möchte ich vermeiden, ein Backup zu verwenden, das die von U2F bereitgestellte Sicherheit gefährdet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ede/ae9/0a7/edeae90a73189ed879d63056d56afda5.jpg" alt="yubikey"></div><br><h2>  Beliebte Sicherungsmethoden </h2><br>  Bisher war es eine gute Praxis, ein zweites unabhängiges U2F-Token für die Sicherung aufzubewahren.  Dieses Token muss manuell zu jedem Dienst hinzugefügt und an einem "sicheren" Ort gespeichert werden.  Eine andere gängige Praxis ist die Verwendung der Nicht-U2F-Methode als Backup (OTP, Wiederherstellungscodes).  Ehrlich gesagt lassen beide Methoden zu wünschen übrig. <br><a name="habracut"></a><br><h3>  Unabhängiges U2F-Token </h3><br>  Dies bedeutet, dass ich jedes Mal, wenn ich mich bei einem neuen Dienst anmelde, meine beiden Token hinzufügen muss.  Diese Tatsache wirft eine Reihe von Problemen auf: <br><br><ul><li>  Ein Backup-Token sollte ziemlich leicht zugänglich sein.  Trotz der Tatsache, dass ich es nicht an einem Schlüsselbund mitnehmen werde, sollte ich in der Lage sein, schnell darauf zuzugreifen, sodass ich mir kaum etwas Besseres einfallen lassen kann, als es zu Hause zu behalten.  Wie real es ist, selbst wenn ein Safe benutzt wird, können Sie lange sprechen; </li><li>  Wenn ich mich unterwegs für einen Dienst registrieren muss, kann ich kein Backup-Token hinzufügen.  Sie müssen also versuchen, sich daran zu erinnern, dass Sie es später hinzufügen müssen. Bis dies geschieht, gibt es keine Sicherung.  Im schlimmsten Fall kann ich ihn völlig vergessen; </li><li>  Wenn ich zu Hause bin, befinden sich meine beiden Token am selben Ort.  Diese Sicherungsmethode ist alles andere als ideal: Beide Token sind möglicherweise aufgrund eines Vorfalls nicht verfügbar (zerstört oder gestohlen). </li><li>  Die Tatsache, dass das Backup-Token zu Hause gespeichert ist, liegt auf der Hand.  Wenn jemand wirklich zu meinem Token kommen möchte, weiß er bereits, wo er danach suchen muss. </li><li>  Nicht universelle Methode: Nicht bei allen Diensten können Sie Ihrem Konto mehr als einen Schlüssel hinzufügen. </li></ul><br>  Meiner Meinung nach ist diese „beispielhafte Praxis“ nicht sehr zuverlässig und ziemlich belastend.  Schauen wir uns eine andere gängige Praxis an. <br><br><h3>  Nicht-U2F-Methode als Backup </h3><br>  OTP: <br><br><ul><li>  Die Verwendung von OTP als Backup ist besser als die Verwendung als Hauptmethode von 2FA, aber die Tatsache, dass OTP vorhanden ist, eröffnet irgendwie einen zusätzlichen Angriffsvektor. </li><li>  Telefone fallen aus, gehen verloren und werden gestohlen. Wenn nach dem Verlust die Möglichkeit besteht, dass sie in die Hände von Fremden gelangen, müssen Sie diese Sicherung auf allen Konten manuell abrufen. </li><li>  Ich habe immer ein Telefon <b>und ein</b> U2F-Token bei mir, daher ist eine solche Sicherungsmethode alles andere als ideal: Die Wahrscheinlichkeit, beide sofort zu verlieren, ist viel höher als wenn die Sicherung separat gespeichert würde.  Dieser Punkt kann jedoch leicht kompensiert werden, indem beispielsweise Authy verwendet wird, das die verschlüsselte Sicherung auf seinem Server speichert. </li><li>  Nicht universelle Methode: Leider gibt es eine ausreichende Anzahl von Diensten, die nur benutzerdefinierte Anwendungen anbieten und Standard-TOTP nicht unterstützen. </li></ul><br>  Wiederherstellungscodes: <br><br><ul><li>  Wiederherstellungscodes müssen an einem sicheren Ort aufbewahrt werden.  Auch dieser „sichere Ort“ wird höchstwahrscheinlich mein Zuhause sein, mit fast den gleichen Problemen wie ein separater U2F-Token. </li><li>  Wieder eine nicht universelle Methode: Jeder Dienst hat seinen eigenen Ansatz für die Sicherung </li></ul><br>  Zusammenfassend sind alle diese Methoden nicht universell, belastend und nicht zu sicher. <br><br><h2>  Die beste Sicherungsmethode </h2><br>  Nachdem ich den aktuellen Stand ausreichend kritisiert habe, werde ich endlich sagen, was ich wirklich will.  Ich möchte wirklich zwei U2F-Token haben: Primär- und Backup-Token, aber sie müssen auf eine bestimmte Weise konfiguriert werden: <br><br><ul><li>  Wenn ich das Haupttoken auf einem Gerät registriere, wird das Sicherungstoken für diesen Dienst automatisch betriebsbereit. </li><li>  Sobald ich für einen Dienst ein Sicherungstoken verwende, ist das Haupttoken für diesen Dienst ungültig. </li></ul><br>  Bevor wir die technische Machbarkeit in U2F diskutieren, werde ich erklären, warum es großartig ist und wie ich es verwende. <br><br><h3>  Warum ist es toll? </h3><br>  Wenn wir uns die Kritik an dem oben beschriebenen unabhängigen Backup-Token ansehen, können wir sehen, dass alle Mängel dieser Methode beseitigt sind: <br><br><ul><li>  Das Backup-Token sollte nicht mehr leicht zugänglich sein.  Extreme Beispiele können sein: Ziegelstein in einer Mauer oder anderthalb Meter in einem Garten oder anderswo.  Kein Scherz, ich bin ziemlich bereit dafür; </li><li>  Unabhängig davon, wo ich mich befinde, muss ich nichts tun, um diesem Dienst ein Sicherungstoken hinzuzufügen, wenn ich mich für einen Dienst anmelde.  Ich benutze nur mein Haupt-Token und bin beruhigt, weil ich weiß, dass ich ein Backup habe. </li><li>  Für Außenstehende ist völlig unklar, wo sich mein Backup-Token befindet.  Selbst wenn man weiß, dass es existiert, macht es kaum Sinn, es selbst zu finden. </li><li>  Es ist sicher genug.  Selbst wenn meinem Haupttoken etwas Schlimmes passiert, ist es sehr unwahrscheinlich, dass derselbe Vorfall das Sicherungstoken beeinflusst. </li><li>  Es ist universell.  Diese Sicherungsmethode funktioniert für alle Dienste, die U2F unterstützen, unabhängig davon, was dieser Dienst sonst noch unterstützt. </li></ul><br>  Und wenn mit dem Haupt-Token wirklich etwas Schlimmes passiert, mache ich Folgendes: <br><br><ul><li>  Ich grabe ein Backup-Token aus / unklar; </li><li>  Authentifizieren Sie sich bei allen meinen Diensten mit U2F und löschen Sie dabei das Haupttoken. </li><li>  Ich bestelle ein neues Paar Token und füge nach Erhalt allen Diensten ein neues Haupt-Token hinzu und widerrufe das alte. </li></ul><br>  Zumindest für mich persönlich ist diese Strategie ein großartiger Kompromiss für ein hohes Maß an Sicherheit und eine einfache Sicherungslast.  Es ist sicherer und zuverlässiger als jede andere Methode. <br><br><h2>  Implementierung </h2><br><h3>  U2F-Protokollübersicht </h3><br>  Bevor wir über die Implementierung sprechen können, müssen wir auf einer bestimmten Ebene verstehen, wie U2F funktioniert.  Die meisten Hersteller implementieren es wie folgt (nicht alle der folgenden Elemente sind im Standard enthalten; einige Dinge sind Implementierungsdetails, aber die meisten vorhandenen Implementierungen funktionieren meines Wissens genau so): <br><br>  <code>device_secret</code> im U2F-Token zusammen mit einem 32-Bit- <code>counter</code> programmiert, der nur inkrementiert werden kann.  Wenn wir ein U2F-Token für einen Dienst registrieren, geschieht Folgendes: <br><br><ul><li>  Der Browser sendet die <code>AppID</code> (tatsächlich den Domänennamen) an das U2F-Gerät. </li><li>  Das Gerät generiert eine Zufallszahl ( <code>nonce</code> ), kombiniert sie mit der <code>AppID</code> , leitet sie mithilfe von <code>device_secret</code> als Schlüssel durch HMAC-SHA256 und der resultierende Hash wird zum privaten Schlüssel für diesen bestimmten Dienst: <code>service_private_key</code> ; </li><li>  Aus <code>service_private_key</code> wird der öffentliche Schlüssel <code>service_public_key</code> generiert. </li><li>  Das Gerät nimmt die <code>AppID</code> erneut, kombiniert sie mit <code>service_private_key</code> und leitet sie erneut mit <code>device_secret</code> als Schlüssel durch den HMAC-SHA256.  Das Ergebnis ( <code>MAC</code> ) wird zusammen mit der zuvor generierten <code>nonce</code> zu <code>key_handle</code> . </li><li>  Das Gerät sendet <code>key_handle</code> und <code>service_public_key</code> zurück an den Browser, und der Browser leitet an den Dienst weiter, der diese Daten für zukünftige Authentifizierungen speichert. </li></ul><br>  Die nachfolgende Authentifizierung erfolgt wie folgt: <br><br><ul><li>  Der Dienst generiert eine <code>challenge</code> (zufällig generierte Daten) und sendet sie zusammen mit <code>key_handle</code> (bestehend aus <code>nonce</code> und <code>MAC</code> ) an den Browser.  Der Browser übergibt dies alles zusammen mit der <code>AppID</code> (d. H. <code>AppID</code> Domänennamen) an das Gerät. </li><li>  Das Gerät mit <code>nonce</code> und <code>AppID</code> generiert <code>service_private_key</code> auf dieselbe Weise, wie es bei der Registrierung generiert wurde. </li><li>  Das Gerät generiert einen <code>MAC</code> auf die gleiche Weise wie bei der Registrierung. Durch den Vergleich mit dem vom Browser empfangenen <code>MAC</code> <code>nonce</code> sichergestellt, dass <code>nonce</code> nicht ersetzt wird. Daher ist <code>service_private_key</code> zuverlässig. </li><li>  Das Gerät erhöht den <code>counter</code> . </li><li>  Das Gerät signiert die <code>AppID</code> , <code>AppID</code> und den <code>counter</code> mit <code>service_private_key</code> und sendet die resultierende Signatur ( <code>signature</code> ) und den <code>counter</code> Browser, der diese Daten weiter an den Dienst überträgt. </li><li>  Der Dienst überprüft die <code>signature</code> mit dem <code>service_public_key</code> , den er nach der Registrierung hat.  Außerdem überprüfen die meisten Dienste, ob der <code>counter</code> größer als der vorherige Wert ist (wenn dies nicht die erste Authentifizierung ist).  Der Zweck dieses Tests besteht darin, das Klonen von U2F-Geräten unzugänglich zu machen.  Wenn die <code>signature</code> übereinstimmt und der <code>counter</code> größer als der vorherige Wert ist, wird die Authentifizierung als erfolgreich abgeschlossen betrachtet, und der Dienst speichert den neuen <code>counter</code> . </li></ul><br>  Lassen Sie uns nun die Details skizzieren, die in direktem Zusammenhang mit der Diskussion stehen. <br><br><h3>  Details von Interesse </h3><br>  Das erste ist, dass das Gerät nicht für jeden Dienst <code>service_private_key</code> speichert, <code>service_private_key</code> jedes Mal mit HMAC-SHA256 <code>service_private_key</code> anzeigt.  Dies ist für uns sehr wichtig: Es ist offensichtlich, dass, wenn jedes Gerät eindeutige Schlüssel für jeden Dienst separat speichern würde, sich nur dieses Gerät anschließend authentifizieren könnte. <br><br>  <i>Dies ist übrigens keine Anforderung von U2F: U2F gibt nicht an, wie Schlüssel gespeichert werden sollen, und einige frühe Implementierungen von U2F haben tatsächlich Schlüssel für jeden Dienst separat gespeichert.</i>  <i>Dieser Ansatz hat den Nachteil, dass die Anzahl der Dienste, für die das Gerät verwendet werden kann, begrenzt ist.</i>  <i>Die Ableitung von <code>service_private_key</code> beseitigt diesen Nachteil.</i> <br><br>  Und zweitens verfügt das Gerät über einen <code>counter</code> , um das Klonen zu verhindern. <br><br>  Auf den ersten Blick scheint es, dass dieser <code>counter</code> es uns nicht erlaubt, die diskutierte Sicherungsstrategie umzusetzen (zumindest schien es mir, als ich versuchte, eine Lösung zu finden), aber tatsächlich hilft er uns nur!  Ich werde es jetzt erklären. <br><br><h3>  Hauptidee </h3><br>  Die Idee ist folgende: Programmieren Sie in der Produktionsphase zwei Token so, dass beide dasselbe <code>device_secret</code> , aber das Backup-Token muss korrigiert werden: Anstatt den <code>counter</code> in seiner reinen Form zu verwenden (wie es normale Token tun), sollte es hinzugefügt werden eine große Konstante zu <code>counter</code> .  Zum Beispiel die Hälfte des 32-Bit-Bereichs, d.h.  ungefähr <code>2 000 000 000</code> , es sieht vernünftig aus: Es ist unwahrscheinlich, dass ich in meinem ganzen Leben so viele Authentifizierungen erschöpfen werde. <br><br>  Das ist alles.  Einfach und effektiv. <br><br>  Nachdem zwei Token auf diese Weise programmiert wurden, verstecke ich das Backup-Token an einem <i>wirklich</i> schwer erreichbaren Ort und berühre es nie.  Wenn etwas Schreckliches passiert und ich den Zugriff auf das Haupttoken verliere, komme ich immer noch zum Sicherungstoken und kann es sofort für alle Dienste verwenden, bei denen ich das Haupttoken registriert habe, weil  Das Backup hat das gleiche <code>device_secret</code> und sein <code>counter</code> beginnt mit einer wirklich großen Zahl, die ich für den Rest meines Lebens nicht bekomme. <br><br>  <b>Ich mache auch darauf</b> aufmerksam, dass <b>ich nicht vorschlage, Token geklont zu machen</b> .  Zwei Token haben, obwohl sie dasselbe <code>device_secret</code> haben, unterschiedliche Zähler, und nach dem Programmieren von <code>device_secret</code> sollte es keine Möglichkeit geben, sie vom Gerät zurückzubekommen oder auf andere Weise einen Klon zu erstellen. <br><br><h3>  Ein Hinweis zum Zähler </h3><br>  Ein aufmerksamer Leser kann feststellen, dass das folgende Sicherheitsproblem vorliegt: Was passiert, wenn ein Angreifer Zugriff auf das Haupttoken erhält und auf irgendeine Weise 2.000.000.000 Authentifizierungen initiiert?  Dann erhält er Zugriff auf den Dienst, auch nachdem das Sicherungstoken für diesen Dienst verwendet wurde. <br><br>  Glücklicherweise hat dieses Problem eine einfache Lösung.  In jedem Fall muss der Zähler in Hardware implementiert sein (vermutlich auf einem Kryptoprozessor), und für eine sichere Implementierung muss dieser Hardwarezähler einen Bereich von weniger als 32 Bit haben.  Beim <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ATECC508A können</a> Zähler beispielsweise nur bis 2097151 zählen. Wenn Sie also die dem Zähler hinzugefügte Konstante auf einen Wert setzen, der größer als der Maximalwert des Zählers ist, können Sie sicher sein, dass das Haupttoken niemals zum Zähler im Sicherungstoken zählen kann. <br><br>  Zur Verdeutlichung: Nehmen wir an, unser U2F-Token verwendet ATECC508A und bezeichnet den Zähler im ATECC508A als <code>hw_counter</code> .  Dann: <br><br><ul><li>  Im <code>hw_counter</code> wir für Berechnungen: <code>hw_counter</code> ; </li><li>  Im Backup-Token verwenden wir für Berechnungen: <code>hw_counter + 2000000000</code> . </li></ul><br>  Bitte beachten Sie, dass wir den echten <code>hw_counter</code> im <code>hw_counter</code> nicht ändern.  es zählt immer noch von 0 bis 2097151. Stattdessen lesen wir jedes Mal, wenn wir den <code>hw_counter</code> müssen, <code>hw_counter</code> von ATECC508A, addieren dann unsere Konstante und geben sie zurück (für weitere Berechnungen für U2F). <br><br>  Somit beträgt der Bereich der Zählerwerte im Haupttoken [0, 2097151], während der Bereich der Zählerwerte im Sicherungstoken [2000000000, 2002097151] beträgt.  Die Tatsache, dass sich diese Bereiche nicht überschneiden, stellt sicher, dass das Haupttoken bei Verwendung der Sicherung gelöscht wird (wenn der Dienst einen <code>counter</code> ; die von mir überprüften Hauptdienste verwenden ihn). <br><br><h3>  Tatsächliche Umsetzung </h3><br>  Keiner der mir bekannten Hersteller von U2F-Token unterstützt heute die erforderliche Anpassung.  Glücklicherweise gibt es eine Open-Source-Implementierung des U2F-Tokens: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SoloKeys</a> . <br><br>  Ich habe meinen ursprünglichen Artikel (auf Englisch) vor einem Jahr geschrieben, und dieser Teil ist etwas veraltet: Dann befand sich SoloKeys im Prototyping-Stadium und ich habe die vorherige Iteration des Projekts verwendet: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">u2f-zero</a> .  Daher werde ich diesen Teil jetzt nicht übersetzen, da der einzige Weg, ein u2f-zero-Gerät zu erhalten, darin besteht, es selbst zu löten, und es ist kaum ratsam, dies zu tun (obwohl es Anweisungen auf dem Github gibt). <br><br>  Trotzdem sind alle Details der notwendigen Modifikation von u2f-zero im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Originalartikel angegeben</a> . <br><br>  Wenn meine Hände die Solokeys erreichen, schreibe ich Anweisungen für deren Änderung. <br><br>  Auf die eine oder andere Weise ist dies die einzige Möglichkeit, die ich heute kenne, um ein funktionierendes U2F-Token mit einer zuverlässigen Sicherung zu erhalten.  Das Überprüfen mehrerer Dienste (mindestens Google und Github) hat gezeigt, dass dies funktioniert: Durch Registrieren des Haupttokens im Dienst können wir auch die Sicherung verwenden, und nach der ersten Verwendung der Sicherung funktioniert das Haupttoken nicht mehr.  Awwwwwww.  &lt;3 <br><br><h3>  Warnung </h3><br>  Trotz der Tatsache, dass diese Backup-Strategie cool ist, bin ich mir ihrer spezifischen Implementierung durch u2f-zero oder solokey nicht so sicher.  Dieser Weg ist der einzige Weg, um das zu bekommen, was Sie wollen, also bin ich diesen Weg gegangen;  Unter der Annahme, dass der Angreifer physischen Zugriff auf das U2F-Gerät erhält, bin ich mir nicht sicher, ob das Hacken des Geräts (d. <code>device_secret</code> das <code>device_secret</code> von <code>device_secret</code> ) so schwierig sein wird wie bei Yubikey oder anderen großen Herstellern.  Die Autoren von solokey behaupten, dass „das Sicherheitsniveau das gleiche ist wie bei einem modernen Autoschlüssel“, aber ich habe keine Untersuchungen durchgeführt, um dies zu bestätigen. <br><br>  Um ehrlich zu sein, mache ich mir darüber jedoch keine großen Sorgen.  Wenn ein Angreifer einfach einen Token stiehlt, ohne ihn zurückgeben zu wollen, spielt die Komplexität des Brechens keine Rolle, weil  Ein Angreifer kann dieses Token einfach verwenden, um auf ein Konto zuzugreifen, und beispielsweise dieses Token einfach widerrufen und ein weiteres hinzufügen.  Dafür muss ich jedoch auch andere ernsthafte Sicherheitsprobleme haben.  U2F-Token ist nur der zweite Faktor. <br><br>  Das einzige Szenario, in dem Solokey möglicherweise weniger sicher ist als etwas anderes, ist, wenn ein Angreifer versucht, für einen kurzen Zeitraum auf das Gerät zuzugreifen, <code>device_secret</code> von ihm <code>device_secret</code> und das Gerät unsichtbar an mich zurückzugeben.  Dazu muss er den Inhalt des Flash-Mikrocontrollers (oder des RAM zum richtigen Zeitpunkt) lesen, was nicht sehr trivial ist. <br><br>  Unter Berücksichtigung aller Faktoren glaube ich, dass eine zuverlässige Sicherung für mich persönlich viel wichtiger ist als eine hochsichere Hardware-Implementierung eines U2F-Geräts.  Die Wahrscheinlichkeit von Problemen mit einer solchen sicheren Implementierung und das Fehlen einer guten Sicherung ist höher als die Wahrscheinlichkeit von Problemen mit u2f-zero (solokey) und Sicherung. <br><br><h2>  Fazit </h2><br>  Die in Betracht gezogene Sicherungsstrategie übertrifft die Alternativen in allen Dimensionen: Sie ist universell, sicherer und zuverlässiger als alle anderen Methoden. <br><br>  Ich würde mich freuen, wenn mindestens einer der Haupthersteller dies in seinen Produkten umsetzt, aber es gibt noch keine Gewissheit.  Ein Mitarbeiter von Yubico, James A., sagte mir sogar, dass die Implementierung des Backups nach Bedarf mit der Art und Weise, wie U2F entworfen wurde, nicht möglich sei. Nachdem ich die Implementierungsdetails dargelegt hatte, reagierte es einfach nicht mehr. <br><br>  Zum Glück war dies nicht so unmöglich, wie Yubico glaubt. <br><br><hr><br>  <i>Mein Originalartikel auf Englisch: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zuverlässige, sichere und universelle Sicherung für U2F-Token</a> .</i>  <i>Weil</i>  <i>Der Autor des Originalartikels bin ich selbst. Mit Ihrer Erlaubnis habe ich diesen Artikel nicht in die Kategorie „Übersetzung“ eingeordnet</i> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de474300/">https://habr.com/ru/post/de474300/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de474284/index.html">Nicht nur Futures und Optionen: Welche anderen sekundären Finanzinstrumente gibt es an Börsen und nicht nur</a></li>
<li><a href="../de474286/index.html">Detaillierte Analyse der Simplex-Methode</a></li>
<li><a href="../de474292/index.html">JavaFX-Tutorial: Erste Schritte</a></li>
<li><a href="../de474294/index.html">Binärkompatibilität: jetzt oder nie</a></li>
<li><a href="../de474298/index.html">Implementieren eines P2P-Gateways von Karte zu Karte</a></li>
<li><a href="../de474302/index.html">So schreiben Sie ein effektives Anwendungsbenutzbarkeitstestskript</a></li>
<li><a href="../de474306/index.html">Ändern Sie die Stile für Zeigen, Fokussieren und aktiven Status.</a></li>
<li><a href="../de474308/index.html">In Python geschriebene Typen für HTTP-APIs: Instagram-Erfahrung</a></li>
<li><a href="../de474310/index.html">Gibt es Zufallszahlen in CSS?</a></li>
<li><a href="../de474312/index.html">Installieren der GUI unter Windows Server Core</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>