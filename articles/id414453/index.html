<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😫 ⬛️ ⏪ Menerapkan Path Finder untuk Agen AI dengan NavMesh 🥝 👖 🌺</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mengikuti jalur dan mengendalikan lalu lintas 
 Terkadang kita membutuhkan karakter AI untuk berkeliaran di dunia game, mengikuti jalur yang ditentuka...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menerapkan Path Finder untuk Agen AI dengan NavMesh</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414453/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/11d/4c5/6ad/11d4c56ad10246e5cb9e56e641938b59.png" alt="gambar"></div><br><h2>  Mengikuti jalur dan mengendalikan lalu lintas </h2><br>  Terkadang kita membutuhkan karakter AI untuk berkeliaran di dunia game, mengikuti jalur yang ditentukan secara kasar atau ditentukan dengan tepat.  Misalnya, dalam permainan balapan, lawan AI harus melakukan perjalanan di sepanjang jalan, dan di RTS, unit harus dapat bergerak ke titik yang diinginkan, bergerak di sepanjang medan dan memperhitungkan posisi masing-masing. <br><br>  Agar tampak cerdas, agen AI harus dapat menentukan apa yang mereka lakukan, dan jika mereka tidak dapat mencapai titik yang diinginkan, maka mereka harus dapat merencanakan rute yang paling efektif dan mengubah jalur mereka ketika ada hambatan di jalan. <br><br>  Menghindari rintangan adalah perilaku sederhana yang memungkinkan entitas AI mencapai titik target.  Penting untuk dicatat bahwa perilaku yang diterapkan dalam posting ini adalah untuk perilaku seperti simulasi kerumunan, di mana tujuan utama setiap agen adalah untuk menghindari agen lain dan mencapai tujuan.  Mereka tidak menentukan jalur yang paling efisien dan terpendek. <br><br><h2>  Persyaratan teknis </h2><br>  Membutuhkan Unity 2017 diinstal pada sistem dengan Windows 7 SP1 +, 8, 10, atau Mac OS X 10.9+.  Kode dalam artikel ini tidak akan berfungsi pada Windows XP dan Vista, dan versi server Windows dan OS X belum diuji. <br><br>  File kode untuk posting ini dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">GitHub</a> . <br><br>  Untuk mempelajari kode ini dalam aksi, tonton <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">video ini</a> . <br><a name="habracut"></a><br><h2>  Jala navigasi </h2><br>  Mari kita cari tahu cara menggunakan generator mesh navigasi Unity bawaan, yang dapat sangat menyederhanakan pencarian jalur untuk agen AI.  Pada tahap awal Unity 5.x, fungsi NavMesh menjadi tersedia untuk semua pengguna, termasuk yang memiliki lisensi edisi pribadi, meskipun sebelumnya hanya berfungsi untuk Unity Pro.  Sebelum rilis 2017.1, sistem telah diperbarui untuk menyediakan alur kerja berbasis komponen, tetapi karena membutuhkan paket tambahan yang dapat diunduh, yang pada saat penulisan ini hanya tersedia dalam versi pratinjau, kami akan mematuhi alur kerja berbasis adegan standar.  Jangan khawatir, konsep kedua pendekatan itu serupa, dan ketika implementasi yang telah selesai akhirnya mencapai 2017.x, seharusnya tidak ada perubahan signifikan. <br><br>  Pelajari lebih lanjut tentang sistem komponen NavMesh di Unity on <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">GitHub</a> . <br><br>  Sekarang kita akan mengeksplorasi semua kemungkinan yang dapat ditawarkan oleh sistem ini kepada kita.  Untuk mencari jalur AI, adegan harus disajikan dalam format tertentu;  pada peta 2D, grid dua dimensi (array) digunakan untuk mencari jalur menggunakan algoritma A *.  Agen AI perlu tahu di mana hambatannya, terutama yang statis.  Berurusan dengan tabrakan antara objek yang bergerak secara dinamis adalah masalah lain yang biasa disebut sebagai perilaku kemudi.  Unity memiliki alat bawaan untuk menghasilkan NavMesh, mewakili adegan dalam konteks yang nyaman bagi agen AI untuk menemukan jalur optimal ke target.  Untuk memulai, buka proyek demo dan buka adegan NavMesh. <br><br><h3>  Kartu belajar </h3><br>  Setelah membuka adegan demo NavMesh, seharusnya terlihat seperti pada tangkapan layar: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a3/35c/15a/7a335c15ad8084dee2aab59de7cdcd3f.png"></div><br>  <em>Adegan hambatan dan kemiringan</em> <br><br>  Ini akan menjadi kotak pasir kami untuk menjelaskan dan menguji fungsionalitas sistem NavMesh.  Skema umum mirip dengan game dalam genre RTS (strategi real-time).  Kami mengendarai tangki biru.  Klik pada titik yang berbeda sehingga tangki bergerak ke arah mereka.  Indikator kuning adalah target tangki saat ini. <br><br><h3>  Navigasi statis </h3><br>  Pertama, Anda perlu mengatakan bahwa Anda harus menandai semua geometri dalam adegan, dipanggang di NavMesh, sebagai <b>Navigasi Statis</b> .  Anda mungkin pernah melihat ini sebelumnya, misalnya, dalam sistem peta pencahayaan Unity.  Untuk membuat objek game statis sangat sederhana, cukup centang kotak <b>Statis</b> untuk semua propertinya (navigasi, pencahayaan, culling, batching, dll.), Atau gunakan daftar drop-down untuk menentukan properti.  Kotak centang terletak di sudut kanan atas inspektur objek yang dipilih. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7c/cfd/224/f7ccfd224088652d0831282397b5eb5c.png"></div><br>  <em>Navigasi Properti Statis</em> <br><br>  Ini dapat dilakukan secara individual untuk objek yang berbeda atau, jika Anda memiliki hierarki objek game bawaan, terapkan parameter ke objek induk, setelah itu Unity akan menawarkan untuk menerapkannya ke semua objek anak. <br><br><h3>  Memanggang Mesh Navigasi </h3><br>  Untuk keseluruhan adegan, opsi navigasi navmesh diterapkan menggunakan jendela <b>Navigasi</b> .  Jendela ini dapat dibuka dengan masuk ke <b>Jendela</b> |  <b>Navigasi</b>  Seperti jendela lainnya, jendela dapat diputus untuk gerakan bebas atau diperbaiki.  Di tangkapan layar kami, ditampilkan sebagai tab merapat di sebelah hierarki, tetapi Anda dapat meletakkan jendela ini di tempat yang nyaman. <br><br>  Membuka jendela, Anda akan melihat tab individual.  Akan terlihat seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/872/7a6/b30/8727a6b301be8f979821ab0446ce5e7d.png"></div><br>  <em>Jendela Navigasi</em> <br><br>  Dalam kasus kami, tangkapan layar sebelumnya menunjukkan tab <b>Bake</b> , tetapi di editor Anda, tab apa pun dapat dipilih secara default. <br><br>  Mari kita lihat masing-masing tab, mulai dari kiri dan pindah ke kanan.  Mari kita mulai dengan tab <b>Agen</b> , yang terlihat seperti tangkapan layar menunjukkan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e2/3e9/db3/9e23e9db3a55b407af7a7bde83c56c4b.png"></div><br>  <em>Tab Agen</em> <br><br>  Jika Anda mengerjakan proyek lain, Anda mungkin menemukan bahwa beberapa pengaturan berbeda dari yang kami atur untuk proyek contoh yang ditunjukkan pada tangkapan layar.  Di bagian atas tab ada daftar di mana Anda dapat menambahkan jenis agen baru dengan mengklik tombol <b>+</b> .  Anda dapat menghapus agen tambahan dengan memilihnya dan mengklik tombol <b>-</b> .  Jendela dengan jelas menunjukkan apa yang dilakukan berbagai pengaturan saat mengubahnya.  Mari kita lihat apa yang dilakukan masing-masing pengaturan: <br><br><ul><li>  Nama: nama jenis agen yang ditampilkan dalam daftar turun-bawah Jenis Agen. </li><li>  Radius: Anda dapat menganggapnya sebagai "ruang pribadi" agen.  Agen akan mencoba untuk menghindari kontak yang terlalu dekat dengan agen lain berdasarkan nilai ini, karena digunakan dalam penghindaran. </li><li>  Tinggi: seperti yang Anda duga, pengaturan ini menetapkan ketinggian agen yang digunakannya untuk penghindaran vertikal (misalnya, ketika melewati benda-benda di bawah). </li><li>  Tinggi Langkah: nilai ini menentukan ketinggian apa yang bisa dipanjat agen. </li><li>  Max Slope: seperti yang akan kita lihat dari bagian selanjutnya, nilai ini menentukan sudut maksimum di mana agen dapat naik.  Dengan menggunakan parameter ini, Anda dapat membuat lereng curam peta tidak dapat diakses oleh agen. </li></ul><br>  Selanjutnya, kami memiliki tab <b>Area</b> , yang terlihat seperti yang ditunjukkan pada tangkapan layar ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/68b/e36/4f6/68be364f6605a8b3f567dfeb31bf56db.png"></div><br>  Seperti yang dapat Anda lihat di tangkapan layar, Unity menyediakan beberapa jenis area yang tidak dapat diubah: <b>Walkable</b> , <b>Not Walkable,</b> dan <b>Jump</b> .  Selain memberi nama dan membuat area baru, Anda dapat menetapkan biaya untuk bergerak di area tersebut. <br><br>  Area melayani dua tujuan: membuat area dapat diakses atau tidak dapat diakses oleh agen, dan menandai area yang kurang diinginkan dalam hal biaya perjalanan.  Misalnya, Anda dapat mengembangkan RPG di mana musuh iblis tidak dapat memasuki area yang ditandai sebagai "tanah yang dikuduskan".  Anda juga dapat menandai beberapa area peta sebagai "rawa" atau "rawa", yang akan dihindari agen karena tingginya biaya bergerak. <br><br>  Tab <b>Panggang</b> ketiga mungkin yang paling penting.  Ini memungkinkan Anda untuk membuat NavMesh sendiri untuk adegan itu.  Anda harus sudah terbiasa dengan beberapa opsi.  Tab <b>Bake</b> terlihat seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/16a/fc2/a66/16afc2a6659910152c0f4d673c9bcacb.png"></div><br>  <em>Bake tab</em> <br><br>  Opsi ukuran agen pada tab ini menentukan bagaimana agen akan berinteraksi dengan lingkungan, sedangkan opsi pada tab <b>Agen</b> mengontrol interaksi dengan agen lain dan objek bergerak.  Tetapi mereka mengontrol parameter yang sama, jadi kita akan melewatkannya.  <b>Jatuhkan Tinggi</b> dan <b>Jarak Lompat</b> mengontrol seberapa jauh agen dapat "melompat" untuk mencapai bagian NavMesh yang tidak terkait langsung dengan bagian di mana agen saat ini berada.  Kami akan mempertimbangkan ini secara lebih rinci di bawah ini, jadi jika Anda tidak yakin, maka Anda masih tidak dapat mempelajari parameter ini. <br><br>  Selain itu, ada opsi lanjutan yang biasanya disembunyikan secara default.  Untuk memperluas opsi ini, cukup klik pada segitiga tarik-turun di sebelah tajuk <b>Tingkat Lanjut</b> .  <b>Ukuran Manual Voxel</b> dapat dianggap sebagai pengaturan "kualitas".  Semakin kecil ukurannya, semakin banyak detail yang akan disimpan dalam jaring.  <b>Area Wilayah Min</b> digunakan untuk melewati platform pemanggangan atau permukaan di bawah ambang batas yang dipilih.  <b>Tinggi Mesh</b> memberi kita data vertikal yang lebih rinci saat memanggang mesh.  Misalnya, opsi ini memungkinkan Anda untuk mempertahankan lokasi agen yang benar saat menaiki tangga. <br><br>  Tombol <b>Hapus</b> menghapus semua data NavMesh dari adegan tersebut, dan tombol <b>Bake</b> menciptakan mesh untuk adegan tersebut.  Proses memanggang cukup cepat.  Selama Anda memiliki jendela yang dipilih, Anda dapat mengamati generasi NavMesh dengan tombol <b>Bake</b> di jendela adegan.  Mari klik tombol <b>Bake</b> untuk melihat hasilnya.  Dalam contoh adegan kami, kami berakhir dengan sesuatu yang mirip dengan tangkapan layar ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/11d/4c5/6ad/11d4c56ad10246e5cb9e56e641938b59.png"></div><br>  Area biru menunjukkan NavMesh.  Di bawah ini kami akan kembali ke sini.  Sementara itu, mari kita beralih ke tab terakhir - <b>Obyek</b> , yang terlihat seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b44/6c7/4e8/b446c74e8154bca80133ff95ce378d31.png"></div><br>  Tiga tombol yang diperlihatkan dalam tangkapan layar sebelumnya - <b>All</b> , <b>Mesh Renderers,</b> dan <b>Terrains</b> - digunakan sebagai filter adegan.  Mereka berguna saat bekerja dalam adegan kompleks dengan banyak objek dalam hierarki.  Memilih opsi memfilter jenis yang sesuai dari hierarki, membuatnya mudah untuk memilihnya.  Anda dapat menggunakan tombol untuk menjelajahi adegan Anda dalam mencari objek yang ingin Anda tandai sebagai navigasi statis. <br><br><h3>  Menggunakan Agen Nav Mesh </h3><br>  Sekarang kami telah menyiapkan adegan dengan NavMesh, kami membutuhkan cara bagi agen untuk menggunakan informasi ini.  Untungnya bagi kami, Unity memiliki komponen <b>Nav Mesh Agent</b> yang dapat Anda seret ke karakter.  Dalam adegan contoh kami, ada objek permainan yang disebut <b>Tank</b> , yang komponennya sudah terpasang.  Lihatlah hierarki dan Anda akan melihat sesuatu seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a31/3ba/68f/a313ba68f88b2417e0225c6f724cbce8.png"></div><br>  Ada beberapa parameter di sini, dan kami tidak akan mempertimbangkan semuanya, karena cukup jelas, dan uraiannya dapat ditemukan di dokumentasi resmi Unity.  Tetapi kami akan menyebutkan hal-hal utama: <br><br><ul><li>  <strong>Jenis Agen</strong> : Ingat tab <strong>Agen</strong> di jendela <strong>Navigasi</strong> ?  Jenis agen yang dapat ditugaskan dapat dipilih di sini. </li><li>  <strong>Auto Traverse Off Mesh Link</strong> : Opsi ini memungkinkan agen untuk secara otomatis menggunakan fitur <strong>Off Mesh Links</strong> , yang akan kita bahas di bawah ini. </li><li>  <strong>Area Mask</strong> : di sini Anda dapat memilih area yang dikonfigurasikan di tab <strong>Area</strong> pada jendela <strong>Navigasi</strong> . </li></ul><br>  Itu saja.  Komponen ini melakukan 90% kerja keras untuk kita: membuka jalan, menghindari rintangan, dan sebagainya.  Satu-satunya hal yang Anda butuhkan adalah mentransfer titik target ke agen.  Mari kita lihat masalah ini. <br><br><h3>  Pengaturan Titik Target </h3><br>  Setelah mengatur agen AI, kita perlu cara untuk memberitahunya ke mana harus pergi.  Dalam proyek contoh kami, ada skrip bernama <b>Target.cs</b> yang melakukan tugas ini dengan tepat. <br><br>  Ini adalah kelas sederhana yang melakukan tiga hal: <br><br><ul><li>  “Tembak” pancaran dari kamera ke posisi mouse di dunia </li><li>  Memperbarui posisi marker </li><li>  Memperbarui properti tujuan untuk semua agen NavMesh. </li></ul><br>  Kode ini cukup sederhana.  Seluruh kelas adalah sebagai berikut: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.AI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Target</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NavMeshAgent[] navAgents; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform targetMarker; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { navAgents = FindObjectsOfType(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(NavMeshAgent)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> NavMeshAgent[]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateTargets</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 targetPosition </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(NavMeshAgent agent <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> navAgents) { agent.destination = targetPosition; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(GetInput()) { Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hitInfo; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray.origin, ray.direction, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hitInfo)) { Vector3 targetPosition = hitInfo.point; UpdateTargets(targetPosition); targetMarker.position = targetPosition; } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetInput</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmos</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Debug.DrawLine(targetMarker.position, targetMarker.position + Vector3.up * <span class="hljs-number"><span class="hljs-number">5</span></span>, Color.red); } }</code> </pre> <br>  Tindakan berikut terjadi di sini: di metode <b>Mulai</b> , kami menginisialisasi array <b>navAgents</b> menggunakan metode <b>FindObjectsOfType ()</b> . <br><br>  Metode <b>UpdateTarget ()</b> melewati array <b>navAgents</b> kami dan menetapkan titik target untuk mereka dalam <b>Vector3 yang</b> diberikan.  Ini adalah kunci kode.  Anda dapat menggunakan mekanisme apa pun untuk mendapatkan titik target, dan agar agen pindah ke sana, cukup setel bidang <b>NavMeshAgent.destination</b> ;  agen akan melakukan sisanya. <br><br>  Dalam contoh kami, klik digunakan untuk bergerak, jadi ketika pemain mengklik mouse, kami melepaskan sinar dari kamera ke dunia ke arah kursor mouse, dan jika berpotongan dengan sesuatu, maka kami menetapkan titik tumbukan ke agen <b>targetPosisi yang</b> baru.  Kami juga menyesuaikan penanda target sesuai dengan mudah memvisualisasikan tujuan dalam permainan. <br><br>  Untuk menguji operasi, Anda perlu memanggang NavMesh sesuai dengan deskripsi dari bagian sebelumnya, lalu mulai mode Putar dan pilih area mana saja di peta.  Jika Anda mengklik berkali-kali, Anda dapat melihat bahwa agen tidak dapat mencapai beberapa area - bagian atas kubus merah, platform atas dan platform di bagian bawah layar. <br><br>  Kubus merah terlalu tinggi.  Kemiringan yang mengarah ke platform tertinggi terlalu tajam untuk pengaturan <b>Max Slope</b> kami, dan agen tidak dapat memanjatnya.  Tangkapan layar berikut menunjukkan bagaimana pengaturan <b>Max Slope</b> memengaruhi NavMesh: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd7/539/7b8/fd75397b851d088fc1fd8d4d53210cc9.png"></div><br>  <i>NavMesh dengan kemiringan maks = 45</i> <br><br>  Jika Anda mengubah nilai <b>Max Slope</b> ke sesuatu seperti <b>51</b> , dan kemudian klik tombol <b>Bake</b> lagi untuk memanggang NavMesh lagi, hasilnya adalah sebagai berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09a/936/b78/09a936b78c4958c9200d00867dbbc418.png"></div><br>  <em>NavMesh dengan kemiringan maksimum = 51</em> <br><br>  Seperti yang Anda lihat, kami dapat menyesuaikan desain level, membuat seluruh area tidak dapat diakses dengan mengubah satu parameter.  Ini bisa berguna, misalnya, ketika Anda memiliki platform atau langkan yang membutuhkan tali, tangga atau lift untuk dipanjat.  Atau mungkin keterampilan khusus, misalnya, kemampuan memanjat? <br><br><h3>  Aplikasi Off Mesh Links </h3><br>  Anda mungkin memperhatikan bahwa ada dua jeda di adegan kami.  Agen kami dapat masuk ke yang pertama, tetapi yang di bagian bawah layar terlalu jauh.  Perhitungan ini tidak sepenuhnya arbitrer.  <strong>Off Mesh Links</strong> pada dasarnya membuat jembatan melintasi ruang antara segmen NavMesh yang tidak terkait.  Tautan ini dapat dilihat di editor: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4b/b0a/425/b4bb0a425446298ae08ea4684bbcef10.png"></div><br>  <i>Lingkaran biru dengan garis penghubung adalah koneksi.</i> <br><br>  Unity dapat menghasilkan tautan ini dalam dua cara.  Yang pertama sudah kami pertimbangkan.  Ingat nilai <b>Jump Distance</b> di tab <b>Bake</b> pada jendela <b>Navigasi</b> ?  Unity secara otomatis menggunakan nilai itu untuk menghasilkan tautan ini saat memanggang NavMesh.  Coba ubah nilainya di adegan pengujian kami menjadi 5 dan buat lagi.  Lihat - platform sekarang terhubung?  Ini karena jerat sekarang dalam ambang yang ditentukan baru. <br><br>  Ubah nilainya menjadi 2 lagi dan panggang.  Sekarang mari kita lihat cara kedua.  Buat bola yang akan digunakan untuk menghubungkan kedua platform.  Tempatkan kira-kira seperti yang ditunjukkan pada tangkapan layar: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7a/28e/020/a7a28e020255bb8855d48017da4188f1.png"></div><br>  Anda sudah dapat melihat apa yang terjadi, tetapi mari kita menganalisis proses yang memungkinkan mereka terhubung.  Dalam kasus kami, saya menyebut bola di <b>awal yang</b> benar, dan bola di <b>ujung</b> kiri.  Anda akan segera mengerti mengapa.  Selanjutnya, saya menambahkan komponen <b>Off Mesh Link</b> ke platform di sebelah kanan (relatif terhadap tangkapan layar sebelumnya).  Anda akan melihat bahwa komponen memiliki bidang <b>awal</b> dan <b>akhir</b> .  Seperti yang Anda tebak, kami akan menyeret bola yang dibuat sebelumnya ke slot yang sesuai - bola awal di bidang <b>awal</b> dan bola akhir di bidang <b>akhir</b> .  Inspektur akan terlihat seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/720/2b4/251/7202b4251068b5d0b1b8b1d7e4b09ff2.png"></div><br>  Nilai <b>Override Biaya</b> diperhitungkan saat diberi nilai positif.  Ini menerapkan faktor biaya ketika menggunakan hubungan ini sebagai lawan dari rute yang lebih hemat biaya ke target. <br><br>  <b>Bi Directional</b> jika benar memungkinkan agen bergerak ke dua arah.  Untuk membuat tautan dengan lalu lintas satu arah, Anda dapat menonaktifkan nilai ini.  Nilai <b>Activated</b> digunakan sesuai dengan namanya.  Jika salah, agen mengabaikan hubungan ini.  Anda dapat menghidupkan dan mematikannya untuk membuat skenario permainan di mana, misalnya, pemain harus menekan sakelar untuk mengaktifkan koneksi. <br><br>  Untuk mengaktifkan hubungan ini, memanggang ulang tidak diperlukan.  Lihatlah NavMesh Anda dan Anda akan melihat bahwa tampilannya persis seperti pada tangkapan layar: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be8/15a/e57/be815ae574360beea94d8907e37fc309.png"></div><br>  Seperti yang Anda lihat, celah yang lebih kecil masih terhubung secara otomatis, dan sekarang kami memiliki koneksi baru yang dihasilkan oleh komponen <b>Off Mesh Link</b> antara dua bola.  Luncurkan mode Putar dan klik pada platform jauh.  Seperti yang diharapkan, agen sekarang dapat menavigasi ke platform terputus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f6/0c7/a61/7f60c7a61db24f3961ea0b7332de56a1.png"></div><br>  Di level gim Anda, Anda mungkin perlu mengubah parameter ini untuk mencapai hasil yang diinginkan, tetapi kombinasi fitur-fitur ini memberi Anda alat yang nyaman dan siap pakai.  Anda dapat dengan cepat membuat game sederhana menggunakan fungsionalitas NavMesh. <br><br>  <em>Tutorial ini adalah bagian dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="external nofollow">Pemrograman AI Game Unity 2017 - Edisi Ketiga</a> oleh Ray Barrera, Aung Sithu Kyaw dan Thet Naing Swe.</em> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id414453/">https://habr.com/ru/post/id414453/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id414443/index.html">Fitur panggilan fungsi di C ++</a></li>
<li><a href="../id414445/index.html">Meningkatkan Zimbra dengan Zextras Suite</a></li>
<li><a href="../id414447/index.html">Macam-macam sepanjang masa</a></li>
<li><a href="../id414449/index.html">Cara berteman dengan semua operator di stadion dan tidak menaburnya dengan ratusan antena</a></li>
<li><a href="../id414451/index.html">"Kalender Tester" untuk bulan Juni. Penguji harus menangkap bug, membaca Caner dan mengatur gerakan.</a></li>
<li><a href="../id414455/index.html">Algoritma Generasi Palet Warna</a></li>
<li><a href="../id414459/index.html">Detektor dan deskriptor poin tunggal CEPAT, SINGKAT, ORB</a></li>
<li><a href="../id414463/index.html">AI sendiri belajar cara membangun Rubik's Cube</a></li>
<li><a href="../id414465/index.html">Meta Crush Saga: game kompilasi-waktu</a></li>
<li><a href="../id414467/index.html">Makalah dari Minsk C ++ Conference CoreHard Spring 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>