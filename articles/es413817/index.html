<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìó üåÖ üë∏üèº Procesamiento de datos competitivos heterog√©neos en tiempo real estrictamente una vez ü§üüèº ü§úüèΩ üè´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Anotaci√≥n 


 El procesamiento de datos en tiempo real exactamente una vez ( exactamente una vez ) es una tarea extremadamente trivial y requiere un e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Procesamiento de datos competitivos heterog√©neos en tiempo real estrictamente una vez</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413817/"><p><img src="https://habrastorage.org/webt/uf/mh/m-/ufmhm-q0wjfbdgbv4jn4ece8duw.jpeg" alt="Salchicha competitiva"></p><br><h2 id="annotaciya">  Anotaci√≥n </h2><br><p>  El procesamiento de datos en tiempo real exactamente una vez ( <em>exactamente una vez</em> ) es una tarea extremadamente trivial y requiere un enfoque serio y reflexivo en toda la cadena de c√°lculos.  Algunos incluso creen que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tal tarea es imposible</a> .  En realidad, quiero tener un enfoque que proporcione un procesamiento tolerante a fallas sin demora y el uso de varios almacenamientos de datos, que presente nuevos requisitos a√∫n m√°s estrictos para el sistema: <em>concurrente exactamente una vez</em> y heterogeneidad de la capa persistente.  Hasta la fecha, dicho requisito no es compatible con ninguno de los sistemas existentes. </p><br><p>  El enfoque propuesto revelar√° consistentemente los ingredientes secretos y los conceptos necesarios que hacen que sea relativamente f√°cil implementar <em>un</em> procesamiento heterog√©neo <em>concurrente exactamente una vez</em> literalmente a partir de dos componentes. </p><br><h2 id="vvedenie">  Introduccion </h2><br><p>  El desarrollador de sistemas distribuidos pasa por varias etapas: </p><br><p>  <em>Etapa 1: Algoritmos</em> .  Aqu√≠ est√° el estudio de algoritmos b√°sicos, estructuras de datos, enfoques de programaci√≥n como OOP, etc.  El c√≥digo es exclusivamente de un solo subproceso.  La fase inicial de ingreso a la profesi√≥n.  Sin embargo, es bastante complicado y puede durar a√±os. </p><br><p>  <em>Etapa 2: Multithreading</em> .  Luego, surgen preguntas sobre la extracci√≥n de la m√°xima eficiencia del hierro, hay m√∫ltiples subprocesos, asincron√≠a, carreras, depuraci√≥n, strace, noches sin dormir ... Muchos se quedan atrapados en esta etapa e incluso comienzan a sentir una emoci√≥n inexplicable en alg√∫n momento.  Pero solo unos pocos llegan a comprender la arquitectura de la memoria virtual y los modelos de memoria, los algoritmos sin bloqueo / sin espera y varios modelos asincr√≥nicos.  Y casi nadie: verificaci√≥n de c√≥digo de subprocesos m√∫ltiples. </p><br><p>  <em>Etapa 3: Distribuci√≥n</em> .  Aqu√≠ est√° sucediendo tal basura que ni en un cuento de hadas ni en un bol√≠grafo para describir. </p><a name="habracut"></a><br><p>  Parecer√≠a que algo complicado.  Hacemos la transformaci√≥n: muchos hilos -&gt; muchos procesos -&gt; muchos servidores.  Pero cada paso de la transformaci√≥n produce cambios cualitativos, y todos caen en el sistema, lo aplastan y lo convierten en polvo. </p><br><p>  Y el punto aqu√≠ es cambiar el dominio de manejo de errores y la disponibilidad de memoria compartida.  Si antes siempre hab√≠a un trozo de memoria disponible en cada subproceso, y si se deseaba, en cada proceso, ahora no existe ese trozo y no puede existir.  Cada uno para s√≠ mismo, independiente y orgulloso. </p><br><p>  Si antes una falla en la corriente enterraba la corriente y el proceso al mismo tiempo, y esto era bueno, porque  no condujo a fallas parciales, ahora las fallas parciales se convierten en la norma y cada vez que piensa cada acci√≥n: "¬øy si?".  Esto es tan molesto y distrae de la escritura, de hecho, las acciones en s√≠ mismas que el c√≥digo debido a esto no crece a veces, sino por √≥rdenes de magnitud.  Todo se convierte en los fideos de manejo de errores, cambio de estado y preservaci√≥n del contexto, restauraci√≥n debido a fallas de un componente, otro componente, inaccesibilidad de algunos servicios, etc.  etc.  Despu√©s de haber estropeado el monitoreo de todo esto, puede tener una buena noche de sue√±o en su computadora port√°til favorita. </p><br><p>  Si se trata de subprocesos m√∫ltiples: tom√© el mutex y fui a triturar la memoria compartida por placer.  Belleza! </p><br><p>  Como resultado, tenemos que se quitaron las claves y los patrones probados en la batalla, y los nuevos, para reemplazarlos, por alguna raz√≥n no se entregaron, y result√≥ como en una broma sobre c√≥mo la hada agit√≥ su varita y la torre se cay√≥ del tanque. </p><br><p>  Sin embargo, los sistemas distribuidos tienen un conjunto de pr√°cticas y algoritmos probados.  Sin embargo, cada programador que se respete a s√≠ mismo considera que es su deber rechazar los logros conocidos y andar en bicicleta por su propio bien, a pesar de la experiencia adquirida, un n√∫mero considerable de art√≠culos cient√≠ficos e investigaciones acad√©micas.  Despu√©s de todo, si puede usar algoritmos y subprocesos m√∫ltiples, ¬øc√≥mo puede meterse en un l√≠o con la distribuci√≥n?  ¬°No puede haber dos opiniones aqu√≠! </p><br><p>  Como resultado, los sistemas tienen errores, los datos divergen y se deterioran, los servicios peri√≥dicamente no est√°n disponibles para la escritura, o incluso no est√°n completamente disponibles, porque de repente un nodo se bloque√≥, la red se cay√≥, Java consumi√≥ mucha memoria y GC se aburri√≥, y hay muchas otras razones que podr√≠an retrasar su finalizaci√≥n. a las autoridades. </p><br><p>  Sin embargo, incluso con enfoques conocidos y probados, la vida no se vuelve m√°s f√°cil, porque  Las primitivas confiables distribuidas son pesadas con requisitos serios para la l√≥gica del c√≥digo ejecutable.  Por lo tanto, las esquinas se cortan siempre que sea posible.  Y, como suele suceder, con esquinas cortadas apresuradamente, aparece la simplicidad y la escalabilidad relativa, pero la confiabilidad, disponibilidad y consistencia de un sistema distribuido desaparece. </p><br><p>  Idealmente, me gustar√≠a no pensar en absoluto que nuestro sistema est√° distribuido y multiproceso, es decir  trabajar en la primera etapa (algoritmos), sin pensar en la segunda (subprocesamiento m√∫ltiple + asincron√≠a) y la tercera (distribuci√≥n).  Esta forma de aislar abstracciones aumentar√≠a significativamente la simplicidad, confiabilidad y velocidad de escribir c√≥digo.  Desafortunadamente, por el momento esto solo es posible en los sue√±os. </p><br><p>  Sin embargo, las abstracciones individuales permiten un relativo aislamiento.  Uno de los ejemplos t√≠picos es el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">uso de corutinas</a> , donde en lugar de c√≥digo asincr√≥nico nos hacemos sincr√≥nicos, es decir.  pasamos de la segunda etapa a la primera etapa, lo que nos permite simplificar significativamente la escritura y el mantenimiento del c√≥digo. </p><br><p>  El art√≠culo revela sucesivamente el uso de algoritmos sin bloqueo para construir un sistema confiable en tiempo real, escalable, distribuido y consistente, es decir  c√≥mo los logros sin bloqueo de la segunda etapa ayudan en la implementaci√≥n de la tercera, reduciendo la tarea a algoritmos de subproceso √∫nico de la primera etapa. </p><br><h2 id="postanovka-zadachi">  Declaraci√≥n del problema. </h2><br><p>  Esta tarea solo ilustra algunos enfoques importantes y se presenta como un ejemplo para introducir problemas en el contexto.  Se puede generalizar f√°cilmente a casos m√°s complejos, lo que se har√° en el futuro. </p><br><p>  <strong>Tarea: procesamiento de datos en tiempo real</strong> . </p><br><p>  Hay dos corrientes de n√∫meros.  El controlador lee los datos de estos flujos de entrada y selecciona los √∫ltimos n√∫meros para un per√≠odo determinado.  Estos n√∫meros se promedian durante este intervalo de tiempo, es decir  en una ventana de datos deslizante durante un tiempo determinado.  El valor promedio obtenido debe escribirse en la cola de salida para el procesamiento posterior.  Adem√°s, si el n√∫mero de n√∫meros en la ventana excede un cierto umbral, aumente en uno el contador en la base de datos transaccional externa. </p><br><p><img src="https://habrastorage.org/webt/nf/9d/jh/nf9djhbhsjmrumrg5eckb1h6u_c.png" alt="Inicial"></p><br><p>  Observamos algunas caracter√≠sticas de este problema. </p><br><ol><li>  <em>No determinismo</em> .  Hay dos fuentes de comportamiento no determinista: esta es una lectura de dos flujos, as√≠ como una ventana de tiempo.  Est√° claro que la lectura puede llevarse a cabo de diferentes maneras, y el resultado final depender√° de en qu√© secuencia se extraer√°n los datos.  La ventana de tiempo tambi√©n cambia el resultado de inicio a inicio, ya que  La cantidad de datos en la ventana depender√° de la velocidad del trabajo. </li><li>  <em>El estado del manejador</em> .  Hay un estado del controlador en forma de un conjunto de n√∫meros en la ventana, del que dependen los resultados actuales y posteriores del trabajo.  Es decir  Tenemos un controlador con estado. </li><li>  <em>Interacci√≥n con almacenamiento externo</em> .  Es necesario actualizar el valor del contador en la base de datos externa.  El punto crucial es que el tipo de almacenamiento externo es diferente del almacenamiento del estado del procesador y los subprocesos. </li></ol><br><p>  Todo esto, como se mostrar√° a continuaci√≥n, afecta seriamente las herramientas utilizadas y los posibles m√©todos de implementaci√≥n. </p><br><p>  Queda por agregar un peque√±o toque a la tarea, que inmediatamente transfiere la tarea de un √°rea m√°s all√° de la complejidad a lo imposible: se necesita <em>una</em> garant√≠a <em>concurrente de una sola vez</em> . </p><br><h2 id="exactly-once">  Exactamente una vez </h2><br><p>  <em>Exactamente una vez a</em> menudo se interpreta de manera demasiado amplia, lo que emascula el t√©rmino en s√≠ mismo, y deja de cumplir con los requisitos originales de la tarea.  Si estamos hablando de un sistema que se ejecuta localmente en una computadora, entonces todo es simple: toma m√°s, tira m√°s.  Pero en este caso estamos hablando de un sistema distribuido en el que: </p><br><ol><li>  El n√∫mero de manejadores puede ser grande: cada manejador trabaja con sus propios datos.  Adem√°s, los resultados se pueden agregar a varios lugares, por ejemplo, una base de datos externa, posiblemente incluso barajada. </li><li>  Cada controlador puede detener repentinamente el procesamiento.  Un sistema tolerante a fallas implica una operaci√≥n continua incluso en caso de falla de partes individuales del sistema. </li></ol><br><p>  Por lo tanto, debemos estar preparados para el hecho de que el controlador puede caer, y otro controlador debe recoger el trabajo ya realizado y continuar con el procesamiento. </p><br><p>  La pregunta surge de inmediato: ¬øqu√© significar√° <em>exactamente una vez</em> si funciona el controlador no determinista?  Despu√©s de todo, cada vez que reiniciamos, recibiremos, en t√©rminos generales, diferentes estados resultantes.  La respuesta aqu√≠ es simple: con <em>exactamente una vez,</em> existe tal ejecuci√≥n del sistema en la que cada valor de entrada se procesa exactamente una vez, dando el resultado de salida correspondiente.  Adem√°s, esta ejecuci√≥n no tiene que estar f√≠sicamente en el mismo nodo.  Pero el resultado deber√≠a ser como si todo se procesara en un solo nodo l√≥gico <em>sin bloqueos</em> . </p><br><h2 id="concurrent-exactly-once">  Concurrente exactamente una vez </h2><br><p>  Para agravar los requisitos, presentamos un nuevo concepto: <em>concurrente exactamente una vez</em> .  La diferencia fundamental de simple <em>exactamente una vez</em> es la ausencia de pausas durante el procesamiento, como si todo se procesara en el mismo nodo <strong>sin ca√≠das</strong> y <strong>sin pausas</strong> .  En nuestra tarea, requeriremos exactamente <em>concurrente exactamente una vez</em> , por simplicidad de presentaci√≥n, para no considerar una comparaci√≥n con los sistemas existentes que no est√°n disponibles hoy en d√≠a. </p><br><p>  Las consecuencias de tener tal requisito se discutir√°n a continuaci√≥n. </p><br><h2 id="tranzakcionnost">  Transaccional </h2><br><p>  Para que el lector est√© a√∫n m√°s profundamente imbuido de la complejidad que ha surgido, veamos varios escenarios negativos que deben tenerse en cuenta al desarrollar un sistema de este tipo.  Tambi√©n intentaremos utilizar un enfoque general que nos permita resolver el problema anterior teniendo en cuenta nuestros requisitos. </p><br><p>  Lo primero que viene a la mente es la necesidad de registrar el estado del controlador y los flujos de entrada y salida.  El estado de los flujos de salida se describe mediante una simple cola de n√∫meros, y el estado de los flujos de entrada por la posici√≥n en ellos.  En esencia, una secuencia es una cola infinita, y una posici√≥n en la cola establece de forma √∫nica una ubicaci√≥n. </p><br><p><img src="https://habrastorage.org/webt/iu/h0/pf/iuh0pfzcezje80kdbsv3idyeu9a.jpeg" alt="Idea"></p><br><p>  La siguiente implementaci√≥n ingenua de un controlador surge utilizando alg√∫n tipo de almac√©n de datos.  En esta etapa, las propiedades espec√≠ficas del repositorio no ser√°n importantes para nosotros.  Usaremos el lenguaje Pseco para ilustrar la idea (Pseco: = pseudoc√≥digo): </p><br><pre><code class="hljs pgsql">handle(input_queues, output_queues, state): #    input_indexes = <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.get_input_indexes() #      <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: #         items, new_input_indexes = input_queues.get_from(input_indexes) #    state.queue.push(items) #     duration state.queue.trim_time_window(duration) avg = state.queue.avg() need_update_counter = state.queue.size() &gt; size_boundary # (A)      output_queues[<span class="hljs-number"><span class="hljs-number">0</span></span>].push(avg) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> need_update_counter: # (B)      db.increment_counter() # (C)     <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.save_state(state) # (D)    <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.save_queue_indexes(new_input_indexes) # (E)    input_indexes = new_input_indexes</code> </pre> <br><p>  Aqu√≠ hay un algoritmo simple de subproceso √∫nico que lee datos de flujos de entrada y escribe los valores deseados de acuerdo con la tarea descrita anteriormente. </p><br><p>  Veamos qu√© sucede en caso de que un nodo caiga en puntos arbitrarios en el tiempo, as√≠ como despu√©s de reanudar el trabajo.  Est√° claro que en caso de una ca√≠da en los puntos <code>(A)</code> y <code>(E)</code> todo estar√° bien: o los datos a√∫n no se han registrado en ning√∫n lugar y simplemente restauramos el estado y continuamos en otro nodo, o todos los datos necesarios ya se han registrado y simplemente contin√∫an con el siguiente paso. </p><br><p>  Sin embargo, en caso de una ca√≠da en todos los dem√°s puntos, nos esperan problemas inesperados.  Si se produce una ca√≠da en el punto <code>(B)</code> , cuando se reinicie el controlador, restauraremos el estado y volveremos a registrar el valor promedio en aproximadamente el mismo rango de n√∫meros.  En el caso de una ca√≠da en el punto <code>(C)</code> adem√°s del duplicado promedio, se producir√° un duplicado en el incremento del valor.  Y en caso de una ca√≠da en <code>(D)</code> obtendremos un estado inconsistente del controlador: el estado corresponde a un nuevo momento en el tiempo, y leeremos los valores de los flujos de entrada antiguos. </p><br><p><img src="https://habrastorage.org/webt/fn/8z/6f/fn8z6f9t3y-fe2hzlepgnie7qps.jpeg" alt="Sorpresas"></p><br><p>  Al mismo tiempo, nada cambiar√° fundamentalmente al reorganizar las operaciones de grabaci√≥n: la inconsistencia y los duplicados seguir√°n si√©ndolo.  Por lo tanto, llegamos a la conclusi√≥n de que todas las acciones para cambiar el estado del controlador en el repositorio, la cola de salida y la base de datos deben realizarse transaccionalmente, es decir.  todo es at√≥mico al mismo tiempo. </p><br><p>  Por consiguiente, es necesario desarrollar un mecanismo para que diferentes almacenamientos puedan cambiar transaccionalmente su estado, y no dentro de cada uno de forma independiente, sino transaccionalmente entre todos los almacenamientos simult√°neamente.  Por supuesto, puede colocar nuestro almacenamiento dentro de una base de datos externa, sin embargo, la tarea asumi√≥ que el motor de la base de datos y el motor para el marco de procesamiento de datos de transmisi√≥n est√°n separados y funcionan de forma independiente el uno del otro.  Aqu√≠ quiero considerar el caso m√°s dif√≠cil, porque  No es interesante considerar casos simples. </p><br><h2 id="konkurentnaya-otzyvchivost">  Capacidad de respuesta competitiva </h2><br><p>  Considere la ejecuci√≥n competitiva exactamente una vez con m√°s detalle.  En el caso de un sistema tolerante a fallas, requerimos la continuaci√≥n del trabajo desde alg√∫n punto.  Est√° claro que este punto ser√° un punto en el pasado, porque  Para mantener el rendimiento, es imposible almacenar todos los momentos de cambios de estado en el presente y en el futuro: se guarda el √∫ltimo resultado de las operaciones o un grupo de valores para aumentar el rendimiento.  Este comportamiento nos lleva inmediatamente al hecho de que despu√©s de la restauraci√≥n del estado del procesador, habr√° alg√∫n retraso en los resultados, aumentar√° con el aumento del tama√±o del grupo de valores y el tama√±o del estado. </p><br><p>  Adem√°s de este retraso, tambi√©n hay retrasos en el sistema asociados con la carga del estado en otro nodo.  Adem√°s de esto, la detecci√≥n de un nodo problem√°tico tambi√©n lleva alg√∫n tiempo, y a menudo mucho.  Esto se debe, en primer lugar, al hecho de que si establecemos un tiempo de detecci√≥n corto, entonces son posibles los falsos positivos frecuentes, lo que conducir√° a todo tipo de efectos especiales desagradables. </p><br><p>  Adem√°s, con el aumento en el n√∫mero de procesadores paralelos, de repente resulta que no todos funcionan igual de bien incluso en ausencia de fallas.  A veces se producen embotamientos, que tambi√©n conducen a retrasos en el procesamiento.  La raz√≥n de tales embotamientos puede variar: </p><br><ol><li>  <em>Software</em> : pausas del GC, fragmentaci√≥n de la memoria, pausas del asignador, interrupci√≥n del kernel y programaci√≥n de tareas, problemas con los controladores de dispositivos que causan ralentizaciones. </li><li>  <em>Hardware</em> : disco alto o carga de red, aceleraci√≥n de la CPU debido a problemas de enfriamiento, sobrecarga, etc., desaceleraci√≥n del disco debido a problemas t√©cnicos. </li></ol><br><p>  Y esta no es una lista exhaustiva de problemas que pueden ralentizar a los manejadores. </p><br><p>  En consecuencia, la desaceleraci√≥n es un hecho con el que uno tiene que vivir.  A veces esto no es un problema grave, y a veces es extremadamente importante mantener una alta velocidad de procesamiento a pesar de fallas o ralentizaciones. </p><br><p>  Inmediatamente surge la idea de la duplicaci√≥n de sistemas: corramos por el mismo flujo de datos, no uno sino dos procesadores a la vez, o incluso tres.  El problema aqu√≠ es que, en este caso, pueden producirse f√°cilmente comportamientos duplicados e inconsistentes del sistema.  Normalmente, los marcos no est√°n dise√±ados para este comportamiento y sugieren que el n√∫mero de controladores en un momento dado no excede uno.  Los sistemas que permiten la duplicaci√≥n de ejecuci√≥n descrita se llaman <em>concurrentes exactamente una vez</em> . </p><br><p>  Esta arquitectura le permite resolver varios problemas a la vez: </p><br><ol><li>  Comportamiento a prueba de fallos: si uno de los nodos cae, el otro simplemente contin√∫a funcionando como si nada hubiera pasado.  No hay necesidad de coordinaci√≥n adicional, ya que  el segundo manejador se ejecuta independientemente del estado del primero. </li><li>  Eliminando las contundentes: el primero que proporcion√≥ el resultado es bueno para √©l.  El otro solo tendr√° que recoger un nuevo estado y continuar desde este momento. </li></ol><br><p>  Este enfoque, en particular, le permite completar un c√°lculo largo y dif√≠cil por un tiempo m√°s predecible, porque  la probabilidad de que ambos sean est√∫pidos y caigan significativamente menos. </p><br><h3 id="veroyatnostnaya-ocenka">  Evaluaci√≥n de probabilidad </h3><br><p>  Intentemos evaluar los beneficios de la duplicaci√≥n del rendimiento.  Supongamos que algo sucede en promedio todos los d√≠as con el controlador: o el GC se ha embotado, o el nodo est√° mintiendo, o los contenedores se han vuelto cancerosos.  Supongamos tambi√©n que preparamos paquetes de datos en 10 segundos. </p><br><p>  Entonces la probabilidad de que algo suceda durante la creaci√≥n del paquete es <code>10 / (24 ¬∑ 3600) ‚âÉ 1e-4</code> . </p><br><p>  Si ejecuta dos controladores en paralelo, entonces la probabilidad de que ambos <code>‚âÉ 1e-8</code> es <code>‚âÉ 1e-8</code> .  ¬°Entonces este evento llegar√° en 23 a√±os!  S√≠, los sistemas no viven tanto, lo que significa que esto nunca suceder√°. </p><br><p>  Adem√°s, si el tiempo de preparaci√≥n del paquete ser√° a√∫n m√°s corto y / o se producir√°n embotamientos incluso con menos frecuencia, esta cifra solo aumentar√°. </p><br><p>  Por lo tanto, concluimos que el enfoque considerado aumenta significativamente la confiabilidad de todo nuestro sistema.  Solo queda resolver una peque√±a pregunta como esta: d√≥nde leer sobre c√≥mo hacer un sistema <em>concurrente de una sola vez</em> .  Y la respuesta es simple: tienes que leer aqu√≠. </p><br><h2 id="polutranzakcii">  Media transacci√≥n </h2><br><p>  Para mayor discusi√≥n, necesitamos el concepto de <em>media transacci√≥n</em> .  La forma m√°s f√°cil de explicarlo es con un ejemplo. </p><br><p>  Considere transferir fondos de una cuenta bancaria a otra.  El enfoque tradicional que utiliza transacciones en el lenguaje Pseco se puede describir de la siguiente manera: </p><br><pre> <code class="hljs pgsql">transfer(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): tx = db.begin_transaction() amount_from = tx.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> amount_from &lt; amount: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> error.insufficient_funds tx.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, amount_from - amount) tx.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, tx.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) + amount) tx.<span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok</code> </pre> <br><p>  Sin embargo, ¬øqu√© pasa si estas transacciones no est√°n disponibles para nosotros?  Usando bloqueos, esto se puede hacer de la siguiente manera: </p><br><pre> <code class="hljs pgsql">transfer(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): #         lock_from = db.<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>) lock_to = db.<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) amount_from = db.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> amount_from &lt; amount: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> error.insufficient_funds db.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, amount_from - amount) db.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, db.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) + amount) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok</code> </pre> <br><p>  Este enfoque puede conducir a puntos muertos, ya que  Los bloqueos se pueden tomar en diferentes secuencias en paralelo.  Para corregir este comportamiento, es suficiente introducir una funci√≥n que tome simult√°neamente varios bloqueos en una secuencia determinista (por ejemplo, ordenada por teclas), lo que elimina por completo los posibles puntos muertos. </p><br><p>  Sin embargo, la implementaci√≥n puede simplificarse un tanto: </p><br><pre> <code class="hljs vbscript">transfer(from, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): lock_from = db.lock(from) amount_from = db.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(from) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> amount_from &lt; amount: return <span class="hljs-keyword"><span class="hljs-keyword">error</span></span>.insufficient_funds db.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(from, amount_from - amount) lock_from.release() #   , # .. db.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(db.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>...)     lock_to = db.lock(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) db.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, db.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) + amount) return ok</code> </pre> <br><p>  Este enfoque tambi√©n hace que el estado final sea consistente, preservando a los invariantes por el tipo de prevenci√≥n de gastos excesivos de fondos.  La principal diferencia con el enfoque anterior es que en tal implementaci√≥n tenemos un cierto per√≠odo de tiempo en el que las cuentas est√°n en un estado inconsistente.  Es decir, tal operaci√≥n implica que el estado total de los fondos en las cuentas no cambia.  En este caso, hay un intervalo de tiempo entre <code>lock_from.release()</code> y <code>db.lock(to)</code> , durante el cual la base de datos puede devolver un valor inconsistente: la cantidad total puede diferir del correcto hacia abajo. </p><br><p>  De hecho, dividimos una transacci√≥n para transferir dinero en dos medias transacciones: </p><br><ol><li>  La primera mitad de la transacci√≥n hace un cheque y deduce la cantidad necesaria de la cuenta. </li><li>  La segunda mitad de la transacci√≥n escribe el monto retirado en otra cuenta. </li></ol><br><p>  Est√° claro que dividir una transacci√≥n en otras m√°s peque√±as, en general, viola el comportamiento transaccional.  Y el ejemplo anterior no es una excepci√≥n.  Sin embargo, si todas las medias transacciones en la cadena se cumplen por completo, entonces el resultado ser√° consistente con todos los invariantes preservados.  Esto es precisamente lo que es una propiedad importante de una cadena de media transacci√≥n. </p><br><p>  Sin embargo, al perder temporalmente cierta coherencia, adquirimos otra caracter√≠stica √∫til: la independencia de las operaciones y, como resultado, una mejor escalabilidad.  La independencia se manifiesta en el hecho de que una media transacci√≥n cada vez funciona con una sola l√≠nea, leyendo, verificando y cambiando sus datos, sin comunicarse con otros datos.  Por lo tanto, puede barajar una base de datos cuyas transacciones funcionan con un solo fragmento.  Adem√°s, este enfoque se puede utilizar en el caso de repositorios heterog√©neos, es decir  las medias transacciones pueden comenzar en un tipo de almacenamiento y terminar en otro.  Son propiedades √∫tiles que se utilizar√°n en el futuro. </p><br><p>  Surge una pregunta leg√≠tima: ¬øc√≥mo implementar half-trance en sistemas distribuidos y no rake?  Para resolver este problema, debe considerar el enfoque sin bloqueo. </p><br><h2 id="lock-free">  Sin bloqueo </h2><br><p>  Como sabe, los enfoques sin bloqueo a veces mejoran el rendimiento de los sistemas de subprocesos m√∫ltiples, especialmente en el caso del acceso competitivo al recurso.  Sin embargo, es completamente obvio que este enfoque puede usarse en sistemas distribuidos.  Profundicemos y consideremos qu√© es sin bloqueo y por qu√© esta propiedad ser√° √∫til para resolver nuestro problema. </p><br><p>  Algunos desarrolladores a veces no entienden qu√© es sin bloqueo.  La mirada de mente estrecha sugiere que esto es algo relacionado con las instrucciones del procesador at√≥mico.  Es importante entender aqu√≠ que sin bloqueo significa el uso de "√°tomos", lo contrario no es cierto, es decir,  no todas las "at√≥micas" dan un comportamiento sin bloqueo. </p><br><p>  Una propiedad importante del algoritmo sin bloqueo es que al menos un subproceso avanza en el sistema.  Pero por alguna raz√≥n, muchos atribuyen esta propiedad como una definici√≥n (es una definici√≥n tan contundente que se puede encontrar, por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en Wikipedia</a> ).  Aqu√≠ es necesario agregar un matiz importante: el progreso se logra incluso en el caso de romos de uno o m√°s hilos.  Este es un punto muy cr√≠tico que a menudo se pasa por alto y tiene serias implicaciones para un sistema distribuido. </p><br><p>  ¬øPor qu√© la ausencia de una condici√≥n de progreso de al menos un hilo niega el concepto de un algoritmo sin bloqueo?  El hecho es que, en este caso, el spinlock habitual tambi√©n estar√° libre de bloqueos.  De hecho, el que tom√≥ la cerradura har√° progresos.  ¬øHay un hilo con progreso =&gt; ‚Äã‚Äãsin bloqueo? </p><br><p>  Obviamente, sin bloqueo significa sin bloqueos, mientras que el spinlock por su nombre indica que se trata de un bloqueo real.  Por eso es importante agregar una condici√≥n al progreso, incluso en el caso de embotamientos.  Despu√©s de todo, estos retrasos pueden durar indefinidamente, porque  la definici√≥n no dice nada sobre la l√≠nea de tiempo superior.  Y si es as√≠, dichos retrasos ser√°n equivalentes en cierto sentido a la desconexi√≥n de los flujos.  En este caso, los algoritmos sin bloqueo producir√°n progreso en este caso. </p><br><p>  Pero, ¬øqui√©n dijo que los enfoques sin bloqueo se aplican exclusivamente a sistemas de subprocesos m√∫ltiples?  Al reemplazar los subprocesos en el mismo proceso en el mismo nodo con procesos en diferentes nodos, y la memoria compartida de los subprocesos con almacenamiento distribuido compartido, obtenemos un algoritmo distribuido sin bloqueo. </p><br><p>  Una ca√≠da de nodo en dicho sistema es equivalente a un retraso en la ejecuci√≥n de un hilo durante alg√∫n tiempo, porque  Es hora de restaurar el trabajo.  Al mismo tiempo, el enfoque sin bloqueo permite que otros participantes en el sistema distribuido contin√∫en trabajando.  Adem√°s, se pueden ejecutar algoritmos especiales sin bloqueo en paralelo entre s√≠, detectando un cambio competitivo y eliminando duplicados. </p><br><p>  <em>El</em> enfoque <em>Exactamente una vez</em> implica la presencia de un almacenamiento distribuido consistente.  Tales almacenamientos, como regla, representan una enorme tabla persistente de clave-valor.  Posibles operaciones: <code>set</code> , <code>get</code> , <code>del</code> .  Sin embargo, se requiere una operaci√≥n m√°s complicada para el enfoque sin bloqueo: CAS o compare-and-swap.  Consideremos con m√°s detalle esta operaci√≥n, las posibilidades de su uso, as√≠ como los resultados que ofrece. </p><br><h3 id="cas">  Cas </h3><br><p>  CAS o compare-and-swap es la primitiva de sincronizaci√≥n principal e importante para algoritmos sin bloqueo y sin espera.  Su esencia puede ilustrarse con el siguiente Pseco: </p><br><pre> <code class="hljs kotlin">CAS(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, expected, new): # ,   atomic,   atomic: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() != expected: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(new) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><p>  A veces, para la optimizaci√≥n, devuelven no <code>true</code> o <code>false</code> , sino el valor anterior, porque  muy a menudo, tales operaciones se realizan en un bucle, y para obtener el valor <code>expected</code> , primero debe leerlo: </p><br><pre> <code class="hljs vala">CAS_optimized(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, expected, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>): # ,   atomic,   atomic: current = <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> current == expected: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current #  CAS   CAS_optimized CAS(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, expected, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.CAS_optimized(expected, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>) == expected</code> </pre> <br><p>  Este enfoque puede ahorrar una lectura.  Como parte de nuestra revisi√≥n, utilizaremos una forma simple de <code>CAS</code> , porque  si se desea, dicha optimizaci√≥n se puede hacer de forma independiente. </p><br><p>  En el caso de los sistemas distribuidos, cada cambio se versiona.  Es decir  Primero leemos el valor de la tienda, obteniendo la versi√≥n actual de los datos.  Y luego tratamos de escribir, esperando que la versi√≥n de los datos no haya cambiado.  En este caso, la versi√≥n se incrementa cada vez que se actualizan los datos: </p><br><pre> <code class="hljs cs">CAS_versioned(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, expected_version, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>): atomic: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.get_version() != expected_version: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>, expected_version + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><p>  Este enfoque le permite controlar con mayor precisi√≥n la actualizaci√≥n de valores, evitando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el problema ABA</a> .  En particular, las versiones son compatibles con Etcd y Zookeeper. </p><br><p>  Tenga en cuenta la importante propiedad que otorga el uso de operaciones <code>CAS_versioned</code> .  El hecho es que tal operaci√≥n puede repetirse sin perjuicio de la l√≥gica superior.  En la programaci√≥n multiproceso, esta propiedad no tiene un valor especial, porque  all√≠, si la operaci√≥n fall√≥, entonces sabemos con certeza que no se aplic√≥.  En el caso de los sistemas distribuidos, esta invariante se viola, porque  la solicitud puede llegar al destinatario, pero la respuesta exitosa ya no est√° all√≠.  Por lo tanto, es importante poder reenviar solicitudes sin temor a romper invariantes de la l√≥gica de alto nivel. </p><br><p>  Es esta propiedad la que <code>CAS_versioned</code> operaci√≥n <code>CAS_versioned</code> .  De hecho, esta operaci√≥n se puede repetir sin cesar hasta que se devuelva la respuesta real del destinatario.  Lo que, a su vez, arroja toda una clase de errores relacionados con la interacci√≥n de la red. </p><br><h3 id="primer">  Ejemplo </h3><br><p>  Veamos c√≥mo, en base a <code>CAS_versioned</code> y medias transacciones, transferir de una cuenta a otra, que pertenecen, por ejemplo, a diferentes copias de Etcd.  Aqu√≠, supongo que la funci√≥n <code>CAS_versioned</code> ya <code>CAS_versioned</code> implementada de acuerdo con la API proporcionada. </p><br><pre> <code class="hljs pgsql">withdraw(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, amount): # CAS- <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: #     version_from, amount_from = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>.get_versioned() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> amount_from &lt; amount: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> error.insufficient_funds <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>.CAS_versioned(version_from, amount_from - amount): break <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok deposit(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): # CAS- <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: version_to, amount_to = <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>.get_versioned() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>.CAS_versioned(version_to, amount_to + amount): break <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok transfer(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): #   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> withdraw(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, amount) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> ok: #     , #    deposit(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount)</code> </pre> <br><p>  Aqu√≠ dividimos nuestra operaci√≥n en medias transacciones, y realizamos cada media transacci√≥n a trav√©s de la operaci√≥n <code>CAS_versioned</code> .  Este enfoque le permite trabajar de forma independiente con cada cuenta, lo que permite el uso de almacenamiento heterog√©neo que no est√° conectado entre s√≠.  El √∫nico problema que nos espera aqu√≠ es la p√©rdida de dinero en caso de una ca√≠da en el proceso actual en el intervalo entre las medias transacciones. </p><br><h2 id="ochered">  Cola </h2><br><p>  Para continuar, debe implementar una cola de eventos.  La idea es que para que los manejadores se comuniquen entre s√≠, debe tener una cola de mensajes ordenada en la que los datos no se pierdan ni se dupliquen.  En consecuencia, toda interacci√≥n en la cadena de controladores se construir√° sobre esta primitiva.  Tambi√©n es una herramienta √∫til para analizar y auditar flujos de datos entrantes y salientes.  Adem√°s de esto, las mutaciones del estado de los manejadores tambi√©n se pueden hacer a trav√©s de la cola. </p><br><p>  La cola consistir√° en un par de operaciones: </p><br><ol><li>  Agregue un mensaje al final de la cola. </li><li>  Recibir un mensaje de la cola en el √≠ndice especificado. </li></ol><br><p>  En este contexto, no considero eliminar mensajes de la cola por varias razones: </p><br><ol><li>  Varios procesadores pueden leer desde la misma cola.  Eliminar la sincronizaci√≥n ser√° una tarea no trivial, aunque no imposible. </li><li>  Es √∫til mantener una cola durante un intervalo relativamente largo (d√≠a o semana) para la depuraci√≥n y la auditor√≠a.  La utilidad de esta propiedad es dif√≠cil de sobreestimar. </li><li>  Puede eliminar elementos antiguos seg√∫n lo programado o configurando TTL en los elementos de la cola.  Es importante asegurarse de que los procesadores logren procesar los datos antes de que llegue la escoba y limpien todo.  Si el tiempo de procesamiento es del orden de segundos y el TTL del orden de d√≠as, entonces nada de esto deber√≠a suceder. </li></ol><br><p>  Para almacenar los elementos e implementar efectivamente la adici√≥n, necesitamos: </p><br><ol><li>  El valor con el √≠ndice actual.  Este √≠ndice apunta al final de la cola para agregar elementos. </li><li>  ,    . </li></ol><br><h3 id="kak-by-lock-free-ochered">   lock-free  </h3><br><p>          :        .        : </p><br><ol><li>    CAS     . </li><li>       . </li></ol><br><p>    ,    ,     . </p><br><ol><li> <strong>    lock-free</strong> .  ,      ,          . Lock-free? !   ,    2 :   .         lock-free,     ‚Äî !    ,  ,        ,   .              .         , ..            ,     . </li><li> <strong>    </strong> .         ,               .    . </li></ol><br><p>  ,    lock-free         . </p><br><h3 id="lock-free-realizaciya-dobavleniya"> Lock-free   </h3><br><p> ,  ,     :   , ..      ,    : </p><br><pre> <code class="hljs pgsql">push(queue, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>): #      <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = queue.get_current_index() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: #  ,    #    var = queue.at(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) #  = <span class="hljs-number"><span class="hljs-number">0</span></span>   , ..   # ,         <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> var.CAS_versioned(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>): #   ,    queue.update_index(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) break #   , .   <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = max(queue.get_current_index(), <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) update_index(queue, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: #     cur_index, version = queue.get_current_index_versioned() #      , #  , .   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cur_index &gt;= <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>: # -     , #        break <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> queue.current_index_var().CAS_versioned(<span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>): #      ,   break # -  . # ,      ,  </code> </pre> <br><p>      .   ,            (     ‚Äî ,  ,     ).       lock-free   .    ? </p><br><p>   ,   <code>push</code>     ,      ! ,             ,      . </p><br><p>        .       :         .   ,      -   ,  -               .  ,      , ..      .          .        ?       , ..     ,    ,        . </p><br><p>  ,       ,          .  Es decir    .        ,    ,     .          ,       . </p><br><p>  ,       .               ,   .    ,   ,     .       ,    . </p><br><h2 id="vzaimodeystvie-ocheredey">   </h2><br><p>  ,  ,   ,      . </p><br><p> <em></em> .       . </p><br><p>    ,      : </p><br><ol><li>  , ..  stateless. </li><li>  ,     ‚Äî . </li></ol><br><p> ,    ,        <em>concurrent exactly-once</em> . </p><br><p>        : </p><br><pre> <code class="hljs pgsql">handle(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>, output): <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) output.push(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> += <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><p>   .        : </p><br><pre> <code class="hljs pgsql">handle(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>, output, state): #   <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = state.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) output.push(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> += <span class="hljs-number"><span class="hljs-number">1</span></span> #   state.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>)</code> </pre> <br><p>     <em>exactly-once</em> .   ,           ,    ,    . </p><br><p>    <em>exactly-once</em> ,     ,    . ..,  ,       ,       ,   ,    ‚Äî      : </p><br><pre> <code class="hljs pgsql">#       get_next_index(queue): <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = queue.get_index() #     <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> queue.has(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>): #    queue.push <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = max(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>, queue.get_index()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> #      . #  <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>    push_at(queue, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>): var = queue.at(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> var.CAS_versioned(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>): #   queue.update_index(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> handle(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>, output, state): #   #    {PREPARING, <span class="hljs-number"><span class="hljs-number">0</span></span>} fsm_state = state.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: switch fsm_state: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {PREPARING, input_index}: #   :   , #        output_index = output.get_next_index() fsm_state = {WRITING, input_index, output_index} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {WRITING, input_index, output_index}: <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(input_index) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> output.push_at(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, output_index): #  ,     input_index += <span class="hljs-number"><span class="hljs-number">1</span></span> #    ,  push_at  <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, #        fsm_state = {PREPARING, input_index} state.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(fsm_state)</code> </pre> <br><p>        <code>push_at</code> ?      ,   .   ,    ,  ,    .   ,               .             .          -  ,     lock-free . </p><br><p>  ,      : </p><br><ol><li>   :       . </li><li> ,  :      . </li></ol><br><p>   :   <em>concurrent</em>  <em>exactly-once</em> . </p><br><p>      ?   : </p><br><ol><li>       ,         ,   <code>push_at</code>     false.            . </li><li>       ,      . ,   ,       . </li></ol><br><p>     <em>concurrent exactly-once</em>   ?   ,     ,            .    ,           .            . </p><br><p>          : </p><br><pre> <code class="hljs pgsql">#     ,  ,     # ..       <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, #      <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>. #       <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> push_at_idempotent(queue, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> queue.push_at(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> queue.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) == <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> handle(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>, output, state): <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state = state.get_versioned() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: switch fsm_state: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {PREPARING, input_index}: #   ,   , #        output_index = output.get_next_index() fsm_state = {WRITING, input_index, output_index} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {WRITING, input_index, output_index}: <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(input_index) #   , #       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> output.push_at_idempotent(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, output_index): input_index += <span class="hljs-number"><span class="hljs-number">1</span></span> fsm_state = {PREPARING, input_index} #     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> state.CAS_versioned(<span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state): <span class="hljs-keyword"><span class="hljs-keyword">version</span></span> += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: #   ,    <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state = state.get_versioned()</code> </pre> <br><p>  : </p><br><p><img src="https://habrastorage.org/webt/rx/qi/ub/rxqiubplbrrdlokp_sniqhktmvu.png" alt="Simple"></p><br><p>     ,     .     ,           . </p><br><p>             kernel panic,   ,    ..              .              .       :      ,    .  ,        . </p><br><p>  ,    <strong> </strong>    ,    . </p><br><h2 id="reshenie-nachalnoy-zadachi">    </h2><br><p>        :    . </p><br><p>       :  ,     ,    ,      ,      : </p><br><pre> <code class="hljs pgsql">#  : # - input_queues -   # - output_queues -   # - state -    # - <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span> -    : state, inputs -&gt; state, outputs handle(input_queues, output_queues, state, <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>): #        <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state = state.get_versioned() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: switch fsm_state: # input_indexes       <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {HANDLING, user_state, input_indexes}: #       inputs = [queue.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> queue, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> zip(input_queues, input_indexes)] #   ,    next_indexes = next(inputs, input_indexes) #    #     user_state, outputs = <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>(user_state, inputs) #      , #     fsm_state = {PREPARING, user_state, next_indexes, outputs, <span class="hljs-number"><span class="hljs-number">0</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {PREPARING, user_state, input_indexes, outputs, output_pos}: #  ,      #    output_index = output_queues[output_pos].get_next_index() #     fsm_state = { WRITING, user_state, input_indexes, outputs, output_pos, output_index } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> { WRITING, user_state, input_indexes, outputs, output_pos, output_index }: <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = outputs[output_pos] #       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> output_queues[output_pos].push_at_idempotent( <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, output_index ): #  ,      output_pos += <span class="hljs-number"><span class="hljs-number">1</span></span> #    ,      PREPARING. #     #     fsm_state = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> output_pos == len(outputs): #   , #       {HANDLING, user_state, input_indexes} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: #       #   , #         {PREPARING, user_state, input_indexes, outputs, output_pos} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> state.CAS_versioned(<span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state): <span class="hljs-keyword"><span class="hljs-keyword">version</span></span> += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: #   ,    <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state = state.get_versioned()</code> </pre> <br><p>     : </p><br><p><img src="https://habrastorage.org/webt/fe/mk/bg/femkbgvjaxyy2gi9ye5wkaufqf4.png" alt="final"></p><br><p>      : <code>HANDLING</code> .        , ..,  ,     .  ,      .    ,   <code>PREPARING</code>  <code>WRITING</code>   ,         .     ,      <code>HANDLING</code> . </p><br><p>  ,      ,       ,          .   ,           .  ,            . </p><br><p>      .         .               . </p><br><p><img src="https://habrastorage.org/webt/or/qk/tg/orqktgqgrdw-9tv0_wkl2wt_rye.png" alt="final"></p><br><p>   : </p><br><pre> <code class="hljs cpp">my_handler(state, inputs): #      state.<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.push(inputs) #    duration state.<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.trim_time_window(duration) #   avg = state.<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.avg() need_update_counter = state.<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.size() &gt; size_boundary <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state, [ avg, <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> need_update_counter: <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: # none      none ]</code> </pre> <br><p>  ,      ,           <em>concurrent exactly-once</em>     <code>handle</code> . </p><br><p>        : </p><br><pre> <code class="hljs pgsql">handle_db(input_queue, db): <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: #      tx = db.begin_transaction() #     . #      , #      <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = tx.get_current_index() #    tx.write_current_index(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) #      <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = intput_queue.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: #    tx.increment_counter() tx.<span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>() #   ,      , #          </code> </pre> <br><p>    . ..       ,         , , ,    <em>concurrent exactly-once</em> .       . </p><br><h2 id="za-bortom">   </h2><br><p>   ‚Äî            .        ,      ,     . </p><br><h3 id="optimizacii-dlya-konkretnogo-hranilischa">     </h3><br><p>      ,      ,       .           ,  ,          . </p><br><h3 id="asinhronnaya-publikaciya">   </h3><br><p>           .    ,     . ..        ,      .              .        . </p><br><h3 id="gruppirovka-znacheniy">   </h3><br><p>        ‚Äî   . ,       ,     .    ,     -  ,   ,    .        , .. ,    ,        . </p><br><h3 id="dvoynoe-shardirovanie">   </h3><br><p>       .   ,     ,           .            ,    ,    . </p><br><h2 id="fundamentalnost-podhoda">   </h2><br><p>     . ,         .  :          ,      .     ,       . </p><br><p>      ,   ,      : </p><br><ol><li>    ,   .          . </li><li>     .      ,        . </li><li>          .    ,       .      ,   ,        .  Es decir          .     :    . </li></ol><br><p>     , , -,     ,  -,     . </p><br><p>     ,     .     : </p><br><pre> <code class="hljs pgsql">transfer(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): #   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> withdraw(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, amount) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> ok: #     , #    deposit(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount)</code> </pre> <br><p>  <code>withdraw</code>     ,   ,  <code>deposit</code>    :      ?    <code>deposit</code>  -     (,   ,       ),    .  ,    ,    ,   ,        ?    ,   ,      - ,     . </p><br><p>     ,   ,   ,     . ,     ,   ,   .   ,     .   ,       ,       . ..     ,       ,        .      ,        :     ,     ‚Äî  . </p><br><h3 id="dvuhfaznost-bez-blokirovok">    </h3><br><p>      ,       . </p><br><p>      :        ,  ,     ,   ,   .   ,        -  : </p><br><ul><li> <em></em> .            ,   , ,     ,     . </li><li> <em></em> .        . </li></ul><br><p>     , , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> . </p><br><p> ,        , ..       ,      ,  .        ,       . </p><br><p>          :     lock-free   ,           .            , ..      ,  . </p><br><p>      CAS       . ,      : </p><br><pre> <code class="hljs swift">#     ,    handle(input, output, state): # ... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> fsm_state: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {<span class="hljs-type"><span class="hljs-type">HANDLING</span></span>, ...}: #      fsm_state = {<span class="hljs-type"><span class="hljs-type">PREPARING</span></span>, ...} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {<span class="hljs-type"><span class="hljs-type">PREPARING</span></span>, input_index}: #   ... output_index = ...get_next_index() fsm_state = {<span class="hljs-type"><span class="hljs-type">WRITING</span></span>, output_index, ...} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {<span class="hljs-type"><span class="hljs-type">WRITING</span></span>, output_index, ...}: #  ,  output_index</code> </pre> <br><p>  ,     .          .      : </p><br><ol><li> <strong>PREPARING</strong> .     ,        . </li><li> <strong>WRITING</strong> .     .       ,       <strong>PREPARING</strong> . </li></ol><br><p>     ,      . ,          ,     ‚Äî    .     : </p><br><ol><li>         .  ,    , ..     ,      . </li><li>            , ..       .         ,     . </li></ol><br><p>  ,  lock-free        ,        ,     . </p><br><h2 id="trebovaniya-k-konsistentnosti">    </h2><br><p>  ,     .     ,      <em>Stale Read</em> ,       .   ‚Äî       CAS:              .       : </p><br><ul><li> <em>Distributed single register</em> ‚Äî       (, etcd  Zookeeper): <br><ol><li> Linearizability </li><li> Sequential consistency </li></ol></li><li> <em>Transactional</em> ‚Äî     (, MySQL, PostgreSQL  ..): <br><ol><li> Serializability </li><li> Snapshot Isolation </li><li> Repeatable Read </li><li> Read Committed </li></ol></li><li> <em>Distributed Transactional</em> ‚Äî NewSQL : <br><ol><li> Strict Consistency </li><li>    </li></ol></li></ul><br><p>   :             ?   ,  ,   .         ,    ,     CAS                .        , ,   <em>Read My Writes</em> . </p><br><h2 id="zaklyuchenie">  Conclusi√≥n </h2><br><p>        <em>exactly-once</em> .     , ..  ,  ,    ,    .       ,      ,  , , ..        ,     . </p><br><p>       lock-free       . </p><br><p>    : </p><br><ol><li> <strong></strong> :      . </li><li> <strong></strong> :       . </li><li> <strong></strong> :        : <em>exactly-once</em> . </li><li> <strong>Concurrent</strong> :       . </li><li> <strong>Real-time</strong> :     . </li><li> <strong>Lock-free</strong> :      ,     . </li><li> <strong>Deadlock free</strong> :      ,      . </li><li> <strong>Race condition free</strong> :     . </li><li> <strong>Hot-hot</strong> :        . </li><li> <strong>Hard stop</strong> :       . </li><li> <strong>No failover</strong> :                  . </li><li> <strong>No downtime</strong> :    . </li><li> <strong> </strong> :   ,    . </li><li> <strong></strong> :         . </li><li> <strong></strong> :         . </li><li> <strong></strong> :        . </li></ol><br><p>  ,        .  Pero esa es otra historia. </p><br><p><img src="https://habrastorage.org/webt/ku/4j/nf/ku4jnf9-1pkdjfh_peshj0xd73w.jpeg" alt="Luz"></p><br><h2 id="novye-terminy">   </h2><br><p>       : </p><br><ol><li> Concurrent exactly-once. </li><li> Semi-transactions  . </li><li> Lock-free two-phase commit,       . </li></ol><br><h2 id="zadachi-dlya-samoistyazaniya">    </h2><br><ol><li>     . </li><li>  lock-free       . </li><li>    . </li></ol><br><h2 id="literatura">  Literatura </h2><br><p> [1] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">:  ABA.</a> <br> [2] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Blog: You Cannot Have Exactly-Once Delivery</a> <br> [3] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">:         .</a> <br> [4] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">:  3:  .</a> <br> [5] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">:  .</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es413817/">https://habr.com/ru/post/es413817/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es413807/index.html">Determinaci√≥n de las caracter√≠sticas bal√≠stico-temporales del movimiento del centro de masa de un paracaidista que aterriza desde un avi√≥n.</a></li>
<li><a href="../es413809/index.html">Set-Top-Box y experimentos con Android en el contenedor LXC</a></li>
<li><a href="../es413811/index.html">El resumen de materiales frescos del mundo del front-end para la √∫ltima semana No. 318 (4 al 10 de junio de 2018)</a></li>
<li><a href="../es413813/index.html">PHP Digest No. 132 (27 de mayo - 10 de junio de 2018)</a></li>
<li><a href="../es413815/index.html">Ir taller de contribuci√≥n en Rusia</a></li>
<li><a href="../es413819/index.html">Sinceramente sobre el mercado de TI en Rusia</a></li>
<li><a href="../es413823/index.html">El boom del empleo sin sentido</a></li>
<li><a href="../es413827/index.html">Proyecto Kubernetes cumple 4 a√±os</a></li>
<li><a href="../es413831/index.html">La nueva versi√≥n del piloto autom√°tico Tesla se lanzar√° en agosto, por primera vez con "caracter√≠sticas de conducci√≥n totalmente aut√≥nomas".</a></li>
<li><a href="../es413837/index.html">Hacer de Tower Defense un juego de unidad - Parte 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>