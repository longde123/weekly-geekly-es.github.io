<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📗 🌅 👸🏼 Procesamiento de datos competitivos heterogéneos en tiempo real estrictamente una vez 🤟🏼 🤜🏽 🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Anotación 


 El procesamiento de datos en tiempo real exactamente una vez ( exactamente una vez ) es una tarea extremadamente trivial y requiere un e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Procesamiento de datos competitivos heterogéneos en tiempo real estrictamente una vez</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413817/"><p><img src="https://habrastorage.org/webt/uf/mh/m-/ufmhm-q0wjfbdgbv4jn4ece8duw.jpeg" alt="Salchicha competitiva"></p><br><h2 id="annotaciya">  Anotación </h2><br><p>  El procesamiento de datos en tiempo real exactamente una vez ( <em>exactamente una vez</em> ) es una tarea extremadamente trivial y requiere un enfoque serio y reflexivo en toda la cadena de cálculos.  Algunos incluso creen que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tal tarea es imposible</a> .  En realidad, quiero tener un enfoque que proporcione un procesamiento tolerante a fallas sin demora y el uso de varios almacenamientos de datos, que presente nuevos requisitos aún más estrictos para el sistema: <em>concurrente exactamente una vez</em> y heterogeneidad de la capa persistente.  Hasta la fecha, dicho requisito no es compatible con ninguno de los sistemas existentes. </p><br><p>  El enfoque propuesto revelará consistentemente los ingredientes secretos y los conceptos necesarios que hacen que sea relativamente fácil implementar <em>un</em> procesamiento heterogéneo <em>concurrente exactamente una vez</em> literalmente a partir de dos componentes. </p><br><h2 id="vvedenie">  Introduccion </h2><br><p>  El desarrollador de sistemas distribuidos pasa por varias etapas: </p><br><p>  <em>Etapa 1: Algoritmos</em> .  Aquí está el estudio de algoritmos básicos, estructuras de datos, enfoques de programación como OOP, etc.  El código es exclusivamente de un solo subproceso.  La fase inicial de ingreso a la profesión.  Sin embargo, es bastante complicado y puede durar años. </p><br><p>  <em>Etapa 2: Multithreading</em> .  Luego, surgen preguntas sobre la extracción de la máxima eficiencia del hierro, hay múltiples subprocesos, asincronía, carreras, depuración, strace, noches sin dormir ... Muchos se quedan atrapados en esta etapa e incluso comienzan a sentir una emoción inexplicable en algún momento.  Pero solo unos pocos llegan a comprender la arquitectura de la memoria virtual y los modelos de memoria, los algoritmos sin bloqueo / sin espera y varios modelos asincrónicos.  Y casi nadie: verificación de código de subprocesos múltiples. </p><br><p>  <em>Etapa 3: Distribución</em> .  Aquí está sucediendo tal basura que ni en un cuento de hadas ni en un bolígrafo para describir. </p><a name="habracut"></a><br><p>  Parecería que algo complicado.  Hacemos la transformación: muchos hilos -&gt; muchos procesos -&gt; muchos servidores.  Pero cada paso de la transformación produce cambios cualitativos, y todos caen en el sistema, lo aplastan y lo convierten en polvo. </p><br><p>  Y el punto aquí es cambiar el dominio de manejo de errores y la disponibilidad de memoria compartida.  Si antes siempre había un trozo de memoria disponible en cada subproceso, y si se deseaba, en cada proceso, ahora no existe ese trozo y no puede existir.  Cada uno para sí mismo, independiente y orgulloso. </p><br><p>  Si antes una falla en la corriente enterraba la corriente y el proceso al mismo tiempo, y esto era bueno, porque  no condujo a fallas parciales, ahora las fallas parciales se convierten en la norma y cada vez que piensa cada acción: "¿y si?".  Esto es tan molesto y distrae de la escritura, de hecho, las acciones en sí mismas que el código debido a esto no crece a veces, sino por órdenes de magnitud.  Todo se convierte en los fideos de manejo de errores, cambio de estado y preservación del contexto, restauración debido a fallas de un componente, otro componente, inaccesibilidad de algunos servicios, etc.  etc.  Después de haber estropeado el monitoreo de todo esto, puede tener una buena noche de sueño en su computadora portátil favorita. </p><br><p>  Si se trata de subprocesos múltiples: tomé el mutex y fui a triturar la memoria compartida por placer.  Belleza! </p><br><p>  Como resultado, tenemos que se quitaron las claves y los patrones probados en la batalla, y los nuevos, para reemplazarlos, por alguna razón no se entregaron, y resultó como en una broma sobre cómo la hada agitó su varita y la torre se cayó del tanque. </p><br><p>  Sin embargo, los sistemas distribuidos tienen un conjunto de prácticas y algoritmos probados.  Sin embargo, cada programador que se respete a sí mismo considera que es su deber rechazar los logros conocidos y andar en bicicleta por su propio bien, a pesar de la experiencia adquirida, un número considerable de artículos científicos e investigaciones académicas.  Después de todo, si puede usar algoritmos y subprocesos múltiples, ¿cómo puede meterse en un lío con la distribución?  ¡No puede haber dos opiniones aquí! </p><br><p>  Como resultado, los sistemas tienen errores, los datos divergen y se deterioran, los servicios periódicamente no están disponibles para la escritura, o incluso no están completamente disponibles, porque de repente un nodo se bloqueó, la red se cayó, Java consumió mucha memoria y GC se aburrió, y hay muchas otras razones que podrían retrasar su finalización. a las autoridades. </p><br><p>  Sin embargo, incluso con enfoques conocidos y probados, la vida no se vuelve más fácil, porque  Las primitivas confiables distribuidas son pesadas con requisitos serios para la lógica del código ejecutable.  Por lo tanto, las esquinas se cortan siempre que sea posible.  Y, como suele suceder, con esquinas cortadas apresuradamente, aparece la simplicidad y la escalabilidad relativa, pero la confiabilidad, disponibilidad y consistencia de un sistema distribuido desaparece. </p><br><p>  Idealmente, me gustaría no pensar en absoluto que nuestro sistema está distribuido y multiproceso, es decir  trabajar en la primera etapa (algoritmos), sin pensar en la segunda (subprocesamiento múltiple + asincronía) y la tercera (distribución).  Esta forma de aislar abstracciones aumentaría significativamente la simplicidad, confiabilidad y velocidad de escribir código.  Desafortunadamente, por el momento esto solo es posible en los sueños. </p><br><p>  Sin embargo, las abstracciones individuales permiten un relativo aislamiento.  Uno de los ejemplos típicos es el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">uso de corutinas</a> , donde en lugar de código asincrónico nos hacemos sincrónicos, es decir.  pasamos de la segunda etapa a la primera etapa, lo que nos permite simplificar significativamente la escritura y el mantenimiento del código. </p><br><p>  El artículo revela sucesivamente el uso de algoritmos sin bloqueo para construir un sistema confiable en tiempo real, escalable, distribuido y consistente, es decir  cómo los logros sin bloqueo de la segunda etapa ayudan en la implementación de la tercera, reduciendo la tarea a algoritmos de subproceso único de la primera etapa. </p><br><h2 id="postanovka-zadachi">  Declaración del problema. </h2><br><p>  Esta tarea solo ilustra algunos enfoques importantes y se presenta como un ejemplo para introducir problemas en el contexto.  Se puede generalizar fácilmente a casos más complejos, lo que se hará en el futuro. </p><br><p>  <strong>Tarea: procesamiento de datos en tiempo real</strong> . </p><br><p>  Hay dos corrientes de números.  El controlador lee los datos de estos flujos de entrada y selecciona los últimos números para un período determinado.  Estos números se promedian durante este intervalo de tiempo, es decir  en una ventana de datos deslizante durante un tiempo determinado.  El valor promedio obtenido debe escribirse en la cola de salida para el procesamiento posterior.  Además, si el número de números en la ventana excede un cierto umbral, aumente en uno el contador en la base de datos transaccional externa. </p><br><p><img src="https://habrastorage.org/webt/nf/9d/jh/nf9djhbhsjmrumrg5eckb1h6u_c.png" alt="Inicial"></p><br><p>  Observamos algunas características de este problema. </p><br><ol><li>  <em>No determinismo</em> .  Hay dos fuentes de comportamiento no determinista: esta es una lectura de dos flujos, así como una ventana de tiempo.  Está claro que la lectura puede llevarse a cabo de diferentes maneras, y el resultado final dependerá de en qué secuencia se extraerán los datos.  La ventana de tiempo también cambia el resultado de inicio a inicio, ya que  La cantidad de datos en la ventana dependerá de la velocidad del trabajo. </li><li>  <em>El estado del manejador</em> .  Hay un estado del controlador en forma de un conjunto de números en la ventana, del que dependen los resultados actuales y posteriores del trabajo.  Es decir  Tenemos un controlador con estado. </li><li>  <em>Interacción con almacenamiento externo</em> .  Es necesario actualizar el valor del contador en la base de datos externa.  El punto crucial es que el tipo de almacenamiento externo es diferente del almacenamiento del estado del procesador y los subprocesos. </li></ol><br><p>  Todo esto, como se mostrará a continuación, afecta seriamente las herramientas utilizadas y los posibles métodos de implementación. </p><br><p>  Queda por agregar un pequeño toque a la tarea, que inmediatamente transfiere la tarea de un área más allá de la complejidad a lo imposible: se necesita <em>una</em> garantía <em>concurrente de una sola vez</em> . </p><br><h2 id="exactly-once">  Exactamente una vez </h2><br><p>  <em>Exactamente una vez a</em> menudo se interpreta de manera demasiado amplia, lo que emascula el término en sí mismo, y deja de cumplir con los requisitos originales de la tarea.  Si estamos hablando de un sistema que se ejecuta localmente en una computadora, entonces todo es simple: toma más, tira más.  Pero en este caso estamos hablando de un sistema distribuido en el que: </p><br><ol><li>  El número de manejadores puede ser grande: cada manejador trabaja con sus propios datos.  Además, los resultados se pueden agregar a varios lugares, por ejemplo, una base de datos externa, posiblemente incluso barajada. </li><li>  Cada controlador puede detener repentinamente el procesamiento.  Un sistema tolerante a fallas implica una operación continua incluso en caso de falla de partes individuales del sistema. </li></ol><br><p>  Por lo tanto, debemos estar preparados para el hecho de que el controlador puede caer, y otro controlador debe recoger el trabajo ya realizado y continuar con el procesamiento. </p><br><p>  La pregunta surge de inmediato: ¿qué significará <em>exactamente una vez</em> si funciona el controlador no determinista?  Después de todo, cada vez que reiniciamos, recibiremos, en términos generales, diferentes estados resultantes.  La respuesta aquí es simple: con <em>exactamente una vez,</em> existe tal ejecución del sistema en la que cada valor de entrada se procesa exactamente una vez, dando el resultado de salida correspondiente.  Además, esta ejecución no tiene que estar físicamente en el mismo nodo.  Pero el resultado debería ser como si todo se procesara en un solo nodo lógico <em>sin bloqueos</em> . </p><br><h2 id="concurrent-exactly-once">  Concurrente exactamente una vez </h2><br><p>  Para agravar los requisitos, presentamos un nuevo concepto: <em>concurrente exactamente una vez</em> .  La diferencia fundamental de simple <em>exactamente una vez</em> es la ausencia de pausas durante el procesamiento, como si todo se procesara en el mismo nodo <strong>sin caídas</strong> y <strong>sin pausas</strong> .  En nuestra tarea, requeriremos exactamente <em>concurrente exactamente una vez</em> , por simplicidad de presentación, para no considerar una comparación con los sistemas existentes que no están disponibles hoy en día. </p><br><p>  Las consecuencias de tener tal requisito se discutirán a continuación. </p><br><h2 id="tranzakcionnost">  Transaccional </h2><br><p>  Para que el lector esté aún más profundamente imbuido de la complejidad que ha surgido, veamos varios escenarios negativos que deben tenerse en cuenta al desarrollar un sistema de este tipo.  También intentaremos utilizar un enfoque general que nos permita resolver el problema anterior teniendo en cuenta nuestros requisitos. </p><br><p>  Lo primero que viene a la mente es la necesidad de registrar el estado del controlador y los flujos de entrada y salida.  El estado de los flujos de salida se describe mediante una simple cola de números, y el estado de los flujos de entrada por la posición en ellos.  En esencia, una secuencia es una cola infinita, y una posición en la cola establece de forma única una ubicación. </p><br><p><img src="https://habrastorage.org/webt/iu/h0/pf/iuh0pfzcezje80kdbsv3idyeu9a.jpeg" alt="Idea"></p><br><p>  La siguiente implementación ingenua de un controlador surge utilizando algún tipo de almacén de datos.  En esta etapa, las propiedades específicas del repositorio no serán importantes para nosotros.  Usaremos el lenguaje Pseco para ilustrar la idea (Pseco: = pseudocódigo): </p><br><pre><code class="hljs pgsql">handle(input_queues, output_queues, state): #    input_indexes = <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.get_input_indexes() #      <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: #         items, new_input_indexes = input_queues.get_from(input_indexes) #    state.queue.push(items) #     duration state.queue.trim_time_window(duration) avg = state.queue.avg() need_update_counter = state.queue.size() &gt; size_boundary # (A)      output_queues[<span class="hljs-number"><span class="hljs-number">0</span></span>].push(avg) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> need_update_counter: # (B)      db.increment_counter() # (C)     <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.save_state(state) # (D)    <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.save_queue_indexes(new_input_indexes) # (E)    input_indexes = new_input_indexes</code> </pre> <br><p>  Aquí hay un algoritmo simple de subproceso único que lee datos de flujos de entrada y escribe los valores deseados de acuerdo con la tarea descrita anteriormente. </p><br><p>  Veamos qué sucede en caso de que un nodo caiga en puntos arbitrarios en el tiempo, así como después de reanudar el trabajo.  Está claro que en caso de una caída en los puntos <code>(A)</code> y <code>(E)</code> todo estará bien: o los datos aún no se han registrado en ningún lugar y simplemente restauramos el estado y continuamos en otro nodo, o todos los datos necesarios ya se han registrado y simplemente continúan con el siguiente paso. </p><br><p>  Sin embargo, en caso de una caída en todos los demás puntos, nos esperan problemas inesperados.  Si se produce una caída en el punto <code>(B)</code> , cuando se reinicie el controlador, restauraremos el estado y volveremos a registrar el valor promedio en aproximadamente el mismo rango de números.  En el caso de una caída en el punto <code>(C)</code> además del duplicado promedio, se producirá un duplicado en el incremento del valor.  Y en caso de una caída en <code>(D)</code> obtendremos un estado inconsistente del controlador: el estado corresponde a un nuevo momento en el tiempo, y leeremos los valores de los flujos de entrada antiguos. </p><br><p><img src="https://habrastorage.org/webt/fn/8z/6f/fn8z6f9t3y-fe2hzlepgnie7qps.jpeg" alt="Sorpresas"></p><br><p>  Al mismo tiempo, nada cambiará fundamentalmente al reorganizar las operaciones de grabación: la inconsistencia y los duplicados seguirán siéndolo.  Por lo tanto, llegamos a la conclusión de que todas las acciones para cambiar el estado del controlador en el repositorio, la cola de salida y la base de datos deben realizarse transaccionalmente, es decir.  todo es atómico al mismo tiempo. </p><br><p>  Por consiguiente, es necesario desarrollar un mecanismo para que diferentes almacenamientos puedan cambiar transaccionalmente su estado, y no dentro de cada uno de forma independiente, sino transaccionalmente entre todos los almacenamientos simultáneamente.  Por supuesto, puede colocar nuestro almacenamiento dentro de una base de datos externa, sin embargo, la tarea asumió que el motor de la base de datos y el motor para el marco de procesamiento de datos de transmisión están separados y funcionan de forma independiente el uno del otro.  Aquí quiero considerar el caso más difícil, porque  No es interesante considerar casos simples. </p><br><h2 id="konkurentnaya-otzyvchivost">  Capacidad de respuesta competitiva </h2><br><p>  Considere la ejecución competitiva exactamente una vez con más detalle.  En el caso de un sistema tolerante a fallas, requerimos la continuación del trabajo desde algún punto.  Está claro que este punto será un punto en el pasado, porque  Para mantener el rendimiento, es imposible almacenar todos los momentos de cambios de estado en el presente y en el futuro: se guarda el último resultado de las operaciones o un grupo de valores para aumentar el rendimiento.  Este comportamiento nos lleva inmediatamente al hecho de que después de la restauración del estado del procesador, habrá algún retraso en los resultados, aumentará con el aumento del tamaño del grupo de valores y el tamaño del estado. </p><br><p>  Además de este retraso, también hay retrasos en el sistema asociados con la carga del estado en otro nodo.  Además de esto, la detección de un nodo problemático también lleva algún tiempo, y a menudo mucho.  Esto se debe, en primer lugar, al hecho de que si establecemos un tiempo de detección corto, entonces son posibles los falsos positivos frecuentes, lo que conducirá a todo tipo de efectos especiales desagradables. </p><br><p>  Además, con el aumento en el número de procesadores paralelos, de repente resulta que no todos funcionan igual de bien incluso en ausencia de fallas.  A veces se producen embotamientos, que también conducen a retrasos en el procesamiento.  La razón de tales embotamientos puede variar: </p><br><ol><li>  <em>Software</em> : pausas del GC, fragmentación de la memoria, pausas del asignador, interrupción del kernel y programación de tareas, problemas con los controladores de dispositivos que causan ralentizaciones. </li><li>  <em>Hardware</em> : disco alto o carga de red, aceleración de la CPU debido a problemas de enfriamiento, sobrecarga, etc., desaceleración del disco debido a problemas técnicos. </li></ol><br><p>  Y esta no es una lista exhaustiva de problemas que pueden ralentizar a los manejadores. </p><br><p>  En consecuencia, la desaceleración es un hecho con el que uno tiene que vivir.  A veces esto no es un problema grave, y a veces es extremadamente importante mantener una alta velocidad de procesamiento a pesar de fallas o ralentizaciones. </p><br><p>  Inmediatamente surge la idea de la duplicación de sistemas: corramos por el mismo flujo de datos, no uno sino dos procesadores a la vez, o incluso tres.  El problema aquí es que, en este caso, pueden producirse fácilmente comportamientos duplicados e inconsistentes del sistema.  Normalmente, los marcos no están diseñados para este comportamiento y sugieren que el número de controladores en un momento dado no excede uno.  Los sistemas que permiten la duplicación de ejecución descrita se llaman <em>concurrentes exactamente una vez</em> . </p><br><p>  Esta arquitectura le permite resolver varios problemas a la vez: </p><br><ol><li>  Comportamiento a prueba de fallos: si uno de los nodos cae, el otro simplemente continúa funcionando como si nada hubiera pasado.  No hay necesidad de coordinación adicional, ya que  el segundo manejador se ejecuta independientemente del estado del primero. </li><li>  Eliminando las contundentes: el primero que proporcionó el resultado es bueno para él.  El otro solo tendrá que recoger un nuevo estado y continuar desde este momento. </li></ol><br><p>  Este enfoque, en particular, le permite completar un cálculo largo y difícil por un tiempo más predecible, porque  la probabilidad de que ambos sean estúpidos y caigan significativamente menos. </p><br><h3 id="veroyatnostnaya-ocenka">  Evaluación de probabilidad </h3><br><p>  Intentemos evaluar los beneficios de la duplicación del rendimiento.  Supongamos que algo sucede en promedio todos los días con el controlador: o el GC se ha embotado, o el nodo está mintiendo, o los contenedores se han vuelto cancerosos.  Supongamos también que preparamos paquetes de datos en 10 segundos. </p><br><p>  Entonces la probabilidad de que algo suceda durante la creación del paquete es <code>10 / (24 · 3600) ≃ 1e-4</code> . </p><br><p>  Si ejecuta dos controladores en paralelo, entonces la probabilidad de que ambos <code>≃ 1e-8</code> es <code>≃ 1e-8</code> .  ¡Entonces este evento llegará en 23 años!  Sí, los sistemas no viven tanto, lo que significa que esto nunca sucederá. </p><br><p>  Además, si el tiempo de preparación del paquete será aún más corto y / o se producirán embotamientos incluso con menos frecuencia, esta cifra solo aumentará. </p><br><p>  Por lo tanto, concluimos que el enfoque considerado aumenta significativamente la confiabilidad de todo nuestro sistema.  Solo queda resolver una pequeña pregunta como esta: dónde leer sobre cómo hacer un sistema <em>concurrente de una sola vez</em> .  Y la respuesta es simple: tienes que leer aquí. </p><br><h2 id="polutranzakcii">  Media transacción </h2><br><p>  Para mayor discusión, necesitamos el concepto de <em>media transacción</em> .  La forma más fácil de explicarlo es con un ejemplo. </p><br><p>  Considere transferir fondos de una cuenta bancaria a otra.  El enfoque tradicional que utiliza transacciones en el lenguaje Pseco se puede describir de la siguiente manera: </p><br><pre> <code class="hljs pgsql">transfer(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): tx = db.begin_transaction() amount_from = tx.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> amount_from &lt; amount: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> error.insufficient_funds tx.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, amount_from - amount) tx.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, tx.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) + amount) tx.<span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok</code> </pre> <br><p>  Sin embargo, ¿qué pasa si estas transacciones no están disponibles para nosotros?  Usando bloqueos, esto se puede hacer de la siguiente manera: </p><br><pre> <code class="hljs pgsql">transfer(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): #         lock_from = db.<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>) lock_to = db.<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) amount_from = db.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> amount_from &lt; amount: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> error.insufficient_funds db.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, amount_from - amount) db.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, db.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) + amount) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok</code> </pre> <br><p>  Este enfoque puede conducir a puntos muertos, ya que  Los bloqueos se pueden tomar en diferentes secuencias en paralelo.  Para corregir este comportamiento, es suficiente introducir una función que tome simultáneamente varios bloqueos en una secuencia determinista (por ejemplo, ordenada por teclas), lo que elimina por completo los posibles puntos muertos. </p><br><p>  Sin embargo, la implementación puede simplificarse un tanto: </p><br><pre> <code class="hljs vbscript">transfer(from, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): lock_from = db.lock(from) amount_from = db.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(from) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> amount_from &lt; amount: return <span class="hljs-keyword"><span class="hljs-keyword">error</span></span>.insufficient_funds db.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(from, amount_from - amount) lock_from.release() #   , # .. db.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(db.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>...)     lock_to = db.lock(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) db.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, db.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) + amount) return ok</code> </pre> <br><p>  Este enfoque también hace que el estado final sea consistente, preservando a los invariantes por el tipo de prevención de gastos excesivos de fondos.  La principal diferencia con el enfoque anterior es que en tal implementación tenemos un cierto período de tiempo en el que las cuentas están en un estado inconsistente.  Es decir, tal operación implica que el estado total de los fondos en las cuentas no cambia.  En este caso, hay un intervalo de tiempo entre <code>lock_from.release()</code> y <code>db.lock(to)</code> , durante el cual la base de datos puede devolver un valor inconsistente: la cantidad total puede diferir del correcto hacia abajo. </p><br><p>  De hecho, dividimos una transacción para transferir dinero en dos medias transacciones: </p><br><ol><li>  La primera mitad de la transacción hace un cheque y deduce la cantidad necesaria de la cuenta. </li><li>  La segunda mitad de la transacción escribe el monto retirado en otra cuenta. </li></ol><br><p>  Está claro que dividir una transacción en otras más pequeñas, en general, viola el comportamiento transaccional.  Y el ejemplo anterior no es una excepción.  Sin embargo, si todas las medias transacciones en la cadena se cumplen por completo, entonces el resultado será consistente con todos los invariantes preservados.  Esto es precisamente lo que es una propiedad importante de una cadena de media transacción. </p><br><p>  Sin embargo, al perder temporalmente cierta coherencia, adquirimos otra característica útil: la independencia de las operaciones y, como resultado, una mejor escalabilidad.  La independencia se manifiesta en el hecho de que una media transacción cada vez funciona con una sola línea, leyendo, verificando y cambiando sus datos, sin comunicarse con otros datos.  Por lo tanto, puede barajar una base de datos cuyas transacciones funcionan con un solo fragmento.  Además, este enfoque se puede utilizar en el caso de repositorios heterogéneos, es decir  las medias transacciones pueden comenzar en un tipo de almacenamiento y terminar en otro.  Son propiedades útiles que se utilizarán en el futuro. </p><br><p>  Surge una pregunta legítima: ¿cómo implementar half-trance en sistemas distribuidos y no rake?  Para resolver este problema, debe considerar el enfoque sin bloqueo. </p><br><h2 id="lock-free">  Sin bloqueo </h2><br><p>  Como sabe, los enfoques sin bloqueo a veces mejoran el rendimiento de los sistemas de subprocesos múltiples, especialmente en el caso del acceso competitivo al recurso.  Sin embargo, es completamente obvio que este enfoque puede usarse en sistemas distribuidos.  Profundicemos y consideremos qué es sin bloqueo y por qué esta propiedad será útil para resolver nuestro problema. </p><br><p>  Algunos desarrolladores a veces no entienden qué es sin bloqueo.  La mirada de mente estrecha sugiere que esto es algo relacionado con las instrucciones del procesador atómico.  Es importante entender aquí que sin bloqueo significa el uso de "átomos", lo contrario no es cierto, es decir,  no todas las "atómicas" dan un comportamiento sin bloqueo. </p><br><p>  Una propiedad importante del algoritmo sin bloqueo es que al menos un subproceso avanza en el sistema.  Pero por alguna razón, muchos atribuyen esta propiedad como una definición (es una definición tan contundente que se puede encontrar, por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en Wikipedia</a> ).  Aquí es necesario agregar un matiz importante: el progreso se logra incluso en el caso de romos de uno o más hilos.  Este es un punto muy crítico que a menudo se pasa por alto y tiene serias implicaciones para un sistema distribuido. </p><br><p>  ¿Por qué la ausencia de una condición de progreso de al menos un hilo niega el concepto de un algoritmo sin bloqueo?  El hecho es que, en este caso, el spinlock habitual también estará libre de bloqueos.  De hecho, el que tomó la cerradura hará progresos.  ¿Hay un hilo con progreso =&gt; ​​sin bloqueo? </p><br><p>  Obviamente, sin bloqueo significa sin bloqueos, mientras que el spinlock por su nombre indica que se trata de un bloqueo real.  Por eso es importante agregar una condición al progreso, incluso en el caso de embotamientos.  Después de todo, estos retrasos pueden durar indefinidamente, porque  la definición no dice nada sobre la línea de tiempo superior.  Y si es así, dichos retrasos serán equivalentes en cierto sentido a la desconexión de los flujos.  En este caso, los algoritmos sin bloqueo producirán progreso en este caso. </p><br><p>  Pero, ¿quién dijo que los enfoques sin bloqueo se aplican exclusivamente a sistemas de subprocesos múltiples?  Al reemplazar los subprocesos en el mismo proceso en el mismo nodo con procesos en diferentes nodos, y la memoria compartida de los subprocesos con almacenamiento distribuido compartido, obtenemos un algoritmo distribuido sin bloqueo. </p><br><p>  Una caída de nodo en dicho sistema es equivalente a un retraso en la ejecución de un hilo durante algún tiempo, porque  Es hora de restaurar el trabajo.  Al mismo tiempo, el enfoque sin bloqueo permite que otros participantes en el sistema distribuido continúen trabajando.  Además, se pueden ejecutar algoritmos especiales sin bloqueo en paralelo entre sí, detectando un cambio competitivo y eliminando duplicados. </p><br><p>  <em>El</em> enfoque <em>Exactamente una vez</em> implica la presencia de un almacenamiento distribuido consistente.  Tales almacenamientos, como regla, representan una enorme tabla persistente de clave-valor.  Posibles operaciones: <code>set</code> , <code>get</code> , <code>del</code> .  Sin embargo, se requiere una operación más complicada para el enfoque sin bloqueo: CAS o compare-and-swap.  Consideremos con más detalle esta operación, las posibilidades de su uso, así como los resultados que ofrece. </p><br><h3 id="cas">  Cas </h3><br><p>  CAS o compare-and-swap es la primitiva de sincronización principal e importante para algoritmos sin bloqueo y sin espera.  Su esencia puede ilustrarse con el siguiente Pseco: </p><br><pre> <code class="hljs kotlin">CAS(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, expected, new): # ,   atomic,   atomic: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() != expected: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(new) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><p>  A veces, para la optimización, devuelven no <code>true</code> o <code>false</code> , sino el valor anterior, porque  muy a menudo, tales operaciones se realizan en un bucle, y para obtener el valor <code>expected</code> , primero debe leerlo: </p><br><pre> <code class="hljs vala">CAS_optimized(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, expected, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>): # ,   atomic,   atomic: current = <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> current == expected: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current #  CAS   CAS_optimized CAS(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, expected, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.CAS_optimized(expected, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>) == expected</code> </pre> <br><p>  Este enfoque puede ahorrar una lectura.  Como parte de nuestra revisión, utilizaremos una forma simple de <code>CAS</code> , porque  si se desea, dicha optimización se puede hacer de forma independiente. </p><br><p>  En el caso de los sistemas distribuidos, cada cambio se versiona.  Es decir  Primero leemos el valor de la tienda, obteniendo la versión actual de los datos.  Y luego tratamos de escribir, esperando que la versión de los datos no haya cambiado.  En este caso, la versión se incrementa cada vez que se actualizan los datos: </p><br><pre> <code class="hljs cs">CAS_versioned(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>, expected_version, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>): atomic: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.get_version() != expected_version: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>, expected_version + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><p>  Este enfoque le permite controlar con mayor precisión la actualización de valores, evitando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el problema ABA</a> .  En particular, las versiones son compatibles con Etcd y Zookeeper. </p><br><p>  Tenga en cuenta la importante propiedad que otorga el uso de operaciones <code>CAS_versioned</code> .  El hecho es que tal operación puede repetirse sin perjuicio de la lógica superior.  En la programación multiproceso, esta propiedad no tiene un valor especial, porque  allí, si la operación falló, entonces sabemos con certeza que no se aplicó.  En el caso de los sistemas distribuidos, esta invariante se viola, porque  la solicitud puede llegar al destinatario, pero la respuesta exitosa ya no está allí.  Por lo tanto, es importante poder reenviar solicitudes sin temor a romper invariantes de la lógica de alto nivel. </p><br><p>  Es esta propiedad la que <code>CAS_versioned</code> operación <code>CAS_versioned</code> .  De hecho, esta operación se puede repetir sin cesar hasta que se devuelva la respuesta real del destinatario.  Lo que, a su vez, arroja toda una clase de errores relacionados con la interacción de la red. </p><br><h3 id="primer">  Ejemplo </h3><br><p>  Veamos cómo, en base a <code>CAS_versioned</code> y medias transacciones, transferir de una cuenta a otra, que pertenecen, por ejemplo, a diferentes copias de Etcd.  Aquí, supongo que la función <code>CAS_versioned</code> ya <code>CAS_versioned</code> implementada de acuerdo con la API proporcionada. </p><br><pre> <code class="hljs pgsql">withdraw(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, amount): # CAS- <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: #     version_from, amount_from = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>.get_versioned() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> amount_from &lt; amount: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> error.insufficient_funds <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>.CAS_versioned(version_from, amount_from - amount): break <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok deposit(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): # CAS- <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: version_to, amount_to = <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>.get_versioned() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>.CAS_versioned(version_to, amount_to + amount): break <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok transfer(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): #   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> withdraw(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, amount) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> ok: #     , #    deposit(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount)</code> </pre> <br><p>  Aquí dividimos nuestra operación en medias transacciones, y realizamos cada media transacción a través de la operación <code>CAS_versioned</code> .  Este enfoque le permite trabajar de forma independiente con cada cuenta, lo que permite el uso de almacenamiento heterogéneo que no está conectado entre sí.  El único problema que nos espera aquí es la pérdida de dinero en caso de una caída en el proceso actual en el intervalo entre las medias transacciones. </p><br><h2 id="ochered">  Cola </h2><br><p>  Para continuar, debe implementar una cola de eventos.  La idea es que para que los manejadores se comuniquen entre sí, debe tener una cola de mensajes ordenada en la que los datos no se pierdan ni se dupliquen.  En consecuencia, toda interacción en la cadena de controladores se construirá sobre esta primitiva.  También es una herramienta útil para analizar y auditar flujos de datos entrantes y salientes.  Además de esto, las mutaciones del estado de los manejadores también se pueden hacer a través de la cola. </p><br><p>  La cola consistirá en un par de operaciones: </p><br><ol><li>  Agregue un mensaje al final de la cola. </li><li>  Recibir un mensaje de la cola en el índice especificado. </li></ol><br><p>  En este contexto, no considero eliminar mensajes de la cola por varias razones: </p><br><ol><li>  Varios procesadores pueden leer desde la misma cola.  Eliminar la sincronización será una tarea no trivial, aunque no imposible. </li><li>  Es útil mantener una cola durante un intervalo relativamente largo (día o semana) para la depuración y la auditoría.  La utilidad de esta propiedad es difícil de sobreestimar. </li><li>  Puede eliminar elementos antiguos según lo programado o configurando TTL en los elementos de la cola.  Es importante asegurarse de que los procesadores logren procesar los datos antes de que llegue la escoba y limpien todo.  Si el tiempo de procesamiento es del orden de segundos y el TTL del orden de días, entonces nada de esto debería suceder. </li></ol><br><p>  Para almacenar los elementos e implementar efectivamente la adición, necesitamos: </p><br><ol><li>  El valor con el índice actual.  Este índice apunta al final de la cola para agregar elementos. </li><li>  ,    . </li></ol><br><h3 id="kak-by-lock-free-ochered">   lock-free  </h3><br><p>          :        .        : </p><br><ol><li>    CAS     . </li><li>       . </li></ol><br><p>    ,    ,     . </p><br><ol><li> <strong>    lock-free</strong> .  ,      ,          . Lock-free? !   ,    2 :   .         lock-free,     — !    ,  ,        ,   .              .         , ..            ,     . </li><li> <strong>    </strong> .         ,               .    . </li></ol><br><p>  ,    lock-free         . </p><br><h3 id="lock-free-realizaciya-dobavleniya"> Lock-free   </h3><br><p> ,  ,     :   , ..      ,    : </p><br><pre> <code class="hljs pgsql">push(queue, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>): #      <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = queue.get_current_index() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: #  ,    #    var = queue.at(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) #  = <span class="hljs-number"><span class="hljs-number">0</span></span>   , ..   # ,         <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> var.CAS_versioned(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>): #   ,    queue.update_index(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) break #   , .   <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = max(queue.get_current_index(), <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) update_index(queue, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: #     cur_index, version = queue.get_current_index_versioned() #      , #  , .   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cur_index &gt;= <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>: # -     , #        break <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> queue.current_index_var().CAS_versioned(<span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>): #      ,   break # -  . # ,      ,  </code> </pre> <br><p>      .   ,            (     — ,  ,     ).       lock-free   .    ? </p><br><p>   ,   <code>push</code>     ,      ! ,             ,      . </p><br><p>        .       :         .   ,      -   ,  -               .  ,      , ..      .          .        ?       , ..     ,    ,        . </p><br><p>  ,       ,          .  Es decir    .        ,    ,     .          ,       . </p><br><p>  ,       .               ,   .    ,   ,     .       ,    . </p><br><h2 id="vzaimodeystvie-ocheredey">   </h2><br><p>  ,  ,   ,      . </p><br><p> <em></em> .       . </p><br><p>    ,      : </p><br><ol><li>  , ..  stateless. </li><li>  ,     — . </li></ol><br><p> ,    ,        <em>concurrent exactly-once</em> . </p><br><p>        : </p><br><pre> <code class="hljs pgsql">handle(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>, output): <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) output.push(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> += <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><p>   .        : </p><br><pre> <code class="hljs pgsql">handle(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>, output, state): #   <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = state.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) output.push(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> += <span class="hljs-number"><span class="hljs-number">1</span></span> #   state.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>)</code> </pre> <br><p>     <em>exactly-once</em> .   ,           ,    ,    . </p><br><p>    <em>exactly-once</em> ,     ,    . ..,  ,       ,       ,   ,    —      : </p><br><pre> <code class="hljs pgsql">#       get_next_index(queue): <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = queue.get_index() #     <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> queue.has(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>): #    queue.push <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = max(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>, queue.get_index()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> #      . #  <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>    push_at(queue, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>): var = queue.at(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> var.CAS_versioned(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>): #   queue.update_index(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> handle(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>, output, state): #   #    {PREPARING, <span class="hljs-number"><span class="hljs-number">0</span></span>} fsm_state = state.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: switch fsm_state: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {PREPARING, input_index}: #   :   , #        output_index = output.get_next_index() fsm_state = {WRITING, input_index, output_index} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {WRITING, input_index, output_index}: <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(input_index) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> output.push_at(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, output_index): #  ,     input_index += <span class="hljs-number"><span class="hljs-number">1</span></span> #    ,  push_at  <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, #        fsm_state = {PREPARING, input_index} state.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(fsm_state)</code> </pre> <br><p>        <code>push_at</code> ?      ,   .   ,    ,  ,    .   ,               .             .          -  ,     lock-free . </p><br><p>  ,      : </p><br><ol><li>   :       . </li><li> ,  :      . </li></ol><br><p>   :   <em>concurrent</em>  <em>exactly-once</em> . </p><br><p>      ?   : </p><br><ol><li>       ,         ,   <code>push_at</code>     false.            . </li><li>       ,      . ,   ,       . </li></ol><br><p>     <em>concurrent exactly-once</em>   ?   ,     ,            .    ,           .            . </p><br><p>          : </p><br><pre> <code class="hljs pgsql">#     ,  ,     # ..       <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, #      <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>. #       <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> push_at_idempotent(queue, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> queue.push_at(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> queue.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) == <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> handle(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>, output, state): <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state = state.get_versioned() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: switch fsm_state: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {PREPARING, input_index}: #   ,   , #        output_index = output.get_next_index() fsm_state = {WRITING, input_index, output_index} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {WRITING, input_index, output_index}: <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(input_index) #   , #       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> output.push_at_idempotent(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, output_index): input_index += <span class="hljs-number"><span class="hljs-number">1</span></span> fsm_state = {PREPARING, input_index} #     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> state.CAS_versioned(<span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state): <span class="hljs-keyword"><span class="hljs-keyword">version</span></span> += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: #   ,    <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state = state.get_versioned()</code> </pre> <br><p>  : </p><br><p><img src="https://habrastorage.org/webt/rx/qi/ub/rxqiubplbrrdlokp_sniqhktmvu.png" alt="Simple"></p><br><p>     ,     .     ,           . </p><br><p>             kernel panic,   ,    ..              .              .       :      ,    .  ,        . </p><br><p>  ,    <strong> </strong>    ,    . </p><br><h2 id="reshenie-nachalnoy-zadachi">    </h2><br><p>        :    . </p><br><p>       :  ,     ,    ,      ,      : </p><br><pre> <code class="hljs pgsql">#  : # - input_queues -   # - output_queues -   # - state -    # - <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span> -    : state, inputs -&gt; state, outputs handle(input_queues, output_queues, state, <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>): #        <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state = state.get_versioned() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: switch fsm_state: # input_indexes       <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {HANDLING, user_state, input_indexes}: #       inputs = [queue.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> queue, <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> zip(input_queues, input_indexes)] #   ,    next_indexes = next(inputs, input_indexes) #    #     user_state, outputs = <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>(user_state, inputs) #      , #     fsm_state = {PREPARING, user_state, next_indexes, outputs, <span class="hljs-number"><span class="hljs-number">0</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {PREPARING, user_state, input_indexes, outputs, output_pos}: #  ,      #    output_index = output_queues[output_pos].get_next_index() #     fsm_state = { WRITING, user_state, input_indexes, outputs, output_pos, output_index } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> { WRITING, user_state, input_indexes, outputs, output_pos, output_index }: <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = outputs[output_pos] #       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> output_queues[output_pos].push_at_idempotent( <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, output_index ): #  ,      output_pos += <span class="hljs-number"><span class="hljs-number">1</span></span> #    ,      PREPARING. #     #     fsm_state = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> output_pos == len(outputs): #   , #       {HANDLING, user_state, input_indexes} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: #       #   , #         {PREPARING, user_state, input_indexes, outputs, output_pos} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> state.CAS_versioned(<span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state): <span class="hljs-keyword"><span class="hljs-keyword">version</span></span> += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: #   ,    <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>, fsm_state = state.get_versioned()</code> </pre> <br><p>     : </p><br><p><img src="https://habrastorage.org/webt/fe/mk/bg/femkbgvjaxyy2gi9ye5wkaufqf4.png" alt="final"></p><br><p>      : <code>HANDLING</code> .        , ..,  ,     .  ,      .    ,   <code>PREPARING</code>  <code>WRITING</code>   ,         .     ,      <code>HANDLING</code> . </p><br><p>  ,      ,       ,          .   ,           .  ,            . </p><br><p>      .         .               . </p><br><p><img src="https://habrastorage.org/webt/or/qk/tg/orqktgqgrdw-9tv0_wkl2wt_rye.png" alt="final"></p><br><p>   : </p><br><pre> <code class="hljs cpp">my_handler(state, inputs): #      state.<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.push(inputs) #    duration state.<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.trim_time_window(duration) #   avg = state.<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.avg() need_update_counter = state.<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.size() &gt; size_boundary <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state, [ avg, <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> need_update_counter: <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: # none      none ]</code> </pre> <br><p>  ,      ,           <em>concurrent exactly-once</em>     <code>handle</code> . </p><br><p>        : </p><br><pre> <code class="hljs pgsql">handle_db(input_queue, db): <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>: #      tx = db.begin_transaction() #     . #      , #      <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = tx.get_current_index() #    tx.write_current_index(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) #      <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = intput_queue.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: #    tx.increment_counter() tx.<span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>() #   ,      , #          </code> </pre> <br><p>    . ..       ,         , , ,    <em>concurrent exactly-once</em> .       . </p><br><h2 id="za-bortom">   </h2><br><p>   —            .        ,      ,     . </p><br><h3 id="optimizacii-dlya-konkretnogo-hranilischa">     </h3><br><p>      ,      ,       .           ,  ,          . </p><br><h3 id="asinhronnaya-publikaciya">   </h3><br><p>           .    ,     . ..        ,      .              .        . </p><br><h3 id="gruppirovka-znacheniy">   </h3><br><p>        —   . ,       ,     .    ,     -  ,   ,    .        , .. ,    ,        . </p><br><h3 id="dvoynoe-shardirovanie">   </h3><br><p>       .   ,     ,           .            ,    ,    . </p><br><h2 id="fundamentalnost-podhoda">   </h2><br><p>     . ,         .  :          ,      .     ,       . </p><br><p>      ,   ,      : </p><br><ol><li>    ,   .          . </li><li>     .      ,        . </li><li>          .    ,       .      ,   ,        .  Es decir          .     :    . </li></ol><br><p>     , , -,     ,  -,     . </p><br><p>     ,     .     : </p><br><pre> <code class="hljs pgsql">transfer(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount): #   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> withdraw(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, amount) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> ok: #     , #    deposit(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, amount)</code> </pre> <br><p>  <code>withdraw</code>     ,   ,  <code>deposit</code>    :      ?    <code>deposit</code>  -     (,   ,       ),    .  ,    ,    ,   ,        ?    ,   ,      - ,     . </p><br><p>     ,   ,   ,     . ,     ,   ,   .   ,     .   ,       ,       . ..     ,       ,        .      ,        :     ,     —  . </p><br><h3 id="dvuhfaznost-bez-blokirovok">    </h3><br><p>      ,       . </p><br><p>      :        ,  ,     ,   ,   .   ,        -  : </p><br><ul><li> <em></em> .            ,   , ,     ,     . </li><li> <em></em> .        . </li></ul><br><p>     , , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> . </p><br><p> ,        , ..       ,      ,  .        ,       . </p><br><p>          :     lock-free   ,           .            , ..      ,  . </p><br><p>      CAS       . ,      : </p><br><pre> <code class="hljs swift">#     ,    handle(input, output, state): # ... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> fsm_state: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {<span class="hljs-type"><span class="hljs-type">HANDLING</span></span>, ...}: #      fsm_state = {<span class="hljs-type"><span class="hljs-type">PREPARING</span></span>, ...} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {<span class="hljs-type"><span class="hljs-type">PREPARING</span></span>, input_index}: #   ... output_index = ...get_next_index() fsm_state = {<span class="hljs-type"><span class="hljs-type">WRITING</span></span>, output_index, ...} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> {<span class="hljs-type"><span class="hljs-type">WRITING</span></span>, output_index, ...}: #  ,  output_index</code> </pre> <br><p>  ,     .          .      : </p><br><ol><li> <strong>PREPARING</strong> .     ,        . </li><li> <strong>WRITING</strong> .     .       ,       <strong>PREPARING</strong> . </li></ol><br><p>     ,      . ,          ,     —    .     : </p><br><ol><li>         .  ,    , ..     ,      . </li><li>            , ..       .         ,     . </li></ol><br><p>  ,  lock-free        ,        ,     . </p><br><h2 id="trebovaniya-k-konsistentnosti">    </h2><br><p>  ,     .     ,      <em>Stale Read</em> ,       .   —       CAS:              .       : </p><br><ul><li> <em>Distributed single register</em> —       (, etcd  Zookeeper): <br><ol><li> Linearizability </li><li> Sequential consistency </li></ol></li><li> <em>Transactional</em> —     (, MySQL, PostgreSQL  ..): <br><ol><li> Serializability </li><li> Snapshot Isolation </li><li> Repeatable Read </li><li> Read Committed </li></ol></li><li> <em>Distributed Transactional</em> — NewSQL : <br><ol><li> Strict Consistency </li><li>    </li></ol></li></ul><br><p>   :             ?   ,  ,   .         ,    ,     CAS                .        , ,   <em>Read My Writes</em> . </p><br><h2 id="zaklyuchenie">  Conclusión </h2><br><p>        <em>exactly-once</em> .     , ..  ,  ,    ,    .       ,      ,  , , ..        ,     . </p><br><p>       lock-free       . </p><br><p>    : </p><br><ol><li> <strong></strong> :      . </li><li> <strong></strong> :       . </li><li> <strong></strong> :        : <em>exactly-once</em> . </li><li> <strong>Concurrent</strong> :       . </li><li> <strong>Real-time</strong> :     . </li><li> <strong>Lock-free</strong> :      ,     . </li><li> <strong>Deadlock free</strong> :      ,      . </li><li> <strong>Race condition free</strong> :     . </li><li> <strong>Hot-hot</strong> :        . </li><li> <strong>Hard stop</strong> :       . </li><li> <strong>No failover</strong> :                  . </li><li> <strong>No downtime</strong> :    . </li><li> <strong> </strong> :   ,    . </li><li> <strong></strong> :         . </li><li> <strong></strong> :         . </li><li> <strong></strong> :        . </li></ol><br><p>  ,        .  Pero esa es otra historia. </p><br><p><img src="https://habrastorage.org/webt/ku/4j/nf/ku4jnf9-1pkdjfh_peshj0xd73w.jpeg" alt="Luz"></p><br><h2 id="novye-terminy">   </h2><br><p>       : </p><br><ol><li> Concurrent exactly-once. </li><li> Semi-transactions  . </li><li> Lock-free two-phase commit,       . </li></ol><br><h2 id="zadachi-dlya-samoistyazaniya">    </h2><br><ol><li>     . </li><li>  lock-free       . </li><li>    . </li></ol><br><h2 id="literatura">  Literatura </h2><br><p> [1] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">:  ABA.</a> <br> [2] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Blog: You Cannot Have Exactly-Once Delivery</a> <br> [3] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">:         .</a> <br> [4] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">:  3:  .</a> <br> [5] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">:  .</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es413817/">https://habr.com/ru/post/es413817/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es413807/index.html">Determinación de las características balístico-temporales del movimiento del centro de masa de un paracaidista que aterriza desde un avión.</a></li>
<li><a href="../es413809/index.html">Set-Top-Box y experimentos con Android en el contenedor LXC</a></li>
<li><a href="../es413811/index.html">El resumen de materiales frescos del mundo del front-end para la última semana No. 318 (4 al 10 de junio de 2018)</a></li>
<li><a href="../es413813/index.html">PHP Digest No. 132 (27 de mayo - 10 de junio de 2018)</a></li>
<li><a href="../es413815/index.html">Ir taller de contribución en Rusia</a></li>
<li><a href="../es413819/index.html">Sinceramente sobre el mercado de TI en Rusia</a></li>
<li><a href="../es413823/index.html">El boom del empleo sin sentido</a></li>
<li><a href="../es413827/index.html">Proyecto Kubernetes cumple 4 años</a></li>
<li><a href="../es413831/index.html">La nueva versión del piloto automático Tesla se lanzará en agosto, por primera vez con "características de conducción totalmente autónomas".</a></li>
<li><a href="../es413837/index.html">Hacer de Tower Defense un juego de unidad - Parte 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>