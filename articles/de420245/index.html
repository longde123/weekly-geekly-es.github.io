<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👉🏼 📶 🤞🏾 So verhindern Sie einen Speicherüberlauf bei Verwendung von Java-Sammlungen 👩🏼‍🤝‍👨🏻 🌁 🔑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! 

 Unser Experiment mit Schritten im Java Developer- Kurs wird fortgesetzt und ist seltsamerweise sogar recht erfolgreich (sozusagen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So verhindern Sie einen Speicherüberlauf bei Verwendung von Java-Sammlungen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/420245/"> Hallo allerseits! <br><br>  Unser Experiment mit Schritten im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Java Developer-</a> Kurs wird fortgesetzt und ist seltsamerweise sogar recht erfolgreich (sozusagen): Wie sich herausstellte, ist es viel bequemer, die Hebelwirkung von ein paar Monaten mit dem nächsten Übergang zu einem neuen Schritt zu einem geeigneten Zeitpunkt zu planen, als wenn Weisen Sie einem so schwierigen Kurs fast sechs Monate zu.  Es besteht also der Verdacht, dass es genau die komplexen Kurse sind, die wir bald langsam auf ein solches System übertragen werden. <br><br>  Aber es geht mir um uns, um Otusovsky, es tut mir leid.  Wie immer beschäftigen wir uns weiterhin mit interessanten Themen, die zwar nicht in unserem Programm behandelt werden, aber mit uns besprochen werden. Deshalb haben wir eine Übersetzung des interessantesten Artikels unserer Meinung zu einer der Fragen vorbereitet, die unsere Lehrer gestellt haben. <br><br>  Lass uns gehen! <br><br><img src="https://habrastorage.org/webt/gg/pb/_w/ggpb_wvr4ihy5kk_wj9wm0awrea.png"><a name="habracut"></a><br><br>  Sammlungen im JDK sind die Standardbibliotheksimplementierungen von Listen und Karten.  Wenn Sie sich den Schnappschuss einer typischen großen Java-Anwendung ansehen, sehen Sie Tausende oder sogar Millionen von Instanzen von <code>java.util.ArrayList</code> , <code>java.util.HashMap</code> usw. Sammlungen sind für das Speichern und Bearbeiten von Daten unverzichtbar.  Aber haben Sie jemals darüber nachgedacht, ob alle Sammlungen in Ihrer Anwendung den Speicher optimal nutzen?  Mit anderen Worten, wenn Ihre Anwendung mit dem beschämenden <code>OutOfMemoryError</code> oder lange Pausen im Garbage Collector verursacht, haben Sie die verwendeten Sammlungen jemals auf Lecks überprüft. <br><br>  Zunächst sollte angemerkt werden, dass die internen Sammlungen von JDK keine Art von Magie sind.  Sie sind in Java geschrieben.  Der Quellcode wird mit dem JDK geliefert, sodass Sie ihn in Ihrer IDE öffnen können.  Ihr Code kann auch leicht im Internet gefunden werden.  Und wie sich herausstellt, sind die meisten Sammlungen nicht sehr elegant, um den Speicherbedarf zu optimieren. <br><br>  Stellen Sie sich zum Beispiel eine der einfachsten und beliebtesten Sammlungen vor - die Klasse <code>java.util.ArrayList</code> .  Intern arbeitet jede <code>ArrayList</code> mit einem Array von <code>Object[] elementData</code> .  Hier werden die Listenelemente gespeichert.  Mal sehen, wie dieses Array verarbeitet wird. <br><br>  Wenn Sie eine <code>ArrayList</code> mit dem Standardkonstruktor erstellen, <code>elementData</code> <code>new ArrayList()</code> <code>elementData</code> , zeigt <code>elementData</code> auf ein generisches Array mit der Größe Null ( <code>elementData</code> kann auch auf <code>null</code> , das Array bietet jedoch einige geringfügige Implementierungsvorteile).  Wenn Sie das erste Element zur Liste hinzufügen, wird ein wirklich eindeutiges Array von <code>elementData</code> und das bereitgestellte Objekt in diese eingefügt.  Um zu vermeiden, dass die Größe des Arrays beim Hinzufügen eines neuen Elements jedes Mal geändert wird, wird es mit einer Länge von 10 („Standardkapazität“) erstellt.  Es stellt sich also heraus: Wenn Sie dieser <code>ArrayList</code> keine Elemente mehr hinzufügen, bleiben 9 von 10 Slots im <code>elementData</code> Array leer.  Und selbst wenn Sie die Liste löschen, wird die Größe des internen Arrays nicht reduziert.  Das Folgende ist ein Diagramm dieses Lebenszyklus: <br><br><img src="https://habrastorage.org/webt/mu/3n/hd/mu3nhdbrmajrdvphqi1kyj6nhii.png"><br><br>  Wie viel Speicher wird hier verschwendet?  In absoluten Zahlen wird es berechnet als (die Größe des Objektzeigers).  Wenn Sie den JVM-HotSpot verwenden (der mit dem Oracle JDK geliefert wird), hängt die Größe des Zeigers von der maximalen Heap-Größe ab (weitere Informationen finden Sie unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://blog.codecentric.de/de/2014/02/35gb-heap-less- 32GB-Java-JVM-Speicher-Kuriositäten /</a> ).  Wenn Sie <code>-Xmx</code> weniger als 32 Gigabyte angeben, <code>-Xmx</code> die Größe des Zeigers <code>-Xmx</code> 4 Byte.  für große Haufen - 8 Bytes.  Somit verschwendet eine vom Standardkonstruktor initialisierte <code>ArrayList</code> mit nur einem Element entweder 36 oder 72 Bytes. <br><br>  Tatsächlich verschwendet eine leere <code>ArrayList</code> auch Speicher, da sie keine Arbeitslast trägt, aber die Größe der <code>ArrayList</code> selbst ist nicht Null und größer als Sie wahrscheinlich denken.  Dies liegt zum einen daran, dass ein von der HotSpot-JVM verwaltetes Objekt einerseits über einen 12- oder 16-Byte-Header verfügt, der von der JVM für interne Zwecke verwendet wird.  Darüber hinaus enthalten die meisten Objekte in der Sammlung ein <code>size</code> , einen Zeiger auf ein internes Array oder ein anderes "Workload Media" -Objekt, ein <code>modCount</code> Feld zum Verfolgen von <code>modCount</code> usw. Daher wird wahrscheinlich auch das kleinstmögliche Objekt, das eine leere Sammlung darstellt, mindestens benötigt 32 Bytes Speicher.  Einige, wie <code>ConcurrentHashMap</code> , nehmen viel mehr auf. <br><br>  Stellen Sie sich eine andere allgemeine Sammlung vor - die Klasse <code>java.util.HashMap</code> .  Sein Lebenszyklus ähnelt dem <code>ArrayList</code> Lebenszyklus: <br><br><img src="https://habrastorage.org/webt/qu/ov/lm/quovlmld5clm9w8f0x3v7a_kor8.png"><br><br>  Wie Sie sehen können, <code>HashMap</code> eine <code>HashMap</code> die nur ein Schlüssel-Wert-Paar enthält, 15 interne Zellen des Arrays, was 60 oder 120 Bytes entspricht.  Diese Zahlen sind gering, aber das Ausmaß des Speicherverlusts ist für alle Sammlungen in Ihrer Anwendung wichtig.  Und es stellt sich heraus, dass einige Anwendungen auf diese Weise ziemlich viel Speicher verbrauchen können.  Zum Beispiel verlieren einige der beliebten Open-Source-Hadoop-Komponenten, die der Autor analysiert hat, in einigen Fällen etwa 20 Prozent ihres Heaps!  Bei Produkten, die von weniger erfahrenen Ingenieuren entwickelt wurden und nicht regelmäßig überprüft werden, kann der Speicherverlust sogar noch höher sein.  Es gibt genug Fälle, in denen beispielsweise 90% der Knoten in einem riesigen Baum nur ein oder zwei Nachkommen (oder gar nichts) enthalten, und andere Situationen, in denen der Heap mit 0-, 1- oder 2-Element-Sammlungen verstopft ist. <br><br>  Wie können Sie unbenutzte oder nicht ausreichend genutzte Sammlungen in Ihrer Anwendung beheben?  Im Folgenden finden Sie einige gängige Rezepte.  Hier wird angenommen, dass unsere problematische Sammlung eine <code>ArrayList</code> auf die das Datenfeld <code>Foo.list</code> . <br><br>  Wenn die meisten Instanzen der Liste nie verwendet werden, versuchen Sie, sie träge zu initialisieren.  Also der Code, der vorher aussah wie ... <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addToList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object x)</span></span></span><span class="hljs-function"> </span></span>{ list.add(x); }</code> </pre> <br>  ... sollte in so etwas wie erneuert werden <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addToList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object x)</span></span></span><span class="hljs-function"> </span></span>{ getOrCreateList().add(x); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> list </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOrCreateList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   ,         if (list == null) list = new ArrayList(); return list; }</span></span></code> </pre> <br>  Denken Sie daran, dass Sie manchmal zusätzliche Maßnahmen ergreifen müssen, um potenziellen Wettbewerb anzugehen.  Wenn Sie beispielsweise <code>ConcurrentHashMap</code> , das von mehreren Threads gleichzeitig aktualisiert werden kann, sollte der Code, der es initialisiert, nicht zulassen, dass zwei Threads zwei Kopien dieser Map zufällig erstellen: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Map </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOrCreateMap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (map == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//,       synchronized (this) { if (map == null) map = new ConcurrentHashMap(); } } return map; }</span></span></code> </pre> <br>  Wenn die meisten Instanzen Ihrer Liste oder Karte nur wenige Elemente enthalten, versuchen Sie beispielsweise, sie mit einer geeigneteren Anfangskapazität zu initialisieren. <br><br><pre> <code class="java hljs">list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList(<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-comment"><span class="hljs-comment">//       4</span></span></code> </pre> <br>  Wenn Ihre Sammlungen leer sind oder in den meisten Fällen nur ein Element (oder ein Schlüssel-Wert-Paar) enthalten, können Sie eine extreme Form der Optimierung in Betracht ziehen.  Dies funktioniert nur, wenn die Sammlung in der aktuellen Klasse vollständig verwaltet wird, dh anderer Code kann nicht direkt darauf zugreifen.  Die Idee ist, dass Sie den Typ Ihres Datenfelds beispielsweise von Liste in ein allgemeineres Objekt ändern, sodass es jetzt entweder auf eine reale Liste oder direkt auf ein einzelnes Listenelement verweisen kann.  Hier ist eine kurze Skizze: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// ***   *** private List&lt;Foo&gt; list = new ArrayList&lt;&gt;(); void addToList(Foo foo) { list.add(foo); } // ***   *** //   ,    null.      , //      .       //   ArrayList. private Object listOrSingleEl; void addToList(Foo foo) { if (listOrSingleEl == null) { //   listOrSingleEl = foo; } else if (listOrSingleEl instanceof Foo) { //  Foo firstEl = (Foo) listOrSingleEl; ArrayList&lt;Foo&gt; list = new ArrayList&lt;&gt;(); listOrSingleEl = list; list.add(firstEl); list.add(foo); } else { //      ((ArrayList&lt;Foo&gt;) listOrSingleEl).add(foo); } }</span></span></code> </pre> <br>  Offensichtlich ist Code mit dieser Optimierung weniger klar und schwieriger zu warten.  Dies kann jedoch hilfreich sein, wenn Sie sicher sind, dass dadurch viel Speicherplatz gespart oder lange Pausen des Garbage Collectors vermieden werden. <br><br>  Sie haben sich wahrscheinlich schon gefragt: Wie finde ich heraus, welche Sammlungen in meiner Anwendung Speicherplatz beanspruchen und wie viel? <br><br>  Kurzum: Ohne die richtigen Werkzeuge ist es schwer herauszufinden.  Der Versuch, die Menge an Speicher zu erraten, die von Datenstrukturen in einer großen komplexen Anwendung verwendet oder verbraucht wird, führt fast nie zu etwas.  Und wenn Sie nicht genau wissen, wohin der Speicher geht, können Sie viel Zeit damit verbringen, die falschen Ziele zu <code>OutOfMemoryError</code> , während Ihre Anwendung mit <code>OutOfMemoryError</code> weiterhin hartnäckig <code>OutOfMemoryError</code> . <br><br>  Daher sollten Sie eine Reihe von Anwendungen mit einem speziellen Tool überprüfen.  Erfahrungsgemäß besteht die optimale Methode zur Analyse des JVM-Speichers (gemessen als verfügbare Informationsmenge im Vergleich zu den Auswirkungen dieses Tools auf die Anwendungsleistung) darin, einen Heap-Dump zu erstellen und ihn dann offline anzuzeigen.  Ein Heap-Dump ist im Wesentlichen eine vollständige Momentaufnahme des Heaps.  Sie können es jederzeit durch Aufrufen des Dienstprogramms jmap abrufen oder die JVM so konfigurieren, dass sie automatisch ausgegeben wird, wenn die Anwendung mit <code>OutOfMemoryError</code> abstürzt.  Wenn Sie "JVM-Heap-Dump" googeln, sehen Sie sofort eine große Anzahl von Artikeln, in denen ausführlich erläutert wird, wie Sie einen Dump erhalten. <br><br>  Ein Heap-Dump ist eine Binärdatei von der Größe eines JVM-Heaps, sodass sie nur mit speziellen Tools gelesen und analysiert werden kann.  Es gibt verschiedene Tools, sowohl Open Source als auch kommerziell.  Das beliebteste Open Source-Tool ist die Eclipse MAT.  Es gibt auch VisualVM und einige weniger leistungsfähige und weniger bekannte Tools.  Zu den kommerziellen Tools gehören universelle Java-Profiler: JProfiler und YourKit sowie ein Tool, das speziell für die Heap-Dump-Analyse entwickelt wurde - JXRay (Haftungsausschluss: zuletzt vom Autor entwickelt). <br><br>  Im Gegensatz zu anderen Tools analysiert JXRay den Heap-Dump sofort auf eine Vielzahl häufiger Probleme wie wiederholte Zeilen und andere Objekte sowie auf unzureichend effiziente Datenstrukturen.  Probleme mit den oben beschriebenen Sammlungen fallen in die letztere Kategorie.  Das Tool generiert einen Bericht mit allen gesammelten Informationen im HTML-Format.  Der Vorteil dieses Ansatzes besteht darin, dass Sie die Analyseergebnisse jederzeit und überall anzeigen und problemlos mit anderen teilen können.  Sie können das Tool auch auf jedem Computer ausführen, einschließlich großer und leistungsstarker, aber „kopfloser“ Computer im Rechenzentrum. <br><br>  JXRay berechnet den Overhead (wie viel Speicher Sie sparen, wenn Sie ein bestimmtes Problem beseitigen) in Bytes und als Prozentsatz des verwendeten Heaps.  Es kombiniert Sammlungen derselben Klasse, die dasselbe Problem haben ... <br><br><img src="https://habrastorage.org/webt/qm/_n/44/qm_n44hqttg315sv5h8wv3ujefc.png"><br><br>  ... und gruppiert dann die problematischen Sammlungen, auf die von einem Stamm des Garbage Collectors über dieselbe Gliederkette zugegriffen werden kann, wie im folgenden Beispiel <br><br><img src="https://habrastorage.org/webt/4o/is/ib/4oisibqplc6cj55ojwossuycohs.png"><br><br>  Wenn Sie wissen, welche Verknüpfungsketten und / oder einzelnen Datenfelder (z. B. <code>INodeDirectory.children</code> oben) Sammlungen angeben, die den größten Teil ihres Speichers <code>INodeDirectory.children</code> können Sie den für das Problem verantwortlichen Code schnell und genau identifizieren und dann die erforderlichen Änderungen vornehmen. <br><br>  Daher können unzureichend konfigurierte Java-Sammlungen viel Speicher verschwenden.  In vielen Situationen ist dieses Problem leicht zu lösen, aber manchmal müssen Sie Ihren Code auf nicht triviale Weise ändern, um eine signifikante Verbesserung zu erzielen.  Es ist sehr schwer zu erraten, welche Sammlungen optimiert werden müssen, um die größte Wirkung zu erzielen.  Um keine Zeit mit der Optimierung der falschen Teile des Codes zu verschwenden, müssen Sie einen JVM-Heap-Dump erstellen und ihn mit dem entsprechenden Tool analysieren. <br><br>  DAS ENDE <br><br>  Wir sind wie immer an Ihren Meinungen und Fragen interessiert, die Sie hier hinterlassen oder bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einer offenen Lektion vorbeischauen</a> und dort unsere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lehrer</a> fragen können. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de420245/">https://habr.com/ru/post/de420245/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de420233/index.html">UE4 | Ausrüstung für den Mehrspielermodus # 5 | Informationsübertragung zwischen Server und Client</a></li>
<li><a href="../de420235/index.html">Zenject: Wie ein IoC-Container die Abhängigkeitsinjektion für Ihr Projekt beenden kann</a></li>
<li><a href="../de420237/index.html">Qt-Wrapper um das gRPC-Framework in C ++</a></li>
<li><a href="../de420239/index.html">Mobile Entwicklung. Swift: das Geheimnis der Protokolle</a></li>
<li><a href="../de420243/index.html">Durchbruch Philanthropie: Humanitäre Durchbruchsprojekte</a></li>
<li><a href="../de420251/index.html">Apple behauptet, dass der Hauptsitzkomplex des Unternehmens nur 200 US-Dollar kostet</a></li>
<li><a href="../de420253/index.html">Wie offene Banking-APIs die Finanzwelt verändern</a></li>
<li><a href="../de420257/index.html">Installieren Sie noch Windows 2008? Ich auch, und deshalb</a></li>
<li><a href="../de420259/index.html">Singapore Alterning Diagnostic Panel</a></li>
<li><a href="../de420261/index.html">Was werden wir messen? So wählen Sie die richtigen ML-Metriken für Geschäftsaufgaben aus</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>