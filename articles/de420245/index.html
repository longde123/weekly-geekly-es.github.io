<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëâüèº üì∂ ü§ûüèæ So verhindern Sie einen Speicher√ºberlauf bei Verwendung von Java-Sammlungen üë©üèº‚Äçü§ù‚Äçüë®üèª üåÅ üîë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! 

 Unser Experiment mit Schritten im Java Developer- Kurs wird fortgesetzt und ist seltsamerweise sogar recht erfolgreich (sozusagen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So verhindern Sie einen Speicher√ºberlauf bei Verwendung von Java-Sammlungen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/420245/"> Hallo allerseits! <br><br>  Unser Experiment mit Schritten im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Java Developer-</a> Kurs wird fortgesetzt und ist seltsamerweise sogar recht erfolgreich (sozusagen): Wie sich herausstellte, ist es viel bequemer, die Hebelwirkung von ein paar Monaten mit dem n√§chsten √úbergang zu einem neuen Schritt zu einem geeigneten Zeitpunkt zu planen, als wenn Weisen Sie einem so schwierigen Kurs fast sechs Monate zu.  Es besteht also der Verdacht, dass es genau die komplexen Kurse sind, die wir bald langsam auf ein solches System √ºbertragen werden. <br><br>  Aber es geht mir um uns, um Otusovsky, es tut mir leid.  Wie immer besch√§ftigen wir uns weiterhin mit interessanten Themen, die zwar nicht in unserem Programm behandelt werden, aber mit uns besprochen werden. Deshalb haben wir eine √úbersetzung des interessantesten Artikels unserer Meinung zu einer der Fragen vorbereitet, die unsere Lehrer gestellt haben. <br><br>  Lass uns gehen! <br><br><img src="https://habrastorage.org/webt/gg/pb/_w/ggpb_wvr4ihy5kk_wj9wm0awrea.png"><a name="habracut"></a><br><br>  Sammlungen im JDK sind die Standardbibliotheksimplementierungen von Listen und Karten.  Wenn Sie sich den Schnappschuss einer typischen gro√üen Java-Anwendung ansehen, sehen Sie Tausende oder sogar Millionen von Instanzen von <code>java.util.ArrayList</code> , <code>java.util.HashMap</code> usw. Sammlungen sind f√ºr das Speichern und Bearbeiten von Daten unverzichtbar.  Aber haben Sie jemals dar√ºber nachgedacht, ob alle Sammlungen in Ihrer Anwendung den Speicher optimal nutzen?  Mit anderen Worten, wenn Ihre Anwendung mit dem besch√§menden <code>OutOfMemoryError</code> oder lange Pausen im Garbage Collector verursacht, haben Sie die verwendeten Sammlungen jemals auf Lecks √ºberpr√ºft. <br><br>  Zun√§chst sollte angemerkt werden, dass die internen Sammlungen von JDK keine Art von Magie sind.  Sie sind in Java geschrieben.  Der Quellcode wird mit dem JDK geliefert, sodass Sie ihn in Ihrer IDE √∂ffnen k√∂nnen.  Ihr Code kann auch leicht im Internet gefunden werden.  Und wie sich herausstellt, sind die meisten Sammlungen nicht sehr elegant, um den Speicherbedarf zu optimieren. <br><br>  Stellen Sie sich zum Beispiel eine der einfachsten und beliebtesten Sammlungen vor - die Klasse <code>java.util.ArrayList</code> .  Intern arbeitet jede <code>ArrayList</code> mit einem Array von <code>Object[] elementData</code> .  Hier werden die Listenelemente gespeichert.  Mal sehen, wie dieses Array verarbeitet wird. <br><br>  Wenn Sie eine <code>ArrayList</code> mit dem Standardkonstruktor erstellen, <code>elementData</code> <code>new ArrayList()</code> <code>elementData</code> , zeigt <code>elementData</code> auf ein generisches Array mit der Gr√∂√üe Null ( <code>elementData</code> kann auch auf <code>null</code> , das Array bietet jedoch einige geringf√ºgige Implementierungsvorteile).  Wenn Sie das erste Element zur Liste hinzuf√ºgen, wird ein wirklich eindeutiges Array von <code>elementData</code> und das bereitgestellte Objekt in diese eingef√ºgt.  Um zu vermeiden, dass die Gr√∂√üe des Arrays beim Hinzuf√ºgen eines neuen Elements jedes Mal ge√§ndert wird, wird es mit einer L√§nge von 10 (‚ÄûStandardkapazit√§t‚Äú) erstellt.  Es stellt sich also heraus: Wenn Sie dieser <code>ArrayList</code> keine Elemente mehr hinzuf√ºgen, bleiben 9 von 10 Slots im <code>elementData</code> Array leer.  Und selbst wenn Sie die Liste l√∂schen, wird die Gr√∂√üe des internen Arrays nicht reduziert.  Das Folgende ist ein Diagramm dieses Lebenszyklus: <br><br><img src="https://habrastorage.org/webt/mu/3n/hd/mu3nhdbrmajrdvphqi1kyj6nhii.png"><br><br>  Wie viel Speicher wird hier verschwendet?  In absoluten Zahlen wird es berechnet als (die Gr√∂√üe des Objektzeigers).  Wenn Sie den JVM-HotSpot verwenden (der mit dem Oracle JDK geliefert wird), h√§ngt die Gr√∂√üe des Zeigers von der maximalen Heap-Gr√∂√üe ab (weitere Informationen finden Sie unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://blog.codecentric.de/de/2014/02/35gb-heap-less- 32GB-Java-JVM-Speicher-Kuriosit√§ten /</a> ).  Wenn Sie <code>-Xmx</code> weniger als 32 Gigabyte angeben, <code>-Xmx</code> die Gr√∂√üe des Zeigers <code>-Xmx</code> 4 Byte.  f√ºr gro√üe Haufen - 8 Bytes.  Somit verschwendet eine vom Standardkonstruktor initialisierte <code>ArrayList</code> mit nur einem Element entweder 36 oder 72 Bytes. <br><br>  Tats√§chlich verschwendet eine leere <code>ArrayList</code> auch Speicher, da sie keine Arbeitslast tr√§gt, aber die Gr√∂√üe der <code>ArrayList</code> selbst ist nicht Null und gr√∂√üer als Sie wahrscheinlich denken.  Dies liegt zum einen daran, dass ein von der HotSpot-JVM verwaltetes Objekt einerseits √ºber einen 12- oder 16-Byte-Header verf√ºgt, der von der JVM f√ºr interne Zwecke verwendet wird.  Dar√ºber hinaus enthalten die meisten Objekte in der Sammlung ein <code>size</code> , einen Zeiger auf ein internes Array oder ein anderes "Workload Media" -Objekt, ein <code>modCount</code> Feld zum Verfolgen von <code>modCount</code> usw. Daher wird wahrscheinlich auch das kleinstm√∂gliche Objekt, das eine leere Sammlung darstellt, mindestens ben√∂tigt 32 Bytes Speicher.  Einige, wie <code>ConcurrentHashMap</code> , nehmen viel mehr auf. <br><br>  Stellen Sie sich eine andere allgemeine Sammlung vor - die Klasse <code>java.util.HashMap</code> .  Sein Lebenszyklus √§hnelt dem <code>ArrayList</code> Lebenszyklus: <br><br><img src="https://habrastorage.org/webt/qu/ov/lm/quovlmld5clm9w8f0x3v7a_kor8.png"><br><br>  Wie Sie sehen k√∂nnen, <code>HashMap</code> eine <code>HashMap</code> die nur ein Schl√ºssel-Wert-Paar enth√§lt, 15 interne Zellen des Arrays, was 60 oder 120 Bytes entspricht.  Diese Zahlen sind gering, aber das Ausma√ü des Speicherverlusts ist f√ºr alle Sammlungen in Ihrer Anwendung wichtig.  Und es stellt sich heraus, dass einige Anwendungen auf diese Weise ziemlich viel Speicher verbrauchen k√∂nnen.  Zum Beispiel verlieren einige der beliebten Open-Source-Hadoop-Komponenten, die der Autor analysiert hat, in einigen F√§llen etwa 20 Prozent ihres Heaps!  Bei Produkten, die von weniger erfahrenen Ingenieuren entwickelt wurden und nicht regelm√§√üig √ºberpr√ºft werden, kann der Speicherverlust sogar noch h√∂her sein.  Es gibt genug F√§lle, in denen beispielsweise 90% der Knoten in einem riesigen Baum nur ein oder zwei Nachkommen (oder gar nichts) enthalten, und andere Situationen, in denen der Heap mit 0-, 1- oder 2-Element-Sammlungen verstopft ist. <br><br>  Wie k√∂nnen Sie unbenutzte oder nicht ausreichend genutzte Sammlungen in Ihrer Anwendung beheben?  Im Folgenden finden Sie einige g√§ngige Rezepte.  Hier wird angenommen, dass unsere problematische Sammlung eine <code>ArrayList</code> auf die das Datenfeld <code>Foo.list</code> . <br><br>  Wenn die meisten Instanzen der Liste nie verwendet werden, versuchen Sie, sie tr√§ge zu initialisieren.  Also der Code, der vorher aussah wie ... <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addToList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object x)</span></span></span><span class="hljs-function"> </span></span>{ list.add(x); }</code> </pre> <br>  ... sollte in so etwas wie erneuert werden <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addToList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object x)</span></span></span><span class="hljs-function"> </span></span>{ getOrCreateList().add(x); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> list </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOrCreateList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   ,         if (list == null) list = new ArrayList(); return list; }</span></span></code> </pre> <br>  Denken Sie daran, dass Sie manchmal zus√§tzliche Ma√ünahmen ergreifen m√ºssen, um potenziellen Wettbewerb anzugehen.  Wenn Sie beispielsweise <code>ConcurrentHashMap</code> , das von mehreren Threads gleichzeitig aktualisiert werden kann, sollte der Code, der es initialisiert, nicht zulassen, dass zwei Threads zwei Kopien dieser Map zuf√§llig erstellen: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Map </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOrCreateMap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (map == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//,       synchronized (this) { if (map == null) map = new ConcurrentHashMap(); } } return map; }</span></span></code> </pre> <br>  Wenn die meisten Instanzen Ihrer Liste oder Karte nur wenige Elemente enthalten, versuchen Sie beispielsweise, sie mit einer geeigneteren Anfangskapazit√§t zu initialisieren. <br><br><pre> <code class="java hljs">list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList(<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-comment"><span class="hljs-comment">//       4</span></span></code> </pre> <br>  Wenn Ihre Sammlungen leer sind oder in den meisten F√§llen nur ein Element (oder ein Schl√ºssel-Wert-Paar) enthalten, k√∂nnen Sie eine extreme Form der Optimierung in Betracht ziehen.  Dies funktioniert nur, wenn die Sammlung in der aktuellen Klasse vollst√§ndig verwaltet wird, dh anderer Code kann nicht direkt darauf zugreifen.  Die Idee ist, dass Sie den Typ Ihres Datenfelds beispielsweise von Liste in ein allgemeineres Objekt √§ndern, sodass es jetzt entweder auf eine reale Liste oder direkt auf ein einzelnes Listenelement verweisen kann.  Hier ist eine kurze Skizze: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// ***   *** private List&lt;Foo&gt; list = new ArrayList&lt;&gt;(); void addToList(Foo foo) { list.add(foo); } // ***   *** //   ,    null.      , //      .       //   ArrayList. private Object listOrSingleEl; void addToList(Foo foo) { if (listOrSingleEl == null) { //   listOrSingleEl = foo; } else if (listOrSingleEl instanceof Foo) { //  Foo firstEl = (Foo) listOrSingleEl; ArrayList&lt;Foo&gt; list = new ArrayList&lt;&gt;(); listOrSingleEl = list; list.add(firstEl); list.add(foo); } else { //      ((ArrayList&lt;Foo&gt;) listOrSingleEl).add(foo); } }</span></span></code> </pre> <br>  Offensichtlich ist Code mit dieser Optimierung weniger klar und schwieriger zu warten.  Dies kann jedoch hilfreich sein, wenn Sie sicher sind, dass dadurch viel Speicherplatz gespart oder lange Pausen des Garbage Collectors vermieden werden. <br><br>  Sie haben sich wahrscheinlich schon gefragt: Wie finde ich heraus, welche Sammlungen in meiner Anwendung Speicherplatz beanspruchen und wie viel? <br><br>  Kurzum: Ohne die richtigen Werkzeuge ist es schwer herauszufinden.  Der Versuch, die Menge an Speicher zu erraten, die von Datenstrukturen in einer gro√üen komplexen Anwendung verwendet oder verbraucht wird, f√ºhrt fast nie zu etwas.  Und wenn Sie nicht genau wissen, wohin der Speicher geht, k√∂nnen Sie viel Zeit damit verbringen, die falschen Ziele zu <code>OutOfMemoryError</code> , w√§hrend Ihre Anwendung mit <code>OutOfMemoryError</code> weiterhin hartn√§ckig <code>OutOfMemoryError</code> . <br><br>  Daher sollten Sie eine Reihe von Anwendungen mit einem speziellen Tool √ºberpr√ºfen.  Erfahrungsgem√§√ü besteht die optimale Methode zur Analyse des JVM-Speichers (gemessen als verf√ºgbare Informationsmenge im Vergleich zu den Auswirkungen dieses Tools auf die Anwendungsleistung) darin, einen Heap-Dump zu erstellen und ihn dann offline anzuzeigen.  Ein Heap-Dump ist im Wesentlichen eine vollst√§ndige Momentaufnahme des Heaps.  Sie k√∂nnen es jederzeit durch Aufrufen des Dienstprogramms jmap abrufen oder die JVM so konfigurieren, dass sie automatisch ausgegeben wird, wenn die Anwendung mit <code>OutOfMemoryError</code> abst√ºrzt.  Wenn Sie "JVM-Heap-Dump" googeln, sehen Sie sofort eine gro√üe Anzahl von Artikeln, in denen ausf√ºhrlich erl√§utert wird, wie Sie einen Dump erhalten. <br><br>  Ein Heap-Dump ist eine Bin√§rdatei von der Gr√∂√üe eines JVM-Heaps, sodass sie nur mit speziellen Tools gelesen und analysiert werden kann.  Es gibt verschiedene Tools, sowohl Open Source als auch kommerziell.  Das beliebteste Open Source-Tool ist die Eclipse MAT.  Es gibt auch VisualVM und einige weniger leistungsf√§hige und weniger bekannte Tools.  Zu den kommerziellen Tools geh√∂ren universelle Java-Profiler: JProfiler und YourKit sowie ein Tool, das speziell f√ºr die Heap-Dump-Analyse entwickelt wurde - JXRay (Haftungsausschluss: zuletzt vom Autor entwickelt). <br><br>  Im Gegensatz zu anderen Tools analysiert JXRay den Heap-Dump sofort auf eine Vielzahl h√§ufiger Probleme wie wiederholte Zeilen und andere Objekte sowie auf unzureichend effiziente Datenstrukturen.  Probleme mit den oben beschriebenen Sammlungen fallen in die letztere Kategorie.  Das Tool generiert einen Bericht mit allen gesammelten Informationen im HTML-Format.  Der Vorteil dieses Ansatzes besteht darin, dass Sie die Analyseergebnisse jederzeit und √ºberall anzeigen und problemlos mit anderen teilen k√∂nnen.  Sie k√∂nnen das Tool auch auf jedem Computer ausf√ºhren, einschlie√ülich gro√üer und leistungsstarker, aber ‚Äûkopfloser‚Äú Computer im Rechenzentrum. <br><br>  JXRay berechnet den Overhead (wie viel Speicher Sie sparen, wenn Sie ein bestimmtes Problem beseitigen) in Bytes und als Prozentsatz des verwendeten Heaps.  Es kombiniert Sammlungen derselben Klasse, die dasselbe Problem haben ... <br><br><img src="https://habrastorage.org/webt/qm/_n/44/qm_n44hqttg315sv5h8wv3ujefc.png"><br><br>  ... und gruppiert dann die problematischen Sammlungen, auf die von einem Stamm des Garbage Collectors √ºber dieselbe Gliederkette zugegriffen werden kann, wie im folgenden Beispiel <br><br><img src="https://habrastorage.org/webt/4o/is/ib/4oisibqplc6cj55ojwossuycohs.png"><br><br>  Wenn Sie wissen, welche Verkn√ºpfungsketten und / oder einzelnen Datenfelder (z. B. <code>INodeDirectory.children</code> oben) Sammlungen angeben, die den gr√∂√üten Teil ihres Speichers <code>INodeDirectory.children</code> k√∂nnen Sie den f√ºr das Problem verantwortlichen Code schnell und genau identifizieren und dann die erforderlichen √Ñnderungen vornehmen. <br><br>  Daher k√∂nnen unzureichend konfigurierte Java-Sammlungen viel Speicher verschwenden.  In vielen Situationen ist dieses Problem leicht zu l√∂sen, aber manchmal m√ºssen Sie Ihren Code auf nicht triviale Weise √§ndern, um eine signifikante Verbesserung zu erzielen.  Es ist sehr schwer zu erraten, welche Sammlungen optimiert werden m√ºssen, um die gr√∂√üte Wirkung zu erzielen.  Um keine Zeit mit der Optimierung der falschen Teile des Codes zu verschwenden, m√ºssen Sie einen JVM-Heap-Dump erstellen und ihn mit dem entsprechenden Tool analysieren. <br><br>  DAS ENDE <br><br>  Wir sind wie immer an Ihren Meinungen und Fragen interessiert, die Sie hier hinterlassen oder bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einer offenen Lektion vorbeischauen</a> und dort unsere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lehrer</a> fragen k√∂nnen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de420245/">https://habr.com/ru/post/de420245/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de420233/index.html">UE4 | Ausr√ºstung f√ºr den Mehrspielermodus # 5 | Informations√ºbertragung zwischen Server und Client</a></li>
<li><a href="../de420235/index.html">Zenject: Wie ein IoC-Container die Abh√§ngigkeitsinjektion f√ºr Ihr Projekt beenden kann</a></li>
<li><a href="../de420237/index.html">Qt-Wrapper um das gRPC-Framework in C ++</a></li>
<li><a href="../de420239/index.html">Mobile Entwicklung. Swift: das Geheimnis der Protokolle</a></li>
<li><a href="../de420243/index.html">Durchbruch Philanthropie: Humanit√§re Durchbruchsprojekte</a></li>
<li><a href="../de420251/index.html">Apple behauptet, dass der Hauptsitzkomplex des Unternehmens nur 200 US-Dollar kostet</a></li>
<li><a href="../de420253/index.html">Wie offene Banking-APIs die Finanzwelt ver√§ndern</a></li>
<li><a href="../de420257/index.html">Installieren Sie noch Windows 2008? Ich auch, und deshalb</a></li>
<li><a href="../de420259/index.html">Singapore Alterning Diagnostic Panel</a></li>
<li><a href="../de420261/index.html">Was werden wir messen? So w√§hlen Sie die richtigen ML-Metriken f√ºr Gesch√§ftsaufgaben aus</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>