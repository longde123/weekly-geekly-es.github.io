<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙆🏼 👩🏾‍🎓 📺 Speicheroffenlegung des Kernels in modernen Betriebssystemen 🏧 📼 ➿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Unter dem Cutter befindet sich die Übersetzung des ersten Teils des Dokuments Detecting Kernel Memory Disclosure mit x86-Emulation und Taint Tracking ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Speicheroffenlegung des Kernels in modernen Betriebssystemen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415685/"><p> Unter dem Cutter befindet sich die Übersetzung des <strong>ersten Teils des</strong> Dokuments <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Detecting Kernel Memory Disclosure mit x86-Emulation und Taint Tracking</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikelprojekt Null</a> ) von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mateusz Jurczyk</a> . </p><br><p>  Im übersetzten Teil des Dokuments: </p><br><ul><li>  Besonderheiten der C-Programmiersprache (als Teil des Speichererweiterungsproblems) </li><li>  die Besonderheiten des Betriebs der Windows- und Linux-Kernel (als Teil des Speichererweiterungsproblems) </li><li>  Bedeutung der Offenlegung des Kernelspeichers und Auswirkungen auf die Betriebssystemsicherheit </li><li>  vorhandene Verfahren und Techniken zum Erkennen und Gegensteuern der Offenbarung des Kernelspeichers </li></ul><br><p>  Obwohl sich das Dokument auf die Kommunikationsmechanismen zwischen dem privilegierten Kernel des Betriebssystems und Benutzeranwendungen konzentriert, kann das Wesentliche des Problems für jede Datenübertragung zwischen verschiedenen Sicherheitsdomänen verallgemeinert werden: Der Hypervisor ist der Gastcomputer, der privilegierte Systemdienst (Daemon) ist die GUI-Anwendung, der Netzwerkclient ist der Server usw. . </p><br><p><img src="https://habrastorage.org/webt/ne/uy/1q/neuy1q8npc2ba-y3vcaycx9kqxe.jpeg" alt="KDPV"></p><a name="habracut"></a><br><h2 id="vvedenie">  Einführung </h2><br><p>  Eine der Aufgaben moderner Betriebssysteme besteht darin, die Trennung von Berechtigungen zwischen Benutzeranwendungen und dem Kernel des Betriebssystems sicherzustellen.  Dies schließt zum einen die Tatsache ein, dass der Einfluss jedes Programms auf die Laufzeit durch eine bestimmte Sicherheitsrichtlinie begrenzt werden sollte, und zum anderen, dass Programme nur auf die Informationen zugreifen können, die sie lesen dürfen.  Die zweite ist angesichts der Eigenschaften der C-Sprache (der Hauptprogrammiersprache, die bei der Entwicklung des Kernels verwendet wird) schwierig bereitzustellen, was es äußerst schwierig macht, Daten sicher zwischen verschiedenen Sicherheitsdomänen zu übertragen. </p><br><p>  Moderne Betriebssysteme, die auf x86 / x86-64-Plattformen ausgeführt werden, sind multithreaded und verwenden ein Client-Server-Modell, in dem Anwendungen (Clients) im Benutzermodus unabhängig ausgeführt werden und den Betriebssystemkern (Server) aufrufen, um mit einer vom System verwalteten Ressource zu arbeiten.  Der Mechanismus, der vom Benutzermoduscode ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ring 3</a> ) zum Aufrufen eines vordefinierten Satzes von Kernelfunktionen (Ring 0) verwendet wird, wird als Systemaufrufe oder (kurz) Systemaufrufe bezeichnet.  Ein typischer Systemaufruf ist in Abbildung 1 dargestellt: <br><img src="https://habrastorage.org/webt/dh/p3/hr/dhp3hruaqmh7onhd0mweycvv4bg.png" alt="Abbildung 1: Systemaufruf"><br>  <em>Abbildung 1: Lebenszyklus eines Systemaufrufs</em> </p><br><p>  Es ist sehr wichtig zu vermeiden, dass versehentlich Kernelspeicherinhalte verloren gehen, wenn Sie mit Programmen im Benutzermodus interagieren.  Es besteht ein erhebliches Risiko, vertrauliche Kerneldaten offenzulegen.  Daten können implizit in den Ausgabeparametern sicherer (aus anderer Sicht) Systemaufrufe übertragen werden. </p><br><p>  Die Offenlegung des privilegierten Systemspeichers erfolgt, wenn der Betriebssystemkern einen Speicherbereich zurückgibt, der größer (überschüssig) ist als zum Speichern der entsprechenden Informationen (darin enthalten) erforderlich ist.  Oft enthalten redundante Bytes Daten, die in einem anderen Kontext gefüllt wurden, und dann wurde der Speicher nicht vorinitialisiert, was die Verbreitung von Informationen in neuen Datenstrukturen verhindern würde. </p><br><h2 id="specifika-yazyka-programmirovaniya-c">  C Besonderheiten der Programmiersprache </h2><br><p>  In diesem Abschnitt werden einige Aspekte der C-Sprache behandelt, die für das Problem der Speichererweiterung am wichtigsten sind. </p><br><h4 id="neopredelennoe-sostoyanie-neinicializirovannyh-peremennyh">  Undefinierter Status nicht initialisierter Variablen </h4><br><p>  Einzelne Variablen einfacher Typen (wie char oder int) sowie Mitglieder von Datenstrukturen (Arrays, Strukturen und Gewerkschaften) bleiben bis zur ersten Initialisierung in einem undefinierten Zustand (unabhängig davon, ob sie auf dem Stapel oder auf dem Heap abgelegt werden).  Relevante Zitate aus der C11-Spezifikation (ISO / IEC 9899: 201x Ausschussentwurf N1570, April 2011): </p><br><blockquote>  6.7.9 Initialisierung <br>  ... <br>  10 Wenn ein Objekt mit automatischer Speicherdauer nicht explizit initialisiert wird, ist <u>sein Wert unbestimmt</u> . <br><br>  7.22.3.4 Die Malloc-Funktion <br>  ... <br>  2 Die Malloc-Funktion reserviert Platz für ein Objekt, dessen Größe durch die Größe angegeben wird und <u>dessen Wert unbestimmt ist</u> . <br><br>  7.22.3.5 Die Realloc-Funktion <br>  ... <br>  2 Die Realloc-Funktion gibt die Zuordnung des alten Objekts frei, auf das ptr zeigt, und gibt einen Zeiger auf ein neues Objekt zurück, dessen Größe durch die Größe angegeben ist.  Der Inhalt des neuen Objekts muss derselbe sein wie der des alten Objekts vor der Freigabe, bis auf die geringere der neuen und alten Größen.  Alle Bytes im neuen Objekt, die über die Größe des alten Objekts hinausgehen, <u>haben unbestimmte Werte</u> . </blockquote><p>  Der Teil, der für Systemcode gilt, ist für Objekte auf dem Stapel am relevantesten, da der Betriebssystemkern normalerweise dynamische Zuordnungsschnittstellen mit eigener Semantik hat (nicht unbedingt kompatibel mit der Standard-C-Bibliothek, wie später beschrieben wird). </p><br><p>  Soweit wir wissen, erstellt keiner der drei beliebtesten C-Compiler für Windows und Linux (Microsoft C / C ++ - Compiler, gcc, LLVM) Code, der vom Programmierer nicht initialisierte Variablen auf dem Stack im Release-Build-Modus (oder einem gleichwertigen) vorinitialisiert.  Es gibt Compileroptionen zum Markieren von Stapelrahmen mit speziellen Byte-Markern (z. B. / RTCs in Microsoft Visual Studio), die jedoch aus Leistungsgründen in Release-Builds nicht verwendet werden.  Infolgedessen <em>erben</em> nicht initialisierte Variablen auf dem Stapel <em>die</em> alten Werte der entsprechenden Speicherbereiche. </p><br><p>  Stellen Sie sich ein Beispiel für eine Standardimplementierung eines fiktiven Windows-Systemaufrufs vor, bei dem eine Eingabe-Ganzzahl mit zwei multipliziert wird und das Ergebnis der Multiplikation zurückgegeben wird (Listing 1).  Im Sonderfall (InputValue == 0) bleibt die Variable OutputValue natürlich nicht initialisiert und wird zurück auf den Client kopiert.  Mit diesem Fehler können Sie für jeden Aufruf vier Byte Kernel-Stack-Speicher öffnen. </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS NTAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NtMultiplyByTwo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DWORD InputValue, LPDWORD OutputPointer)</span></span></span><span class="hljs-function"> </span></span>{ DWORD OutputValue; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (InputValue != <span class="hljs-number"><span class="hljs-number">0</span></span>) { OutputValue = InputValue * <span class="hljs-number"><span class="hljs-number">2</span></span>; } *OutputPointer = OutputValue; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> STATUS_SUCCESS; }</code> </pre> <br><p>  <em>Codeauflistung 1: Speichererweiterung durch eine nicht initialisierte lokale Variable.</em> </p><br><p>  Lecks durch eine nicht initialisierte lokale Variable sind in der Praxis nicht sehr häufig: Einerseits erkennen und warnen moderne Compiler häufig solche Probleme, andererseits sind solche Lecks Funktionsfehler, die während der Entwicklung oder des Testens erkannt werden können.  Das zweite Beispiel (in Listing 2) zeigt jedoch, dass ein Leck auch durch das Strukturfeld auftreten kann. </p><br><p>  In diesem Fall wird das reservierte Strukturfeld im Code nie explizit verwendet, sondern dennoch in den Benutzermodus zurückkopiert und stellt daher auch vier Byte Kernelspeicher für den aufrufenden Code bereit.  Dieses Beispiel zeigt deutlich, dass das Initialisieren jedes Felds jeder Struktur, die für alle Zweige der Codeausführung an den Client zurückgegeben wird, keine leichte Aufgabe ist.  In vielen Fällen erscheint eine erzwungene Initialisierung unlogisch, insbesondere wenn dieses Feld keine praktische Rolle spielt.  Es ist jedoch die Tatsache, dass eine nicht initialisierte Variable (oder ein Strukturfeld) auf dem Stapel (oder auf dem Heap) den Inhalt von Daten akzeptiert, die zuvor in diesem Speicherbereich (im Kontext einer anderen Operation) gespeichert wurden, das Herzstück des Kernel-Speichererweiterungsproblems. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SYSCALL_OUTPUT</span></span></span><span class="hljs-class"> {</span></span> DWORD Sum; DWORD Product; DWORD Reserved; } SYSCALL_OUTPUT, *PSYSCALL_OUTPUT; <span class="hljs-function"><span class="hljs-function">NTSTATUS NTAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NtArithOperations</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( DWORD InputValue, PSYSCALL_OUTPUT OutputPointer )</span></span></span><span class="hljs-function"> </span></span>{ SYSCALL_OUTPUT OutputStruct; OutputStruct.Sum = InputValue + <span class="hljs-number"><span class="hljs-number">2</span></span>; OutputStruct.Product = InputValue * <span class="hljs-number"><span class="hljs-number">2</span></span>; RtlCopyMemory(OutputPointer, &amp;OutputStruct, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(SYSCALL_OUTPUT)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> STATUS_SUCCESS; }</code> </pre> <br><p>  <em>Listing 2: Speichererweiterung durch ein reserviertes Strukturfeld.</em> </p><br><h4 id="vyravnivanie-struktur-i-zapolnyayuschie-padding-bayty">  Ausrichtung von Strukturen und Füllbytes </h4><br><p>  Das Initialisieren aller Felder der Ausgabestruktur ist ein guter Anfang, um eine Speichererweiterung zu vermeiden.  Dies reicht jedoch nicht aus, um sicherzustellen, dass in der Darstellung auf niedriger Ebene keine nicht initialisierten Bytes vorhanden sind.  Kehren wir zur C11-Spezifikation zurück: </p><br><blockquote>  6.5.3.4 Die Größe und Ausrichtung der Operatoren <br>  ... <br>  4 [...] Bei Anwendung auf einen Operanden mit Struktur- oder Vereinigungstyp ergibt sich die Gesamtzahl der Bytes in einem solchen Objekt, <u>einschließlich interner und nachfolgender Auffüllung</u> . <br><br>  6.2.8 Ausrichtung von Objekten <br>  1 Für vollständige Objekttypen gelten Ausrichtungsanforderungen, die <u>die Adressen einschränken, an denen Objekte dieses Typs zugewiesen werden können</u> .  Eine Ausrichtung ist ein implementierungsdefinierter integrierter ganzzahliger Wert, der die Anzahl der Bytes zwischen aufeinanderfolgenden Adressen darstellt, an denen ein bestimmtes Objekt zugewiesen werden kann.  [...] <br><br>  6.7.2.1 Struktur- und Gewerkschaftsspezifizierer <br>  ... <br>  17 <u>Am Ende einer Struktur oder Vereinigung befindet sich möglicherweise eine unbenannte Polsterung</u> . </blockquote><p>  Das heißt, C-Sprach-Compiler für x86 (-64) -Architekturen verwenden die natürliche Ausrichtung von Feldern von Strukturen (mit einem primitiven Typ): Jedes dieser Felder wird durch N Bytes ausgerichtet, wobei N die Größe des Feldes ist.  Darüber hinaus werden ganze Strukturen und Verknüpfungen auch ausgerichtet, wenn sie in einem Array deklariert werden, und die Anforderung für die Ausrichtung verschachtelter Felder ist erfüllt.  Um die Ausrichtung sicherzustellen, werden bei Bedarf implizite Füllbytes in Strukturen eingefügt.  Obwohl im Quellcode nicht direkt auf sie zugegriffen werden kann, erben diese Bytes auch alte Werte aus Speicherbereichen und können Informationen in den Benutzermodus übertragen. </p><br><p>  Im Beispiel in Listing 3 wird die Struktur SYSCALL_OUTPUT an den aufrufenden Code zurückgegeben.  Es enthält 4- und 8-Byte-Felder, die durch 4 Füllbytes getrennt sind, damit die Adresse des LargeSum-Feldes ein Vielfaches von 8 wird.  Trotz der Tatsache, dass beide Felder korrekt initialisiert wurden, werden Füllbytes nicht explizit gesetzt, was wiederum zur Erweiterung des Kernel-Stack-Speichers führt.  Die spezifische Position der Struktur im Speicher ist in Abbildung 2 dargestellt. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SYSCALL_OUTPUT</span></span></span><span class="hljs-class"> {</span></span> DWORD Sum; QWORD LargeSum; } SYSCALL_OUTPUT, *PSYSCALL_OUTPUT; <span class="hljs-function"><span class="hljs-function">NTSTATUS NTAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NtSmallSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( DWORD InputValue, PSYSCALL_OUTPUT OutputPointer )</span></span></span><span class="hljs-function"> </span></span>{ SYSCALL_OUTPUT OutputStruct; OutputStruct.Sum = InputValue + <span class="hljs-number"><span class="hljs-number">2</span></span>; OutputStruct.LargeSum = <span class="hljs-number"><span class="hljs-number">0</span></span>; RtlCopyMemory(OutputPointer, &amp;OutputStruct, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(SYSCALL_OUTPUT)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> STATUS_SUCCESS; }</code> </pre> <br><p>  <em>Listing 3: Speichererweiterung durch Ausrichten der Struktur.</em> </p><br><p><img src="https://habrastorage.org/webt/pw/i1/1a/pwi11anmkjf_ujlkogv2bjmbsuo.png" alt="Abbildung 2: Struktur ausrichten"><br>  Abbildung 2: Darstellung der Struktur im Speicher unter Berücksichtigung der Ausrichtung. </p><br><p>  Lecks durch Alignments sind relativ häufig, da viele Ausgabeparameter von Systemaufrufen durch Strukturen dargestellt werden.  Das Problem ist besonders akut für 64-Bit-Plattformen, bei denen die Größe von Zeigern, size_t und ähnlichen Typen von 4 auf 8 Bytes zunimmt, was zum Auftreten von Auffüllungen führt, die zum Ausrichten der Felder solcher Strukturen erforderlich sind. </p><br><p>  Da Auffüllbytes im Quellcode nicht adressiert werden können, muss ein Memset oder eine ähnliche Funktion verwendet werden, um den gesamten Speicherbereich der Struktur zurückzusetzen, bevor eines ihrer Felder initialisiert und in den Benutzermodus kopiert wird, zum Beispiel: </p><br><pre> <code class="cpp hljs"> <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;OutputStruct, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(OutputStruct));</code> </pre> <br><p>  Seacord RC stellt jedoch in seinem Buch "The CERT C Coding Standard, 2. Auflage: 98 Regeln für die Entwicklung sicherer, zuverlässiger und sicherer Systeme. Addison-Wesley Professional" 2014 fest, dass dies keine ideale Lösung ist, da Bytes aufgefüllt werden ) kann nach dem Aufrufen von memset beispielsweise als Nebeneffekt von Operationen mit benachbarten Feldern immer noch <em>heruntergefahren</em> werden.  Bedenken können durch die folgende Aussage in Spezifikation C begründet werden: </p><br><blockquote>  6.2.6 Darstellungen von Typen <br>  6.2.6.1 Allgemeines <br>  ... <br>  6 <u>Wenn ein Wert in einem Objekt vom Typ Struktur oder Vereinigung gespeichert wird</u> , einschließlich in einem <u>Elementobjekt</u> , nehmen die Bytes der Objektdarstellung, <u>die Auffüllbytes</u> entsprechen, <u>nicht angegebene Werte an</u> .  [...] </blockquote><p>  In der Praxis hat jedoch keiner der von uns getesteten C-Compiler außerhalb der Speicherbereiche explizit deklarierter Felder gelesen oder geschrieben.  Es scheint, dass diese Meinung von Entwicklern von Betriebssystemen geteilt wird, die memset verwenden. </p><br><h4 id="obedineniya-unions-i-polya-raznogo-razmera">  Gewerkschaften und Felder unterschiedlicher Größe </h4><br><p>  Joins sind ein weiteres komplexes C-Sprachkonstrukt im Zusammenhang mit der Kommunikation mit weniger privilegiertem Aufrufcode.  Überlegen Sie, wie die C11-Spezifikation die Darstellung von Gewerkschaften im Speicher beschreibt: </p><br><blockquote>  6.2.5 Typen <br>  ... <br>  20 Aus den Objekt- und Funktionstypen können wie folgt beliebig viele abgeleitete Typen erstellt werden: [...] <u>Ein Vereinigungstyp beschreibt eine überlappende nicht leere Menge von Elementobjekten</u> , von denen jedes einen optional angegebenen Namen und möglicherweise einen unterschiedlichen Typ hat. <br><br>  6.7.2.1 Struktur- und Gewerkschaftsspezifizierer <br>  ... <br>  6 Wie in 6.2.5 erläutert, ist eine Struktur ein Typ, der aus einer Folge von Elementen besteht, deren Speicher in einer geordneten Reihenfolge zugeordnet ist, und <u>eine Vereinigung ist ein Typ, der aus einer Folge von Mitgliedern besteht, deren Speicher sich überlappen</u> . <br>  ... <br>  16 <u>Die Größe einer Gewerkschaft reicht aus, um das größte ihrer Mitglieder aufzunehmen</u> .  Der Wert von höchstens einem der Mitglieder kann jederzeit in einem Gewerkschaftsobjekt gespeichert werden. </blockquote><p>  Das Problem ist, dass, wenn die Vereinigung aus mehreren Feldern unterschiedlicher Größe besteht und nur ein Feld kleinerer Größe explizit initialisiert wird, die verbleibenden Bytes, die zur Aufnahme großer Felder zugewiesen sind, nicht initialisiert bleiben.  Schauen wir uns ein Beispiel für einen hypothetischen Systemaufruf-Handler an, der in Listing 4 gezeigt ist, zusammen mit der in Abbildung 3 gezeigten SYSCALL_OUTPUT-Zuordnungsspeicherzuordnung. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> _SYSCALL_OUTPUT { DWORD Sum; QWORD LargeSum; } SYSCALL_OUTPUT, *PSYSCALL_OUTPUT; <span class="hljs-function"><span class="hljs-function">NTSTATUS NTAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NtSmallSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( DWORD InputValue, PSYSCALL_OUTPUT OutputPointer )</span></span></span><span class="hljs-function"> </span></span>{ SYSCALL_OUTPUT OutputStruct; OutputStruct.Sum = InputValue + <span class="hljs-number"><span class="hljs-number">2</span></span>; RtlCopyMemory(OutputPointer, &amp;OutputStruct, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(SYSCALL_OUTPUT)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> STATUS_SUCCESS; }</code> </pre> <br><p>  <em>Codeauflistung 4: Erweitern des Speichers durch teilweises Initialisieren einer Union.</em> </p><br><p><img src="https://habrastorage.org/webt/pa/8y/ck/pa8yckhciassiwm9yc19nssczwo.png" alt="Abbildung 3: Ausrichten eines Joins"><br>  <em>Abbildung 3: Darstellung der Vereinigung im Speicher mit Ausrichtung.</em> </p><br><p>  Es stellt sich heraus, dass die Gesamtgröße der SYSCALL_OUTPUT-Vereinigung 8 Byte beträgt (aufgrund der Größe des größeren LargeSum-Felds).  Die Funktion legt jedoch nur den Wert des kleineren Felds fest, sodass 4 nachfolgende Bytes nicht initialisiert werden, was anschließend zu einem Leck in der Clientanwendung führt. </p><br><p>  Eine sichere Implementierung sollte nur das Feld Summe im Benutzeradressraum festlegen und nicht das gesamte Objekt mit möglicherweise nicht verwendeten Speicherbereichen kopieren.  Eine weitere funktionierende Lösung besteht darin, die Memset-Funktion aufzurufen, um eine Kopie der Union im Kernelspeicher aufzuheben, bevor eines ihrer Felder festgelegt und in den Benutzermodus zurücküberwiesen wird. </p><br><h4 id="nebezopasnyy-sizeof">  Unsichere Größe von </h4><br><p>  Wie in den beiden vorherigen Abschnitten gezeigt, kann die Verwendung des Operators sizeof direkt oder indirekt dazu beitragen, den Kernelspeicher freizulegen, wodurch mehr Daten kopiert werden als zuvor initialisiert. </p><br><p>  C verfügt nicht über die erforderliche Vorrichtung, um Daten sicher vom Kernel in den Benutzerbereich zu übertragen - oder allgemeiner zwischen verschiedenen Sicherheitskontexten.  Die Sprache enthält keine Laufzeitmetadaten, die explizit angeben können, welche Bytes in jeder Datenstruktur festgelegt wurden, die für die Interaktion mit dem Betriebssystemkern verwendet wird.  Infolgedessen liegt die Verantwortung beim Programmierer, der bestimmen muss, welche Teile jedes Objekts an den aufrufenden Code übergeben werden sollen.  Bei korrekter Ausführung müssen Sie für jede in Systemaufrufen verwendete Ausgabestruktur eine separate Funktion zum sicheren Kopieren schreiben.  Dies führt wiederum zu einer Aufblähung des Codes, einer Verschlechterung der Lesbarkeit und ist im Allgemeinen eine mühsame und zeitaufwändige Aufgabe. </p><br><p>  Andererseits ist es bequem und einfach, den gesamten Speicherbereich des Kernels mit einem einzigen memcpy-Aufruf und dem Argument sizeof zu kopieren und den Client bestimmen zu lassen, welche Teile der Ausgabe verwendet werden.  Es stellt sich heraus, dass dieser Ansatz heute unter Windows und Linux verwendet wird.  Und wenn ein bestimmter Fall von Informationslecks erkannt wird, wird sofort ein Patch mit einem Memset-Aufruf bereitgestellt und vom Betriebssystemhersteller verteilt.  Leider löst dies das Problem im allgemeinen Fall nicht. </p><br><h2 id="specifika-konkretnyh-os">  Betriebssystemspezifikationen </h2><br><p>  Es gibt bestimmte Kernel-Design-Lösungen, Programmiermethoden und Codemuster, die sich darauf auswirken, wie anfällig das Betriebssystem für Schwachstellen bei der Speichererweiterung ist.  Sie werden in den folgenden Unterabschnitten berücksichtigt. </p><br><h4 id="pereispolzovanie-dinamicheskoy-pamyati">  Dynamischen Speicher wiederverwenden </h4><br><p>  Die aktuellen Allokatoren des dynamischen Speichers (sowohl im Benutzermodus als auch im Kernelmodus) sind stark optimiert, da ihre Leistung einen erheblichen Einfluss auf die Leistung des gesamten Systems hat.  Eine der wichtigsten Optimierungen ist die Wiederverwendung von Speicher: Wenn der entsprechende Speicher freigegeben wird, wird er selten vollständig verworfen. Stattdessen wird er in der Liste der Regionen gespeichert, die bei der nächsten Zuweisung zurückgegeben werden können.  Um CPU-Zyklen zu speichern, werden die Standardspeicherbereiche nicht zwischen Freigabe und neuer Zuweisung gelöscht.  Infolgedessen stellt sich heraus, dass zwei nicht verbundene Teile des Kernels für kurze Zeit mit demselben Speicherbereich arbeiten.  Dies bedeutet, dass Sie durch das Auslaufen des Inhalts des dynamischen Speichers des Kernels die Daten verschiedener Betriebssystemkomponenten anzeigen können. </p><br><p>  In den folgenden Abschnitten geben wir einen kurzen Überblick über die im Windows- und Linux-Kernel verwendeten Allokatoren und ihre bemerkenswertesten Eigenschaften. </p><br><p>  <strong>Windows</strong> <br>  Die Schlüsselfunktion des Windows-Kernel-Pool-Managers ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ExAllocatePoolWithTag</a> , der direkt oder über eine der verfügbaren Shells aufgerufen werden kann: ExAllocatePool {∅, Ex, WithQuotaTag, WithTagPriority}.  Keine dieser Funktionen löscht den Inhalt des zurückgegebenen Speichers, entweder standardmäßig oder über Eingabeflags.  Im Gegenteil, alle haben die folgende Warnung in ihrer jeweiligen MSDN-Dokumentation: </p><br><blockquote>  Hinweis Der von der Funktion zugewiesene Speicher ist nicht initialisiert.  Ein Kernel-Modus-Treiber muss diesen Speicher zuerst auf Null setzen, wenn er für Benutzer-Modus-Software sichtbar gemacht werden soll (um zu vermeiden, dass potenziell privilegierte Inhalte verloren gehen). </blockquote><p>  Der aufrufende Code kann einen von sechs Haupttypen von Pools auswählen: NonPagedPool, NonPagedPoolNx, NonPagedPoolSession, NonPagedPoolSessionNx, PagedPool und PagedPoolSession.  Jeder von ihnen hat einen eigenen Bereich im virtuellen Adressraum, und daher können die zugewiesenen Speicherbereiche nur innerhalb desselben Pooltyps wiederverwendet werden.  Die Häufigkeit der Wiederverwendung von Speicherelementen ist sehr hoch, und Bereiche mit Nullen werden normalerweise nur zurückgegeben, wenn in den Lookaside-Listen kein geeigneter Datensatz gefunden wird oder die Anforderung so groß ist, dass neue Speicherseiten erforderlich sind.  Mit anderen Worten, es gibt derzeit praktisch keine Faktoren, die die Offenlegung des Poolspeichers in Windows verhindern, und fast jeder dieser Fehler kann verwendet werden, um vertrauliche Daten aus verschiedenen Teilen des Kernels zu verlieren. </p><br><p>  <strong>Linux</strong> <br>  Der Linux-Kernel verfügt über drei Hauptschnittstellen für die dynamische Zuweisung von Speicher: </p><br><ul><li>  <strong>kmalloc</strong> - eine allgemeine Funktion zum <strong>Zuweisen von</strong> Speicherblöcken beliebiger Größe (kontinuierlich sowohl im virtuellen als auch im physischen Adressraum), verwendet die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Plattenspeicherzuweisung</a> . </li><li>  <strong>kmem_cache_create</strong> und <strong>kmem_cache_alloc</strong> - ein spezialisierter Mechanismus zum <strong>Zuweisen von</strong> Objekten fester Größe (z. B. Strukturen) - verwendet ebenfalls die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zuweisung von Plattenspeicher</a> . </li><li>  <strong>vmalloc</strong> ist eine selten verwendete Zuordnungsfunktion, die Regionen zurückgibt, deren Kontinuität auf der Ebene des physischen Speichers nicht garantiert ist. </li></ul><br><p>  Diese Funktionen (für sich allein) garantieren nicht, dass die ausgewählten Regionen keine alten (möglicherweise vertraulichen) Daten enthalten, wodurch der Speicher des Kernel-Heaps geöffnet werden kann.  Es gibt jedoch verschiedene Möglichkeiten, wie der aufrufende Code den ungültigen Speicher anfordern kann: </p><br><ul><li>  Die <strong>kmalloc-</strong> Funktion hat ein Analogon von <strong>kzalloc</strong> , das sicherstellt, dass der zurückgegebene Speicher gelöscht wird. </li><li>  Das optionale __GFP_ZERO-Flag kann an <strong>kmalloc</strong> , <strong>kmem_cache_alloc</strong> und einige andere Funktionen übergeben werden, um das gleiche Ergebnis zu erzielen. </li><li>  <strong>kmem_cache_create</strong> akzeptiert einen Zeiger auf eine optionale Konstruktorfunktion, die aufgerufen wird, um jedes Objekt vorab zu initialisieren, bevor es an den aufrufenden Code zurückgegeben wird.  Der Konstruktor kann als Wrapper um ein Memset implementiert werden, um einen bestimmten Speicherbereich auf Null zu setzen. </li></ul><br><p>  Wir sehen die Verfügbarkeit dieser Optionen als günstige Bedingungen für die Kernel-Sicherheit, da sie Entwickler dazu ermutigen, fundierte Entscheidungen zu treffen und einfach mit vorhandenen Speicherzuweisungsfunktionen arbeiten zu können, anstatt nach jeder Zuweisung von dynamischem Speicher zusätzliche Memset-Aufrufe hinzuzufügen. </p><br><h4 id="massivy-fiksirovannogo-razmera">  Arrays mit fester Größe </h4><br><p>  Der Zugriff auf eine Reihe von Betriebssystemressourcen kann über deren Testnamen erfolgen.  Die Vielfalt der benannten Ressourcen in Windows ist sehr groß, zum Beispiel: Dateien und Verzeichnisse, Schlüssel und Werte von Registrierungsschlüsseln, Windows, Schriftarten und vieles mehr.  Für einige von ihnen ist die Namenslänge begrenzt und wird durch eine Konstante ausgedrückt, z. B. MAX_PATH (260) oder LF_FACESIZE (32).  In solchen Fällen vereinfachen Kernelentwickler den Code häufig, indem sie die Puffer mit der maximalen Größe deklarieren und als Ganzes kopieren (z. B. mit dem Schlüsselwort sizeof), anstatt nur mit dem entsprechenden Teil der Zeile zu arbeiten.  Dies ist besonders nützlich, wenn Zeichenfolgen Mitglieder größerer Strukturen sind.  Solche Objekte können frei im Speicher verschoben werden, ohne sich um die Verwaltung von Zeigern auf den dynamischen Speicher kümmern zu müssen. </p><br><p>  Wie zu erwarten ist, werden große Puffer selten vollständig verwendet, und der verbleibende Speicherplatz wird häufig nicht geleert.  Dies kann zu besonders starken Lecks langer zusammenhängender Bereiche des Kernelspeichers führen.  In dem Beispiel in Listing 5 verwendet der Systemaufruf die Funktion RtlGetSystemPath, um den Systempfad in den lokalen Puffer zu laden. Wenn der Aufruf erfolgreich ist, werden alle 260 Bytes unabhängig von der tatsächlichen Leitungslänge an den Aufrufer übergeben. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS NTAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NtGetSystemPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PCHAR OutputPath)</span></span></span><span class="hljs-function"> </span></span>{ CHAR SystemPath[MAX_PATH]; NTSTATUS Status; Status = RtlGetSystemPath(SystemPath, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(SystemPath)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NT_SUCCESS(Status)) { RtlCopyMemory(OutputPath, SystemPath, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(SystemPath)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status; }</code> </pre> <br><p>  <em>Listing 5: Speichererweiterung durch teilweise Initialisierung des Zeichenfolgenpuffers.</em> </p><br><p>  Der in diesem Beispiel in den Benutzerbereich zurückkopierte Speicherbereich ist in Abbildung 4 dargestellt. </p><br><p><img src="https://habrastorage.org/webt/ki/8j/5z/ki8j5zyo73i5k4o12grlolwsrhk.png" alt="Abbildung 4: Teilweise initialisierter String-Pufferspeicher"><br>  <em>Abbildung 4: Speicher eines teilweise initialisierten Zeilenpuffers.</em> </p><br><p>  Eine sichere Implementierung sollte nur den angeforderten Pfad und nicht den gesamten für die Speicherung verwendeten Puffer zurückgeben.  Dieses Beispiel zeigt einmal mehr, wie die Schätzung der Datengröße mit dem Operator sizeof (der als Parameter für RtlCopyMemory verwendet wird) in Bezug auf die tatsächliche Datenmenge, die der Kernel an den Benutzerbereich übergeben muss, völlig falsch sein kann. </p><br><h4 id="proizvolnyy-razmer-vyhodnyh-dannyh-sistemnogo-vyzova">  Beliebige Ausgabegröße für Systemaufrufe </h4><br><p>  Die meisten Systemaufrufe akzeptieren Zeiger auf die Ausgabe im Benutzermodus zusammen mit der Größe des Puffers.  In den meisten Fällen sollten Größeninformationen nur verwendet werden, um festzustellen, ob der bereitgestellte Puffer ausreicht, um Systemaufrufausgaben zu empfangen.  Verwenden Sie nicht die gesamte Größe des bereitgestellten Ausgabepuffers, um die zu kopierende Speichermenge anzugeben.  Es treten jedoch Fälle auf, in denen der Kernel versucht, jedes Byte des Ausgabepuffers des Benutzers zu verwenden, ohne die Menge der tatsächlich zu kopierenden Daten zu berücksichtigen.  Ein Beispiel für dieses Verhalten ist in Listing 6 dargestellt. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS NTAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NtMagicValues</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LPDWORD OutputPointer, DWORD OutputLength)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (OutputLength &lt; <span class="hljs-number"><span class="hljs-number">3</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(DWORD)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> STATUS_BUFFER_TOO_SMALL; } LPDWORD KernelBuffer = Allocate(OutputLength); KernelBuffer[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0xdeadbeef</span></span>; KernelBuffer[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">0xbadc0ffe</span></span>; KernelBuffer[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">0xcafed00d</span></span>; RtlCopyMemory(OutputPointer, KernelBuffer, OutputLength); Free(KernelBuffer); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> STATUS_SUCCESS; }</code> </pre> <br><p>  <em>Listing 6: Speichererweiterung um einen Ausgabepuffer beliebiger Größe.</em> </p><br><p>  Der Zweck eines Systemaufrufs besteht darin, dem aufrufenden Code drei spezielle 32-Bit-Werte bereitzustellen, die insgesamt 12 Bytes belegen.  Obwohl die Überprüfung der korrekten Puffergröße am Anfang der Funktion korrekt ist, sollte die Verwendung des OutputLength-Arguments dort enden.  In dem Wissen, dass der Ausgabepuffer groß genug ist, um das Ergebnis zu speichern, kann der Kernel 12 Byte Speicher zuweisen, ihn füllen und den Inhalt zurück in den bereitgestellten Benutzermoduspuffer kopieren.  Stattdessen weist ein Systemaufruf einen Poolblock zu (außerdem mit einer benutzergesteuerten Länge) und kopiert den gesamten zugewiesenen Speicher in den Benutzerbereich.  Es stellt sich heraus, dass alle Bytes mit Ausnahme der ersten 12 nicht initialisiert und fälschlicherweise für den Benutzer geöffnet werden, wie in Abbildung 5 dargestellt. </p><br><p><img src="https://habrastorage.org/webt/m7/hy/dj/m7hydjfgkhaqgizxuhr2xcmv8jw.png" alt="Abbildung 5: Beliebiger Pufferspeicher"><br>  <em>Abbildung 5: Pufferspeicher beliebiger Größe.</em> </p><br><p>  Das in diesem Abschnitt beschriebene Schema ist besonders für Windows üblich.  Ein ähnlicher Fehler kann einem Angreifer ein äußerst nützliches Grundelement für die Speichererweiterung liefern: </p><br><ul><li> ,      Windows,                  .            ,       . </li><li>              .   ,     ,                .      ,    (   —  )  . </li></ul><br><p>  ,        .      ,     ,       . </p><br><h2 id="faktory-sposobstvuyuschie-poyavleniyu-oshibok-raskrytiya-pamyati"> ,      </h2><br><p>     ,           .         ,          Windows    . </p><br><p> <strong>  </strong> <br>  ,       ,   .        ,      : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AddressSanitizer</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PageHeap</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Special Pool</a> .  , ,   -          .         ,         .   ,         ,       ,           ,        ,       .       <em></em>     ,      (   ). </p><br><p>  ,             ,  ,       .               ,                  . </p><br><p> <strong>,    API</strong> <br>           API,   Windows (Win32/User32 API). API         ,   ,          ,     .     ,  ,        , ,      .              <em></em>  . </p><br><h2 id="znachimost-i-vliyanie-na-bezopasnost-sistemy">       </h2><br><p>   ,             .          ,            .      ,     <em></em>       ,       ,      .        ,         ,    . </p><br><p>  ,      ,          .     ,       KASLR (Kernel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Address Space Layout Randomization</a> ),                .  :   Windows,    Hacking Team   2015  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Juan Vazquez. Revisiting an Info Leak</a> )         (derandomize)     win32k.sys,       . ,         Matt Tait'  Google Project Zero ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kernel-mode ASLR leak via uninitialized memory returned to usermode by NtGdiGetTextMetrics</a> )     MS15-080 (CVE-2015-2433). </p><br><p> <strong></strong> <br>       (/)   ,      ,      (control ﬂow),  :   ,   ,   ,   ,   StackGuard  Linux  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">/GS  Windows</a> .    ,             .        ,   ,            . </p><br><p> <strong>  (/)</strong> <br>    (/)    ,    ,      ,    :  ,   ,  ,     .               ,     ,      .         .  ,         ( ,    )   ,  ,      . </p><br><h2 id="drugie-suschestvuyuschie-issledovaniya">    </h2><br><p><img src="https://habrastorage.org/webt/wp/ky/ap/wpkyap5uiyz52hrghshrxxve1v0.jpeg" alt="#2"></p><br><h4 id="microsoft-windows"> Microsoft Windows </h4><br><p> <strong></strong> <br>  2015            Windows.   2015  Matt Tait           win32k!NtGdiGetTextMetrics.          Windows   Hacking Team.   ,      ,       ,    0-day       Windows. </p><br><p>    2015, WanderingGlitch (HP Zero Day Initiative)          ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Acknowledgments – 2015</a> ).           Ruxcon 2016 (  )    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Leaking Windows Kernel Pointers"</a> . </p><br><p>  ,   2017 fanxiaocao  pjf  IceSword Lab (Qihoo 360)   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Automatically Discovering Windows Kernel Information Leak Vulnerabilities"</a> ,    ,      14   2017  (8      ).        Bochspwn Reloaded,             ,            .        VMware     (Bochs)         .   ,  Bochspwn Reloaded,                . </p><br><p>         ,  ,    2010-2011          ,     win32k: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Challenge: On 32bit Windows7, explain where the upper 16bits of eax come from after a call to NtUserRegisterClassExWOW()"</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Subtle information disclosure in WIN32K.SYS syscall return values"</a> .          Windows 8,   2015  Matt Tait ,           : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Google Project Zero Bug Tracker</a> . </p><br><p> <strong></strong> <br>       (   ),  ,    2017   - Windows        -,   : Joseph Bialek — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Anyone notice my change to the Windows IO Manager to generically kill a class of info disclosure? BuﬀeredIO output buﬀer is always zero'd"</a> .      ,  IOCTL-          . </p><br><p>        ,   Visual Studio 15.5   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">POD-</a> ,       "= {0}",   .       ,      padding- ()   . </p><br><h4 id="linux"> Linux </h4><br><p>    Windows,   Linux        ,         2010 .        ,             (  )   (    ) .  ,        Windows  Linux         ,        — ,    . </p><br><p> <strong></strong> <br>    ,   Linux       .   "Linux kernel vulnerabilities: State-of-the-art defenses and open problems"   2010    2011   28    .   2017-  "Securing software systems by preventing information leaks" Lu K.    59  ,    2013-   2016-.          . : Rosenberg  Oberheide    25 ,     Linux  2009-2010 ,     .          Linux c <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">grsecurity</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PaX-hardened</a> . Vasiliy Kulikov   25   2010-2011 ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   Coccinelle</a> .  , Mathias Krause <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   21      2013 </a>   50      . </p><br><p>    ,      ,           Linux.     —   -Wuninitialized (  gcc,   LLVM),          .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  kmemcheck</a> ,      Valgrind'   .        ,        .         ,         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">KernelAddressSANitizer</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">KernelMemorySANitizer</a> .      KMSAN    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">syzkaller</a> (   ) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> 19    </a> ,        . </p><br><p>               Linux.  2014 — 2016  Peir´o      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Coccinelle</a>     ,      Linux  3.12: "Detecting stack based kernel information leaks" International Joint Conference SOCO14-CISIS14-ICEUTE14, pages 321–331 (Springer, 2014)  "An analysis on the impact and detection of kernel stack infoleaks" Logic Journal of the IGPL.         ,          .  2016- Lu       UniSan —   ,    ,                 :   ,   .            ,        20%     (350   1800),      19     Linux  Android. </p><br><p>             —    (multi-variant program execution),            ,      .           ,             .     ,  KASLR,   -,         .         ,  2006    DieHard: probabilistic memory safety for unsafe languages,   2017  — BUDDY: Securing software systems by preventing information leaks.     John North   "Identifying Memory Address Disclosures" 2015- . ,  SafeInit (Comprehensive and Practical Mitigation of Uninitialized Read Vulnerabilities)  ,          ,            .       , ,   ,        Linux. </p><br><p> <strong></strong> <br>                  ,   .      ,       :     ,        .     ,  , -    ,             .                   . </p><br><p>        CONFIG_PAGE_POISONING  CONFIG_DEBUG_SLAB,       -.       -,      .        , ,  ,       Linux. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">grsecurity</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PaX</a>    .  ,   PAX_MEMORY_SANITIZE   ,         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">slab</a> ,    (        —   ).  ,  PAX_MEMORY_STRUCTLEAK     ,    (  ),       .         padding- (),          100% .  ,      — PAX_MEMORY_STACKLEAK,            .      ,      ,        .       (Kernel Self Protection Project)   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> STACKLEAK</a>   . </p><br><p>               Linux: </p><br><div class="spoiler"> <b class="spoiler_title">Secure deallocation, Chow  , 2005</b> <div class="spoiler_text"><p> Chow, Jim and Pfaﬀ, Ben and Garﬁnkel, Tal and Rosenblum, Mendel. Shredding Your Garbage: Reducing Data Lifetime Through Secure Deallocation. In USENIX Security Symposium, pages 22–22, 2005. </p></div></div><br><p>  ,       ,          ( )  .         Linux     . </p><br><div class="spoiler"> <b class="spoiler_title">Split Kernel, Kurmus  Zippel, 2014</b> <div class="spoiler_text"><p> Kurmus, Anil and Zippel, Robby. A tale of two kernels: Towards ending kernel hardening wars with split kernel. In Proceedings of the 2014 ACM SIGSAC Conference on Computer and Communications Security, pages 1366–1377. ACM, 2014. </p></div></div><br><p>      ,           . </p><br><div class="spoiler"> <b class="spoiler_title">SafeInit, Milburn  , 2017</b> <div class="spoiler_text"><p> Milburn, Alyssa and Bos, Herbert and Giuﬀrida, Cristiano. SafeInit: Comprehensive and Practical Mitigation of Uninitialized Read Vulnerabilities. In Proceedings of the 2017 Annual Network and Distributed System Security Symposium (NDSS)(San Diego, CA), 2017. </p></div></div><br><p>         ,      ,         . </p><br><div class="spoiler"> <b class="spoiler_title">UniSan, Lu  , 2016</b> <div class="spoiler_text"><p> Lu, Kangjie and Song, Chengyu and Kim, Taesoo and Lee, Wenke. UniSan: Proactive kernel memory initialization to eliminate data leakages. In Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security, pages 920–932. ACM, 2016. </p></div></div><br><p>    SafeInit         ,  ,       ,      ,      . </p><br><p>       ,  Linux             . </p><br><h2 id="vmesto-epiloga-ot-perevodchika">   ( ) </h2><br><p>        ,    ,          (      ).  :  (),     , ,    ,   ( - )     .   ,          . , ,        . </p><br><p>     ,             : </p><br><ul><li> Bochspwn Reloaded – detection with software x86 emulation </li><li> Windows bug reproduction techniques </li><li> Alternative detection methods </li><li> Other data sinks </li><li> Future work </li><li> Other system instrumentation schemes </li></ul><br><p>  ,     :)          ,       . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de415685/">https://habr.com/ru/post/de415685/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de415675/index.html">PostgreSQL News Digest. Ausgabe Nummer 8</a></li>
<li><a href="../de415677/index.html">Wachsende Städte haben Schwierigkeiten, die Massen von Menschen vertikal und an der Oberfläche zu bewegen</a></li>
<li><a href="../de415679/index.html">Warum reiche Kinder in einem Marshmallow-Experiment gute Ergebnisse zeigen</a></li>
<li><a href="../de415681/index.html">Die Geschichte der Entstehung des Gebärdensprachdolmetschers</a></li>
<li><a href="../de415683/index.html">Versuchen Sie sich in der Q # -Programmierung</a></li>
<li><a href="../de415687/index.html">Fintech Digest: Die Zentralbank verpflichtet die Banken, Client-Geräte zu überprüfen, von denen Geld überwiesen wird</a></li>
<li><a href="../de415689/index.html">Wir spielen Seeschlacht auf BGP</a></li>
<li><a href="../de415691/index.html">Vergleich der Austauschsortierung</a></li>
<li><a href="../de415693/index.html">Oumuamua. Angekommen, ratlos, flog weg (und versprach nicht zurückzukehren). Und eines Tages war es wieder einmal rätselhaft</a></li>
<li><a href="../de415695/index.html">Google gab zu, dass es auch GitHub kaufen wollte</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>