<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôÜüèº üë©üèæ‚Äçüéì üì∫ Speicheroffenlegung des Kernels in modernen Betriebssystemen üèß üìº ‚ûø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Unter dem Cutter befindet sich die √úbersetzung des ersten Teils des Dokuments Detecting Kernel Memory Disclosure mit x86-Emulation und Taint Tracking ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Speicheroffenlegung des Kernels in modernen Betriebssystemen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415685/"><p> Unter dem Cutter befindet sich die √úbersetzung des <strong>ersten Teils des</strong> Dokuments <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Detecting Kernel Memory Disclosure mit x86-Emulation und Taint Tracking</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikelprojekt Null</a> ) von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mateusz Jurczyk</a> . </p><br><p>  Im √ºbersetzten Teil des Dokuments: </p><br><ul><li>  Besonderheiten der C-Programmiersprache (als Teil des Speichererweiterungsproblems) </li><li>  die Besonderheiten des Betriebs der Windows- und Linux-Kernel (als Teil des Speichererweiterungsproblems) </li><li>  Bedeutung der Offenlegung des Kernelspeichers und Auswirkungen auf die Betriebssystemsicherheit </li><li>  vorhandene Verfahren und Techniken zum Erkennen und Gegensteuern der Offenbarung des Kernelspeichers </li></ul><br><p>  Obwohl sich das Dokument auf die Kommunikationsmechanismen zwischen dem privilegierten Kernel des Betriebssystems und Benutzeranwendungen konzentriert, kann das Wesentliche des Problems f√ºr jede Daten√ºbertragung zwischen verschiedenen Sicherheitsdom√§nen verallgemeinert werden: Der Hypervisor ist der Gastcomputer, der privilegierte Systemdienst (Daemon) ist die GUI-Anwendung, der Netzwerkclient ist der Server usw. . </p><br><p><img src="https://habrastorage.org/webt/ne/uy/1q/neuy1q8npc2ba-y3vcaycx9kqxe.jpeg" alt="KDPV"></p><a name="habracut"></a><br><h2 id="vvedenie">  Einf√ºhrung </h2><br><p>  Eine der Aufgaben moderner Betriebssysteme besteht darin, die Trennung von Berechtigungen zwischen Benutzeranwendungen und dem Kernel des Betriebssystems sicherzustellen.  Dies schlie√üt zum einen die Tatsache ein, dass der Einfluss jedes Programms auf die Laufzeit durch eine bestimmte Sicherheitsrichtlinie begrenzt werden sollte, und zum anderen, dass Programme nur auf die Informationen zugreifen k√∂nnen, die sie lesen d√ºrfen.  Die zweite ist angesichts der Eigenschaften der C-Sprache (der Hauptprogrammiersprache, die bei der Entwicklung des Kernels verwendet wird) schwierig bereitzustellen, was es √§u√üerst schwierig macht, Daten sicher zwischen verschiedenen Sicherheitsdom√§nen zu √ºbertragen. </p><br><p>  Moderne Betriebssysteme, die auf x86 / x86-64-Plattformen ausgef√ºhrt werden, sind multithreaded und verwenden ein Client-Server-Modell, in dem Anwendungen (Clients) im Benutzermodus unabh√§ngig ausgef√ºhrt werden und den Betriebssystemkern (Server) aufrufen, um mit einer vom System verwalteten Ressource zu arbeiten.  Der Mechanismus, der vom Benutzermoduscode ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ring 3</a> ) zum Aufrufen eines vordefinierten Satzes von Kernelfunktionen (Ring 0) verwendet wird, wird als Systemaufrufe oder (kurz) Systemaufrufe bezeichnet.  Ein typischer Systemaufruf ist in Abbildung 1 dargestellt: <br><img src="https://habrastorage.org/webt/dh/p3/hr/dhp3hruaqmh7onhd0mweycvv4bg.png" alt="Abbildung 1: Systemaufruf"><br>  <em>Abbildung 1: Lebenszyklus eines Systemaufrufs</em> </p><br><p>  Es ist sehr wichtig zu vermeiden, dass versehentlich Kernelspeicherinhalte verloren gehen, wenn Sie mit Programmen im Benutzermodus interagieren.  Es besteht ein erhebliches Risiko, vertrauliche Kerneldaten offenzulegen.  Daten k√∂nnen implizit in den Ausgabeparametern sicherer (aus anderer Sicht) Systemaufrufe √ºbertragen werden. </p><br><p>  Die Offenlegung des privilegierten Systemspeichers erfolgt, wenn der Betriebssystemkern einen Speicherbereich zur√ºckgibt, der gr√∂√üer (√ºbersch√ºssig) ist als zum Speichern der entsprechenden Informationen (darin enthalten) erforderlich ist.  Oft enthalten redundante Bytes Daten, die in einem anderen Kontext gef√ºllt wurden, und dann wurde der Speicher nicht vorinitialisiert, was die Verbreitung von Informationen in neuen Datenstrukturen verhindern w√ºrde. </p><br><h2 id="specifika-yazyka-programmirovaniya-c">  C Besonderheiten der Programmiersprache </h2><br><p>  In diesem Abschnitt werden einige Aspekte der C-Sprache behandelt, die f√ºr das Problem der Speichererweiterung am wichtigsten sind. </p><br><h4 id="neopredelennoe-sostoyanie-neinicializirovannyh-peremennyh">  Undefinierter Status nicht initialisierter Variablen </h4><br><p>  Einzelne Variablen einfacher Typen (wie char oder int) sowie Mitglieder von Datenstrukturen (Arrays, Strukturen und Gewerkschaften) bleiben bis zur ersten Initialisierung in einem undefinierten Zustand (unabh√§ngig davon, ob sie auf dem Stapel oder auf dem Heap abgelegt werden).  Relevante Zitate aus der C11-Spezifikation (ISO / IEC 9899: 201x Ausschussentwurf N1570, April 2011): </p><br><blockquote>  6.7.9 Initialisierung <br>  ... <br>  10 Wenn ein Objekt mit automatischer Speicherdauer nicht explizit initialisiert wird, ist <u>sein Wert unbestimmt</u> . <br><br>  7.22.3.4 Die Malloc-Funktion <br>  ... <br>  2 Die Malloc-Funktion reserviert Platz f√ºr ein Objekt, dessen Gr√∂√üe durch die Gr√∂√üe angegeben wird und <u>dessen Wert unbestimmt ist</u> . <br><br>  7.22.3.5 Die Realloc-Funktion <br>  ... <br>  2 Die Realloc-Funktion gibt die Zuordnung des alten Objekts frei, auf das ptr zeigt, und gibt einen Zeiger auf ein neues Objekt zur√ºck, dessen Gr√∂√üe durch die Gr√∂√üe angegeben ist.  Der Inhalt des neuen Objekts muss derselbe sein wie der des alten Objekts vor der Freigabe, bis auf die geringere der neuen und alten Gr√∂√üen.  Alle Bytes im neuen Objekt, die √ºber die Gr√∂√üe des alten Objekts hinausgehen, <u>haben unbestimmte Werte</u> . </blockquote><p>  Der Teil, der f√ºr Systemcode gilt, ist f√ºr Objekte auf dem Stapel am relevantesten, da der Betriebssystemkern normalerweise dynamische Zuordnungsschnittstellen mit eigener Semantik hat (nicht unbedingt kompatibel mit der Standard-C-Bibliothek, wie sp√§ter beschrieben wird). </p><br><p>  Soweit wir wissen, erstellt keiner der drei beliebtesten C-Compiler f√ºr Windows und Linux (Microsoft C / C ++ - Compiler, gcc, LLVM) Code, der vom Programmierer nicht initialisierte Variablen auf dem Stack im Release-Build-Modus (oder einem gleichwertigen) vorinitialisiert.  Es gibt Compileroptionen zum Markieren von Stapelrahmen mit speziellen Byte-Markern (z. B. / RTCs in Microsoft Visual Studio), die jedoch aus Leistungsgr√ºnden in Release-Builds nicht verwendet werden.  Infolgedessen <em>erben</em> nicht initialisierte Variablen auf dem Stapel <em>die</em> alten Werte der entsprechenden Speicherbereiche. </p><br><p>  Stellen Sie sich ein Beispiel f√ºr eine Standardimplementierung eines fiktiven Windows-Systemaufrufs vor, bei dem eine Eingabe-Ganzzahl mit zwei multipliziert wird und das Ergebnis der Multiplikation zur√ºckgegeben wird (Listing 1).  Im Sonderfall (InputValue == 0) bleibt die Variable OutputValue nat√ºrlich nicht initialisiert und wird zur√ºck auf den Client kopiert.  Mit diesem Fehler k√∂nnen Sie f√ºr jeden Aufruf vier Byte Kernel-Stack-Speicher √∂ffnen. </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS NTAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NtMultiplyByTwo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DWORD InputValue, LPDWORD OutputPointer)</span></span></span><span class="hljs-function"> </span></span>{ DWORD OutputValue; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (InputValue != <span class="hljs-number"><span class="hljs-number">0</span></span>) { OutputValue = InputValue * <span class="hljs-number"><span class="hljs-number">2</span></span>; } *OutputPointer = OutputValue; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> STATUS_SUCCESS; }</code> </pre> <br><p>  <em>Codeauflistung 1: Speichererweiterung durch eine nicht initialisierte lokale Variable.</em> </p><br><p>  Lecks durch eine nicht initialisierte lokale Variable sind in der Praxis nicht sehr h√§ufig: Einerseits erkennen und warnen moderne Compiler h√§ufig solche Probleme, andererseits sind solche Lecks Funktionsfehler, die w√§hrend der Entwicklung oder des Testens erkannt werden k√∂nnen.  Das zweite Beispiel (in Listing 2) zeigt jedoch, dass ein Leck auch durch das Strukturfeld auftreten kann. </p><br><p>  In diesem Fall wird das reservierte Strukturfeld im Code nie explizit verwendet, sondern dennoch in den Benutzermodus zur√ºckkopiert und stellt daher auch vier Byte Kernelspeicher f√ºr den aufrufenden Code bereit.  Dieses Beispiel zeigt deutlich, dass das Initialisieren jedes Felds jeder Struktur, die f√ºr alle Zweige der Codeausf√ºhrung an den Client zur√ºckgegeben wird, keine leichte Aufgabe ist.  In vielen F√§llen erscheint eine erzwungene Initialisierung unlogisch, insbesondere wenn dieses Feld keine praktische Rolle spielt.  Es ist jedoch die Tatsache, dass eine nicht initialisierte Variable (oder ein Strukturfeld) auf dem Stapel (oder auf dem Heap) den Inhalt von Daten akzeptiert, die zuvor in diesem Speicherbereich (im Kontext einer anderen Operation) gespeichert wurden, das Herzst√ºck des Kernel-Speichererweiterungsproblems. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SYSCALL_OUTPUT</span></span></span><span class="hljs-class"> {</span></span> DWORD Sum; DWORD Product; DWORD Reserved; } SYSCALL_OUTPUT, *PSYSCALL_OUTPUT; <span class="hljs-function"><span class="hljs-function">NTSTATUS NTAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NtArithOperations</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( DWORD InputValue, PSYSCALL_OUTPUT OutputPointer )</span></span></span><span class="hljs-function"> </span></span>{ SYSCALL_OUTPUT OutputStruct; OutputStruct.Sum = InputValue + <span class="hljs-number"><span class="hljs-number">2</span></span>; OutputStruct.Product = InputValue * <span class="hljs-number"><span class="hljs-number">2</span></span>; RtlCopyMemory(OutputPointer, &amp;OutputStruct, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(SYSCALL_OUTPUT)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> STATUS_SUCCESS; }</code> </pre> <br><p>  <em>Listing 2: Speichererweiterung durch ein reserviertes Strukturfeld.</em> </p><br><h4 id="vyravnivanie-struktur-i-zapolnyayuschie-padding-bayty">  Ausrichtung von Strukturen und F√ºllbytes </h4><br><p>  Das Initialisieren aller Felder der Ausgabestruktur ist ein guter Anfang, um eine Speichererweiterung zu vermeiden.  Dies reicht jedoch nicht aus, um sicherzustellen, dass in der Darstellung auf niedriger Ebene keine nicht initialisierten Bytes vorhanden sind.  Kehren wir zur C11-Spezifikation zur√ºck: </p><br><blockquote>  6.5.3.4 Die Gr√∂√üe und Ausrichtung der Operatoren <br>  ... <br>  4 [...] Bei Anwendung auf einen Operanden mit Struktur- oder Vereinigungstyp ergibt sich die Gesamtzahl der Bytes in einem solchen Objekt, <u>einschlie√ülich interner und nachfolgender Auff√ºllung</u> . <br><br>  6.2.8 Ausrichtung von Objekten <br>  1 F√ºr vollst√§ndige Objekttypen gelten Ausrichtungsanforderungen, die <u>die Adressen einschr√§nken, an denen Objekte dieses Typs zugewiesen werden k√∂nnen</u> .  Eine Ausrichtung ist ein implementierungsdefinierter integrierter ganzzahliger Wert, der die Anzahl der Bytes zwischen aufeinanderfolgenden Adressen darstellt, an denen ein bestimmtes Objekt zugewiesen werden kann.  [...] <br><br>  6.7.2.1 Struktur- und Gewerkschaftsspezifizierer <br>  ... <br>  17 <u>Am Ende einer Struktur oder Vereinigung befindet sich m√∂glicherweise eine unbenannte Polsterung</u> . </blockquote><p>  Das hei√üt, C-Sprach-Compiler f√ºr x86 (-64) -Architekturen verwenden die nat√ºrliche Ausrichtung von Feldern von Strukturen (mit einem primitiven Typ): Jedes dieser Felder wird durch N Bytes ausgerichtet, wobei N die Gr√∂√üe des Feldes ist.  Dar√ºber hinaus werden ganze Strukturen und Verkn√ºpfungen auch ausgerichtet, wenn sie in einem Array deklariert werden, und die Anforderung f√ºr die Ausrichtung verschachtelter Felder ist erf√ºllt.  Um die Ausrichtung sicherzustellen, werden bei Bedarf implizite F√ºllbytes in Strukturen eingef√ºgt.  Obwohl im Quellcode nicht direkt auf sie zugegriffen werden kann, erben diese Bytes auch alte Werte aus Speicherbereichen und k√∂nnen Informationen in den Benutzermodus √ºbertragen. </p><br><p>  Im Beispiel in Listing 3 wird die Struktur SYSCALL_OUTPUT an den aufrufenden Code zur√ºckgegeben.  Es enth√§lt 4- und 8-Byte-Felder, die durch 4 F√ºllbytes getrennt sind, damit die Adresse des LargeSum-Feldes ein Vielfaches von 8 wird.  Trotz der Tatsache, dass beide Felder korrekt initialisiert wurden, werden F√ºllbytes nicht explizit gesetzt, was wiederum zur Erweiterung des Kernel-Stack-Speichers f√ºhrt.  Die spezifische Position der Struktur im Speicher ist in Abbildung 2 dargestellt. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SYSCALL_OUTPUT</span></span></span><span class="hljs-class"> {</span></span> DWORD Sum; QWORD LargeSum; } SYSCALL_OUTPUT, *PSYSCALL_OUTPUT; <span class="hljs-function"><span class="hljs-function">NTSTATUS NTAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NtSmallSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( DWORD InputValue, PSYSCALL_OUTPUT OutputPointer )</span></span></span><span class="hljs-function"> </span></span>{ SYSCALL_OUTPUT OutputStruct; OutputStruct.Sum = InputValue + <span class="hljs-number"><span class="hljs-number">2</span></span>; OutputStruct.LargeSum = <span class="hljs-number"><span class="hljs-number">0</span></span>; RtlCopyMemory(OutputPointer, &amp;OutputStruct, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(SYSCALL_OUTPUT)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> STATUS_SUCCESS; }</code> </pre> <br><p>  <em>Listing 3: Speichererweiterung durch Ausrichten der Struktur.</em> </p><br><p><img src="https://habrastorage.org/webt/pw/i1/1a/pwi11anmkjf_ujlkogv2bjmbsuo.png" alt="Abbildung 2: Struktur ausrichten"><br>  Abbildung 2: Darstellung der Struktur im Speicher unter Ber√ºcksichtigung der Ausrichtung. </p><br><p>  Lecks durch Alignments sind relativ h√§ufig, da viele Ausgabeparameter von Systemaufrufen durch Strukturen dargestellt werden.  Das Problem ist besonders akut f√ºr 64-Bit-Plattformen, bei denen die Gr√∂√üe von Zeigern, size_t und √§hnlichen Typen von 4 auf 8 Bytes zunimmt, was zum Auftreten von Auff√ºllungen f√ºhrt, die zum Ausrichten der Felder solcher Strukturen erforderlich sind. </p><br><p>  Da Auff√ºllbytes im Quellcode nicht adressiert werden k√∂nnen, muss ein Memset oder eine √§hnliche Funktion verwendet werden, um den gesamten Speicherbereich der Struktur zur√ºckzusetzen, bevor eines ihrer Felder initialisiert und in den Benutzermodus kopiert wird, zum Beispiel: </p><br><pre> <code class="cpp hljs"> <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;OutputStruct, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(OutputStruct));</code> </pre> <br><p>  Seacord RC stellt jedoch in seinem Buch "The CERT C Coding Standard, 2. Auflage: 98 Regeln f√ºr die Entwicklung sicherer, zuverl√§ssiger und sicherer Systeme. Addison-Wesley Professional" 2014 fest, dass dies keine ideale L√∂sung ist, da Bytes aufgef√ºllt werden ) kann nach dem Aufrufen von memset beispielsweise als Nebeneffekt von Operationen mit benachbarten Feldern immer noch <em>heruntergefahren</em> werden.  Bedenken k√∂nnen durch die folgende Aussage in Spezifikation C begr√ºndet werden: </p><br><blockquote>  6.2.6 Darstellungen von Typen <br>  6.2.6.1 Allgemeines <br>  ... <br>  6 <u>Wenn ein Wert in einem Objekt vom Typ Struktur oder Vereinigung gespeichert wird</u> , einschlie√ülich in einem <u>Elementobjekt</u> , nehmen die Bytes der Objektdarstellung, <u>die Auff√ºllbytes</u> entsprechen, <u>nicht angegebene Werte an</u> .  [...] </blockquote><p>  In der Praxis hat jedoch keiner der von uns getesteten C-Compiler au√üerhalb der Speicherbereiche explizit deklarierter Felder gelesen oder geschrieben.  Es scheint, dass diese Meinung von Entwicklern von Betriebssystemen geteilt wird, die memset verwenden. </p><br><h4 id="obedineniya-unions-i-polya-raznogo-razmera">  Gewerkschaften und Felder unterschiedlicher Gr√∂√üe </h4><br><p>  Joins sind ein weiteres komplexes C-Sprachkonstrukt im Zusammenhang mit der Kommunikation mit weniger privilegiertem Aufrufcode.  √úberlegen Sie, wie die C11-Spezifikation die Darstellung von Gewerkschaften im Speicher beschreibt: </p><br><blockquote>  6.2.5 Typen <br>  ... <br>  20 Aus den Objekt- und Funktionstypen k√∂nnen wie folgt beliebig viele abgeleitete Typen erstellt werden: [...] <u>Ein Vereinigungstyp beschreibt eine √ºberlappende nicht leere Menge von Elementobjekten</u> , von denen jedes einen optional angegebenen Namen und m√∂glicherweise einen unterschiedlichen Typ hat. <br><br>  6.7.2.1 Struktur- und Gewerkschaftsspezifizierer <br>  ... <br>  6 Wie in 6.2.5 erl√§utert, ist eine Struktur ein Typ, der aus einer Folge von Elementen besteht, deren Speicher in einer geordneten Reihenfolge zugeordnet ist, und <u>eine Vereinigung ist ein Typ, der aus einer Folge von Mitgliedern besteht, deren Speicher sich √ºberlappen</u> . <br>  ... <br>  16 <u>Die Gr√∂√üe einer Gewerkschaft reicht aus, um das gr√∂√üte ihrer Mitglieder aufzunehmen</u> .  Der Wert von h√∂chstens einem der Mitglieder kann jederzeit in einem Gewerkschaftsobjekt gespeichert werden. </blockquote><p>  Das Problem ist, dass, wenn die Vereinigung aus mehreren Feldern unterschiedlicher Gr√∂√üe besteht und nur ein Feld kleinerer Gr√∂√üe explizit initialisiert wird, die verbleibenden Bytes, die zur Aufnahme gro√üer Felder zugewiesen sind, nicht initialisiert bleiben.  Schauen wir uns ein Beispiel f√ºr einen hypothetischen Systemaufruf-Handler an, der in Listing 4 gezeigt ist, zusammen mit der in Abbildung 3 gezeigten SYSCALL_OUTPUT-Zuordnungsspeicherzuordnung. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> _SYSCALL_OUTPUT { DWORD Sum; QWORD LargeSum; } SYSCALL_OUTPUT, *PSYSCALL_OUTPUT; <span class="hljs-function"><span class="hljs-function">NTSTATUS NTAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NtSmallSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( DWORD InputValue, PSYSCALL_OUTPUT OutputPointer )</span></span></span><span class="hljs-function"> </span></span>{ SYSCALL_OUTPUT OutputStruct; OutputStruct.Sum = InputValue + <span class="hljs-number"><span class="hljs-number">2</span></span>; RtlCopyMemory(OutputPointer, &amp;OutputStruct, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(SYSCALL_OUTPUT)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> STATUS_SUCCESS; }</code> </pre> <br><p>  <em>Codeauflistung 4: Erweitern des Speichers durch teilweises Initialisieren einer Union.</em> </p><br><p><img src="https://habrastorage.org/webt/pa/8y/ck/pa8yckhciassiwm9yc19nssczwo.png" alt="Abbildung 3: Ausrichten eines Joins"><br>  <em>Abbildung 3: Darstellung der Vereinigung im Speicher mit Ausrichtung.</em> </p><br><p>  Es stellt sich heraus, dass die Gesamtgr√∂√üe der SYSCALL_OUTPUT-Vereinigung 8 Byte betr√§gt (aufgrund der Gr√∂√üe des gr√∂√üeren LargeSum-Felds).  Die Funktion legt jedoch nur den Wert des kleineren Felds fest, sodass 4 nachfolgende Bytes nicht initialisiert werden, was anschlie√üend zu einem Leck in der Clientanwendung f√ºhrt. </p><br><p>  Eine sichere Implementierung sollte nur das Feld Summe im Benutzeradressraum festlegen und nicht das gesamte Objekt mit m√∂glicherweise nicht verwendeten Speicherbereichen kopieren.  Eine weitere funktionierende L√∂sung besteht darin, die Memset-Funktion aufzurufen, um eine Kopie der Union im Kernelspeicher aufzuheben, bevor eines ihrer Felder festgelegt und in den Benutzermodus zur√ºck√ºberwiesen wird. </p><br><h4 id="nebezopasnyy-sizeof">  Unsichere Gr√∂√üe von </h4><br><p>  Wie in den beiden vorherigen Abschnitten gezeigt, kann die Verwendung des Operators sizeof direkt oder indirekt dazu beitragen, den Kernelspeicher freizulegen, wodurch mehr Daten kopiert werden als zuvor initialisiert. </p><br><p>  C verf√ºgt nicht √ºber die erforderliche Vorrichtung, um Daten sicher vom Kernel in den Benutzerbereich zu √ºbertragen - oder allgemeiner zwischen verschiedenen Sicherheitskontexten.  Die Sprache enth√§lt keine Laufzeitmetadaten, die explizit angeben k√∂nnen, welche Bytes in jeder Datenstruktur festgelegt wurden, die f√ºr die Interaktion mit dem Betriebssystemkern verwendet wird.  Infolgedessen liegt die Verantwortung beim Programmierer, der bestimmen muss, welche Teile jedes Objekts an den aufrufenden Code √ºbergeben werden sollen.  Bei korrekter Ausf√ºhrung m√ºssen Sie f√ºr jede in Systemaufrufen verwendete Ausgabestruktur eine separate Funktion zum sicheren Kopieren schreiben.  Dies f√ºhrt wiederum zu einer Aufbl√§hung des Codes, einer Verschlechterung der Lesbarkeit und ist im Allgemeinen eine m√ºhsame und zeitaufw√§ndige Aufgabe. </p><br><p>  Andererseits ist es bequem und einfach, den gesamten Speicherbereich des Kernels mit einem einzigen memcpy-Aufruf und dem Argument sizeof zu kopieren und den Client bestimmen zu lassen, welche Teile der Ausgabe verwendet werden.  Es stellt sich heraus, dass dieser Ansatz heute unter Windows und Linux verwendet wird.  Und wenn ein bestimmter Fall von Informationslecks erkannt wird, wird sofort ein Patch mit einem Memset-Aufruf bereitgestellt und vom Betriebssystemhersteller verteilt.  Leider l√∂st dies das Problem im allgemeinen Fall nicht. </p><br><h2 id="specifika-konkretnyh-os">  Betriebssystemspezifikationen </h2><br><p>  Es gibt bestimmte Kernel-Design-L√∂sungen, Programmiermethoden und Codemuster, die sich darauf auswirken, wie anf√§llig das Betriebssystem f√ºr Schwachstellen bei der Speichererweiterung ist.  Sie werden in den folgenden Unterabschnitten ber√ºcksichtigt. </p><br><h4 id="pereispolzovanie-dinamicheskoy-pamyati">  Dynamischen Speicher wiederverwenden </h4><br><p>  Die aktuellen Allokatoren des dynamischen Speichers (sowohl im Benutzermodus als auch im Kernelmodus) sind stark optimiert, da ihre Leistung einen erheblichen Einfluss auf die Leistung des gesamten Systems hat.  Eine der wichtigsten Optimierungen ist die Wiederverwendung von Speicher: Wenn der entsprechende Speicher freigegeben wird, wird er selten vollst√§ndig verworfen. Stattdessen wird er in der Liste der Regionen gespeichert, die bei der n√§chsten Zuweisung zur√ºckgegeben werden k√∂nnen.  Um CPU-Zyklen zu speichern, werden die Standardspeicherbereiche nicht zwischen Freigabe und neuer Zuweisung gel√∂scht.  Infolgedessen stellt sich heraus, dass zwei nicht verbundene Teile des Kernels f√ºr kurze Zeit mit demselben Speicherbereich arbeiten.  Dies bedeutet, dass Sie durch das Auslaufen des Inhalts des dynamischen Speichers des Kernels die Daten verschiedener Betriebssystemkomponenten anzeigen k√∂nnen. </p><br><p>  In den folgenden Abschnitten geben wir einen kurzen √úberblick √ºber die im Windows- und Linux-Kernel verwendeten Allokatoren und ihre bemerkenswertesten Eigenschaften. </p><br><p>  <strong>Windows</strong> <br>  Die Schl√ºsselfunktion des Windows-Kernel-Pool-Managers ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ExAllocatePoolWithTag</a> , der direkt oder √ºber eine der verf√ºgbaren Shells aufgerufen werden kann: ExAllocatePool {‚àÖ, Ex, WithQuotaTag, WithTagPriority}.  Keine dieser Funktionen l√∂scht den Inhalt des zur√ºckgegebenen Speichers, entweder standardm√§√üig oder √ºber Eingabeflags.  Im Gegenteil, alle haben die folgende Warnung in ihrer jeweiligen MSDN-Dokumentation: </p><br><blockquote>  Hinweis Der von der Funktion zugewiesene Speicher ist nicht initialisiert.  Ein Kernel-Modus-Treiber muss diesen Speicher zuerst auf Null setzen, wenn er f√ºr Benutzer-Modus-Software sichtbar gemacht werden soll (um zu vermeiden, dass potenziell privilegierte Inhalte verloren gehen). </blockquote><p>  Der aufrufende Code kann einen von sechs Haupttypen von Pools ausw√§hlen: NonPagedPool, NonPagedPoolNx, NonPagedPoolSession, NonPagedPoolSessionNx, PagedPool und PagedPoolSession.  Jeder von ihnen hat einen eigenen Bereich im virtuellen Adressraum, und daher k√∂nnen die zugewiesenen Speicherbereiche nur innerhalb desselben Pooltyps wiederverwendet werden.  Die H√§ufigkeit der Wiederverwendung von Speicherelementen ist sehr hoch, und Bereiche mit Nullen werden normalerweise nur zur√ºckgegeben, wenn in den Lookaside-Listen kein geeigneter Datensatz gefunden wird oder die Anforderung so gro√ü ist, dass neue Speicherseiten erforderlich sind.  Mit anderen Worten, es gibt derzeit praktisch keine Faktoren, die die Offenlegung des Poolspeichers in Windows verhindern, und fast jeder dieser Fehler kann verwendet werden, um vertrauliche Daten aus verschiedenen Teilen des Kernels zu verlieren. </p><br><p>  <strong>Linux</strong> <br>  Der Linux-Kernel verf√ºgt √ºber drei Hauptschnittstellen f√ºr die dynamische Zuweisung von Speicher: </p><br><ul><li>  <strong>kmalloc</strong> - eine allgemeine Funktion zum <strong>Zuweisen von</strong> Speicherbl√∂cken beliebiger Gr√∂√üe (kontinuierlich sowohl im virtuellen als auch im physischen Adressraum), verwendet die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Plattenspeicherzuweisung</a> . </li><li>  <strong>kmem_cache_create</strong> und <strong>kmem_cache_alloc</strong> - ein spezialisierter Mechanismus zum <strong>Zuweisen von</strong> Objekten fester Gr√∂√üe (z. B. Strukturen) - verwendet ebenfalls die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zuweisung von Plattenspeicher</a> . </li><li>  <strong>vmalloc</strong> ist eine selten verwendete Zuordnungsfunktion, die Regionen zur√ºckgibt, deren Kontinuit√§t auf der Ebene des physischen Speichers nicht garantiert ist. </li></ul><br><p>  Diese Funktionen (f√ºr sich allein) garantieren nicht, dass die ausgew√§hlten Regionen keine alten (m√∂glicherweise vertraulichen) Daten enthalten, wodurch der Speicher des Kernel-Heaps ge√∂ffnet werden kann.  Es gibt jedoch verschiedene M√∂glichkeiten, wie der aufrufende Code den ung√ºltigen Speicher anfordern kann: </p><br><ul><li>  Die <strong>kmalloc-</strong> Funktion hat ein Analogon von <strong>kzalloc</strong> , das sicherstellt, dass der zur√ºckgegebene Speicher gel√∂scht wird. </li><li>  Das optionale __GFP_ZERO-Flag kann an <strong>kmalloc</strong> , <strong>kmem_cache_alloc</strong> und einige andere Funktionen √ºbergeben werden, um das gleiche Ergebnis zu erzielen. </li><li>  <strong>kmem_cache_create</strong> akzeptiert einen Zeiger auf eine optionale Konstruktorfunktion, die aufgerufen wird, um jedes Objekt vorab zu initialisieren, bevor es an den aufrufenden Code zur√ºckgegeben wird.  Der Konstruktor kann als Wrapper um ein Memset implementiert werden, um einen bestimmten Speicherbereich auf Null zu setzen. </li></ul><br><p>  Wir sehen die Verf√ºgbarkeit dieser Optionen als g√ºnstige Bedingungen f√ºr die Kernel-Sicherheit, da sie Entwickler dazu ermutigen, fundierte Entscheidungen zu treffen und einfach mit vorhandenen Speicherzuweisungsfunktionen arbeiten zu k√∂nnen, anstatt nach jeder Zuweisung von dynamischem Speicher zus√§tzliche Memset-Aufrufe hinzuzuf√ºgen. </p><br><h4 id="massivy-fiksirovannogo-razmera">  Arrays mit fester Gr√∂√üe </h4><br><p>  Der Zugriff auf eine Reihe von Betriebssystemressourcen kann √ºber deren Testnamen erfolgen.  Die Vielfalt der benannten Ressourcen in Windows ist sehr gro√ü, zum Beispiel: Dateien und Verzeichnisse, Schl√ºssel und Werte von Registrierungsschl√ºsseln, Windows, Schriftarten und vieles mehr.  F√ºr einige von ihnen ist die Namensl√§nge begrenzt und wird durch eine Konstante ausgedr√ºckt, z. B. MAX_PATH (260) oder LF_FACESIZE (32).  In solchen F√§llen vereinfachen Kernelentwickler den Code h√§ufig, indem sie die Puffer mit der maximalen Gr√∂√üe deklarieren und als Ganzes kopieren (z. B. mit dem Schl√ºsselwort sizeof), anstatt nur mit dem entsprechenden Teil der Zeile zu arbeiten.  Dies ist besonders n√ºtzlich, wenn Zeichenfolgen Mitglieder gr√∂√üerer Strukturen sind.  Solche Objekte k√∂nnen frei im Speicher verschoben werden, ohne sich um die Verwaltung von Zeigern auf den dynamischen Speicher k√ºmmern zu m√ºssen. </p><br><p>  Wie zu erwarten ist, werden gro√üe Puffer selten vollst√§ndig verwendet, und der verbleibende Speicherplatz wird h√§ufig nicht geleert.  Dies kann zu besonders starken Lecks langer zusammenh√§ngender Bereiche des Kernelspeichers f√ºhren.  In dem Beispiel in Listing 5 verwendet der Systemaufruf die Funktion RtlGetSystemPath, um den Systempfad in den lokalen Puffer zu laden. Wenn der Aufruf erfolgreich ist, werden alle 260 Bytes unabh√§ngig von der tats√§chlichen Leitungsl√§nge an den Aufrufer √ºbergeben. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS NTAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NtGetSystemPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PCHAR OutputPath)</span></span></span><span class="hljs-function"> </span></span>{ CHAR SystemPath[MAX_PATH]; NTSTATUS Status; Status = RtlGetSystemPath(SystemPath, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(SystemPath)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NT_SUCCESS(Status)) { RtlCopyMemory(OutputPath, SystemPath, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(SystemPath)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status; }</code> </pre> <br><p>  <em>Listing 5: Speichererweiterung durch teilweise Initialisierung des Zeichenfolgenpuffers.</em> </p><br><p>  Der in diesem Beispiel in den Benutzerbereich zur√ºckkopierte Speicherbereich ist in Abbildung 4 dargestellt. </p><br><p><img src="https://habrastorage.org/webt/ki/8j/5z/ki8j5zyo73i5k4o12grlolwsrhk.png" alt="Abbildung 4: Teilweise initialisierter String-Pufferspeicher"><br>  <em>Abbildung 4: Speicher eines teilweise initialisierten Zeilenpuffers.</em> </p><br><p>  Eine sichere Implementierung sollte nur den angeforderten Pfad und nicht den gesamten f√ºr die Speicherung verwendeten Puffer zur√ºckgeben.  Dieses Beispiel zeigt einmal mehr, wie die Sch√§tzung der Datengr√∂√üe mit dem Operator sizeof (der als Parameter f√ºr RtlCopyMemory verwendet wird) in Bezug auf die tats√§chliche Datenmenge, die der Kernel an den Benutzerbereich √ºbergeben muss, v√∂llig falsch sein kann. </p><br><h4 id="proizvolnyy-razmer-vyhodnyh-dannyh-sistemnogo-vyzova">  Beliebige Ausgabegr√∂√üe f√ºr Systemaufrufe </h4><br><p>  Die meisten Systemaufrufe akzeptieren Zeiger auf die Ausgabe im Benutzermodus zusammen mit der Gr√∂√üe des Puffers.  In den meisten F√§llen sollten Gr√∂√üeninformationen nur verwendet werden, um festzustellen, ob der bereitgestellte Puffer ausreicht, um Systemaufrufausgaben zu empfangen.  Verwenden Sie nicht die gesamte Gr√∂√üe des bereitgestellten Ausgabepuffers, um die zu kopierende Speichermenge anzugeben.  Es treten jedoch F√§lle auf, in denen der Kernel versucht, jedes Byte des Ausgabepuffers des Benutzers zu verwenden, ohne die Menge der tats√§chlich zu kopierenden Daten zu ber√ºcksichtigen.  Ein Beispiel f√ºr dieses Verhalten ist in Listing 6 dargestellt. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS NTAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NtMagicValues</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LPDWORD OutputPointer, DWORD OutputLength)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (OutputLength &lt; <span class="hljs-number"><span class="hljs-number">3</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(DWORD)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> STATUS_BUFFER_TOO_SMALL; } LPDWORD KernelBuffer = Allocate(OutputLength); KernelBuffer[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0xdeadbeef</span></span>; KernelBuffer[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">0xbadc0ffe</span></span>; KernelBuffer[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">0xcafed00d</span></span>; RtlCopyMemory(OutputPointer, KernelBuffer, OutputLength); Free(KernelBuffer); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> STATUS_SUCCESS; }</code> </pre> <br><p>  <em>Listing 6: Speichererweiterung um einen Ausgabepuffer beliebiger Gr√∂√üe.</em> </p><br><p>  Der Zweck eines Systemaufrufs besteht darin, dem aufrufenden Code drei spezielle 32-Bit-Werte bereitzustellen, die insgesamt 12 Bytes belegen.  Obwohl die √úberpr√ºfung der korrekten Puffergr√∂√üe am Anfang der Funktion korrekt ist, sollte die Verwendung des OutputLength-Arguments dort enden.  In dem Wissen, dass der Ausgabepuffer gro√ü genug ist, um das Ergebnis zu speichern, kann der Kernel 12 Byte Speicher zuweisen, ihn f√ºllen und den Inhalt zur√ºck in den bereitgestellten Benutzermoduspuffer kopieren.  Stattdessen weist ein Systemaufruf einen Poolblock zu (au√üerdem mit einer benutzergesteuerten L√§nge) und kopiert den gesamten zugewiesenen Speicher in den Benutzerbereich.  Es stellt sich heraus, dass alle Bytes mit Ausnahme der ersten 12 nicht initialisiert und f√§lschlicherweise f√ºr den Benutzer ge√∂ffnet werden, wie in Abbildung 5 dargestellt. </p><br><p><img src="https://habrastorage.org/webt/m7/hy/dj/m7hydjfgkhaqgizxuhr2xcmv8jw.png" alt="Abbildung 5: Beliebiger Pufferspeicher"><br>  <em>Abbildung 5: Pufferspeicher beliebiger Gr√∂√üe.</em> </p><br><p>  Das in diesem Abschnitt beschriebene Schema ist besonders f√ºr Windows √ºblich.  Ein √§hnlicher Fehler kann einem Angreifer ein √§u√üerst n√ºtzliches Grundelement f√ºr die Speichererweiterung liefern: </p><br><ul><li> ,      Windows,                  .            ,       . </li><li>              .   ,     ,                .      ,    (   ‚Äî  )  . </li></ul><br><p>  ,        .      ,     ,       . </p><br><h2 id="faktory-sposobstvuyuschie-poyavleniyu-oshibok-raskrytiya-pamyati"> ,      </h2><br><p>     ,           .         ,          Windows    . </p><br><p> <strong>  </strong> <br>  ,       ,   .        ,      : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AddressSanitizer</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PageHeap</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Special Pool</a> .  , ,   -          .         ,         .   ,         ,       ,           ,        ,       .       <em></em>     ,      (   ). </p><br><p>  ,             ,  ,       .               ,                  . </p><br><p> <strong>,    API</strong> <br>           API,   Windows (Win32/User32 API). API         ,   ,          ,     .     ,  ,        , ,      .              <em></em>  . </p><br><h2 id="znachimost-i-vliyanie-na-bezopasnost-sistemy">       </h2><br><p>   ,             .          ,            .      ,     <em></em>       ,       ,      .        ,         ,    . </p><br><p>  ,      ,          .     ,       KASLR (Kernel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Address Space Layout Randomization</a> ),                .  :   Windows,    Hacking Team   2015  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Juan Vazquez. Revisiting an Info Leak</a> )         (derandomize)     win32k.sys,       . ,         Matt Tait'  Google Project Zero ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kernel-mode ASLR leak via uninitialized memory returned to usermode by NtGdiGetTextMetrics</a> )     MS15-080 (CVE-2015-2433). </p><br><p> <strong></strong> <br>       (/)   ,      ,      (control Ô¨Çow),  :   ,   ,   ,   ,   StackGuard  Linux  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">/GS  Windows</a> .    ,             .        ,   ,            . </p><br><p> <strong>  (/)</strong> <br>    (/)    ,    ,      ,    :  ,   ,  ,     .               ,     ,      .         .  ,         ( ,    )   ,  ,      . </p><br><h2 id="drugie-suschestvuyuschie-issledovaniya">    </h2><br><p><img src="https://habrastorage.org/webt/wp/ky/ap/wpkyap5uiyz52hrghshrxxve1v0.jpeg" alt="#2"></p><br><h4 id="microsoft-windows"> Microsoft Windows </h4><br><p> <strong></strong> <br>  2015            Windows.   2015  Matt Tait           win32k!NtGdiGetTextMetrics.          Windows   Hacking Team.   ,      ,       ,    0-day       Windows. </p><br><p>    2015, WanderingGlitch (HP Zero Day Initiative)          ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Acknowledgments ‚Äì 2015</a> ).           Ruxcon 2016 (  )    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Leaking Windows Kernel Pointers"</a> . </p><br><p>  ,   2017 fanxiaocao  pjf  IceSword Lab (Qihoo 360)   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Automatically Discovering Windows Kernel Information Leak Vulnerabilities"</a> ,    ,      14   2017  (8      ).        Bochspwn Reloaded,             ,            .        VMware     (Bochs)         .   ,  Bochspwn Reloaded,                . </p><br><p>         ,  ,    2010-2011          ,     win32k: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Challenge: On 32bit Windows7, explain where the upper 16bits of eax come from after a call to NtUserRegisterClassExWOW()"</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Subtle information disclosure in WIN32K.SYS syscall return values"</a> .          Windows 8,   2015  Matt Tait ,           : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Google Project Zero Bug Tracker</a> . </p><br><p> <strong></strong> <br>       (   ),  ,    2017   - Windows        -,   : Joseph Bialek ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Anyone notice my change to the Windows IO Manager to generically kill a class of info disclosure? BuÔ¨ÄeredIO output buÔ¨Äer is always zero'd"</a> .      ,  IOCTL-          . </p><br><p>        ,   Visual Studio 15.5   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">POD-</a> ,       "= {0}",   .       ,      padding- ()   . </p><br><h4 id="linux"> Linux </h4><br><p>    Windows,   Linux        ,         2010 .        ,             (  )   (    ) .  ,        Windows  Linux         ,        ‚Äî ,    . </p><br><p> <strong></strong> <br>    ,   Linux       .   "Linux kernel vulnerabilities: State-of-the-art defenses and open problems"   2010    2011   28    .   2017-  "Securing software systems by preventing information leaks" Lu K.    59  ,    2013-   2016-.          . : Rosenberg  Oberheide    25 ,     Linux  2009-2010 ,     .          Linux c <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">grsecurity</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PaX-hardened</a> . Vasiliy Kulikov   25   2010-2011 ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   Coccinelle</a> .  , Mathias Krause <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   21      2013 </a>   50      . </p><br><p>    ,      ,           Linux.     ‚Äî   -Wuninitialized (  gcc,   LLVM),          .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  kmemcheck</a> ,      Valgrind'   .        ,        .         ,         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">KernelAddressSANitizer</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">KernelMemorySANitizer</a> .      KMSAN    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">syzkaller</a> (   ) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> 19    </a> ,        . </p><br><p>               Linux.  2014 ‚Äî 2016  Peir¬¥o      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Coccinelle</a>     ,      Linux  3.12: "Detecting stack based kernel information leaks" International Joint Conference SOCO14-CISIS14-ICEUTE14, pages 321‚Äì331 (Springer, 2014)  "An analysis on the impact and detection of kernel stack infoleaks" Logic Journal of the IGPL.         ,          .  2016- Lu       UniSan ‚Äî   ,    ,                 :   ,   .            ,        20%     (350   1800),      19     Linux  Android. </p><br><p>             ‚Äî    (multi-variant program execution),            ,      .           ,             .     ,  KASLR,   -,         .         ,  2006    DieHard: probabilistic memory safety for unsafe languages,   2017  ‚Äî BUDDY: Securing software systems by preventing information leaks.     John North   "Identifying Memory Address Disclosures" 2015- . ,  SafeInit (Comprehensive and Practical Mitigation of Uninitialized Read Vulnerabilities)  ,          ,            .       , ,   ,        Linux. </p><br><p> <strong></strong> <br>                  ,   .      ,       :     ,        .     ,  , -    ,             .                   . </p><br><p>        CONFIG_PAGE_POISONING  CONFIG_DEBUG_SLAB,       -.       -,      .        , ,  ,       Linux. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">grsecurity</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PaX</a>    .  ,   PAX_MEMORY_SANITIZE   ,         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">slab</a> ,    (        ‚Äî   ).  ,  PAX_MEMORY_STRUCTLEAK     ,    (  ),       .         padding- (),          100% .  ,      ‚Äî PAX_MEMORY_STACKLEAK,            .      ,      ,        .       (Kernel Self Protection Project)   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> STACKLEAK</a>   . </p><br><p>               Linux: </p><br><div class="spoiler"> <b class="spoiler_title">Secure deallocation, Chow  , 2005</b> <div class="spoiler_text"><p> Chow, Jim and PfaÔ¨Ä, Ben and GarÔ¨Ånkel, Tal and Rosenblum, Mendel. Shredding Your Garbage: Reducing Data Lifetime Through Secure Deallocation. In USENIX Security Symposium, pages 22‚Äì22, 2005. </p></div></div><br><p>  ,       ,          ( )  .         Linux     . </p><br><div class="spoiler"> <b class="spoiler_title">Split Kernel, Kurmus  Zippel, 2014</b> <div class="spoiler_text"><p> Kurmus, Anil and Zippel, Robby. A tale of two kernels: Towards ending kernel hardening wars with split kernel. In Proceedings of the 2014 ACM SIGSAC Conference on Computer and Communications Security, pages 1366‚Äì1377. ACM, 2014. </p></div></div><br><p>      ,           . </p><br><div class="spoiler"> <b class="spoiler_title">SafeInit, Milburn  , 2017</b> <div class="spoiler_text"><p> Milburn, Alyssa and Bos, Herbert and GiuÔ¨Ärida, Cristiano. SafeInit: Comprehensive and Practical Mitigation of Uninitialized Read Vulnerabilities. In Proceedings of the 2017 Annual Network and Distributed System Security Symposium (NDSS)(San Diego, CA), 2017. </p></div></div><br><p>         ,      ,         . </p><br><div class="spoiler"> <b class="spoiler_title">UniSan, Lu  , 2016</b> <div class="spoiler_text"><p> Lu, Kangjie and Song, Chengyu and Kim, Taesoo and Lee, Wenke. UniSan: Proactive kernel memory initialization to eliminate data leakages. In Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security, pages 920‚Äì932. ACM, 2016. </p></div></div><br><p>    SafeInit         ,  ,       ,      ,      . </p><br><p>       ,  Linux             . </p><br><h2 id="vmesto-epiloga-ot-perevodchika">   ( ) </h2><br><p>        ,    ,          (      ).  :  (),     , ,    ,   ( - )     .   ,          . , ,        . </p><br><p>     ,             : </p><br><ul><li> Bochspwn Reloaded ‚Äì detection with software x86 emulation </li><li> Windows bug reproduction techniques </li><li> Alternative detection methods </li><li> Other data sinks </li><li> Future work </li><li> Other system instrumentation schemes </li></ul><br><p>  ,     :)          ,       . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de415685/">https://habr.com/ru/post/de415685/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de415675/index.html">PostgreSQL News Digest. Ausgabe Nummer 8</a></li>
<li><a href="../de415677/index.html">Wachsende St√§dte haben Schwierigkeiten, die Massen von Menschen vertikal und an der Oberfl√§che zu bewegen</a></li>
<li><a href="../de415679/index.html">Warum reiche Kinder in einem Marshmallow-Experiment gute Ergebnisse zeigen</a></li>
<li><a href="../de415681/index.html">Die Geschichte der Entstehung des Geb√§rdensprachdolmetschers</a></li>
<li><a href="../de415683/index.html">Versuchen Sie sich in der Q # -Programmierung</a></li>
<li><a href="../de415687/index.html">Fintech Digest: Die Zentralbank verpflichtet die Banken, Client-Ger√§te zu √ºberpr√ºfen, von denen Geld √ºberwiesen wird</a></li>
<li><a href="../de415689/index.html">Wir spielen Seeschlacht auf BGP</a></li>
<li><a href="../de415691/index.html">Vergleich der Austauschsortierung</a></li>
<li><a href="../de415693/index.html">Oumuamua. Angekommen, ratlos, flog weg (und versprach nicht zur√ºckzukehren). Und eines Tages war es wieder einmal r√§tselhaft</a></li>
<li><a href="../de415695/index.html">Google gab zu, dass es auch GitHub kaufen wollte</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>