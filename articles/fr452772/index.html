<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧀 🤷🏾 👨🏻‍🚀 5 techniques avancées de test Go 🍘 👩🏽‍🎨 🌬️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut à tous! Il reste moins d'une semaine avant le début du cours «Développeur Golang» et nous continuons à partager des informations utiles sur le s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>5 techniques avancées de test Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/452772/"> Salut à tous!  Il reste moins d'une semaine avant le début du cours <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Développeur Golang»</a> et nous continuons à partager des informations utiles sur le sujet.  C'est parti! <br><br><img src="https://habrastorage.org/webt/mi/ly/nj/milynjiemmrcxgeldshfcz383pa.png"><br><br>  Go a une bibliothèque intégrée bonne et fiable pour les tests.  Si vous écrivez sur Go, vous le savez déjà.  Dans cet article, nous parlerons de plusieurs stratégies qui peuvent améliorer vos compétences de test avec Go.  De l'expérience de l'écriture de notre impressionnante base de code sur Go, nous avons appris que ces stratégies fonctionnent vraiment et permettent ainsi d'économiser du temps et des efforts pour travailler avec le code. <a name="habracut"></a><br><br>  <b>Utiliser des suites de tests</b> <br><br>  Si vous apprenez par vous-même une seule chose utile de cet article, ce doit être l'utilisation de suites de tests.  Pour ceux qui ne connaissent pas ce concept, le test par kits est le processus de développement d'un test pour tester une interface commune qui peut être utilisée sur de nombreuses implémentations de cette interface.  Ci-dessous, vous pouvez voir comment nous réussissons plusieurs implémentations <code>Thinger</code> différentes et les <code>Thinger</code> avec les mêmes tests. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Thinger <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { DoThing(input <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) (Result, error) } <span class="hljs-comment"><span class="hljs-comment">// Suite tests all the functionality that Thingers should implement func Suite(t *testing.T, impl Thinger) { res, _ := impl.DoThing("thing") if res != expected { t.Fail("unexpected result") } } // TestOne tests the first implementation of Thinger func TestOne(t *testing.T) { one := one.NewOne() Suite(t, one) } // TestOne tests another implementation of Thinger func TestTwo(t *testing.T) { two := two.NewTwo() Suite(t, two) }</span></span></code> </pre><br>  Les lecteurs chanceux ont travaillé avec des bases de code qui utilisent cette méthode.  Souvent utilisé dans les tests de systèmes basés sur des plugins qui sont écrits pour tester une interface, il peut être utilisé par toutes les implémentations de cette interface pour comprendre comment ils répondent aux exigences de comportement. <br><br>  L'utilisation de cette approche permettra potentiellement de gagner des heures, des jours et même suffisamment de temps pour résoudre le problème de l'égalité des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">classes P et NP</a> .  De plus, lors du remplacement d'un système de base par un autre, la nécessité d'écrire (un grand nombre) de tests supplémentaires disparaît et il est également certain que cette approche ne perturbera pas le fonctionnement de votre application.  Implicitement, vous devez créer une interface qui définit la zone de la zone testée.  À l'aide de l'injection de dépendances, vous pouvez personnaliser un ensemble à partir d'un package qui est transmis à l'implémentation de l'ensemble du package. <br><br>  Vous pouvez trouver un exemple complet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Malgré le fait que cet exemple soit tiré par les cheveux, on peut imaginer qu'une base de données est distante et que l'autre est en mémoire. <br><br>  Un autre exemple intéressant de cette technique se trouve dans la bibliothèque standard du package <code>golang.org/x/net/nettest</code> .  Il fournit un moyen de vérifier que net.Conn satisfait l'interface. <br><br>  <b>Évitez la contamination de l'interface</b> <br><br>  Vous ne pouvez pas parler de test dans Go, mais ne parlez pas d'interfaces. <br><br>  Les interfaces sont importantes dans le contexte des tests, car elles sont l'outil le plus puissant de notre arsenal de tests, vous devez donc les utiliser correctement. <br><br>  Les packages exportent souvent des interfaces vers les développeurs, ce qui conduit au fait que: <br><br>  A) Les développeurs créent leur propre maquette pour implémenter le package; <br>  B) Le package exporte sa propre maquette. <br><br><blockquote>  <i>"Plus l'interface est grande, plus l'abstraction est faible"</i> <i><br></i>  <i>- Rob Pike, Sayings of Go</i> </blockquote><br>  Les interfaces doivent être soigneusement vérifiées avant l'exportation.  Il est souvent tentant d'exporter des interfaces pour donner aux utilisateurs la possibilité de simuler le comportement dont ils ont besoin.  Au lieu de cela, documentez les interfaces qui conviennent à vos structures afin de ne pas créer une relation étroite entre le package consommateur et le vôtre.  Un bon exemple de cela est le package d' <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">erreurs</a></i> . <br><br>  Lorsque nous avons une interface que nous ne voulons pas exporter, nous pouvons utiliser <i><a href="">la sous-arborescence interne / package</a></i> pour la sauvegarder dans le package.  Ainsi, nous ne pouvons pas avoir peur que l'utilisateur final puisse dépendre de lui, et, par conséquent, peut être flexible dans le changement d'interface en fonction des nouvelles exigences.  Habituellement, nous créons des interfaces avec des dépendances externes afin de pouvoir exécuter des tests localement. <br><br>  Cette approche permet à l'utilisateur d'implémenter ses propres petites interfaces en enveloppant simplement une partie de la bibliothèque pour le test.  Pour plus d'informations sur ce concept, lisez l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article rakyl sur la pollution des interfaces</a> . <br><br>  <b>N'exportez pas de primitives de concurrence</b> <br><br>  Go propose des primitives de simultanéité faciles à utiliser qui peuvent également parfois conduire à leur surutilisation en raison de la même simplicité.  Tout d'abord, nous sommes préoccupés par les chaînes et le package de synchronisation.  Parfois, il est tentant d'exporter une chaîne depuis votre package pour que d'autres puissent l'utiliser.  De plus, une erreur courante consiste à intégrer <code>sync.Mutex</code> sans le définir sur privé.  Comme d'habitude, cela n'est pas toujours mauvais, mais cela crée certains problèmes lors du test de votre programme. <br><br>  Si vous exportez des chaînes, vous compliquez en outre la vie de l'utilisateur du package, ce qui ne vaut pas la peine.  Dès que le canal est exporté du package, vous créez des difficultés lors du test pour celui qui utilise ce canal.  Pour réussir les tests, l'utilisateur doit savoir: <br><br><ul><li>  Lorsque les données finissent par être envoyées sur le canal. </li><li>  Y a-t-il eu des erreurs lors de la réception des données. </li><li>  Comment un paquet vide-t-il le canal une fois terminé, s'il est purgé? </li><li>  Comment encapsuler une API de package pour ne pas l'appeler directement? </li></ul><br>  Jetez un œil à l'exemple de lecture de file d'attente.  Voici un exemple de bibliothèque qui lit à partir de la file d'attente et fournit à l'utilisateur un flux de lecture. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Reader <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> {...} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadChan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> &lt;-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">chan</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Msg</span></span></span></span> {...}</code> </pre> <br>  L'utilisateur de votre bibliothèque souhaite maintenant implémenter un test pour son consommateur: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestConsumer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t testing.T)</span></span></span></span> { cons := &amp;Consumer{ r: libqueue.NewReader(), } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> msg := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> cons.r.ReadChan() { <span class="hljs-comment"><span class="hljs-comment">// Test thing. } }</span></span></code> </pre> <br><br>  L'utilisateur peut alors décider que l'injection de dépendances est une bonne idée et écrire ses propres messages dans le canal: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestConsumer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t testing.T, q queueIface)</span></span></span></span> { cons := &amp;Consumer{ r: q, } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> msg := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> cons.r.ReadChan() { <span class="hljs-comment"><span class="hljs-comment">// Test thing. } }</span></span></code> </pre> <br><br>  Attendez, qu'en est-il des erreurs? <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestConsumer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t testing.T, q queueIface)</span></span></span></span> { cons := &amp;Consumer{ r: q, } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> msg := &lt;-cons.r.ReadChan(): <span class="hljs-comment"><span class="hljs-comment">// Test thing. case err := &lt;-cons.r.ErrChan(): // What caused this again? } } }</span></span></code> </pre> <br><br>  Maintenant, nous devons en quelque sorte générer des événements afin d'écrire réellement sur ce stub, qui reproduit le comportement de la bibliothèque que nous utilisons.  Si la bibliothèque vient d'écrire l'API synchrone, nous pourrions ajouter tout le parallélisme au code client, afin que les tests deviennent plus faciles. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestConsumer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t testing.T, q queueIface)</span></span></span></span> { cons := &amp;Consumer{ r: q, } msg, err := cons.r.ReadMsg() <span class="hljs-comment"><span class="hljs-comment">// handle err, test thing }</span></span></code> </pre><br><br>  En cas de doute, n'oubliez pas qu'il est toujours facile d'ajouter du parallélisme au package consommateur (package consommateur) et qu'il est difficile, voire impossible de le supprimer après l'exportation depuis la bibliothèque.  Et surtout, n'oubliez pas d'écrire dans la documentation du package si la structure / le package est sûr pour un accès simultané à plusieurs goroutines. <br>  Parfois, il est toujours souhaitable ou nécessaire d'exporter la chaîne.  Afin d'atténuer certains des problèmes mentionnés ci-dessus, vous pouvez fournir des canaux via des accesseurs au lieu d'un accès direct et les laisser ouverts uniquement pour la lecture ( <code>←chan</code> ) ou uniquement pour l'écriture ( <code>chan←</code> ) lors de la déclaration. <br><br>  <b>Utilisez <code>net/http/httptest</code></b> <br><br>  <code>Httptest</code> permet d'exécuter <code>http.Handler</code> code <code>http.Handler</code> sans démarrer de serveur ni lier à un port.  Cela accélère les tests et vous permet d'exécuter des tests en parallèle à moindre coût. <br><br>  Voici un exemple du même test implémenté de deux manières.  Il n'y a rien de grandiose ici, mais cette approche réduit la quantité de code et économise les ressources. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestServe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// The method to use if you want to practice typing s := &amp;http.Server{ Handler: http.HandlerFunc(ServeHTTP), } // Pick port automatically for parallel tests and to avoid conflicts l, err := net.Listen("tcp", ":0") if err != nil { t.Fatal(err) } defer l.Close() go s.Serve(l) res, err := http.Get("http://" + l.Addr().String() + "/?sloths=arecool") if err != nil { log.Fatal(err) } greeting, err := ioutil.ReadAll(res.Body) res.Body.Close() if err != nil { log.Fatal(err) } fmt.Println(string(greeting)) } func TestServeMemory(t *testing.T) { // Less verbose and more flexible way req := httptest.NewRequest("GET", "http://example.com/?sloths=arecool", nil) w := httptest.NewRecorder() ServeHTTP(w, req) greeting, err := ioutil.ReadAll(w.Body) if err != nil { log.Fatal(err) } fmt.Println(string(greeting)) }</span></span></code> </pre> <br>  La caractéristique la plus importante est peut-être qu'avec <code>httptest</code> vous ne pouvez diviser le test qu'en fonction que vous souhaitez tester.  Aucun routeur, middleware ou autre effet secondaire qui se produit lors de la configuration des serveurs, des services, des usines de processeurs, des usines de processeurs ou toute autre chose que vous pensez serait une bonne idée. <br><br>  Pour voir ce principe en action, consultez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'article de Marc Berger</a> . <br><br>  <b>Utiliser un package distinct <code>_test</code></b> <br><br>  La plupart des tests de l'écosystème sont créés dans les fichiers <code>pkg_test.go</code> , mais restent toujours dans le même package: <code>package pkg</code> .  Un package de test distinct est le package que vous créez dans le nouveau fichier, <code>foo_test.go</code> , dans le répertoire du module que vous souhaitez tester, <code>foo/</code> , avec le <code>package foo_test</code> déclaration <code>package foo_test</code> .  De là, vous pouvez importer <code>github.com/example/foo</code> et d'autres dépendances.  Cette fonctionnalité vous permet de faire beaucoup de choses.  C'est la solution recommandée pour les dépendances cycliques dans les tests, elle empêche l'apparition de «tests fragiles» et permet au développeur de ressentir ce que c'est que d'utiliser votre propre package.  Si votre paquet est difficile à utiliser, alors tester avec cette méthode sera également difficile. <br><br>  Cette stratégie empêche les tests fragiles en restreignant l'accès aux variables privées.  En particulier, si vos tests échouent et que vous utilisez des packages de test distincts, il est presque garanti qu'un client utilisant une fonction qui interrompt les tests s'arrêtera également lors de son appel. <br><br>  Enfin, cela permet d'éviter les cycles d'importation dans les tests.  La plupart des packages sont plus susceptibles de dépendre d'autres packages que vous avez écrits en plus des tests, vous vous retrouverez donc dans une situation où le cycle d'importation se produit naturellement.  Un package externe est situé au-dessus des deux packages dans la hiérarchie des packages.  Prenons un exemple tiré du langage de programmation Go (chapitre 11, section 2.4), où <code>net/url</code> implémente un analyseur d'URL que <code>net/http</code> importe pour utilisation.  Cependant, <code>net / url</code> doit être testé avec un cas d'utilisation réel en important <code>net / http</code> .  Ainsi, <code>net/url_test</code> . <br><br>  Désormais, lorsque vous utilisez un package de test distinct, vous devrez peut-être accéder aux entités non exportées dans le package où elles étaient auparavant disponibles.  Certains développeurs sont confrontés à cela pour la première fois lorsqu'ils testent quelque chose en fonction du temps (par exemple, time.Now devient un stub en utilisant une fonction).  Dans ce cas, nous pouvons utiliser un fichier supplémentaire pour fournir des entités exclusivement pendant les tests, car les fichiers <code>_test.go</code> exclus des <code>_test.go</code> régulières. <br><br>  <b>De quoi devez-vous vous souvenir?</b> <br><br>  Il est important de se rappeler qu'aucune des méthodes décrites ci-dessus n'est une panacée.  La meilleure approche dans toute entreprise consiste à analyser la situation de manière critique et à choisir indépendamment la meilleure solution au problème. <br><br>  Vous voulez en savoir plus sur les tests avec Go? <br>  Lisez ces articles: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les tests pilotés par table d'écriture de Dave Cheney dans Go</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le chapitre Go Programming Language sur les tests.</a> <br>  Ou regardez ces vidéos: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Présentation de Hashimoto Advanced Testing With Go de Gophercon 2017</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Andrew Gerrand parle des techniques de test de 2014</a> <br><br>  Nous espérons que cette traduction vous a été utile.  Nous attendons les commentaires, et tous ceux qui veulent en savoir plus sur le cours, nous vous invitons à la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">journée portes ouvertes</a> , qui se tiendra le 23 mai. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr452772/">https://habr.com/ru/post/fr452772/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr452760/index.html">Vitamine D. Boire ou ne pas boire, telle est la question. (Ou une histoire sur la façon dont j'ai réussi une analyse qui ne m'a pas été prescrite)</a></li>
<li><a href="../fr452762/index.html">MVCC-7. Nettoyage auto</a></li>
<li><a href="../fr452764/index.html">[Peter] Rencontre JUG.ru avec Sergei Melnikov - Profilage à la vitesse supraluminique: théorie et pratique</a></li>
<li><a href="../fr452766/index.html">La technologie de streaming progressif, ou comment regarder des vidéos 4k sur le réseau, sans frises</a></li>
<li><a href="../fr452768/index.html">Comment concevoir un produit si vous décidez d'entrer sur le marché étranger</a></li>
<li><a href="../fr452774/index.html">Dell XPS 13 9380: un ordinateur portable fiable et très compact pour les affaires sérieuses</a></li>
<li><a href="../fr452776/index.html">N.M.D. (Pas mon entreprise)</a></li>
<li><a href="../fr452778/index.html">Comment accélérer le déchargement de LZ4 dans ClickHouse</a></li>
<li><a href="../fr452780/index.html">Mobius 2019 Piter: Streaming en direct gratuit et tout le reste</a></li>
<li><a href="../fr452788/index.html">La lutte pour la qualité dans les applications Web, la dépression, les dragons et Westeros</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>