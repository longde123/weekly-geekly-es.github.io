<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔗 🤧 🤛🏿 Python-Speicherverwaltung 📎 👨🏽‍🤝‍👨🏼 🚵🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! So endete das lange Märzwochenende. Wir möchten die erste Veröffentlichung nach den Feiertagen der von vielen Kursen geliebten Perso...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python-Speicherverwaltung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/443312/">  Hallo allerseits!  So endete das lange Märzwochenende.  Wir möchten die erste Veröffentlichung nach den Feiertagen der von vielen Kursen geliebten Person widmen - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Python Developer"</a> , die in weniger als zwei Wochen beginnt.  Lass uns gehen. <br><br>  <b>Inhalt</b> <br><br><ol><li>  Die Erinnerung ist ein leeres Buch. </li><li>  Speicherverwaltung: Von der Hardware zur Software </li><li>  Python-Basisimplementierung </li><li>  Global Interpreter Lock (GIL) -Konzept </li><li>  Müllsammler </li><li>  Speicherverwaltung in CPython: <br><ul><li>  Pools </li><li>  Blöcke </li><li>  Arenen </li></ul></li><li>  Fazit </li></ol><br><img src="https://habrastorage.org/webt/ww/vn/wj/wwvnwjqala4vtezc2ei4dx4ml_w.png"><br><br>  Haben Sie sich jemals gefragt, wie Python Backstage Ihre Daten verarbeitet?  Wie werden Ihre Variablen gespeichert?  Wann werden sie entfernt? <br>  In diesem Artikel werden wir uns eingehender mit der internen Struktur von Python befassen, um zu verstehen, wie die Speicherverwaltung funktioniert. <br><br>  Nach dem Lesen dieses Artikels haben Sie: <br><br><ul><li>  Erfahren Sie mehr über Operationen auf niedriger Ebene, insbesondere über Speicher. </li><li>  Verstehen Sie, wie Python Operationen auf niedriger Ebene abstrahiert. </li><li>  Erfahren Sie mehr über Speicherverwaltungsalgorithmen in Python. </li></ul><br>  Wenn Sie die interne Struktur von Python kennen, können Sie die Prinzipien seines Verhaltens besser verstehen.  Ich hoffe, Sie können Python aus einer neuen Perspektive betrachten.  Hinter den Kulissen gibt es so viele logische Operationen, damit Ihr Programm ordnungsgemäß funktioniert. <a name="habracut"></a><br><br>  <b>Die Erinnerung ist ein leeres Buch</b> <br><br>  Sie können sich den Speicher des Computers als leeres Buch vorstellen, das darauf wartet, dass es viele Kurzgeschichten schreibt.  Es gibt noch nichts auf seinen Seiten, aber bald werden Autoren erscheinen, die ihre Geschichten darin schreiben wollen.  Dazu brauchen sie einen Platz. <br>  Da sie eine Geschichte nicht übereinander schreiben können, müssen sie sehr vorsichtig mit den Seiten sein, auf denen sie schreiben.  Bevor Sie mit dem Schreiben beginnen, wenden Sie sich an den Buchmanager.  Der Manager entscheidet, wo in dem Buch die Autoren ihre Geschichte aufschreiben können. <br><br>  Da es das Buch seit vielen Jahren gibt, sind viele Geschichten darin veraltet.  Wenn niemand die Geschichte liest oder anspricht, entfernt er sie, um neuen Geschichten Platz zu machen. <br>  Der Computerspeicher ist im Kern wie ein leeres Buch.  Kontinuierliche Speicherblöcke mit fester Länge werden normalerweise als Seiten bezeichnet, daher ist diese Analogie nützlich. <br><br>  Die Autoren können verschiedene Anwendungen oder Prozesse sein, die Daten im Speicher speichern müssen.  Ein Manager, der entscheidet, wo Autoren ihre Geschichten schreiben können, spielt die Rolle eines Speichermanagers - eines Sortierers.  Und derjenige, der alte Geschichten löscht, ist ein Müllsammler. <br><br>  <b>Speicherverwaltung: Von der Hardware zur Software</b> <br><br>  Speicherverwaltung ist der Prozess, bei dem Softwareanwendungen Daten lesen und schreiben.  Der Speichermanager bestimmt, wo die Programmdaten abgelegt werden sollen.  Da die Speichermenge natürlich der Anzahl der Seiten im Buch entspricht, muss der Manager freien Speicherplatz finden, um sie für die Anwendung bereitzustellen.  Dieser Vorgang wird als "Speicherzuordnung" bezeichnet. <br><br>  Wenn Daten jedoch nicht mehr benötigt werden, können sie gelöscht werden.  In diesem Fall geht es darum, Speicherplatz freizugeben.  Aber wovon wird es befreit und woher kommt es? <br>  Irgendwo im Computer befindet sich ein physisches Gerät, das Daten speichert, wenn Sie Python-Programme ausführen.  Python-Code durchläuft viele Abstraktionsebenen, bevor er auf dieses Gerät gelangt. <br><br>  Eine der Hauptebenen über dem Gerät (RAM, Festplatte usw.) ist das Betriebssystem.  Es verwaltet Lese- und Schreibanforderungen in den Speicher. <br>  Über dem Betriebssystem befindet sich eine Anwendungsschicht, auf der sich eine der Python-Implementierungen befindet (mit Ihrem Betriebssystem verbunden oder von python.org heruntergeladen).  Die Speicherverwaltung für Code in dieser Programmiersprache wird durch spezielle Python-Tools geregelt.  Die Algorithmen und Strukturen, mit denen Python den Speicher verwaltet, sind das Hauptthema dieses Artikels. <br><br>  <b>Python-Basisimplementierung</b> <br><br>  Die Basisimplementierung von Python oder „reinem Python“ ist CPython, geschrieben in C. <br>  Ich war sehr überrascht, als ich zum ersten Mal davon hörte.  Wie kann eine Sprache in einer anderen Sprache geschrieben werden ?!  Natürlich nicht wörtlich, aber die Idee ist ungefähr so. <br><br>  Die Python-Sprache wird in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">speziellen Referenzhandbuch in Englisch beschrieben</a> .  Diese Anleitung allein ist jedoch nicht sehr nützlich.  Sie benötigen noch ein Tool, um Code zu interpretieren, der nach den Regeln des Verzeichnisses geschrieben wurde. <br><br>  Sie benötigen auch etwas, um den Code auf Ihrem Computer auszuführen.  Die grundlegende Python-Implementierung bietet beide Bedingungen.  Es konvertiert Python-Code in Anweisungen, die in einer virtuellen Maschine ausgeführt werden. <br><br><blockquote>  Hinweis: Virtuelle Maschinen ähneln physischen Computern, sind jedoch in die Software eingebettet.  Sie verarbeiten grundlegende Anweisungen ähnlich dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Assembler-Code</a> . </blockquote><br><br>  Python ist eine interpretierte Programmiersprache.  Ihr Python-Code wird anhand von Anweisungen kompiliert, die vom Computer- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bytecode</a> besser verstanden werden.  Diese Anweisungen werden von der virtuellen Maschine interpretiert, wenn Sie den Code ausführen. <br><br>  Haben Sie jemals Dateien mit der Erweiterung <i>.pyc</i> oder dem Ordner <i>__pycache__ gesehen</i> ?  Dies ist der gleiche Bytecode, der von der virtuellen Maschine interpretiert wird. <br>  Es ist wichtig zu verstehen, dass es neben CPython noch andere Implementierungen gibt, z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IronPython</a> , das in der Microsoft Common Language Runtime (CLR) kompiliert und ausgeführt wird.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jython</a> kompiliert zu Java-Bytecode, um in einer virtuellen Java-Maschine ausgeführt zu werden.  Und es gibt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PyPy,</a> über das Sie einen separaten Artikel schreiben können, daher werde ich ihn nur beiläufig erwähnen. <br><br>  In diesem Artikel konzentrieren wir uns auf die Speicherverwaltung mit CPython-Tools. <br>  Hinweis: Python-Versionen werden aktualisiert und in Zukunft kann alles passieren.  Zum Zeitpunkt des Schreibens war die neueste Version <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Python 3.7</a> . <br><br>  Ok, wir haben CPython in C geschrieben, das Python-Bytecode interpretiert.  Wie hängt das mit der Speicherverwaltung zusammen?  Zunächst sind im CPython-Code in C Algorithmen und Strukturen zum Verwalten des Speichers vorhanden. Um diese Prinzipien in Python zu verstehen, benötigen Sie ein grundlegendes Verständnis von CPython. <br><br>  CPython ist in C geschrieben, was wiederum keine objektorientierte Programmierung unterstützt.  Aus diesem Grund hat CPython-Code eine ziemlich interessante Struktur. <br><br>  Sie müssen gehört haben, dass alles in Python ein Objekt ist, auch Typen wie int und str.  Dies gilt auf der CPython-Implementierungsebene.  Es gibt eine Struktur namens PyObject, die jedes Objekt in CPython verwendet. <br><br>  Hinweis: Eine Struktur in C ist ein benutzerdefinierter Datentyp, der verschiedene Datentypen in sich gruppiert.  Wir können eine Analogie mit objektorientierten Sprachen ziehen und sagen, dass eine Struktur eine Klasse mit Attributen, aber ohne Methoden ist. <br><br>  PyObject ist der Vorläufer aller Objekte in Python und enthält nur zwei Dinge: <br><br><ul><li>  <b>ob_refcnt</b> : Referenzzähler; </li><li>  <b>ob_type</b> : Zeiger auf einen anderen Typ. </li></ul><br>  Für die Speicherbereinigung ist ein Referenzzähler erforderlich.  Wir haben auch einen Zeiger auf einen bestimmten Objekttyp.  Ein Objekttyp ist nur eine andere Struktur, die Objekte in Python beschreibt (z. B. dict oder int). <br><br>  Jedes Objekt verfügt über einen objektorientierten Speicherzuweiser, der weiß, wie Speicher zugewiesen und das Objekt gespeichert wird.  Jedes Objekt verfügt außerdem über einen objektorientierten Ressourcen-Liberator, der den Speicher bereinigt, wenn sein Inhalt nicht mehr benötigt wird. <br><br>  Es gibt einen wichtigen Faktor, wenn es um die Speicherzuweisung und deren Bereinigung geht.  Speicher ist eine gemeinsam genutzte Ressource eines Computers, und etwas Unangenehmes kann passieren, wenn zwei Prozesse gleichzeitig versuchen, Daten an denselben Speicherort zu schreiben. <br><br>  <b>Globale Interpretationssperre (GIL)</b> <br><br>  GIL ist eine Lösung für das allgemeine Problem der gemeinsamen Nutzung von Speicher zwischen gemeinsam genutzten Ressourcen wie Computerspeicher.  Wenn zwei Threads versuchen, dieselbe Ressource gleichzeitig zu ändern, treten sie sich gegenseitig auf die Fersen.  Infolgedessen bildet sich im Speicher ein vollständiges Durcheinander, und kein Prozess beendet seine Arbeit mit dem gewünschten Ergebnis. <br><br>  Um auf die Analogie mit dem Buch zurückzukommen, nehmen wir an, dass jeder der beiden Autoren beschließt, seine Geschichte zu diesem bestimmten Zeitpunkt auf der aktuellen Seite zu schreiben.  Jeder von ihnen ignoriert die Versuche des anderen, eine Geschichte zu schreiben, und beginnt hartnäckig, auf die Seite zu schreiben.  Als Ergebnis haben wir zwei Geschichten übereinander und eine absolut unlesbare Seite. <br><br>  Eine der Lösungen für dieses Problem ist genau GIL, das den Interpreter blockiert, während der Thread mit der zugewiesenen Ressource interagiert, sodass nur ein Thread in den zugewiesenen Speicherbereich schreiben kann.  Wenn CPython Speicher zuweist, verwendet es die GIL, um sicherzustellen, dass es richtig funktioniert. <br>  Dieser Ansatz hat sowohl viele Vor- als auch viele Nachteile, weshalb GIL in der Python-Community zu Konflikten führt.  Um mehr über GIL zu erfahren, empfehle ich, den folgenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel zu</a> lesen. <br><br>  <b>Müllsammler</b> <br><br>  Kehren wir zu unserer Analogie mit dem Buch zurück und stellen wir uns vor, dass einige darin enthaltene Geschichten hoffnungslos veraltet sind.  Niemand liest sie und spricht sie an.  In diesem Fall wäre eine natürliche Lösung, sie als unnötig loszuwerden und dadurch Platz für neue Geschichten zu schaffen. <br>  Solche alten nicht verwendeten Storys können mit Objekten in Python verglichen werden, deren Referenzanzahl auf 0 gesunken ist. Denken Sie daran, dass jedes Objekt in Python eine Referenzanzahl und einen Zeiger auf einen Typ hat. <br><br>  Die Referenzanzahl kann sich aus mehreren Gründen erhöhen.  Sie erhöht sich beispielsweise, wenn Sie eine Variable einer anderen Variablen zuweisen. <br><br><img src="https://habrastorage.org/webt/zv/me/dj/zvmedjrxhn3qqrac6tibjlrpnuu.png"><br><br>  Sie erhöht sich auch, wenn Sie das Objekt als Argument übergeben. <br><br><img src="https://habrastorage.org/webt/kq/np/pm/kqnppmeqfhl4pg6-4atqz_nnhhq.png"><br><br>  Im letzten Beispiel erhöht sich die Referenzanzahl, wenn Sie das Objekt in die Liste aufnehmen. <br><br><img src="https://habrastorage.org/webt/ql/ro/mj/qlromj2eg80jfhzykfkpzv8syfg.png"><br><br>  Python informiert Sie über den aktuellen Wert des Referenzzählers mithilfe des sys-Moduls.  Sie können <code>sys.getrefcount(numbers)</code> , aber denken Sie daran, dass der Aufruf von <code>getrefcount()</code> den Referenzzähler um einen anderen erhöht. <br><br>  In jedem Fall, wenn das Objekt in Ihrem Code noch benötigt wird, ist sein Wert für seinen Referenzzähler größer als 0. Wenn es auf Null fällt, wird eine spezielle Funktion gestartet, um den Speicher zu löschen, wodurch es freigegeben und für andere Objekte verfügbar gemacht wird. <br><br>  Aber was bedeutet es, „Speicher freizugeben“ und wie verwenden andere Objekte ihn?  Lassen Sie uns direkt in die Speicherverwaltung in CPython eintauchen. <br><br>  <b>Speicherverwaltung in CPython</b> <br><br>  In diesem Teil werden wir uns mit der CPython-Speicherarchitektur und den Algorithmen befassen, mit denen sie arbeitet. <br><br>  Wie bereits erwähnt, gibt es Abstraktionsstufen zwischen physischer Ausrüstung und CPython.  Das Betriebssystem abstrahiert den physischen Speicher und erstellt eine Ebene des virtuellen Speichers, auf die Anwendungen, einschließlich Python, zugreifen können. <br><br>  Ein betriebssystemorientierter virtueller Speichermanager weist Python-Prozessen einen bestimmten Speicherbereich zu.  Im Bild sind die dunkelgrauen Bereiche der Raum, den der Python-Prozess einnimmt. <br><br><img src="https://habrastorage.org/webt/6k/-f/n6/6k-fn6hhelja1ilktfil1yzmaas.png"><br><br>  Python verwendet einen Teil des Speichers für den internen Gebrauch und für Nicht-Objektspeicher.  Der andere Teil gliedert sich in die Speicherung von Objekten (Ihr <i>Int, Diktat</i> usw.). Jetzt spreche ich in einer sehr einfachen Sprache. Sie können jedoch direkt unter die Haube schauen, <a href="">dh</a> in den <a href="">Quellcode von CPython</a> und sehen, wie dies alles aus praktischer Sicht geschieht . <br><br>  In CPython gibt es einen Objektzuweiser, der für die Zuweisung von Speicher innerhalb eines Objektspeicherbereichs verantwortlich ist.  In diesem Vertreiber von Objekten wird alle Magie ausgeführt.  Es wird jedes Mal aufgerufen, wenn jedes neue Objekt Speicher belegen oder freigeben muss. <br><br>  Normalerweise werden beim Hinzufügen und Entfernen von Daten in Python, wie z. B. int oder list, nicht viele Daten gleichzeitig verwendet.  Aus diesem Grund konzentriert sich die Architektur des Spenders auf die Arbeit mit kleinen Datenmengen pro Zeiteinheit.  Außerdem weist er Speicher nicht im Voraus zu, dh bis zu diesem Moment, bis er absolut notwendig wird. <br><br>  Die Kommentare im Quellcode definieren den Allokator als "einen speziellen Schnellspeicher-Allokator, der wie die universelle Malloc-Funktion funktioniert".  Dementsprechend wird in C malloc verwendet, um Speicher zuzuweisen. <br><br>  Schauen wir uns nun die Speicherzuweisungsstrategie von CPython an.  Lassen Sie uns zunächst über die drei Hauptteile und ihre Beziehung zueinander sprechen. <br><br>  Arenen sind die größten Speicherbereiche, die bis zum Rand der Seiten im Speicher Platz beanspruchen.  Der Seitenrand (Seitenverteilung) ist der äußerste Punkt eines fortlaufenden Speicherblocks mit fester Länge, der vom Betriebssystem verwendet wird.  Python setzt den Seitenrahmen des Systems auf 256 KB. <br><br><img src="https://habrastorage.org/webt/cu/t2/ta/cut2ta8lwor00zy8h5k8ogjjhgy.png"><br><br>  Innerhalb der Arenen befinden sich Pools (Pools), die als eine virtuelle Speicherseite (4 KB) betrachtet werden.  Sie sehen aus wie Seiten in unserer Analogie.  Pools sind in noch kleinere Speicherblöcke unterteilt. <br><br>  Alle Blöcke im Pool befinden sich in einer „Größenklasse“.  Die Größenklasse bestimmt die Größe des Blocks mit einer bestimmten Menge angeforderter Daten.  Die Abstufung in der folgenden Tabelle stammt direkt aus den Kommentaren im Quellcode: <br><br><img src="https://habrastorage.org/webt/n9/sk/55/n9sk55ex-esbcfdnnxhavivbeta.png"><br><br>  Wenn beispielsweise 42 Bytes benötigt werden, werden die Daten in einem 48-Byte-Block abgelegt. <br><br>  <b>Pools</b> <br><br>  Pools bestehen aus Blöcken derselben Größenklasse.  Jeder Pool arbeitet nach dem Prinzip einer doppelt verknüpften Liste mit anderen Pools derselben Größenklasse.  Daher kann der Algorithmus selbst unter vielen Pools leicht den erforderlichen Platz für die erforderliche Blockgröße finden. <br><br>  In der <code>usedpools list</code> der verwendeten Pools werden alle Pools <code>usedpools list</code> , in denen für Daten jeder Größenklasse freier Speicherplatz verfügbar ist.  Wenn die erforderliche Blockgröße angefordert wird, überprüft der Algorithmus die Liste der verwendeten Pools, um einen geeigneten Pool dafür zu finden. <br><br>  Pools befinden sich in drei Zuständen: verwendet, voll, leer.  Der verwendete Pool enthält Blöcke, in die einige Informationen geschrieben werden können.  Die Blöcke des vollständigen Pools sind alle verteilt und enthalten bereits Daten.  Leere Pools enthalten keine Daten und können bei Bedarf in geeignete Größenklassen unterteilt werden. <br><br>  Die Liste der leeren Pools ( <code>freepools list</code> ) enthält jeweils alle Pools in einem leeren Zustand.  Aber ab wann werden sie eingesetzt? <br><br>  Angenommen, Ihr Code benötigt einen Speicherbereich von 8 Byte.  Wenn die Liste der verwendeten Pools mit einer Klassengröße von 8 Byte keine Pools enthält, wird ein neuer leerer Pool als Speicherblock mit 8 Byte initialisiert.  Anschließend wird der leere Pool zur Liste der verwendeten Pools hinzugefügt und kann in den folgenden Abfragen verwendet werden. <br><br>  Ein vollständiger Pool gibt einige Blöcke frei, wenn diese Informationen nicht mehr benötigt werden.  Dieser Pool wird der Liste entsprechend seiner Größenklasse hinzugefügt.  Sie können beobachten, wie die Pools ihre Zustände und sogar Größenklassen gemäß dem Algorithmus ändern. <br><br>  <b>Blöcke</b> <br><br><img src="https://habrastorage.org/webt/p4/y1/_v/p4y1_v_kaiwweb9eut_gl3boybg.png"><br><br>  Wie aus der Abbildung ersichtlich ist, enthalten die Pools Zeiger auf freie Speicherblöcke.  Ihre Arbeit weist eine leichte Nuance auf.  Laut den Kommentaren im Quellcode bemüht sich der Distributor, „niemals einen Speicherbereich auf einer der Ebenen (Arena, Pool, Block) zu berühren, bis er benötigt wird“. <br><br>  Dies bedeutet, dass ein Block drei Zustände haben kann.  Sie können wie folgt definiert werden: <br><br><ul><li>  <b>Unberührt</b> : Speicherbereiche, die nicht zugewiesen wurden; </li><li>  <b>Frei</b> : Speicherbereiche, die zugewiesen, aber später von CPython freigegeben wurden, weil sie keine relevanten Informationen enthielten. </li><li>  <b>Verteilt</b> : Speicherbereiche, die derzeit aktuelle Informationen enthalten. </li></ul><br>  Der Freeblock-Zeiger ist eine einfach verknüpfte Liste von Free-Memory-Blöcken.  Mit anderen Worten, dies ist eine Liste von freien Stellen, an denen Sie Informationen schreiben können.  Wenn mehr Speicher benötigt wird als in freien Blöcken vorhanden ist, verwendet der Allokator die unberührten Blöcke im Pool. <br><br>  Sobald der Speichermanager Blöcke freigibt, werden diese Blöcke am Anfang der Liste der freien Blöcke hinzugefügt.  Die tatsächliche Liste enthält möglicherweise keine fortlaufende Folge von Speicherblöcken, wie in der ersten „erfolgreichen“ Abbildung. <br><br><img src="https://habrastorage.org/webt/cj/7g/d-/cj7gd-xeci1k_d0qwexo8zarr5y.png"><br><br>  <b>Arenen</b> <br><br>  Arenen enthalten Pools.  Arenen haben im Gegensatz zu Pools keine expliziten staatlichen Unterteilungen. <br><br>  Sie selbst sind in einer doppelt verknüpften Liste organisiert, die als Liste der verwendbaren Arenen (usable_arenas) bezeichnet wird.  Diese Liste ist nach der Anzahl der freien Pools sortiert.  Je weniger freie Pools, desto näher steht die Arena ganz oben auf der Liste. <br><br><img src="https://habrastorage.org/webt/4e/1f/fl/4e1ffl6eisaila8c1zxsmh3fc_m.png"><br><br>  Dies bedeutet, dass die vollständigste Arena ausgewählt wird, um noch mehr Daten aufzuzeichnen.  Aber warum genau?  Warum nicht Daten dorthin schreiben, wo der größte freie Speicherplatz vorhanden ist? <br><br>  Dies bringt uns zu der Idee, das Gedächtnis vollständig freizugeben.  Tatsache ist, dass in einigen Fällen, wenn Speicher freigegeben wird, für das Betriebssystem immer noch kein Zugriff möglich ist.  Der Python-Prozess hält es verteilt und verwendet es später für neue Daten.  Die Freigabe des vollen Speichers gibt den Speicher an das Betriebssystem zurück. <br><br>  Arenen sind nicht die einzigen Bereiche, die vollständig geräumt werden können.  Wir verstehen daher, dass die Arenen, die auf der Liste „näher an der Leere“ stehen, freigegeben werden sollten.  In diesem Fall kann der Speicherbereich wirklich vollständig freigegeben werden, und dementsprechend wird die Gesamtspeicherkapazität Ihres Python-Programms reduziert. <br><br>  <b>Fazit</b> <br><br>  Die Speicherverwaltung ist einer der wichtigsten Teile bei der Arbeit mit einem Computer.  Auf die eine oder andere Weise führt Python praktisch alle seine Operationen im Stealth-Modus aus. <br><br>  Aus diesem Artikel haben Sie gelernt: <br><br><ul><li>  Was ist Speicherverwaltung und warum ist sie wichtig? </li><li>  Was ist CPython, eine grundlegende Python-Implementierung? </li><li>  Wie Datenstrukturen und Algorithmen in der Speicherverwaltung von CPython funktionieren und Ihre Daten speichern. </li></ul><br>  Python abstrahiert die vielen Nuancen der Arbeit mit einem Computer.  Dies ermöglicht es, auf einer höheren Ebene zu arbeiten und die Kopfschmerzen beim Thema, wo und wie Bytes Ihres Programms gespeichert werden, loszuwerden. <br><br>  Also haben wir in Python etwas über Speicherverwaltung gelernt.  Traditionell warten wir auf Ihre Kommentare und laden Sie zu einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tag</a> der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offenen Tür</a> in den Python Developer-Kurs ein, der am 13. März stattfinden wird </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de443312/">https://habr.com/ru/post/de443312/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de443302/index.html">Wie Apple sich auf eine Ära nach dem iPhone vorbereitet</a></li>
<li><a href="../de443304/index.html">Technophobie ist sinnlos, auch wenn Technophobie gerechtfertigt ist</a></li>
<li><a href="../de443306/index.html">Acht Namensgesetze im UX-Design (Teil 1)</a></li>
<li><a href="../de443308/index.html">Mythen der modernen Physik. Naturschutzgesetze</a></li>
<li><a href="../de443310/index.html">Bellabeat Frauen Wellness Gadget Bewertung</a></li>
<li><a href="../de443314/index.html">Was ist Herzlichkeit? [Übersetzung des Artikels]</a></li>
<li><a href="../de443316/index.html">ReactJS-Test: Wie tief das Kaninchenloch ist</a></li>
<li><a href="../de443318/index.html">Schreiben eines Wasm Loader für Ghidra. Teil 1: Problemstellung und Einrichtung der Umgebung</a></li>
<li><a href="../de443320/index.html">Elektronisches Dokumentenmanagementsystem "Vizier"</a></li>
<li><a href="../de443322/index.html">GitLab 11.8 veröffentlicht mit SAST für JavaScript, GitLab Pages für Untergruppen und Bug Tracking</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>