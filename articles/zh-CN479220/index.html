<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤚🏼 🔌 ⬆️ Nano-neuron-7个简单的JavaScript函数，显示机器如何“学习” 🧐 🌸 😾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="纳米神经元是神经网络概念的简化版本。 纳米神经元执行最简单的任务，并受过训练，可以将温度从摄氏温度转换为华氏温度。 


 NanoNeuron.js代码由7个简单的JavaScript函数组成，这些函数涉及模型信号的学习，训练，预测以及正向和反向传播。 编写这些功能的目的是为读者提供有关机器如何能...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nano-neuron-7个简单的JavaScript函数，显示机器如何“学习”</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479220/"><p>  <a href="https://github.com/trekhleb/nano-neuron" rel="nofollow"><strong>纳米神经元</strong></a>是神经网络概念的<em>简化</em>版本。 纳米神经元执行最简单的任务，并受过训练，可以将温度从摄氏温度转换为华氏温度。 </p><br><p>  <a href="" rel="nofollow"><strong>NanoNeuron.js</strong></a>代码由7个简单的JavaScript函数组成，这些函数涉及模型信号的学习，训练，预测以及正向和反向传播。 编写这些功能的目的是为读者提供有关机器如何能够“学习”的最少的基本解释（直觉）。 该代码不使用第三方库。 俗话说，只有简单的“香草” JavaScript函数。 </p><br><p> 这些功能<strong>绝不是</strong>机器学习的详尽指南。 许多机器学习概念缺失或简化了！ 简化的唯一目的是使读者对机器如何在原理上“学习”有<strong>最基本的</strong>了解和直觉，因此，“机器学习的魔力”对读者来说越来越像“机器学习的数学”。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/98d/6c4/69e/98d6c469e1facbf97154fe29f698cd12.png" alt="纳米神经元"></p><a name="habracut"></a><br><h2 id="chto-vyuchit-nash-nano-neyron"> 我们的纳米神经元将“学习”什么 </h2><br><p> 您可能听说过<a href="https://ru.wikipedia.org/wiki/%25D0%2598%25D1%2581%25D0%25BA%25D1%2583%25D1%2581%25D1%2581%25D1%2582%25D0%25B2%25D0%25B5%25D0%25BD%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BD%25D0%25B5%25D0%25B9%25D1%2580%25D0%25BE%25D0%25BD%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2581%25D0%25B5%25D1%2582%25D1%258C" rel="nofollow">神经网络</a>中的<a href="https://ru.wikipedia.org/wiki/%25D0%2598%25D1%2581%25D0%25BA%25D1%2583%25D1%2581%25D1%2581%25D1%2582%25D0%25B2%25D0%25B5%25D0%25BD%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BD%25D0%25B5%25D0%25B9%25D1%2580%25D0%25BE%25D0%25BD%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2581%25D0%25B5%25D1%2582%25D1%258C" rel="nofollow">神经元</a> 。 纳米神经元是同一神经元的简化版本。 在此示例中，我们将从头开始编写其实现。 为简单起见，我们不会建立纳米神经元网络。 我们将专注于创建单个纳米神经元，并尝试教他如何将温度从摄氏温度转换为华氏温度。 换句话说，我们将教他基于摄氏温度来<strong>预测</strong>华氏温度。 </p><br><p> 顺便说一下，将摄氏度转换为华氏度的公式如下： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/9fa/2e8/8b5/9fa2e88b5a7324c8b9fc359b274ba091.png" alt="天鹅到华氏度"></p><br><p> 但是目前，我们的纳米神经元对此公式一无所知... </p><br><h3 id="model-nano-neyrona"> 纳米神经元模型 </h3><br><p>首先创建一个描述纳米神经元模型的函数。 该模型是<code>x</code>和<code>y</code>之间的简单线性关系，如下所示： <code>y = w * x + b</code> 。 简而言之，我们的纳米神经元是可以在<code>XY</code>坐标系中绘制直线的孩子。 </p><br><p> 变量<code>w</code>和<code>b</code>是模型<strong>参数</strong> 。 纳米神经元仅知道线性函数的这两个参数。 这些参数正是我们的纳米神经元将在训练过程中学习的参数。 </p><br><p> 纳米神经元在此阶段唯一可以做的就是模拟线性关系。 他在<code>predict()</code>方法中执行此操作，该方法在输入处获取变量<code>x</code> ，并在输出处预测变量<code>y</code> 。 没魔术 </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NanoNeuron</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">w, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.w = w; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.b = b; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.predict = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.w + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.b; } }</code> </pre> <br><p>  _（...等等... <a href="https://en.wikipedia.org/wiki/Linear_regression" rel="nofollow">线性回归</a>是您还是什么？）_ </p><br><h3 id="konvertaciya-gradusov-celsiya-v-gradusy-farengeyta"> 将摄氏度转换为华氏度 </h3><br><p> 可以根据以下公式将以摄氏度为单位的温度转换为华氏度： <code>f = 1.8 * c + 32</code> ，其中<code>c</code>是以摄氏度为单位的温度， <code>f</code>是以华氏度为单位的温度。 </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">celsiusToFahrenheit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">c</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> w = <span class="hljs-number"><span class="hljs-number">1.8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-number"><span class="hljs-number">32</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> f = c * w + b; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f; };</code> </pre> <br><p> 结果，我们希望纳米神经元能够模拟这一特定功能。 他将不得不猜测（学习）参数<code>w = 1.8</code>和<code>b = 32</code>而无需事先知道。 </p><br><p> 这就是转换函数在图表上的外观。 这就是我们的纳米神经“婴儿”必须学会“吸引”的东西： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/68b/0d6/8bc/68b0d68bcc7be00ec9526867b2fcecf3.png" alt="摄氏到华氏转换"></p><br><h3 id="generirovanie-dannyh"> 资料产生 </h3><br><p> 在经典编程中，我们知道输入数据（ <code>x</code> ）和用于转换该数据的算法（参数<code>w</code>和<code>b</code> ），但是输出数据（ <code>y</code> ）是未知的。 使用已知算法基于输入来计算输出。 相反，在机器学习中，仅输入和输出数据（ <code>x</code>和<code>y</code> ）是已知的，但是从<code>x</code>切换到<code>y</code>的算法<code>y</code>未知的（参数<code>w</code>和<code>b</code> ）。 </p><br><p> 这就是我们现在要做的输入和输出的生成。 我们需要生成用于<strong>训练</strong>模型的数据和用于<strong>测试</strong>模型的数据。  <code>celsiusToFahrenheit()</code>辅助函数将帮助我们解决此问题。 每个训练和测试数据集都是<code>x</code>和<code>y</code>对的集合。 例如，如果<code>x = 2</code> ，则<code>y = 35,6</code> ，依此类推。 </p><br><blockquote> 在现实世界中，大多数数据很可能是<em>收集的</em>而不是<em>生成的</em> 。 例如，这样收集的数据可以是成对的“脸部照片”-&gt;“人的名字”的集合。 </blockquote><p> 我们将使用TRAINING数据集来训练我们的纳米神经元。 在他长大并能够自己做出决定之前，我们必须使用训练集中的“正确”数据来教他什么是“真”，什么是“假”。 </p><br><blockquote> 顺便说一句，这里明确地遵循了生活原则“入口处的垃圾-出口处的垃圾”。 如果纳米神经元对训练套件“撒谎”，将5°C转换为1000°F，则在多次迭代训练后，他会相信这一点，并将正确转换<strong>除</strong> 5°C <strong>以外的</strong>所有温度值。 我们需要非常谨慎，每天将训练数据加载到大脑神经网络中。 </blockquote><p> 分心。 让我们继续。 </p><br><p> 我们将使用TEST数据集来评估我们的纳米神经元的训练水平，并可以对他在训练期间未看到的新数据做出正确的预测。 </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateDataSets</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// xTrain -&gt; [0, 1, 2, ...], // yTrain -&gt; [32, 33.8, 35.6, ...] const xTrain = []; const yTrain = []; for (let x = 0; x &lt; 100; x += 1) { const y = celsiusToFahrenheit(x); xTrain.push(x); yTrain.push(y); } // xTest -&gt; [0.5, 1.5, 2.5, ...] // yTest -&gt; [32.9, 34.7, 36.5, ...] const xTest = []; const yTest = []; //   0.5    1,       //   ,       . for (let x = 0.5; x &lt; 100; x += 1) { const y = celsiusToFahrenheit(x); xTest.push(x); yTest.push(y); } return [xTrain, yTrain, xTest, yTest]; }</span></span></code> </pre> <br><h3 id="ocenka-pogreshnosti-predskazaniy"> 预测误差估计 </h3><br><p> 我们需要一个确定的指标（度量，数量，等级），以显示纳米神经元的预测与真实情况的接近程度。 换句话说，此数字/度量/功能应显示纳米神经元的正确与否。 就像在学校一样，学生的控制成绩为<code>5</code>或<code>2</code> 。 </p><br><p> 对于纳米神经元，其<code>y</code>的真实值与预测的预测值之间的误差（误差）将由以下公式产生： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/8d8/e50/ac1/8d8e50ac12d03614e65975f7b5d36931.png" alt="预测成本"></p><br><p> 从公式可以看出，我们将误差视为两个值之间的简单差异。 值彼此越接近，差异越小。 我们在这里使用平方来消除符号，因此最后<code>(1 - 2) ^ 2</code>等效于<code>(2 - 1) ^ 2</code> 。 除以<code>2</code>只是为了简化该函数的导数在信号反向传播的公式中的含义（下面对此有更多说明）。 </p><br><p> 在这种情况下，错误函数将如下所示： </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">predictionCost</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">y, prediction</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (y - prediction) ** <span class="hljs-number"><span class="hljs-number">2</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ie -&gt; 235.6 }</span></span></code> </pre> <br><h3 id="pryamoe-rasprostranenie-signala"> 直接信号传播 </h3><br><p> 通过我们的模型直接传播信号意味着要从<code>xTrain</code>和<code>yTrain</code>训练数据集中对所有对进行预测，并计算这些预测的平均误差（错误）。 </p><br><p> 我们只是让我们的纳米神经元“说出来”，使其做出预测（转换温度）。 同时，在这个阶段的纳米神经元可能是非常错误的。 预测误差的平均值将向我们显示当前模型与模型的真实距离。 此处的误差值非常重要，因为通过更改参数<code>w</code>和<code>b</code>并再次直接传播信号，我们可以评估我们的纳米神经元是否已通过新参数变得“更智能”。 </p><br><p> 纳米神经元的平均预测误差将使用以下公式执行： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/575/db3/e0a/575db3e0a0c872b29582147e41231344.png" alt="平均费用"></p><br><p> 其中<code>m</code>是训练副本的数量（在我们的例子中，我们有<code>100</code>数据对）。 </p><br><p> 这是我们可以在代码中实现的方法： </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forwardPropagation</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">model, xTrain, yTrain</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> m = xTrain.length; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> predictions = []; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cost = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; m; i += <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> prediction = nanoNeuron.predict(xTrain[i]); cost += predictionCost(yTrain[i], prediction); predictions.push(prediction); } <span class="hljs-comment"><span class="hljs-comment">//     . cost /= m; return [predictions, cost]; }</span></span></code> </pre> <br><h3 id="obratnoe-rasprostranenie-signala"> 信号反向传播 </h3><br><p> 现在我们知道我们的纳米神经元的预测是对还是错（基于误差的平均值），如何使预测更准确？ </p><br><p> 反向信号传播将对此有所帮助。 信号反向传播是评估纳米神经元的误差，然后调整其参数<code>w</code>和<code>b</code> ，以使整个训练数据集对纳米神经元的下一个预测变得更加精确。 </p><br><p> 这是机器学习变得神奇的地方。 这里的关键概念是<strong>函数</strong>的<strong>派生</strong> ，它显示了要达到函数的最小值（在我们的情况下为误差函数的最小值），我们需要采取什么大小步长和采取哪种方式。 </p><br><p> 训练纳米神经元的最终目标是找到误差函数的最小值（请参见上面的函数）。 如果我们能够找到<code>w</code>和<code>b</code>这样的值，它们的误差函数的平均值很小，那么这意味着我们的纳米中子能很好地应对以华氏度为单位的温度预测。 </p><br><p> 派生类是一个很大的主题，我们将不在本文中介绍。  <a href="https://www.mathsisfun.com/calculus/derivatives-introduction.html" rel="nofollow">MathIsFun</a>是一个很好的资源，可以提供对派生的基本了解。 </p><br><p> 我们必须从导数的本质中学习到的一件事，这将有助于我们理解信号的反向传播是如何定义的，根据定义，该函数在特定点<code>x</code>和<code>y</code>处的导数是该函数在<code>x</code>和<code>y</code>处的曲线的切线。 <code>y</code>并向<em>我们指示函数最小值的方向</em> 。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/66d/bfd/49a/66dbfd49aaf1ced48d7f6b5917fddb12.svg" alt="导数斜率"></p><br><p>  <em>图片取自<a href="https://www.mathsisfun.com/calculus/derivatives-introduction.html" rel="nofollow">MathIsFun</a></em> </p><br><p> 例如，在上图中，您看到在点<code>(x=2, y=4)</code>切线<code>(x=2, y=4)</code>斜率表明我们需要<code></code> <code></code>才能达到函数的最小值。 还要注意，切线的斜率越大，我们必须更快地移到最小点。 </p><br><p>  <code>averageCost</code>参数<code>w</code>和<code>b</code>平均误差函数<code>averageCost</code>的导数将如下所示： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/4cc/bda/ba1/4ccbdaba120c399c1528e2bc38cf0efd.png" alt="dW"></p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e02/0cb/125/e020cb125449849009a9f565a32ff46f.png" alt="分贝"></p><br><p> 其中<code>m</code>是训练副本的数量（在我们的例子中，我们有<code>100</code>数据对）。 </p><br><p>  <em>您可以在<a href="https://www.mathsisfun.com/calculus/derivatives-rules.html" rel="nofollow">此处</a>详细了解如何使用复杂函数的派生。</em> </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">backwardPropagation</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">predictions, xTrain, yTrain</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> m = xTrain.length; <span class="hljs-comment"><span class="hljs-comment">//           'w'  'b'. //      0. let dW = 0; let dB = 0; for (let i = 0; i &lt; m; i += 1) { dW += (yTrain[i] - predictions[i]) * xTrain[i]; dB += yTrain[i] - predictions[i]; } //    . dW /= m; dB /= m; return [dW, dB]; }</span></span></code> </pre> <br><h3 id="trenirovka-modeli"> 模型训练 </h3><br><p> 现在我们知道了如何针对所有训练数据（直接信号传播）估算纳米神经元模型预测的误差。 我们还知道如何调整纳米神经元模型的参数<code>w</code>和<code>b</code> （信号的反向传播）以提高预测的准确性。 问题是，如果仅对信号执行一次正向和反向传播，那么对于我们的模型来说，这不足以识别和学习训练数据中的依存关系和定律。 您可以将其与学生的一日游进行比较。 他/她必须日复一日，年复一年地定期上学，以便学习所有材料。 </p><br><p> 因此，我们必须多次<em>重复</em>信号<em>的</em>正向和反向传播。 这<code>trainModel()</code>函数的<code>trainModel()</code> 。 她就像我们的纳米神经元模型的“老师”： </p><br><ul><li> 她将花一些时间（ <code>epochs</code> ）与我们仍然愚蠢的纳米神经元，试图训练他， </li><li> 她将使用特殊书籍（ <code>xTrain</code>和<code>yTrain</code>数据集）进行培训， </li><li> 它鼓励我们的“学生”使用<code>alpha</code>参数更努力地（更快地）学习，该参数实质上控制了学习的速度。 </li></ul><br><p> 关于<code>alpha</code>参数的几句话。 这只是变量<code>dW</code>和<code>dB</code>的值的系数（乘数），我们在信号的反向传播期间进行了计算。 因此，导数向我们显示了误差函数最小值的方向（ <code>dW</code>和<code>dB</code>值的符号告诉我们）。 导数还向我们展示了我们需要多快才能朝函数的最小值移动（ <code>dW</code>和<code>dB</code>的绝对值告诉我们）。 现在，我们需要将步长乘以<code>alpha</code> ，以便将我们的方法的速度调整到最小（总步长）。 有时，如果我们对<code>alpha</code>使用较大的值，则步幅可能很大，以至于我们可以简单地跳过函数<em>的</em>最小值，从而跳过该函数。 </p><br><p> 类似于“老师”，她强迫我们的“纳米学生”学习的能力越强，他学习的速度就越快，但是，如果您用力对他施加压力，那么我们的“纳米学生”可能会感到精神崩溃，完全无动于衷，他根本不会学到任何东西。 </p><br><p> 我们将更新模型<code>w</code>和<code>b</code>的参数，如下所示： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c7b/db8/84f/c7bdb884f2a940d62332246cdbcb44bc.png" alt="w"></p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b57/622/0ab/b576220ab6515d44255ef56699077bab.png" alt="b"></p><br><p> 这就是训练本身的样子： </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trainModel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{model, epochs, alpha, xTrain, yTrain}</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     -.  . const costHistory = []; //    ()  for (let epoch = 0; epoch &lt; epochs; epoch += 1) { //   . const [predictions, cost] = forwardPropagation(model, xTrain, yTrain); costHistory.push(cost); //   . const [dW, dB] = backwardPropagation(predictions, xTrain, yTrain); //    -,    . nanoNeuron.w += alpha * dW; nanoNeuron.b += alpha * dB; } return costHistory; }</span></span></code> </pre> <br><h3 id="soberem-vse-funkcii-vmeste"> 将所有功能放在一起 </h3><br><p> 是时候一起使用所有以前创建的功能了。 </p><br><p> 创建纳米神经元模型的实例。 此刻，纳米神经元对参数<code>w</code>和<code>b</code>应该是什么一无所知。 因此，让我们随机设置<code>w</code>和<code>b</code> 。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> w = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random(); <span class="hljs-comment"><span class="hljs-comment">// ie -&gt; 0.9492 const b = Math.random(); // ie -&gt; 0.4570 const nanoNeuron = new NanoNeuron(w, b);</span></span></code> </pre> <br><p> 我们生成培训和测试数据集。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [xTrain, yTrain, xTest, yTest] = generateDataSets();</code> </pre> <br><p> 现在，让我们尝试使用小步长（ <code>0.0005</code> ）训练我们的模型<code>70000</code>时代。 您可以试验这些参数，它们是凭经验确定的。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> epochs = <span class="hljs-number"><span class="hljs-number">70000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> alpha = <span class="hljs-number"><span class="hljs-number">0.0005</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> trainingCostHistory = trainModel({<span class="hljs-attr"><span class="hljs-attr">model</span></span>: nanoNeuron, epochs, alpha, xTrain, yTrain});</code> </pre> <br><p> 让我们检查一下模型的误差值在训练过程中如何变化。 我们期望训练后的误差值应明显小于训练前的误差值。 这将意味着我们的纳米神经元更明智。 相反的选择也是可能的，当训练后，预测误差仅增加（例如，学习步骤<code>alpha</code>值较大）。 </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'  :'</span></span>, trainingCostHistory[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-comment"><span class="hljs-comment">// ie -&gt; 4694.3335043 console.log('  :', trainingCostHistory[epochs - 1]); // ie -&gt; 0.0000024</span></span></code> </pre> <br><p> 这是训练期间模型误差的值如何变化。  <code>x</code>轴上是历元（以千为单位）。 我们预计图表将下降。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/191/860/d6f/191860d6f0cd8cf7d24127f04f779462.png" alt="培训过程"></p><br><p> 让我们看看我们的纳米神经元“学习了”哪些参数。 我们希望参数<code>w</code>和<code>b</code>与<code>celsiusToFahrenheit()</code>函数中的同名参数相似（ <code>w = 1.8</code>和<code>b = 32</code> ），因为我试图模拟的是她的纳米神经元。 </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">' -:'</span></span>, {<span class="hljs-attr"><span class="hljs-attr">w</span></span>: nanoNeuron.w, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: nanoNeuron.b}); <span class="hljs-comment"><span class="hljs-comment">// ie -&gt; {w: 1.8, b: 31.99}</span></span></code> </pre> <br><p> 如您所见，纳米神经元非常接近<code>celsiusToFahrenheit()</code>函数。 </p><br><p> 现在，让我们看看我们的纳米神经元的预测对于他在训练期间未看到的测试数据的准确性如何。 测试数据的预测误差应接近训练数据的预测误差。 这将意味着纳米神经元已经学会了正确的依赖性，并且可以从以前未知的数据（这是模型的全部价值）中正确地提取其经验。 </p><br><pre> <code class="javascript hljs">[testPredictions, testCost] = forwardPropagation(nanoNeuron, xTest, yTest); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'   :'</span></span>, testCost); <span class="hljs-comment"><span class="hljs-comment">// ie -&gt; 0.0000023</span></span></code> </pre> <br><p> 现在，由于我们的“纳米婴儿”在“学校”中受过良好的训练，并且现在即使对于他看不见的数据，也知道如何将摄氏度准确转换为华氏度，因此我们可以称他为“聪明”。 现在我们甚至可以向他咨询温度转换方面的建议，这就是整个培训的目的。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tempInCelsius = <span class="hljs-number"><span class="hljs-number">70</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> customPrediction = nanoNeuron.predict(tempInCelsius); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`- "",  </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${tempInCelsius}</span></span></span><span class="hljs-string">°C   :`</span></span>, customPrediction); <span class="hljs-comment"><span class="hljs-comment">// -&gt; 158.0002 console.log('  :', celsiusToFahrenheit(tempInCelsius)); // -&gt; 158</span></span></code> </pre> <br><p> 很近！ 像人一样，我们的纳米神经元是好的，但不是完美的:) </p><br><p> 编码成功！ </p><br><h2 id="kak-zapustit-i-protestirovat-nano-neyron"> 如何运行和测试纳米神经元 </h2><br><p> 您可以克隆存储库并在本地运行纳米神经元： </p><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/trekhleb/nano-neuron.git <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> nano-neuron</code> </pre> <br><pre> <code class="bash hljs">node ./NanoNeuron.js</code> </pre> <br><h2 id="upuschennye-koncepcii"> 遗漏的概念 </h2><br><p> 为了便于说明，以下机器学习概念已被省略或简化。 </p><br><p>  <strong>分离训练和测试数据集</strong> </p><br><p> 通常，您只有一个大数据集。 根据该套中的份数，可以按70/30的比例将其分为训练和测试套。 集合中的数据必须先随机混合后才能拆分。 如果数据量很大（例如，数百万），则可以按接近90/10或95/5的比例划分测试集和训练集。 </p><br><p>  <strong>在线电源</strong> </p><br><p> 通常，仅使用一个神经元时，您不会找到病例。 力量在这种神经元的<a href="https://en.wikipedia.org/wiki/Neural_network" rel="nofollow">网络中</a> 。 神经网络可以学习更复杂的依赖关系。 </p><br><p> 同样在上面的示例中，我们的纳米神经元看起来更像是简单的<a href="https://en.wikipedia.org/wiki/Linear_regression" rel="nofollow">线性回归，而</a>不是神经网络。 </p><br><p>  <strong>输入归一化</strong> </p><br><p> 在训练之前，习惯<a href="https://www.jeremyjordan.me/batch-normalization/" rel="nofollow">上将输入数据标准化</a> 。 </p><br><p>  <strong>向量执行</strong> </p><br><p> 对于神经网络，矢量（矩阵）计算比<code>for</code>循环中的计算快得多。 通常，使用例如Python <a href="https://numpy.org/" rel="nofollow">Numpy</a>库的矩阵运算执行正向和反向信号传播。 </p><br><p>  <strong>最小误差函数</strong> </p><br><p> 我们用于纳米神经元的误差函数非常简化。 它应该包含<a href="https://stackoverflow.com/questions/32986123/why-the-cost-function-of-logistic-regression-has-a-logarithmic-expression/32998675" rel="nofollow">对数成分</a> 。 误差函数公式的改变也将导致信号向前和向后传播的公式的改变。 </p><br><p>  <strong>激活功能</strong> </p><br><p> 通常，神经元的输出值通过激活函数。 为了激活，可以使用诸如<a href="https://en.wikipedia.org/wiki/Sigmoid_function" rel="nofollow">Sigmoid</a> ， <a href="https://en.wikipedia.org/wiki/Rectifier_(neural_networks)" rel="nofollow">ReLU</a>和其他函数。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN479220/">https://habr.com/ru/post/zh-CN479220/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN479202/index.html">C ++和数值方法：近似牛顿-科茨积分</a></li>
<li><a href="../zh-CN479210/index.html">自2020年1月1日起，外国在线商店的购买将发生什么</a></li>
<li><a href="../zh-CN479214/index.html">莫斯科＃2开发人员即将到来的免费活动精选</a></li>
<li><a href="../zh-CN479216/index.html">第二次风Pandora DXL 3000或我如何固定自己的遥测</a></li>
<li><a href="../zh-CN479218/index.html">如何制作将照片转换为漫画书的机器人：傻瓜的分步说明</a></li>
<li><a href="../zh-CN479222/index.html">＃325移动开发人员的有趣材料摘要（12月2日至8日）</a></li>
<li><a href="../zh-CN479226/index.html">Habr分析：用户从Habr订购什么作为礼物</a></li>
<li><a href="../zh-CN479230/index.html">使用草率的注释记录您的Express API</a></li>
<li><a href="../zh-CN479232/index.html">Spring Boot上的MQ JMS应用程序开发</a></li>
<li><a href="../zh-CN479234/index.html">来自OpenStreetMap 488世界的新闻（11/19/2019-11/25/2019）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>