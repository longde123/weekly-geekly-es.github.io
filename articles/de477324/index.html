<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíà üöã üóæ Warum Sie sich f√ºr den PVS-Studio Static Analyzer entscheiden sollten, um ihn in Ihren Entwicklungsprozess zu integrieren ‚úãüèº üëñ üéå</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="PVS-Studio ist ein Tool zum Erkennen von Fehlern und potenziellen Schwachstellen im Quellcode von Programmen, die in C, C ++, C # oder Java geschriebe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Warum Sie sich f√ºr den PVS-Studio Static Analyzer entscheiden sollten, um ihn in Ihren Entwicklungsprozess zu integrieren</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/477324/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b8/b57/a2f/6b8b57a2fb64b484b201b2d8cba6cabb.png" alt="Warum Sie sich f√ºr den PVS-Studio Static Analyzer entscheiden sollten, um ihn in Ihren Entwicklungsprozess zu integrieren"></div><br>  PVS-Studio ist ein Tool zum Erkennen von Fehlern und potenziellen Schwachstellen im Quellcode von Programmen, die in C, C ++, C # oder Java geschrieben wurden, sowie ein SAST-Tool (Static Application Security Testing).  Es soll als Teil der CI-Praxis verwendet werden und erm√∂glicht es dem Benutzer, Fehler in der fr√ºhesten Entwicklungsphase zu erkennen, bei der die Behebung fast nichts kostet. <br><a name="habracut"></a><br><h2>  Statische Code-Analyse </h2><br>  W√§hrend sich Softwareprojekte entwickeln, wachsen sie an Gr√∂√üe.  Vergleichen Sie: <br><br><ul><li>  Linux-Kernel 1.0.0: 176.000 LOC </li><li>  Linux-Kernel 5.0: 26.000.000 LOC </li><li>  Photoshop 1.0: 128.000 LOC </li><li>  Photoshop CS 6: 10.000.000 LOC </li></ul><br>  Wenn das Projekt w√§chst, w√§chst seine Komplexit√§t schneller als linear.  Dies erkl√§rt, warum die Fehlerdichte mit der Codebasis <a href="https://www.viva64.com/en/b/0158/">w√§chst</a> .  Eine M√∂glichkeit, die wachsende Komplexit√§t auszugleichen, besteht in der Verwendung statischer Code-Analysetools. <br><br>  Ein statischer Analysator ist ein Software-Tool, das vorl√§ufige Code√ºberpr√ºfungen durchf√ºhrt und auf Codefragmente hinweist, bei denen mit hoher Wahrscheinlichkeit Fehler auftreten.  Dies erm√∂glicht Entwicklern, die meisten Fehler in der fr√ºhesten Entwicklungsphase zu beheben, in der sie am billigsten zu beheben sind. <br><br>  <a href="https://www.viva64.com/en/t/0046/">Die statische Analyse</a> ersetzt andere Methoden zur <a href="https://www.viva64.com/en/t/0046/">Fehlererkennung</a> nicht, sondern erg√§nzt sie, z. B. Code√ºberpr√ºfung, Komponententests, dynamische Analysen, Regressionstests, manuelle Tests usw. <br><br>  Nehmen Sie zum Beispiel die Code√ºberpr√ºfung.  Ein viel besseres Szenario besteht darin, einen Software-Analysator die f√ºr Sie trivialsten Fehler finden zu lassen, damit Sie sich auf n√ºtzlichere allgemeine √úberpr√ºfungen des Algorithmus konzentrieren k√∂nnen, anstatt Vergleichsfunktionen herauszufinden - zumal, wie unsere <a href="https://www.viva64.com/en/b/0587/">Erfahrung</a> beweist, Das menschliche Auge ist schlecht darin, viele der Fehler zu bemerken, und es ist sehr wahrscheinlich, dass sie bei der Code√ºberpr√ºfung √ºbersehen werden. <br><br>  Ein weiterer Vorteil von statischen Analysewerkzeugen ist die umfangreiche Fehlermusterbasis.  Sie k√∂nnen Fehler finden, die viele Programmierer m√∂glicherweise gar nicht kennen, z. B. <a href="https://www.viva64.com/en/w/v698/">V698</a> , <a href="https://www.viva64.com/en/w/v718/">V718</a> , <a href="https://www.viva64.com/en/w/v1023/">V1023</a> . <br><br><h2>  PVS-Studio </h2><br>  Wir empfehlen PVS-Studio, einen von unserem Team entwickelten statischen Code-Analysator.  Es l√§uft auf 64-Bit-Windows-, Linux- und MacOS-Systemen und kann den Quellcode von Programmen f√ºr 32-Bit-, 64-Bit- und eingebettete ARM-Plattformen √ºberpr√ºfen. <br><br>  Zum jetzigen Zeitpunkt unterst√ºtzt der Analyzer die folgenden Sprachen und Compiler: <br><br><ul><li>  Windows  Visual Studio 2010-2019 C, C ++, C ++ / CLI, C ++ / CX (WinRT), C # </li><li>  Windows  IAR Embedded Workbench, C / C ++ - Compiler f√ºr ARM C, C ++ </li><li>  Windows  QNX Momentics, QCC C, C ++ </li><li>  Windows / Linux  Keil ¬µVision, DS-MDK, ARM Compiler 5/6 C, C ++ </li><li>  Windows / Linux  Texas Instruments Code Composer Studio, Tools zur ARM-Codegenerierung C, C ++ </li><li>  Windows / Linux / MacOS.  GNU Arm Embedded Toolchain, GCC-Compiler f√ºr Arm Embedded, C, C ++ </li><li>  Windows / Linux / MacOS.  Clang C, C ++ </li><li>  Linux / macOS.  GCC C, C ++ </li><li>  Windows  MinGW C, C ++ </li><li>  Windows / Linux / MacOS.  Java </li></ul><br>  Der Analysator wird mit einer ausf√ºhrlichen <a href="https://www.viva64.com/en/m/">Dokumentation</a> in Englisch und Russisch geliefert.  Die Beschreibungen der Diagnoseregeln enthalten Beispiele f√ºr richtigen und falschen Code.  Sie enthalten auch Links zu Codeausschnitten aus echten Open-Source-Programmen. <br><br>  F√ºr die Spezialisten, die PVS-Studio als <a href="https://www.viva64.com/en/sast/">SAST-Tool verwenden</a> , werden die Diagnosen den Standards Common Weakness Enumeration, SEI CERT Coding und MISRA zugeordnet.  Hier sind die Zuordnungstabellen der PVS-Studio-Diagnose zu verschiedenen Standards: <br><br><ul><li>  <a href="https://www.viva64.com/en/cwe/">CWE-Zuordnung</a> </li><li>  <a href="https://www.viva64.com/en/cwe/">SEI Cert Mapping</a> </li><li>  <a href="https://www.viva64.com/en/cwe/">Misra-Mapping</a> </li></ul><br>  Der Analyzer kann sowohl als eigenst√§ndiges Tool als auch als Plugin f√ºr Visual Studio und IntelliJ IDEA verwendet werden.  Einige unserer Kunden haben in letzter Zeit auch PVS-Studio als Teil von SonarQube verwendet.  Bei Verwendung als <a href="https://www.viva64.com/en/m/0037/">Plugin</a> f√ºr SonarQube bietet der Analyzer zus√§tzliche Diagnosemeldungen. <br><br>  Wir haben eine Reihe von Szenarien f√ºr die Verwendung von PVS-Studio mit CI-Systemen entwickelt.  Da das Beobachten aller Szenarien au√üerhalb des Geltungsbereichs dieses Artikels liegt, lesen Sie bitte die Dokumentation.  Hier sind nur ein paar Links, die Ihnen einen allgemeinen Eindruck vermitteln: <br><br><ul><li>  <a href="https://www.viva64.com/en/b/0670/">PVS-Studio in den Wolken: Azure DevOps</a> </li><li>  <a href="https://www.viva64.com/en/b/0636/">PVS-Studio in den Wolken: Travis CI</a> </li><li>  <a href="https://www.viva64.com/en/b/0676/">PVS-Studio in den Wolken: CircleCI</a> </li><li>  <a href="https://www.viva64.com/en/b/0686/">PVS-Studio in den Wolken: GitLab CI / CD</a> </li><li>  <a href="https://www.viva64.com/en/m/0048/">Ausf√ºhren von PVS-Studio in Jenkins</a> </li><li>  <a href="https://www.viva64.com/en/b/0567/">Funktionen der PVS-Studio-Einstellung und der Ausf√ºhrung in Docker am Beispiel des Azure Service Fabric-Codes</a> </li></ul><br>  PVS-Studio erkennt effektiv eine Vielzahl von Fehlern, von <a href="https://www.viva64.com/en/b/0260/">Tippfehlern</a> bis hin zu <a href="https://www.viva64.com/en/b/0543/">Speicherlecks</a> .  Dies ist dank der Datenflussanalyse, der symbolischen Ausf√ºhrung, des Mustervergleichs und der Annotation von Methoden (einschlie√ülich automatisierter Annotation) m√∂glich.  Weitere Informationen zu den Funktionsprinzipien des Analysators finden Sie im Artikel " <a href="https://www.viva64.com/en/b/0592/">Im PVS-Studio-Code-Analysator verwendete Technologien zum Auffinden von Fehlern und potenziellen Schwachstellen</a> ". <br><br><h2>  Warum sollten Sie PVS-Studio verwenden? </h2><br>  Durch die Integration von PVS-Studio in Ihren Entwicklungsprozess werden viele der zu behebenden Fehler billiger. Dadurch sparen Sie Zeit, die Sie in die Implementierung einer neuen Funktion oder die Durchf√ºhrung gr√ºndlicherer Tests auf hoher Ebene investieren k√∂nnen. <br><br>  Bei regelm√§√üiger Verwendung hilft Ihnen der Analyzer, die Codequalit√§t zu verbessern und die Wartung zu vereinfachen.  Regelm√§√üige Fehlerbehebung und das Schreiben von qualitativ hochwertigem Code machen ihn weniger anf√§llig f√ºr Zero-Day-Schwachstellen.  Dieses Thema wird im Artikel " <a href="https://www.viva64.com/en/b/0514/">Wie kann PVS-Studio beim Erkennen von Sicherheitsl√ºcken helfen?</a> " <a href="https://www.viva64.com/en/b/0514/">N√§her</a> erl√§utert. <br><br>  PVS-Studio ist am kosteng√ºnstigsten, wenn es von Teams mit f√ºnf oder mehr Mitgliedern verwendet wird.  Die ROI-Sch√§tzung finden Sie im Artikel " <a href="https://www.viva64.com/en/b/0606/">PVS-Studio ROI</a> ". <br><br>  PVS-Studio in Projekte zu integrieren, die von ein paar Enthusiasten entwickelt wurden, w√§re wahrscheinlich unpraktisch, aber auch kleine Projekte k√∂nnen davon profitieren - zumal wir <a href="https://www.viva64.com/en/b/0614/">kostenlose</a> Lizenzoptionen f√ºr Studenten, Open Source-Entwickler usw. anbieten. <br><br>  Unsere <a href="https://www.viva64.com/en/customers/">Neukunden</a> erwerben in der Regel eine einj√§hrige Lizenz.  Nach Ablauf der G√ºltigkeitsdauer freuen sie sich bereits √ºber die Funktionen und den Benutzer-Support-Service unseres Analyseger√§ts und verl√§ngern die Lizenz um zwei oder drei Jahre, was viel billiger ist als die einj√§hrige Lizenz.  Hier k√∂nnen Sie die Preise erfragen und Ratschl√§ge zur Lizenzierung einholen. <br><br>  Werden Sie zu unseren Kunden und lassen Sie PVS-Studio Ihren Entwicklungsprozess reifer, das Beheben von Fehlern billiger und Ihren Code besser machen. <br><br>  Wir unterst√ºtzen Sie schnell und kompetent.  Ihre Fragen werden direkt von den Programmierern beantwortet, die die jeweiligen Module entwickeln.  Dies garantiert auch in den kompliziertesten Situationen eine Antwort.  Hier ist ein Beispiel: " <a href="https://www.viva64.com/en/b/0612/">False Positives in PVS-Studio: Wie tief das Kaninchenloch geht</a> ." <br><br><h2>  Auf Kritik antworten </h2><br>  Programmierer stehen der Idee, statische Code-Analyse in ihren Entwicklungsprozess einzubeziehen, mitunter ablehnend gegen√ºber und kritisieren die statische Analysemethode im Allgemeinen oder PVS-Studio im Besonderen.  Wenn Sie anfangen, tiefer zu graben, stellt sich heraus, dass ihre Kritik unbegr√ºndet ist und einfach das Ergebnis ihrer Zur√ºckhaltung ist, irgendetwas im etablierten Entwicklungsprozess zu √§ndern.  Mal sehen, welche typischen Argumente daf√ºr sprechen, die Situation, auf die sie zur√ºckgreifen, nicht zu √§ndern und was mit ihnen los ist. <br><br><h3>  "Die statische Analyse nimmt einen Teil Ihrer Arbeitszeit in Anspruch" </h3><br>  Aus dem Zusammenhang heraus ist die Aussage "die statische Analyse wird einen Teil Ihrer Arbeitszeit in Anspruch nehmen" wahr.  Es braucht Zeit, um die vom Analyseger√§t ausgegebenen Warnungen regelm√§√üig auf neu geschriebenen oder ge√§nderten Code zu √ºberpr√ºfen.  Aber diese Idee muss fortgesetzt werden: "Aber sie wird viel weniger Zeit in Anspruch nehmen als andere Methoden zur Fehlererkennung." <br><br>  Warum glauben die Leute, dass die Pr√ºfung des Berichts eines statischen Analysators zeitaufw√§ndig ist? <br><br>  Diejenigen Programmierer, die noch nicht mit der Codeanalyse vertraut sind, verwechseln einmalige Testl√§ufe und die regelm√§√üige Verwendung.  Bei der ersten Ausf√ºhrung gibt jedes Analyseger√§t eine gro√üe Liste von Warnungen mit einer hohen Rate an Fehlalarmen aus.  Dies geschieht, weil das Tool noch nicht angepasst wurde.  Mit den Einstellungen, die genau auf Ihre Bed√ºrfnisse abgestimmt sind, werden Sie nicht viele Fehlalarme sehen, wenn Sie den Analysator regelm√§√üig ausf√ºhren.  Mit anderen Worten, bei regelm√§√üiger Verwendung werden die meisten Diagnosen des Analyseger√§ts echte Fehler oder Geruchscodes erkennen.  Sie m√ºssen nur diese Anpassungen vornehmen. <br><br>  Der Artikel " <a href="https://www.viva64.com/en/b/0669/">Umgang mit Einw√§nden: Statische Analyse nimmt einen Teil der Arbeitszeit in Anspruch</a> " behandelt das Thema. <br><br><h3>  "Statische Analyseger√§te erzeugen zu viel Rauschen (dh zu viele falsche Positive)" </h3><br>  Auch diese Aussage trifft zu, wenn Sie das Tool nicht richtig angepasst haben.  Sobald Sie die Einstellungen von PVS-Studio nach Bedarf angepasst haben, k√∂nnen Sie damit rechnen, dass die False-Positives-Rate auf 10-20% sinkt.  Das hei√üt, von f√ºnf Warnungen verweisen vier auf echte Fehler oder Code, der in Zukunft sehr wahrscheinlich zur Fehlerquelle werden wird.  Der Artikel " <a href="https://www.viva64.com/en/b/0523/">Eigenschaften des PVS-Studio Analyzers am Beispiel von EFL-Core-Bibliotheken, 10-15% von False Positives</a> " zeigt ein Beispiel f√ºr die Anpassung des Analyzers. <br><br>  Eine weitere Ursache f√ºr Missverst√§ndnisse ist die Versuchung, so viele Diagnosen wie m√∂glich zu aktivieren, ohne deren genauen Zweck zu kennen.  Wenn Sie beispielsweise den f√ºr eingebettete Systeme entwickelten MISRA-Regelsatz aktivieren, generiert der Analyzer beim √úberpr√ºfen einer klassischen Windows-Anwendung Hunderttausende von Warnungen, von denen keine f√ºr Sie von Nutzen ist.  Eine irrelevante Diagnose ist besonders sch√§dlich, wenn Sie erst mit dem Tool beginnen, da Sie m√∂glicherweise einen falschen Eindruck von den Diagnosefunktionen des Tools bekommen.  Der Artikel " <a href="https://www.viva64.com/en/b/0633/">Wie Sie die interessanten Warnungen des PVS-Studio-Analysators f√ºr C- und C ++ - Code schnell √ºberpr√ºfen k√∂nnen</a> " hilft Ihnen dabei, Entt√§uschungen zu vermeiden. <br><br><h3>  "Die Integration der statischen Analyse in den Entwicklungsprozess ist in Bezug auf Aufwand, Zeit und Geld zu kostspielig." </h3><br>  Dieses Anliegen wird durch den folgenden Kommentar anschaulich veranschaulicht: <br><br>  <i>Leider sind statische Analyseger√§te selbst nichts anderes als Spielzeug.</i>  <i>Es ist eine verdammt schwere Aufgabe, sie in Ihren Routinearbeitsprozess einzubeziehen, und einige Mitarbeiter m√ºssen die Analyseergebnisse untersuchen und filtern.</i>  <i>Jeder Versuch, diese Belastung auf normale Entwickler zu √ºbertragen, ist normalerweise erfolglos.</i> <br><br>  Es ist nicht so schrecklich.  Es gibt mindestens drei Vorgehensweisen, um statische Analysen reibungslos in gro√üe alte Projekte zu integrieren. <br><br>  <b>√úbung 1.</b> "Ratcheting", was Ivan Ponomarev in seinem Artikel " <a href="https://habr.com/en/post/440610/">Statische Analyse in den Prozess einf√ºhren, nicht nur nach</a> Fehlern suchen" gut erkl√§rt. <br><br>  <b>√úbung 2.</b> Um unseren Benutzern einen schnellen Einstieg zu erm√∂glichen, empfehlen wir die Verwendung der " <a href="https://www.viva64.com/en/m/0032/">Unterdr√ºckungsbasis</a> ".  Kurz gesagt, die Idee ist, dass Sie den Analysator ausf√ºhren und mehrere Warnungen erhalten.  Da sich das Projekt seit vielen Jahren in der Entwicklung befindet und noch lebt, sich weiterentwickelt und profitabel ist, werden Sie wahrscheinlich nicht viele Warnungen erhalten, die auf kritische M√§ngel hinweisen.  Mit anderen Worten, die meisten kritischen Fehler wurden bereits mit anderen - teureren - Mitteln oder als Reaktion auf das Feedback der Benutzer behoben.  In diesem Fall k√∂nnen alle Fehler, die bei der ersten √úberpr√ºfung gefunden wurden, als technische Schulden angesehen werden, deren sofortige Behebung unvern√ºnftig w√§re. <br><br>  Sie k√∂nnen PVS-Studio anweisen, diese Warnungen als irrelevant zu behandeln (wodurch die Aufl√∂sung der technischen Schulden auf einen sp√§teren Zeitpunkt verschoben wird) und sie nicht erneut anzuzeigen.  Der Analysator erstellt eine spezielle Datei, in der die Informationen zu derzeit irrelevanten Fehlern gespeichert werden, und gibt Warnungen nur f√ºr frisch geschriebenen oder ge√§nderten Code aus.  Der Mechanismus ist ziemlich schlau.  Wenn Sie beispielsweise am Anfang einer CPP-Datei eine leere Zeile einf√ºgen, erkennt der Analysator, dass diese Zeile keinen Unterschied macht, und schweigt.  Die Unterdr√ºckungsdatei kann versionsgesteuert sein.  Es ist gro√ü, aber es spielt keine Rolle, da Sie es nicht oft versionieren m√ºssen. <br><br>  Danach erh√§lt jeder Programmierer in Ihrem Team nur die Warnungen, die durch frisch geschriebenen oder ge√§nderten Code ausgel√∂st werden.  Ab dem n√§chsten Tag k√∂nnen Sie den Analysator als Teil Ihrer Routinearbeit verwenden.  Die technischen Probleme k√∂nnen Sie sp√§ter beheben und die Einstellungen des Analyseger√§ts nach und nach anpassen. <br><br>  <b>√úbung 3.</b> Sie k√∂nnen die Aufgabe des Aufbaus und der Integration von PVS-Studio an unser Team delegieren, indem Sie einen Vertrag mit uns abschlie√üen.  Ein Beispiel f√ºr diese Vorgehensweise ist im Artikel " <a href="https://www.viva64.com/en/b/0330/">Wie das PVS-Studio-Team den Code der Unreal Engine verbesserte</a> " beschrieben. <br><br><h3>  "Wir haben den Analysator gestartet, aber nichts Interessantes gefunden" </h3><br>  Dieses Szenario ist durchaus m√∂glich, bedeutet jedoch nicht, dass der Analysator nicht von Nutzen sein wird.  Das Problem ist, dass die Fehler bereits mit anderen, teureren Mitteln gefunden und behoben wurden.  Es ist, als w√ºrde man einen Text, der bereits von einer Reihe von Korrektoren gepr√ºft wurde, in Microsoft Word eingeben, um festzustellen, ob die integrierte Rechtschreibpr√ºfung etwas gefunden hat.  Es w√ºrde nur ein paar Fehler finden, wenn √ºberhaupt, aber das bedeutet nicht, dass die Rechtschreibpr√ºfung von Word beim Schreiben neuer Texte nutzlos ist. <br><br>  Dieses Thema wird im Artikel " <a href="https://www.viva64.com/en/b/0534/">Philosophie der statischen Codeanalyse: Wir haben 100 Entwickler, der Analyzer hat nur wenige Fehler gefunden, ist der Analyzer unbrauchbar?</a> " Ausf√ºhrlicher besprochen. <br><br><h3>  "Ein statischer Analysator ist ein teures Werkzeug.  Wir sollten einen zus√§tzlichen Programmierer / Tester engagieren ¬ª </h3><br>  Was dieses Argument wirklich sagt, ist, dass die Person nichts √§ndern will.  Immerhin ist ihr Team schon seit einiger Zeit gewachsen und stellt neue Programmierer und Tester ein, aber das hat nicht dazu beigetragen, einen ausgereifteren Entwicklungsprozess zu erreichen.  Trotzdem sollten wir dieses Argument noch n√§her erl√§utern. <br><br>  Erstens ist die Einstellung einer anderen Person f√ºr die Fehlersuche viel teurer als der Kauf eines statischen Analyseger√§ts.  Berechnen Sie einfach die j√§hrliche Gehaltsabrechnung des neuen Mitarbeiters und addieren Sie die Steuern und Abgaben beim Einrichten eines neuen Arbeitsbereichs.  In Anbetracht der sich daraus ergebenden Zahlen scheint das Argument, ein Software-Analyseger√§t sei zu teuer, √ºberhaupt kein Argument zu sein.  Au√üerdem nimmt ein statischer Analysator im Gegensatz zu Menschen keinen Urlaub, er erkrankt nicht und verl√§sst das Unternehmen nicht vollst√§ndig.  F√ºr ein gro√ües Team von beispielsweise 100 Mitarbeitern m√ºsste man nicht einen, sondern mehrere neue Mitarbeiter einstellen, um ein sp√ºrbares Ergebnis zu erzielen.  In diesem Fall ist der Kauf eines statischen Analysators eine noch g√ºnstigere L√∂sung. <br><br>  Zweitens wird das beste Ergebnis durch die Synergie zwischen verschiedenen in Kombination verwendeten Fehlererkennungstechniken erzielt.  Einige Fehler lassen sich besser durch Komponententests diagnostizieren, andere durch manuelle Tests und so weiter.  Stellen Sie sich vor, 10 Programmierer arbeiten an einem Projekt, mit vielen Unit-Tests, aber nicht einem einzigen Tester.  Die Benutzer sind mit der Qualit√§t des Projekts nicht zufrieden, daher sollten Sie einen Tester beauftragen, aber Sie tun dies nicht, weil "wir einen zus√§tzlichen Programmierer beauftragen sollten, damit es noch mehr Komponententests gibt!" kann man nicht eine weise Entscheidung nennen, oder?  In diesem Szenario ist der QS-Prozess offensichtlich einbeinig und w√ºrde nur durch Hinzuf√ºgen manueller Tests verbessert.  Gleiches gilt f√ºr die statische Analyse. <br><br><h3>  "Dynamische Analyse ist besser als statische Analyse" </h3><br>  Einige Fehler werden besser von statischen Analyseger√§ten diagnostiziert, andere von dynamischen Analyseger√§ten.  Diese Arten von Tools <a href="https://www.viva64.com/en/b/0643/">erg√§nzen sich</a> gegenseitig, sodass Sie nicht nur eines ausw√§hlen m√ºssen. <br><br>  Beispielsweise k√∂nnen dynamische Analysatoren nicht erreichbaren Code und viele der durch Tippfehler verursachten Fehler nicht erkennen.  Einige der Arten von Fehlern, die bei der dynamischen Analyse nur schwer zu finden sind, werden im Artikel " <a href="https://www.viva64.com/en/b/0504/">√úberpr√ºfen des Codes des dynamischen Valgrind-Analysators mit einem statischen Analysator</a> " beschrieben. <br><br><h3>  "Unit Testing ist besser als statische Analyse" </h3><br>  Wenn Sie zwischen dem Schreiben von Komponententests und der Verwendung von statischen Analysen w√§hlen w√ºrden, w√§ren die Tests wichtiger und wertvoller.  Aber du musst nicht w√§hlen;  Sie sollten sowohl Unit-Tests als auch statische Analysen verwenden.  Diese Techniken funktionieren sehr gut zusammen. <br><br>  Hier sind die Argumente f√ºr die Verwendung der statischen Analyse zusammen mit Unit-Tests: <br><br><ol><li>  Tests selbst werden nicht getestet und enthalten h√§ufig Fehler.  In unseren Artikeln zeigen wir viele Beispiele von Fehlern, die in Unit-Tests in realen Projekten gefunden wurden.  Statische Analysen k√∂nnen Fehler in Tests finden, die wiederum Fehler im Hauptcode finden k√∂nnen. </li><li>  Es ist schwierig, den gesamten Code mit Tests abzudecken, insbesondere die Teile, die sich mit der Ausnahmebehandlung befassen.  Im Gegensatz dazu √ºberpr√ºfen statische Analysatoren den gesamten Code. </li><li>  Einige Bugs lassen sich nach M√∂glichkeit nur sehr schwer durch Unit-Tests erkennen.  <a href="https://www.viva64.com/en/w/v597/">V597 (CWE-14)</a> ist ein solches Beispiel. </li><li>  Einige Fehler treten nur dann auf, wenn das Programm mit gro√üen Datenmengen arbeitet. Daher ist es unpraktisch, solche Situationen in Komponententests zu simulieren.  Ein solches Beispiel ist ein √úberlauf einer 32-Bit-Variablen in einem 64-Bit-Programm ( <a href="https://www.viva64.com/en/w/v108/">V108</a> , <a href="https://www.viva64.com/en/w/v127/">V127</a> ). </li><li>  Wenn ein Test nicht bestanden wird, kann der Fehler durch Ausf√ºhren des statischen Analysators einfacher und schneller gefunden werden als durch Debuggen.  Nat√ºrlich w√ºrden Unit-Tests mehr Bugs finden, aber wenn Sie sie mit einer g√ºnstigeren Technik (dh statischen Analyse) finden k√∂nnen, warum nicht? </li><li>  In verschiedenen Projekten finden wir <a href="https://www.viva64.com/en/examples/">Unmengen von Fehlern</a> .  Viele von ihnen sind stark mit Tests bedeckt, aber wie Sie sehen, helfen sie nicht viel.  Es gibt also keinen Grund, warum Sie zus√§tzlich zu Unit-Tests keine statische Analyse anwenden sollten, um die Qualit√§t und Zuverl√§ssigkeit Ihres Codes zu verbessern. </li></ol><br><h3>  "Zeitgen√∂ssische freie Compiler k√∂nnen die gleichen Fehler finden, die PVS-Studio kann" </h3><br>  Sicher, Compiler entwickeln sich weiter und erhalten neue Warnungen, die Fehler erkennen k√∂nnen.  Im Vergleich zu professionellen propriet√§ren L√∂sungen wie PVS-Studio kann man von Compilern jedoch nicht viel erwarten. <br><br>  Gr√ºnde f√ºr PVS-Studio: <br><br><ol><li>  Effiziente Benutzerunterst√ºtzung </li><li>  Hochentwickelte Infrastruktur (Integration mit anderen Produkten) </li><li>  Leistungsstarke Diagnosefunktionen </li></ol><br>  Die ersten beiden Gr√ºnde sprechen bereits f√ºr PVS-Studio, aber auch f√ºr die Diagnose.  Wir verbessern unser Produkt st√§ndig, um anderen Anbietern einen Schritt voraus zu sein.  Beispielsweise kann unser Tool einen interessanten Fehler erkennen, der im Artikel " <a href="https://www.viva64.com/en/b/0550/">31. Februar</a> " beschrieben ist. <br><br>  Da wir uns dar√ºber im Klaren sind, dass das oben Gesagte nicht ausreicht, um Skeptiker dazu zu bringen, ihre Meinung zu √§ndern, √ºberpr√ºfen wir die Compiler von Zeit zu Zeit, um zu zeigen, dass auch sie Fehler aufweisen, die PVS-Studio erkennen kann: <br><br><ul><li>  <a href="http://www.viva64.com/en/b/0108/">LLVM wurde 2011 √ºberpr√ºft</a> </li><li>  <a href="http://www.viva64.com/en/b/0155/">LLVM wurde 2012 √ºberpr√ºft</a> </li><li>  <a href="http://www.viva64.com/en/b/0425/">GCC hat im Jahr 2016 gepr√ºft</a> </li><li>  <a href="http://www.viva64.com/en/b/0446/">LLVM wurde 2016 √ºberpr√ºft</a> </li><li>  <a href="https://www.viva64.com/en/b/0622/">Roslyn (.NET Compiler Platform) wurde 2019 √ºberpr√ºft</a> </li><li>  <a href="https://www.viva64.com/en/b/0629/">LLVM wurde 2019 √ºberpr√ºft</a> </li></ul><br><h2>  PS </h2><br>  Wenn Sie immer noch Zweifel haben, ob Sie PVS-Studio verwenden sollen, sehen Sie sich diese Liste der <a href="https://www.viva64.com/en/examples/">Fehler an, die es in verschiedenen Projekten gefunden hat</a> . <br><br><h2>  Referenzen </h2><br><ol><li>  PVS-Studio: <a href="https://www.viva64.com/en/pvs-studio/">Homepage</a> , <a href="https://www.viva64.com/en/m/">Dokumentation</a> , <a href="https://www.viva64.com/en/pvs-studio-download/">Download</a> , <a href="https://www.viva64.com/en/order/">Kauf</a> . </li><li>  Argumente f√ºr PVS-Studio: <a href="https://www.viva64.com/en/inspections/">gepr√ºfte Projekte</a> , <a href="https://www.viva64.com/en/customers/">Kunden</a> , <a href="https://www.viva64.com/en/b/0606/">ROI</a> . </li><li>  <a href="https://www.viva64.com/en/b/0633/">Wie k√∂nnen interessante Warnungen des PVS-Studio-Analysators f√ºr C- und C ++ - Code schnell √ºberpr√ºft werden?</a> </li><li>  <a href="https://www.viva64.com/en/b/0625/">Kurz √ºber PVS-Studio als SAST-L√∂sung</a> </li><li>  <a href="https://www.viva64.com/en/b/0659/">PVS-Studio: Motor des Fortschritts</a> </li><li>  <a href="https://www.viva64.com/en/b/0675/">Hinweis f√ºr Professoren: Verwenden Sie PVS-Studio, um die Sch√ºler mit den Code-Analyse-Tools vertraut zu machen</a> </li><li>  <a href="https://www.viva64.com/en/b/0637/">Warum wir keine Artikel schreiben, in denen PVS-Studio mit anderen statischen Analysatoren verglichen wird</a> </li><li>  <a href="https://www.viva64.com/en/b/0514/">Wie kann PVS-Studio bei der Erkennung von Sicherheitsl√ºcken helfen?</a> </li><li>  <a href="https://www.viva64.com/en/l/full/">Lektionen zur Entwicklung von 64-Bit-C / C ++ - Anwendungen</a> </li><li>  <a href="https://www.viva64.com/en/b/0592/">Technologien, die im PVS-Studio Code Analyzer zum Auffinden von Fehlern und potenziellen Schwachstellen verwendet werden</a> </li><li>  <a href="https://www.viva64.com/en/b/0603/">PVS-Studio f√ºr Java</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de477324/">https://habr.com/ru/post/de477324/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de477308/index.html">Klon Numpy</a></li>
<li><a href="../de477310/index.html">Dynamisches CDN f√ºr WebRTC-Streaming mit geringer Latenz</a></li>
<li><a href="../de477314/index.html">Senden von Ereignissen von ViewModel an Activity / Fragment in MVVM</a></li>
<li><a href="../de477318/index.html">PHP Digest Nr. 168 (5. - 25. November 2019)</a></li>
<li><a href="../de477320/index.html">Umwelt: Wie das Internet der Dinge zum Schutz der Umwelt beitr√§gt</a></li>
<li><a href="../de477326/index.html">Einfachheit Hickey</a></li>
<li><a href="../de477328/index.html">Gr√ºnde f√ºr die Einf√ºhrung des statischen Code-Analysators PVS-Studio in den Entwicklungsprozess</a></li>
<li><a href="../de477332/index.html">Hackney Pipeline: Hackathon zum Markieren von Daten von Ozon, Yandex.Tolki und Netologiya</a></li>
<li><a href="../de477336/index.html">Serverloses Rechnen basierend auf OpenWhisk, Teil 1</a></li>
<li><a href="../de477338/index.html">OWASP Treffen Moskau (Russland) 12/19 CFP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>