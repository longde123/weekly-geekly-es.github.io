<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏾 🏪 🧖🏽 Kursus MIT "Keamanan Sistem Komputer". Kuliah 3: Buffer Overflows: Eksploitasi dan Perlindungan, Bagian 2 🎤 💿 👨🏻‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Institut Teknologi Massachusetts. Kursus Kuliah # 6.858. "Keamanan sistem komputer." Nikolai Zeldovich, James Mickens. Tahun 2014 
 Keamanan Sistem Ko...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kursus MIT "Keamanan Sistem Komputer". Kuliah 3: Buffer Overflows: Eksploitasi dan Perlindungan, Bagian 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/418093/"><h3>  Institut Teknologi Massachusetts.  Kursus Kuliah # 6.858.  "Keamanan sistem komputer."  Nikolai Zeldovich, James Mickens.  Tahun 2014 </h3><br>  Keamanan Sistem Komputer adalah kursus tentang pengembangan dan implementasi sistem komputer yang aman.  Ceramah mencakup model ancaman, serangan yang membahayakan keamanan, dan teknik keamanan berdasarkan pada karya ilmiah baru-baru ini.  Topik meliputi keamanan sistem operasi (OS), fitur, manajemen aliran informasi, keamanan bahasa, protokol jaringan, keamanan perangkat keras, dan keamanan aplikasi web. <br><br>  Kuliah 1: “Pendahuluan: model ancaman” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 2: "Kontrol serangan hacker" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 3: “Buffer Overflows: Exploits and Protection” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <a name="habracut"></a><br><br>  Menariknya, seorang penyerang tidak dapat melompat ke alamat tertentu, meskipun pada kenyataannya kami terutama menggunakan alamat yang dikodekan dengan keras.  Apa yang dia lakukan disebut "heap attack", dan jika Anda adalah orang jahat, maka itu akan sangat menyenangkan bagi Anda.  Dengan serangan seperti itu, seorang hacker mulai secara dinamis mengalokasikan banyak kode shell dan cukup memasukkannya secara acak ke dalam memori.  Ini sangat efektif jika Anda menggunakan bahasa tingkat tinggi yang dinamis seperti JavaScript.  Dengan demikian, pembaca tag berada dalam satu lingkaran sempit dan hanya menghasilkan sejumlah besar baris kode shell dan kemudian mengisinya. <br><br>  Penyerang tidak dapat menentukan lokasi garis yang tepat, ia hanya memilih 10 MB baris kode shell dan membuat lompatan sewenang-wenang.  Dan jika dia entah bagaimana bisa mengendalikan salah satu pointer <b>ret</b> , ada kemungkinan dia akan "mendarat" dalam kode shell. <br><br><img src="https://habrastorage.org/webt/jl/7-/8x/jl7-8xckq3eq6z_wf2_m2alslzg.jpeg"><br><br>  Anda dapat menggunakan satu trik yang disebut <b>NOP slide</b> , <b>NOP sled</b> atau <b>NOP ramp</b> , di mana <b>NOP</b> adalah <b>instruksi tanpa operasi</b> , atau perintah kosong yang tidak digunakan.  Ini berarti bahwa aliran eksekusi perintah prosesor "tergelincir" ke tujuan akhir yang diinginkan setiap kali program pergi ke alamat memori di mana saja pada slide. <br><br>  Bayangkan jika Anda memiliki satu baris kode shell dan Anda pergi ke tempat acak di baris itu, ini mungkin tidak berfungsi, karena itu tidak memungkinkan Anda untuk menyebarkan serangan dengan cara yang benar. <br><br>  Tapi mungkin barang-barang yang Anda masukkan pada heap pada dasarnya hanya satu ton <b>NOP</b> , dan pada akhirnya, Anda memiliki kode shell.  Ini sebenarnya cukup pintar, karena itu berarti sekarang Anda benar-benar bisa sampai ke tempat yang tepat di mana Anda melompat.  Karena jika Anda melompat ke salah satu <b>NOP</b> ini, itu hanya terjadi "boom, boom, boom, boom, boom, boom, boom, boom", dan kemudian Anda masuk ke kode shell. <br><br>  Sepertinya orang-orang datang dengan ini, yang mungkin Anda lihat di tim kami.  Mereka menciptakan sesuatu seperti itu, dan itulah masalahnya.  Jadi ini adalah cara lain untuk menyiasati beberapa hal acak hanya dengan membuat pengacakan kode Anda kuat, jika itu masuk akal. <br><br>  Jadi, kami telah membahas beberapa jenis keacakan yang dapat Anda gunakan.  Ada beberapa ide bodoh yang juga muncul pada orang.  Jadi sekarang Anda tahu bahwa ketika Anda ingin membuat panggilan sistem, misalnya, menggunakan fungsi <b>syscall libc</b> , Anda pada dasarnya memasukkan nomor unik yang mewakili panggilan sistem yang ingin Anda buat.  Jadi mungkin fungsi <b>garpu</b> 7, <b>tidur</b> 8, atau sesuatu seperti itu. <br><br>  Ini berarti bahwa jika seorang penyerang dapat mengetahui alamat dari instruksi <b>syscall</b> ini dan mendapatkannya dengan cara apa pun, ia sebenarnya hanya dapat mengganti nomor system call yang ingin mereka gunakan secara langsung.  Anda dapat membayangkan bahwa setiap kali program berjalan, Anda benar-benar membuat penugasan dinamis nomor <b>syscall untuk syscall yang</b> valid, untuk mempersulit penangkapan penyerang. <br><br><img src="https://habrastorage.org/webt/nq/l6/ob/nql6obzl82-6vvdgdkt6iuhzs8g.jpeg"><br><br>  Bahkan ada beberapa saran untuk mengubah perangkat keras sehingga peralatan tersebut berisi kunci enkripsi <b>xor</b> , yang digunakan untuk fungsi dinamis <b>xor</b> .  Bayangkan bahwa setiap kali Anda mengkompilasi suatu program, semua kode instruksi mendapatkan kunci <b>xor</b> tertentu.  Kunci ini disimpan dalam register peralatan ketika Anda pertama kali mengunduh program, dan setelah itu, setiap kali Anda menjalankan instruksi, peralatan secara otomatis melakukan operasi untuknya sebelum melanjutkan dengan instruksi ini.  Hal yang baik tentang pendekatan ini adalah bahwa sekarang, bahkan jika penyerang dapat menghasilkan kode shell, ia tidak akan mengenali kunci ini.  Jadi akan sangat sulit baginya untuk mencari tahu apa yang sebenarnya perlu dimasukkan ke dalam memori. <br><br>  <b>Hadirin:</b> tetapi jika dia bisa mendapatkan kode, maka dia juga bisa menggunakan <b>xor</b> untuk mengubah kode kembali menjadi instruksi. <br><br>  <b>Profesor:</b> ya, itu adalah masalah kanonik, benar.  Ini agak mirip dengan apa yang terjadi selama serangan <b>BROP</b> , ketika kita tampaknya mengacak lokasi kode, tetapi penyerang dapat "merasakan" itu dan mencari tahu apa yang terjadi.  Orang dapat membayangkan bahwa, misalnya, jika seorang penyerang mengetahui beberapa sub-urutan kode yang ia harapkan akan ditemukan dalam file biner, ia akan mencoba menggunakan operasi <b>xor</b> untuk file ini untuk mengekstraksi kunci. <br><br>  Pada dasarnya, kami membahas semua jenis serangan pengacakan yang ingin saya sampaikan kepada Anda hari ini.  Sebelum kita beralih ke pemrograman, ada baiknya membahas metode perlindungan mana yang digunakan dalam praktiknya.  Ternyata <b>GCC</b> dan Visual Studio menyertakan pendekatan <b>stack canaries</b> secara <b>default</b> .  Ini adalah komunitas yang sangat populer dan sangat terkenal.  Jika Anda melihat Linux dan Windows, mereka juga memanfaatkan hal-hal seperti memori yang tidak dapat dieksekusi dan pengacakan ruang alamat.  Benar, sistem <b>batas longgar</b> tidak begitu populer dengan mereka, mungkin karena biaya memori, prosesor, alarm palsu, dan sebagainya, yang telah kita bicarakan.  Jadi pada dasarnya kami telah memeriksa bagaimana hal-hal akan mencegah masalah buffer overflow. <br><br>  Sekarang kita akan berbicara tentang <b>ROP</b> , pemrograman berorientasi terbalik.  Hari ini saya sudah memberi tahu Anda apa yang diwakilinya dalam hal pengacakan ruang alamat dan mencegah data dieksekusi - itu membaca, menulis, dan mengeksekusi.  Ini sebenarnya adalah hal yang sangat kuat.  Karena pengacakan mencegah kemungkinan penyerang memahami di mana alamat hard-coded kami.  Dan kemampuan untuk mencegah eksekusi data memastikan bahwa bahkan jika Anda meletakkan kode shell pada stack, seorang penyerang tidak bisa langsung melompat ke sana dan menjalankannya. <br><br>  Semua ini terlihat cukup progresif, tetapi peretas terus mengembangkan metode serangan terhadap solusi pertahanan progresif tersebut. <br><br>  Jadi apa inti dari pemrograman berorientasi terbalik? <br><br>  Bagaimana jika, alih-alih hanya membuat kode baru selama serangan, seorang penyerang dapat menggabungkan potongan-potongan kode yang ada dan kemudian menggabungkannya secara abnormal?  Bagaimanapun, kita tahu bahwa program itu berisi banyak kode seperti itu. <br><br><img src="https://habrastorage.org/webt/fd/76/08/fd7608uferkfub0zyknpa6w1vfk.jpeg"><br><br>  Jadi, untungnya, atau sayangnya, semuanya tergantung di sisi mana Anda berada.  Jika Anda dapat menemukan beberapa potongan kode yang menarik dan menggabungkannya, Anda bisa mendapatkan sesuatu seperti bahasa <b>Turing</b> , di mana penyerang pada dasarnya dapat melakukan apapun yang dia inginkan. <br><br>  Mari kita lihat contoh yang sangat sederhana yang akan terasa akrab bagi Anda pada awalnya, tetapi kemudian dengan cepat berubah menjadi sesuatu yang gila. <br><br>  Katakanlah kita memiliki program berikut.  Jadi, mari kita memiliki beberapa fungsi dan, yang nyaman bagi penyerang, inilah fungsi <b>shell run yang</b> bagus.  Jadi ini hanya panggilan ke sistem, itu akan menjalankan perintah <b>bin / bash</b> dan ini akan berakhir.  Selanjutnya, kami memiliki proses buffer overflow kanonik atau, maaf, fungsi yang akan mengumumkan pembuatan buffer dan kemudian menggunakan salah satu fungsi tidak aman ini untuk mengisi buffer dengan byte. <br><br><img src="https://habrastorage.org/webt/7r/os/et/7rosetpoais8blpdvc_-7mfkg7u.jpeg"><br><br>  Jadi, kita tahu bahwa buffer overflow terjadi tanpa masalah.  Tetapi hal yang menarik adalah bahwa kita memiliki fungsi <b>run shell ini</b> , tetapi sulit untuk mendapatkannya dengan cara berdasarkan buffer overflows.  Bagaimana seorang penyerang dapat <b>menjalankan</b> perintah <b>shell run</b> ini? <br><br>  Pertama-tama, penyerang dapat membongkar program, memulai <b>GDB</b> , dan mencari tahu alamat benda ini di file yang dapat dieksekusi.  Anda mungkin akrab dengan metode ini dari pekerjaan laboratorium.  Kemudian, selama buffer overflow, penyerang dapat mengambil alamat ini, memasukkannya ke dalam buffer overflow yang dihasilkan, dan memverifikasi bahwa fungsinya kembali ke <b>run shell</b> . <br><br>  Untuk membuatnya jelas, saya akan menggambarnya.  Jadi, Anda memiliki tumpukan yang terlihat seperti ini: di bagian bawah ada buffer yang meluap, di atasnya adalah indikator gap yang disimpan, di atasnya adalah alamat pengirim untuk <b>prosess_msg</b> .  Kiri bawah kita memiliki stack pointer baru yang memulai fungsi, di atasnya break pointer baru, kemudian stack pointer yang akan digunakan, dan lebih tinggi lagi adalah break pointer dari frame sebelumnya.  Semuanya terlihat cukup akrab. <br><br><img src="https://habrastorage.org/webt/qf/ee/vg/qfeevg9_wr3ctwybpgx8acjcpeq.jpeg"><br><br>  Seperti yang saya katakan, selama serangan, <b>GDB</b> digunakan untuk mencari tahu apa alamat <b>run shell</b> .  Jadi, ketika buffer overflows, kita cukup meletakkan alamat <b>run shell</b> di sini di sebelah kanan.  Ini sebenarnya adalah perpanjangan yang cukup sederhana dari apa yang sudah kita ketahui bagaimana melakukannya.  Pada dasarnya, ini berarti bahwa jika kita memiliki perintah yang meluncurkan shell, dan jika kita dapat membongkar file biner untuk mencari tahu di mana alamat ini berada, kita dapat dengan mudah meletakkannya di limpahan limpahan ini yang terletak di bagian bawah tumpukan.  Ini sangat sederhana. <br><br>  Jadi, ini adalah contoh yang sangat sembrono, karena programmer, untuk beberapa alasan gila, meletakkan fungsi ini di sini, dengan demikian menghadirkan penyerang hadiah nyata. <br>  Sekarang anggaplah bahwa alih-alih memanggil hal ini <b>run_shell</b> , kita akan menyebutnya <b>run_boring</b> , dan kemudian menjalankan perintah <b>/ bin / ls</b> .  Namun, kami tidak kehilangan apa-apa, karena kami akan memiliki string <b>char * bash_path di atas</b> , yang akan memberi tahu kami jalan ke <b>bin / bash ini</b> . <br><br><img src="https://habrastorage.org/webt/1d/u1/a2/1du1a2wtfwbzgtyul4bknzikpti.jpeg"><br><br>  Jadi hal yang paling menarik tentang ini adalah bahwa seorang penyerang yang ingin menjalankan <b>ls</b> dapat "mengurai" program dan menemukan lokasi <b>run_boring</b> , dan ini sama sekali tidak menyenangkan.  Tetapi pada kenyataannya, kita memiliki garis dalam memori yang menunjuk ke jalur shell, di samping itu, kita tahu sesuatu yang menarik.  Ini adalah bahwa meskipun program tidak memanggil sistem dengan argumen <b>/ bin / ls</b> , ia masih membuat semacam panggilan. <br><br>  Jadi, kita tahu bahwa sistem harus entah bagaimana terhubung dengan program ini - <b>sistem ("/ bin / ls")</b> .  Oleh karena itu, kita dapat menggunakan dua operasi <b>void ini</b> untuk benar-benar mengasosiasikan sistem dengan <b>argumen char * bash_path ini</b> .  Hal pertama yang kita lakukan adalah masuk ke <b>GDB</b> dan mencari tahu di mana <b>sistem</b> ini <b>("/ bin / ls")</b> berada di gambar proses biner.  Jadi, Anda hanya pergi ke <b>GDB</b> , cukup ketik <b>print_system</b> dan dapatkan informasi tentang offset-nya.  Ini cukup sederhana, dan Anda dapat melakukan hal yang sama untuk <b>bash_path</b> .  Artinya, Anda cukup menggunakan <b>GDB</b> untuk mencari tahu di mana benda ini hidup. <br><br>  Setelah selesai, Anda perlu melakukan sesuatu yang lain.  Karena sekarang kita benar-benar perlu mencari cara bagaimana memanggil sistem menggunakan argumen yang kita pilih.  Dan cara kita melakukan ini pada dasarnya terdiri dari memalsukan bingkai panggilan untuk sistem.  Jika Anda ingat, frame adalah apa yang digunakan oleh kompiler dan perangkat keras untuk mengimplementasikan panggilan stack. <br><br>  Kami ingin mengatur tumpukan seperti apa yang saya gambarkan dalam gambar ini.  Sebenarnya, kita akan memalsukan sistem yang seharusnya ada di stack, tetapi tepat sebelum itu benar-benar mengeksekusi kodenya. <br><br>  Jadi, di sini kita memiliki argumen sistem, ini adalah baris yang ingin kita jalankan.  Di bagian bawah kita memiliki garis di mana sistem harus kembali ketika garis dengan argumen selesai.  Sistem mengharapkan tumpukan terlihat seperti itu sebelum eksekusi dimulai. <br><br><img src="https://habrastorage.org/webt/7r/ik/vp/7rikvpe59gsq0xdlubuhbew1juu.jpeg"><br><br>  Kami dulu beranggapan bahwa tidak ada argumen ketika Anda melewati fungsi, tetapi sekarang terlihat sedikit berbeda.  Kita hanya perlu memastikan bahwa <b>argumen</b> ada dalam kode overflow yang kita buat.  Kita hanya perlu memastikan bahwa <b>frame panggilan</b> palsu ini ada dalam array ini.  Dengan demikian, pekerjaan kami adalah sebagai berikut.  Ingat bahwa stack overflow berpindah dari bawah ke atas. <br><br><img src="https://habrastorage.org/webt/kh/by/g7/khbyg7us4ir4ydv6ossc2-bbnd0.jpeg"><br><br>  Pertama, kita akan meletakkan alamat sistem di sini.  Dan di atas kita akan menempatkan beberapa <b>alamat pengirim sampah</b> .  Ini adalah tempat di mana sistem akan kembali setelah selesai.  Alamat ini akan menjadi set byte acak.  Di atasnya kita akan meletakkan alamat <b>bash_path</b> .  Apa yang terjadi ketika buffer overflow sekarang? <br><br>  Setelah <b>prosess_msg</b> mencapai garis finish, dia akan berkata: "OK, ini adalah tempat di mana saya harus kembali"!  Kode sistem terus berjalan, bergerak lebih tinggi dan melihat bingkai panggilan palsu yang kami buat.  Untuk sistem, tidak ada yang menakjubkan yang akan terjadi, ia akan mengatakan: "Ya, ini dia, argumen yang ingin saya jalankan adalah <b>bin / bash</b> ", dijalankan, dan selesai - penyerang telah menangkap shell! <br><br>  Apa yang sudah kita lakukan sekarang?  Kami memanfaatkan pengetahuan tentang <b>konvensi pemanggilan</b> , <b>konvensi pemanggilan</b> , sebagai platform untuk membuat bingkai tumpukan palsu, atau nama bingkai palsu, menurut saya.  Dengan menggunakan <b>bingkai panggilan</b> palsu ini, kita dapat melakukan fungsi apa pun yang dirujuk dan yang sudah ditentukan oleh aplikasi. <br><br>  Pertanyaan selanjutnya yang harus kita tanyakan adalah: bagaimana jika program tidak memiliki baris <b>char * bash_path ini</b> sama <b>sekali</b> ?  Saya perhatikan bahwa baris ini hampir selalu ada dalam program.  Namun, anggaplah kita hidup di dunia yang terbalik, dan itu masih belum ada.  Jadi apa yang bisa kita lakukan untuk meletakkan baris ini dalam sebuah program? <br><br>  Hal pertama yang dapat Anda lakukan untuk ini adalah menentukan alamat yang benar untuk <b>bash_path</b> , menempatkannya lebih tinggi, di sini di kompartemen tumpukan kami, memasukkan di sana tiga elemen, yang masing-masing berukuran 4 byte: <br><br>  <b>/ 0</b> <b><br></b>  <b>/ pat</b> <b><br></b>  <b>/ bin</b> <br><br><img src="https://habrastorage.org/webt/7y/ko/bo/7ykobou1yi5jzfppu2w0ok6b0zs.jpeg"><br><br>  Tetapi bagaimanapun juga, pointer kita datang ke sini dan - booming!  - Masalahnya sudah selesai.  Dengan begitu, Anda sekarang dapat memanggil argumen hanya dengan menempatkannya di kode shell Anda.  Mengerikan, bukan?  Dan semua ini dibangun sebelum serangan <b>BROP</b> penuh.  Tetapi sebelum Anda menunjukkan serangan <b>BROP</b> penuh, Anda perlu memahami bagaimana Anda hanya rantai bersama hal-hal yang sudah ada di dalam kode.  Ketika saya memiliki alamat pengirim yang dibuang di sini, kami hanya ingin mengakses shell.  Tetapi jika Anda seorang penyerang, maka Anda bisa mengarahkan alamat pengirim ini, atau alamat pengirim, ke sesuatu yang benar-benar dapat digunakan.  Dan jika Anda melakukan ini, maka Anda bisa merangkai beberapa fungsi berturut-turut menjadi satu baris, beberapa tanda fungsi dalam satu baris.  Ini memang pilihan yang sangat kuat. <br><br>  Karena jika kita hanya mengatur alamat pengirim untuk lompatan, maka setelah itu program biasanya macet, yang mungkin kita tidak inginkan.  Oleh karena itu, ada baiknya menghubungkan beberapa hal ini bersama-sama untuk melakukan hal-hal yang lebih menarik dengan program ini. <br><br>  Misalkan tujuan kita adalah bahwa kita ingin memanggil sistem beberapa kali secara sewenang-wenang.  Kami tidak hanya ingin melakukan ini sekali saja, kami akan melakukannya beberapa kali secara sewenang-wenang.  Jadi bagaimana ini bisa dilakukan? <br><br>  Untuk melakukan ini, kami menggunakan dua informasi yang sudah kami ketahui cara mendapatkannya.  Kami tahu cara mendapatkan alamat sistem - Anda hanya perlu melihat ke <b>GDB</b> dan menemukannya di sana.  Kami juga tahu cara menemukan alamat baris ini, <b>bin / bash</b> .  Sekarang, untuk memulai serangan ini menggunakan beberapa panggilan ke sistem, kita perlu menggunakan gadget.  Ini membawa kita lebih dekat dengan apa yang terjadi di <b>BROP</b> . <br><br>  Jadi yang kita butuhkan sekarang adalah menemukan alamat dari dua operasi kode ini: <b>pop% eax</b> and <b>ret</b> .  Yang pertama menghapus bagian atas tumpukan dan meletakkannya di register <b>eax</b> , dan yang kedua meletakkannya di <b>pointer</b> instruksi <b>eip</b> .  Inilah yang kami sebut gadget.  Sepertinya seperangkat instruksi perakitan yang dapat digunakan penyerang untuk membangun serangan yang lebih ambisius. <br><br><img src="https://habrastorage.org/webt/r4/nw/c6/r4nwc61pbprp8gv2gof8kxdj0uw.jpeg"><br><br>  Gadget ini adalah alat standar yang digunakan peretas untuk menemukan hal-hal seperti file biner.  Juga mudah untuk menemukan salah satu gadget ini, dengan asumsi Anda memiliki salinan biner, dan kami tidak repot-repot dengan pengacakan.  Hal-hal ini sangat mudah ditemukan, juga sangat mudah untuk menemukan alamat sistem dan sebagainya. <br><br>  Jadi, jika kita memiliki salah satu gadget ini, mengapa kita dapat menggunakannya?  Tentu saja, melakukan kejahatan!  Untuk melakukan ini, Anda dapat melakukan hal berikut. <br><br>  Misalkan kita mengubah tumpukan kita sehingga terlihat seperti ini, exploit, seperti sebelumnya, diarahkan dari bawah ke atas.  Hal pertama yang kita lakukan adalah menempatkan alamat sistem di sini, dan di atasnya kita masukkan alamat gadget <b>pop / ret</b> .  Bahkan lebih tinggi, kami memasukkan alamat <b>bash_path</b> , dan kemudian mengulangi semuanya: dari atas kami lagi menempatkan alamat sistem, alamat <b>pop / ret</b> gadget dan alamat <b>bash_path</b> . <br><br><img src="https://habrastorage.org/webt/f6/ti/zh/f6tizhirkpxkzrwjeavzjc6uulc.jpeg"><br><br>  Apa yang akan terjadi di sini sekarang?  Ini akan sedikit rumit, jadi catatan kuliah ini tersedia di Internet, dan untuk sekarang Anda bisa mendengarkan apa yang terjadi di sini, tetapi ketika saya pertama kali memahami ini, rasanya seperti memahami bahwa Santa Claus tidak ada! <br><br>  Kami akan mulai dari tempat entri <b>entri</b> berada, kembali ke sistem tempat pernyataan <b>ret</b> akan menghapus item dari tumpukan menggunakan perintah <b>pop</b> , jadi sekarang bagian atas penunjuk tumpukan ada di sini.  Jadi, kami menghapus elemen menggunakan <b>pop</b> , lalu mengembalikan prosedur <b>ret</b> , yang mentransfer kontrol ke alamat kembali yang dipilih dari tumpukan, dan alamat kembali ini ditempatkan di sana dengan perintah <b>panggilan</b> .  Jadi, kami kembali melakukan panggilan ke sistem, dan proses ini dapat diulangi lagi dan lagi. <br><br><img src="https://habrastorage.org/webt/js/mz/oz/jsmzoz4p8_mrqlskie75rmdgcnu.jpeg"><br><br>  Jelas bahwa kita dapat menghubungkan urutan ini untuk melakukan sejumlah hal yang sewenang-wenang.  Pada dasarnya, kernel mendapatkan apa yang disebut pemrograman berorientasi terbalik.  Harap perhatikan bahwa kami tidak melakukan apa pun pada tumpukan ini.  Kami melakukan apa yang memungkinkan kami untuk mencegah eksekusi data tanpa merusak apa pun.  Kami baru saja melakukan lompatan tak terduga untuk melakukan apa yang kami inginkan.  Sebenarnya itu sangat, sangat, sangat, pintar. <br><br>  Dan yang menarik adalah bahwa pada level tinggi kami telah mengidentifikasi model baru ini untuk komputasi.  ,   ,     ,       .     ,  ,    .  , -       .     ,       ,   .          ,       .         .  ,        .  ,    ,     <b>stack canaries.</b> <br><br>   ,  «»  ,      .  ,  ,  «»    <b>ret address</b>   <b>saved %ebp</b> ,    -   ,   «».  ,        <b>ret</b> ,   ,       «»,  ,    - .    <b>stack canaries</b> . <br><br>  ,    «».         ,   . ,     «»? <br><br> ,    ,  ,      . <br> ,   ,  ,   «»  ,    «»  «». <br><br>  ,    ,  ,    «»     ,   ,    . <br>   ,    -  ,     «»         ,         .    ,   ?           ? <br>   ,       <b>fork</b>    .   , <b>fork</b>     .    ,   ,    ,      <b>fork</b> ,      ,  ,       ,       «»   .     ,       <b>stack canaries</b> . <br><br>       «»?      .  ,    ,     ,   «».  «»    .                . <br><br><img src="https://habrastorage.org/webt/ql/h1/ol/qlh1olpcbsug9nbtozpjevlll7u.jpeg"><br><br> ,    ,     –    ,      «».         , ,      0.    ,  «»,      .    ,  : <br><br> «,      «»!     ,      0.  «»!  1 –  «»,  2 –   . ,    2- .  ,     ,  «». <br><br><img src="https://habrastorage.org/webt/tx/xp/rc/txxprcve2i3lgkwslbdrluiv-sk.jpeg"><br><br>    ,   ,      ,     . <br><br>      «»,   ,    ,     .     ,          ,      «». <br><br> 57:10  <br><br> : <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kursus MIT "Keamanan Sistem Komputer".</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kuliah 3: Buffer Overflows: Eksploitasi dan Perlindungan, Bagian 3</font></font></a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/xSQxaie_h1o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versi lengkap dari kursus ini tersedia di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br>  Terima kasih telah tinggal bersama kami.  Apakah Anda suka artikel kami?  Ingin melihat materi yang lebih menarik?  Dukung kami dengan melakukan pemesanan atau merekomendasikannya kepada teman-teman Anda, <b>diskon 30% untuk pengguna Habr pada analog unik dari server entry-level yang kami temukan untuk Anda:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Seluruh kebenaran tentang VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps dari $ 20 atau bagaimana membagi server?</a>  (opsi tersedia dengan RAID1 dan RAID10, hingga 24 core dan hingga 40GB DDR4). <br><br>  <b>Dell R730xd 2 kali lebih murah?</b>  Hanya kami yang memiliki <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2 x Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100 TV dari $ 249</a> di Belanda dan Amerika Serikat!</b>  Baca tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara Membangun Infrastruktur Bldg.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kelas menggunakan server Dell R730xd E5-2650 v4 seharga 9.000 euro untuk satu sen?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id418093/">https://habr.com/ru/post/id418093/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id418083/index.html">Server sederhana dengan GraphQL bukan REST, implementasi di java</a></li>
<li><a href="../id418085/index.html">Menggunakan Janji dalam JavaScript</a></li>
<li><a href="../id418087/index.html">80% dari checkout mandiri memiliki risiko</a></li>
<li><a href="../id418089/index.html">Ikhtisar Mesin Penggilingan SolidCraft CNC</a></li>
<li><a href="../id418091/index.html">Daftar artikel dan literatur tentang NAS</a></li>
<li><a href="../id418095/index.html">Tentang perangkat fungsionalitas pengujian bawaan di Rust (terjemahan)</a></li>
<li><a href="../id418099/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 3: Buffer Overflows: Eksploitasi dan Perlindungan, Bagian 3</a></li>
<li><a href="../id418101/index.html">Etimologi Istilah TI</a></li>
<li><a href="../id418103/index.html">Kepala Roscosmos ingat roket pertamanya dan berbagi rencana untuk masa depan</a></li>
<li><a href="../id418105/index.html">Mengapa membuka YouTube di Firefox atau Edge dapat memakan waktu 5 kali lebih lama daripada di Google Chrome</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>