<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧝🏾 🤜🏽 🔠 Java Challengers # 2: String-Vergleich 🤚 🌽 😝</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Java Challengers # 2: String-Vergleich 


 Wie immer haben wir viel Verspätung für den Beginn des Kurses, so dass erst gestern eine zweite Lektion unt...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Java Challengers # 2: String-Vergleich</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/428449/"><h1 id="java-challengers-2-sravnenie-strok">  Java Challengers # 2: String-Vergleich </h1><br><p>  <em>Wie immer haben wir viel Verspätung für den Beginn des Kurses, so dass erst gestern eine zweite Lektion unter dem neuen Thread <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Java Developer"</a> abgehalten wurde.</em>  <em>Aber das ist so, kleine Dinge im Leben, aber im Moment veröffentlichen wir weiterhin eine Reihe von Java Challengers-Artikeln, deren Übersetzung für Sie vorbereitet wurde.</em> </p><br><p> In Java kapselt die <code>String</code> Klasse ein <code>char</code> Array ( <em>Anmerkung des Übersetzers - mit Java 9 ist es bereits ein <code>byte</code> Array, siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Compact Strings in Java 9</a></em> ).  In einfachen Worten ist <code>String</code> ein Array von Zeichen, mit denen Wörter, Sätze oder andere Konstrukte zusammengesetzt werden. </p><br><p>  <strong>Die Kapselung</strong> ist eines der mächtigsten Konzepte in der objektorientierten Programmierung.  Dank der Kapselung müssen Sie nicht wissen, wie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>String</code></a> Klasse funktioniert.  Sie müssen nur die Methoden der Schnittstelle kennen. </p><br><p><img src="https://habrastorage.org/webt/9y/nz/bu/9ynzbuynkgesfwcmvuapp9ah5ci.png"><a name="habracut"></a></p><br><p>  Wenn Sie sich die <code>String</code> Klasse in Java ansehen, können Sie sehen, wie das <code>char</code> Array gekapselt ist: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">String</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(value, <span class="hljs-number"><span class="hljs-number">0</span></span>, value.length, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); }</code> </pre> <br><p>  Stellen Sie sich zum besseren Verständnis der Kapselung ein physisches Objekt vor: eine Maschine.  Müssen Sie wissen, wie ein Auto unter der Motorhaube funktioniert, um es zu fahren?  Natürlich nicht, aber Sie sollten wissen, was die Schnittstellen des Autos bewirken: das Gaspedal, die Bremsen und das Lenkrad.  Jede dieser Schnittstellen unterstützt bestimmte Aktionen: Beschleunigen, Bremsen, Linksabbiegen, Rechtsabbiegen.  Gleiches gilt für die objektorientierte Programmierung. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der erste Artikel</a> in der Java Challengers-Reihe befasste sich mit der Methodenüberladung, die in der <code>String</code> Klasse weit verbreitet ist.  Überladen kann Ihre Klassen wirklich flexibel machen: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">String</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String original)</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">String</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value[], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count)</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">String</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] codePoints, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count)</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">String</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bytes[], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length, String charsetName)</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-comment"><span class="hljs-comment">//    ...</span></span></code> </pre> <br><p>  Anstatt zu verstehen, wie die <code>String</code> Klasse funktioniert, hilft Ihnen dieser Artikel zu verstehen, <em>was</em> sie tut und <em>wie Sie</em> sie in Ihrem Code verwenden. </p><br><h2 id="chto-takoe-pul-strok-string-pool">  Was ist ein String-Pool? </h2><br><p>  Die <code>String</code> Klasse ist wohl die am häufigsten verwendete Klasse in Java.  Wenn wir jedes Mal, wenn wir <code>String</code> , ein neues Objekt im dynamischen Speicher (Speicherheap) erstellen, verschwenden wir viel Speicher.  Der String-Pool löst dieses Problem, indem nur ein Objekt für jeden Zeilenwert gespeichert wird. </p><br><p><img src="https://habrastorage.org/webt/kx/zv/kb/kxzvkbdaf7imr8yq5dj6bj048lu.jpeg" alt="Strings-in-the-String-Pool"></p><br><p>  <em>Linien in einer Reihe Pool</em> </p><br><p>  Obwohl wir mehrere <code>String</code> Variablen mit den Werten <code>Duke</code> und <code>Juggy</code> , werden nur zwei Objekte erstellt und im dynamischen Speicher (Heap) gespeichert.  Siehe das folgende Codebeispiel zum Beweis.  (Denken Sie daran, dass in Java der Operator " <code>==</code> " verwendet wird, um zwei Objekte zu vergleichen und festzustellen, ob dasselbe Objekt dasselbe ist oder nicht.) </p><br><pre> <code class="java hljs">String juggy = <span class="hljs-string"><span class="hljs-string">"Juggy"</span></span>; String anotherJuggy = <span class="hljs-string"><span class="hljs-string">"Juggy"</span></span>; System.out.println(juggy == anotherJuggy);</code> </pre> <br><p>  Dieser Code gibt <code>true</code> da die beiden <code>String</code> Variablen auf dasselbe Objekt im String-Pool verweisen.  Ihre Bedeutungen sind die gleichen. </p><br><h2 id="isklyuchenie----operator-new">  Die Ausnahme ist der <code>new</code> Operator. </h2><br><p>  Schauen Sie sich jetzt diesen Code an - er sieht ähnlich aus wie im vorherigen Beispiel, aber es gibt einen Unterschied. </p><br><pre> <code class="plaintext hljs">String duke = new String("duke"); String anotherDuke = new String("duke"); System.out.println(duke == anotherDuke);</code> </pre> <br><p>  Basierend auf dem vorherigen Beispiel könnten Sie denken, dass dieser Code <code>true</code> , dies ist jedoch nicht der <code>true</code> .  Durch Hinzufügen eines <code>new</code> Operators wird ein neues <code>String</code> Objekt im Speicher erstellt.  Somit erstellt die JVM zwei verschiedene Objekte. </p><br><blockquote>  <strong>Native Methoden</strong> <br><br>  Native Methoden in Java sind Methoden, die in der Sprache C kompiliert werden, normalerweise mit dem Ziel, den Speicher zu verwalten und die Leistung zu optimieren. </blockquote><br><h2 id="puly-strok-i-metod-intern">  String-Pools und <code>intern()</code> -Methode </h2><br><p>  Zum Speichern von Zeichenfolgen in einem Pool wird eine Methode namens String-Internierung verwendet. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Folgendes</a> erzählt uns <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Javadoc</a> über die <code>intern()</code> -Methode: </p><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/** *      . * *   ( )   {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> String}. * *    intern,     , *    {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> String},   *  {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> #equals(Object)},     . * ,   {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> String}   *        {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> String}. * *   ,      {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> s}  {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> t}, * {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> s.intern() == t.intern()}  {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> true} *    ,  {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> s.equals(t)}  {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> true}. * *       . *      3.10.5 The Java&amp;trade; Language Specification. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@returns</span></span></span><span class="hljs-comment"> ,         , * , ,       . * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@jls</span></span></span><span class="hljs-comment"> 3.10.5 String Literals */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">native</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">intern</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br><p>  Die <code>intern()</code> -Methode wird zum Speichern von Zeichenfolgen in einem Zeichenfolgenpool verwendet.  Zunächst wird überprüft, ob eine bereits erstellte Zeile im Pool vorhanden ist.  Wenn nicht, wird eine neue Zeile im Pool erstellt.  Die Zeilenpoollogik basiert auf dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Flyweight-</a> Muster. </p><br><p>  Beachten Sie nun, was passiert, wenn wir mit <code>new</code> zwei Zeilen erstellen: </p><br><pre> <code class="java hljs">String duke = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String(<span class="hljs-string"><span class="hljs-string">"duke"</span></span>); String duke2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String(<span class="hljs-string"><span class="hljs-string">"duke"</span></span>); System.out.println(duke == duke2); <span class="hljs-comment"><span class="hljs-comment">//    false System.out.println(duke.intern() == duke2.intern()); //    true</span></span></code> </pre> <br><p>  Im Gegensatz zum vorherigen Beispiel mit dem <code>new</code> Schlüsselwort gibt der Vergleich in diesem Fall <code>true</code> .  Dies liegt daran, dass durch die Verwendung der <code>intern()</code> -Methode sichergestellt wird, dass sich die Zeichenfolge im Pool befindet. </p><br><h2 id="metod-equals-v-klasse-string">  <code>equals</code> Methode in der <code>String</code> Klasse </h2><br><p>  Mit der Methode <code>equals()</code> wird überprüft, ob zwei Klassen gleich sind oder nicht.  Da sich <code>equals()</code> in der <code>Object</code> Klasse befindet, erbt jede Java-Klasse diese.  Die Methode <code>equals()</code> muss jedoch überschrieben werden, damit sie ordnungsgemäß funktioniert.  <code>String</code> überschreibt natürlich <code>equals()</code> . </p><br><p>  Schauen Sie mal rein: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object anObject)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == anObject) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (anObject <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String) { String aString = (String)anObject; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (coder() == aString.coder()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> isLatin1() ? StringLatin1.equals(value, aString.value) : StringUTF16.equals(value, aString.value); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; }</code> </pre> <br><p>  Wie Sie sehen können, wird der Wert der <code>String</code> Klasse durch <code>equals()</code> und nicht durch eine Objektreferenz verglichen.  Es spielt keine Rolle, ob die Verweise auf die Objekte unterschiedlich sind;  Bedingungen werden verglichen. </p><br><h2 id="naibolee-rasprostranennye-metody-string">  Allgemeine Zeichenfolgenmethoden </h2><br><p>  Bevor Sie das Problem mit dem Zeichenfolgenvergleich lösen, müssen Sie noch eines wissen. </p><br><p>  Betrachten Sie die gängigsten Methoden der <code>String</code> Klasse: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//         trim() //     substring(int beginIndex, int endIndex) //    length() //  ,     replaceAll(String regex, String replacement) // ,     CharSequence   contains(CharSequences)</span></span></code> </pre> <br><h2 id="reshite-zadachku-na-sravnenie-strok">  Lösen Sie das Problem mit dem Zeichenfolgenvergleich </h2><br><p>  Lassen Sie uns überprüfen, was Sie über die <code>String</code> Klasse gelernt haben, indem Sie ein kleines Rätsel lösen. </p><br><p>  In dieser Aufgabe vergleichen Sie mehrere Zeilen mit den erlernten Konzepten.  Können Sie anhand des folgenden Codes den Wert jedes variablen <code>result</code> bestimmen? </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ComparisonStringChallenge</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... doYourBest)</span></span></span><span class="hljs-function"> </span></span>{ String result = <span class="hljs-string"><span class="hljs-string">""</span></span>; result += <span class="hljs-string"><span class="hljs-string">" powerfulCode "</span></span>.trim() == <span class="hljs-string"><span class="hljs-string">"powerfulCode"</span></span> ? <span class="hljs-string"><span class="hljs-string">"0"</span></span> : <span class="hljs-string"><span class="hljs-string">"1"</span></span>; result += <span class="hljs-string"><span class="hljs-string">"flexibleCode"</span></span> == <span class="hljs-string"><span class="hljs-string">"flexibleCode"</span></span> ? <span class="hljs-string"><span class="hljs-string">"2"</span></span> : <span class="hljs-string"><span class="hljs-string">"3"</span></span>; result += <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String(<span class="hljs-string"><span class="hljs-string">"doYourBest"</span></span>) == <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String(<span class="hljs-string"><span class="hljs-string">"doYourBest"</span></span>) ? <span class="hljs-string"><span class="hljs-string">"4"</span></span> : <span class="hljs-string"><span class="hljs-string">"5"</span></span>; result += <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String(<span class="hljs-string"><span class="hljs-string">"noBugsProject"</span></span>) .equals(<span class="hljs-string"><span class="hljs-string">"noBugsProject"</span></span>) ? <span class="hljs-string"><span class="hljs-string">"6"</span></span> : <span class="hljs-string"><span class="hljs-string">"7"</span></span>; result += <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String(<span class="hljs-string"><span class="hljs-string">"breakYourLimits"</span></span>).intern() == <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String(<span class="hljs-string"><span class="hljs-string">"breakYourLimits"</span></span>).intern() ? <span class="hljs-string"><span class="hljs-string">"8"</span></span> : <span class="hljs-string"><span class="hljs-string">"9"</span></span>; System.out.println(result); } }</code> </pre> <br><p>  Was wird die Schlussfolgerung sein? </p><br><ul><li>  A: 02468 </li><li>  B: 12469 </li><li>  C: 12579 </li><li>  D: 12568 </li></ul><br><p>  Die richtige Antwort finden Sie am Ende des Artikels. </p><br><h2 id="chto-seychas-proizoshlo-ponimanie-povedeniya-string">  Was ist jetzt passiert?  Grundlegendes zum Verhalten von Zeichenfolgen </h2><br><p>  In der ersten Zeile sehen wir: </p><br><pre> <code class="java hljs">result += <span class="hljs-string"><span class="hljs-string">" powerfulCode "</span></span>.trim() == <span class="hljs-string"><span class="hljs-string">"powerfulCode"</span></span> ? <span class="hljs-string"><span class="hljs-string">"0"</span></span> : <span class="hljs-string"><span class="hljs-string">"1"</span></span>;</code> </pre> <br><p>  In diesem Fall ist das Ergebnis <code>false</code> , da beim Entfernen von Leerzeichen mit der Methode <code>trim()</code> mit dem <code>new</code> Operator ein neuer <code>String</code> erstellt wird. </p><br><p>  Als nächstes sehen wir: </p><br><pre> <code class="java hljs">result += <span class="hljs-string"><span class="hljs-string">"flexibleCode"</span></span> == <span class="hljs-string"><span class="hljs-string">"flexibleCode"</span></span> ? <span class="hljs-string"><span class="hljs-string">"2"</span></span> : <span class="hljs-string"><span class="hljs-string">"3"</span></span>;</code> </pre> <br><p>  Hier gibt es kein Geheimnis, die Zeilen im Zeilenpool sind gleich.  Dieser Vergleich gibt <code>true</code> . </p><br><p>  Dann haben wir: </p><br><pre> <code class="java hljs">result += <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String(<span class="hljs-string"><span class="hljs-string">"doYourBest"</span></span>) == <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String(<span class="hljs-string"><span class="hljs-string">"doYourBest"</span></span>) ? <span class="hljs-string"><span class="hljs-string">"4"</span></span> : <span class="hljs-string"><span class="hljs-string">"5"</span></span>;</code> </pre> <br><p>  Die Verwendung <code>new</code> Zeilen führt zur Erstellung von zwei neuen Zeilen, und es spielt keine Rolle, ob ihre Werte gleich sind oder nicht.  In diesem Fall ist der Vergleich auch dann <code>false</code> , wenn die Werte gleich sind. </p><br><p>  Weiter: </p><br><pre> <code class="java hljs">result += <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String(<span class="hljs-string"><span class="hljs-string">"noBugsProject"</span></span>) .equals(<span class="hljs-string"><span class="hljs-string">"noBugsProject"</span></span>) ? <span class="hljs-string"><span class="hljs-string">"6"</span></span> : <span class="hljs-string"><span class="hljs-string">"7"</span></span>;</code> </pre> <br><p>  Da wir die Methode <code>equals()</code> verwendet haben, wird der Wert der Zeichenfolge verglichen, nicht die Instanz des Objekts. </p><br><p>  In diesem Fall spielt es keine Rolle, ob verschiedene Objekte vorhanden sind oder nicht, da der Wert verglichen wird.  Das Ergebnis ist <code>true</code> . </p><br><p>  Endlich haben wir: </p><br><pre> <code class="java hljs">result += <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String(<span class="hljs-string"><span class="hljs-string">"breakYourLimits"</span></span>).intern() == <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String(<span class="hljs-string"><span class="hljs-string">"breakYourLimits"</span></span>).intern() ? <span class="hljs-string"><span class="hljs-string">"8"</span></span> : <span class="hljs-string"><span class="hljs-string">"9"</span></span>;</code> </pre> <br><p>  Wie Sie bereits gesehen haben, <code>intern()</code> die <code>intern()</code> -Methode einen String in einen String-Pool ein.  Beide Linien zeigen auf dasselbe Objekt, also in diesem Fall <code>true</code> . </p><br><h2 id="rasprostranennye-oshibki-so-strokami">  Häufige Zeichenfolgenfehler </h2><br><p>  Es kann schwierig sein zu bestimmen, ob zwei Linien auf dasselbe Objekt zeigen oder nicht, insbesondere wenn die Linien denselben Wert enthalten.  Es ist nützlich, sich daran zu erinnern, dass die Verwendung von <code>new</code> immer zur Erstellung eines neuen Objekts im Speicher führt, selbst wenn die Zeichenfolgenwerte gleich sind. </p><br><p>  Die Verwendung von <code>String</code> Methoden zum Vergleichen von Objektreferenzen kann ebenfalls schwierig sein.  Die Besonderheit ist, dass, wenn die Methode etwas in der Zeile ändert, unterschiedliche Verweise auf Objekte vorhanden sind. </p><br><p>  Einige Beispiele zur Verdeutlichung: </p><br><pre> <code class="java hljs">System.out.println(<span class="hljs-string"><span class="hljs-string">"duke"</span></span>.trim() == <span class="hljs-string"><span class="hljs-string">"duke"</span></span>.trim());</code> </pre> <br><p>  Dieser Vergleich ist wahr, da die <code>trim()</code> -Methode keine neue Zeile erstellt. </p><br><pre> <code class="java hljs">System.out.println(<span class="hljs-string"><span class="hljs-string">" duke"</span></span>.trim() == <span class="hljs-string"><span class="hljs-string">"duke"</span></span>.trim());</code> </pre> <br><p>  In diesem Fall generiert die erste <code>trim()</code> -Methode eine neue Zeile, da die Methode ihre Aufgabe erfüllt und daher die Verknüpfungen unterschiedlich sind. </p><br><p>  Wenn <code>trim()</code> seine Arbeit erledigt, erstellt es schließlich eine neue Zeile: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   trim   String new String(Arrays.copyOfRange(val, index, index + len), LATIN1);</span></span></code> </pre> <br><h2 id="chto-nuzhno-pomnit-o-strokah">  Woran Sie sich bei Saiten erinnern sollten </h2><br><ul><li><p>  Zeilen sind nicht veränderbar, daher kann der Zeilenstatus nicht geändert werden. </p><br></li><li><p>  Um Speicherplatz zu sparen, speichert die JVM Zeichenfolgen in einem Zeichenfolgenpool.  Beim Erstellen einer neuen Zeile überprüft die JVM ihren Wert und zeigt auf ein vorhandenes Objekt.  Wenn der Pool keine Zeile mit diesem Wert enthält, erstellt die JVM eine neue Zeile. </p><br></li><li><p>  Der Operator " <code>==</code> " vergleicht Objektreferenzen.  Die Methode <code>equals()</code> vergleicht Zeichenfolgenwerte.  Die gleiche Regel gilt für alle Objekte. </p><br></li><li><p>  Wenn Sie den <code>new</code> Operator verwenden, wird eine neue Zeile im Heap erstellt (Anmerkung des Übersetzers - es wird im Original geschrieben, dass sie sich im Pool befindet, aber dies ist nicht der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Fall</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">danke</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">zagayevskiy</a> ), selbst wenn es eine Zeile mit demselben Wert gibt. </p><br></li></ul><br><h2 id="otvet">  Die Antwort </h2><br><p>  Die Antwort auf dieses Problem lautet D. Die Schlussfolgerung lautet 12568. </p><br><p>  <em>Fortsetzung folgt...</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de428449/">https://habr.com/ru/post/de428449/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de428439/index.html">Ohne Ensemble</a></li>
<li><a href="../de428441/index.html">GitHub-Kauf abgeschlossen. Was wird als nächstes passieren?</a></li>
<li><a href="../de428443/index.html">Abstimmung - Überprüfung der Datenintegrität in verteilten Systemen</a></li>
<li><a href="../de428445/index.html">Wie wir in Helsinki einen Hackathon gemacht und verloren haben</a></li>
<li><a href="../de428447/index.html">Cloud Data Protection: Ein Leitfaden für Entwickler</a></li>
<li><a href="../de428451/index.html">KubeDirector ist eine einfache Möglichkeit, komplexe statusbehaftete Anwendungen in Kubernetes auszuführen</a></li>
<li><a href="../de428453/index.html">Wie Programmierer ihre Heimat retteten</a></li>
<li><a href="../de428457/index.html">Labels umgehen: SoundCloud hat direkte Verträge mit Musikern abgeschlossen - Bedingungen kritisiert</a></li>
<li><a href="../de428461/index.html">Aufbau eines verteilten VPN-Netzwerks basierend auf Check Point. Mehrere gängige Szenarien</a></li>
<li><a href="../de428465/index.html">Leitfaden zur Analyse der Geschäftsauswirkungen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>