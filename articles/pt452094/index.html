<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßìüèæ üôã üë©üèº‚Äç‚úàÔ∏è .NET: Ferramentas para trabalhar com multithreading e assincronia. Parte 1 üìè üñ≤Ô∏è üêì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Publico o artigo original sobre Habr, cuja tradu√ß√£o est√° publicada no blog da Codingsight . 
 A segunda parte est√° dispon√≠vel aqui. 

 A necessidade d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>.NET: Ferramentas para trabalhar com multithreading e assincronia. Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452094/">  <i>Publico o artigo original sobre Habr, cuja tradu√ß√£o est√° publicada no blog da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Codingsight</a> .</i> <br>  <i>A segunda parte est√° dispon√≠vel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui.</a></i> <br><br>  A necessidade de fazer algo de forma ass√≠ncrona, sem esperar pelo resultado aqui e agora, ou de compartilhar muito trabalho entre v√°rias unidades que o realizavam, era ainda antes do advento dos computadores.  Com sua apar√™ncia, essa necessidade se tornou muito tang√≠vel.  Agora, em 2019, digitando este artigo em um laptop com um processador Intel Core de 8 n√∫cleos, no qual n√£o cem processos funcionam ao mesmo tempo, mas ainda mais threads.  Ao lado dele, encontra-se um telefone ligeiramente desgastado, comprado h√° alguns anos, com um processador de 8 n√∫cleos a bordo.  Os recursos tem√°ticos est√£o cheios de artigos e v√≠deos em que seus autores admiram os principais smartphones deste ano, onde colocam processadores de 16 n√∫cleos.  Por menos de US $ 20 / hora, o MS Azure fornece uma m√°quina virtual com 128 processadores principais e 2 TB de RAM.  Infelizmente, √© imposs√≠vel maximizar e restringir esse poder sem poder controlar a intera√ß√£o dos fluxos. <br><a name="habracut"></a><br><h3>  Terminologia </h3><br>  <b>Processo</b> - Um objeto do SO, um espa√ßo de endere√ßo isolado, cont√©m threads. <br>  <b>Thread (Thread)</b> - um objeto do SO, a menor unidade de execu√ß√£o, parte de um processo, threads compartilha mem√≥ria e outros recursos entre si dentro do processo. <br>  <b>Multitarefa</b> √© um recurso do sistema operacional, a capacidade de executar v√°rios processos ao mesmo tempo <br>  <b>Multicore</b> - uma propriedade do processador, a capacidade de usar v√°rios n√∫cleos para processamento de dados <br>  <b>Multiprocessamento</b> - uma propriedade de um computador, a capacidade de trabalhar simultaneamente com v√°rios processadores fisicamente <br>  <b>Multithreading</b> √© uma propriedade de um processo, a capacidade de distribuir o processamento de dados entre v√°rios threads. <br>  <b>Paralelismo</b> - executando v√°rias a√ß√µes fisicamente ao mesmo tempo por unidade de tempo <br>  <b>Assincronia</b> - execu√ß√£o de uma opera√ß√£o sem aguardar o final desse processamento, o resultado da execu√ß√£o pode ser processado posteriormente. <br><br><h3>  Met√°fora </h3><br>  Como nem todas as defini√ß√µes s√£o boas e algumas precisam de explica√ß√µes adicionais, adicionarei uma met√°fora para o caf√© da manh√£ √† terminologia formalmente introduzida.  Cozinhar o caf√© da manh√£ nessa met√°fora √© um processo. <br><br>  Fazendo o caf√© da manh√£, eu ( <b>CPU</b> ) venho para a cozinha ( <b>Computador</b> ).  Eu tenho 2 m√£os ( <b>Cores</b> ).  A cozinha possui v√°rios dispositivos ( <b>IO</b> ): forno, chaleira, torradeira, geladeira.  Eu ligo o acelerador, coloco uma frigideira sobre ele e despejo √≥leo l√°, sem esperar at√© que aque√ßa ( <b>ass√≠ncrona, N√£o obstruindo-IO-Espere</b> ), tiro os ovos da geladeira e os quebro em um prato, depois bato com uma m√£o ( <b>T√≥pico # 1</b> ) e o segundo ( <b>T√≥pico # 2</b> ) seguro a placa (Recurso Compartilhado).  Agora eu ainda ligava a chaleira, mas n√£o h√° m√£os suficientes ( <b>Fome de Linha</b> ). Durante esse per√≠odo, a frigideira √© aquecida (Processando o resultado), onde despejo o que bati.  Pego a chaleira e a ligo e, estupidamente, observo como a √°gua ferve ( <b>Bloqueio-Espera-IO</b> ), embora eu pudesse lavar o prato durante esse tempo, onde bato na omelete. <br><br>  Eu cozinhei uma omelete usando apenas duas m√£os, mas n√£o tenho mais, mas ao mesmo tempo tr√™s opera√ß√µes foram realizadas no momento de chicotear uma omelete: chicoteando uma omelete, segurando uma placa, aquecendo uma frigideira. A CPU √© a parte mais r√°pida do computador, o IO √© mais frequente diminui a velocidade de tudo, com freq√º√™ncia uma solu√ß√£o eficaz √© pegar alguma CPU ao receber dados do IO. <br><br>  Continuando a met√°fora: <br><br><ul><li>  Se, no processo de preparar uma omelete, eu tamb√©m tentasse trocar de roupa, isso seria um exemplo de multitarefa.  Uma nuance importante: os computadores com isso s√£o muito melhores que as pessoas. </li><li>  Uma cozinha com v√°rios chefs, por exemplo em um restaurante, √© um computador com v√°rios n√∫cleos. </li><li>  Muitos restaurantes de pra√ßa de alimenta√ß√£o em um shopping center - data center </li></ul><br><h3>  Ferramentas .NET </h3><br>  Ao trabalhar com threads, como em muitas outras coisas, o .NET √© bom.  A cada nova vers√£o, ele apresenta mais e mais novas ferramentas para trabalhar com elas, novas camadas de abstra√ß√£o nos encadeamentos do SO.  Ao trabalhar com a constru√ß√£o de abstra√ß√µes, os desenvolvedores da estrutura usam a abordagem que deixa a possibilidade ao usar a abstra√ß√£o de alto n√≠vel; ela descer√° um ou v√°rios n√≠veis abaixo.  Na maioria das vezes isso n√£o √© necess√°rio; al√©m disso, isso abre a possibilidade de uma espingarda ser baleada no p√©, mas √†s vezes, em casos raros, pode ser a √∫nica maneira de resolver um problema que n√£o resolve no n√≠vel atual de abstra√ß√£o. <br><br>  Por ferramentas, refiro-me √†s interfaces de programa (APIs) fornecidas pela estrutura e aos pacotes de terceiros e a uma solu√ß√£o de software completa que simplifica a busca por problemas associados ao c√≥digo multithread. <br><br><h4>  In√≠cio do stream </h4><br>  A classe Thread, a classe mais b√°sica do .NET para trabalhar com threads.  O construtor aceita um dos dois delegados: <br><br><ul><li>  ThreadStart - sem par√¢metros </li><li>  ParametrizedThreadStart - com um par√¢metro do tipo objeto. </li></ul><br>  O delegado ser√° executado no thread rec√©m-criado depois de chamar o m√©todo Start, se um delegado do tipo ParametrizedThreadStart for passado para o construtor, um objeto dever√° ser passado para o m√©todo Start.  Esse mecanismo √© necess√°rio para transferir qualquer informa√ß√£o local para o fluxo.  Vale ressaltar que a cria√ß√£o de um encadeamento √© uma opera√ß√£o cara e o pr√≥prio encadeamento √© um objeto pesado, pelo menos porque 1 MB de mem√≥ria √© alocado para a pilha e requer intera√ß√£o com a API do SO. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(...).Start(...);</code> </pre> <br>  A classe ThreadPool representa o conceito de um pool.  No .NET, o pool de threads √© uma obra de arte e os desenvolvedores da Microsoft se esfor√ßam muito para faz√™-lo funcionar de maneira ideal em uma ampla variedade de cen√°rios. <br><br>  <b>Conceito geral:</b> <br><br>  <i>Desde o in√≠cio, o aplicativo em segundo plano cria v√°rios encadeamentos em reserva e oferece a oportunidade de us√°-los.</i>  <i>Se os encadeamentos forem usados ‚Äã‚Äãcom frequ√™ncia e em grandes n√∫meros, o pool se expandir√° para atender √† necessidade do c√≥digo de chamada.</i>  <i>Quando n√£o houver fluxos livres no pool no momento certo, ele aguardar√° o retorno de um dos fluxos ou criar√° um novo.</i>  <i>Daqui resulta que o conjunto de encadeamentos √© √≥timo para algumas a√ß√µes curtas e pouco adequado para opera√ß√µes que operam como um servi√ßo em todo o aplicativo.</i> <i><br><br></i>  <i>Para usar um encadeamento do pool, existe um m√©todo QueueUserWorkItem que aceita um delegado do tipo WaitCallback, que √© a mesma assinatura que ParametrizedThreadStart e o par√¢metro passado a ele executa a mesma fun√ß√£o.</i> <br><br><pre> <code class="cs hljs">ThreadPool.QueueUserWorkItem(...);</code> </pre><br>  O m√©todo de pool de encadeamentos menos conhecido, RegisterWaitForSingleObject, √© usado para organizar opera√ß√µes de E / S sem bloqueio.  O delegado passado para esse m√©todo ser√° chamado quando o WaitHandle passado para o m√©todo for "Liberado". <br><br><pre> <code class="cs hljs">ThreadPool.RegisterWaitForSingleObject(...)</code> </pre><br>  O .NET possui um cron√¥metro de fluxo e difere dos cron√¥metros WinForms / WPF, pois seu manipulador ser√° chamado em um fluxo retirado do pool. <br><br><pre> <code class="cs hljs">System.Threading.Timer</code> </pre><br>  Tamb√©m h√° uma maneira bastante ex√≥tica de enviar um representante para o thread do pool - o m√©todo BeginInvoke. <br><br><pre> <code class="cs hljs">DelegateInstance.BeginInvoke</code> </pre><br>  Tamb√©m quero insistir em transmitir uma fun√ß√£o que chama muitos dos m√©todos acima - CreateThread da API Win32 do Kernel32.dll.  Existe uma maneira, gra√ßas ao mecanismo de m√©todos externos para chamar essa fun√ß√£o.  Vi esse desafio apenas uma vez em um terr√≠vel exemplo de c√≥digo legado, e a motiva√ß√£o do autor para fazer exatamente isso ainda √© um mist√©rio para mim. <br><br><pre> <code class="cs hljs">Kernel32.dll CreateThread</code> </pre><br><h4>  Exibir e depurar threads </h4><br>  Os threads que voc√™ criou pessoalmente por todos os componentes de terceiros e o pool .NET podem ser exibidos na janela Threads Visual Studio.  Essa janela exibir√° informa√ß√µes sobre fluxos somente quando o aplicativo estiver em depura√ß√£o e no modo de interrup√ß√£o (modo de interrup√ß√£o).  Aqui voc√™ pode visualizar convenientemente os nomes e as prioridades da pilha de cada thread, alternar a depura√ß√£o para um thread espec√≠fico.  A propriedade Priority da classe Thread permite definir a prioridade do thread, que o OC e o CLR perceber√£o como uma recomenda√ß√£o ao dividir o tempo da CPU entre os threads. <br><br><img src="https://habrastorage.org/webt/ow/kq/i5/owkqi5zdx2m8oe7iava3q1mikri.png"><br><br><h4>  Biblioteca paralela de tarefas </h4><br>  A Biblioteca Paralela de Tarefas (TPL) apareceu no .NET 4.0.  Agora √© o padr√£o e a principal ferramenta para trabalhar com assincronia.  Qualquer c√≥digo que use uma abordagem mais antiga √© considerado legado.  A unidade b√°sica do TPL √© a classe Task do espa√ßo para nome System.Threading.Tasks.  Tarefa √© uma abstra√ß√£o sobre um encadeamento.  Com a nova vers√£o do C #, temos uma maneira elegante de trabalhar com os operadores Task - async / wait.  Esses conceitos tornaram poss√≠vel escrever c√≥digo ass√≠ncrono como se fosse simples e s√≠ncrono; isso possibilitou, mesmo para pessoas com pouco conhecimento da cozinha interna de encadeamentos, escrever aplicativos que os utilizavam, aplicativos que n√£o congelam durante opera√ß√µes longas.  O uso de async / waitit √© um t√≥pico para um ou v√°rios artigos, mas tentarei entender o essencial de algumas frases: <br><br><ul><li>  async √© um modificador do m√©todo que retorna Task ou void </li><li>  e aguardar √© a instru√ß√£o de espera sem bloqueio de tarefas. </li></ul><br>  Mais uma vez: o operador wait, no caso geral (h√° exce√ß√µes), lan√ßar√° ainda mais o encadeamento atual de execu√ß√£o, e quando a Tarefa terminar sua execu√ß√£o, e o encadeamento (na verdade √© mais correto dizer o contexto, mas mais sobre isso mais tarde) estar√° livre para continuar o m√©todo.  No .NET, esse mecanismo √© implementado da mesma maneira que o retorno de rendimento, quando um m√©todo escrito se transforma em uma classe inteira, que √© uma m√°quina de estados e pode ser executada em partes separadas, dependendo desses estados.  Qualquer pessoa interessada pode escrever qualquer c√≥digo simples usando ass√≠ncrono / aguardar, compilar e visualizar a montagem usando o JetBrains dotPeek com o c√≥digo gerado pelo compilador ativado. <br><br>  Considere as op√ß√µes para iniciar e usar a Tarefa.  Usando o exemplo de c√≥digo abaixo, criamos uma nova tarefa que n√£o √© √∫til ( <i>Thread.Sleep (10000)</i> ), mas na vida real deve ser algum tipo de trabalho complexo que envolve a CPU. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TCO = System.Threading.Tasks.TaskCreationOptions; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VoidAsyncMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cancellationSource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CancellationTokenSource(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Factory.StartNew( <span class="hljs-comment"><span class="hljs-comment">// Code of action will be executed on other context () =&gt; Thread.Sleep(10000), cancellationSource.Token, TCO.LongRunning | TCO.AttachedToParent | TCO.PreferFairness, scheduler ); // Code after await will be executed on captured context }</span></span></code> </pre><br>  A tarefa √© criada com v√°rias op√ß√µes: <br><br><ul><li>  LongRunning √© uma dica de que a tarefa n√£o ser√° conclu√≠da rapidamente, o que significa que pode valer a pena considerar n√£o retirar um thread do pool, mas criar um separado para esta Tarefa para n√£o prejudicar os outros. </li><li>  AttachedToParent - Tarefas podem ser organizadas em uma hierarquia.  Se essa op√ß√£o foi usada, a tarefa poder√° estar em um estado em que tenha sido conclu√≠da e esteja aguardando a conclus√£o dos filhos. </li><li>  PreferFairness - significa que seria bom executar as tarefas enviadas anteriormente para execu√ß√£o antes daquelas que foram enviadas posteriormente.  Mas isso √© apenas uma recomenda√ß√£o e o resultado n√£o √© garantido. </li></ul><br>  O segundo par√¢metro para o m√©todo passou CancellationToken.  Para processar corretamente o cancelamento de uma opera√ß√£o ap√≥s seu lan√ßamento, o c√≥digo executado deve ser preenchido com as verifica√ß√µes de status de CancellationToken.  Se n√£o houver verifica√ß√µes, o m√©todo Cancel chamado no objeto CancellationTokenSource poder√° parar a execu√ß√£o da Tarefa apenas antes de iniciar. <br><br>  O √∫ltimo par√¢metro passou o objeto do planejador do tipo TaskScheduler.  Essa classe e seus descendentes foram projetados para controlar as estrat√©gias de distribui√ß√£o de Task'ov por encadeamento; por padr√£o, a Tarefa ser√° executada em um encadeamento aleat√≥rio do pool. <br><br>  O operador wait √© aplicado √† tarefa criada, o que significa que o c√≥digo gravado depois dele, se houver, ser√° executado no mesmo contexto (geralmente isso significa que est√° no mesmo encadeamento) que o c√≥digo antes de aguardar. <br><br>  O m√©todo √© marcado como vazio ass√≠ncrono, o que significa que voc√™ pode usar o operador de espera nele, mas o c√≥digo de chamada n√£o pode esperar pela execu√ß√£o.  Se esse recurso for necess√°rio, o m√©todo deve retornar a tarefa.  Os m√©todos marcados como async void s√£o bastante comuns: como regra geral, trata-se de manipuladores de eventos ou outros m√©todos que trabalham com o princ√≠pio de disparar e esquecer.  Se voc√™ precisar n√£o apenas dar a oportunidade de esperar at√© a conclus√£o da execu√ß√£o, mas tamb√©m retornar o resultado, dever√° usar a Tarefa. <br><br>  Na tarefa que o m√©todo StartNew retornou, no entanto, como em qualquer outro, voc√™ pode chamar o m√©todo ConfigureAwait com o par√¢metro false; a execu√ß√£o ap√≥s aguardar continuar√° n√£o no contexto capturado, mas em um contexto arbitr√°rio.  Isso sempre deve ser feito quando o contexto de execu√ß√£o n√£o for importante para o c√≥digo ap√≥s aguardar.  Tamb√©m √© uma recomenda√ß√£o da MS ao escrever o c√≥digo de que ele ser√° fornecido em um formul√°rio de biblioteca. <br><br>  Vamos pensar um pouco mais em como voc√™ pode esperar at√© a conclus√£o da tarefa.  Abaixo est√° um c√≥digo de exemplo, com coment√°rios, quando a espera √© feita condicionalmente boa e quando condicionalmente ruim. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnotherMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> AsyncMethod(); <span class="hljs-comment"><span class="hljs-comment">// good result = AsyncMethod().Result; // bad AsyncMethod().Wait(); // bad IEnumerable&lt;Task&gt; tasks = new Task[] { AsyncMethod(), OtherAsyncMethod() }; await Task.WhenAll(tasks); // good await Task.WhenAny(tasks); // good Task.WaitAll(tasks.ToArray()); // bad }</span></span></code> </pre><br>  No primeiro exemplo, aguardamos a conclus√£o da tarefa e, sem bloquear o segmento de chamada, retornaremos ao processamento do resultado apenas quando ele j√° estiver l√°, at√© que o segmento de chamada seja deixado sozinho. <br><br>  Na segunda op√ß√£o, bloqueamos o thread de chamada at√© que o resultado do m√©todo seja calculado.  Isso √© ruim n√£o apenas porque pegamos o encadeamento, um recurso t√£o valioso do programa, por simples ociosidade, mas tamb√©m porque, se o c√≥digo do m√©todo que chamamos aguardar, e o contexto de sincroniza√ß√£o envolver o retorno ao encadeamento de chamada depois de aguardar, teremos um conflito. : o encadeamento de chamada aguarda at√© que o resultado do m√©todo ass√≠ncrono seja calculado, o m√©todo ass√≠ncrono tenta em v√£o continuar sua execu√ß√£o no encadeamento de chamada. <br><br>  Outra desvantagem dessa abordagem √© o tratamento de erros complicado.  O fato √© que os erros no c√≥digo ass√≠ncrono ao usar async / waitit s√£o muito f√°ceis de manipular - eles se comportam como se o c√≥digo fosse s√≠ncrono.  Embora, se aplicarmos <s>exorcismo,</s> expectativa s√≠ncrona a Tarefa, a exce√ß√£o original se transformar em uma AggregateException, ou seja,  Para manipular uma exce√ß√£o, voc√™ ter√° que examinar o tipo InnerException e escrever a cadeia if dentro de um bloco catch ou usar a catch quando construir em vez da cadeia de blocos catch mais familiar em C #. <br><br>  O terceiro e o √∫ltimo exemplo tamb√©m s√£o marcados como ruins pelo mesmo motivo e cont√™m todos os mesmos problemas. <br><br>  Quando os m√©todos AnyAny e WhenAll s√£o extremamente convenientes na espera de um grupo de Task'ov, eles agrupam um grupo de Task'ov em um, que funcionar√° na primeira opera√ß√£o da Task'a do grupo ou quando todos terminarem sua execu√ß√£o. <br><br><h4>  Parada de fluxo </h4><br>  Por v√°rios motivos, pode ser necess√°rio interromper o fluxo ap√≥s o in√≠cio.  Existem v√°rias maneiras de fazer isso.  A classe Thread possui dois m√©todos com nomes apropriados - <b>Interromper</b> e <b>Interromper</b> .  O primeiro n√£o √© recomendado para uso, pois  ap√≥s ser chamado em qualquer momento aleat√≥rio, durante o processamento de qualquer instru√ß√£o, uma <b>ThreadAbortedException</b> ser√° lan√ßada.  Voc√™ n√£o espera que essa exce√ß√£o falhe ao incrementar uma vari√°vel inteira, certo?  E ao usar esse m√©todo, essa √© uma situa√ß√£o muito real.  Se voc√™ deseja impedir que o CLR lance uma exce√ß√£o em uma se√ß√£o espec√≠fica do c√≥digo, √© poss√≠vel <b>agrup√°-</b> lo nas chamadas para <b>Thread.BeginCriticalRegion</b> , <b>Thread.EndCriticalRegion</b> .  Qualquer c√≥digo escrito em um bloco final √© envolvido com essas chamadas.  Por esse motivo, nas entranhas do c√≥digo da estrutura, voc√™ pode encontrar blocos com uma tentativa vazia, mas n√£o uma vazia finalmente.  A Microsoft n√£o recomenda o uso desse m√©todo, que n√£o o incluiu no n√∫cleo .net. <br><br>  O m√©todo Interrup√ß√£o funciona de forma mais previs√≠vel.  Ele pode interromper um encadeamento com exce√ß√£o de <b>ThreadInterruptedException</b> somente quando o encadeamento estiver no estado ocioso.  Nesse estado, ele fica em suspens√£o enquanto aguarda WaitHandle, lock ou ap√≥s chamar Thread.Sleep. <br><br>  Ambas as op√ß√µes descritas acima s√£o ruins por sua imprevisibilidade.  A solu√ß√£o √© usar a estrutura <b>CancellationToken</b> e a classe <b>CancellationTokenSource</b> .  A linha inferior √©: uma inst√¢ncia da classe CancellationTokenSource √© criada e somente a pessoa que a possui pode parar a opera√ß√£o chamando o m√©todo <b>Cancel</b> .  Somente o CancellationToken √© passado para a pr√≥pria opera√ß√£o.  Os propriet√°rios do CancellationToken n√£o podem cancelar a opera√ß√£o, mas podem apenas verificar se a opera√ß√£o foi cancelada.  Para fazer isso, h√° uma propriedade booleana <b>IsCancellationRequested</b> e o m√©todo <b>ThrowIfCancelRequested</b> .  O √∫ltimo gerar√° uma <b>TaskCancelledException</b> se o m√©todo Cancel for chamado na inst√¢ncia CancellationToken cancelada do CancellationTokenSource.  E √© esse m√©todo que eu recomendo usar.  Isso √© melhor do que as op√ß√µes anteriores, obtendo controle total sobre os pontos em que a opera√ß√£o de exce√ß√£o pode ser interrompida. <br><br>  A op√ß√£o mais cruel para interromper o segmento √© chamar a fun√ß√£o TerminateThread da API do Win32.  O comportamento do CLR ap√≥s chamar esta fun√ß√£o pode ser imprevis√≠vel.  No MSDN, foi escrito o seguinte sobre esta fun√ß√£o: <i>‚ÄúTerminateThread √© uma fun√ß√£o perigosa que s√≥ deve ser usada nos casos mais extremos.</i>  <i>"</i> <br><br><h4>  Converter API herdada em Baseado em Tarefas usando o m√©todo FromAsync </h4><br>  Se voc√™ teve a sorte de trabalhar em um projeto iniciado depois que as tarefas foram introduzidas e deixou de causar um horror silencioso para a maioria dos desenvolvedores, n√£o precisar√° lidar com muitas APIs antigas, tanto de terceiros quanto de sua equipe torturadas no passado.  Felizmente, a equipe de desenvolvimento do .NET Framework cuidou de n√≥s, embora talvez o objetivo fosse cuidar de n√≥s mesmos.  Seja como for, o .NET possui v√°rias ferramentas para a convers√£o simples de c√≥digos escritos em abordagens de programa√ß√£o ass√≠ncrona antiga para uma nova.  Um deles √© o m√©todo FromAsync do TaskFactory.  Usando o exemplo de c√≥digo abaixo, envolvo os m√©todos ass√≠ncronos antigos da classe WebRequest na tarefa usando esse m√©todo. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> state = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; WebRequest wr = WebRequest.CreateHttp(<span class="hljs-string"><span class="hljs-string">"http://github.com"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Factory.FromAsync( wr.BeginGetResponse, we.EndGetResponse );</code> </pre><br>  <i>Este √© apenas um exemplo, e √© improv√°vel que voc√™ fa√ßa isso com tipos internos, mas qualquer projeto antigo est√° simplesmente repleto de m√©todos BeginDoSomething que retornam os m√©todos IAsyncResult e EndDoSomething que o aceitam.</i> <br><br><h4>  Converter API herdada em Baseado em Tarefas usando a classe TaskCompletionSource </h4><br>  Outra ferramenta importante a considerar √© a classe <b>TaskCompletionSource</b> .  Em termos de fun√ß√µes, objetivo e princ√≠pio de opera√ß√£o, ele pode de alguma forma lembrar o m√©todo RegisterWaitForSingleObject da classe ThreadPool sobre a qual escrevi acima.  Usando essa classe, voc√™ pode agrupar APIs ass√≠ncronas antigas de maneira f√°cil e conveniente na tarefa. <br><br>  <i>Voc√™ dir√° que eu j√° falei sobre o m√©todo FromAsync da classe TaskFactory destinado a esses fins.</i>  <i>Aqui, teremos de recordar todo o hist√≥rico do desenvolvimento de modelos ass√≠ncronos em .net que a Microsoft oferece h√° 15 anos: antes do TAP, havia o padr√£o de programa√ß√£o ass√≠ncrona (APP), que tratava dos m√©todos <b>Begin</b> DoSomething que retornam os m√©todos <b>IAsyncResult</b> e <b>End</b> DoSomething que o aceitam. e o m√©todo FromAsync √© adequado para o legado desses anos, mas, com o tempo, foi substitu√≠do pelo <b>EAP</b> (Event Based Asynchronous Pattern), que supunha que um evento seria acionado quando a opera√ß√£o ass√≠ncrona fosse conclu√≠da.</i> <br><br>  TaskCompletionSource √© √≥timo para agrupar na Task e na API herdada criada em torno do modelo de evento.  A ess√™ncia de seu trabalho √© a seguinte: um objeto dessa classe possui uma propriedade p√∫blica do tipo Task, cujo estado pode ser controlado pelos m√©todos SetResult, SetException etc. da classe TaskCompletionSource.  Nos locais em que o operador de espera foi aplicado a esta tarefa, ele ser√° executado ou travado com uma exce√ß√£o, dependendo do m√©todo aplicado ao TaskCompletionSource.  Se tudo ainda n√£o estiver claro, vejamos este exemplo de c√≥digo, em que alguma API EAP antiga √© agrupada na Tarefa usando TaskCompletionSource: quando o evento √© disparado, a Tarefa ser√° transferida para o estado Conclu√≠do e o m√©todo que aplicou o operador de espera a esta Tarefa continuar√° a execu√ß√£o obtendo o objeto de <b>resultado</b> . <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Task&lt;Result&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> SomeApiInstance someApiObj</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> completionSource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskCompletionSource&lt;Result&gt;(); someApiObj.Done += result =&gt; completionSource.SetResult(result); someApiObj.Do(); result completionSource.Task; }</code> </pre><br><h4>  Dicas e truques para fonte de tarefas </h4><br>  O agrupamento de APIs antigas n√£o √© tudo o que voc√™ pode fazer com TaskCompletionSource.  O uso dessa classe abre uma possibilidade interessante de criar v√°rias APIs em tarefas que n√£o ocupam threads.  E o fluxo, como lembramos, √© um recurso caro e seu n√∫mero √© limitado (principalmente pela RAM).  Essa limita√ß√£o √© facilmente alcan√ßada atrav√©s do desenvolvimento, por exemplo, de um aplicativo da web carregado com l√≥gica de neg√≥cios complexa.  Considere as possibilidades de que estou falando sobre a implementa√ß√£o de um truque como a pesquisa longa. <br><br>  <i>Em resumo, a ess√™ncia do truque √© esta: voc√™ precisa obter informa√ß√µes da API sobre alguns eventos que ocorrem do seu lado, enquanto a API, por algum motivo, n√£o pode relatar o evento, mas pode retornar apenas o estado.</i>  <i>Um exemplo disso s√£o todas as APIs criadas sobre HTTP antes dos tempos do WebSocket ou quando, por algum motivo, n√£o √© poss√≠vel usar essa tecnologia.</i>  <i>O cliente pode perguntar ao servidor HTTP.</i>  <i>Um servidor HTTP n√£o pode, por si s√≥, provocar comunica√ß√£o com um cliente.</i>  <i>Uma solu√ß√£o simples √© interrogar o servidor por timer, mas isso cria uma carga adicional no servidor e um atraso adicional em m√©dia TimerInterval / 2. Para contornar isso, foi inventado um truque chamado Long Polling, que envolve atrasar a resposta do servidor at√© o tempo limite expirar ou um evento vai acontecer.</i>  <i>Se um evento ocorreu, ele √© processado; caso contr√°rio, a solicita√ß√£o √© enviada novamente.</i> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!eventOccures &amp;&amp; !timeoutExceeded) { CheckTimout(); CheckEvent(); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre><br>  Mas essa solu√ß√£o se mostrar√° terrivelmente assim que o n√∫mero de clientes que aguardam o evento aumentar, porque  Cada um desses clientes, em antecipa√ß√£o ao evento, ocupa um fluxo inteiro.  Sim, e temos um atraso adicional de 1ms no acionamento do evento, na maioria das vezes n√£o √© significativo, mas por que tornar o software pior do que pode ser?  Se voc√™ remover o Thread.Sleep (1), em v√£o carregaremos um n√∫cleo do processador com 100% de ociosidade, girando em um ciclo in√∫til.  Usando TaskCompletionSource, voc√™ pode facilmente refazer esse c√≥digo e resolver todos os problemas identificados acima: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">LongPollingApi</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, TaskCompletionSource&lt;Msg&gt;&gt; tasks; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;Msg&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcceptMessageAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> userId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> duration</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskCompletionSource&lt;Msg&gt;(); tasks[userId] = cs; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.WhenAny(Task.Delay(duration), cs.Task); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cs.Task.IsCompleted ? cs.Task.Result : <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendMessage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> userId, Msg m</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tasks.TryGetValue(userId, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> completionSource)) completionSource.SetResult(m); } }</code> </pre><br>  <i>Este c√≥digo n√£o est√° pronto para produ√ß√£o, mas apenas uma demonstra√ß√£o.</i>  <i>Para us√°-lo em casos reais, voc√™ precisa pelo menos lidar com a situa√ß√£o quando uma mensagem chegar no momento em que ningu√©m a espera: nesse caso, o m√©todo AsseptMessageAsync deve retornar uma tarefa j√° conclu√≠da.</i>  <i>Se esse caso for o mais frequente, voc√™ poder√° pensar em usar o ValueTask.</i> <br><br>  Ap√≥s o recebimento de uma solicita√ß√£o de mensagem, criamos e colocamos TaskCompletionSource no dicion√°rio e aguardamos o que acontece primeiro: o intervalo de tempo especificado expira ou uma mensagem √© recebida. <br><br><h4>  ValueTask: por que e como </h4><br>  Operadores ass√≠ncronos / esperados, como o operador de retorno de rendimento, geram uma m√°quina de estado a partir do m√©todo, que est√° criando um novo objeto, que quase sempre n√£o √© importante, mas em casos raros, pode criar um problema.  Este caso pode ser um m√©todo chamado com muita frequ√™ncia, falando sobre dezenas e centenas de milhares de chamadas por segundo.  Se esse m√©todo for escrito para que, na maioria dos casos, retorne um resultado ignorando todos os m√©todos de espera, o .NET fornecer√° uma ferramenta para otimizar isso - a estrutura ValueTask.  Para deixar claro, considere um exemplo de uso: existe um cache para o qual acessamos com muita frequ√™ncia.  Existem alguns valores nele e, em seguida, n√≥s os devolvemos, se n√£o, ent√£o vamos a um IO lento por tr√°s deles.  Eu quero fazer o √∫ltimo assincronamente, o que significa que todo o m√©todo √© ass√≠ncrono.  Assim, a maneira √≥bvia de escrever um m√©todo √© a seguinte: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetById</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cache.TryGetValue(id, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> val)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> RequestById(id); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Devido ao desejo de otimizar um pouco e um leve medo do que Roslyn gerar√° ao compilar esse c√≥digo, podemos reescrever este exemplo da seguinte maneira: </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetById</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cache.TryGetValue(id, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> val)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.FromResult(val); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> RequestById(id); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> De fato, a solu√ß√£o ideal nesse caso √© otimizar o caminho ativo, ou seja, obter o valor do dicion√°rio sem aloca√ß√µes e carga extras no GC, enquanto nesses casos raros em que ainda precisamos ir para o IO, tudo permanecer√° mais / menos antigo: </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ValueTask&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetById</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cache.TryGetValue(id, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> val)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ValueTask&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(val); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ValueTask&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(RequestById(id)); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos dar uma olhada mais de perto neste fragmento de c√≥digo: se houver um valor no cache, criamos uma estrutura, caso contr√°rio, a tarefa real ser√° agrupada em uma significativa. </font><font style="vertical-align: inherit;">O c√≥digo de chamada n√£o se importa de que maneira esse c√≥digo foi executado: a ValueTask do ponto de vista da sintaxe C # se comportar√° exatamente como a Tarefa usual neste caso.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> TaskSchedulers: Gerenciando estrat√©gias de inicializa√ß√£o de tarefas </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A pr√≥xima API que eu gostaria de considerar √© a classe </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TaskScheduler</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e seus derivados. </font><font style="vertical-align: inherit;">Eu j√° mencionei acima que no TPL existe a capacidade de controlar as estrat√©gias de distribui√ß√£o de Task'ov por thread. </font><font style="vertical-align: inherit;">Essas estrat√©gias s√£o definidas nos descendentes da classe TaskScheduler. </font><font style="vertical-align: inherit;">Quase toda estrat√©gia necess√°ria pode ser encontrada na biblioteca </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ParallelExtensionsExtras</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , desenvolvida pela microsoft, mas n√£o parte do .NET, mas entregue como um pacote Nuget. </font><font style="vertical-align: inherit;">Vamos considerar brevemente alguns deles:</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CurrentThreadTaskScheduler</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Executa Tarefa no thread atual</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LimitedConcurrencyLevelTaskScheduler</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - limita o n√∫mero de tarefas executadas simultaneamente ao par√¢metro N, aceito no construtor</font></font></li><li> <b>OrderedTaskScheduler</b> ‚Äî   LimitedConcurrencyLevelTaskScheduler(1),     . </li><li> <b>WorkStealingTaskScheduler</b> ‚Äî  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">work-stealing</a>    .     ThreadPool.   ,   .NET ThreadPool   ,    ,                  .        . ..      WorkStealingTaskScheduler'    ,   ThreadPool     . </li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QueuedTaskScheduler</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - permite executar tarefas de acordo com as regras da fila com prioridades</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ThreadPerTaskScheduler</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - cria um thread separado para cada tarefa executada nele. </font><font style="vertical-align: inherit;">Pode ser √∫til para tarefas com dura√ß√£o imprevis√≠vel.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H√° um bom </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artigo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> detalhado </font><font style="vertical-align: inherit;">sobre TaskSchedulers no blog da microsoft. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para uma depura√ß√£o conveniente de tudo relacionado a Tarefas no Visual Studio, h√° uma janela Tarefas. </font><font style="vertical-align: inherit;">Nesta janela, voc√™ pode ver o status atual da tarefa e ir para a linha de c√≥digo atualmente em execu√ß√£o.</font></font><br><br><img src="https://habrastorage.org/webt/tb/fv/3l/tbfv3l-sdz-jw0mpcakbt_-lve8.png"><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PLinq e a classe Parallel </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√©m do Task e tudo o que foi dito com eles no .NET, existem mais duas ferramentas interessantes: PLinq (Linq2Parallel) e a classe Parallel. O primeiro promete execu√ß√£o paralela de todas as opera√ß√µes do Linq em v√°rios encadeamentos. O n√∫mero de threads pode ser configurado com o m√©todo de extens√£o WithDegreeOfParallelism. Infelizmente, na maioria das vezes o PLinq no modo de execu√ß√£o, por padr√£o, n√£o possui informa√ß√µes suficientes sobre a fonte de dados para fornecer um ganho de velocidade significativo, por outro lado, o pre√ßo da tentativa √© muito baixo: basta chamar o m√©todo AsParallel na frente da cadeia de m√©todos do Linq e realizar testes de desempenho. Al√©m disso, √© poss√≠vel transferir para o PLinq informa√ß√µes adicionais sobre a natureza da sua fonte de dados usando o mecanismo Partitions. Voc√™ pode ler mais </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A classe est√°tica Parallel fornece m√©todos para iterar sobre uma cole√ß√£o Foreach em paralelo, executando um loop For e executando v√°rios delegados em paralelo a Invoke. A execu√ß√£o do encadeamento atual ser√° interrompida at√© o final dos c√°lculos. O n√∫mero de threads pode ser configurado passando ParallelOptions como o √∫ltimo argumento. Usando as op√ß√µes, voc√™ tamb√©m pode especificar TaskScheduler e CancellationToken.</font></font><br><br><h4>  Conclus√µes </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando comecei a escrever este artigo com base nos materiais do meu relat√≥rio e nas informa√ß√µes que coletei durante o trabalho depois dele, n√£o esperava que o resultado fosse tanto. </font><font style="vertical-align: inherit;">Agora, quando o editor de texto em que estou digitando este artigo reprovadoramente me disser que a 15¬™ p√°gina se foi, resumirei os resultados intermedi√°rios. </font><font style="vertical-align: inherit;">Outros truques, APIs, ferramentas visuais e armadilhas ser√£o discutidos em um artigo futuro. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclus√µes:</font></font></b> <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Voc√™ precisa conhecer as ferramentas para trabalhar com threads, assincronia e paralelismo para usar os recursos dos PCs modernos. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O .NET possui muitas ferramentas diferentes para esse fim. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nem todos eles apareceram de uma s√≥ vez, porque o legado pode ser encontrado com frequ√™ncia, no entanto, existem maneiras de converter APIs antigas sem muito esfor√ßo. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O trabalho com threads no .NET √© representado pelas classes Thread e ThreadPool </font></font></li><li>  Thread.Abort, Thread.Interrupt,  Win32 API TerminateThread      .      CancellationToken' </li><li>  ‚Äî  ,   .   ,     .      TaskCompletionSource </li><li>      .NET        Task'. </li><li>  c# async/await     </li><li>   Task'       TaskScheduler'  </li><li>  ValueTask      hot-paths  memory-traffic </li><li>  Tasks  Threads Visual Studio           </li><li> PLinq  ,            ,        partitioning </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> ... </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt452094/">https://habr.com/ru/post/pt452094/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt452082/index.html">Fluxo flex√≠vel de atualiza√ß√µes no aplicativo: acelere o processo de atualiza√ß√£o de aplicativos no Android</a></li>
<li><a href="../pt452086/index.html">O que h√° no meu pixel para voc√™: cria√ß√£o de nanopixels usando metassuperf√≠cies de plasmon</a></li>
<li><a href="../pt452088/index.html">Reconhecimento de estradas por segmenta√ß√£o sem√¢ntica</a></li>
<li><a href="../pt452090/index.html">Criando um gerador de quebra-cabe√ßas procedural</a></li>
<li><a href="../pt452092/index.html">Atualiza√ß√µes no aplicativo: Acelerando as atualiza√ß√µes de aplicativos Android</a></li>
<li><a href="../pt452098/index.html">Logs do desenvolvedor front-end Habr: refator e reflexo</a></li>
<li><a href="../pt452102/index.html">Jogo de fotos para quem gosta de drones: brevemente sobre o AirSelfie 2</a></li>
<li><a href="../pt452106/index.html">Convidamos palestrantes para a reuni√£o de bricolage de ver√£o em 16 de junho de 2019</a></li>
<li><a href="../pt452108/index.html">Docker: conselhos inofensivos</a></li>
<li><a href="../pt452110/index.html">Automatize a substitui√ß√£o do disco com o Ansible</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>