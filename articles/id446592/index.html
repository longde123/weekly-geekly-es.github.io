<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñïüèæ üîì üë®üèª‚Äçüé§ Memeriksa kode sumber Roslyn üöØ üßóüèº üß¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dari waktu ke waktu, kami kembali ke proyek yang sebelumnya kami uji dengan PVS-Studio dan menulis artikel tentang itu. Ada dua alasan untuk melakukan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memeriksa kode sumber Roslyn</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/446592/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/833/abb/d94/833abbd94d6e48526a175b89fffc9dd5.png" alt="PVS-Studio vs Roslyn"></div><br>  Dari waktu ke waktu, kami kembali ke proyek yang sebelumnya kami uji dengan PVS-Studio dan menulis artikel tentang itu.  Ada dua alasan untuk melakukan ini.  Pertama, untuk memahami seberapa baik analisa kami.  Kedua, untuk melacak apakah penulis proyek memperhatikan artikel kami, serta laporan kesalahan yang biasanya kami berikan kepada mereka.  Tentu saja, kesalahan dapat diperbaiki tanpa partisipasi kami.  Tapi itu selalu baik ketika tepatnya upaya kami membantu membuat proyek menjadi lebih baik.  Roslyn tidak terkecuali.  Artikel ulasan sebelumnya tentang proyek ini berasal dari 23 Desember 2015.  Ini cukup lama, mengingat jalur yang telah ditempuh oleh analis kami dalam pengembangannya selama ini.  Bagi kami secara pribadi, Roslyn juga memiliki minat tambahan dengan fakta bahwa inti dari C # analyzer PVS-Studio didasarkan padanya.  Oleh karena itu, kami sangat tertarik dengan kualitas kode untuk proyek ini.  Kami akan mengatur pemeriksaan kedua dan mencari tahu apa yang baru dan menarik (tapi semoga tidak ada yang signifikan) PVS-Studio dapat temukan di sana. <br><a name="habracut"></a><br>  Roslyn (atau .NET Compiler Platform) mungkin akrab bagi banyak pembaca kami.  Singkatnya, ini adalah kumpulan kompiler sumber terbuka dan API untuk analisis kode untuk bahasa C # dan Visual Basic .NET.  Kode sumber untuk proyek tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> . <br><br>  Saya tidak akan memberikan uraian terperinci tentang platform ini, tetapi saya akan merekomendasikan kepada semua orang yang tertarik dengan artikel oleh kolega saya Sergey Vasiliev, " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengantar Roslyn. Menggunakan alat analisis statis untuk mengembangkan</a> ."  Dari artikel ini Anda dapat belajar tidak hanya tentang fitur arsitektur Roslyn, tetapi juga bagaimana tepatnya kita menggunakan platform ini. <br><br>  Seperti yang saya sebutkan sebelumnya, lebih dari tiga tahun telah berlalu sejak penulisan artikel terakhir oleh rekan saya Andrei Karpov tentang cek Roslyn " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rilis Tahun Baru PVS-Studio 6.00: memeriksa Roslyn</a> ".  Selama ini, penganalisa C # PVS-Studio telah memperoleh banyak fitur baru.  Secara umum, artikel Andrey adalah semacam "bola uji", karena C # analyzer hanya ditambahkan ke PVS-Studio saat itu.  Meskipun demikian, meskipun demikian, dalam proyek berkualitas tinggi tanpa syarat, Roslyn berhasil menemukan kesalahan yang menarik.  Apa yang telah berubah dalam alat analisis untuk kode C # sejauh ini, yang berpotensi memungkinkan analisis yang lebih dalam? <br><br>  Selama beberapa waktu terakhir, inti penganalisa dan infrastruktur telah berkembang.  Dukungan ditambahkan untuk Visual Studio 2017 dan Roslyn 2.0, serta integrasi mendalam dengan MSBuild.  Anda dapat membaca lebih lanjut tentang pendekatan kami untuk integrasi dengan MSBuild dan tentang alasan yang membuat kami menerimanya dalam artikel oleh rekan saya Pavel Yeremeyev, " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dukungan untuk Visual Studio 2017 dan Roslyn 2.0 di PVS-Studio: kadang-kadang menggunakan solusi yang sudah jadi tidak semudah kelihatannya sekilas</a> . " <br><br>  Sekarang kami secara aktif bekerja pada transisi ke Roslyn 3.0 sesuai dengan skema yang sama yang kami awalnya mendukung Visual Studio 2017, yaitu, melalui toolset kami sendiri, yang datang dalam kit distribusi PVS-Studio dengan "rintisan" dalam bentuk file MSBuild.exe kosong.  Terlepas dari kenyataan bahwa itu terlihat seperti "penopang" (API MSBuild tidak terlalu ramah untuk digunakan kembali dalam proyek-proyek patry ketiga karena portabilitas yang rendah dari perpustakaan), pendekatan ini telah membantu kami menghidupkan kembali beberapa pembaruan Roslyn yang relatif tanpa rasa sakit selama kehidupan Visual Studio 2017. dan sekarang, meskipun dengan sejumlah besar overlay, selamat dari upgrade ke Visual Studio 2019, serta mempertahankan kompatibilitas mundur penuh dan kinerja pada sistem dengan versi MSBuild yang lebih lama. <br><br>  Inti penganalisa juga telah mengalami sejumlah perbaikan.  Salah satu inovasi utama adalah analisis antar-prosedur yang lengkap, dengan mempertimbangkan nilai input dan output metode, dengan mempertimbangkan, tergantung pada parameter ini, jangkauan cabang-cabang eksekusi dan poin pengembalian. <br><br>  Tugas melacak parameter di dalam metode sudah hampir selesai, sambil mempertahankan anotasi otomatis untuk apa yang terjadi dengan parameter ini di sana (misalnya, dereferencing yang berpotensi berbahaya).  Ini akan memungkinkan untuk diagnostik apa pun yang menggunakan mekanisme aliran data untuk memperhitungkan situasi berbahaya yang terjadi ketika meneruskan parameter ke suatu metode.  Sebelumnya, ketika menganalisis tempat berbahaya seperti itu, peringatan tidak dibuat, karena kami tidak bisa mengetahui semua nilai input yang mungkin untuk metode tersebut.  Sekarang kita dapat mendeteksi bahaya, karena di semua tempat di mana metode ini dipanggil, parameter input ini akan diperhitungkan. <br><br>  Catatan: Anda dapat membiasakan diri dengan mekanisme utama alat analisis, seperti aliran data dan lainnya, dari artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Teknologi yang Digunakan dalam Penganalisis Kode PVS-Studio untuk Menemukan Kesalahan dan Kerentanan Potensial</a> ". <br><br>  Analisis antar-prosedur dalam PVS-Studio C # tidak dibatasi oleh parameter input atau kedalaman.  Satu-satunya batasan adalah metode virtual di kelas yang tidak ditutup untuk warisan dan jatuh ke rekursi (kita akan berhenti ketika kita melihat pada stack panggilan berulang ke metode yang sudah dihitung).  Selain itu, metode rekursif itu sendiri pada akhirnya akan dihitung dengan asumsi bahwa nilai kembalinya rekursi sendiri tidak diketahui. <br><br>  Inovasi besar lainnya dalam penganalisis C # adalah kemungkinan dereferensi penunjuk yang berpotensi nol.  Sebelumnya, analisa bersumpah pada pengecualian referensi nol yang mungkin jika yakin bahwa di semua cabang eksekusi nilai variabel akan menjadi nol.  Tentu saja, ia terkadang salah, sehingga diagnostik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3080</a> sebelumnya disebut referensi nol potensial. <br><br>  Sekarang penganalisa mengingat bahwa variabel bisa nol di salah satu cabang eksekusi (misalnya, dalam kondisi tertentu jika).  Jika dia melihat akses ke variabel seperti itu tanpa memeriksa, dia akan mendapatkan pesan V3080, tetapi pada tingkat kepentingan yang lebih rendah daripada jika dia melihat nol di semua cabang.  Dalam kombinasi dengan peningkatan analisis antarproedural, mekanisme semacam itu memungkinkan menemukan kesalahan yang sangat sulit dideteksi.  Contohnya adalah rangkaian panjang pemanggilan metode, yang terakhir yang tidak Anda kenal, dan yang, misalnya, mengembalikan nol dalam keadaan tertentu, tetapi Anda tidak melindungi diri dari ini karena Anda sama sekali tidak mengetahuinya.  Dalam hal ini, penganalisa hanya bersumpah ketika secara tepat melihat penugasan nol.  Menurut pendapat kami, ini secara kualitatif membedakan pendekatan kami dari inovasi C # 8.0 sebagai jenis referensi yang dapat dibatalkan, yang, pada kenyataannya, bermuara pada pengaturan pemeriksaan nol dalam setiap metode.  Kami menawarkan alternatif - untuk melakukan pemeriksaan hanya di mana null benar-benar dapat datang, dan penganalisa kami sekarang dapat mencari situasi seperti itu. <br><br>  Jadi, tanpa penundaan, mari beralih ke "tanya jawab" - menganalisis hasil pemeriksaan Roslyn.  Pertama, mari kita lihat kesalahan yang ditemukan berkat inovasi yang dijelaskan di atas.  Secara umum, beberapa peringatan dikeluarkan untuk kode Roslyn kali ini.  Saya pikir ini disebabkan oleh kenyataan bahwa platform berkembang sangat aktif (basis kode saat ini berada di sekitar 2.770.000 baris kode, tidak termasuk yang kosong), dan kami belum melakukan analisis proyek ini untuk waktu yang lama.  Namun, tidak ada begitu banyak kesalahan kritis, yaitu mereka menarik untuk artikel ini.  Dan ya, ada beberapa tes di Roslyn yang saya, seperti biasa, tidak termasuk dalam pengujian. <br><br>  Saya akan mulai dengan kesalahan V3080, dengan tingkat kekritisan sedang, di mana penganalisa mendeteksi kemungkinan akses melalui tautan nol, tetapi tidak dalam semua kasus yang mungkin (cabang kode). <br><br>  <b>Kemungkinan null dereference - Medium</b> <br><br>  V3080 Kemungkinan null dereference.  Pertimbangkan untuk memeriksa 'saat ini'.  CSharpSyntaxTreeFactoryService.PositionalSyntaxReference.cs 70 <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> SyntaxNode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SyntaxNode root)</span></span></span><span class="hljs-function"> </span></span>{ var current = root; .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current.FullSpan.Contains(....)) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { .... var nodeOrToken = current.ChildThatContainsPosition(....); .... current = nodeOrToken.AsNode(); // &lt;= } .... } public SyntaxNode AsNode() { if (_token != null) { return null; } return _nodeOrParent; }</span></span></code> </pre> <br>  Pertimbangkan metode <i>GetNode</i> .  Penganalisa menganggap bahwa akses dengan referensi nol dimungkinkan dalam kondisi blok <i>sementara</i> .  Di dalam tubuh blok <i>sementara</i> , variabel <i>saat ini</i> akan diberi nilai - hasil dari eksekusi metode <i>AsNode</i> .  Dan nilai ini dalam beberapa kasus akan menjadi <i>nol</i> .  Contoh yang baik dari analisis antar prosedur dalam aksi. <br><br>  Sekarang pertimbangkan kasus serupa di mana analisis antar-prosedur dilakukan melalui dua pemanggilan metode. <br><br>  V3080 Kemungkinan null dereference.  Pertimbangkan untuk memeriksa 'direktori'.  CommonCommandLineParser.cs 911 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> IEnumerable&lt;CommandLineSourceFile&gt; ExpandFileNamePattern(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> path, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> baseDirectory, ....) { <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> directory = PathUtilities.GetDirectoryName(path); .... var resolvedDirectoryPath = (directory.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) ? <span class="hljs-comment"><span class="hljs-comment">// &lt;= baseDirectory : FileUtilities.ResolveRelativePath(directory, baseDirectory); .... } public static string GetDirectoryName(string path) { return GetDirectoryName(path, IsUnixLikePlatform); } internal static string GetDirectoryName(string path, bool isUnixLike) { if (path != null) { .... } return null; }</span></span></code> </pre> <br>  Variabel <i>direktori</i> dalam tubuh metode <i>ExpandFileNamePattern</i> mendapatkan nilai dari metode <i>GetDirectoryName</i> <i>(string)</i> .  Itu, pada gilirannya, akan mengembalikan hasil dari metode <i>GetDirectoryName (string, bool)</i> yang kelebihan beban, nilainya mungkin <i>nol</i> .  Karena lebih jauh dalam tubuh metode <i>ExpandFileNamePattern</i> variabel <i>direktori</i> digunakan tanpa memeriksa awal untuk kesetaraan <i>nol</i> , kita dapat berbicara tentang legitimasi peringatan oleh penganalisis.  Ini adalah desain yang berpotensi tidak aman. <br><br>  Sepotong kode dengan kesalahan V3080, lebih tepatnya, segera dengan dua kesalahan yang dikeluarkan untuk satu baris kode.  Di sini, analisis antar-prosedur tidak diperlukan. <br><br>  V3080 Kemungkinan null dereference.  Pertimbangkan untuk memeriksa 'spanStartLocation'.  TestWorkspace.cs 574 <br><br>  V3080 Kemungkinan null dereference.  Pertimbangkan untuk memeriksa 'spanEndLocationExclusive'.  TestWorkspace.cs 574 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MapMarkupSpans</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (....) { .... foreach (....) { .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>? spanStartLocation = null; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>? spanEndLocationExclusive = null; foreach (....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spanStartLocation == null &amp;&amp; positionInMarkup &lt;= markupSpanStart &amp;&amp; ....) { .... spanStartLocation = ....; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spanEndLocationExclusive == null &amp;&amp; positionInMarkup &lt;= markupSpanEndExclusive &amp;&amp; ....) { .... spanEndLocationExclusive = ....; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } .... } .... } tempMappedMarkupSpans[key]. Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TextSpan( spanStartLocation.Value, <span class="hljs-comment"><span class="hljs-comment">// &lt;= spanEndLocationExclusive.Value - // &lt;= spanStartLocation.Value)); } } .... }</span></span></code> </pre> <br>  <i>Variabel spanStartLocation</i> dan <i>spanEndLocationExclusive</i> adalah tipe <i>nullable int</i> dan diinisialisasi ke <i>nol</i> .  Lebih lanjut dalam kode mereka dapat diberi nilai, tetapi hanya jika kondisi tertentu terpenuhi.  Dalam beberapa kasus, nilainya akan tetap sama dengan <i>nol</i> .  Lebih lanjut dalam kode, variabel-variabel ini diakses dengan referensi tanpa terlebih dahulu memeriksa kesetaraan <i>nol</i> , seperti yang ditunjukkan oleh penganalisa. <br><br>  Kode Roslyn mengandung beberapa kesalahan seperti itu, lebih dari 100. Seringkali pola kesalahan ini sama.  Ada beberapa metode umum yang berpotensi menghasilkan <i>null</i> .  Hasil dari metode ini digunakan di banyak tempat, kadang-kadang melalui puluhan panggilan metode menengah atau pemeriksaan tambahan.  Penting untuk dipahami bahwa kesalahan ini tidak fatal, tetapi mereka berpotensi menyebabkan akses melalui tautan nol.  Dan untuk mendeteksi kesalahan seperti itu sangat sulit.  Oleh karena itu, dalam beberapa kasus, Anda harus mempertimbangkan refactoring kode, di mana pengecualian akan dilemparkan jika metode mengembalikan <i>nol</i> .  Jika tidak, Anda hanya dapat mengamankan kode Anda dengan total cek, yang cukup membosankan dan tidak dapat diandalkan.  Tentu saja, dalam setiap kasus, keputusan harus dibuat berdasarkan karakteristik proyek. <br><br>  Catatan  Itu terjadi bahwa saat ini tidak ada situasi (input data) di mana metode mengembalikan <i>nol</i> dan tidak ada kesalahan nyata.  Namun, kode semacam itu masih tidak dapat diandalkan, karena semuanya dapat berubah ketika perubahan dilakukan pada kode tersebut. <br><br>  Untuk menutup topik dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3080</a> , mari kita lihat kesalahan yang jelas dengan tingkat kepercayaan tinggi, ketika akses melalui tautan nol lebih mungkin atau bahkan tidak terhindarkan. <br><br>  <b>Kemungkinan null dereference - Tinggi</b> <br><br>  V3080 Kemungkinan null dereference.  Pertimbangkan untuk memeriksa 'collectionType.Type'.  AbstractConvertForToForEachCodeRefactoringProvider.cs 137 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override async Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ComputeRefactoringsAsync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CodeRefactoringContext context)</span></span></span><span class="hljs-function"> </span></span>{ .... var collectionType = semanticModel.GetTypeInfo(....); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collectionType.Type == null &amp;&amp; collectionType.Type.TypeKind == TypeKind.Error) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } .... }</code> </pre> <br>  Karena kesalahan ketik dalam kondisi (alih-alih operator <i>|| yang</i> kami gunakan <i>&amp;&amp;</i> ), kode tidak berfungsi sebagaimana dimaksud, dan variabel <i>collectionType.Type</i> akan diakses jika <i>nol</i> .  Kondisi tersebut harus diperbaiki sebagai berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collectionType.Type == null || collectionType.Type.TypeKind == TypeKind.Error) ....</code> </pre> <br>  Omong-omong, varian kedua dari pengembangan acara juga dimungkinkan: di bagian pertama, kondisinya digabungkan oleh operator <i>==</i> dan <i>! =</i> .  Maka kode yang diperbaiki adalah: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collectionType.Type != null &amp;&amp; collectionType.Type.TypeKind == TypeKind.Error) ....</code> </pre> <br>  Versi kode ini kurang logis, tetapi juga memperbaiki kesalahan.  Keputusan akhir tergantung pada penulis proyek. <br><br>  Kesalahan serupa lainnya. <br><br>  V3080 Kemungkinan null dereference.  Pertimbangkan untuk memeriksa 'tindakan'.  TextViewWindow_InProc.cs 372 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Func&lt;IWpfTextView, Task&gt; GetLightBulbApplicationAction(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (action == null) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException( $<span class="hljs-string"><span class="hljs-string">"Unable to find FixAll in {fixAllScope.ToString()} code fix for suggested action '{action.DisplayText}'."</span></span>); } .... }</code> </pre> <br>  Kesalahan dibuat saat menulis pesan untuk pengecualian.  Pada saat yang sama, upaya dilakukan untuk mengakses properti <i>action.DisplayText</i> melalui variabel <i>tindakan</i> , yang jelas <i>nol</i> . <br><br>  Dan kesalahan terakhir adalah V3080 High level. <br><br>  V3080 Kemungkinan null dereference.  Pertimbangkan untuk memeriksa 'tipe'.  ObjectFormatterHelpers.cs 91 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsApplicableAttribute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TypeInfo type, TypeInfo targetType, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> targetTypeName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type != null &amp;&amp; AreEquivalent(targetType, type) || targetTypeName != null &amp;&amp; type.FullName == targetTypeName; }</code> </pre> <br>  Metode ini kecil, jadi saya memberikan seluruh kodenya.  Kondisi di blok <i>kembali</i> salah.  Dalam beberapa kasus, dimungkinkan untuk melempar <i>NullReferenceException</i> saat mengakses <i>type.FullName</i> .  Saya menggunakan tanda kurung (mereka tidak akan mengubah perilaku di sini) untuk mengklarifikasi situasi: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (type != null &amp;&amp; AreEquivalent(targetType, type)) || (targetTypeName != null &amp;&amp; type.FullName == targetTypeName);</code> </pre> <br>  Begitulah, sesuai dengan prioritas operasi, kode ini akan berfungsi.  Jika variabel <i>type</i> adalah <i>null</i> , kita masuk ke cek lain, di mana, memastikan variabel <i>targetTypeName</i> adalah <i>null</i> , kami menggunakan referensi <i>tipe</i> nol.  Anda dapat memperbaiki kode, misalnya, seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type != null &amp;&amp; (AreEquivalent(targetType, type) || targetTypeName != null &amp;&amp; type.FullName == targetTypeName);</code> </pre> <br>  Saya pikir di situlah Anda dapat menyelesaikan studi tentang kesalahan V3080 dan melihat apa lagi yang berhasil ditemukan oleh penganalisa PVS-Studio dalam kode Roslyn. <br><br>  <b>Salah ketik</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3005 Variabel</a> 'SourceCodeKind' ditugaskan untuk dirinya sendiri.  DynamicFileInfo.cs 17 <br><br><pre> <code class="cpp hljs">internal sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DynamicFileInfo</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DynamicFileInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> filePath, SourceCodeKind sourceCodeKind, TextLoader textLoader, IDocumentServiceProvider documentServiceProvider)</span></span></span><span class="hljs-function"> </span></span>{ FilePath = filePath; SourceCodeKind = SourceCodeKind; <span class="hljs-comment"><span class="hljs-comment">// &lt;= TextLoader = textLoader; DocumentServiceProvider = documentServiceProvider; } .... }</span></span></code> </pre> <br>  Karena nama variabel yang gagal, salah ketik dibuat di konstruktor kelas <i>DynamicFileInfo</i> .  Bidang <i>SourceCodeKind</i> diberikan nilainya sendiri, alih-alih menggunakan parameter <i>sourceCodeKind</i> .  Untuk meminimalkan kemungkinan kesalahan tersebut, disarankan untuk menggunakan awalan garis bawah untuk nama parameter dalam kasus tersebut.  Saya akan memberikan contoh versi kode yang diperbaiki: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DynamicFileInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _filePath, SourceCodeKind _sourceCodeKind, TextLoader _textLoader, IDocumentServiceProvider _documentServiceProvider)</span></span></span><span class="hljs-function"> </span></span>{ FilePath = _filePath; SourceCodeKind = _sourceCodeKind; TextLoader = _textLoader; DocumentServiceProvider = _documentServiceProvider; }</code> </pre> <br>  <b>Kecerobohan</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3006</a> Objek telah dibuat tetapi tidak sedang digunakan.  Kata kunci 'melempar' bisa hilang: lempar InvalidOperationException (FOO) baru.  ProjectBuildManager.cs 61 <br><br><pre> <code class="cpp hljs">~ProjectBuildManager() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_batchBuildStarted) { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">"ProjectBuilderManager.Stop() not called."</span></span>); } }</code> </pre> <br>  Di bawah kondisi tertentu, destruktor harus melempar pengecualian, tetapi ini tidak terjadi, dan objek pengecualian hanya dibuat.  Kata kunci <i>lemparan</i> dihilangkan.  Versi kode yang diperbaiki: <br><br><pre> <code class="cpp hljs">~ProjectBuildManager() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_batchBuildStarted) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">"ProjectBuilderManager.Stop() not called."</span></span>); } }</code> </pre> <br>  Masalah bekerja dengan destruktor di C # dan melemparkan pengecualian dari mereka adalah topik untuk diskusi terpisah, yang berada di luar cakupan artikel ini. <br><br>  <b>Ketika hasilnya tidak penting</b> <br><br>  Sejumlah peringatan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3009 telah</a> diterima untuk metode yang mengembalikan nilai yang sama dalam semua kasus.  Kadang-kadang ini tidak kritis, atau kode kembali tidak diperiksa dalam kode panggilan.  Saya melewatkan peringatan seperti itu.  Tetapi beberapa kode terasa mencurigakan bagi saya.  Saya akan mengutip salah satu dari mereka: <br><br>  V3009 Aneh bahwa metode ini selalu mengembalikan satu dan nilai yang sama dari 'benar'.  GoToDefinitionCommandHandler.cs 62 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (context.OperationContext.AddScope(....)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Metode <i>TryExecuteCommand</i> hanya mengembalikan <i>true</i> , dan tidak lain kecuali <i>true</i> .  Pada saat yang sama, nilai pengembalian terlibat dalam beberapa pemeriksaan dalam kode panggilan: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (caretPos.HasValue &amp;&amp; TryExecuteCommand(....)) { .... } .... }</code> </pre> <br>  Sulit untuk mengatakan betapa berbahayanya perilaku ini.  Tetapi jika hasilnya tidak diperlukan, mungkin perlu mengganti jenis kembali dengan void dan membuat sedikit perubahan pada metode pemanggilan.  Ini akan membuat kode lebih mudah dimengerti dan aman. <br><br>  Peringatan serupa lainnya: <br><br><ul><li>  V3009 Aneh bahwa metode ini selalu mengembalikan satu dan nilai yang sama dari 'benar'.  CommentUncommentSelectionCommandHandler.cs 86 </li><li>  V3009 Aneh bahwa metode ini selalu mengembalikan satu dan nilai yang sama dari 'benar'.  RenameTrackingTaggerProvider.RenameTrackingCommitter.cs 99 </li><li>  V3009 Aneh bahwa metode ini selalu mengembalikan satu dan nilai yang sama dari 'benar'.  JsonRpcClient.cs 138 </li><li>  V3009 Aneh bahwa metode ini selalu mengembalikan satu dan nilai yang sama dari 'benar'.  AbstractFormatEngine.OperationApplier.cs 164 </li><li>  V3009 Aneh bahwa metode ini selalu mengembalikan satu dan nilai yang sama 'salah'.  TriviaDataFactory.CodeShapeAnalyzer.cs 254 </li><li>  V3009 Aneh bahwa metode ini selalu mengembalikan satu dan nilai yang sama dari 'benar'.  ObjectList.cs 173 </li><li>  V3009 Aneh bahwa metode ini selalu mengembalikan satu dan nilai yang sama dari 'benar'.  ObjectList.cs 249 </li></ul><br>  <b>Tidak dicentang</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3019</a> Mungkin variabel yang salah dibandingkan dengan nol setelah konversi jenis menggunakan kata kunci 'sebagai'.  Periksa variabel 'nilai', 'valueToSerialize'.  RoamingVisualStudioProfileOptionPersister.cs 277 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryPersist</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OptionKey optionKey, object value)</span></span></span><span class="hljs-function"> </span></span>{ .... var valueToSerialize = value as NamingStylePreferences; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value != null) { value = valueToSerialize.CreateXElement().ToString(); } .... }</code> </pre> <br>  Nilai variabel adalah tipe <i>NamingStylePreferences</i> .  Masalahnya mengikuti cek ini.  Bahkan jika variabel <i>nilai</i> bukan nol, ini tidak menjamin bahwa konversi tipe berhasil dan <i>valueToSerialize</i> tidak mengandung <i>nol</i> .  <i>NullReferenceException dapat dilempar</i> .  Kode perlu diperbaiki sebagai berikut: <br><br><pre> <code class="cpp hljs">var valueToSerialize = value as NamingStylePreferences; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (valueToSerialize != null) { value = valueToSerialize.CreateXElement().ToString(); }</code> </pre> <br>  Dan satu lagi kesalahan serupa. <br><br>  V3019 Mungkin variabel yang salah dibandingkan dengan nol setelah konversi jenis menggunakan kata kunci 'sebagai'.  Periksa variabel 'columnState', 'columnState2'.  StreamingFindUsagesPresenter.cs 181 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetDefinitionGroupingPriority</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (var columnState in ....) { var columnState2 = columnState as ColumnState2; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (columnState?.Name == <span class="hljs-comment"><span class="hljs-comment">// &lt;= StandardTableColumnDefinitions2.Definition) { newColumns.Add(new ColumnState2( columnState2.Name, // &lt;= ....)); } .... } .... }</span></span></code> </pre> <br>  Variabel <i>columnState</i> adalah tipe <i>ColumnState2</i> .  Namun, hasil operasi, variabel <i>columnState2</i> , tidak diperiksa lebih lanjut untuk <i>null</i> .  Sebagai gantinya, variabel <i>columnState</i> diperiksa menggunakan pernyataan <i>null</i> bersyarat.  Apa bahayanya kode ini?  Seperti dalam contoh sebelumnya, ketik casting menggunakan operator <i>as</i> mungkin gagal, dan variabel <i>columnState2</i> akan menjadi <i>nol</i> , yang selanjutnya akan melempar pengecualian.  Ngomong-ngomong, kesalahan ketik mungkin bisa disalahkan.  Perhatikan kondisi di blok <i>if</i> .  Mungkin alih-alih <i>columnState? .Name</i> mereka ingin menulis <i>columnState2? .Name</i> .  Ini sangat mungkin diberikan nama variabel yang agak disayangkan <i>columnState dan columnState2.</i> <br><br>  <b>Cek berlebihan</b> <br><br>  Sejumlah besar peringatan (lebih dari 100) dikeluarkan untuk konstruksi yang tidak kritis, tetapi berpotensi tidak aman terkait dengan cek yang berlebihan.  Sebagai contoh, saya akan memberikan salah satunya. <br><br>  Ekspresi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3022</a> 'navInfo == null' selalu salah.  AbstractSyncClassViewCommandHandler.cs 101 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... IVsNavInfo navInfo = null; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (symbol != null) { navInfo = libraryService.NavInfoFactory.CreateForSymbol(....); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (navInfo == null) { navInfo = libraryService.NavInfoFactory.CreateForProject(....); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (navInfo == null) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { return true; } .... } public IVsNavInfo CreateForSymbol(....) { .... return null; } public IVsNavInfo CreateForProject(....) { return new NavInfo(....); }</span></span></code> </pre> <br>  Mungkin tidak ada kesalahan nyata di sini.  Hanya alasan yang bagus untuk menunjukkan kombinasi teknologi "analisis antar-proses + analisis aliran data" dalam tindakan.  Penganalisa menganggap bahwa cek kedua <i>navInfo == null adalah</i> mubazir.  Memang, sebelum itu, nilai untuk menetapkan <i>navInfo</i> akan diperoleh dari <i>libraryService.NavInfoFactory.CreateForProject</i> , yang akan membangun dan mengembalikan objek baru dari kelas <i>NavInfo</i> .  Tapi bukan <i>nol</i> sama sekali.  Pertanyaannya adalah, mengapa penganalisis tidak <i>menghasilkan</i> peringatan untuk pemeriksaan pertama <i>navInfo == null</i> ?  Ada penjelasan untuk ini.  Pertama, jika variabel <i>simbol</i> ternyata <i>nol</i> , maka nilai <i>navInfo</i> akan tetap menjadi referensi nol.  Kedua, bahkan jika <i>navInfo</i> mendapatkan nilai dari metode <i>libraryService.NavInfoFactory.CreateForSymbol</i> , nilai ini mungkin <i>nol</i> .  Jadi pemeriksaan pertama <i>navInfo == null</i> benar-benar diperlukan. <br><br>  <b>Cek tidak cukup</b> <br><br>  Dan sekarang situasinya adalah kebalikan dari yang di atas.  Beberapa peringatan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3042</a> diterima untuk kode yang dapat diakses dengan referensi nol.  Selain itu, hanya satu atau dua cek kecil yang dapat memperbaiki semuanya. <br><br>  Pertimbangkan satu bagian kode yang menarik yang mengandung dua kesalahan seperti itu. <br><br>  V3042 Kemungkinan NullReferenceException.  '?.'  dan '.'  operator digunakan untuk mengakses anggota objek 'penerima' Binder_Expressions.cs 7770 <br><br>  V3042 Kemungkinan NullReferenceException.  '?.'  dan '.'  operator digunakan untuk mengakses anggota objek 'penerima' Binder_Expressions.cs 7776 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> BoundExpression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetReceiverForConditionalBinding</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ExpressionSyntax binding, DiagnosticBag diagnostics)</span></span></span><span class="hljs-function"> </span></span>{ .... BoundExpression receiver = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ConditionalReceiverExpression; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (receiver?.Syntax != <span class="hljs-comment"><span class="hljs-comment">// &lt;= GetConditionalReceiverSyntax(conditionalAccessNode)) { receiver = BindConditionalAccessReceiver(conditionalAccessNode, diagnostics); } var receiverType = receiver.Type; // &lt;= if (receiverType?.IsNullableType() == true) { .... } receiver = new BoundConditionalReceiver(receiver.Syntax, 0, // &lt;= receiverType ?? CreateErrorType(), hasErrors: receiver.HasErrors) // &lt;= { WasCompilerGenerated = true }; return receiver; }</span></span></code> </pre> <br>  Variabel <i>penerima</i> bisa <i>nol</i> .  Penulis kode mengetahui hal ini karena ia menggunakan operator <i>null</i> bersyarat dalam kondisi blok <i>if</i> untuk mengakses <i>receiver? .Sinktax</i> .  Lebih lanjut dalam kode, <i>penerima</i> variabel digunakan tanpa pemeriksaan untuk mengakses <i>receiver. Jenis</i> , <i>penerima</i> . <i>Sintaks</i> dan <i>penerima</i> . <i>Memiliki Kesalahan</i> .  Kesalahan ini perlu diperbaiki: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> BoundExpression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetReceiverForConditionalBinding</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ExpressionSyntax binding, DiagnosticBag diagnostics)</span></span></span><span class="hljs-function"> </span></span>{ .... BoundExpression receiver = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ConditionalReceiverExpression; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (receiver?.Syntax != GetConditionalReceiverSyntax(conditionalAccessNode)) { receiver = BindConditionalAccessReceiver(conditionalAccessNode, diagnostics); } var receiverType = receiver?.Type; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (receiverType?.IsNullableType() == <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { .... } receiver = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BoundConditionalReceiver(receiver?.Syntax, <span class="hljs-number"><span class="hljs-number">0</span></span>, receiverType ?? CreateErrorType(), hasErrors: receiver?.HasErrors) { WasCompilerGenerated = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> receiver; }</code> </pre> <br>  Anda juga perlu memastikan bahwa konstruktor <i>BoundConditionalReceiver</i> mendukung mendapatkan nilai <i>nol</i> untuk parameternya, atau melakukan refactoring tambahan. <br><br>  Kesalahan serupa lainnya: <br><br><ul><li>  V3042 Kemungkinan NullReferenceException.  '?.'  dan '.'  operator digunakan untuk mengakses anggota objek 'mengandungType' SyntaxGeneratorExtensions_Negate.cs 240 </li><li>  V3042 Kemungkinan NullReferenceException.  '?.'  dan '.'  operator digunakan untuk mengakses anggota objek 'ekspresi' ExpressionSyntaxExtensions.cs 349 </li><li>  V3042 Kemungkinan NullReferenceException.  '?.'  dan '.'  operator digunakan untuk mengakses anggota objek 'ekspresi' ExpressionSyntaxExtensions.cs 349 </li></ul><br>  <b>Kesalahan dalam kondisi</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3057</a> Fungsi 'Substring' dapat menerima nilai '-1' sementara nilai non-negatif diharapkan.  Periksa argumen kedua.  CommonCommandLineParser.cs 109 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryParseOption</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colon &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { name = arg.Substring(<span class="hljs-number"><span class="hljs-number">1</span></span>, colon - <span class="hljs-number"><span class="hljs-number">1</span></span>); value = arg.Substring(colon + <span class="hljs-number"><span class="hljs-number">1</span></span>); } .... }</code> </pre> <br>  Jika variabel <i>titik dua</i> adalah 0, yang memungkinkan suatu kondisi dalam kode, metode <i>Substring akan</i> melempar <i>ArgumentOutOfRangeException</i> .  Diperlukan koreksi: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colon &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  <b>Mungkin salah ketik</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3065</a> Parameter 't2' tidak digunakan di dalam tubuh metode.  CSharpCodeGenerationHelpers.cs 84 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> TypeDeclarationSyntax </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReplaceUnterminatedConstructs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... var updatedToken = lastToken.ReplaceTrivia(lastToken.TrailingTrivia, (t1, t2) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t1.Kind() == SyntaxKind.MultiLineCommentTrivia) { var text = t1.ToString(); .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t1.Kind() == SyntaxKind.SkippedTokensTrivia) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ReplaceUnterminatedConstructs(t1); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t1; }); .... }</code> </pre> <br>  Dua parameter dilewatkan ke ekspresi lambda: t1 dan t2.  Namun, hanya t1 yang digunakan.  Itu terlihat mencurigakan, mengingat betapa mudahnya melakukan kesalahan saat menggunakan variabel dengan nama-nama ini. <br><br>  <b>Kecerobohan</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3083</a> Doa yang tidak aman dari acara 'TagsChanged', NullReferenceException dimungkinkan.  Pertimbangkan menugaskan acara ke variabel lokal sebelum menjalankannya.  PreviewUpdater.Tagger.cs 37 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnTextBufferChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PreviewUpdater.SpanToShow != <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TagsChanged != null) { var span = _textBuffer.CurrentSnapshot.GetFullSpan(); TagsChanged(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SnapshotSpanEventArgs(span)); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } } }</span></span></code> </pre> <br>  Acara <i>TagsChanged</i> dipicu tidak aman.  Antara memeriksa kesetaraan <i>nol</i> dan memanggil suatu acara, mereka mungkin punya waktu untuk berhenti berlangganan darinya, maka pengecualian akan dilemparkan.  Selain itu, di badan blok <i>if</i> , sesaat sebelum acara dipanggil, beberapa operasi lain dilakukan.  Saya menyebut kesalahan ini "Ketidakpedulian", karena di tempat lain dalam kode mereka bekerja dengan acara ini lebih akurat, misalnya, seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnTrackingSpansChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> leafChanged)</span></span></span><span class="hljs-function"> </span></span>{ var handler = TagsChanged; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handler != null) { var snapshot = _buffer.CurrentSnapshot; handler(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SnapshotSpanEventArgs(snapshot.GetFullSpan())); } }</code> </pre> <br>  Menggunakan variabel <i>handler</i> opsional menghilangkan masalah.  Dalam metode <i>OnTextBufferChanged</i> , <i>Anda</i> perlu mengedit untuk operasi aman yang sama dengan acara tersebut. <br><br>  <b>Rentang berpotongan</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3092</a> Range intersection dimungkinkan dalam ekspresi bersyarat.  Contoh: if (A&gt; 0 &amp;&amp; A &lt;5) {...} lain jika (A&gt; 3 &amp;&amp; A &lt;9) {...}.  ILBuilderEmit.cs 677 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EmitLongConstant</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MinValue &amp;&amp; value &lt;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= uint.MinValue &amp;&amp; value &lt;= uint.MaxValue) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } }</code> </pre> <br>  Untuk pemahaman yang lebih baik, saya akan menulis ulang fragmen kode ini, mengganti nama konstan dengan nilai aktualnya: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EmitLongConstant</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= <span class="hljs-number"><span class="hljs-number">-2147483648</span></span> &amp;&amp; value &lt;= <span class="hljs-number"><span class="hljs-number">2147483648</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; value &lt;= <span class="hljs-number"><span class="hljs-number">4294967295</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } }</code> </pre> <br>  Mungkin, tidak ada kesalahan nyata, tetapi kondisinya terlihat aneh.  Bagian kedua ( <i>jika tidak</i> ) akan dilakukan hanya untuk rentang nilai dari 2147483648 + 1 hingga 4294967295. <br><br>  Beberapa lagi dari peringatan ini: <br><br><ul><li>  V3092 Range intersection dimungkinkan dalam ekspresi bersyarat.  Contoh: if (A&gt; 0 &amp;&amp; A &lt;5) {...} lain jika (A&gt; 3 &amp;&amp; A &lt;9) {...}.  LocalRewriter_Literal.cs 109 </li><li>  V3092 Range intersection dimungkinkan dalam ekspresi bersyarat.  Contoh: if (A&gt; 0 &amp;&amp; A &lt;5) {...} lain jika (A&gt; 3 &amp;&amp; A &lt;9) {...}.  LocalRewriter_Literal.cs 66 </li></ul><br>  <b>Lebih lanjut tentang pemeriksaan kesetaraan nol (atau ketiadaan)</b> <br><br>  Beberapa kesalahan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V3095</a> tentang memeriksa variabel untuk <i>null</i> setelah menggunakannya.  Yang pertama ambigu, pertimbangkan kodenya. <br><br>  V3095 Objek 'displayName' digunakan sebelum diverifikasi terhadap nol.  Periksa baris: 498, 503. FusionAssemblyIdentity.cs 498 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IAssemblyName </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToAssemblyNameObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> displayName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (displayName.IndexOf(<span class="hljs-string"><span class="hljs-string">'\0'</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } Debug.Assert(displayName != null); .... }</code> </pre> <br>  Diasumsikan bahwa referensi <i>displayName</i> mungkin nol.  Untuk melakukan ini, periksa <i>Debug.Assert</i> .  Tidak jelas mengapa ia pergi setelah menggunakan string.  Perlu juga <i>dicatat</i> bahwa untuk konfigurasi lain selain Debug, kompiler akan <i>menghapus Debug. Masukkan</i> dari kode sama sekali.  Apakah ini berarti bahwa hanya untuk Debug dimungkinkan untuk mendapatkan referensi nol?  Dan jika ini tidak demikian, mengapa tidak memeriksa <i>string. IsNullOrEmpty (string)</i> , misalnya.  Ini adalah pertanyaan untuk pembuat kode. <br><br>  Kesalahan berikut ini lebih jelas. <br><br>  V3095 Objek 'scriptArgsOpt' digunakan sebelum diverifikasi terhadap null.  Periksa baris: 321, 325. CommonCommandLineParser.cs 321 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FlattenArgs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., List&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; scriptArgsOpt, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (args.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parsingScriptArgs) { scriptArgsOpt.Add(arg); <span class="hljs-comment"><span class="hljs-comment">// &lt;= continue; } if (scriptArgsOpt != null) { .... } .... } }</span></span></code> </pre> <br>  Saya pikir kode ini tidak memerlukan penjelasan.  Saya akan memberikan versi yang diperbaiki: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FlattenArgs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., List&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; scriptArgsOpt, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (args.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parsingScriptArgs) { scriptArgsOpt?.Add(arg); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (scriptArgsOpt != null) { .... } .... } }</code> </pre> <br>  Kode Roslyn menemukan 15 kesalahan lainnya: <br><br><ul><li>  V3095 Objek 'LocalFunctions' digunakan sebelum diverifikasi terhadap nol.  Periksa baris: 289, 317. ControlFlowGraphBuilder.RegionBuilder.cs 289 </li><li>  V3095 Objek 'resolution.OverloadResolutionResult' digunakan sebelum diverifikasi terhadap null.  Periksa baris: 579, 588. Binder_Invocation.cs 579 </li><li>  V3095 Objek 'resolution.MethodGroup' digunakan sebelum diverifikasi terhadap nol.  Periksa baris: 592, 621. Binder_Invocation.cs 592 </li><li>  V3095 Objek 'touchFilesLogger' digunakan sebelum diverifikasi terhadap null.  Periksa baris: 111, 126. CSharpCompiler.cs 111 </li><li>  V3095 Objek 'newExceptionRegionsOpt' digunakan sebelum diverifikasi terhadap nol.  Periksa baris: 736, 743. AbstrakEditAndLanjutkanAnalyzer.cs 736 </li><li>  V3095 Objek 'simbol' digunakan sebelum diverifikasi terhadap nol.  Periksa baris: 422, 427. AbstractGenerateConstructorService.Editor.cs 422 </li><li>  V3095 Objek '_state.BaseTypeOrInterfaceOpt' digunakan sebelum diverifikasi terhadap nol.  Periksa baris: 132, 140. AbstractGenerateTypeService.GenerateNamedType.cs 132 </li><li>  V3095 Objek 'elemen' digunakan sebelum diverifikasi terhadap nol.  Periksa baris: 232, 233. ProjectUtil.cs 232 </li><li>  V3095 Objek 'bahasa' digunakan sebelum diverifikasi terhadap nol.  Periksa baris: 22, 28. ExportCodeCleanupProvider.cs 22 </li><li>  V3095 Objek 'memberType' digunakan sebelum diverifikasi terhadap nol.  Periksa baris: 183, 184. SyntaxGeneratorExtensions_CreateGetHashCodeMethod.cs 183 </li><li>  V3095 Objek 'validTypeDeclarations' digunakan sebelum diverifikasi terhadap nol. Check lines: 223, 228. SyntaxTreeExtensions.cs 223 </li><li> V3095 The 'text' object was used before it was verified against null. Check lines: 376, 385. MSBuildWorkspace.cs 376 </li><li> V3095 The 'nameOrMemberAccessExpression' object was used before it was verified against null. Check lines: 206, 223. CSharpGenerateTypeService.cs 206 </li><li> V3095 The 'simpleName' object was used before it was verified against null. Check lines: 83, 85. CSharpGenerateMethodService.cs 83 </li><li> V3095 The 'option' object was used before it was verified against null. Check lines: 23, 28. OptionKey.cs 23 </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertimbangkan kesalahan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3105</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Di sini kita menggunakan operator </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bersyarat </font><font style="vertical-align: inherit;">saat menginisialisasi variabel, dan selanjutnya dalam kode variabel digunakan tanpa memeriksa kesetaraan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nol</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kesalahan berikutnya ditandai segera oleh dua peringatan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3105 Variabel 'documentId' digunakan setelah ditugaskan melalui operator kondisional nol. NullReferenceException dimungkinkan. CodeLensReferencesService.cs 138 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3105 Variabel 'documentId' digunakan setelah ditugaskan melalui operator kondisional nol. NullReferenceException dimungkinkan. CodeLensReferencesService.cs 139</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> async Task&lt;ReferenceLocationDescriptor&gt; GetDescriptorOfEnclosingSymbolAsync(....) { .... var documentId = solution.GetDocument(location.SourceTree)?.Id; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReferenceLocationDescriptor( .... documentId.ProjectId.Id, documentId.Id, ....); }</code> </pre> <br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DocumentId</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> variabel </font><font style="vertical-align: inherit;">dapat diinisialisasi ke </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nol</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Akibatnya, pembuatan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReferenceLocationDescriptor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> akan berakhir dengan melemparkan pengecualian. </font><font style="vertical-align: inherit;">Kode perlu diperbaiki:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReferenceLocationDescriptor( .... documentId?.ProjectId.Id, documentId?.Id, ....);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain itu, lebih lanjut dalam kode, perlu untuk memberikan kemungkinan kesetaraan </font><font style="vertical-align: inherit;">variabel </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nol yang</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diteruskan ke konstruktor. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kesalahan serupa lainnya dalam kode:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3105 Variabel 'simbol' digunakan setelah ditugaskan melalui operator kondisional nol. </font><font style="vertical-align: inherit;">NullReferenceException dimungkinkan. </font><font style="vertical-align: inherit;">SymbolFinder_Hierarchy.cs 44</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3105 Variabel 'simbol' digunakan setelah ditugaskan melalui operator kondisional nol. </font><font style="vertical-align: inherit;">NullReferenceException dimungkinkan. </font><font style="vertical-align: inherit;">SymbolFinder_Hierarchy.cs 51</font></font></li></ul><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prioritas dan tanda kurung </font></font></b> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3123</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mungkin </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">operator</font></a><font style="vertical-align: inherit;"> '?:' Bekerja dengan cara yang berbeda dari yang diharapkan. Prioritasnya lebih rendah daripada prioritas operator lain dalam kondisinya. Edit.cs 70</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Edit&lt;TNode&gt; other)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _kind == other._kind &amp;&amp; (_oldNode == null) ? other._oldNode == null : _oldNode.Equals(other._oldNode) &amp;&amp; (_newNode == null) ? other._newNode == null : _newNode.Equals(other._newNode); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kondisi di blok kembali tidak dihitung sama sekali seperti yang dipikirkan pengembang. </font><font style="vertical-align: inherit;">Diasumsikan bahwa kondisi pertama adalah </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_kind == other._kin</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> d (oleh karena itu, pembungkus baris dilakukan setelah kondisi ini), dan kemudian blok kondisi dengan Operator </font><font style="vertical-align: inherit;">" </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " </font><font style="vertical-align: inherit;">Akan dihitung secara berurutan </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Faktanya, kondisi pertama adalah </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_kind == other._kind &amp;&amp; (_oldNode == null)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ini karena operator </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&amp;&amp;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memiliki prioritas lebih tinggi daripada Operator </font><font style="vertical-align: inherit;">" </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ". </font><font style="vertical-align: inherit;">Untuk memperbaiki kesalahan, perlu tanda kurung semua ekspresi operator </font><font style="vertical-align: inherit;">" </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ":</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _kind == other._kind &amp;&amp; ((_oldNode == null) ? other._oldNode == null : _oldNode.Equals(other._oldNode)) &amp;&amp; ((_newNode == null) ? other._newNode == null : _newNode.Equals(other._newNode));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ini menyimpulkan deskripsi kesalahan yang ditemukan. </font></font><br><br>  <b>Kesimpulan</b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terlepas dari sejumlah besar kesalahan yang dapat saya deteksi, dalam hal ukuran kode proyek Roslyn (2.770.000 baris), ini akan menjadi jumlah yang sangat kecil. Seperti Andrei di artikel sebelumnya, saya juga siap untuk mengenali kualitas tinggi dari proyek ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya ingin mencatat bahwa pemeriksaan kode sesekali tidak ada hubungannya dengan metodologi analisis statis dan praktis tidak membawa manfaat apa pun. Analisis statis harus diterapkan secara teratur, dan bukan dari kasus ke kasus. Maka banyak kesalahan akan diperbaiki pada tahap paling awal, dan, oleh karena itu, biaya memperbaikinya akan sepuluh kali lebih rendah. Gagasan ini dijelaskan secara lebih rinci dalam </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artikel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kecil </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">ini</font></a><font style="vertical-align: inherit;"> , yang saya minta Anda untuk membiasakan diri.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda dapat secara independen mencari beberapa kesalahan lagi baik dalam proyek yang dipertimbangkan, dan yang lainnya. </font><font style="vertical-align: inherit;">Untuk melakukan ini, Anda hanya perlu </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengunduh</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan mencoba penganalisa kami.</font></font><br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jika Anda ingin berbagi artikel ini dengan audiens yang berbahasa Inggris, silakan gunakan tautan ke terjemahan: Sergey Khrenov. </font></font> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memeriksa Kode Sumber Roslyn</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id446592/">https://habr.com/ru/post/id446592/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id446578/index.html">Bahasa pemrograman berbasis kartu pos</a></li>
<li><a href="../id446582/index.html">Refleksi tentang Hosting Surya untuk Lebah</a></li>
<li><a href="../id446586/index.html">Pengaturan Jaringan dari FreeRadius via DHCP</a></li>
<li><a href="../id446588/index.html">Memeriksa Kode Sumber Roslyn</a></li>
<li><a href="../id446590/index.html">39 fitur baru akan tersedia di Java 12</a></li>
<li><a href="../id446598/index.html">Menciptakan Font CRT</a></li>
<li><a href="../id446602/index.html">Maksimum Arus DC Melalui Transistor Efek Bidang</a></li>
<li><a href="../id446604/index.html">ESET: Skema Pengiriman Backdoor OceanLotus Cybergroup Baru</a></li>
<li><a href="../id446606/index.html">Periksa seberapa baik Anda dalam teknologi aditif</a></li>
<li><a href="../id446608/index.html">Mengatasi Hukum Ketiga Gravitasi Organisasi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>