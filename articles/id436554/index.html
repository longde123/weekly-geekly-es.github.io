<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ¿â€ğŸ”§ â™ï¸ ğŸ‘©â€ğŸ‘¦ Transfer 30.000 baris kode dari Flow ke TypeScript ğŸ‘ğŸ» ğŸï¸ ğŸ¦‰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami baru-baru ini memindahkan 30.000 baris kode JavaScript dari sistem MemSQL Studio kami dari Flow ke TypeScript. Pada artikel ini saya akan menjela...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Transfer 30.000 baris kode dari Flow ke TypeScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436554/">  Kami baru-baru ini memindahkan 30.000 baris kode JavaScript dari sistem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MemSQL Studio</a> kami dari Flow ke TypeScript.  Pada artikel ini saya akan menjelaskan mengapa kami mem-porting basis kode, bagaimana itu terjadi dan apa yang terjadi. <br><br>  <i>Penafian: Tujuan saya bukan untuk mengkritik Flow sama sekali.</i>  <i>Saya mengagumi proyek dan berpikir ada cukup ruang di komunitas JavaScript untuk kedua jenis opsi pemeriksaan.</i>  <i>Pada akhirnya, semua orang akan memilih yang paling cocok untuknya.</i>  <i>Saya sangat berharap artikel ini akan membantu dalam pilihan ini.</i> <br><br>  Pertama, saya akan memberi Anda informasi terkini.  Kami di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MemSQL adalah</a> penggemar berat pengetikan JavaScript statis dan kuat untuk menghindari masalah umum dengan pengetikan dinamis dan lemah. <br><a name="habracut"></a><br>  Pidato tentang masalah umum: <br><br><ol><li>  Ketik kesalahan dalam runtime karena fakta bahwa berbagai bagian kode tidak cocok dengan tipe implisit. </li><li>  Terlalu banyak waktu dihabiskan untuk menulis tes untuk hal-hal sepele seperti memeriksa parameter tipe (memeriksa runtime juga meningkatkan ukuran paket). </li><li> Ada kekurangan integrasi editor / IDE, karena tanpa pengetikan statis akan jauh lebih sulit untuk mengimplementasikan fungsi Langsung ke Definisi, refactoring mekanis, dan fungsi lainnya. </li><li>  Tidak ada cara untuk menulis kode di sekitar model data, yaitu, tipe data desain pertama, dan kemudian kode pada dasarnya "menulis sendiri". </li></ol><br>  Ini hanya beberapa manfaat dari pengetikan statis, yang selanjutnya tercantum dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel terbaru tentang Flow</a> . <br><br>  Pada awal 2016, kami menerapkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tcomb</a> untuk mengimplementasikan beberapa jenis keamanan dalam runtime dari salah satu proyek JavaScript internal kami (penafian: Saya tidak terlibat dalam proyek ini).  Meskipun pengecekan runtime terkadang berguna, itu bahkan tidak memberikan semua manfaat pengetikan statis (kombinasi pengetikan statis dan pengecekan tipe dalam runtime mungkin cocok untuk kasus-kasus tertentu, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">io-ts</a> memungkinkan Anda melakukan ini dengan tcomb dan TypeScript, meskipun saya belum pernah mencoba )  Memahami hal ini, kami memutuskan untuk mengimplementasikan Flow untuk proyek lain yang kami mulai pada tahun 2016.  Pada saat itu, Flow sepertinya pilihan yang bagus: <br><br><ul><li>  Dukungan dari Facebook, yang telah melakukan pekerjaan luar biasa dalam mengembangkan React dan menumbuhkan komunitas (mereka juga mengembangkan React <i>with</i> Flow). </li><li>  Kira-kira ekosistem pengembangan JavaScript yang sama.  Sangat menakutkan untuk meninggalkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Babel</a> untuk tsc (compiler TypeScript) karena kami telah kehilangan fleksibilitas untuk beralih ke pemeriksaan tipe lain (jelas, situasinya telah berubah sejak saat itu). </li><li>  Tidak perlu mengetikkan seluruh basis kode (kami ingin mendapatkan gagasan tentang JavaScript yang diketik secara statis sebelum masuk semua), tetapi hanya sebagian dari file.  Harap dicatat bahwa baik Flow dan TypeScript sekarang mengizinkan ini. </li><li>  TypeScript (pada waktu itu) tidak memiliki beberapa fungsi dasar yang sekarang tersedia, ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">adalah tipe pencarian</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">parameter default untuk tipe generik</a> , dll. </li></ul><br>  Ketika kami mulai bekerja pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MemSQL Studio</a> pada akhir 2017, kami akan membahas jenis-jenis seluruh aplikasi (seluruhnya ditulis dalam JavaScript: baik frontend dan backend dieksekusi di browser).  Kami mengambil Flow sebagai alat yang kami berhasil gunakan di masa lalu. <br><br>  Tapi perhatian saya tertarik ke <a href="">Babel 7 dengan dukungan TypeScript</a> .  Rilis ini berarti bahwa beralih ke TypeScript tidak lagi memerlukan transisi ke seluruh ekosistem TypeScript, dan Anda dapat terus menggunakan Babel untuk JavaScript.  Lebih penting lagi, kita bisa <b>menggunakan TypeScript hanya untuk memeriksa jenis</b> , dan bukan sebagai "bahasa" lengkap. <br><br>  Secara pribadi, saya percaya bahwa memisahkan pemeriksaan jenis dari generator kode adalah cara yang lebih elegan untuk mengetik statis dalam JavaScript, karena: <br><br><ol><li>  Kami berbagi masalah kode dan pengetikan.  Ini mengurangi berhenti pengecekan tipe dan mempercepat pengembangan: jika karena alasan tertentu pengecekan tipe lambat, kode masih akan menghasilkan dengan benar (jika Anda menggunakan tsc dengan Babel, Anda dapat mengonfigurasinya untuk melakukan hal yang sama). </li><li>  Babel memiliki plugin dan fitur hebat yang tidak dimiliki generator TypeScript.  Misalnya, Babel memungkinkan Anda untuk menentukan browser yang didukung dan secara otomatis akan mengeluarkan kode untuk mereka.  Ini adalah fungsi yang sangat kompleks dan tidak masuk akal untuk mendukungnya dalam dua proyek berbeda secara bersamaan. </li><li>  Saya suka JavaScript sebagai bahasa pemrograman (kecuali untuk kurangnya pengetikan statis), dan saya tidak tahu berapa banyak TypeScript akan ada, sementara saya percaya pada ECMAScript selama bertahun-tahun.  Oleh karena itu, saya lebih suka menulis dan "berpikir" dalam JavaScript (perhatikan bahwa saya mengatakan "gunakan Flow" atau "gunakan TypeScript" daripada "tulis dalam Flow" atau "TypeScript", karena saya selalu mewakili mereka dengan alat, bukan bahasa pemrograman). </li></ol><br>  Tentu saja, pendekatan ini memiliki beberapa kelemahan: <br><br><ol><li>  Compiler TypeScript secara teoritis dapat melakukan optimasi berbasis tipe, tetapi di sini kita kehilangan kesempatan itu. </li><li>  Konfigurasi proyek sedikit lebih rumit dengan peningkatan jumlah alat dan dependensi.  Saya pikir ini adalah argumen yang relatif lemah: sekelompok Babel dan Flow tidak pernah mengecewakan kita. </li></ol><br><h1>  TypeScript sebagai alternatif untuk Flow </h1><br>  Saya melihat minat yang tumbuh pada TypeScript di komunitas JavaScript: baik online dan di antara pengembang di sekitarnya.  Oleh karena itu, segera setelah saya mengetahui bahwa Babel 7 mendukung TypeScript, saya segera mulai mempelajari opsi transisi yang potensial.  Selain itu, kami menemukan beberapa kelemahan dari Flow: <br><br><ol><li>  Kualitas integrasi editor / IDE yang lebih rendah (dibandingkan dengan TypeScript).  Nuclide, IDE milik Facebook dengan integrasi terbaik, sudah ketinggalan zaman. </li><li>  Komunitas yang lebih kecil, yang berarti lebih sedikit definisi tipe untuk pustaka yang berbeda, dan mereka memiliki kualitas yang lebih rendah (saat ini repositori DefinitelyTyped memiliki 19.682 bintang GitHub, dan repositori tipe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aliran</a> hanya memiliki 3070). </li><li>  Kurangnya rencana pengembangan publik dan interaksi yang buruk antara tim Flow di Facebook dan komunitas.  Anda dapat membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komentar ini</a> dari karyawan Facebook untuk memahami situasinya. </li><li>  Konsumsi memori yang tinggi dan kebocoran yang sering terjadi - untuk beberapa pengembang kami, Flow terkadang memakan hampir 10 GB RAM. </li></ol><br>  Tentu saja, Anda harus mempelajari bagaimana TypeScript cocok untuk kita.  Ini adalah pertanyaan yang sangat kompleks: mempelajari topik termasuk membaca dokumentasi secara menyeluruh, yang membantu untuk memahami bahwa untuk setiap fungsi Flow terdapat TypeScript yang setara.  Kemudian saya menjelajahi rencana pengembangan publik TypeScript, dan saya sangat menyukai fitur-fitur yang direncanakan untuk masa depan (misalnya, turunan sebagian dari argumen tipe yang kami gunakan dalam Flow). <br><br><h1>  Transfer lebih dari 30 ribu baris kode dari Flow ke TypeScript </h1><br>  Sebagai permulaan, Anda harus memutakhirkan Babel dari 6 menjadi 7. Tugas sederhana ini memakan waktu 16 orang-jam, karena kami memutuskan untuk memutakhirkan Webpack 3 menjadi 4. Pada saat yang sama, beberapa dependensi usang dalam kode kami mempersulit tugas.  Sebagian besar proyek JavaScript tidak akan memiliki masalah seperti itu. <br><br>  Setelah itu, kami mengganti preset Babel Flow dengan preset TypeScript yang baru, dan kemudian untuk pertama kalinya meluncurkan kompiler TypeScript pada semua sumber kami yang ditulis menggunakan Flow.  Hasilnya adalah <b>8245 kesalahan sintaks</b> (CLI tsc tidak menunjukkan kesalahan nyata untuk proyek sampai semua kesalahan sintaks telah diperbaiki). <br><br>  Pada awalnya, angka ini membuat kami takut (sangat), tetapi kami segera menyadari bahwa sebagian besar kesalahan adalah karena TypeScript tidak mendukung file .js.  Setelah mempelajari topik tersebut, saya belajar bahwa file TypeScript harus diakhiri dengan .ts atau .tsx (jika memiliki JSX).  Bagi saya ini sepertinya ketidaknyamanan yang jelas.  Agar tidak memikirkan ada / tidaknya JSX, saya cukup mengganti nama semua file menjadi .tsx. <br><br>  Sekitar 4.000 kesalahan sintaks masih ada.  Kebanyakan dari mereka terkait dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">impor tipe</a> , yang dengan TypeScript dapat diganti hanya dengan impor, serta perbedaan dalam penunjukan objek ( <code>{||}</code> bukan <code>{}</code> ).  Dengan cepat menerapkan beberapa ekspresi reguler, kami meninggalkan 414 kesalahan sintaks.  Segala sesuatu yang lain harus diperbaiki secara manual: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tipe eksistensial</a> , yang kami gunakan untuk memperoleh sebagian argumen dari tipe generik, harus diganti dengan argumen eksplisit atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak dikenal</a> untuk memberi tahu TypeScript bahwa beberapa argumen tidak penting. </li><li>  Ketik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">$ Keys</a> dan tipe Flow canggih lainnya memiliki sintaks yang berbeda dalam TypeScript (misalnya, <code>$Shapeâ€œâ€</code> sesuai dengan <code>Partialâ€œâ€</code> di TypeScript). </li></ul><br>  Setelah memperbaiki semua kesalahan sintaksis, tsc akhirnya mengatakan berapa banyak kesalahan tipe nyata dalam basis kode kami hanya sekitar 1.300. Sekarang kami harus duduk dan memutuskan apakah akan melanjutkan atau tidak.  Lagi pula, jika migrasi membutuhkan waktu berminggu-minggu, yang terbaik adalah tetap menggunakan Flow.  Namun, kami memutuskan bahwa porting kode akan membutuhkan kurang dari satu minggu kerja oleh satu insinyur, yang cukup dapat diterima. <br><br>  Harap dicatat bahwa selama migrasi saya harus menghentikan semua pekerjaan pada basis kode ini.  Namun demikian, secara paralel Anda dapat memulai proyek baru - tetapi Anda harus mengingat secara potensial ratusan jenis kesalahan dalam kode yang ada, yang tidak mudah. <br><br><h1>  Kesalahan macam apa? </h1><br>  TypeScript dan Proses aliran kode JavaScript dalam banyak cara.  Jadi, Flow lebih ketat dalam kaitannya dengan beberapa hal, dan TypeScript - dalam kaitannya dengan yang lain.  Perbandingan yang mendalam dari kedua sistem akan sangat panjang, jadi lihat saja beberapa contoh. <br><br>  Catatan: semua tautan ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kotak pasir TypeScript menggunakan</a> parameter "ketat".  Sayangnya, saat Anda membagikan tautan, opsi ini tidak disimpan di URL.  Oleh karena itu, mereka harus diatur secara manual setelah membuka tautan apa pun ke kotak pasir dari artikel ini. <br><br><h3>  invariant.js </h3><br>  Fungsi <code>invariant</code> ternyata sangat umum dalam kode sumber kami.  Hanya mengutip dokumentasi: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> invariant = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'invariant'</span></span>); invariant(someTruthyVal, <span class="hljs-string"><span class="hljs-string">'This will not throw'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// No errors invariant(someFalseyVal, 'This will throw an error with this message'); // Error raised: Invariant Violation: This will throw an error with this message</span></span></code> </pre> <br>  Idenya jelas: fungsi sederhana yang melempar kesalahan pada beberapa kondisi.  Mari kita lihat bagaimana <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menerapkan dan menggunakannya</a> pada Flow: <br><br><pre> <code class="javascript hljs">type Maybe&lt;T&gt; = T | <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invariant</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">condition: boolean, message: string</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!condition) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(message); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x: Maybe&lt;number&gt;, c: number</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { invariant(x !== <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>, <span class="hljs-string"><span class="hljs-string">"When c is positive, x should never be undefined"</span></span>); (x + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// works because x has been refined to "number" } }</span></span></code> </pre> <br>  Sekarang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">muat cuplikan yang sama di TypeScript</a> .  Seperti yang dapat Anda lihat dari tautan, TypeScript memberikan kesalahan, karena itu tidak dapat memahami bahwa <code>x</code> dijamin tidak akan tetap <code>undefined</code> setelah baris terakhir.  Ini sebenarnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">masalah yang terkenal</a> - TypeScript (untuk saat ini) tidak tahu bagaimana melakukan inferensi ini melalui suatu fungsi.  Namun, ini adalah template yang sangat umum di basis kode kami, jadi saya harus mengganti secara manual setiap instance invarian (lebih dari 150 buah) dengan kode lain yang segera memberikan kesalahan: <br><br><pre> <code class="javascript hljs">type Maybe&lt;T&gt; = T | <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x: Maybe&lt;number&gt;, c: number</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x === <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"When c is positive, x should never be undefined"</span></span>); } (x + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// works because x has been refined to "number" } }</span></span></code> </pre> <br>  Tidak benar-benar dibandingkan dengan <code>invariant</code> , tetapi bukan masalah penting. <br><br><h3>  $ ExpectError vs @ ts-abaikan </h3><br>  Flow memiliki fungsi yang sangat menarik, mirip dengan <code>@ts-ignore</code> , kecuali bahwa ia melempar kesalahan jika baris berikutnya <b>bukan</b> kesalahan.  Ini sangat berguna untuk menulis "tes tipe" yang memastikan bahwa pemeriksaan tipe (apakah TypeScript atau Flow) menemukan kesalahan tipe tertentu. <br><br>  Sayangnya, TypeScript tidak memiliki fungsi seperti itu, jadi pengujian kami telah kehilangan beberapa nilai.  Saya berharap dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengimplementasikan fungsi ini pada TypeScript</a> . <br><br><h3>  Kesalahan tipe umum dan inferensi tipe </h3><br>  Seringkali TypeScript memungkinkan kode yang lebih eksplisit daripada Flow, seperti dalam contoh ini: <br><br><pre> <code class="javascript hljs">type Leaf = { <span class="hljs-attr"><span class="hljs-attr">host</span></span>: string; port: number; type: <span class="hljs-string"><span class="hljs-string">"LEAF"</span></span>; }; type Aggregator = { <span class="hljs-attr"><span class="hljs-attr">host</span></span>: string; port: number; type: <span class="hljs-string"><span class="hljs-string">"AGGREGATOR"</span></span>; } type MemsqlNode = Leaf | Aggregator; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">leaves: Array&lt;Leaf&gt;, aggregators: Array&lt;Aggregator&gt;</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Array</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MemsqlNode</span></span></span><span class="hljs-function">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// The next line errors because you cannot concat aggregators to leaves. return leaves.concat(aggregators); }</span></span></code> </pre> <br>  Flow <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">infers leaves.concat (agregator) ketik sebagai Array &lt;Leaf |</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Aggregator&gt;</a> , yang kemudian dapat <code>Array&lt;MemsqlNode&gt;</code> ke <code>Array&lt;MemsqlNode&gt;</code> .  Saya pikir ini adalah contoh yang bagus di mana Flow sedikit lebih pintar, dan TypeScript membutuhkan sedikit bantuan: dalam hal ini kita dapat menerapkan pernyataan tipe, tapi ini berbahaya dan harus dilakukan dengan sangat hati-hati. <br><br>  Meskipun saya tidak memiliki bukti formal, saya percaya Flow jauh lebih unggul daripada TypeScript dalam inferensi tipe.  Saya sangat berharap bahwa TypeScript akan mencapai level Flow, karena bahasa ini sangat aktif berkembang, dan banyak perbaikan baru-baru ini telah dibuat di bidang ini.  Di banyak tempat dalam kode kami, TypeScript harus membantu sedikit melalui penjelasan atau mengetik pernyataan, meskipun kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menghindari yang terakhir</a> sebanyak mungkin).  Mari kita pertimbangkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">satu contoh lagi</a> (kami memiliki lebih dari 200 kesalahan seperti itu): <br><br><pre> <code class="javascript hljs">type Player = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: string; age: number; position: <span class="hljs-string"><span class="hljs-string">"STRIKER"</span></span> | <span class="hljs-string"><span class="hljs-string">"GOALKEEPER"</span></span>, }; type F = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>&lt;Player&gt;&gt;; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> f1: F = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all([ { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"David Gomes"</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">23</span></span>, <span class="hljs-attr"><span class="hljs-attr">position</span></span>: <span class="hljs-string"><span class="hljs-string">"GOALKEEPER"</span></span>, }, { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Cristiano Ronaldo"</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">33</span></span>, <span class="hljs-attr"><span class="hljs-attr">position</span></span>: <span class="hljs-string"><span class="hljs-string">"STRIKER"</span></span>, } ]); };</code> </pre> <br>  TypeScript tidak akan memungkinkan Anda untuk menulis ini karena itu tidak akan memungkinkan Anda untuk mendeklarasikan <code>{ name: "David Gomes", age: 23, type: "GOALKEEPER" }</code> sebagai objek dengan tipe <code>Player</code> (lihat kotak pasir untuk kesalahan yang tepat).  Ini adalah kasus lain di mana saya menemukan TypeScript tidak cukup pintar (setidaknya dibandingkan dengan Flow, yang mengerti kode ini). <br><br>  Ada beberapa opsi untuk memperbaikinya: <br><br><ul><li>  Deklarasikan <code>"STRIKER"</code> menjadi <code>"STRIKER"</code> sehingga TypeScript memahami bahwa string adalah enumerasi tipe <code>"STRIKER" | "GOALKEEPER"</code> valid <code>"STRIKER" | "GOALKEEPER"</code>  <code>"STRIKER" | "GOALKEEPER"</code> . </li><li>  Deklarasikan semua objek sebagai <code>Player</code> . </li><li>  Atau apa yang saya anggap sebagai solusi terbaik: hanya membantu TypeScript tanpa menggunakan pernyataan tipe apa pun dengan menulis <code>Promise.all&lt;Player&gt;(...)</code> . </li></ul><br>  Berikut adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh lain</a> (TypeScript) di mana <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Flow lagi lebih baik di inferensi tipe</a> : <br><br><pre> <code class="javascript hljs">type Connection = { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: number }; declare <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getConnection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Connection</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolveConnection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> resolve(getConnection()); }) } resolveConnection().then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">conn</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// TypeScript errors in the next line because it does not understand // that conn is of type Connection. We have to manually annotate // resolveConnection as Promise&lt;Connection&gt;. (conn.id); });</span></span></code> </pre> <br>  Contoh yang sangat kecil namun menarik: Flow menganggap <code>Array&lt;T&gt;.pop()</code> tipe <code>T</code> , dan TypeScript menganggapnya sebagai <code>T | void</code>  <code>T | void</code>  Suatu titik yang mendukung TypeScript, karena memaksa Anda untuk memeriksa ulang keberadaan elemen (jika array kosong, maka <code>Array.pop</code> mengembalikan yang <code>undefined</code> ).  Ada beberapa contoh kecil lainnya seperti ini di mana TypeScript lebih unggul dari Flow. <br><br><h3>  Definisi TypeScript untuk Ketergantungan Pihak Ketiga </h3><br>  Tentu saja, ketika menulis aplikasi JavaScript apa pun, Anda akan memiliki setidaknya beberapa dependensi.  Mereka harus diketik, jika tidak, Anda akan kehilangan sebagian besar kemungkinan analisis tipe statis (seperti yang dijelaskan di awal artikel). <br><br>  Perpustakaan dari npm dapat datang dengan definisi tipe Flow atau TypeScript, dengan atau tanpa keduanya.  Sangat sering (kecil) perpustakaan tidak disediakan dengan salah satu atau yang lain, jadi Anda harus menulis definisi jenis Anda sendiri atau meminjamnya dari komunitas.  Baik Flow maupun TypeScript mendukung repositori definisi standar untuk paket JavaScript pihak ketiga: ini adalah tipe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">-diketik</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DefinitelyTyped</a> . <br><br>  Saya harus mengatakan bahwa DefinitelyTyped kami lebih menyukai.  Dengan flow-typed, saya harus menggunakan alat CLI untuk memperkenalkan definisi tipe untuk berbagai dependensi ke dalam proyek.  DefinitelyTyped menggabungkan fungsi ini dengan alat CLI npm dengan mengirimkan <code>@types/package-name</code> paket ke repositori paket npm.  Ini sangat keren dan sangat menyederhanakan input definisi tipe untuk dependensi kita (gurauan, reaksi, lodash, reaksi-redux, ini hanya beberapa). <br><br>  Selain itu, saya bersenang-senang mengisi database DefinitelyTyped (jangan berpikir bahwa definisi tipe sama ketika porting kode dari Flow ke TypeScript).  Saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sudah</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengirim</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">beberapa</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">permintaan tarik</a> , dan tidak ada masalah di mana pun.  Cukup tirukan repositori, edit definisi tipe, tambahkan tes - dan kirim permintaan tarik.  Bot GitHub DefinitelyTyped menandai pembuat definisi yang Anda edit.  Jika tidak ada dari mereka yang memberikan umpan balik dalam 7 hari, permintaan tarik diajukan untuk dipertimbangkan kepada pengelola.  Setelah bergabung dengan cabang utama, versi baru dari paket dependensi dikirim ke npm.  Misalnya, ketika saya pertama kali memperbarui paket @ types / redux-form, versi 7.4.14 secara otomatis dikirim ke npm.  jadi cukup perbarui file package.json untuk mendapatkan definisi tipe baru.  Jika Anda tidak bisa menunggu adopsi permintaan tarik, Anda selalu dapat mengubah definisi jenis yang digunakan dalam proyek Anda, seperti yang dijelaskan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam salah satu artikel sebelumnya</a> . <br><br>  Secara umum, kualitas definisi tipe di DefinitelyTyped jauh lebih baik karena komunitas TypeScript yang lebih besar dan lebih makmur.  Bahkan, setelah proyek dipindahkan ke TypeScript <b>, cakupan tipe kami meningkat dari 88% menjadi 96%</b> , terutama karena definisi yang lebih baik dari tipe ketergantungan pihak ketiga, dengan lebih sedikit jenis <code>any</code> . <br><br><h1>  Linting dan tes </h1><br><ol><li>  Kami beralih dari eslint ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tslint</a> (dengan eslint untuk TypeScript, tampaknya lebih sulit untuk memulai). </li><li>  Tes TypeScript menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ts-jest</a> .  Beberapa tes diketik, sementara yang lain tidak (jika diketik terlalu lama, kami menyimpannya sebagai file .js). </li></ol><br><h1>  Apa yang terjadi setelah memperbaiki semua kesalahan pengetikan? </h1><br>  Setelah 40 jam kerja, kami mencapai kesalahan pengetikan terakhir, menundanya sebentar menggunakan <code>@ts-ignore</code> . <br><br>  Setelah meninjau komentar ulasan kode dan memperbaiki beberapa bug (sayangnya, saya harus mengubah sedikit kode runtime untuk memperbaiki logika yang tidak dapat dipahami TypeScript) permintaan tariknya hilang, dan sejak itu kami telah menggunakan TypeScript.  (Dan ya, kami memperbaiki <code>@ts-ignore</code> pada permintaan tarikan berikutnya). <br><br>  Selain integrasi dengan editor, bekerja dengan TypeScript sangat mirip dengan bekerja dengan Flow.  Kinerja server aliran sedikit lebih tinggi, tetapi ini bukan masalah besar, karena mereka menghasilkan kesalahan untuk file saat ini dengan sama cepat.  Satu-satunya perbedaan kinerja adalah bahwa TypeScript melaporkan kesalahan baru setelah menyimpan file beberapa saat kemudian (sekitar 0,5âˆ’1 detik).  Waktu startup server kira-kira sama (sekitar 2 menit), tetapi tidak begitu penting.  Sejauh ini, kami belum memiliki masalah dengan konsumsi memori.  Sepertinya tsc terus menggunakan sekitar 600 MB. <br><br>  Mungkin tampak bahwa fungsi inferensi tipe memberi Flow keuntungan besar, tetapi ada dua alasan mengapa itu tidak terlalu penting: <br><br><ol><li>  Kami mengonversi basis kode aliran ke TypeScript.  Jelas, kami hanya menemukan kode yang dapat diekspresikan Flow, tetapi TypeScript tidak.  Jika migrasi terjadi di arah yang berlawanan, saya yakin akan ada hal-hal yang ditampilkan / diekspresikan oleh TypeScript. </li><li>  Ketik inferensi penting dalam membantu menulis kode yang lebih ringkas.  Namun semua sama, hal-hal lain lebih penting, seperti komunitas yang kuat dan ketersediaan definisi tipe, karena inferensi tipe lemah dapat diperbaiki dengan menghabiskan sedikit waktu mengetik. </li></ol><br><h3>  Statistik kode </h3><br><pre> <code class="bash hljs">$ npm run <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>-coverage <span class="hljs-comment"><span class="hljs-comment"># https://github.com/plantain-00/type-coverage 43330 / 45047 96.19% $ cloc # ignoring tests and dependencies -------------------------------------------------------------------------------- Language files blank comment code -------------------------------------------------------------------------------- TypeScript 330 5179 1405 31463</span></span></code> </pre> <br><h1>  Apa selanjutnya </h1><br>  Kami tidak selesai dengan meningkatkan analisis tipe statis.  MemSQL memiliki proyek lain yang pada akhirnya akan beralih dari Flow ke TypeScript (dan beberapa proyek JavaScript yang akan mulai menggunakan TypeScript), dan kami ingin membuat konfigurasi TypeScript kami lebih ketat.  Saat ini kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengaktifkan</a> opsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">strictNullChecks</a> , tetapi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">noImplicitAny</a> masih dinonaktifkan.  Kami juga akan menghapus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">beberapa pernyataan tipe berbahaya</a> dari kode. <br><br>  Saya senang berbagi dengan Anda semua yang saya pelajari selama petualangan saya dengan mengetikkan JavaScript.  Jika Anda tertarik pada topik tertentu, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">beri tahu saya</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id436554/">https://habr.com/ru/post/id436554/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id436544/index.html">Marketplace akan menjawab semuanya</a></li>
<li><a href="../id436546/index.html">Pengembangan tim untuk menanyakan data dari database - bagian 3</a></li>
<li><a href="../id436548/index.html">Program Pendidikan Realitas Virtual</a></li>
<li><a href="../id436550/index.html">Berkat robot itu, para ilmuwan mengetahui bagaimana salah satu penghuni sushi pertama berjalan</a></li>
<li><a href="../id436552/index.html">Berita kematian sampai Chromecast Audio atau mengapa Google membunuh cakram hitam</a></li>
<li><a href="../id436556/index.html">Pekerjaan di perusahaan Jerman - bagaimana cara melamar dan tidak mendapat penolakan?</a></li>
<li><a href="../id436558/index.html">Selamat Ulang Tahun ke-18, Wikipedia; merayakan datangnya proyek yang baik</a></li>
<li><a href="../id436560/index.html">Protokol kriptografi untuk pemilihan elektronik</a></li>
<li><a href="../id436564/index.html">Bagaimana ProGuard Bekerja</a></li>
<li><a href="../id436568/index.html">Platform video sendiri atau cara mengambil banyak sumber daya komputasi. Bagian 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>