<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍💼 👃 ⚫️ WBOIT di OpenGL: transparansi tanpa pengurutan 🚶🏻 🔀 🚵🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Posting ini adalah tentang transparansi campuran pesanan-independen tertimbang (WBOIT) - trik yang dicakup dalam JCGT pada 2013. 

 Ketika beberapa ob...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WBOIT di OpenGL: transparansi tanpa pengurutan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457292/">  Posting ini adalah tentang transparansi campuran pesanan-independen tertimbang (WBOIT) - trik yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dicakup</a> dalam JCGT pada 2013. <br><a name="habracut"></a><br>  Ketika beberapa objek transparan muncul di layar, warna piksel bergantung pada yang mana yang lebih dekat dengan penampil.  Berikut adalah operator pencampuran terkenal yang digunakan dalam kasus itu: <br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><merror><mtext>\&amp;#xA0;begin&amp;#xA0;{matrix}&amp;#xA0;C&amp;#xA0;=&amp;#xA0;C_&amp;#xA0;{near}&amp;#xA0;\&amp;#xA0;alpha&amp;#xA0;+&amp;#xA0;C_&amp;#xA0;{far}&amp;#xA0;(1-&amp;#xA0;\&amp;#xA0;alpha)&amp;#xA0;&amp;amp;&amp;amp;&amp;#xA0;(1)&amp;#xA0;\&amp;#xA0;end&amp;#xA0;{matrix}</mtext></merror></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><span class="noError" aria-hidden="true" style="display: inline-block;">\&nbsp;begin&nbsp;{matrix}&nbsp;C&nbsp;=&nbsp;C_&nbsp;{near}&nbsp;\&nbsp;alpha&nbsp;+&nbsp;C_&nbsp;{far}&nbsp;(1-&nbsp;\&nbsp;alpha)&nbsp;&amp;&amp;&nbsp;(1)&nbsp;\&nbsp;end&nbsp;{matrix}</span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><merror><mtext>\&nbsp;begin&nbsp;{matrix}&nbsp;C&nbsp;=&nbsp;C_&nbsp;{near}&nbsp;\&nbsp;alpha&nbsp;+&nbsp;C_&nbsp;{far}&nbsp;(1-&nbsp;\&nbsp;alpha)&nbsp;&amp;&amp;&nbsp;(1)&nbsp;\&nbsp;end&nbsp;{matrix}</mtext></merror></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> \ begin {matrix} C = C_ {near} \ alpha + C_ {far} (1- \ alpha) && (1) \ end {matrix} </script></p><br><br>  Pemesanan fragmen penting.  Operator berisi warna (C <sub>dekat</sub> ) dan opacity ( <i>α</i> ) dari fragmen dekat dan keseluruhan warna (C <sub>jauh</sub> ) dari semua fragmen di belakangnya.  Opacity dapat berkisar dari 0 hingga 1;  0 berarti objek sepenuhnya transparan (tidak terlihat) dan 1 berarti sepenuhnya buram. <br><br>  Untuk menggunakan operator ini, Anda perlu mengurutkan fragmen berdasarkan kedalaman.  Bayangkan betapa kutukan itu.  Secara umum, Anda perlu membuat satu penyortiran per bingkai.  Jika Anda menyortir objek maka Anda mungkin harus berurusan dengan permukaan berbentuk tidak teratur yang harus dipotong menjadi beberapa bagian, dan kemudian cut-off PARTS dari permukaan tersebut harus diurutkan (Anda pasti perlu melakukannya untuk memotong permukaan).  Jika Anda menyortir fragmen maka Anda akan menempatkan penyortiran yang sebenarnya di shader Anda.  Metode ini dikenal sebagai "Transparansi independen pesanan" (OIT), dan didasarkan pada daftar tertaut yang disimpan dalam memori video.  Hampir mustahil untuk memperkirakan berapa banyak memori yang harus dialokasikan untuk daftar itu.  Dan jika Anda kekurangan memori, Anda mendapatkan artefak di layar. <br><br>  Anggap diri Anda beruntung jika Anda dapat mengatur jumlah objek transparan pada adegan Anda dan sesuaikan posisi relatifnya.  Tetapi jika Anda mengembangkan CAD maka itu tergantung pada pengguna untuk memposisikan objek mereka, sehingga akan ada objek sebanyak yang mereka inginkan, dan penempatan mereka akan jelas sewenang-wenang. <br><br>  Sekarang Anda tahu mengapa begitu menggoda untuk menemukan operator campuran yang tidak memerlukan penyortiran awal.  Dan ada operator seperti itu - dalam sebuah makalah yang saya sebutkan di awal.  Sebenarnya, ada beberapa formula, tetapi salah satunya yang penulis (dan saya sendiri) anggap sebagai yang terbaik: <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display"><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><merror><mtext>\&amp;#xA0;begin&amp;#xA0;{matrix}&amp;#xA0;C&amp;#xA0;=&amp;#xA0;{{\&amp;#xA0;sum_&amp;#xA0;{i&amp;#xA0;=&amp;#xA0;1}&amp;#xA0;^&amp;#xA0;{n}&amp;#xA0;C_i&amp;#xA0;\&amp;#xA0;alpha_i}&amp;#xA0;\&amp;#xA0;over&amp;#xA0;{\&amp;#xA0;sum_&amp;#xA0;{i&amp;#xA0;=&amp;#xA0;1}&amp;#xA0;^&amp;#xA0;{n}&amp;#xA0;\&amp;#xA0;alpha_i}}&amp;#xA0;(1-&amp;#xA0;\&amp;#xA0;prod_&amp;#xA0;{i&amp;#xA0;=&amp;#xA0;1}&amp;#xA0;^&amp;#xA0;{n}&amp;#xA0;(1-&amp;#xA0;\&amp;#xA0;alpha_i))&amp;#xA0;+&amp;#xA0;C_0&amp;#xA0;\&amp;#xA0;prod_&amp;#xA0;{i&amp;#xA0;=&amp;#xA0;1}&amp;#xA0;^&amp;#xA0;{n}&amp;#xA0;(1-&amp;#xA0;\&amp;#xA0;alpha_i)&amp;#xA0;&amp;amp;&amp;amp;&amp;#xA0;(2)&amp;#xA0;\&amp;#xA0;end&amp;#xA0;{matrix}</mtext></merror></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><span class="noError" aria-hidden="true" style="display: inline-block;">\&nbsp;begin&nbsp;{matrix}&nbsp;C&nbsp;=&nbsp;{{\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;C_i&nbsp;\&nbsp;alpha_i}&nbsp;\&nbsp;over&nbsp;{\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;\&nbsp;alpha_i}}&nbsp;(1-&nbsp;\&nbsp;prod_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;(1-&nbsp;\&nbsp;alpha_i))&nbsp;+&nbsp;C_0&nbsp;\&nbsp;prod_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;(1-&nbsp;\&nbsp;alpha_i)&nbsp;&amp;&amp;&nbsp;(2)&nbsp;\&nbsp;end&nbsp;{matrix}</span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><merror><mtext>\&nbsp;begin&nbsp;{matrix}&nbsp;C&nbsp;=&nbsp;{{\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;C_i&nbsp;\&nbsp;alpha_i}&nbsp;\&nbsp;over&nbsp;{\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;\&nbsp;alpha_i}}&nbsp;(1-&nbsp;\&nbsp;prod_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;(1-&nbsp;\&nbsp;alpha_i))&nbsp;+&nbsp;C_0&nbsp;\&nbsp;prod_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;(1-&nbsp;\&nbsp;alpha_i)&nbsp;&amp;&amp;&nbsp;(2)&nbsp;\&nbsp;end&nbsp;{matrix}</mtext></merror></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-2"> \ begin {matrix} C = {{\ sum_ {i = 1} ^ {n} C_i \ alpha_i} \ over {\ sum_ {i = 1} ^ {n} \ alpha_i}} (1- \ prod_ {i = 1} ^ {n} (1- \ alpha_i)) + C_0 \ prod_ {i = 1} ^ {n} (1- \ alpha_i) && (2) \ end {matrix} </script></p><br><br><img src="https://habrastorage.org/webt/65/b9/oz/65b9ozbni1afvlupqfso9uve2ey.png" width="1000"><br><br>  Pada tangkapan layar orang dapat melihat kelompok segitiga transparan yang disusun pada empat lapisan kedalaman.  Di sisi kiri mereka diberikan dengan WBOIT, dan di sisi kanan campuran klasik yang tergantung pesanan - dengan rumus (1) - digunakan (saya akan menyebutnya CODB mulai sekarang). <br><br>  Sebelum kita dapat mulai membuat objek transparan, kita perlu membuat semua yang tidak transparan.  Setelah itu, objek transparan dirender dengan uji kedalaman tetapi tanpa menulis apa pun ke buffer kedalaman (dapat dilakukan dengan cara ini: <code>glEnable(GL_DEPTH_TEST); glDepthMask(GL_FALSE);</code> ). <br><br>  Sekarang, mari kita lihat apa yang terjadi di beberapa titik dengan koordinat layar-ruang (x, y).  Fragmen transparan - yang kebetulan lebih dekat daripada yang tidak transparan - lulus uji kedalaman, tidak peduli bagaimana mereka ditempatkan relatif terhadap fragmen transparan yang telah diberikan.  Fragmen transparan yang jatuh di belakang yang tidak transparan - well, mereka tidak lulus uji kedalaman dan dibuang secara alami. <br><br>  C <sub>0</sub> dalam rumus (2) adalah warna dari fragmen non-transparan yang diberikan pada titik itu (x, y).  Kami memiliki n fragmen transparan total yang lulus uji kedalaman, dan mereka memiliki indeks i ∈ [1, n].  C <sub>i</sub> adalah warna dari fragmen transparan dan <i>α <sub>i</sub></i> adalah opacity-nya. <br><br>  Formula (2) sedikit mirip dengan formula (1), meskipun tidak terlalu jelas.  Ganti <img src="https://habrastorage.org/webt/xz/w1/z8/xzw1z8f-nsnfuokbqssbhic6tpw.png" width="60">  dengan C <sub>dekat</sub> , C <sub>0</sub> dengan C <sub>jauh</sub> dan <img src="https://habrastorage.org/webt/li/tu/em/lituem-w98r3gl7cee5184y6b7q.png" width="100">  dengan <i>α</i> dan formula (1) akan persis seperti yang Anda dapatkan.  Memang, <img src="https://habrastorage.org/webt/xz/w1/z8/xzw1z8f-nsnfuokbqssbhic6tpw.png" width="60">  adalah <b>rata</b> - <b>rata aritmatika tertimbang</b> dari warna semua fragmen transparan (ada rumus serupa dalam mekanika untuk "pusat massa"), dan akan pergi untuk warna fragmen <sub>dekat</sub> C <sub>dekat</sub> .  C <sub>0</sub> adalah warna dari fragmen non-transparan di balik semua fragmen transparan yang kami hitung rata-rata aritmatika tertimbang.  Dengan kata lain, kami mengganti semua fragmen transparan dengan satu fragmen "rata-rata tertimbang" dan menggunakan operator pencampuran standar - formula (1).  Sekarang, ada rumus yang agak canggih untuk <i>α</i> , dan kami belum mengetahui artinya. <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mtext>&amp;#xA0;</mtext><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><mi>a</mi><mo>=</mo><mn>1</mn><mo>&amp;#x2212;</mo><mtext>&amp;#xA0;</mtext><mi>p</mi><mi>r</mi><mi>o</mi><msubsup><mi>d</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>n</mi></mrow></msubsup><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mo>&amp;#x2212;</mo><mtext>&amp;#xA0;</mtext><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><msub><mi>a</mi><mi>i</mi></msub><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="34.233ex" height="2.901ex" viewBox="0 -832 14738.9 1249" role="img" focusable="false" style="vertical-align: -0.969ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjwqB2cnQThBaVbt7_03tSVa4dMlA#MJMATHI-61" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjwqB2cnQThBaVbt7_03tSVa4dMlA#MJMATHI-6C" x="779" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjwqB2cnQThBaVbt7_03tSVa4dMlA#MJMATHI-70" x="1078" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjwqB2cnQThBaVbt7_03tSVa4dMlA#MJMATHI-68" x="1581" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjwqB2cnQThBaVbt7_03tSVa4dMlA#MJMATHI-61" x="2158" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjwqB2cnQThBaVbt7_03tSVa4dMlA#MJMAIN-3D" x="2965" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjwqB2cnQThBaVbt7_03tSVa4dMlA#MJMAIN-31" x="4021" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjwqB2cnQThBaVbt7_03tSVa4dMlA#MJMAIN-2212" x="4744" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjwqB2cnQThBaVbt7_03tSVa4dMlA#MJMATHI-70" x="5995" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjwqB2cnQThBaVbt7_03tSVa4dMlA#MJMATHI-72" x="6498" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjwqB2cnQThBaVbt7_03tSVa4dMlA#MJMATHI-6F" x="6950" y="0"></use><g transform="translate(7435,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjwqB2cnQThBaVbt7_03tSVa4dMlA#MJMATHI-64" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjwqB2cnQThBaVbt7_03tSVa4dMlA#MJMATHI-6E" x="741" y="499"></use><g transform="translate(520,-308)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjwqB2cnQThBaVbt7_03tSVa4dMlA#MJMATHI-69" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjwqB2cnQThBaVbt7_03tSVa4dMlA#MJMAIN-3D" x="345" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjwqB2cnQThBaVbt7_03tSVa4dMlA#MJMAIN-31" x="1124" y="0"></use></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjwqB2cnQThBaVbt7_03tSVa4dMlA#MJMAIN-28" x="9204" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjwqB2cnQThBaVbt7_03tSVa4dMlA#MJMAIN-31" x="9594" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjwqB2cnQThBaVbt7_03tSVa4dMlA#MJMAIN-2212" x="10316" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjwqB2cnQThBaVbt7_03tSVa4dMlA#MJMATHI-61" x="11567" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjwqB2cnQThBaVbt7_03tSVa4dMlA#MJMATHI-6C" x="12097" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjwqB2cnQThBaVbt7_03tSVa4dMlA#MJMATHI-70" x="12395" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjwqB2cnQThBaVbt7_03tSVa4dMlA#MJMATHI-68" x="12899" y="0"></use><g transform="translate(13475,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjwqB2cnQThBaVbt7_03tSVa4dMlA#MJMATHI-61" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjwqB2cnQThBaVbt7_03tSVa4dMlA#MJMATHI-69" x="748" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457292/&amp;usg=ALkJrhjwqB2cnQThBaVbt7_03tSVa4dMlA#MJMAIN-29" x="14349" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtext>&nbsp;</mtext><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><mi>a</mi><mo>=</mo><mn>1</mn><mo>−</mo><mtext>&nbsp;</mtext><mi>p</mi><mi>r</mi><mi>o</mi><msubsup><mi>d</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow class="MJX-TeXAtom-ORD"><mi>n</mi></mrow></msubsup><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mtext>&nbsp;</mtext><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><msub><mi>a</mi><mi>i</mi></msub><mo stretchy="false">)</mo></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-3"> \ alpha = 1- \ prod_ {i = 1} ^ {n} (1- \ alpha_i) </script></p><br>  Ini adalah fungsi skalar dalam ruang n-dimensi.  Semua <i>α <sub>i</sub></i> terkandung dalam [0, 1] sehingga turunan parsialnya berkenaan dengan salah satu <i>α <sub>i</sub></i> adalah konstanta non-negatif.  Ini berarti bahwa opacity dari fragmen "weighted mean" meningkat ketika Anda meningkatkan opacity dari salah satu fragmen transparan, yang persis seperti yang kita inginkan.  Selain itu, meningkat secara linear. <br><br>  Jika opacity dari beberapa fragmen adalah 0 maka itu sama sekali tidak terlihat.  Itu tidak berkontribusi pada warna yang dihasilkan sama sekali. <br><br>  Jika setidaknya satu fragmen memiliki opacity 1 maka <i>α</i> adalah 1 juga.  Artinya, fragmen non-transparan menjadi tidak terlihat, yang bagus.  Masalahnya adalah, fragmen transparan lainnya (di belakang fragmen ini dengan opacity = 1) masih dapat dilihat melaluinya dan berkontribusi pada warna yang dihasilkan: <br><br><img src="https://habrastorage.org/webt/3s/lm/3y/3slm3yxglf43xno7dyqu8g7ua-o.png" width="300"><br><br>  Segitiga oranye pada gambar ini terletak di bagian atas, segitiga hijau terletak di bawahnya dan di bawah segitiga hijau terletak segitiga abu-abu dan cyan.  Latar belakangnya hitam.  Opacity segitiga oranye adalah 1;  yang lainnya memiliki opacity = 0,5.  Di sini Anda dapat melihat bahwa WBOIT terlihat sangat miskin.  Satu-satunya tempat di mana warna oranye sejati muncul adalah tepi segitiga hijau yang diuraikan dengan garis putih tidak transparan.  Seperti yang saya sebutkan, fragmen non-transparan tidak terlihat jika memiliki fragmen transparan di atasnya dengan opacity = 1. <br><br>  Itu terlihat lebih baik pada gambar berikut: <br><br><img src="https://habrastorage.org/webt/-3/dc/ey/-3dcey8p1s2ynmgq9oyatw1ojma.png" width="300"><br><br>  Opacity segitiga oranye adalah 1, segitiga hijau dengan transparansi dimatikan hanya ditampilkan dengan objek yang tidak transparan.  Sepertinya warna HIJAU dari segitiga di belakang menyaring melalui segitiga atas sebagai warna ORANGE. <br><br>  Cara paling sederhana untuk membuat gambar Anda terlihat masuk akal adalah dengan tidak mengatur opacity tinggi untuk objek Anda.  Dalam sebuah proyek di mana saya menggunakan teknik ini, saya tidak mengatur opacity lebih dari 0,5.  Ini adalah CAD 3D di mana objek digambar secara skematis dan tidak perlu terlihat sangat realistis, sehingga batasan ini dapat diterima. <br><br>  Dengan opasitas rendah, gambar kiri dan kanan terlihat sangat mirip: <br><br><img src="https://habrastorage.org/webt/hz/pc/ud/hzpcud9vuojz7vk0rsofbidyumy.png" width="1000"><br><br>  Dan mereka jelas berbeda dengan opasitas tinggi: <br><br><img src="https://habrastorage.org/webt/iv/hq/_l/ivhq_lqrb8ofbxie323mtwpfg-q.png" width="1000"><br><br>  Berikut ini adalah polyhedron transparan: <br><br><img src="https://habrastorage.org/webt/nm/oi/6u/nmoi6u1xvycmbwvt50z6pinofbg.png" width="500"><br><img src="https://habrastorage.org/webt/ej/9u/p1/ej9up1muignigkr73kn2mi5byrs.png" width="500"><br><br>  Ini memiliki wajah sisi oranye dan wajah horisontal hijau, yang sayangnya tidak jelas, yang berarti bahwa gambar tidak terlihat kredibel.  Di mana pun wajah oranye berada di atas, warnanya harus lebih oranye, dan di mana di balik wajah hijau, warnanya harus lebih hijau.  Lebih baik menggambarnya dengan satu warna: <br><br><img src="https://habrastorage.org/webt/a2/eg/bf/a2egbfdzwlwmaltuc4lpyna45gs.png" width="500"><br><br><h3>  Suntikkan kedalaman ke operator blending </h3><br>  Untuk mengkompensasi kurangnya penyortiran kedalaman, penulis makalah JCGT tersebut datang dengan beberapa cara untuk menyuntikkan kedalaman dalam formula (2).  Ini mempersulit implementasi dan membuat hasilnya kurang dapat diprediksi.  Untuk membuatnya berfungsi, blending parameter harus disesuaikan dengan adegan 3D tertentu.  Saya tidak mempelajari topik ini secara mendalam, jadi jika Anda ingin tahu lebih banyak, baca koran. <br><br>  Penulis mengklaim bahwa terkadang WBOIT mampu melakukan sesuatu yang tidak dapat dilakukan CODB.  Misalnya, pertimbangkan menggambar asap sebagai sistem partikel dengan dua partikel: asap gelap dan asap lebih ringan.  Ketika partikel bergerak dan satu partikel melewati yang lain, warna campurannya langsung beralih dari gelap ke terang, yang tidak baik.  Operator WBOIT dengan kedalaman menghasilkan hasil yang lebih disukai dengan transisi warna yang halus.  Rambut atau bulu yang dimodelkan sebagai satu set tabung tipis memiliki sifat yang sama. <br><br><h3>  Kodenya </h3><br>  Sekarang untuk implementasi OpenGL dari rumus (2).  Anda dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">melihat implementasinya</a> di GitHub.  Ini adalah aplikasi berbasis Qt, dan gambar yang Anda lihat di sini sebagian besar berasal dari itu. <br><br>  Jika Anda baru mengenal rendering transparan, berikut ini adalah materi entry-level yang bagus: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pelajari OpenGL.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memadukan</a> <br><br>  Saya sarankan membacanya sebelum melanjutkan dengan posting ini. <br><br>  Untuk mengevaluasi formula (2) kita membutuhkan 2 framebuffer tambahan, 3 tekstur multisamle dan renderbuffer kedalaman.  Objek yang tidak transparan akan dirender ke tekstur pertama, colorTextureNT.  Jenisnya adalah GL_RGB10_A2.  Tekstur kedua (colorTexture) akan bertipe GL_RGBA16F.  Tiga komponen pertama colorTexture akan mengandung bagian formula ini (2): <img src="https://habrastorage.org/webt/9p/7i/vm/9p7ivmikwxs8ltenmceiumeogoo.png" width="70">  , dan <img src="https://habrastorage.org/webt/i2/bg/uc/i2bguc_jhzovzvn6ybqfkkuds4q.png" width="50">  akan ditulis ke komponen keempat.  Tekstur terakhir, alphaTexture, dari tipe GL_R16 akan berisi <img src="https://habrastorage.org/webt/ma/si/f0/masif074trzop-clpwvbwtfj92i.png" width="90">  . <br><br>  Pertama, kita perlu membuat semua objek itu dan mendapatkan pengenalnya dari OpenGL: <br><pre> <code class="cpp hljs"> f-&gt;glGenFramebuffers (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;framebufferNT ); f-&gt;glGenTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;colorTextureNT ); f-&gt;glGenRenderbuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;depthRenderbuffer); f-&gt;glGenFramebuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;framebuffer ); f-&gt;glGenTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;colorTexture); f-&gt;glGenTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;alphaTexture);</code> </pre> <br>  Saya menggunakan Qt framewok, seperti yang Anda ingat, dan semua panggilan ke OpenGL dibuat dari objek bertipe QOpenGLFunctions_4_5_Core, yang untuknya saya selalu menggunakan nama f. <br><br>  Alokasi memori berikutnya: <br><pre> <code class="cpp hljs"> f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, colorTextureNT); f-&gt;glTexImage2DMultisample( GL_TEXTURE_2D_MULTISAMPLE, numOfSamples, GL_RGB16F, w, h, GL_TRUE ); f-&gt;glBindRenderbuffer(GL_RENDERBUFFER, depthRenderbuffer); f-&gt;glRenderbufferStorageMultisample( GL_RENDERBUFFER, numOfSamples, GL_DEPTH_COMPONENT, w, h ); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, colorTexture); f-&gt;glTexImage2DMultisample( GL_TEXTURE_2D_MULTISAMPLE, numOfSamples, GL_RGBA16F, w, h, GL_TRUE ); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, alphaTexture); f-&gt;glTexImage2DMultisample( GL_TEXTURE_2D_MULTISAMPLE, numOfSamples, GL_R16F, w, h, GL_TRUE );</code> </pre> <br>  Pengaturan Framebuffer: <br><pre> <code class="cpp hljs"> f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebufferNT); f-&gt;glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, colorTextureNT, <span class="hljs-number"><span class="hljs-number">0</span></span> ); f-&gt;glFramebufferRenderbuffer( GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthRenderbuffer ); f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebuffer); f-&gt;glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, colorTexture, <span class="hljs-number"><span class="hljs-number">0</span></span> ); f-&gt;glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT1, GL_TEXTURE_2D_MULTISAMPLE, alphaTexture, <span class="hljs-number"><span class="hljs-number">0</span></span> ); GLenum attachments[<span class="hljs-number"><span class="hljs-number">2</span></span>] = {GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1}; f-&gt;glDrawBuffers(<span class="hljs-number"><span class="hljs-number">2</span></span>, attachments); f-&gt;glFramebufferRenderbuffer( GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthRenderbuffer );</code> </pre> <br>  Selama pass rendering kedua, output dari shader fragmen akan terdiri dari dua tekstur, yang harus ditentukan secara eksplisit dengan glDrawBuffers. <br>  Sebagian besar kode ini dieksekusi satu kali, ketika program dimulai.  Kode untuk alokasi memori tekstur dan renderbuffer dijalankan setiap kali ukuran jendela diubah.  Sekarang kita lanjutkan ke kode yang dieksekusi setiap kali isi jendela diperbarui. <br><pre> <code class="cpp hljs"> f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebufferNT); <span class="hljs-comment"><span class="hljs-comment">// ... rendering non-transparent objects ... // ....... // done! (you didn't expect me to explain how do I render primitives in OpenGL, did you? // It's not relevant for this topic</span></span></code> </pre> <br>  Kami baru saja memberikan semua objek yang tidak transparan ke colorTextureNT dan menulis kedalaman di renderbuffer.  Sebelum menggunakan renderbuffer yang sama pada pass rendering berikutnya, kita perlu memastikan bahwa semua operasi penulisan dalam renderbuffer mendalam dari objek yang tidak transparan telah selesai.  Ini dicapai dengan GL_FRAMEBUFFER_BARRIER_BIT.  Setelah objek transparan di-render, kita akan memanggil fungsi ApplyTextures () yang akan melakukan proses rendering akhir di mana shader fragmen akan mengambil sampel dari tekstur colorTextureNT, colorTexture, dan alphaTexture untuk menerapkan rumus (2).  Tekstur harus siap pada saat itu, jadi kami menggunakan GL_TEXTURE_FETCH_BARRIER_BIT sebelum memanggil ApplyTextures (). <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> GLfloat clearColor[<span class="hljs-number"><span class="hljs-number">4</span></span>] = { <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> GLfloat clearAlpha = <span class="hljs-number"><span class="hljs-number">1.0f</span></span>; f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebuffer); f-&gt;glClearBufferfv(GL_COLOR, <span class="hljs-number"><span class="hljs-number">0</span></span>, clearColor); f-&gt;glClearBufferfv(GL_COLOR, <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;clearAlpha); f-&gt;glMemoryBarrier(GL_FRAMEBUFFER_BARRIER_BIT); PrepareToTransparentRendering(); { <span class="hljs-comment"><span class="hljs-comment">// ... rendering transparent objects ... } CleanupAfterTransparentRendering(); f-&gt;glMemoryBarrier(GL_TEXTURE_FETCH_BARRIER_BIT); f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, defaultFBO); ApplyTextures();</span></span></code> </pre> <br>  defaultFBO adalah framebuffer yang kami gunakan untuk menampilkan gambar di layar.  Dalam kebanyakan kasus itu adalah 0, tetapi dalam Qt adalah QOpenGLWidget :: defaultFramebufferObject (). <br><br>  Dalam setiap doa shader fragmen kita akan memiliki akses ke warna dan opacity dari fragmen saat ini.  Tetapi dalam colorTexture harus muncul jumlah (dan dalam alphaTexture produk) dari entitas tersebut.  Untuk itu, kami akan menggunakan blending.  Selain itu, mengingat bahwa untuk tekstur pertama kita menghitung jumlah sedangkan untuk yang kedua kita menghitung suatu produk, kita harus menyediakan pengaturan pencampuran yang berbeda (glBlendFunc dan glBlendEquation) untuk setiap lampiran. <br><br>  Berikut ini isi dari fungsi SiapkanToTransparentRendering (): <br><pre> <code class="cpp hljs"> f-&gt;glEnable(GL_DEPTH_TEST); f-&gt;glDepthMask(GL_FALSE); f-&gt;glDepthFunc(GL_LEQUAL); f-&gt;glDisable(GL_CULL_FACE); f-&gt;glEnable(GL_MULTISAMPLE); f-&gt;glEnable(GL_BLEND); f-&gt;glBlendFunci(<span class="hljs-number"><span class="hljs-number">0</span></span>, GL_ONE, GL_ONE); f-&gt;glBlendEquationi(<span class="hljs-number"><span class="hljs-number">0</span></span>, GL_FUNC_ADD); f-&gt;glBlendFunci(<span class="hljs-number"><span class="hljs-number">1</span></span>, GL_DST_COLOR, GL_ZERO); f-&gt;glBlendEquationi(<span class="hljs-number"><span class="hljs-number">1</span></span>, GL_FUNC_ADD);</code> </pre> <br><br>  Dan isi fungsi CleanupAfterTransparentRendering (): <br><pre> <code class="cpp hljs"> f-&gt;glDepthMask(GL_TRUE); f-&gt;glDisable(GL_BLEND);</code> </pre> <br>  Dalam fragmen shader saya, w berarti opacity.  Produk warna dan w - dan w itu sendiri - akan pergi ke parameter output pertama, dan 1 - w akan pergi ke parameter output kedua.  Kualifikasi tata letak harus ditetapkan untuk setiap parameter output dalam bentuk "location = X", di mana X adalah indeks elemen dalam array lampiran - yang kami berikan ke fungsi glDrawBuffers.  Lebih tepatnya, parameter output dengan location = 0 pergi ke tekstur terikat ke GL_COLOR_ATTACHMENT1, dan parameter dengan lokasi = 1 pergi ke tekstur terikat ke GL_COLOR_ATTACHMENT1.  Angka-angka yang sama digunakan dalam fungsi glBlendFunci dan glBlendEquationi untuk menunjukkan lampiran warna mana yang kita atur parameter blending. <br><br>  Shader fragmen: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 core in vec3 color; layout (location = 0) out vec4 outData; layout (location = 1) out float alpha; layout (location = 2) uniform float w; void main() { outData = vec4(w * color, w); alpha = 1 - w; }</span></span></code> </pre> <br>  Dalam fungsi ApplyTextures () kita cukup menggambar persegi panjang yang menutupi seluruh viewport.  Sampel sampel shader fragmen dari ketiga tekstur menggunakan koordinat layar-ruang saat ini sebagai tekstur, dan indeks sampel saat ini (gl_SampleID) sebagai indeks sampel untuk tekstur multisampel.  Kehadiran variabel gl_SampleID dalam kode shader membuat sistem untuk memanggil fragmen shader sekali per sampel (sementara biasanya itu dipanggil sekali per piksel, menulis outputnya ke semua sampel yang termasuk dalam primitif). <br><br>  Vertex shader adalah sepele: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 core const vec2 p[4] = vec2[4]( vec2(-1, -1), vec2( 1, -1), vec2( 1, 1), vec2(-1, 1) ); void main() { gl_Position = vec4(p[gl_VertexID], 0, 1); }</span></span></code> </pre> <br><br>  Shader fragmen: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 core out vec4 outColor; layout (location = 0) uniform sampler2DMS colorTextureNT; layout (location = 1) uniform sampler2DMS colorTexture; layout (location = 2) uniform sampler2DMS alphaTexture; void main() { ivec2 upos = ivec2(gl_FragCoord.xy); vec4 cc = texelFetch(colorTexture, upos, gl_SampleID); vec3 sumOfColors = cc.rgb; float sumOfWeights = cc.a; vec3 colorNT = texelFetch(colorTextureNT, upos, gl_SampleID).rgb; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (sumOfWeights == 0) { outColor = vec4(colorNT, 1.0); return; } float alpha = 1 - texelFetch(alphaTexture, upos, gl_SampleID).r; colorNT = sumOfColors / sumOfWeights * alpha + colorNT * (1 - alpha); outColor = vec4(colorNT, 1.0); }</span></span></code> </pre> <br>  Dan akhirnya - fungsi ApplyTextures (): <br><pre> <code class="cpp hljs"> f-&gt;glActiveTexture(GL_TEXTURE0); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, colorTextureNT); f-&gt;glUniform1i(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); f-&gt;glActiveTexture(GL_TEXTURE1); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, colorTexture); f-&gt;glUniform1i(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); f-&gt;glActiveTexture(GL_TEXTURE2); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, alphaTexture); f-&gt;glUniform1i(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); f-&gt;glEnable(GL_MULTISAMPLE); f-&gt;glDisable(GL_DEPTH_TEST); f-&gt;glDrawArrays(GL_TRIANGLE_FAN, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre> <br><br>  Pada akhirnya, sumber daya OpenGL harus dibebaskan.  Saya melakukannya di destructor widget OpenGL saya: <br><pre> <code class="cpp hljs"> f-&gt;glDeleteFramebuffers (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;framebufferNT); f-&gt;glDeleteTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;colorTextureNT); f-&gt;glDeleteRenderbuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;depthRenderbuffer); f-&gt;glDeleteFramebuffers (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;framebuffer); f-&gt;glDeleteTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;colorTexture); f-&gt;glDeleteTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;alphaTexture);</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id457292/">https://habr.com/ru/post/id457292/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id457282/index.html">"Kematian Tuhan" atau runtuhnya undang-undang yang berlaku umum untuk membangun tim TI dan menciptakan sistem TI di abad ke-21</a></li>
<li><a href="../id457284/index.html">WBOIT di OpenGL: transparansi tanpa pengurutan</a></li>
<li><a href="../id457286/index.html">Solusi tugas WorldSkills dari modul Network dalam kompetensi "CCA". Bagian 1 - Pengaturan Dasar</a></li>
<li><a href="../id457288/index.html">Stasiun kerja kriptografis berdasarkan token PKCS # 11. Tanda tangan elektronik. Bagian 2</a></li>
<li><a href="../id457290/index.html">Konferensi DEFCON 25. Garry Kasparov. "Pertempuran terakhir otak." Bagian 2</a></li>
<li><a href="../id457294/index.html">"Live high" atau kisah saya dari penundaan hingga pengembangan diri</a></li>
<li><a href="../id457298/index.html">Frontend Weekly Digest (17 - 23 Juni 2019)</a></li>
<li><a href="../id457300/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 370 (17 - Juni 23, 2019)</a></li>
<li><a href="../id457302/index.html">10 fitur untuk mempercepat analisis data dalam Python</a></li>
<li><a href="../id457304/index.html">Layanan Statistik untuk Aplikasi Seluler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>