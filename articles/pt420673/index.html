<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙋🏿 ✍🏾 ✌🏽 Docker para Symfony 4 - da LAN à produção 💅🏽 🙎🏼 ☦️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pré-história 
 Um belo dia, eu precisava implantar um ambiente de desenvolvimento para o meu projeto. O Vagrant já estava cansado disso e queria ter u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Docker para Symfony 4 - da LAN à produção</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420673/"><h2>  Pré-história </h2><br>  Um belo dia, eu precisava implantar um ambiente de desenvolvimento para o meu projeto.  O Vagrant já estava cansado disso e queria ter um ambiente de desenvolvimento único para todos os participantes do projeto que fosse idêntico ao servidor de produção.  Assim, depois de ouvir informações sobre o docker hipster, decidi começar a lidar com isso.  A seguir, tentarei descrever com o máximo de detalhes possível todas as etapas, desde a instalação de uma janela de encaixe em uma LAN até a implantação de um produto no KVM. <br><br>  <b>Pilha de tecnologia original:</b> <br><br>  - janela de encaixe <br>  - symfony 4 <br>  - nginx <br>  - php-fpm <br>  - postgresql <br>  - elasticsearch <br>  - rabbitmq <br>  - jenkins <br><br>  <b>Ferro:</b> <br><br>  - laptop no sistema operacional Ubuntu 16.04 <br>  - servidor de produção na hospedagem KVM <br><br>  <i>Por que, além da pilha tecnológica, também listei a pilha de ferro?</i> <br><br>  Se você nunca trabalhou anteriormente com uma janela de encaixe, poderá encontrar vários problemas relacionados especificamente ao hardware, ao sistema operacional do seu laptop ou ao tipo de virtualização de hospedagem. <br><br>  O primeiro e provavelmente o aspecto mais importante ao começar a trabalhar com a janela de encaixe é o sistema operacional do seu laptop.  A maneira mais fácil de trabalhar com o docker é em sistemas Linux.  Se você trabalha no Windows ou Mac, terá 100% de algumas dificuldades, mas essas dificuldades não serão críticas e se você quiser “pesquisar” como isso é corrigido, não haverá problemas. <br><br>  A segunda pergunta é de hospedagem.  Por que a hospedagem é necessária com o tipo de virtualização KVM?  O motivo é que a virtualização VPS é muito diferente da KVM e você simplesmente não poderá instalar a janela de encaixe no VPS, pois o VPS aloca dinamicamente os recursos do servidor. <br><br>  Subtotal: para o início mais rápido na janela de encaixe, é mais razoável escolher o Ubuntu como um SO local e hospedagem KVM (ou seu próprio servidor).  Além disso, a história continuará precisando desses dois componentes. <br><a name="habracut"></a><br><h2>  Docker-compor para LAN </h2><br><h3>  Instalação </h3><br>  Primeiro, você precisa instalar a própria janela de encaixe localmente.  Você pode ver as instruções de instalação no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">link do</a> site oficial <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">para a documentação oficial do ubuntu</a> (você precisa instalar o docker e o docker-compose) ou executando o comando no console: <br><br><pre><code class="bash hljs">curl -sSl https://get.docker.com/ | sh</code> </pre> <br>  Este comando instalará a janela de encaixe e a composição de encaixe.  Depois disso, verifique a versão do Docker com o comando: <br><br><pre> <code class="bash hljs">docker --version</code> </pre> <br>  Estou começando tudo isso na janela de encaixe versão 18.06.0-ce. <br><br>  A instalação está completa! <br><br><h3>  Consciência </h3><br>  Para trabalhar com algo com menos sucesso - você precisa ter uma idéia de como ele funciona.  Se você trabalhou anteriormente apenas com o Vagrant ou algo semelhante, será extremamente incomum e incompreensível a princípio, mas isso é apenas a princípio. <br><br>  Vou tentar fazer uma analogia para o Vagrant.  Agora muitos podem dizer que comparar Vagrant e Docker está fundamentalmente errado.  Sim, concordo com isso, mas não vou compará-los, apenas tentarei transmitir aos recém-chegados que trabalharam apenas com o sistema de trabalho Vagrant the Docker, apelando para o que os recém-chegados sabem. <br><br>  Minha visão do contêiner "nos dedos" é a seguinte: cada contêiner é um pequeno mundo isolado.  Cada contêiner pode ser imaginado como se fosse um pequeno Vagrant no qual apenas uma ferramenta está instalada, por exemplo, nginx ou php.  Inicialmente, os contêineres geralmente são isolados de tudo ao seu redor, mas com manipulações complicadas, você pode configurar tudo para que eles se comuniquem e trabalhem juntos.  Isso não significa que cada um dos contêineres seja uma máquina virtual separada, nem um pouco.  Mas é mais fácil para o entendimento inicial, como me parece. <br><br>  O Vagrant simplesmente retira parte dos recursos do seu computador, cria uma máquina virtual, instala um sistema operacional, instala bibliotecas, instala tudo o que você escreveu no script depois de vagar.  Por fim, parece algo como isto: <br><br>  → <a href="">Ver esquema</a> <br><br>  O Docker, por sua vez, funciona radicalmente diferente.  Não cria máquinas virtuais.  O Docker cria contêineres (por enquanto, você pode considerá-los máquinas micro-virtuais) com seu sistema operacional Alpine e 1-3 bibliotecas necessárias para o aplicativo funcionar, por exemplo, php ou nginx.  Ao mesmo tempo, o Docker não bloqueia os recursos do seu sistema, mas simplesmente os utiliza conforme necessário.  Por fim, para ilustrar, será algo parecido com isto: <br><br>  → <a href="">Ver esquema</a> <br><br>  Cada um dos contêineres tem uma imagem a partir da qual é criado.  A grande maioria das imagens é uma extensão de outra imagem, por exemplo, Ubuntu xenial ou Alpine ou Debian, na qual drivers adicionais e outros componentes são colocados no topo. <br><br>  Minha primeira imagem foi para php-fpm.  Minha imagem estende a imagem oficial do php: 7.2-fpm-alpine3.6.  Ou seja, em essência, ele pega a imagem oficial e fornece os componentes que eu preciso, por exemplo, pdo_pgsql, imagick, zip e assim por diante.  Assim, você pode criar a imagem que precisa.  Se você quiser, você pode usá-lo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  Com a criação das imagens, tudo é bastante simples, na minha opinião, se elas são feitas com base no xenial, por exemplo, mas elas produzem um pouco de hemorróidas se forem feitas com base no Alpine.  Antes de começar a trabalhar com o docker, eu basicamente não ouvia falar do Alpine, pois o Vagrant sempre trabalhava para mim no Ubuntu xenial.  Alpine é um sistema operacional Linux vazio, no qual não há praticamente nada (mínimo extremo).  Portanto, no início, é extremamente inconveniente trabalhar com ele, já que existe, por exemplo, a mesma instalação do apt-get (com a qual você se acostuma), mas há apenas o apk add e um conjunto de pacotes não muito sensato.  Uma grande vantagem do Alpine é seu peso, por exemplo, se Xenial pesa (abstratamente) 500 sacas, então Alpine (abstratamente) é de cerca de 78 sacas.  O que isso afeta?  E isso afeta a velocidade de criação e o peso final de todas as imagens que serão armazenadas no servidor no final.  Digamos que você tenha 5 contêineres diferentes e tudo baseado em xenial, seu peso total será superior a 2,5 GB e alpino - cerca de 500 sacas.  Portanto, idealmente, devemos nos esforçar para garantir que os contêineres sejam o mais fino possível.  (Link útil para instalar pacotes nos pacotes Alpine - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Alpine</a> ). <br><br>  Em todos os lugares no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">hub</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">docker, eles</a> escrevem como iniciar o contêiner usando o <code>docker run</code> e, por algum motivo, não escrevem como ele pode ser iniciado através do docker-compose, e é através do docker-compose que ele inicia na maioria das vezes, uma vez que há muito pouca procura. inicie manualmente todos os contêineres, redes, portas abertas e muito mais.  O Docker-compose em nome do usuário se parece com um arquivo yaml com configurações.  Inclui uma descrição de cada um dos serviços que devem ser iniciados.  Minha construção para o ambiente local é a seguinte: <br><br><pre> <code class="hljs powershell">version: <span class="hljs-string"><span class="hljs-string">'3.1'</span></span> services: php<span class="hljs-literal"><span class="hljs-literal">-fpm</span></span>: image: otezvikentiy/php7.<span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-literal"><span class="hljs-literal">-fpm</span></span>:<span class="hljs-number"><span class="hljs-number">0.0</span></span>.<span class="hljs-number"><span class="hljs-number">11</span></span> ports: - <span class="hljs-string"><span class="hljs-string">'9000:9000'</span></span> volumes: - ../:/app working_dir: /app container_name: <span class="hljs-string"><span class="hljs-string">'php-fpm'</span></span> nginx: image: nginx:<span class="hljs-number"><span class="hljs-number">1.15</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> container_name: <span class="hljs-string"><span class="hljs-string">'nginx'</span></span> working_dir: /app ports: - <span class="hljs-string"><span class="hljs-string">'7777:80'</span></span> volumes: - ../:/app - ./nginx/nginx.conf:/etc/nginx/conf.d/default.conf postgres: image: postgres:<span class="hljs-number"><span class="hljs-number">9.6</span></span> ports: - <span class="hljs-string"><span class="hljs-string">'5432:5432'</span></span> container_name: <span class="hljs-string"><span class="hljs-string">'postgresql'</span></span> working_dir: /app restart: always environment: POSTGRES_DB: <span class="hljs-string"><span class="hljs-string">'db_name'</span></span> POSTGRES_USER: <span class="hljs-string"><span class="hljs-string">'db_user'</span></span> POSTGRES_PASSWORD: <span class="hljs-string"><span class="hljs-string">'db_pass'</span></span> volumes: - ./<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>/dump:/app/dump - ./<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>/postgresql:/var/lib/postgresql/<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> rabbitmq: image: rabbitmq:<span class="hljs-number"><span class="hljs-number">3.7</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span><span class="hljs-literal"><span class="hljs-literal">-management</span></span> working_dir: /app hostname: rabbit<span class="hljs-literal"><span class="hljs-literal">-mq</span></span> container_name: <span class="hljs-string"><span class="hljs-string">'rabbit-mq'</span></span> ports: - <span class="hljs-string"><span class="hljs-string">'15672:15672'</span></span> - <span class="hljs-string"><span class="hljs-string">'5672:5672'</span></span> environment: RABBITMQ_DEFAULT_USER: user RABBITMQ_DEFAULT_PASS: password RABBITMQ_DEFAULT_VHOST: my_vhost elasticsearch: image: docker.elastic.co/elasticsearch/elasticsearch:<span class="hljs-number"><span class="hljs-number">6.3</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> container_name: <span class="hljs-string"><span class="hljs-string">'elastic-search'</span></span> environment: - discovery.type=single<span class="hljs-literal"><span class="hljs-literal">-node</span></span> - <span class="hljs-string"><span class="hljs-string">"discovery.zen.ping.unicast.hosts=elasticsearch"</span></span> - bootstrap.memory_lock=true - <span class="hljs-string"><span class="hljs-string">"ES_JAVA_OPTS=-Xms512m -Xmx512m"</span></span> ports: - <span class="hljs-number"><span class="hljs-number">9200</span></span>:<span class="hljs-number"><span class="hljs-number">9200</span></span> - <span class="hljs-number"><span class="hljs-number">9300</span></span>:<span class="hljs-number"><span class="hljs-number">9300</span></span> working_dir: /app volumes: - ../:/app - ./<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>/elasticsearch:/usr/share/elasticsearch/<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> volumes: elasticsearch: postgresql:</code> </pre><br>  docker-compose.yaml para SF4 é um determinado conjunto de serviços: nginx, php-fpm, postgresql, rabbitmq (se você precisar), elasticsearch (se você precisar).  Para o ambiente local, isso é suficiente.  Para fazer tudo funcionar - há um conjunto mínimo de configurações, sem as quais nada funcionará.  Na maioria das vezes, são imagem, volumes, portas, ambiente, working_dir e container_name.  Tudo para iniciar esta ou aquela imagem está descrito em sua documentação em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">hub.docker.com</a> .  Nem sempre existe uma descrição para o docker-compose, mas isso não significa que ele não funcione.  É apenas necessário transferir todos os dados recebidos do comando docker run para o docker-composite e tudo funcionará. <br><br>  Por exemplo, há uma imagem para o RabbitMQ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  Quando você vê ISTO pela primeira vez, causa sentimentos e emoções confusas, mas nem tudo é tão assustador.  As etiquetas são indicadas nesta imagem.  Geralmente tags - representam imagens diferentes, versões diferentes do aplicativo com diferentes imagens expansíveis.  Por exemplo, a tag 3.7.7-alpine significa que esta imagem é mais fina que, por exemplo, 3.7.7, pois é baseada em Alpine.  Bem, e também nas tags, na maioria das vezes, as versões do aplicativo são indicadas.  Normalmente escolho a versão mais recente e a versão estável do próprio aplicativo e da imagem alpina. <br><br>  Depois de estudar e selecionar uma tag - muitas vezes você vê algo desse tipo: <br><br><pre> <code class="bash hljs">docker run -d --hostname my-rabbit --name some-rabbit -e RABBITMQ_DEFAULT_USER=user -e RABBITMQ_DEFAULT_PASS=password rabbitmq:3-management</code> </pre> <br>  E o primeiro pensamento é WTF?  Como transferir isso para docker-compondo? <br><br>  Tudo é bem fácil.  De fato, esta linha indica todos os mesmos parâmetros que no arquivo yaml, apenas abreviados.  Por exemplo, -e é um ambiente no qual vários parâmetros são passados; também pode haver entradas como -p - essas são portas que são chamadas de portas no yaml.  Portanto, para usar uma imagem desconhecida de uma maneira de qualidade, você só precisa “google” a janela de encaixe executar abreviações e aplicar os nomes completos no arquivo yaml. <br><br>  Agora, de volta ao docker-compose.yml, que citei como exemplo acima. <br><br>  Este exemplo usa minha imagem php7.2 criada como uma extensão da imagem oficial php7.2-fpm-alpine, mas se você não precisar de tantas bibliotecas adicionais, poderá criar sua extensão para a imagem oficial e usá-la.  O restante das imagens para LAN são completamente originais e oficiais. <br><br>  <b>imagem</b> - indica qual imagem baixar.  Por exemplo (rabbitmq: 3.7.7-management-alpine). <br><br>  <b>portas</b> - especifique as portas que o contêiner usará (consulte a documentação da imagem).  A porta nginx de exemplo é 80 por padrão.  Portanto, se você deseja usar a porta 80, especifique 80:80 aqui e seu site estará disponível no host local.  Ou você pode especificar 7777: 80 e, em seguida, seu site estará no URL localhost: 7777.  Isso é necessário para que vários projetos possam ser implantados no mesmo host. <br><br>  <b>volumes</b> - diretórios compartilhados são indicados aqui.  Por exemplo, seu projeto está no diretório ~ / projects / my-sf4-app, e o contêiner php está configurado para funcionar com o diretório / app (o mesmo que em / var / www / my-sf4-app).  Por conseguinte, seria conveniente para o contêiner ter acesso ao projeto.  Assim, em volumes, escrevemos <code>~/projects/my-sf4-app:/app</code> (veja este exemplo em docker-compose.yml acima (eu o indiquei de maneira relativa ../:/app)). <br><br>  Assim, a pasta será compartilhada para o contêiner e poderá executar várias ações, como a <code>php bin/console doctrine:migrations:migrate</code> .  Também é conveniente usar esses diretórios para salvar os dados do aplicativo.  Por exemplo, postgresql, você pode especificar um diretório para armazenar dados do banco de dados e, ao recriar o contêiner, não será necessário rolar um dump ou acessórios. <br><br>  <b>working_dir</b> - indica o diretório de trabalho do contêiner.  Nesse caso, / app (ou por analogia com o vagrant / var / www / my-sf4-app). <br><br>  <b>ambiente</b> - todas as variáveis ​​para o contêiner são passadas aqui.  Por exemplo, para rabbitmq, o nome de usuário e a senha são transmitidos, para o postgresql, o nome da base, o nome de usuário e a senha são passados. <br><br>  <b>container_name</b> é um campo opcional, mas prefiro especificar, para a conveniência de conectar-se a contêineres.  Se não especificado, os nomes padrão com hashes serão atribuídos. <br><br>  Estes são os principais parâmetros que devem ser especificados.  O restante pode ser opcional para configurações adicionais ou de acordo com a documentação do contêiner. <br><br>  Agora, para iniciar tudo isso, você precisa executar o <code>docker-compose up -d</code> no diretório em que o arquivo docker-compose está localizado. <br><br><h3>  Como e onde armazenar tudo isso para a LAN? </h3><br>  Para a LAN, uso a pasta docker na raiz do projeto. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pv/rg/a8/pvrga87xk7vcujz2-qwbjnqmtjk.png"></div><br>  Ele contém a pasta de dados na qual eu armazeno todas as informações postgresql e elasticsearch, para que, quando você recrie o projeto, não precise rolar os equipamentos do zero.  Há também um pai nginx no qual armazeno a configuração para o contêiner nginx local.  Sincronizo essas pastas no docker-compose.yml com os arquivos e pastas correspondentes nos contêineres.  Também na minha opinião, é muito conveniente escrever scripts bash para trabalhar com o docker.  Por exemplo, o script start.sh inicia contêineres, instala o compositor, limpa o cache e migra.  Também é conveniente para os colegas do projeto, eles não precisam fazer nada, apenas executam o script e tudo funciona. <br><br>  Exemplo de script Start.sh <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env bash green=$(tput setf 2) toend=$(tput hpa $(tput cols))$(tput cub 6) echo -n '   ?: ' read name echo "  $name!       tutmesto.ru" echo -n "$name,      ? (y/n): " read use_dump echo '    !' docker-compose up -d || exit echo -en '\n' echo -n "  ! ${green}${toend}[OK]" echo -en '\n' echo '    .' ./composer-install.sh echo -en '\n' echo -n "   ${green}${toend}[OK]" echo -en '\n' echo '     40 ,    postgres-' sleep 5 echo '  35 ...' sleep 5 echo '  30 ...' sleep 5 echo '  25 ...' sleep 5 echo '  20 ...' sleep 5 echo '  15 ...' sleep 5 echo '  10 ...' sleep 5 echo '  5 ...' sleep 5 echo ' .   postgres-        !' case "$use_dump" in y|Y) ./dump.sh echo -en '\n' echo -n "  ! ${green}${toend}[OK]" echo -en '\n' ;; *) echo "$name, ,   ! =)" ;; esac echo '    !' ./migrations-migrate.sh echo -en '\n' echo -n "  ! ${green}${toend}[OK]" echo -en '\n' echo '  !' ./php-fpm-command.sh rm -rf var/cache/* ./php-fpm-command.sh chmod 777 var/ -R ./cache-clear.sh echo -en '\n' echo -n "  ! ${green}${toend}[OK]" echo -en '\n' echo '    !' ./env.sh echo -en '\n' echo -n "   ! ${green}${toend}[OK]" echo -en '\n' echo ", $name,    !    localhost:7777  !" echo -en '\n' echo "------------------------------------------------------------------------------" echo -en '\n' echo "    :" echo "./cache-clear.sh |  symfony 4" echo "./composer.sh [command(ex. install)] |  " echo "./composer-install.sh | composer install" echo "./connect-to-php-fpm.sh |   php" echo "./console.sh [command(ex. cache:clear)] |  php bin/console" echo "./destroy.sh |  .    ." echo "./dump.sh | ,     (dump.sql)" echo "./env.sh |   " echo "./migrations-migrate.sh | " echo "./php-fpm-command.sh [command(ex. php -m)] |   php-fpm " echo "./start.sh |  ( )" echo "./stop.sh |Gracefull shutdown " echo -en '\n' echo "        :" echo "client@c.cc | QWEasd123" echo "admin@a.aa | QWEasd123" echo "moderator@m.mm | QWEasd123" echo -en '\n' echo "------------------------------------------------------------------------------" echo -en '\n' echo -en '\n' echo 'OtezVikentiy brain corporation!' echo -en '\n' echo -en '\n'</span></span></code> </pre><br>  <i>Exemplo de</i> script <i>Php-fpm-command.sh</i> <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env bash cd "`dirname \"$0\"`" &amp;&amp; \ docker-compose exec -T "php-fpm" sh -c "cd /app &amp;&amp; $*"</span></span></code> </pre><br>  <i>Exemplo de</i> script <i>Connect-to-php-fpm.sh</i> <br><br><pre> <code class="bash hljs"><span class="hljs-meta"><span class="hljs-meta">#!/usr/bin/env bash docker exec -i -t --privileged php-fpm bash</span></span></code> </pre><br>  O ambiente de desenvolvimento local termina aqui.  Parabéns, você pode compartilhar o resultado final com seus colegas!  ) <br><br><h2>  Produtivo </h2><br><h3>  Preparação </h3><br>  Suponha que você já tenha escrito algo em uma LAN e queira colocá-lo em um servidor de produção ou em um servidor de teste.  Você tem hospedagem na virtualização KVM ou no seu servidor na próxima sala com ar condicionado. <br><br>  Para implantar um produto ou beta - o servidor deve ter um sistema operacional (idealmente linux) e docker instalado.  O Docker pode ser instalado da mesma maneira que na LAN, não há diferenças. <br><br>  O Docker em produtividade é um pouco diferente da LAN.  Em primeiro lugar, você não pode simplesmente pegar e especificar senhas e outras informações e compor o docker.  Em segundo lugar, você não pode usar o docker-compose diretamente. <br><br>  O Docker usa enxame de encaixe e pilha de encaixe para produtividade.  Se estiver correto, esse sistema difere apenas em outros comandos e nesse enxame de encaixe é um balanceador de carga para o cluster (novamente um pouco abstrato, mas será mais fácil de entender). <br><br>  PS: Eu recomendo que você pratique a configuração do docker swarm no Vagrant (por mais paradoxal que isso possa parecer).  Uma receita simples para treinamento - escolha um Vagrant vazio com o mesmo sistema operacional do produto e configure-o para iniciar. <br><br>  Para configurar o docker swarm, basta executar alguns comandos: <br><br><pre> <code class="bash hljs">docker swarm init --advertise-addr 192.168.***.** (ip-  ) mkdir /app (          app) chown docker /app (     ) docker stack deploy -c docker-compose.yml my-first-sf4-docker-app</code> </pre><br>  Agora, consideramos tudo isso com mais detalhes. <br><br>  <b>docker swarm init --advertise-addr</b> - inicia o docker swarm diretamente e atrapalha um link para que você possa conectar outro servidor a esse "swarm" para que eles funcionem no cluster. <br>  <b>mkdir / app &amp;&amp; chown ..</b> - você deve criar todos os diretórios necessários para que a janela de encaixe trabalhe com antecedência, para que durante a compilação não se queixe da falta de diretórios. <br>  <b>pilha do docker deploy -c docker-compose.yml my-first-sf4-docker-app</b> - este comando inicia a montagem do seu próprio aplicativo, um análogo do docker-compose up -d apenas para o enxame do docker. <br><br>  Para iniciar qualquer montagem, você precisa do mesmo docker-compose.yaml, mas ele já foi ligeiramente modificado especificamente para produtivo / beta. <br><br><pre> <code class="hljs powershell">version: <span class="hljs-string"><span class="hljs-string">'3.1'</span></span> services: php<span class="hljs-literal"><span class="hljs-literal">-fpm</span></span>: image: otezvikentiy/php7.<span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-literal"><span class="hljs-literal">-fpm</span></span>:<span class="hljs-number"><span class="hljs-number">0.0</span></span>.<span class="hljs-number"><span class="hljs-number">11</span></span> ports: - <span class="hljs-string"><span class="hljs-string">'9000:9000'</span></span> networks: - my<span class="hljs-literal"><span class="hljs-literal">-test</span></span><span class="hljs-literal"><span class="hljs-literal">-network</span></span> depends_on: - postgres - rabbitmq volumes: - /app:/app working_dir: /app deploy: replicas: <span class="hljs-number"><span class="hljs-number">1</span></span> restart_policy: condition: on<span class="hljs-literal"><span class="hljs-literal">-failure</span></span> placement: constraints: [<span class="hljs-type"><span class="hljs-type">node.role</span></span> == <span class="hljs-type"><span class="hljs-type">manager</span></span>] nginx: image: nginx:<span class="hljs-number"><span class="hljs-number">1.15</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> networks: - my<span class="hljs-literal"><span class="hljs-literal">-test</span></span><span class="hljs-literal"><span class="hljs-literal">-network</span></span> working_dir: /app ports: - <span class="hljs-string"><span class="hljs-string">'80:80'</span></span> depends_on: - php<span class="hljs-literal"><span class="hljs-literal">-fpm</span></span> volumes: - /app:/app - ./nginx/nginx.conf:/etc/nginx/conf.d/default.conf deploy: replicas: <span class="hljs-number"><span class="hljs-number">1</span></span> restart_policy: condition: on<span class="hljs-literal"><span class="hljs-literal">-failure</span></span> placement: constraints: [<span class="hljs-type"><span class="hljs-type">node.role</span></span> == <span class="hljs-type"><span class="hljs-type">manager</span></span>] postgres: image: postgres:<span class="hljs-number"><span class="hljs-number">9.6</span></span> ports: - <span class="hljs-string"><span class="hljs-string">'5432:5432'</span></span> working_dir: /app networks: - my<span class="hljs-literal"><span class="hljs-literal">-test</span></span><span class="hljs-literal"><span class="hljs-literal">-network</span></span> secrets: - postgres_db - postgres_user - postgres_pass environment: POSTGRES_DB_FILE: /run/secrets/postgres_db POSTGRES_USER_FILE: /run/secrets/postgres_user POSTGRES_PASSWORD_FILE: /run/secrets/postgres_pass volumes: - ./<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>/dump:/app/dump - ./<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>/postgresql:/var/lib/postgresql/<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> deploy: replicas: <span class="hljs-number"><span class="hljs-number">1</span></span> restart_policy: condition: on<span class="hljs-literal"><span class="hljs-literal">-failure</span></span> placement: constraints: [<span class="hljs-type"><span class="hljs-type">node.role</span></span> == <span class="hljs-type"><span class="hljs-type">manager</span></span>] rabbitmq: image: rabbitmq:<span class="hljs-number"><span class="hljs-number">3.7</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span><span class="hljs-literal"><span class="hljs-literal">-management</span></span> networks: - my<span class="hljs-literal"><span class="hljs-literal">-test</span></span><span class="hljs-literal"><span class="hljs-literal">-network</span></span> working_dir: /app hostname: my<span class="hljs-literal"><span class="hljs-literal">-test</span></span><span class="hljs-literal"><span class="hljs-literal">-sf4</span></span><span class="hljs-literal"><span class="hljs-literal">-app</span></span><span class="hljs-literal"><span class="hljs-literal">-rabbit</span></span><span class="hljs-literal"><span class="hljs-literal">-mq</span></span> volumes: - /app:/app ports: - <span class="hljs-string"><span class="hljs-string">'5672:5672'</span></span> - <span class="hljs-string"><span class="hljs-string">'15672:15672'</span></span> secrets: - rabbitmq_default_user - rabbitmq_default_pass - rabbitmq_default_vhost environment: RABBITMQ_DEFAULT_USER_FILE: /run/secrets/rabbitmq_default_user RABBITMQ_DEFAULT_PASS_FILE: /run/secrets/rabbitmq_default_pass RABBITMQ_DEFAULT_VHOST_FILE: /run/secrets/rabbitmq_default_vhost deploy: replicas: <span class="hljs-number"><span class="hljs-number">1</span></span> restart_policy: condition: on<span class="hljs-literal"><span class="hljs-literal">-failure</span></span> placement: constraints: [<span class="hljs-type"><span class="hljs-type">node.role</span></span> == <span class="hljs-type"><span class="hljs-type">manager</span></span>] elasticsearch: image: docker.elastic.co/elasticsearch/elasticsearch:<span class="hljs-number"><span class="hljs-number">6.3</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> networks: - my<span class="hljs-literal"><span class="hljs-literal">-test</span></span><span class="hljs-literal"><span class="hljs-literal">-network</span></span> depends_on: - postgres environment: - discovery.type=single<span class="hljs-literal"><span class="hljs-literal">-node</span></span> - discovery.zen.ping.unicast.hosts=elasticsearch - bootstrap.memory_lock=true - ES_JAVA_OPTS=<span class="hljs-literal"><span class="hljs-literal">-Xms512m</span></span> <span class="hljs-literal"><span class="hljs-literal">-Xmx512m</span></span> ports: - <span class="hljs-number"><span class="hljs-number">9200</span></span>:<span class="hljs-number"><span class="hljs-number">9200</span></span> - <span class="hljs-number"><span class="hljs-number">9300</span></span>:<span class="hljs-number"><span class="hljs-number">9300</span></span> working_dir: /app volumes: - /app:/app - ./<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>/elasticsearch:/usr/share/elasticsearch/<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> deploy: replicas: <span class="hljs-number"><span class="hljs-number">1</span></span> restart_policy: condition: on<span class="hljs-literal"><span class="hljs-literal">-failure</span></span> placement: constraints: [<span class="hljs-type"><span class="hljs-type">node.role</span></span> == <span class="hljs-type"><span class="hljs-type">manager</span></span>] jenkins: image: otezvikentiy/jenkins:<span class="hljs-number"><span class="hljs-number">0.0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span> networks: - my<span class="hljs-literal"><span class="hljs-literal">-test</span></span><span class="hljs-literal"><span class="hljs-literal">-network</span></span> ports: - <span class="hljs-string"><span class="hljs-string">'8080:8080'</span></span> - <span class="hljs-string"><span class="hljs-string">'50000:50000'</span></span> volumes: - /app:/app - ./<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>/jenkins:/var/jenkins_home - /var/run/docker.sock:/var/run/docker.sock - /usr/bin/docker:/usr/bin/docker deploy: replicas: <span class="hljs-number"><span class="hljs-number">1</span></span> restart_policy: condition: on<span class="hljs-literal"><span class="hljs-literal">-failure</span></span> placement: constraints: [<span class="hljs-type"><span class="hljs-type">node.role</span></span> == <span class="hljs-type"><span class="hljs-type">manager</span></span>] volumes: elasticsearch: postgresql: jenkins: networks: my<span class="hljs-literal"><span class="hljs-literal">-test</span></span><span class="hljs-literal"><span class="hljs-literal">-network</span></span>: secrets: rabbitmq_default_user: file: ./secrets/rabbitmq_default_user rabbitmq_default_pass: file: ./secrets/rabbitmq_default_pass rabbitmq_default_vhost: file: ./secrets/rabbitmq_default_vhost postgres_db: file: ./secrets/postgres_db postgres_user: file: ./secrets/postgres_user postgres_pass: file: ./secrets/postgres_pass</code> </pre><br>  Como você pode ver, o arquivo de configurações do produto é um pouco diferente do arquivo da LAN.  Ele adicionou segredos, implantações e redes. <br><br>  <b>segredos</b> - arquivos para armazenar chaves.  As chaves são criadas de maneira bastante simples.  Você cria um arquivo com o nome da chave - escreva o valor dentro.  Depois disso, em docker-compose.yml, você especifica a seção segredos e transfere toda a lista de arquivos com chaves.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mais detalhes</a> . <br>  <b>redes</b> - isso cria uma certa grade interna através da qual os contêineres se comunicam.  Na LAN - isso é feito automaticamente, mas no produtivo - isso precisa ser feito manualmente.  Além disso, você pode especificar configurações adicionais, exceto as padrão.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mais detalhes</a> . <br>  <b>deploy</b> é a principal diferença entre LAN e Product / Beta. <br><br><pre> <code class="hljs powershell"> deploy: replicas: <span class="hljs-number"><span class="hljs-number">1</span></span> restart_policy: condition: on<span class="hljs-literal"><span class="hljs-literal">-failure</span></span> placement: constraints: [<span class="hljs-type"><span class="hljs-type">node.role</span></span> == <span class="hljs-type"><span class="hljs-type">manager</span></span>]</code> </pre><br>  Conjunto mínimo de lutadores: <br><br>  <b>réplicas</b> - indica o número de réplicas que você precisa executar (na verdade, isso é usado se você tiver um cluster e usar o balanceador de carga da janela de encaixe).  Por exemplo, você tem dois servidores e os conectou através do enxame de encaixe.  Especificando o número 2 aqui, por exemplo, 1 instância será criada em 1 servidor e a segunda no segundo servidor.  Assim, a carga no servidor será dividida pela metade. <br>  <b>restart_policy</b> - a política de "aumentar novamente" automaticamente o contêiner, caso ele caia por algum motivo. <br>  <b>canal</b> - o local da instância do contêiner.  Por exemplo, há momentos em que você deseja que todas as instâncias de um contêiner girem em apenas 1 de 5 servidores e não sejam distribuídas entre eles. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Eu quero ler a documentação!</a> <br><br>  Portanto, aprimoramos um pouco o que distingue o docker-compose.yaml para LAN da versão do produto / beta.  Agora vamos tentar administrar esse negócio. <br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suponha que você esteja treinando no Vagrant e na raiz do servidor você já tenha o arquivo configurado para o produto docker-compose.yml</font></font></i> <br><br><pre> <code class="bash hljs">sudo apt-get update sudo apt-get -y upgrade sudo apt-get install -y language-pack-en-base <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> LC_ALL=en_US.UTF-8 <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> LANGUAGE=en_US.UTF-8 <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> LANG=en_US.UTF-8 curl -sSl https://get.docker.com/ | sh sudo usermod -aG docker ubuntu sudo apt-get install git sudo docker swarm init --advertise-addr 192.168.128.77 sudo mkdir /app sudo chmod 777 /app -R docker stack deploy -c /docker-compose.yml my-app git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> git@bitbucket.org:JohnDoe/my-app.git /app docker stack ps my-app docker stack ls docker stack services my-app</code> </pre><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> não opte pelo sudo e pelo 777, é claro que não vale a pena fazê-lo no produtivo. </font><font style="vertical-align: inherit;">Isso é apenas para aprender velocidade. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portanto, estamos mais interessados ​​nas linhas associadas à janela de encaixe. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeiro, inicializamos o "enxame" (docker swarm). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em seguida, criamos os diretórios necessários para o trabalho. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Faça o download do nabo com o nosso código SF4 no diretório / app. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois disso, existem três comandos: ps, ls e serviços. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cada um deles é útil à sua maneira. </font><font style="vertical-align: inherit;">Uso ps com mais frequência, pois exibe o status dos contêineres e parte do erro, se houver.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Digamos que os contêineres tenham aumentado, mas alguns deles travam constantemente com um erro e, na pilha docker ps my-app, você vê várias reinicializações. </font><font style="vertical-align: inherit;">Para ver o motivo da queda, você precisa executar o container docker ps -a - e um container aparecerá que cai constantemente. </font><font style="vertical-align: inherit;">Haverá muitas instâncias do mesmo contêiner, por exemplo my-app_php-fpm.1. * Algum hash feroz *. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portanto, agora, sabendo o nome do contêiner, execute os logs do docker my-app_php-fpm.1. * Algum hash feroz * e examine os logs. </font><font style="vertical-align: inherit;">Corrija o erro e reinicie TUDO. </font><font style="vertical-align: inherit;">Para bater todos os contêineres, você pode fazer isso:</font></font><br><br><pre> <code class="bash hljs">docker stack rm my-app</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois disso, você terá um enxame limpo sem recipientes. </font><font style="vertical-align: inherit;">Corrija o erro - e novamente a pilha do docker implemente -c docker-compose.yml my-app.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt420673/">https://habr.com/ru/post/pt420673/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt420663/index.html">Métricas simples e uma maneira de economizar tempo ao procurar problemas na infraestrutura</a></li>
<li><a href="../pt420665/index.html">Criando um aplicativo no .NET Core e Kubernetes: Nossa experiência</a></li>
<li><a href="../pt420667/index.html">Princípios de operação do protocolo EIGRP</a></li>
<li><a href="../pt420669/index.html">Visão Geral do Mercado de Automação Corporativa: Soluções para Empresas de Construção e Gerenciamento de Habitações e Utilidades</a></li>
<li><a href="../pt420671/index.html">[Ekaterinburg, anúncio] UralJS # 9 - três relatórios sobre microsserviços, testes e registro de erros na frente</a></li>
<li><a href="../pt420675/index.html">SOC são pessoas. “Olá, estamos procurando talentos” ou de onde vêm os analistas do centro de monitoramento e resposta a ataques cibernéticos</a></li>
<li><a href="../pt420677/index.html">A história de como a Epson forneceu ao planeta 30 milhões de "fábricas"</a></li>
<li><a href="../pt420679/index.html">Novos cursos em Python do Mail.Ru Group</a></li>
<li><a href="../pt420681/index.html">AMD ThreadRipper 2: Primeira Introdução</a></li>
<li><a href="../pt420685/index.html">Corrija e neutralize: como domamos a prata. Uma palavra sobre bactericidas para a água</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>