<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ‚ÄçüöÄ ü•å üßïüèø Gesti√≥n de la memoria o, con menos frecuencia, dispararse en el pie ‚è¨ üôÜ üçô</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! En este art√≠culo tratar√© de decir qu√© gesti√≥n de memoria en programas / aplicaciones es desde el punto de vista de un programador de aplica...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gesti√≥n de la memoria o, con menos frecuencia, dispararse en el pie</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473294/"><p>  Hola Habr!  En este art√≠culo tratar√© de decir qu√© gesti√≥n de memoria en programas / aplicaciones es desde el punto de vista de un programador de aplicaciones.  Esta no es una gu√≠a o manual exhaustivo, sino simplemente una descripci√≥n general de los problemas existentes y algunos enfoques para resolverlos. </p><br><p>  ¬øPor qu√© es esto necesario?  Un programa es una secuencia de instrucciones de procesamiento de datos (en el caso m√°s general).  Estos datos <strong>deben almacenarse</strong> , <strong>cargarse</strong> , <strong>transferirse</strong> , etc. de alguna manera.  Todas estas operaciones no ocurren instant√°neamente, por lo tanto, afectan directamente la velocidad de su aplicaci√≥n final.  La capacidad de administrar de manera √≥ptima los datos en el proceso de trabajo le permitir√° crear programas muy triviales y que requieren muchos recursos. </p><br><p>  Nota: la mayor parte del material se presenta con ejemplos de juegos / motores de juegos (ya que este tema es m√°s interesante para m√≠ personalmente), sin embargo, la mayor parte del material se puede aplicar a servidores de escritura, aplicaciones de usuario, paquetes de gr√°ficos, etc. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f13/ef3/482/f13ef3482dfe066b41b53e44179a0242.jpg"></p><br><p>  <em>Es imposible tener todo en mente.</em>  <em>Pero si no lograste cargarlo, obtendr√°s jab√≥n</em> </p><a name="habracut"></a><br><h1 id="s-mesta-v-karer">  De buenas a primeras </h1><br><p>  Sucedi√≥ en la industria que los grandes proyectos de juegos AAA se desarrollan principalmente en motores escritos con C ++.  Una de las caracter√≠sticas de este lenguaje es la necesidad de una gesti√≥n manual de la memoria.  Java / C # etc.  Cuentan con recolecci√≥n de basura (GarbageCollection / GC): la capacidad de crear objetos y a√∫n no liberar la memoria usada a mano.  Este proceso simplifica y acelera el desarrollo, pero tambi√©n puede causar algunos problemas: un recolector de basura activado peri√≥dicamente puede matar todo el tiempo blando en tiempo real y agregar congelaciones desagradables al juego. </p><br><p>  S√≠, en proyectos como "Minecraft", el GC puede no ser notable, ya que  generalmente no exigen los recursos de la computadora, pero los juegos como "Red Dead Redemption 2", "God of War", "Last of Us" funcionan "casi" en la cima del rendimiento del sistema y, por lo tanto, no solo necesitan grandes la cantidad de recursos, pero tambi√©n en su distribuci√≥n competente. </p><br><p>  Adem√°s, al trabajar en un entorno con asignaci√≥n autom√°tica de memoria y recolecci√≥n de basura, puede encontrar una falta de flexibilidad en la administraci√≥n de recursos.  No es ning√∫n secreto que Java oculta todos los detalles de implementaci√≥n y aspectos de su trabajo, por lo que en la salida solo tiene la interfaz instalada para interactuar con los recursos del sistema, pero puede que no sea suficiente para resolver algunos problemas.  Por ejemplo, iniciar un algoritmo con un n√∫mero no constante de asignaciones de memoria en cada cuadro (esto puede ser una b√∫squeda de rutas para AI, verificar la visibilidad, la animaci√≥n, etc.) inevitablemente conduce a una ca√≠da catastr√≥fica en el rendimiento. </p><br><h1 id="kak-vyglyadyat-allokacii-v-kode">  C√≥mo se ven las asignaciones en el c√≥digo </h1><br><p>  Antes de continuar la discusi√≥n, me gustar√≠a mostrar c√≥mo el trabajo con memoria en C / C ++ ocurre directamente con un par de ejemplos.  En general, la interfaz est√°ndar y m√°s simple para asignar memoria de proceso est√° representada por las siguientes operaciones: </p><br><pre><code class="plaintext hljs">//        size  void* malloc(size_t size); //      p void free(void* p);</code> </pre> <br><p>  Aqu√≠ puede agregar funciones adicionales que le permiten asignar una pieza de memoria alineada: </p><br><pre> <code class="plaintext hljs">// C11  -     , * alignment void* aligned_alloc(size_t size, size_t alignment); // Posix  -       //        address (*address = allocated_mem_p) int posix_memalign(void** address, size_t alignment, size_t size);</code> </pre> <br><p>  Tenga en cuenta que las diferentes plataformas pueden admitir diferentes est√°ndares de funci√≥n, disponibles por ejemplo en macOS y no disponibles en win. </p><br><p>  Mirando hacia el futuro, pueden ser necesarias √°reas de memoria <strong>especialmente</strong> alineadas para que pueda acceder a la l√≠nea de cach√© del procesador y para realizar c√°lculos utilizando un conjunto extendido de registros ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SSE</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MMX</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AVX</a> , etc.). </p><br><p>  Un ejemplo de un programa de juguete que asigna memoria e imprime valores de b√∫fer, interpret√°ndolos como enteros con signo: </p><br><pre> <code class="plaintext hljs">/* main.cpp */ #include &lt;cstdio&gt; #include &lt;cstdlib&gt; int main(int argc, char** argv) { const int N = 10; int* buffer = (int*) malloc(sizeof(int) * N); for(int i = 0; i &lt; N; i++) { printf("%i ", buffer[i]); } free(buffer); return 0; }</code> </pre> <br><p>  En macOS 10.14, este programa se puede construir y ejecutar con el siguiente conjunto de comandos: </p><br><pre> <code class="plaintext hljs">$ clang++ main.cpp -o main $ ./main</code> </pre> <br><p>  Nota: en adelante no quiero cubrir las operaciones de C ++ como new / delete, ya que es m√°s probable que se usen para construir / destruir objetos directamente, pero usan las operaciones habituales con memoria como malloc / free. </p><br><h1 id="problemy-s-pamyatyu">  Problemas de memoria </h1><br><p>  Existen varios problemas que surgen cuando se trabaja con la RAM de la computadora.  Todos ellos, de una forma u otra, son causados ‚Äã‚Äãno solo por las caracter√≠sticas del sistema operativo y el software, sino tambi√©n por la arquitectura del hierro en el que funciona todo esto. </p><br><h3 id="1-kolichestvo-pamyati">  1. Cantidad de memoria </h3><br><p>  Desafortunadamente, la memoria es f√≠sicamente limitada.  En PlayStation 4, esto es 8 GiB GDDR5, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.5 GiB de los cuales el sistema operativo se reserva para sus necesidades</a> .  La memoria virtual y el intercambio de p√°ginas no ayudar√°n mucho, ya que el intercambio de p√°ginas en el disco es una operaci√≥n muy lenta (dentro de N marcos fijos por segundo, si hablamos de juegos). </p><br><p>  Tambi√©n vale la pena se√±alar el limitado " <em>presupuesto</em> ": alguna limitaci√≥n artificial en la cantidad de memoria utilizada, creada para ejecutar la aplicaci√≥n en varias plataformas.  Si est√° creando un juego para una plataforma m√≥vil y desea admitir no solo uno, sino tambi√©n una l√≠nea completa de dispositivos, tendr√° que limitar su apetito en aras de proporcionar un mercado de ventas m√°s amplio.  Esto se puede lograr simplemente limitando el consumo de RAM y la capacidad de configurar esta restricci√≥n seg√∫n el dispositivo en el que se inicia realmente el juego. </p><br><h3 id="2-fragmentaciya">  2. Fragmentaci√≥n </h3><br><p>  Un efecto desagradable que aparece durante el proceso de asignaciones m√∫ltiples de piezas de memoria de varios tama√±os.  Como resultado, obtienes un espacio de direcciones fragmentado en muchas partes separadas.  La combinaci√≥n de estas partes en bloques individuales de mayor tama√±o no funcionar√°, ya que parte de la memoria est√° ocupada y no podemos moverla libremente. </p><br><p><img src="https://habrastorage.org/webt/8f/un/ie/8funiekbmroqz6xqhdpsyrpovcs.png"><br>  Fragmentaci√≥n por el ejemplo de asignaciones secuenciales y lanzamientos de bloques de memoria </p><br><p>  Como resultado: podemos tener suficiente memoria libre cuantitativamente, pero no cualitativamente.  Y la siguiente solicitud, por ejemplo, "asignar espacio para la pista de audio", el asignador no podr√° satisfacer, porque simplemente no hay una sola pieza de memoria de este tama√±o. </p><br><h3 id="3-kesh-processora">  3. cach√© de la CPU </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e9d/592/5e5/e9d5925e5a0fc9629656ead20ce91b36.png"><br>  Jerarqu√≠a de memoria de la computadora </p><br><p>  El cach√© de un procesador moderno es un enlace intermedio que conecta la memoria principal (RAM) y el procesador se registra directamente.  Sucedi√≥ que el acceso de lectura / escritura a la memoria es una operaci√≥n muy lenta (si hablamos de la cantidad de ciclos de reloj de la CPU necesarios para ejecutar).  Por lo tanto, existe cierta jerarqu√≠a de cach√© (L1, L2, L3, etc.), que permite, por as√≠ decirlo, "seg√∫n algunas predicciones", cargar datos desde la RAM o introducirlos lentamente en una memoria m√°s lenta. </p><br><p>  Colocar objetos del mismo tipo en una fila en la memoria le permite acelerar "significativamente" el proceso de procesamiento (si el procesamiento se produce secuencialmente), ya que en este caso es m√°s f√°cil predecir qu√© datos se necesitar√°n a continuaci√≥n.  Y por "significativo" se entiende ganancias de productividad a veces.  Los desarrolladores del motor de Unity han hablado repetidamente sobre esto en sus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">informes en el GDC</a> . </p><br><h3 id="4-multi-threading">  4. Multihilo </h3><br><p>  <strong>Garantizar el acceso seguro a la memoria compartida en un entorno de subprocesos m√∫ltiples</strong> es uno de los principales problemas que tendr√° que resolver al crear su propio motor de juego / juego / cualquier otra aplicaci√≥n que use m√∫ltiples hilos para lograr un mayor rendimiento.  Las computadoras modernas est√°n dispuestas de una manera muy no trivial.  Tenemos una estructura de cach√© compleja y varios n√∫cleos de calculadora.  Todo esto, si se usa incorrectamente, puede conducir a situaciones en las que los datos compartidos de su proceso se da√±ar√°n como resultado de varios subprocesos (si intentan trabajar simult√°neamente con estos datos sin control de acceso).  En el caso m√°s simple, se ver√° as√≠: <br><img src="https://habrastorage.org/webt/sl/dm/2y/sldm2ybotnk9ncozwf5rkgozifw.png"><br>  No quiero profundizar en el tema de la programaci√≥n multiproceso, ya que muchos de sus aspectos van mucho m√°s all√° del alcance del art√≠culo o incluso de todo el libro. </p><br><h3 id="5-mallocfree">  5. Malloc / gratis </h3><br><p>  Las operaciones de asignaci√≥n / liberaci√≥n no ocurren instant√°neamente.  En los sistemas operativos modernos, si hablamos de Windows / Linux / MacOS, se implementan bien y funcionan <em>r√°pidamente en la mayor√≠a de las situaciones</em> .  Pero potencialmente esta es una operaci√≥n que consume mucho tiempo.  No solo se trata de una llamada al sistema, sino que, dependiendo de la implementaci√≥n, puede llevar un tiempo encontrar una memoria adecuada (primer ajuste, mejor ajuste, etc.) o encontrar un lugar para insertar y / o fusionar el √°rea liberada. </p><br><p>  Adem√°s, es posible que la memoria reci√©n asignada no se asigne realmente a p√°ginas f√≠sicas reales, lo que tambi√©n puede llevar alg√∫n tiempo en el primer acceso. </p><br><p>  Estos son detalles de implementaci√≥n, pero ¬øqu√© pasa con la aplicabilidad?  Malloc / new no tiene idea de d√≥nde, c√≥mo o por qu√© los llamaste.  Asignan memoria (en el peor de los casos) de 1 KiB y 100 MiB por igual ... igualmente malo.  Directamente, la estrategia de uso se deja al programador o al que implement√≥ el tiempo de ejecuci√≥n de su programa. </p><br><h3 id="6-memory-corruption">  6. corrupci√≥n de la memoria </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Como dice la wiki</a> , este es uno de los errores m√°s impredecibles que aparece solo durante el curso del programa, y ‚Äã‚Äãcon mayor frecuencia es causado directamente por errores en la redacci√≥n de este programa.  ¬øPero cu√°l es este problema?  Afortunadamente (o desafortunadamente), no est√° relacionado con la corrupci√≥n de su computadora.  M√°s bien, muestra una situaci√≥n en la que est√° intentando trabajar con memoria que <em>no le pertenece</em> .  Explicar√© ahora: </p><br><ol><li>  Esto puede ser un intento de leer / escribir en una parte de la memoria no asignada. </li><li>  Ir m√°s all√° de los l√≠mites del bloque de memoria que se le proporcion√≥.  Este problema es un tipo de caso especial del problema (1), pero es peor porque el sistema le dir√° que super√≥ los l√≠mites solo cuando deja la p√°gina mostrada.  Es decir, potencialmente, este problema es muy dif√≠cil de detectar, porque el sistema operativo solo puede responder si deja los l√≠mites de las p√°ginas virtuales que se le muestran.  Puede estropear la memoria del proceso y obtener un error muy extra√±o del lugar desde el que no se esperaba en absoluto. </li><li>  Liberar una memoria ya liberada (suena extra√±o) o a√∫n no asignada </li><li>  etc. </li></ol><br><p>  En C / C ++, donde hay aritm√©tica de puntero, te encontrar√°s con esto una o dos veces.  Sin embargo, en Java Runtime, tienes que esforzarte bastante para obtener este tipo de error (no lo he intentado yo mismo, pero creo que esto es posible, de lo contrario la vida ser√≠a demasiado simple). </p><br><h3 id="7-utechki-pamyati">  7. Fugas de memoria </h3><br><p>  Es un caso especial de un problema m√°s general que ocurre en muchos lenguajes de programaci√≥n.  La biblioteca est√°ndar de C / C ++ proporciona acceso a los recursos del sistema operativo.  Pueden ser archivos, sockets, memoria, etc.  Despu√©s de su uso, el recurso debe estar correctamente cerrado y <br>  el recuerdo ocupado por √©l deber√≠a ser liberado.  Y si hablamos espec√≠ficamente sobre la liberaci√≥n de memoria, las fugas acumuladas como resultado del programa pueden provocar un error de "falta de memoria" cuando el sistema operativo no podr√° satisfacer la pr√≥xima solicitud de asignaci√≥n.  A menudo, el desarrollador simplemente olvida liberar la memoria usada por una raz√≥n u otra. </p><br><p>  Aqu√≠ vale la pena agregar sobre el cierre correcto y la liberaci√≥n de recursos en la GPU, porque los primeros controladores no permitieron continuar trabajando con la tarjeta de video si la sesi√≥n anterior no se complet√≥ correctamente.  Solo reiniciar el sistema podr√≠a resolver este problema, lo cual es muy dudoso: obligar al usuario a reiniciar el sistema despu√©s de ejecutar su aplicaci√≥n. </p><br><h3 id="8-dangling-pointer">  8. Puntero colgando </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong>Un puntero colgante</strong></a> es una jerga que describe una situaci√≥n en la que un puntero se refiere a un valor no v√°lido.  Una situaci√≥n similar puede surgir f√°cilmente cuando se utilizan punteros cl√°sicos de estilo C en un programa C / C ++.  Suponga que asign√≥ memoria, guard√≥ la direcci√≥n en el puntero p y luego liber√≥ la memoria (vea el ejemplo de c√≥digo): </p><br><pre> <code class="plaintext hljs">//   void* p = malloc(size); // ...  -    //   free(p); //    p? // *p == ?</code> </pre> <br><p>  El puntero almacena alg√∫n valor, que podemos interpretar como la direcci√≥n del bloque de memoria.  Sucedi√≥ que no podemos decir si este bloque de memoria es v√°lido o no.  Solo un programador, basado en ciertos acuerdos, puede operar con un puntero.  Comenzando con C ++ 11, se introdujeron una serie de punteros adicionales de "punteros inteligentes" en la biblioteca est√°ndar, que permiten de alguna manera debilitar el control de recursos por parte del programador mediante el uso de metainformaci√≥n adicional dentro de ellos (m√°s sobre esto m√°s adelante). </p><br><p>  Como soluci√≥n parcial, puede usar el <em>valor especial del</em> puntero, que nos indicar√° que no hay nada en esta direcci√≥n.  En C, la macro NULL se usa como el valor de este valor, y en C ++, se usa la palabra clave del lenguaje nullptr.  La soluci√≥n es parcial porque: </p><br><ol><li>  El valor del puntero debe establecerse manualmente, por lo que el programador simplemente puede olvidarse de hacerlo. </li><li>  nullptr o solo 0x0 se incluye en el conjunto de valores aceptados por el puntero, lo que no es bueno cuando el estado especial de un objeto se expresa a trav√©s de su estado habitual.  Este es alg√∫n tipo de legado y, por acuerdo, el sistema operativo no le asignar√° un trozo de memoria cuya direcci√≥n comience con 0x0. </li></ol><br><p>  C√≥digo de muestra con nulo: </p><br><pre> <code class="plaintext hljs">//  -  p free(p); p = nullptr; //   p == nullptr   ,       </code> </pre> <br><p>  Puede automatizar este proceso hasta cierto punto: </p><br><pre> <code class="plaintext hljs">void _free(void* &amp;p) { free(p); p = nullptr; } //  -  p _free(p); //   p == nullptr,     //   </code> </pre> <br><h3 id="9-tip-pamyati">  9. Tipo de memoria </h3><br><p>  <strong>RAM</strong> es una memoria de acceso aleatorio de prop√≥sito general com√∫n, cuyo acceso a trav√©s del bus central tiene todos los n√∫cleos de su procesador y dispositivos perif√©ricos.  Su volumen var√≠a, pero a menudo estamos hablando de N gigabytes, donde N es 1,2,4,8,16 y as√≠ sucesivamente.  Las llamadas malloc / free buscan colocar el bloque de memoria que desea en la RAM de la computadora. </p><br><p>  <strong>VRAM</strong> (memoria de video): memoria de video, suministrada con la tarjeta de video / acelerador de video de su PC.  Como regla, es m√°s peque√±o que la RAM (aproximadamente 1.2.4 GiB), pero tiene una alta velocidad.  La distribuci√≥n de este tipo de memoria es manejada por el controlador de la tarjeta de video, y la mayor√≠a de las veces no tiene acceso directo a ella. </p><br><p>  No existe tal separaci√≥n en la PlayStation 4, y toda la RAM est√° representada por un solo 8 gigabytes en GDDR5.  Por lo tanto, todos los datos para el procesador y el acelerador de video est√°n cerca. </p><br><p>  La buena gesti√≥n de recursos en el motor del juego incluye una asignaci√≥n de memoria competente tanto en la RAM principal como en el lado VRAM.  Aqu√≠ puede encontrar <strong>duplicaci√≥n</strong> cuando los mismos datos est√°n all√≠ o all√≠, o con <strong>una transferencia excesiva de</strong> datos de RAM a VRAM y viceversa. </p><br><p>  <strong>Como ilustraci√≥n de todos los problemas expresados</strong> : puede ver los aspectos de las computadoras del dispositivo en el ejemplo de la arquitectura PlayStation 4 (Fig.).  Aqu√≠ est√° el procesador central, 8 n√∫cleos, cach√©s de nivel L1 y L2, buses de datos, RAM, acelerador de gr√°ficos, etc.  Para obtener una descripci√≥n completa y detallada, consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Game Engine Architecture" de</a> Jason Gregory. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c50/7ba/756/c507ba75624a3c9be702f85ddfa50e11.png"><br>  Arquitectura de PlayStation 4 </p><br><h1 id="obschie-podhody-k-resheniyu">  Enfoques generales </h1><br><p>  No hay una soluci√≥n universal.  Pero hay un conjunto de algunos puntos en los que debe enfocarse si va a implementar la asignaci√≥n manual y la administraci√≥n de memoria en su aplicaci√≥n.  Esto incluye contenedores y asignadores especializados, estrategias de asignaci√≥n de memoria, dise√±o de sistemas / juegos, administradores de recursos y m√°s. </p><br><h2 id="tipy-allokatorov">  Tipos de asignadores </h2><br><p>  El uso de asignadores de memoria especiales se basa en la siguiente idea: usted sabe qu√© tama√±o, en qu√© momentos de trabajo y en qu√© lugar necesitar√° piezas de memoria.  Por lo tanto, puede asignar la memoria necesaria, estructurarla de alguna manera y usarla / reutilizarla.  Esta es la idea / concepto general de usar asignadores especiales.  Lo que son (por supuesto, no todos) se puede ver m√°s all√°: </p><br><ol><li><p>  <strong>Asignador lineal</strong> <br>  Representa un b√∫fer de espacio de direcciones contiguo.  En el curso del trabajo, le permite asignar secciones de memoria de tama√±o arbitrario (de modo que quepan en un b√∫fer).  Pero puede liberar toda la memoria asignada solo 1 vez.  Es decir, una pieza arbitraria de memoria no se puede liberar: permanecer√° como <em>ocupada</em> hasta que todo el b√∫fer se marque como limpio.  Este dise√±o proporciona la asignaci√≥n y liberaci√≥n de O (1), lo que garantiza una velocidad bajo cualquier condici√≥n. <br><img src="https://habrastorage.org/webt/eb/tp/vm/ebtpvmrs616uwpgdfpd1nujw69s.png"><br>  Caso de uso t√≠pico: en el proceso de actualizaci√≥n del estado del proceso (cada cuadro en el juego) puede usar LinearAllocator para asignar buffers tmp para cualquier necesidad t√©cnica: procesamiento de entrada, trabajo con cadenas, an√°lisis de comandos de ConsoleManager en modo de depuraci√≥n, etc. </p><br></li><li><p>  <strong>Asignador de pila</strong> <br>  Modificaci√≥n de un asignador lineal.  Le permite liberar memoria en el orden inverso de asignaci√≥n, en otras palabras, se comporta como una pila normal de acuerdo con el principio LIFO.  Puede ser muy √∫til para realizar c√°lculos matem√°ticos cargados (jerarqu√≠a de transformaciones), para implementar el trabajo del subsistema de secuencias de comandos, para cualquier c√°lculo en el que se conozca de antemano el procedimiento indicado para liberar memoria. <br><img src="https://habrastorage.org/webt/hu/7j/fm/hu7jfm6iqhxz0uk5xwo_ayzwyfo.png"><br>  La simplicidad del dise√±o proporciona O (1) asignaci√≥n de memoria y velocidad de liberaci√≥n. </p><br></li><li><p>  <strong>Asignador de piscina</strong> <br>  Le permite asignar bloques de memoria del mismo tama√±o.  Se puede implementar como un b√∫fer de espacio de direcciones continuo, dividido en bloques de un tama√±o predeterminado.  Estos bloques pueden formar una lista vinculada.  Y siempre sabemos qu√© bloque dar en la pr√≥xima asignaci√≥n.  Esta metainformaci√≥n puede almacenarse en los propios bloques, lo que impone una restricci√≥n en el tama√±o m√≠nimo del bloque (sizeof (void *)).  En realidad, esto no es cr√≠tico. <br><img src="https://habrastorage.org/webt/cv/sl/qz/cvslqzmqj1nsp-gtqccoyx6hwy4.png"><br>  Dado que todos los bloques son del mismo tama√±o, no nos importa qu√© bloque devolver, y por lo tanto, todas las operaciones de asignaci√≥n / desasignaci√≥n se pueden realizar en O (1). </p><br></li><li><p>  <strong>Asignador de cuadros</strong> <br>  Asignador lineal pero solo con referencia al marco actual: le permite hacer la asignaci√≥n de memoria tmp y luego liberar autom√°ticamente todo al cambiar el marco.  Debe destacarse por separado, ya que esta es una entidad global y √∫nica dentro del marco del juego de tiempo de ejecuci√≥n, y por lo tanto, puede estar hecha de un tama√±o muy impresionante, digamos un par de docenas de MiB, que ser√°n muy √∫tiles al cargar recursos y procesarlos. </p><br></li><li><p>  <strong>Asignador de doble marco</strong> <br>  Es un asignador de doble marco, pero con algunas caracter√≠sticas.  Le permite asignar memoria en el marco actual y usarla tanto en el marco actual como en el siguiente.  Es decir, la memoria que asign√≥ en el cuadro N se liberar√° solo despu√©s del cuadro N + 1.  Esto se realiza cambiando el cuadro activo para resaltar al final de cada cuadro. <br><img src="https://habrastorage.org/webt/ug/cc/zh/ugcczhvv6ibzbarvb0plwhvgbuu.png"><br>  Pero este tipo de asignador, como el anterior, impone una serie de restricciones en la vida √∫til de los objetos creados en la memoria asignada a √©l.  Por lo tanto, debe tener en cuenta que al final del marco, los datos simplemente se vuelven inv√°lidos y el acceso repetido a ellos puede causar serios problemas. </p><br></li><li><p>  <strong>Asignador est√°tico</strong> <br>  Este tipo de asignador asigna memoria de un b√∫fer, obtenido, por ejemplo, en la etapa de inicio del programa, o capturado en la pila en un marco de funci√≥n.  Por tipo, puede ser absolutamente cualquier asignador: lineal, pool, stack.  ¬øPor qu√© se llama <em>est√°tica</em> ?  El tama√±o del b√∫fer de memoria capturado debe conocerse <strong>en la etapa de compilaci√≥n del</strong> programa.  Esto impone una limitaci√≥n significativa: la cantidad de memoria disponible para este asignador no se puede cambiar durante la operaci√≥n.  ¬øPero cu√°les son los beneficios?  El b√∫fer utilizado se capturar√° autom√°ticamente y luego se liberar√° (al finalizar el trabajo o al salir de la funci√≥n).  Esto no carga el mont√≥n, lo salva de la fragmentaci√≥n, le permite asignar r√°pidamente la memoria en su lugar. <br>  Puede ver el ejemplo del c√≥digo con este asignador, si necesita dividir la cadena en subcadenas y hacer algo con ellas: <br><img src="https://habrastorage.org/webt/3s/xk/t5/3sxkt5_00ztji1gesnh0cd1edno.png"><br>  Tambi√©n se puede notar que el uso de memoria de la pila en teor√≠a es mucho m√°s eficiente, porque  apilar el marco de la funci√≥n actual con una alta probabilidad ya estar√° en el cach√© del procesador. </p><br></li></ol><br><p>  Todos estos asignadores de alguna manera resuelven los problemas de fragmentaci√≥n, con falta de memoria, con la velocidad de recepci√≥n y liberaci√≥n de bloques del tama√±o requerido, con la vida √∫til de los objetos y la memoria que ocupan. </p><br><p>  Tambi√©n se debe tener en cuenta que el enfoque correcto para el dise√±o de la interfaz le permitir√° crear una especie de <em>jerarqu√≠a de</em> asignadores cuando, por ejemplo: el grupo asigna memoria de la asignaci√≥n de cuadros, y la asignaci√≥n de cuadros a su vez asigna memoria de la asignaci√≥n lineal.  Se puede continuar una estructura similar, adapt√°ndose a sus tareas y necesidades. </p><br><p><img src="https://habrastorage.org/webt/rf/l8/4a/rfl84aakccaw2qfdw6hxlqiygos.png"></p><br><p>  Veo una interfaz similar para crear jerarqu√≠as de la siguiente manera: </p><br><pre> <code class="plaintext hljs">class IAllocator { public: virtual void* alloc(size_t size) = 0; virtual void* alloc(size_t size, size_t alignment) = 0; virtual void free (void* &amp;p) = 0; }</code> </pre> <br><p>          malloc/free ,     .  ,        ,            .           /    ,       . </p><br><h2 id="umnye-ukazateli">   </h2><br><p> Smart pointer ‚Äî        C++   ++11 (   boost,    ).   -,     ,        -  ,        .                . </p><br><p>       ?     : </p><br><ol><li>       </li><li>   (/) </li><li>    </li></ol><br><p>         : </p><br><ol><li><p> <strong>Unique pointer</strong> <br>      1    ( ). <br>   unique pointer ,          .        , ..    1   / . <br>        uniquePtr1  uniquePtr2,    uniquePtr1 , .   1  . <br><img src="https://habrastorage.org/webt/xl/qd/x2/xlqdx2thnzcg7rvvv0va70zpzl4.png"></p><br></li><li><p> <strong>Shared pointer</strong> <br>        (reference counting).       ,    ,      .    , ,      ,    . <br><img src="https://habrastorage.org/webt/jb/y6/wi/jby6wipfn5sv2ghabpuzzresgsk.png"><br>       . -,       ,      .        . -,  -                . </p><br></li><li><p> <strong>Weak pointer</strong> <br>    .       ,    .  ¬øQu√© significa esto?           shared pointer.   ,   shared pointer  ,     . ,     shared pointer weak pointer.  ,   (shared)    ,   weak pointer    shared pointer.    ‚Äî  weak pointer ,     ,  ,       . <br><img src="https://habrastorage.org/webt/nr/bt/bq/nrbtbqg6rukrcdgmij-v08bpim4.png"><br>   shared,   weak pointer     meta-data   .    -   ,     ..   ,  O(N) overhead  ,  N ‚Äî -  .      , .               ,        .         . </p><br></li></ol><br><p>     :         . ,  shared pointer,     ,    (      )  <em>- - -</em> .           .            meta-info   ,  ,           .  Un ejemplo: </p><br><pre> <code class="plaintext hljs">/*     */ /*   ,  shared pointer */ Array&lt;TSharedPtr&lt;Object&gt;&gt; objects; objects.add(newShared&lt;Object&gt;(...)); ... objects.add(newShared&lt;Object&gt;(...));</code> </pre> <br><pre> <code class="plaintext hljs">/*      (   meta-info    ) */ Array&lt;Object&gt; objects; objects.emplace(...); ... objects.emplace(...);</code> </pre> <br><p>   .            .  Sobre esto m√°s all√°. </p><br><h2 id="unique-id"> Unique id </h2><br><p>      ,    .     (id/identificator),   , ,   -.    : </p><br><ol><li> <strong> </strong> <br>     ,   id.    ,   <strong>  </strong> ,  ,          id. </li><li> <strong>  </strong> <br>      ,          (  ,     ) </li><li> <strong>    </strong> <br>    id  ,      ,        id. </li><li> <strong>    </strong> <br>                 . ,   id,     . </li></ol><br><p>     :    id,   ,      id,         . </p><br><p>  id     ,  (Vulkan, OpenGL),   (Godot, CryEngine).  EntityID   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">     CryEngine</a> . </p><br><p>   ,  id   :   .     ,     (   ),     ,      . </p><br><pre> <code class="plaintext hljs">/*    */ class ID { uint32 index; uint32 generation; }</code> </pre> <br><pre> <code class="plaintext hljs">/*  - /  */ class ObjectManager { public: ID create(...); void destroy(ID); void update(ID id, ...); private: Array&lt;uint32&gt; generations; Array&lt;Objects&gt; objects; }</code> </pre> <br><p>   ID        ,     ID .     : </p><br><pre> <code class="plaintext hljs">generation = generations[id.index]; if (generation == id.generation) then /*    */ else /*  ,     */</code> </pre> <br><p>      id      generation  1   id   ids. </p><br><h2 id="konteynery">  </h2><br><p>     C++   ,         .      std,     <strong></strong>   ,   <strong></strong>    .        : </p><br><ul><li> Linked list ‚Äî   </li><li> Array ‚Äî /  </li><li> Queue ‚Äî  </li><li> Stack ‚Äî  </li><li> Map ‚Äî   </li><li> Set ‚Äî  </li></ul><br><p>         ?             memory corruption.        / ,    ,   ,    ,     . </p><br><h1 id="obschie-idei">   </h1><br><p>           ,     ,       .  , ,    /         . </p><br><h2 id="pod-konkretnye-zadachi">    </h2><br><p>   ,      ,       .              ,   (  )   .    ,   malloc/free  ,       ,            . </p><br><p>     ?   ,     (/ ),     ,     ,   .    ,     ,    ,           . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/554/778/95b/55477895bb7e2fcf71d44ad06ceb8ce3.jpg"><br> ryEngine Sandbox:       </p><br><p>   ,   Unreal, Unity, CryEngine  .,     ,    . ,       , ,     ‚Äî       ,                 . </p><br><h2 id="pre-allocating"> Pre-allocating </h2><br><p>        ,      /          . </p><br><p>    :   malloc/free      .     ,      "run out of memory", .        .         ,       (,   ,     .). </p><br><p>       .          .  ,         -  .           ,           malloc/free,    : ,  ,  . </p><br><h2 id="ne-nado-boyatsya-dinamicheskoy-pamyati">      </h2><br><p>            .   :     ,       , ,   ..             . </p><br><p>    :   ,      ,       ,    .  open-source ,      ,     .   ,  ,   ‚Äî     malloc/free. </p><br><h2 id="dizayn-iz-ogranicheniy">    </h2><br><p>  GDC  CD Project Red <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  </a> ,     ,       "The Witcher: Blood and Wine"    ()        .     ,     ,    ,         ,         . <br><img src="https://habrastorage.org/getpro/habr/post_images/80b/c6c/fb0/80bc6cfb08009ba02caee322cb092110.png"></p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">   </a>    Naughty Dog  ,      "Uncharted 4: A Thief's End"     ,         (,    )       . <br><img src="https://habrastorage.org/getpro/habr/post_images/7c4/2c8/469/7c42c84690c9374423bba12dea6126ff.jpg"></p><br><h1 id="zaklyuchenie">  Conclusi√≥n </h1><br><p>     ,    ,     ,          .       ,         .     / ,     ,   -   ..       ,        (,    ). </p><br><h1 id="literatura-i-poleznye-ssylki">     </h1><br><ul><li>         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Game Engine Architecture"</a> .           ,  , , ,   ..  ,    ,      . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Custom memory allocators</a> ‚Äî        ,     C++  .     ,         . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Smart pointers</a> ‚Äî     ,      . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Start Pre-allocating And Stop Worrying</a> ‚Äî        </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/473294/">https://habr.com/ru/post/473294/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../473284/index.html">Senior, TechLead, Architect: ¬øqu√© sigue? ¬øC√≥mo lidiar con una rutina de trabajo y d√≥nde seguir?</a></li>
<li><a href="../473286/index.html">Escribimos protecci√≥n contra ataques DDoS en XDP. Parte nuclear</a></li>
<li><a href="../473288/index.html">Cree su c√≥digo desde cero, aumentar√° su nivel</a></li>
<li><a href="../473290/index.html">Julia ¬øD√≥nde comenzar el proyecto? ...</a></li>
<li><a href="../473292/index.html">El resumen de materiales interesantes para el desarrollador m√≥vil # 319 (del 21 al 27 de octubre)</a></li>
<li><a href="../473296/index.html">Arranque sin dinero. Experiencia personal</a></li>
<li><a href="../473298/index.html">C√≥mo construir procesos y dejar de burlarse de un equipo</a></li>
<li><a href="../473300/index.html">Relaciones p√∫blicas en la era digital, programas modernos de fidelizaci√≥n y marketing de festivales.</a></li>
<li><a href="../473302/index.html">Adi√≥s HTML, Hola QML</a></li>
<li><a href="../473306/index.html">Concepto de gafas de realidad aumentada. Mi auricular AR perfecto, que es posible</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>