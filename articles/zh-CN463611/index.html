<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>◾️ ⛺️ 🍝 神奇的插件，卷。 2.练习 ⛴️ ✍🏻 ✊🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在这里，您可以阅读有关插件工程理论的第一篇文章。 


 在这一部分中，我将告诉您在创建插件期间遇到了哪些问题以及我们如何解决这些问题。 

 我要说什么 


- 实践部分 多页用户界面 插件中的DI 代码生成 代码修改 
- 多页用户界面 
- 插件中的DI 
- 代码生成 
- 代码修改 
-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>神奇的插件，卷。 2.练习</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/hh/blog/463611/"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里，</a>您可以阅读有关插件工程理论的第一篇文章。 </p><br><p> 在这一部分中，我将告诉您在创建插件期间遇到了哪些问题以及我们如何解决这些问题。 <br><img src="https://habrastorage.org/webt/db/cn/c-/dbcnc-m5gfz68a0hpvnt2qjdcgw.png" alt="图片"></p><a name="habracut"></a><br><h1 id="o-chem-budu-govorit"> 我要说什么 </h1><br><ul><li> 实践部分 <br><ul><li> 多页用户界面 </li><li> 插件中的DI </li><li> 代码生成 </li><li> 代码修改 </li></ul></li><li> 接下来要做什么？ <br><ul><li> 小费 </li><li> 常见问题 </li></ul></li></ul><br><h2 id="mnogostranichnyy-ui"> 多页用户界面 </h2><br><p> 我们需要做的第一件事是创建一个多页面的UI。 我们使用了许多复选标记和输入字段来制作了第一个复杂表格。 过了一会儿，我们决定增加选择用户可以连接到新模块的模块列表的功能。 我们还希望选择计划将创建的模块连接到的应用程序模块。 </p><br><p> 在一种表单上拥有如此多的控件不是很方便，因此他们制作了三个单独的页面，三个单独的小甜饼切割器。 简而言之，向导对话框。 </p><br><p><img src="https://habrastorage.org/webt/hd/jw/wf/hdjwwfojlb6w7gj_sacdswi802g.png" alt="图片"></p><br><p> 但是由于在插件中制作多页UI非常痛苦，所以我想找一些准备好的东西。 在IDEA的肠道中，我们发现了一个名为<em>WizardDialog</em>的类。 </p><br><p><img src="https://habrastorage.org/webt/tl/gr/6z/tlgr6ztp3yro6-yyyqyhjsd55ky.png" alt="图片"></p><br><p> 这是常规对话框上的包装器类，可独立监视向导中用户的进度，并显示必要的按钮（上一个，下一个，完成等）。 特殊的<em>WizardModel</em>附加到<em>WizardDialog</em> ，并向其中添加了各个WizardSteps。 每个<em>WizardStep</em>都是单独的表单。 </p><br><p> 对话的最简单形式如下： </p><br><div class="spoiler">  <b class="spoiler_title">巫师对话</b> <div class="spoiler_text"><pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyWizardDialog</span></span></span></span>( model: MyWizardModel, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> onFinishButtonClickedListener: (MyWizardModel) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> ): WizardDialog&lt;MyWizardModel&gt;(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, model) { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onWizardGoalAchieved</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onWizardGoalAchieved() onFinishButtonClickedListener.invoke(myModel) } }</code> </pre> </div></div><br><p>  <em>我们将从WizardDialog</em>类<em>继承</em> ，并使用<em>WizardModel的</em>类进行参数<em>化</em> 。 此类具有特殊的回调（ <em>onWizardGoalAchieved</em> ），它告诉我们用户已通过向导结束并单击“完成”按钮。 <br> 重要的是要注意，在此类中，有机会仅访问<em>WizardModel</em> 。 这意味着在向导通过期间用户将收集的所有数据，必须添加到<em>WizardModel中</em> 。 </p><br><div class="spoiler">  <b class="spoiler_title">向导模型</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyWizardModel</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">WizardModel</span></span></span></span>(<span class="hljs-string"><span class="hljs-string">"Title for my wizard"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.add(MyWizardStep1()) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.add(MyWizardStep2()) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.add(MyWizardStep3()) } }</code> </pre> </div></div><br><p> 该模型如下所示：我们从<em>WizardModel</em>类继承，并使用内置的<em>add</em>方法<em>将</em>单独的<em>WizardSteps</em> <em>添加</em>到对话框。 </p><br><div class="spoiler">  <b class="spoiler_title">向导步骤</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyWizardStep1</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">WizardStep</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyWizardModel</span></span></span><span class="hljs-class">&gt;</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contentPanel: JPanel <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(state: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">WizardNavigationState</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span>: JComponent { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> contentPanel } }</code> </pre> </div></div><br><p>  <em>WizardSteps</em>也很简单：我们从<em>WizardStep</em>类继承，使用我们的模型类对其进行参数化，最重要的是，重新定义prepare方法，该方法返回您将来表单的根组件。 </p><br><p> 简单来说，它看起来确实像这样。 但是在现实世界中，您的表单很可能类似于以下内容： </p><br><p><img src="https://habrastorage.org/webt/as/6d/mc/as6dmcznqssdt7zwhdz7ndebuv8.png" alt="图片"></p><br><p> 在这里，您可以回想起那些我们在Android世界中还不知道什么是Clean Architecture，MVP并在一个Activity中编写所有代码的时代。 架构之战有了新的领域，如果您想弄糊涂，可以为插件实现自己的架构。 </p><br><h3 id="vyvod"> 结论 </h3><br><p> 如果您需要多页UI，请使用<em>WizardDialog-</em>这样会更容易。 </p><br><p> 我们进入下一个主题-插件中的DI。 </p><br><h2 id="di-v-plaginah"> 插件中的DI </h2><br><p> 为什么可能需要在插件内部进行依赖注入？ <br> 第一个原因是插件内部架构的组织。 </p><br><p> 看起来，为什么通常在插件内部观察某种架构？ 插件是一种实用程序，一旦我写了，就是这样，我忘记了。 <br> 是的，但是没有。 <br> 当您的插件增长时，当您编写大量代码时，结构化代码的问题就自动出现了。  DI在这里可能会派上用场。 </p><br><p> 第二个更重要的原因-在DI的帮助下，您可以找到由其他插件的开发人员编写的组件。 它可以是事件总线，记录器等等。 </p><br><p> 尽管您可以自由使用任何DI框架（例如Spring，Dagger等），但在IntelliJ IDEA中还是有您自己的DI框架，它基于前三个抽象级别，我已经在上面提到过： <em>Application</em> ， <em>Project</em>和<em>Module</em> 。 </p><br><p><img src="https://habrastorage.org/webt/ix/kh/dk/ixkhdkerqkc0sapkdvgj5qsg_44.png" alt="图片"></p><br><p> 每个级别都有其自己的抽象，称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>Component</em></a> 。 根据该级别的对象的实例创建所需级别的组件。 因此，为<em>Application</em>类的每个实例创建一次<em>ApplicationComponent</em> ，类似于<em>Project</em>实例的<em>ProjectComponent</em> ，依此类推。 </p><br><p> 使用DI框架需要做什么？ </p><br><p> 首先，创建一个实现我们需要的接口组件之一的类-例如，一个实现<em>ApplicationComponent</em>或<em>ProjectComponent</em>或<em>ModuleComponent的类</em> 。 同时，我们有机会注入要实现其接口的级别的对象。 也就是说，例如，您可以在<em>ProjectComponent</em>中注入<em>Project</em>类的对象。 </p><br><div class="spoiler">  <b class="spoiler_title">创建组件类</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyAppComponent</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> application: Application, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> anotherApplicationComponent: AnotherAppComponent ): ApplicationComponent <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyProjectComponent</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> project: Project, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> anotherProjectComponent: AnotherProjectComponent, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> myAppComponent: MyAppComponent ): ProjectComponent <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyModuleComponent</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> module: Module, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> anotherModuleComponent: AnotherModuleComponent, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> myProjectComponent: MyProjectComponent, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> myAppComponent: MyAppComponent ): ModuleComponent</code> </pre> </div></div><br><p> 其次，可以注入相同或更高级别的其他组件。 也就是说，例如，您可以在<em>ProjectComponent</em>中注入其他<em>ProjectComponent</em>或<em>ApplicationComponent</em> 。 在这里您可以访问“外来”组件的实例。 </p><br><p> 同时，IDEA保证将正确地组装整个依赖图，所有对象都将以正确的顺序创建并正确初始化。 </p><br><p> 下一步是在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>plugin.xml</em></a>文件中注册组件。 一旦实现了Component接口之一（例如<em>ApplicationComponent</em> ），IDEA将立即提供将您的组件注册在plugin.xml中的功能。 </p><br><div class="spoiler">  <b class="spoiler_title">在plugin.xml中注册组件</b> <div class="spoiler_text"><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">idea-plugin</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">project-components</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">component</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">interface-class</span></span></span><span class="hljs-tag">&gt;</span></span> com.experiment.MyProjectComponent <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">interface-class</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">implementation-class</span></span></span><span class="hljs-tag">&gt;</span></span> com.experiments.MyProjectComponentImpl <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">implementation-class</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">component</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">project-components</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">idea-plugin</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> </div></div><br><p> 怎么做？ 出现一个特殊的<em>&lt;project-component&gt;</em>标记（ <em>&lt;application-component&gt;</em> ， <em>&lt;module-component&gt;</em> -取决于级别）。 它内部有一个标签<em>，其中还有两个标签： <em>&lt;interface-class&gt;</em> （表示组件的接口名称）和<em>&lt;implementation-class&gt;</em> （表示实现类）。</em>  <em>一个类可以是组件的接口，也可以是其实现，因此可以使用单个<em>&lt;implementation-class&gt;标签</em> 。</em> <br></p><p> 最后要做的是从相应的对象中获取组件，即，我们从<em>Application</em>实例中获取<em>ApplicationComponent</em> ，从<em>Project中</em>获取<em>ProjectComponent</em> ，等等。 </p><br><div class="spoiler">  <b class="spoiler_title">获取组件</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> myAppComponent = application.getComponent(MyAppComponent::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">myProjectComponent</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">project</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">getComponent</span></span></span></span>(MyProjectComponent::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">myModuleComponent</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">module</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">getComponent</span></span></span></span>(MyModuleComponent::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">)</span></span></code> </pre> </div></div><br><h3 id="vyvody"> 结论 </h3><br><ol><li>  IDEA中有一个DI框架-无需自己拖任何东西：Dagger和Spring都没有。 当然可以。 </li><li> 使用此DI，您可以获取完成的组件，这就是果汁本身。 </li></ol><br><p> 让我们继续第三个任务-代码生成。 </p><br><h2 id="generaciya-koda"> 代码生成 </h2><br><p> 还记得吗，在清单中，我们有生成大量文件的任务？ 每次创建新模块时，我们都会创建一堆文件：交互器，演示者，片段。 创建新模块时，这些组件彼此非常相似，我想学习如何自动生成此框架。 </p><br><h3 id="shablony"> 模式 </h3><br><p> 生成大量相似代码的最简单方法是什么？ 使用模式。 首先，您需要查看模板并了解对代码生成器提出了哪些要求。 </p><br><div class="spoiler">  <b class="spoiler_title">一块build.gradle文件模板</b> <div class="spoiler_text"><pre> <code class="java hljs">apply plugin: <span class="hljs-string"><span class="hljs-string">'com.android.library'</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isKotlinProject) { apply plugin: <span class="hljs-string"><span class="hljs-string">'kotlin-android'</span></span> apply plugin: <span class="hljs-string"><span class="hljs-string">'kotlin-kapt'</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isModuleWithUI) { apply plugin: <span class="hljs-string"><span class="hljs-string">'kotlin-android-extensions'</span></span> }&gt; }&gt; ... android { ... &lt;<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isMoxyEnabled) { kapt { arguments { arg(<span class="hljs-string"><span class="hljs-string">"moxyReflectorPackage"</span></span>, <span class="hljs-string"><span class="hljs-string">'&lt;include var="packageName"&gt;'</span></span>) } } }&gt; ... } ... dependencies { <span class="hljs-function"><span class="hljs-function">compileOnly </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">project</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">':common'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> compileOnly </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">project</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">':core-utils'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> &lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(moduleName in enabledModules)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">compileOnly </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">project</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'&lt;include var="moduleName"&gt;'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> }&gt; ... }</span></span></code> </pre> </div></div><br><p> 首先：我们希望能够在这些模式中使用条件。 我举一个例子：如果插件以某种方式与UI连接，我们想连接特殊的Gradle-plugin <em>kotlin-android-extensions</em> 。 </p><br><div class="spoiler">  <b class="spoiler_title">模板中的条件</b> <div class="spoiler_text"><pre> <code class="java hljs">&lt;<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isKotlinProject) { apply plugin: <span class="hljs-string"><span class="hljs-string">'kotlin-android'</span></span> apply plugin: <span class="hljs-string"><span class="hljs-string">'kotlin-kapt'</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isModuleWithUI) { apply plugin: <span class="hljs-string"><span class="hljs-string">'kotlin-android-extensions'</span></span> }&gt; }&gt;</code> </pre> </div></div><br><p> 我们想要的第二件事是能够在此模板内使用变量。 例如，当我们为Moxy配置kapt时，我们想将包名称作为注释处理器的参数插入。 </p><br><div class="spoiler">  <b class="spoiler_title">在模板中替换变量的值</b> <div class="spoiler_text"><pre> <code class="java hljs">kapt { arguments { arg(<span class="hljs-string"><span class="hljs-string">"moxyReflectorPackage"</span></span>, <span class="hljs-string"><span class="hljs-string">'&lt;include var="packageName"&gt;'</span></span>) } }</code> </pre> </div></div><br><p> 我们需要的另一件事是能够处理模板内的循环。 还记得我们在表格中选择了要连接到正在创建的新模块的模块列表吗？ 我们想循环处理它们并添加同一行。 </p><br><div class="spoiler">  <b class="spoiler_title">使用模板中的循环。</b> <div class="spoiler_text"><pre> <code class="java hljs">&lt;<span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (moduleName in enabledModules) { <span class="hljs-function"><span class="hljs-function">compileOnly </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">project</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'&lt;include var="moduleName"&gt;'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> }&gt;</span></span></code> </pre> </div></div><br><p> 因此，我们为代码生成器提出了三个条件： </p><br><ul><li> 我们要使用条件 </li><li> 替代变量值的能力 </li><li> 我们需要模式循环 </li></ul><br><h3 id="generatory-koda"> 代码生成器 </h3><br><p> 有哪些实现代码生成器的选项？ 例如，您可以编写自己的代码生成器。 例如，Uber的人就是这样做的：他们编写了自己的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">插件来生成Riblet</a> （所谓的建筑单元）。 他们提出了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">自己的模板语言</a> ，他们只使用了插入变量的能力。 他们使条件达到<a href="">了发电机</a>的<a href="">水平</a> 。 但是我们认为我们不会那样做。 </p><br><p> 第二种选择是使用IDEA中内置的FileTemplateManager实用工具类，但我不建议这样做。 因为他具有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Velocity</a>作为引擎，所以在将Java对象转发到模板方面存在一些问题。 此外， <em>FileTemplateManager</em>无法从框中生成Java或XML以外的文件。 我们需要生成Groovy文件，Kotlin，Proguard和其他类型的文件。 </p><br><p> 第三个选项是... <em>FreeMarker</em> 。 如果您有现成的<em>FreeMarker</em>模板，请不要着急丢弃它们-它们在插件内对您很有用。 </p><br><p> 需要做什么，如何在插件中使用<em>FreeMarker</em> ？ 首先，添加文件模板。 您可以在<em>/ resources</em>文件夹内创建<em>/ templates</em>文件夹，并在其中添加所有文件的所有模板-演示者，片段等。 </p><br><p><img src="https://habrastorage.org/webt/gk/ww/fe/gkwwfelyl443hdze6vd6a99ecmw.png" alt="图片"></p><br><p> 之后，您将需要在FreeMarker库上添加一个依赖项。 由于该插件使用Gradle，因此添加依赖项非常简单。 </p><br><div class="spoiler">  <b class="spoiler_title">在FreeMarker库上添加依赖项</b> <div class="spoiler_text"><pre> <code class="java hljs">dependencies { ... compile <span class="hljs-string"><span class="hljs-string">'org.freemarker:freemarker:2.3.28'</span></span> }</code> </pre> </div></div><br><p> 之后，在我们的插件中配置FreeMarker。 我建议您在此简单复制此配置-受其折磨，受苦，复制它，一切正常。 </p><br><div class="spoiler">  <b class="spoiler_title">FreeMarker配置</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TemplatesFactory</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> project: Project) : ProjectComponent { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> freeMarkerConfig <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> lazy { Configuration(Configuration.VERSION_2_3_28).apply { setClassForTemplateLoading( TemplatesFactory::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">"/templates" ) defaultEncoding = Charsets.UTF_8.name</span></span></span></span>() templateExceptionHandler = TemplateExceptionHandler.RETHROW_HANDLER logTemplateExceptions = <span class="hljs-literal"><span class="hljs-literal">false</span></span> wrapUncheckedExceptions = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } } ...</code> </pre> </div></div><br><p> 现在该使用<em>FreeMarker</em>创建文件了。 为此，我们从配置中按名称获取模板，并使用常规<em>FileWriter</em>在磁盘上直接创建具有所需文本的文件。 </p><br><div class="spoiler">  <b class="spoiler_title">通过FileWriter创建文件</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TemplatesFactory</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> project: Project) : ProjectComponent { ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( pathToFile: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, templateFileName: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">data</span></span></span></span><span class="hljs-function"><span class="hljs-params">: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Map</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Any&gt; )</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> template = freeMarkerConfig.getTemplate(templateFileName) FileWriter(pathToFile, <span class="hljs-literal"><span class="hljs-literal">false</span></span>).use { writer -&gt; template.process(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>, writer) } } }</code> </pre> </div></div><br><p> 任务似乎已经解决，但是没有。 在理论部分，我提到整个IDEA都渗透了PSI结构，因此必须予以考虑。 如果您绕过PSI结构创建文件（例如，通过FileWriter），则IDEA根本不会理解您已创建了文件，因此不会在项目树中显示文件。 我们等了大约7分钟，然后IDEA索引了，然后看到了创建的文件。 </p><br><p> 结论-考虑PSI的结构，正确执行操作，创建文件。 </p><br><h3 id="sozdaem-psi-strukturu-dlya-faylov"> 为文件创建PSI结构 </h3><br><p> 首先， <a href="">让我们看一下</a>使用<a href="">PsiDirectory的</a>文件夹结构。 可以使用扩展功能<em>guessProjectDir</em>和<em>toPsiDirectory</em>获得项目的开始目录： </p><br><div class="spoiler">  <b class="spoiler_title">获取PsiDirectory项目</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> projectPsiDirectory = project.guessProjectDir()?.toPsiDirectory(project)</code> </pre> </div></div><br><p> 后续目录可以使用<em>PsiDirectory</em> <em>findSubdirectory</em>类方法找到，也可以使用<em>createSubdirectory</em>方法创建。 </p><br><div class="spoiler">  <b class="spoiler_title">查找并创建PsiDirectory</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> coreModuleDir = projectPsiDirectory.findSubdirectory(<span class="hljs-string"><span class="hljs-string">"core"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> newModulePsiDir = coreModuleDir.createSubdirectory(config.mainParams.moduleName)</code> </pre> </div></div><br><p> 我还建议您创建一个<em>Map</em> ，使用字符串键从中获取所有<em>PsiDirectory</em>文件夹结构，然后将创建的文件添加到这些文件夹中的任何一个。 </p><br><div class="spoiler">  <b class="spoiler_title">创建文件夹结构图</b> <div class="spoiler_text"><p> 返回mutableMapOf &lt;String，PsiDirectory？&gt;（）。套用{ <br> 这个[“ root”] = modulePsiDir <br> 这个[“ src”] = modulePsiDir.createSubdirectory（“ src”） <br>  this [“ main”] = this [“ src”]？。createSubdirectory（“ main”） <br>  this [“ java”] = this [“ main”]？。createSubdirectory（“ java”） <br>  this [“ res”] = this [“ main”]？。createSubdirectory（“ res”） </p><br><pre> <code class="plaintext hljs">//   PsiDirectory   package name: // ru.hh.feature_worknear → ru / hh / feature_worknear createPackageNameFolder(config) // data this["data"] = this["package"]?.createSubdirectory("data") // ...</code> </pre> <br><p>  } </p></div></div><br><p> 文件夹已创建。 我们将使用<a href="">PsiFileFactory</a>创建<a href="">PsiFiles</a> 。 此类具有称为<em>createFileFromText</em>的特殊方法。 该方法接受三个参数作为输入：输出文件的名称（字符串fileName），文本（字符串text）和类型（FileType fileType）。 三个参数中的两个参数清楚地说明了从何处获取它：我们自己知道名称，我们从FreeMarker获得了文本。 在哪里获取<em>FileType</em> ？ 到底是什么呢？ </p><br><h3 id="filetype"> 档案类型 </h3><br><p>  <a href=""><em>FileType</em></a>是一个特殊的类，表示文件的类型。  “框”中只有两个FileType可供我们使用：JavaFileType和XmlFileType，分别用于Java文件和XML文件。 但是问题来了：从哪里获得<em>build.gradle</em>文件， <em>Kotlin</em>文件， <em>Proguard</em> ， <em>.gitignore的类型</em> ，最后呢？ </p><br><p> 首先，大多数这些<em>FileType</em>可以从某人已经编写的其他插件中获取。  GroovyFileType可以从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Groovy插件获取</a> ，KotlinFileType可以从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Kotlin插件获取</a> ，Proguard可以从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Android插件获取</a> 。 </p><br><p> 我们如何将另一个插件的依赖关系添加到我们的插件中？ 我们使用<em>gradle-intellij-plugin</em> 。 它在插件的build.gradle文件中添加了一个特殊的intellij块，该文件中有一个特殊的属性-plugins。 在此属性中，您可以列出我们要依赖的插件标识符列表。 </p><br><div class="spoiler">  <b class="spoiler_title">添加对其他插件的依赖</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// build.gradle  intellij { … plugins = ['android', 'Groovy', 'kotlin'] }</span></span></code> </pre> </div></div><br><p> 我们从官方<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JetBrains插件存储库中</a>获取密钥。 对于内置在IDEA中的插件（Groovy，Kotlin和Android），IDEA中的插件文件夹名称就足够了。 其余的，您需要转到官方JetBrains插件存储库中特定插件的页面，该位置将显示<em>Plugin XML ID</em>属性以及版本（例如，这是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Docker插件</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">页面</a> ）。 阅读有关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在GitHub上</a>连接其他插件的更多信息。 </p><br><p> 其次，您需要在<em>plugin.xml</em>文件中添加一个依赖项描述。 这是使用标记完成的<em>。</em> <br></p><div class="spoiler">  <b class="spoiler_title">我们在plugin.xml中连接插件</b> <div class="spoiler_text"><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">idea-plugin</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">depends</span></span></span><span class="hljs-tag">&gt;</span></span>org.jetbrains.android<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">depends</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">depends</span></span></span><span class="hljs-tag">&gt;</span></span>org.jetbrains.kotlin<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">depends</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">depends</span></span></span><span class="hljs-tag">&gt;</span></span>org.intellij.groovy<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">depends</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">idea-plugin</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> </div></div><br><p> 同步项目后，我们将加强来自其他插件的依赖关系，并能够使用它们。 </p><br><p> 但是，如果我们不想依赖其他插件怎么办？ 在这种情况下，我们可以为所需的文件类型创建一个存根。 为此，首先创建一个将从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>Language</em></a>类继承的类。 我们的编程语言的唯一标识符将传递给此类（在我们的示例中为<strong>“ ru.hh.plugins.Ignore”</strong> ）。 </p><br><div class="spoiler">  <b class="spoiler_title">为GitIgnore文件创建语言</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IgnoreLanguage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">private</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>() : Language(<span class="hljs-string"><span class="hljs-string">"ru.hh.plugins.Ignore"</span></span>, <span class="hljs-string"><span class="hljs-string">"ignore"</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>), InjectableLanguage { <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> INSTANCE = IgnoreLanguage() } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDisplayName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: String { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Ignore() (</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$id</span></span></span><span class="hljs-string">)"</span></span> } }</code> </pre> </div></div><br><p> 这里有一个功能：一些开发人员添加一个非唯一的行作为标识符。 因此，您的插件与其他插件的集成可能会中断。 我们很棒，我们有一条独特的路线。 </p><br><p> 创建<em>Language</em>之后，接下来要做的就是创建<em>FileType</em> 。 我们从<em>LanguageFileType</em>类继承，使用我们定义的语言实例进行初始化，覆盖一些非常简单的方法。 做完了 现在我们可以使用新创建的<em>FileType</em> 。 </p><br><div class="spoiler">  <b class="spoiler_title">为.gitignore创建自己的FileType</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IgnoreFileType</span></span></span></span>(language: Language) : LanguageFileType(language) { <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> INSTANCE = IgnoreFileType(IgnoreLanguage.INSTANCE) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: String = <span class="hljs-string"><span class="hljs-string">"gitignore file"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDescription</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: String = <span class="hljs-string"><span class="hljs-string">"gitignore files"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDefaultExtension</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: String = <span class="hljs-string"><span class="hljs-string">"gitignore"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIcon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Icon? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> }</code> </pre></div></div><br><h3 id="zavershaem-sozdanie-fayla"> 完成创建文件 </h3><br><p> 找到所有必需的<em>FileType之后</em> ，我建议创建一个名为<em>TemplateData</em>的特殊容器-该容器将包含有关要从其生成代码的模板的所有数据。 它将包含模板文件的名称，生成代码后获得的<em>输出</em>文件的名称，所需的<em>FileType</em>以及最后的<em>PsiDirectory</em> ，在其中添加创建的文件。 </p><br><div class="spoiler">  <b class="spoiler_title">模板数据</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TemplateData</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> templateFileName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> outputFileName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> outputFileType: FileType, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> outputFilePsiDirectory: PsiDirectory? )</code> </pre> </div></div><br><p> 然后返回<em>FreeMarker-</em>我们从其中获取模板文件，使用<em>StringWriter</em>获取文本，在<em>PsiFileFactory中</em>生成具有所需文本和类型的<em>PsiFile</em> 。 创建的文件将添加到所需目录。 </p><br><div class="spoiler">  <b class="spoiler_title">在所需的文件夹中创建PsiFile</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createFromTemplate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">data</span></span></span></span><span class="hljs-function"><span class="hljs-params">: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">FileTemplateData</span></span></span></span><span class="hljs-function"><span class="hljs-params">, properties: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Map</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Any&gt;)</span></span></span></span>: PsiFile { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> template = freeMarkerConfig.getTemplate(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.templateFileName) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> text = StringWriter().use { writer -&gt; template.process(properties, writer) writer.buffer.toString() } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> psiFileFactory.createFileFromText(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.outputFileName, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.outputFileType, text) }</code> </pre> </div></div><br><p> 因此，考虑了PSI结构，IDEA和其他插件将看到我们所做的事情。 这样做有好处：例如，如果Git插件发现您已添加了新文件，它将自动显示一个对话框，询问您是否要将这些文件添加到Git？ </p><br><h3 id="vyvody-pro-generaciyu-koda"> 代码生成结论 </h3><br><ul><li> 文本文件可以由FreeMarker生成。 很舒服 </li><li> 生成文件时，您需要考虑PSI结构，否则一切都会出错。 </li><li> 如果要使用PsiFileFactory生成文件，则必须在某处找到FileType。 </li></ul><br><p> 好了，现在我们来看最后一个最实用的部分-这是对代码的修改。 </p><br><h2 id="modifikaciya-koda"> 代码修改 </h2><br><p> 实际上，仅创建用于代码生成的插件是胡说八道，因为您可以使用其他工具和相同的<em>FreeMarker</em>来生成代码。 但是<em>FreeMarker</em>不能做的就是修改代码。 </p><br><p> 我们的清单有几项与修改代码有关的任务，让我们从最简单的一项开始-修改<em>settings.gradle</em>文件。 </p><br><h3 id="modifikaciya-settingsgradle"> 修改settings.gradle </h3><br><p> 让我提醒您我们想要做什么：我们需要在此文件中添加几行内容，以描述新创建的模块的路径： </p><br><div class="spoiler">  <b class="spoiler_title">模块路径说明</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// settings.gradle include ':analytics project(':analytics').projectDir = new File(settingsDir, 'core/framework-metrics/analytics) ... include ':feature-worknear' project(':feature-worknear').projectDir = new File(settingsDir, 'feature/feature-worknear')</span></span></code> </pre> </div></div><br><p> 我稍早吓到您，在处理文件时必须始终考虑PSI结构，否则 <del> 一切都会燃烧 </del> 将无法正常工作。 实际上，在简单的任务中（例如在文件末尾添加几行），可以将其省略。 您可以使用通常的<em>java.io.File</em>将一些行添加到文件中。 为此，我们找到文件的路径，创建<em>java.io.File</em>实例，并在Kotlin <em>扩展</em>功能的帮助下，在此文件的末尾添加两行。 您可以执行此操作，IDEA将看到您的更改。 </p><br><div class="spoiler">  <b class="spoiler_title">在settings.gradle文件中添加行</b> <div class="spoiler_text"><p>  val projectBaseDirPath = project.basePath ?:返回 <br>  val settingsPathFile = projectBaseDirPath +“ /settings.gradle” </p><br><p>  val settingsFile =文件（settingsPathFile） </p><br><p>  settingsFile.appendText（“ include'：$ moduleName'”） <br>  settingsFile.appendText（ <br>  “项目（'：$ moduleName'）。projectDir =新文件（settingsDir，'$ folderPath'）” <br>  ） </p></div></div><br><p> 好吧，理想情况下，当然，通过PSI结构会更好-它更可靠。 </p><br><h3 id="donastroyka-kapt-a-dlya-toothpick">  Kapt调整牙签 </h3><br><p> 我再次提醒您这个问题：在应用程序模块中有一个<em>build.gradle</em>文件，并且在其中有注释处理器的设置。 我们想将我们创建的模块的软件包添加到特定位置。 </p><br><div class="spoiler">  <b class="spoiler_title">在哪里？</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/jt/hv/1b/jthv1bxuiigvexnvwnrvzs41wh8.png" alt="图片"></p></div></div><br><p> 我们的目标是找到一个特定的<em>PsiElement</em> ，然后计划添加我们的线。 对元素的搜索始于对<em>PsiFile</em>的搜索，该文件表示应用程序模块的<em>build.gradle</em>文件。 为此，您需要找到我们将在其中寻找文件的模块。 </p><br><div class="spoiler">  <b class="spoiler_title">我们正在按名称查找模块</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> appModule = ModuleManager.getInstance(project) .modules.toList() .first { it.name == <span class="hljs-string"><span class="hljs-string">"headhunter-applicant"</span></span> }</code> </pre> </div></div><br><p> 接下来，使用实用程序类<em>FilenameIndex，</em>可以通过其名称查找<em>PsiFile</em> ，并将找到的模块指定为搜索区域。 </p><br><div class="spoiler">  <b class="spoiler_title">按名称查找PsiFile</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> buildGradlePsiFile = FilenameIndex.getFilesByName( appModule.project, <span class="hljs-string"><span class="hljs-string">"build.gradle"</span></span>, appModule.moduleContentScope ).first()</code> </pre> </div></div><br><p> 找到PsiFile之后，我们可以开始搜索PsiElement。   ,      – <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PSI Viewer</a> .     IDEA  ,    PSI-  . </p><br><p><img src="https://habrastorage.org/webt/sd/nl/ac/sdnlac9nrqcqqt14wtrhohr9pf8.png" alt="图片"></p><br><p>    -  (, build.gradle)        ,      PSI-   . </p><br><p><img src="https://habrastorage.org/webt/gt/et/xo/gtetxo8_4hbk0gzzfty7p_zmawu.png" alt="图片"></p><br><p>    –   ,        <em>PsiFile</em> -. </p><br><p>    .   <em>PsiFile</em> .            . </p><br><div class="spoiler"> <b class="spoiler_title">  PsiElement</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> toothpickRegistryPsiElement = buildGradlePsiFile.originalFile .collectDescendantsOfType&lt;GrAssignmentExpression&gt;() .firstOrNull { it.text.startsWith(<span class="hljs-string"><span class="hljs-string">"arguments"</span></span>) } ?.lastChild ?.children?.firstOrNull { it.text.startsWith(<span class="hljs-string"><span class="hljs-string">"toothpick_registry_children_package_names"</span></span>) } ?.collectDescendantsOfType&lt;GrListOrMap&gt;() ?.first() ?: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span></code> </pre> </div></div><br><p><del>  ?.. </del>   ?          PSI-.        <em>GrAssignmentExpression</em> ,   ,    <em>arguments = [ … ]</em> .      ,      <em>toothpick_registry_children_package_names = [...]</em> ,       Groovy-. </p><br><p>    <em>PsiElement</em> ,   .            .      . </p><br><p>     PSI- ,       <em>PsiElementFactory</em>   ,    .  Java-?    Java-.   Groovy?  <em>GroovyPsiElementFactory</em> . 依此类推。 </p><br><p>  <em>PsiElementFactory</em>       .       Groovy  Kotlin ,        . </p><br><div class="spoiler"> <b class="spoiler_title"> PsiElement  package name</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> factory = GroovyPsiElementFactory.getInstance(buildGradlePsiFile.project) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> packageName = config.mainParams.packageName <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> newArgumentItem = factory.createStringLiteralForReference(packageName)</code> </pre> </div></div><br><p>         <em>PsiElement</em> . </p><br><div class="spoiler"> <b class="spoiler_title">   Map-</b> <div class="spoiler_text"><pre> <code class="kotlin hljs">targetPsiElement.add(newArgumentItem)</code> </pre> </div></div><br><h3 id="donastroyka-kapt-a-dlya-moxy-v-application-module">  kapt-  Moxy  application  </h3><br><p>    -,    , –  kapt-  Moxy  application .  :          <em>@RegisterMoxyReflectorPackages</em> . </p><br><div class="spoiler"> <b class="spoiler_title">-?</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/us/17/in/us17inlvgteb4k9pmegkurtl7y8.png" alt="图片"></p></div></div><br><p>         ,  :  <em>PsiFile</em> ,  <em>PsiElement</em> ,  …      ,         <em>PsiElement</em> -. </p><br><p>     :  ,    <em>@RegisterMoxyReflectorPackages</em> ,       <em>value</em>  ,          . </p><br><p>    ,       . ,     <em>PsiManager</em> ,   <em>PsiClass</em>  . </p><br><div class="spoiler"> <b class="spoiler_title"> PsiClass  @RegisterMoxyReflectorPackages</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> appModule = ModuleManager.getInstance(project) .modules.toList() .first { it.name == <span class="hljs-string"><span class="hljs-string">"headhunter-applicant"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> psiManager = PsiManager.getInstance(appModule.project) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> annotationPsiClass = ClassUtil.findPsiClass( psiManager, <span class="hljs-string"><span class="hljs-string">"com.arellomobile.mvp.RegisterMoxyReflectorPackages"</span></span> ) ?: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span></code> </pre> </div></div><br><p>     <em>AnnotatedMembersSearch</em>   ,      . </p><br><div class="spoiler"> <b class="spoiler_title"> ,  </b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> annotatedPsiClass = AnnotatedMembersSearch.search( annotationPsiClass, appModule.moduleContentScope ).findAll() ?.firstOrNull() ?: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span></code> </pre> </div></div><br><p>  ,  <em>PsiElement</em>  ,        value.     ,      . </p><br><div class="spoiler"> <b class="spoiler_title">      </b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> annotationPsiElement = (annotatedPsiClass .annotations .first() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> KtLightAnnotationForSourceEntry ).kotlinOrigin <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> packagesPsiElements = annotationPsiElement .collectDescendantsOfType&lt;KtValueArgumentList&gt;() .first() .collectDescendantsOfType&lt;KtValueArgument&gt;() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> updatedPackagesList = packagesPsiElements .mapTo(mutableListOf()) { it.text } .apply { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> += <span class="hljs-string"><span class="hljs-string">"\"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${config.packageName}</span></span></span><span class="hljs-string">\""</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> newAnnotationValue = updatedPackagesList.joinToString(separator = <span class="hljs-string"><span class="hljs-string">",\n"</span></span>)</code> </pre> </div></div><br><p>   <em>KtPsiFactory</em>   <em>PsiElement</em> –          . </p><br><div class="spoiler"> <b class="spoiler_title">      </b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kotlinPsiFactory = KtPsiFactory(project) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> newAnnotationPsiElement = kotlinPsiFactory.createAnnotationEntry( <span class="hljs-string"><span class="hljs-string">"@RegisterMoxyReflectorPackages(\n</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$newAnnotationValue</span></span></span><span class="hljs-string">\n)"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> replaced = annotationPsiElement.replace(newAnnotationPsiElement)</code> </pre> </div></div><br><p>  . </p><br><p>     ?    code style.  ,      IDEA    : CodeStyleManager. </p><br><div class="spoiler"> <b class="spoiler_title"> code style</b> <div class="spoiler_text"><pre> <code class="kotlin hljs">CodeStyleManager.getInstance(module.project).reformat(replacedElement)</code> </pre> </div></div><br><p>    -  ,     . </p><br><h3 id="vyvody-1">  </h3><br><ul><li>     ,      PSI-,      . </li><li> ,  PSI     ,    ,    PsiElement-. </li></ul><br><h1 id="chto-delat-dalshe">   ? </h1><br><p>   . </p><br><ul><li>      –    ,       . </li><li>       .       .   :            . </li><li>     ?      .  , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">   IDEA</a>   ,   .       ,        . —   -  ,    GitHub  .  ,    ,  . </li><li>    -   –    IntelliJ IDEA   .  ,   <em>Util</em>  <em>Manager</em> ,  ,    ,    . </li><li>   :     .  ,  <em>runIde</em> ,     IDEA,   .   ,           hh.ru,       . </li></ul><br><p> 仅此而已。 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">  </a> ,  ,   – . </p><br><h2 id="faq"> 常见问题 </h2><br><ul><li>       ? </li></ul><br><p>       ,       .      ,   2  3 . </p><br><ul><li>       IDEA   ,   -  ? </li></ul><br><p> ,    IDEA   IDEA SDK ,   deprecated,   ,  .   SDK-   ,   ,     . </p><br><ul><li>         ? </li></ul><br><p>    –    gitignore .   -   . </p><br><ul><li>          ? </li></ul><br><p>      Android Studio  Mac OS,    Ubuntu,   . ,     Windows,    . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN463611/">https://habr.com/ru/post/zh-CN463611/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN463599/index.html">“这是一场噩梦”：宇航员就好莱坞在拍摄太空电影时犯的错误分享看法</a></li>
<li><a href="../zh-CN463601/index.html">Java / logback中的单独方法记录</a></li>
<li><a href="../zh-CN463605/index.html">技术知识分子-来自深空</a></li>
<li><a href="../zh-CN463607/index.html">带有React Context和hook的Redux内置替代方案</a></li>
<li><a href="../zh-CN463609/index.html">Directum Club的推荐系统。 第一部分，协作</a></li>
<li><a href="../zh-CN463613/index.html">Docker镜像也可以使用常规Dockerfile在werf中构建</a></li>
<li><a href="../zh-CN463617/index.html">测试移动MMO的功能</a></li>
<li><a href="../zh-CN463619/index.html">远程工作：我们的经验</a></li>
<li><a href="../zh-CN463623/index.html">我们是从测试的丛林中选拔出来的：从夹具到测试，我们正在建立一条捷径</a></li>
<li><a href="../zh-CN463625/index.html">使用Flowmon Networks解决方案进行网络监视和异常网络活动的检测</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>