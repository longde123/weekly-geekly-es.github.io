<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üÖøÔ∏è üçÅ üê® √úber einige Probleme bei der Mikrooptimierung üë©‚Äçüî¨ üë®üèª‚Äçüé§ ü•¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hintergrund 
 Einmal begann ein Gespr√§ch mit einem Kollegen √ºber die Verbesserung von Werkzeugen f√ºr die Arbeit mit Bit-Flags in C ++ - Enumerationen....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√úber einige Probleme bei der Mikrooptimierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482766/"><h2>  Hintergrund </h2><br>  Einmal begann ein Gespr√§ch mit einem Kollegen √ºber die Verbesserung von Werkzeugen f√ºr die Arbeit mit Bit-Flags in C ++ - Enumerationen.  Zu diesem Zeitpunkt hatten wir bereits die Funktion IsEnumFlagSet, die die getestete Variable als erstes Argument und die zweite zu √ºberpr√ºfende Gruppe von Flags verwendet.  Warum ist es besser als das gute alte bitweise Und? <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsEnumFlagSet(state, flag)) { } <span class="hljs-comment"><span class="hljs-comment">// vs if (state &amp; flag) { }</span></span></code> </pre> <a name="habracut"></a><br>  Meiner Meinung nach - Lesbarkeit.  Ich arbeite im Allgemeinen selten mit Bit-Flags und Bit-Operationen. Wenn Sie also den Code eines anderen Benutzers anzeigen, ist es viel einfacher, die √ºblichen Funktionsnamen zu erkennen, als das kryptische &amp; und |, das sofort das interne window.alert () mit der √úberschrift ‚ÄûAttention!  Es kann eine Art Magie passieren. ‚Äú <br><br><div class="spoiler">  <b class="spoiler_title">Ein bisschen Traurigkeit</b> <div class="spoiler_text">  Leider unterst√ºtzt C ++ immer noch keine Erweiterungsmethoden (obwohl es bereits einen <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4174.pdf" rel="nofollow">√§hnlichen Vorschlag gab</a> ) - ansonsten w√§re zum Beispiel die Methode a la std :: bitset eine ideale Option: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state.Test(particularFlags)) {}</code> </pre> <br></div></div><br>  Insbesondere die Lesbarkeit verschlechtert sich beim Setzen oder Entfernen von Flags.  Vergleichen Sie: <br><br><pre> <code class="cpp hljs">state |= flag; <span class="hljs-comment"><span class="hljs-comment">//    enum class,     |= state &amp;= ~flag; //vs RaiseEnumFlag(state, flag); ClearEnumFlag(state, flag);</span></span></code> </pre><br>  W√§hrend der Diskussion wurde auch die Idee zum Ausdruck gebracht, die Funktion <code>SetEnumFlag(state, flag, isSet)</code> : Abh√§ngig vom dritten Argument w√ºrde <code>state</code> entweder Flags <code>SetEnumFlag(state, flag, isSet)</code> oder sie l√∂schen. <br><br>  Da davon ausgegangen wurde, dass dieses Argument zur <code>RaiseEnumFlag/ClearEnumFlag</code> wird, k√∂nnen Sie im Vergleich zum <code>RaiseEnumFlag/ClearEnumFlag</code> Paar nicht auf Overhead <code>RaiseEnumFlag/ClearEnumFlag</code> .  Aber aus Gr√ºnden des akademischen Interesses wollte ich es minimieren, indem ich <a href="https://youtu.be/FJJTYQYB1JQ%3Ft%3D1932" rel="nofollow">zum Teufel der</a> Mikrooptimierungen in die <a href="https://youtu.be/FJJTYQYB1JQ%3Ft%3D1932" rel="nofollow">Mine</a> hinabstieg. <br><br><h2>  Implementierung </h2><br><h3>  1. Naive Umsetzung </h3><br>  Zuerst f√ºhren wir unsere Aufz√§hlung ein (wir werden die Aufz√§hlungsklasse nicht zum Vereinfachen verwenden): <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;limits&gt; #include &lt;random&gt; enum Flags : uint32_t { One = 1u &lt;&lt; 1, Two = 1u &lt;&lt; 2, Three = 1u &lt;&lt; 3, OneOrThree = One | Three, Max = 1u &lt;&lt; 31, All = std::numeric_limits&lt;uint32_t&gt;::max() };</span></span></span></span></code> </pre> <br>  Und die Implementierung selbst: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetFlagBranched</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Flags&amp; x, Flags y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cond)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cond) { x = Flags(x | y); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { x = Flags(x &amp; (~y)); } }</code> </pre> <br><h3>  2. Mikrooptimierung </h3><br>  Die naive Implementierung hat eine offensichtliche Verzweigung, die ich sehr gerne auf das Rechnen √ºbertragen m√∂chte, was wir jetzt versuchen. <br><br>  Zuerst m√ºssen wir einen Ausdruck ausw√§hlen, mit dem wir basierend auf dem Parameter von einem Ergebnis zu einem anderen wechseln k√∂nnen.  Zum Beispiel <br><br><pre> <code class="plaintext hljs">(x | y) &amp; ¬¨p</code> </pre> <br><ol><li>  Wenn <code>p = 0</code> die Flags: <br><br><pre> <code class="plaintext hljs">(x | y) &amp; ¬¨0 ‚â° (x | y) &amp; 1 ‚â° x | y</code> </pre> <br></li><li>  Wenn <code>p = y</code> Flags entfernt: <br><br><pre> <code class="plaintext hljs">(x | y) &amp; ¬¨y ‚â° (x &amp; ¬¨y) | (y &amp; ¬¨y) ‚â° (x &amp; ¬¨y) | 0 ‚â° x &amp; ¬¨y</code> </pre> <br></li></ol><br>  Jetzt m√ºssen wir die √Ñnderung des Werts des Parameters in Abh√§ngigkeit von der Variablen <code>cond</code> irgendwie in die Arithmetik ‚Äûpacken‚Äú (denken Sie daran - Verzweigung ist verboten). <br><br>  Lassen Sie anfangs <code>p = y</code> und, wenn <code>cond</code> wahr ist, versuchen Sie, <code>p</code> , wenn nicht, lassen Sie alles so, wie es ist. <br><br>  Wir werden nicht in der Lage sein, direkt mit der Variablen <code>cond</code> : Wenn bei der Konvertierung in den arithmetischen Typ true angegeben wird, erhalten wir nur eine Einheit in der niedrigen Reihenfolge, und im Idealfall m√ºssen wir Einheiten in allen Bits erhalten (UPD: <a href="https://habr.com/ru/post/482766/">Sie k√∂nnen immer noch</a> ).  Als Ergebnis fiel mir nichts besseres ein, als bitweise Verschiebungen vorzunehmen. <br><br>  Wir definieren das Ausma√ü der Verschiebung: Wir k√∂nnen nicht alle unsere Bits sofort verschieben, sodass der Parameter <code>p</code> in einer Operation zur√ºckgesetzt wird, da der Standard verlangt, dass das Ausma√ü der Verschiebung kleiner als die Typgr√∂√üe ist. <br><br><div class="spoiler">  <b class="spoiler_title">Nicht zu recht</b> <div class="spoiler_text">  Der Befehl zum Verschieben der Arithmetik nach links (SAL) in der ASM-Dokumentation lautet beispielsweise "Der Z√§hlbereich ist auf 0 bis 31 begrenzt (oder 63, wenn der 64-Bit-Modus und REX.W verwendet werden)". <br></div></div><br>  Daher berechnen wir die maximale Verschiebungsgr√∂√üe, schreiben den vorl√§ufigen Ausdruck <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> shiftSize = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">underlying_type_t</span></span>&lt;Flags&gt;) * <span class="hljs-number"><span class="hljs-number">8</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>; (x | y) &amp; ~ ( y &gt;&gt; shiftSize * cond);</code> </pre><br>  Und verarbeiten Sie das niederwertige Bit des Ergebnisses des Ausdrucks <code>y &gt;&gt; shiftSize * cond</code> : <br><br><pre> <code class="cpp hljs">(x | y) &amp; ~ (( y &gt;&gt; shiftSize * cond) &amp; ~cond);</code> </pre> <br>  Die Verzweigung wurde in <code>shiftSize * cond</code> Abh√§ngig von false oder true in cond ist der Verschiebungswert entweder 0 oder 31, und unser Parameter ist entweder gleich <code>y</code> oder 0. <br><br>  Was passiert wenn <code>shiftSize = 31</code> : <br><br><ol><li>  Mit <code>cond = true</code> verschieben wir die <code>y</code> Bits um 31 nach rechts, wodurch das h√∂chstwertige Bit von <code>y</code> das niedrigstwertige wird und alle anderen zur√ºckgesetzt werden.  Im Gegensatz dazu ist das niedrigstwertige Bit 0 und alle anderen sind eins.  Die bitweise Multiplikation dieser Werte ergibt eine saubere 0. </li><li>  Wenn <code>cond = false</code> keine Verschiebung auf, <code>~cond</code> in allen Ziffern 1, und die bitweise Multiplikation dieser Werte ergibt <code>y</code> . </li></ol><br>  Ich m√∂chte auf den Kompromiss dieses Ansatzes hinweisen, der nicht sofort offensichtlich ist: Ohne Verwendung von Verzweigungen berechnen wir <code>x | y</code>  <code>x | y</code> (d. h. einer der Zweige der naiven Version) und dann aufgrund der "zus√§tzlichen" arithmetischen Operationen in das gew√ºnschte Ergebnis umwandeln.  Und all dies ist sinnvoll, wenn der Mehraufwand f√ºr zus√§tzliche Arithmetik geringer ist als f√ºr Verzweigungen. <br><br>  Die endg√ºltige Entscheidung war also wie folgt: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetFlagsBranchless</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Flags&amp; x, Flags y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cond)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> shiftSize = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">underlying_type_t</span></span>&lt;Flags&gt;) * <span class="hljs-number"><span class="hljs-number">8</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>; x = Flags((x | y) &amp; ~(( y &gt;&gt; shiftSize * cond) &amp; ~cond)); }</code> </pre> <br>  (Die Verschiebungsgr√∂√üe ist korrekter, um <code>std::numeric_limits::digits</code> , <a href="https://habr.com/ru/post/482766/">siehe Kommentar</a> ) <br><br><h3>  3. Vergleich </h3><br>  <a href="http://quick-bench.com/" rel="nofollow">Nachdem ich</a> die L√∂sung ohne Verzweigung implementiert hatte, ging ich zu <a href="http://quick-bench.com/" rel="nofollow">quick-bench.com</a> , um den Vorteil zu <a href="http://quick-bench.com/" rel="nofollow">√ºberpr√ºfen</a> .  F√ºr die Entwicklung verwenden wir haupts√§chlich clang, daher habe ich beschlossen, die Benchmarks (clang-9.0) auszuf√ºhren.  Aber dann erwartete mich eine √úberraschung ... <br><br><img src="https://habrastorage.org/webt/j8/ar/se/j8arset8k9nbzroo2ws7a2flzeu.png"><br><br>  Und das ist mit -O3.  Ohne Optimierungen ist es schlimmer.  Wie ist es passiert?  Wer ist schuld und was zu tun? <br><br>  Wir befehlen, "die Panik beiseite zu legen!" Und gehen zu <a href="https://godbolt.org/" rel="nofollow">godbolt.org</a> (quick-bench bietet auch asm-Auflistung, aber godbolt sieht in dieser Hinsicht praktischer aus). <br><br>  Als n√§chstes werden wir nur √ºber den Optimierungsgrad -O3 sprechen.  Welchen Code hat Clang f√ºr unsere naive Implementierung generiert? <br><br><pre> <code class="plaintext hljs">SetFlagBranched(Flags&amp;, Flags, bool): # @SetFlagBranched(Flags&amp;, Flags, bool) mov eax, dword ptr [rdi] mov ecx, esi not ecx and ecx, eax or eax, esi test edx, edx cmove eax, ecx mov dword ptr [rdi], eax ret</code> </pre> <br>  Nicht schlecht, oder?  Clang wei√ü auch, wie man einen Kompromiss eingeht, und versteht, dass es schneller sein wird, bedingte Sprungbefehle zu verwenden, um <i>beide</i> Zweige zu berechnen und den bedingten Verschiebebefehl zu verwenden, der <a href="https://stackoverflow.com/questions/14131096/why-is-a-conditional-move-not-vulnerable-for-branch-prediction-failure" rel="nofollow">keine</a> Verzweigungsvorhersage in die Arbeit <a href="https://stackoverflow.com/questions/14131096/why-is-a-conditional-move-not-vulnerable-for-branch-prediction-failure" rel="nofollow">einbezieht</a> . <br><br>  Verzweigungsloser Implementierungscode: <br><br><pre> <code class="plaintext hljs">SetFlag(Flags&amp;, Flags, bool): # @SetFlag(Flags&amp;, Flags, bool) mov eax, dword ptr [rdi] or eax, esi test edx, edx mov ecx, 31 cmove ecx, edx shr esi, cl not esi or esi, edx and esi, eax mov dword ptr [rdi], esi ret</code> </pre> <br>  Fast ‚Äûverzweigungslos‚Äú - ich habe hier sozusagen die √ºbliche Multiplikation angeordnet, und Sie, mein Freund, haben einen bedingten Zug ausgef√ºhrt.  Vielleicht hat der Compiler recht, und test + cmove ist in diesem Fall schneller als imul, aber ich bin nicht so gut im Assembler (sachkundige Leute, sag es mir bitte in den Kommentaren). <br><br>  Interessant ist auch, dass bei beiden Implementierungen nach Optimierungen der Compiler nicht genau das generiert hat, was wir angefordert haben, und dass wir dadurch etwas dazwischen bekommen haben: cmove wird in beiden Varianten verwendet, wir haben nur eine Menge zus√§tzlicher Arithmetik in der branchless-Implementierung, die den Benchmark √ºberfordert. <br><br>  Clang der achten und √§lteren Version verwendet im Allgemeinen echte bedingte √úberg√§nge, ‚Äûaufgrund derer‚Äú die ‚Äûverzweigungslose‚Äú Version fast eineinhalb Mal langsamer wird: <br><br><pre> <code class="plaintext hljs">SetFlag(Flags&amp;, Flags, bool): # @SetFlag(Flags&amp;, Flags, bool) mov eax, dword ptr [rdi] or eax, esi mov cl, 31 test edx, edx jne .LBB0_2 xor ecx, ecx .LBB0_2: shr esi, cl not esi or esi, edx and eax, esi mov dword ptr [rdi], eax ret</code> </pre> <br>  Welche Schlussfolgerung kann gezogen werden?  Neben dem offensichtlichen Hinweis, dass Sie die Mikrooptimierung nicht unn√∂tig durchf√ºhren sollten, es sei denn, Sie k√∂nnen Ihnen raten, immer das Ergebnis der Arbeit mit Maschinencode zu √ºberpr√ºfen. Es kann sich herausstellen, dass der Compiler die urspr√ºngliche Version bereits ausreichend optimiert hat und dass Ihre ‚Äûgenialen‚Äú Optimierungen dies nicht verstehen und Sie dar√ºber nachdenken werden √úberg√§nge statt Multiplikationen. <br><br>  An diesem Punkt w√§re es m√∂glich zu beenden, wenn nicht f√ºr ein "aber".  Der gcc-Code f√ºr die naive Implementierung ist identisch mit dem Clang-Code, aber die verzweigungslose Version ist ..: <br><br><pre> <code class="plaintext hljs">SetFlag(Flags&amp;, Flags, bool): movzx edx, dl mov eax, esi or eax, DWORD PTR [rdi] mov ecx, edx sal ecx, 5 sub ecx, edx shr esi, cl not esi or esi, edx and esi, eax mov DWORD PTR [rdi], esi ret</code> </pre> <br>  Ich respektiere die Entwickler f√ºr eine so elegante Art und Weise, unseren Ausdruck zu optimieren, ohne entweder <code>imul</code> oder <code>cmove</code> .  Was passiert hier: Die Bool-Variable cond wird bitweise um 5 Zeichen nach links verschoben (weil der Typ unserer Aufz√§hlung uint32_t ist, ihre Gr√∂√üe 32 Bit, das hei√üt 100000 <sub>2</sub> ) und dann vom Ergebnis subtrahiert.  Somit erhalten wir im Fall von cond = true 11111 <sub>2</sub> = 31 <sub>10</sub> und andernfalls 0.  Selbstverst√§ndlich ist eine solche Option schneller als die naive, auch unter Ber√ºcksichtigung der bedingten Bewegungsoptimierung? <br><br><img src="https://habrastorage.org/webt/il/-k/sv/il-ksv3hfdrbu0npoffcva7c67o.png" alt="Bild"><br><br>  Nun, das Ergebnis war sehr merkw√ºrdig - je nach Compiler kann die Option ohne Verzweigungen schneller oder langsamer sein als die Implementierung mit Verzweigungen.  Versuchen wir, unseren Ausdruck mit der gcc-Methode zu klingeln und zu transformieren (vereinfachen wir gleichzeitig den Teil <code>~((y &gt;&gt; shiftSize * cond) &amp; ~cond)</code> nach de Morgan - dies geschieht sowohl mit clang als auch mit gcc): <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetFlagVerbose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Flags&amp; x, Flags y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> shiftSize = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">underlying_type_t</span></span>&lt;Flags&gt;) + <span class="hljs-number"><span class="hljs-number">1</span></span>; x = Flags( (x | y) &amp; ( ~(y &gt;&gt; ((b &lt;&lt; shiftSize) - b)) | b) ); }</code> </pre> <br>  Ein solcher Hinweis wirkt sich nur auf die Trunk-Version von clang aus, bei der tats√§chlich Code √§hnlich wie bei gcc generiert wird (obwohl es sich bei dem urspr√ºnglichen "branchless" um denselben Test + cmove handelt). <br><br>  Was ist mit MSVC?  In beiden Versionen wird ohne Verzweigung "honest imul" verwendet (ich wei√ü nicht, wie viel schneller / langsamer als die Option "clang / gcc" ist - quick-bench unterst√ºtzt diesen Compiler nicht). In der naiven Version ist "conditional jump" aufgetreten.  Traurig aber wahr. <br><br><h2>  Zusammenfassung </h2><br>  Die Hauptschlussfolgerung l√§sst sich vielleicht so fassen, dass die Absichten des Programmierers in Code auf hoher Ebene sich nicht immer in Maschinencode widerspiegeln. Dies macht Mikrooptimierungen ohne Benchmarks und Anzeigen von Auflistungen sinnlos.  Dar√ºber hinaus kann das Ergebnis von Mikrooptimierungen entweder besser oder schlechter als die √ºbliche Version sein - es h√§ngt alles vom Compiler ab, was ein ernstes Problem sein kann, wenn das Projekt plattform√ºbergreifend ist. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de482766/">https://habr.com/ru/post/de482766/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de482748/index.html">Aufbau eines Taxibuchungsgesch√§fts in Dubai: Wie starte ich eine kundenorientierte Taxi-App wie Careem & Hala?</a></li>
<li><a href="../de482752/index.html">"Neue Epen". Wir essen den Elefanten in Teilen</a></li>
<li><a href="../de482756/index.html">Ist es eine neblige gr√ºne Zukunft?</a></li>
<li><a href="../de482762/index.html">42.000.000.000 Besuche. PornHub fasste 2019 zusammen</a></li>
<li><a href="../de482764/index.html">Rhasspy ist ein Open-Source- und Offline-Sprach-Toolkit. Anerkennung der russischen Sprache. Keine Lecks in die Wolke</a></li>
<li><a href="../de482768/index.html">Wann erscheint DeepRegistry? Auf die Liebe der Weltregulierungsbeh√∂rden, alles zu kontrollieren</a></li>
<li><a href="../de482772/index.html">Progressive Webanwendungen im Jahr 2020</a></li>
<li><a href="../de482774/index.html">Schwarzes Seoshniki und beste Werbemethoden. Erwachsener, Apotheke, Aufs√§tze, Datierung. Schestakow | Menschen PRO # 75</a></li>
<li><a href="../de482778/index.html">L√ºftung mit Erholung in der Wohnung. Ohne Leitungen und SMS</a></li>
<li><a href="../de482780/index.html">Experimente mit neuronalen Netzen basierend auf seismischen Daten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>