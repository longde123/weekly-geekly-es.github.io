<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🅿️ 🍁 🐨 Über einige Probleme bei der Mikrooptimierung 👩‍🔬 👨🏻‍🎤 🥢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hintergrund 
 Einmal begann ein Gespräch mit einem Kollegen über die Verbesserung von Werkzeugen für die Arbeit mit Bit-Flags in C ++ - Enumerationen....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Über einige Probleme bei der Mikrooptimierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482766/"><h2>  Hintergrund </h2><br>  Einmal begann ein Gespräch mit einem Kollegen über die Verbesserung von Werkzeugen für die Arbeit mit Bit-Flags in C ++ - Enumerationen.  Zu diesem Zeitpunkt hatten wir bereits die Funktion IsEnumFlagSet, die die getestete Variable als erstes Argument und die zweite zu überprüfende Gruppe von Flags verwendet.  Warum ist es besser als das gute alte bitweise Und? <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsEnumFlagSet(state, flag)) { } <span class="hljs-comment"><span class="hljs-comment">// vs if (state &amp; flag) { }</span></span></code> </pre> <a name="habracut"></a><br>  Meiner Meinung nach - Lesbarkeit.  Ich arbeite im Allgemeinen selten mit Bit-Flags und Bit-Operationen. Wenn Sie also den Code eines anderen Benutzers anzeigen, ist es viel einfacher, die üblichen Funktionsnamen zu erkennen, als das kryptische &amp; und |, das sofort das interne window.alert () mit der Überschrift „Attention!  Es kann eine Art Magie passieren. “ <br><br><div class="spoiler">  <b class="spoiler_title">Ein bisschen Traurigkeit</b> <div class="spoiler_text">  Leider unterstützt C ++ immer noch keine Erweiterungsmethoden (obwohl es bereits einen <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4174.pdf" rel="nofollow">ähnlichen Vorschlag gab</a> ) - ansonsten wäre zum Beispiel die Methode a la std :: bitset eine ideale Option: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state.Test(particularFlags)) {}</code> </pre> <br></div></div><br>  Insbesondere die Lesbarkeit verschlechtert sich beim Setzen oder Entfernen von Flags.  Vergleichen Sie: <br><br><pre> <code class="cpp hljs">state |= flag; <span class="hljs-comment"><span class="hljs-comment">//    enum class,     |= state &amp;= ~flag; //vs RaiseEnumFlag(state, flag); ClearEnumFlag(state, flag);</span></span></code> </pre><br>  Während der Diskussion wurde auch die Idee zum Ausdruck gebracht, die Funktion <code>SetEnumFlag(state, flag, isSet)</code> : Abhängig vom dritten Argument würde <code>state</code> entweder Flags <code>SetEnumFlag(state, flag, isSet)</code> oder sie löschen. <br><br>  Da davon ausgegangen wurde, dass dieses Argument zur <code>RaiseEnumFlag/ClearEnumFlag</code> wird, können Sie im Vergleich zum <code>RaiseEnumFlag/ClearEnumFlag</code> Paar nicht auf Overhead <code>RaiseEnumFlag/ClearEnumFlag</code> .  Aber aus Gründen des akademischen Interesses wollte ich es minimieren, indem ich <a href="https://youtu.be/FJJTYQYB1JQ%3Ft%3D1932" rel="nofollow">zum Teufel der</a> Mikrooptimierungen in die <a href="https://youtu.be/FJJTYQYB1JQ%3Ft%3D1932" rel="nofollow">Mine</a> hinabstieg. <br><br><h2>  Implementierung </h2><br><h3>  1. Naive Umsetzung </h3><br>  Zuerst führen wir unsere Aufzählung ein (wir werden die Aufzählungsklasse nicht zum Vereinfachen verwenden): <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;limits&gt; #include &lt;random&gt; enum Flags : uint32_t { One = 1u &lt;&lt; 1, Two = 1u &lt;&lt; 2, Three = 1u &lt;&lt; 3, OneOrThree = One | Three, Max = 1u &lt;&lt; 31, All = std::numeric_limits&lt;uint32_t&gt;::max() };</span></span></span></span></code> </pre> <br>  Und die Implementierung selbst: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetFlagBranched</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Flags&amp; x, Flags y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cond)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cond) { x = Flags(x | y); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { x = Flags(x &amp; (~y)); } }</code> </pre> <br><h3>  2. Mikrooptimierung </h3><br>  Die naive Implementierung hat eine offensichtliche Verzweigung, die ich sehr gerne auf das Rechnen übertragen möchte, was wir jetzt versuchen. <br><br>  Zuerst müssen wir einen Ausdruck auswählen, mit dem wir basierend auf dem Parameter von einem Ergebnis zu einem anderen wechseln können.  Zum Beispiel <br><br><pre> <code class="plaintext hljs">(x | y) &amp; ¬p</code> </pre> <br><ol><li>  Wenn <code>p = 0</code> die Flags: <br><br><pre> <code class="plaintext hljs">(x | y) &amp; ¬0 ≡ (x | y) &amp; 1 ≡ x | y</code> </pre> <br></li><li>  Wenn <code>p = y</code> Flags entfernt: <br><br><pre> <code class="plaintext hljs">(x | y) &amp; ¬y ≡ (x &amp; ¬y) | (y &amp; ¬y) ≡ (x &amp; ¬y) | 0 ≡ x &amp; ¬y</code> </pre> <br></li></ol><br>  Jetzt müssen wir die Änderung des Werts des Parameters in Abhängigkeit von der Variablen <code>cond</code> irgendwie in die Arithmetik „packen“ (denken Sie daran - Verzweigung ist verboten). <br><br>  Lassen Sie anfangs <code>p = y</code> und, wenn <code>cond</code> wahr ist, versuchen Sie, <code>p</code> , wenn nicht, lassen Sie alles so, wie es ist. <br><br>  Wir werden nicht in der Lage sein, direkt mit der Variablen <code>cond</code> : Wenn bei der Konvertierung in den arithmetischen Typ true angegeben wird, erhalten wir nur eine Einheit in der niedrigen Reihenfolge, und im Idealfall müssen wir Einheiten in allen Bits erhalten (UPD: <a href="https://habr.com/ru/post/482766/">Sie können immer noch</a> ).  Als Ergebnis fiel mir nichts besseres ein, als bitweise Verschiebungen vorzunehmen. <br><br>  Wir definieren das Ausmaß der Verschiebung: Wir können nicht alle unsere Bits sofort verschieben, sodass der Parameter <code>p</code> in einer Operation zurückgesetzt wird, da der Standard verlangt, dass das Ausmaß der Verschiebung kleiner als die Typgröße ist. <br><br><div class="spoiler">  <b class="spoiler_title">Nicht zu recht</b> <div class="spoiler_text">  Der Befehl zum Verschieben der Arithmetik nach links (SAL) in der ASM-Dokumentation lautet beispielsweise "Der Zählbereich ist auf 0 bis 31 begrenzt (oder 63, wenn der 64-Bit-Modus und REX.W verwendet werden)". <br></div></div><br>  Daher berechnen wir die maximale Verschiebungsgröße, schreiben den vorläufigen Ausdruck <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> shiftSize = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">underlying_type_t</span></span>&lt;Flags&gt;) * <span class="hljs-number"><span class="hljs-number">8</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>; (x | y) &amp; ~ ( y &gt;&gt; shiftSize * cond);</code> </pre><br>  Und verarbeiten Sie das niederwertige Bit des Ergebnisses des Ausdrucks <code>y &gt;&gt; shiftSize * cond</code> : <br><br><pre> <code class="cpp hljs">(x | y) &amp; ~ (( y &gt;&gt; shiftSize * cond) &amp; ~cond);</code> </pre> <br>  Die Verzweigung wurde in <code>shiftSize * cond</code> Abhängig von false oder true in cond ist der Verschiebungswert entweder 0 oder 31, und unser Parameter ist entweder gleich <code>y</code> oder 0. <br><br>  Was passiert wenn <code>shiftSize = 31</code> : <br><br><ol><li>  Mit <code>cond = true</code> verschieben wir die <code>y</code> Bits um 31 nach rechts, wodurch das höchstwertige Bit von <code>y</code> das niedrigstwertige wird und alle anderen zurückgesetzt werden.  Im Gegensatz dazu ist das niedrigstwertige Bit 0 und alle anderen sind eins.  Die bitweise Multiplikation dieser Werte ergibt eine saubere 0. </li><li>  Wenn <code>cond = false</code> keine Verschiebung auf, <code>~cond</code> in allen Ziffern 1, und die bitweise Multiplikation dieser Werte ergibt <code>y</code> . </li></ol><br>  Ich möchte auf den Kompromiss dieses Ansatzes hinweisen, der nicht sofort offensichtlich ist: Ohne Verwendung von Verzweigungen berechnen wir <code>x | y</code>  <code>x | y</code> (d. h. einer der Zweige der naiven Version) und dann aufgrund der "zusätzlichen" arithmetischen Operationen in das gewünschte Ergebnis umwandeln.  Und all dies ist sinnvoll, wenn der Mehraufwand für zusätzliche Arithmetik geringer ist als für Verzweigungen. <br><br>  Die endgültige Entscheidung war also wie folgt: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetFlagsBranchless</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Flags&amp; x, Flags y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cond)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> shiftSize = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">underlying_type_t</span></span>&lt;Flags&gt;) * <span class="hljs-number"><span class="hljs-number">8</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>; x = Flags((x | y) &amp; ~(( y &gt;&gt; shiftSize * cond) &amp; ~cond)); }</code> </pre> <br>  (Die Verschiebungsgröße ist korrekter, um <code>std::numeric_limits::digits</code> , <a href="https://habr.com/ru/post/482766/">siehe Kommentar</a> ) <br><br><h3>  3. Vergleich </h3><br>  <a href="http://quick-bench.com/" rel="nofollow">Nachdem ich</a> die Lösung ohne Verzweigung implementiert hatte, ging ich zu <a href="http://quick-bench.com/" rel="nofollow">quick-bench.com</a> , um den Vorteil zu <a href="http://quick-bench.com/" rel="nofollow">überprüfen</a> .  Für die Entwicklung verwenden wir hauptsächlich clang, daher habe ich beschlossen, die Benchmarks (clang-9.0) auszuführen.  Aber dann erwartete mich eine Überraschung ... <br><br><img src="https://habrastorage.org/webt/j8/ar/se/j8arset8k9nbzroo2ws7a2flzeu.png"><br><br>  Und das ist mit -O3.  Ohne Optimierungen ist es schlimmer.  Wie ist es passiert?  Wer ist schuld und was zu tun? <br><br>  Wir befehlen, "die Panik beiseite zu legen!" Und gehen zu <a href="https://godbolt.org/" rel="nofollow">godbolt.org</a> (quick-bench bietet auch asm-Auflistung, aber godbolt sieht in dieser Hinsicht praktischer aus). <br><br>  Als nächstes werden wir nur über den Optimierungsgrad -O3 sprechen.  Welchen Code hat Clang für unsere naive Implementierung generiert? <br><br><pre> <code class="plaintext hljs">SetFlagBranched(Flags&amp;, Flags, bool): # @SetFlagBranched(Flags&amp;, Flags, bool) mov eax, dword ptr [rdi] mov ecx, esi not ecx and ecx, eax or eax, esi test edx, edx cmove eax, ecx mov dword ptr [rdi], eax ret</code> </pre> <br>  Nicht schlecht, oder?  Clang weiß auch, wie man einen Kompromiss eingeht, und versteht, dass es schneller sein wird, bedingte Sprungbefehle zu verwenden, um <i>beide</i> Zweige zu berechnen und den bedingten Verschiebebefehl zu verwenden, der <a href="https://stackoverflow.com/questions/14131096/why-is-a-conditional-move-not-vulnerable-for-branch-prediction-failure" rel="nofollow">keine</a> Verzweigungsvorhersage in die Arbeit <a href="https://stackoverflow.com/questions/14131096/why-is-a-conditional-move-not-vulnerable-for-branch-prediction-failure" rel="nofollow">einbezieht</a> . <br><br>  Verzweigungsloser Implementierungscode: <br><br><pre> <code class="plaintext hljs">SetFlag(Flags&amp;, Flags, bool): # @SetFlag(Flags&amp;, Flags, bool) mov eax, dword ptr [rdi] or eax, esi test edx, edx mov ecx, 31 cmove ecx, edx shr esi, cl not esi or esi, edx and esi, eax mov dword ptr [rdi], esi ret</code> </pre> <br>  Fast „verzweigungslos“ - ich habe hier sozusagen die übliche Multiplikation angeordnet, und Sie, mein Freund, haben einen bedingten Zug ausgeführt.  Vielleicht hat der Compiler recht, und test + cmove ist in diesem Fall schneller als imul, aber ich bin nicht so gut im Assembler (sachkundige Leute, sag es mir bitte in den Kommentaren). <br><br>  Interessant ist auch, dass bei beiden Implementierungen nach Optimierungen der Compiler nicht genau das generiert hat, was wir angefordert haben, und dass wir dadurch etwas dazwischen bekommen haben: cmove wird in beiden Varianten verwendet, wir haben nur eine Menge zusätzlicher Arithmetik in der branchless-Implementierung, die den Benchmark überfordert. <br><br>  Clang der achten und älteren Version verwendet im Allgemeinen echte bedingte Übergänge, „aufgrund derer“ die „verzweigungslose“ Version fast eineinhalb Mal langsamer wird: <br><br><pre> <code class="plaintext hljs">SetFlag(Flags&amp;, Flags, bool): # @SetFlag(Flags&amp;, Flags, bool) mov eax, dword ptr [rdi] or eax, esi mov cl, 31 test edx, edx jne .LBB0_2 xor ecx, ecx .LBB0_2: shr esi, cl not esi or esi, edx and eax, esi mov dword ptr [rdi], eax ret</code> </pre> <br>  Welche Schlussfolgerung kann gezogen werden?  Neben dem offensichtlichen Hinweis, dass Sie die Mikrooptimierung nicht unnötig durchführen sollten, es sei denn, Sie können Ihnen raten, immer das Ergebnis der Arbeit mit Maschinencode zu überprüfen. Es kann sich herausstellen, dass der Compiler die ursprüngliche Version bereits ausreichend optimiert hat und dass Ihre „genialen“ Optimierungen dies nicht verstehen und Sie darüber nachdenken werden Übergänge statt Multiplikationen. <br><br>  An diesem Punkt wäre es möglich zu beenden, wenn nicht für ein "aber".  Der gcc-Code für die naive Implementierung ist identisch mit dem Clang-Code, aber die verzweigungslose Version ist ..: <br><br><pre> <code class="plaintext hljs">SetFlag(Flags&amp;, Flags, bool): movzx edx, dl mov eax, esi or eax, DWORD PTR [rdi] mov ecx, edx sal ecx, 5 sub ecx, edx shr esi, cl not esi or esi, edx and esi, eax mov DWORD PTR [rdi], esi ret</code> </pre> <br>  Ich respektiere die Entwickler für eine so elegante Art und Weise, unseren Ausdruck zu optimieren, ohne entweder <code>imul</code> oder <code>cmove</code> .  Was passiert hier: Die Bool-Variable cond wird bitweise um 5 Zeichen nach links verschoben (weil der Typ unserer Aufzählung uint32_t ist, ihre Größe 32 Bit, das heißt 100000 <sub>2</sub> ) und dann vom Ergebnis subtrahiert.  Somit erhalten wir im Fall von cond = true 11111 <sub>2</sub> = 31 <sub>10</sub> und andernfalls 0.  Selbstverständlich ist eine solche Option schneller als die naive, auch unter Berücksichtigung der bedingten Bewegungsoptimierung? <br><br><img src="https://habrastorage.org/webt/il/-k/sv/il-ksv3hfdrbu0npoffcva7c67o.png" alt="Bild"><br><br>  Nun, das Ergebnis war sehr merkwürdig - je nach Compiler kann die Option ohne Verzweigungen schneller oder langsamer sein als die Implementierung mit Verzweigungen.  Versuchen wir, unseren Ausdruck mit der gcc-Methode zu klingeln und zu transformieren (vereinfachen wir gleichzeitig den Teil <code>~((y &gt;&gt; shiftSize * cond) &amp; ~cond)</code> nach de Morgan - dies geschieht sowohl mit clang als auch mit gcc): <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetFlagVerbose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Flags&amp; x, Flags y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> shiftSize = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">underlying_type_t</span></span>&lt;Flags&gt;) + <span class="hljs-number"><span class="hljs-number">1</span></span>; x = Flags( (x | y) &amp; ( ~(y &gt;&gt; ((b &lt;&lt; shiftSize) - b)) | b) ); }</code> </pre> <br>  Ein solcher Hinweis wirkt sich nur auf die Trunk-Version von clang aus, bei der tatsächlich Code ähnlich wie bei gcc generiert wird (obwohl es sich bei dem ursprünglichen "branchless" um denselben Test + cmove handelt). <br><br>  Was ist mit MSVC?  In beiden Versionen wird ohne Verzweigung "honest imul" verwendet (ich weiß nicht, wie viel schneller / langsamer als die Option "clang / gcc" ist - quick-bench unterstützt diesen Compiler nicht). In der naiven Version ist "conditional jump" aufgetreten.  Traurig aber wahr. <br><br><h2>  Zusammenfassung </h2><br>  Die Hauptschlussfolgerung lässt sich vielleicht so fassen, dass die Absichten des Programmierers in Code auf hoher Ebene sich nicht immer in Maschinencode widerspiegeln. Dies macht Mikrooptimierungen ohne Benchmarks und Anzeigen von Auflistungen sinnlos.  Darüber hinaus kann das Ergebnis von Mikrooptimierungen entweder besser oder schlechter als die übliche Version sein - es hängt alles vom Compiler ab, was ein ernstes Problem sein kann, wenn das Projekt plattformübergreifend ist. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de482766/">https://habr.com/ru/post/de482766/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de482748/index.html">Aufbau eines Taxibuchungsgeschäfts in Dubai: Wie starte ich eine kundenorientierte Taxi-App wie Careem & Hala?</a></li>
<li><a href="../de482752/index.html">"Neue Epen". Wir essen den Elefanten in Teilen</a></li>
<li><a href="../de482756/index.html">Ist es eine neblige grüne Zukunft?</a></li>
<li><a href="../de482762/index.html">42.000.000.000 Besuche. PornHub fasste 2019 zusammen</a></li>
<li><a href="../de482764/index.html">Rhasspy ist ein Open-Source- und Offline-Sprach-Toolkit. Anerkennung der russischen Sprache. Keine Lecks in die Wolke</a></li>
<li><a href="../de482768/index.html">Wann erscheint DeepRegistry? Auf die Liebe der Weltregulierungsbehörden, alles zu kontrollieren</a></li>
<li><a href="../de482772/index.html">Progressive Webanwendungen im Jahr 2020</a></li>
<li><a href="../de482774/index.html">Schwarzes Seoshniki und beste Werbemethoden. Erwachsener, Apotheke, Aufsätze, Datierung. Schestakow | Menschen PRO # 75</a></li>
<li><a href="../de482778/index.html">Lüftung mit Erholung in der Wohnung. Ohne Leitungen und SMS</a></li>
<li><a href="../de482780/index.html">Experimente mit neuronalen Netzen basierend auf seismischen Daten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>