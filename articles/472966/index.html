<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕚 🏑 🤧 Cómo se ve el archivo zip y qué podemos hacer con él. Parte 2 - Descriptor de datos y compresión 🤝 🤰 👃🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuación del artículo Cómo se ve el archivo zip y qué podemos hacer con él . 
 Prólogo 


 Buen dia 
 Y nuevamente en el aire tenemos programación...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cómo se ve el archivo zip y qué podemos hacer con él. Parte 2 - Descriptor de datos y compresión</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472966/"><p>  <i>Continuación del artículo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cómo se ve el archivo zip y qué podemos hacer con él</a> .</i> </p><br><h3>  Prólogo </h3><br><p> Buen dia <br>  Y nuevamente en el aire tenemos programación no convencional en PHP. </p><br><p>  En un artículo anterior, los lectores estimados estaban interesados ​​en la compresión zip y la transmisión zip.  Hoy intentaremos abrir un poco este tema. </p><a name="habracut"></a><br><p>  Echemos un vistazo a <br><br></p><div class="spoiler">  <b class="spoiler_title">Código del último artículo</b> <div class="spoiler_text"><pre><code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-comment"><span class="hljs-comment">//        (1.txt  2.txt)   : $entries = [ '1.txt' =&gt; 'Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc id ante ultrices, fermentum nibh eleifend, ullamcorper nunc. Sed dignissim ut odio et imperdiet. Nunc id felis et ligula viverra blandit a sit amet magna. Vestibulum facilisis venenatis enim sed bibendum. Duis maximus felis in suscipit bibendum. Mauris suscipit turpis eleifend nibh commodo imperdiet. Donec tincidunt porta interdum. Aenean interdum condimentum ligula, vitae ornare lorem auctor in. Suspendisse metus ipsum, porttitor et sapien id, fringilla aliquam nibh. Curabitur sem lacus, ultrices quis felis sed, blandit commodo metus. Duis tincidunt vel mauris at accumsan. Integer et ipsum fermentum leo viverra blandit.', '2.txt' =&gt; 'Mauris in purus sit amet ante tempor finibus nec sed justo. Integer ac nibh tempus, mollis sem vel, consequat diam. Pellentesque ut condimentum ex. Praesent finibus volutpat gravida. Vivamus eleifend neque sit amet diam scelerisque lacinia. Nunc imperdiet augue in suscipit lacinia. Curabitur orci diam, iaculis non ligula vitae, porta pellentesque est. Duis dolor erat, placerat a lacus eu, scelerisque egestas massa. Aliquam molestie pulvinar faucibus. Quisque consequat, dolor mattis lacinia pretium, eros eros tempor neque, volutpat consectetur elit elit non diam. In faucibus nulla justo, non dignissim erat maximus consectetur. Sed porttitor turpis nisl, elementum aliquam dui tincidunt nec. Nunc eu enim at nibh molestie porta ut ac erat. Sed tortor sem, mollis eget sodales vel, faucibus in dolor.', ]; //      Lorem.zip,      cwd (      ) $destination = 'Lorem.zip'; $handle = fopen($destination, 'w'); //      ,    ,     ,   "" Central Directory File Header $written = 0; $dictionary = []; foreach ($entries as $filename =&gt; $content) { //         Local File Header,     //        ,      . $fileInfo = [ //     'versionToExtract' =&gt; 10, //   0,        - 'generalPurposeBitFlag' =&gt; 0, //      ,    0 'compressionMethod' =&gt; 0, // -    mtime ,    ,      ? 'modificationTime' =&gt; 28021, //   , ? 'modificationDate' =&gt; 20072, //      .     ,       ,   ? 'crc32' =&gt; hexdec(hash('crc32b', $content)), //     .        . //       :) 'compressedSize' =&gt; $size = strlen($content), 'uncompressedSize' =&gt; $size, //    'filenameLength' =&gt; strlen($filename), //  .    ,   0. 'extraFieldLength' =&gt; 0, ]; //      . $LFH = pack('LSSSSSLLLSSa*', ...array_values([ 'signature' =&gt; 0x04034b50, //  Local File Header ] + $fileInfo + ['filename' =&gt; $filename])); //       ,       Central Directory File Header $dictionary[$filename] = [ 'signature' =&gt; 0x02014b50, //  Central Directory File Header 'versionMadeBy' =&gt; 798, //  .    ,  -  . ] + $fileInfo + [ 'fileCommentLength' =&gt; 0, //    . No comments 'diskNumber' =&gt; 0, //     0,        'internalFileAttributes' =&gt; 0, //    'externalFileAttributes' =&gt; 2176057344, //    'localFileHeaderOffset' =&gt; $written, //      Local File Header 'filename' =&gt; $filename, //  . ]; //      $written += fwrite($handle, $LFH); //    $written += fwrite($handle, $content); } // ,     ,    . //          End of central directory record (EOCD) $EOCD = [ //  EOCD 'signature' =&gt; 0x06054b50, //  .    ,   0 'diskNumber' =&gt; 0, //      -  0 'startDiskNumber' =&gt; 0, //       . 'numberCentralDirectoryRecord' =&gt; $records = count($dictionary), //    .    ,     'totalCentralDirectoryRecord' =&gt; $records, //   Central Directory Record. //      ,      'sizeOfCentralDirectory' =&gt; 0, // ,    Central Directory Records 'centralDirectoryOffset' =&gt; $written, //     'commentLength' =&gt; 0 ]; //     !   foreach ($dictionary as $entryInfo) { $CDFH = pack('LSSSSSSLLLSSSSSLLa*', ...array_values($entryInfo)); $written += fwrite($handle, $CDFH); } // ,   .  ,    $EOCD['sizeOfCentralDirectory'] = $written - $EOCD['centralDirectoryOffset']; //     End of central directory record $EOCD = pack('LSSSSLLS', ...array_values($EOCD)); $written += fwrite($handle, $EOCD); //  . fclose($handle); echo '  : ' . $written . ' ' . PHP_EOL; echo '     `unzip -tq ' . $destination . '`' . PHP_EOL; echo PHP_EOL;</span></span></code> </pre> <br></div></div><br><p>  Cual es su problema?  Bueno, para ser justos, vale la pena señalar que su única ventaja es que funciona, y hay problemas allí, pero aún así. <br><br>  En mi opinión, el problema principal es que primero debemos escribir el <b>Encabezado de archivo local (LFH)</b> con <b>crc32</b> y la longitud del archivo, y luego el contenido del archivo en sí. <br>  ¿Qué amenaza esto?  O cargamos todo el archivo en la memoria, consideramos crc32 para ello, escribimos <b>LFH</b> , y luego el contenido del archivo es económico desde el punto de vista de E / S, pero es inaceptable con archivos grandes.  O leemos el archivo 2 veces, primero para calcular el hash, y luego para leer el contenido y escribir en el archivo, económicamente desde el punto de vista de la RAM, pero, por ejemplo, primero duplica la carga en el disco, que no es necesariamente un SSD. <br><br>  ¿Y si el archivo se encuentra de forma remota y su volumen, por ejemplo, 1,5 GB?  Bueno, debe cargar todos los 1.5GB en la memoria, o esperar hasta que se descarguen todos estos 1.5GB y calcularemos el hash, y luego los volveremos a descargar para dar el contenido.  Si queremos dar sobre la marcha, por ejemplo, una base de datos de volcado, que, por ejemplo, leemos de stdout, esto generalmente es inaceptable: los datos en la base de datos han cambiado, los datos de volcado cambiarán, habrá un hash completamente diferente y obtendremos un archivo no válido.  Sí, las cosas están mal, por supuesto. </p><br><h3>  Estructura del descriptor de datos para la transmisión de registros de archivo </h3><br><p>  Pero no se desanime, la especificación ZIP nos permite escribir datos primero y luego pegar la estructura del <b>Descriptor de datos (DD)</b> después de los datos, que ya contiene crc32, la longitud de los datos empaquetados y la longitud de los datos sin compresión.  Para hacer esto, <strike>solo</strike> necesitamos <strike>3 veces al día con el estómago vacío</strike> en <b>LFH</b> especifique <b>generalPurposeBitFlag</b> igual a <b>0x0008</b> , y <b>crc32</b> , <b>compressedSize</b> y <b>descompressedSize</b> especifique <b>0</b> .  Luego, después de los datos, escribimos la estructura <b>DD</b> , que se verá así: </p><br><br><pre> <code class="php hljs">pack(<span class="hljs-string"><span class="hljs-string">'LLLL'</span></span>, ...array_values([ <span class="hljs-string"><span class="hljs-string">'signature'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">0x08074b50</span></span>, <span class="hljs-comment"><span class="hljs-comment">//  Data Descriptor 'crc32' =&gt; $crc32, //  crc32    'compressedSize' =&gt; $compressedSize, //    'uncompressedSize' =&gt; $uncompressedSize, //    . ]));</span></span></code> </pre> <br><p>  Y en el <b>encabezado del archivo del directorio central (CDFH)</b> solo <b>cambia</b> el <b>generalPurposeBitFlag</b> , el resto de los datos deben ser reales.  Pero esto no es un problema, ya que escribimos <b>CDFH</b> después de todos los datos, y en cualquier caso se conocen hashes con longitudes de datos. </p><br><p>  Esto es todo, por supuesto, bueno.  Solo queda implementar en PHP. <br>  Y la biblioteca estándar de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hash</a> nos ayudará mucho.  Podemos crear un contexto hash en el que será suficiente para rellenar fragmentos con datos y, al final, obtener el valor hash.  Por supuesto, esta solución será algo más engorrosa que el <i>hash ('crc32b', $ content)</i> , pero nos ahorrará una cantidad inimaginable de recursos y tiempo. <br><br>  Se parece a esto: <br><br></p><pre> <code class="php hljs">$hashCtx = hash_init(<span class="hljs-string"><span class="hljs-string">'crc32b'</span></span>); $handle = fopen($source, <span class="hljs-string"><span class="hljs-string">'r'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!feof($handle)) { $chunk = fread($handle, <span class="hljs-number"><span class="hljs-number">8</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>); hash_update($hashCtx, $chunk); $chunk = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } $hash = hash_final($hashCtx);</code> </pre> <br>  Si todo se hace correctamente, el valor no será diferente de <i>hash_file ('crc32b', $ source)</i> o <i>hash ('crc32b', file_get_content ($ source))</i> . <br><br><p>  Intentemos de alguna manera resumir todo esto en una función, para que podamos leer el archivo de una manera conveniente para nosotros, y al final obtener su hash y longitud.  Y los generadores nos ayudarán con esto: <br><br></p><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $path)</span></span></span><span class="hljs-function">: \</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Generator</span></span></span><span class="hljs-function"> </span></span>{ $length = <span class="hljs-number"><span class="hljs-number">0</span></span>; $handle = fopen($path, <span class="hljs-string"><span class="hljs-string">'r'</span></span>); $hashCtx = hash_init(<span class="hljs-string"><span class="hljs-string">'crc32b'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!feof($handle)) { $chunk = fread($handle, <span class="hljs-number"><span class="hljs-number">8</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>); $length += strlen($chunk); hash_update($hashCtx, $chunk); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> $chunk; $chunk = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } fclose($handle); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-string"><span class="hljs-string">'length'</span></span> =&gt; $length, <span class="hljs-string"><span class="hljs-string">'crc32'</span></span> =&gt; hexdec(hash_final($hashCtx))]; }</code> </pre> <br>  y ahora solo podemos <br><br><pre> <code class="php hljs">$reader = read(<span class="hljs-string"><span class="hljs-string">'https://speed.hetzner.de/1GB.bin'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($reader <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $chunk) { <span class="hljs-comment"><span class="hljs-comment">// -   . } //      . ['length' =&gt; $length, 'crc32' =&gt; $crc32] = $reader-&gt;getReturn(); echo round(memory_get_peak_usage(true) / 1024 / 1024, 2) . 'MB - Memory Peak Usage' . PHP_EOL;</span></span></code> </pre> <br>  En mi opinión, es bastante simple y conveniente.  Con un archivo de 1GB, mi consumo máximo de memoria fue de 2MB. <br><p>  Ahora intentemos modificar el código del artículo anterior para que podamos usar esta función. <br><br></p><div class="spoiler">  <b class="spoiler_title">Guión final</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $path)</span></span></span><span class="hljs-function">: \</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Generator</span></span></span><span class="hljs-function"> </span></span>{ $length = <span class="hljs-number"><span class="hljs-number">0</span></span>; $handle = fopen($path, <span class="hljs-string"><span class="hljs-string">'r'</span></span>); $hashCtx = hash_init(<span class="hljs-string"><span class="hljs-string">'crc32b'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!feof($handle)) { $chunk = fread($handle, <span class="hljs-number"><span class="hljs-number">8</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>); $length += strlen($chunk); hash_update($hashCtx, $chunk); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> $chunk; $chunk = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } fclose($handle); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-string"><span class="hljs-string">'length'</span></span> =&gt; $length, <span class="hljs-string"><span class="hljs-string">'crc32'</span></span> =&gt; hexdec(hash_final($hashCtx))]; } $entries = [<span class="hljs-string"><span class="hljs-string">'https://speed.hetzner.de/100MB.bin'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">__FILE__</span></span>]; $destination = <span class="hljs-string"><span class="hljs-string">'test.zip'</span></span>; $handle = fopen($destination, <span class="hljs-string"><span class="hljs-string">'w'</span></span>); $written = <span class="hljs-number"><span class="hljs-number">0</span></span>; $dictionary = []; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($entries <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $entry) { $filename = basename($entry); $fileInfo = [ <span class="hljs-string"><span class="hljs-string">'versionToExtract'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-comment"><span class="hljs-comment">//       Data Descriptor,     00008, //   00000    . 'generalPurposeBitFlag' =&gt; 0x0008, 'compressionMethod' =&gt; 0, 'modificationTime' =&gt; 28021, 'modificationDate' =&gt; 20072, 'crc32' =&gt; 0, 'compressedSize' =&gt; 0, 'uncompressedSize' =&gt; 0, 'filenameLength' =&gt; strlen($filename), 'extraFieldLength' =&gt; 0, ]; $LFH = pack('LSSSSSLLLSSa*', ...array_values([ 'signature' =&gt; 0x04034b50, ] + $fileInfo + ['filename' =&gt; $filename])); $fileOffset = $written; $written += fwrite($handle, $LFH); //     $reader = read($entry); foreach ($reader as $chunk) { //      $written += fwrite($handle, $chunk); $chunk = null; } //       ['length' =&gt; $length, 'crc32' =&gt; $crc32] = $reader-&gt;getReturn(); //    fileInfo,     CDFH $fileInfo['crc32'] = $crc32; $fileInfo['compressedSize'] = $length; $fileInfo['uncompressedSize'] = $length; //  Data Descriptor $DD = pack('LLLL', ...array_values([ 'signature' =&gt; 0x08074b50, 'crc32' =&gt; $fileInfo['crc32'], 'compressedSize' =&gt; $fileInfo['compressedSize'], 'uncompressedSize' =&gt; $fileInfo['uncompressedSize'], ])); $written += fwrite($handle, $DD); $dictionary[$filename] = [ 'signature' =&gt; 0x02014b50, 'versionMadeBy' =&gt; 798, ] + $fileInfo + [ 'fileCommentLength' =&gt; 0, 'diskNumber' =&gt; 0, 'internalFileAttributes' =&gt; 0, 'externalFileAttributes' =&gt; 2176057344, 'localFileHeaderOffset' =&gt; $fileOffset, 'filename' =&gt; $filename, ]; } $EOCD = [ 'signature' =&gt; 0x06054b50, 'diskNumber' =&gt; 0, 'startDiskNumber' =&gt; 0, 'numberCentralDirectoryRecord' =&gt; $records = count($dictionary), 'totalCentralDirectoryRecord' =&gt; $records, 'sizeOfCentralDirectory' =&gt; 0, 'centralDirectoryOffset' =&gt; $written, 'commentLength' =&gt; 0 ]; foreach ($dictionary as $entryInfo) { $CDFH = pack('LSSSSSSLLLSSSSSLLa*', ...array_values($entryInfo)); $written += fwrite($handle, $CDFH); } $EOCD['sizeOfCentralDirectory'] = $written - $EOCD['centralDirectoryOffset']; $EOCD = pack('LSSSSLLS', ...array_values($EOCD)); $written += fwrite($handle, $EOCD); fclose($handle); echo '  : ' . memory_get_peak_usage(true) . ' ' . PHP_EOL; echo '  : ' . $written . ' ' . PHP_EOL; echo '   `unzip -tq ' . $destination . '`: ' . PHP_EOL; echo '&gt; ' . exec('unzip -tq ' . $destination) . PHP_EOL; echo PHP_EOL;</span></span></code> </pre> <br></div></div><br>  En la salida, deberíamos obtener un archivo Zip con el nombre test.zip, en el que habrá un archivo con el script anterior y 100MB.bin, de aproximadamente 100 MB de tamaño. <br><br><h3>  Compresión en archivos zip </h3><br><p>  Ahora tenemos prácticamente todo para comprimir los datos y hacerlo también sobre la marcha. <br>  Del mismo modo que obtenemos un hash al dar pequeños fragmentos a las funciones, también podemos comprimir datos gracias a la maravillosa biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Zlib</a> y sus <i>funciones</i> <i>deflate_init</i> y <i>deflate_add</i> . </p><br><p>  Se parece a esto: <br><br></p><pre> <code class="php hljs">$deflateCtx = deflate_init(ZLIB_ENCODING_RAW, [<span class="hljs-string"><span class="hljs-string">'level'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>]); $handle = fopen($source, <span class="hljs-string"><span class="hljs-string">'r'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!feof($handle)) { $chunk = fread($handle, <span class="hljs-number"><span class="hljs-number">8</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> deflate_add($deflateCtx, $chunk, feof($handle) ? ZLIB_FINISH : ZLIB_SYNC_FLUSH); $chunk = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }</code> </pre> <br>  <i>Conocí una opción como esta que, en comparación con la anterior, agregará algunos ceros al final.</i> <div class="spoiler">  <b class="spoiler_title">Encabezado de spoiler</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!feof($handle)) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> deflate_add($deflateCtx, $chunk, ZLIB_SYNC_FLUSH); } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> deflate_add($deflateCtx, <span class="hljs-string"><span class="hljs-string">''</span></span>, ZLIB_FINISH);</code> </pre> <br></div></div>  <i>Pero descomprimir juró, así que tuve que deshacerme de esa simplificación.</i> <br><br><p>  Arreglemos nuestro <i>lector</i> para que comprima inmediatamente nuestros datos, y al final nos devuelve un hash, la longitud de los datos sin compresión y la longitud de los datos con compresión: <br><br></p><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $path)</span></span></span><span class="hljs-function">: \</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Generator</span></span></span><span class="hljs-function"> </span></span>{ $uncompressedSize = <span class="hljs-number"><span class="hljs-number">0</span></span>; $compressedSize = <span class="hljs-number"><span class="hljs-number">0</span></span>; $hashCtx = hash_init(<span class="hljs-string"><span class="hljs-string">'crc32b'</span></span>); $deflateCtx = deflate_init(ZLIB_ENCODING_RAW, [<span class="hljs-string"><span class="hljs-string">'level'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>]); $handle = fopen($path, <span class="hljs-string"><span class="hljs-string">'r'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!feof($handle)) { $chunk = fread($handle, <span class="hljs-number"><span class="hljs-number">8</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>); hash_update($hashCtx, $chunk); $compressedChunk = deflate_add($deflateCtx, $chunk, feof($handle) ? ZLIB_FINISH : ZLIB_SYNC_FLUSH); $uncompressedSize += strlen($chunk); $compressedSize += strlen($compressedChunk); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> $compressedChunk; $chunk = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; $compressedChunk = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } fclose($handle); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-string"><span class="hljs-string">'uncompressedSize'</span></span> =&gt; $uncompressedSize, <span class="hljs-string"><span class="hljs-string">'compressedSize'</span></span> =&gt; $compressedSize, <span class="hljs-string"><span class="hljs-string">'crc32'</span></span> =&gt; hexdec(hash_final($hashCtx)) ]; }</code> </pre> <br>  y prueba un archivo de 100 mb: <br><br><pre> <code class="php hljs">$reader = read(<span class="hljs-string"><span class="hljs-string">'https://speed.hetzner.de/100MB.bin'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($reader <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $chunk) { <span class="hljs-comment"><span class="hljs-comment">// -   . } ['uncompressedSize' =&gt; $uncompressedSize, 'compressedSize' =&gt; $compressedSize, 'crc32' =&gt; $crc32] = $reader-&gt;getReturn(); echo 'Uncompressed size: ' . $uncompressedSize . PHP_EOL; echo 'Compressed size: ' . $compressedSize . PHP_EOL; echo round(memory_get_peak_usage(true) / 1024 / 1024, 2) . 'MB - Memory Peak Usage' . PHP_EOL;</span></span></code> </pre> <br>  El consumo de memoria todavía muestra que no cargamos todo el archivo en la memoria. <br><br><p>  Pongámoslo todo junto y finalmente obtengamos un archivo de script realmente real. <br>  A diferencia de la versión anterior, nuestro <b>generalPurposeBitFlag</b> cambiará, ahora su valor es <b>0x0018</b> , así como el modo de <b>compresión</b> - <b>8</b> (lo que significa <b>Deflate</b> ). <br><br></p><div class="spoiler">  <b class="spoiler_title">Guión final</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $path)</span></span></span><span class="hljs-function">: \</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Generator</span></span></span><span class="hljs-function"> </span></span>{ $uncompressedSize = <span class="hljs-number"><span class="hljs-number">0</span></span>; $compressedSize = <span class="hljs-number"><span class="hljs-number">0</span></span>; $hashCtx = hash_init(<span class="hljs-string"><span class="hljs-string">'crc32b'</span></span>); $deflateCtx = deflate_init(ZLIB_ENCODING_RAW, [<span class="hljs-string"><span class="hljs-string">'level'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>]); $handle = fopen($path, <span class="hljs-string"><span class="hljs-string">'r'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!feof($handle)) { $chunk = fread($handle, <span class="hljs-number"><span class="hljs-number">8</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>); hash_update($hashCtx, $chunk); $compressedChunk = deflate_add($deflateCtx, $chunk, feof($handle) ? ZLIB_FINISH : ZLIB_SYNC_FLUSH); $uncompressedSize += strlen($chunk); $compressedSize += strlen($compressedChunk); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> $compressedChunk; $chunk = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; $compressedChunk = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } fclose($handle); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-string"><span class="hljs-string">'uncompressedSize'</span></span> =&gt; $uncompressedSize, <span class="hljs-string"><span class="hljs-string">'compressedSize'</span></span> =&gt; $compressedSize, <span class="hljs-string"><span class="hljs-string">'crc32'</span></span> =&gt; hexdec(hash_final($hashCtx)) ]; } $entries = [<span class="hljs-string"><span class="hljs-string">'https://speed.hetzner.de/100MB.bin'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">__FILE__</span></span>]; $destination = <span class="hljs-string"><span class="hljs-string">'test.zip'</span></span>; $handle = fopen($destination, <span class="hljs-string"><span class="hljs-string">'w'</span></span>); $written = <span class="hljs-number"><span class="hljs-number">0</span></span>; $dictionary = []; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($entries <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $entry) { $filename = basename($entry); $fileInfo = [ <span class="hljs-string"><span class="hljs-string">'versionToExtract'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-comment"><span class="hljs-comment">//   ,        0x0018  0x0008 'generalPurposeBitFlag' =&gt; 0x0018, 'compressionMethod' =&gt; 8, //      : 8 - Deflate 'modificationTime' =&gt; 28021, 'modificationDate' =&gt; 20072, 'crc32' =&gt; 0, 'compressedSize' =&gt; 0, 'uncompressedSize' =&gt; 0, 'filenameLength' =&gt; strlen($filename), 'extraFieldLength' =&gt; 0, ]; $LFH = pack('LSSSSSLLLSSa*', ...array_values([ 'signature' =&gt; 0x04034b50, ] + $fileInfo + ['filename' =&gt; $filename])); $fileOffset = $written; $written += fwrite($handle, $LFH); $reader = read($entry); foreach ($reader as $chunk) { $written += fwrite($handle, $chunk); $chunk = null; } [ 'uncompressedSize' =&gt; $uncompressedSize, 'compressedSize' =&gt; $compressedSize, 'crc32' =&gt; $crc32 ] = $reader-&gt;getReturn(); $fileInfo['crc32'] = $crc32; $fileInfo['compressedSize'] = $compressedSize; $fileInfo['uncompressedSize'] = $uncompressedSize; $DD = pack('LLLL', ...array_values([ 'signature' =&gt; 0x08074b50, 'crc32' =&gt; $fileInfo['crc32'], 'compressedSize' =&gt; $fileInfo['compressedSize'], 'uncompressedSize' =&gt; $fileInfo['uncompressedSize'], ])); $written += fwrite($handle, $DD); $dictionary[$filename] = [ 'signature' =&gt; 0x02014b50, 'versionMadeBy' =&gt; 798, ] + $fileInfo + [ 'fileCommentLength' =&gt; 0, 'diskNumber' =&gt; 0, 'internalFileAttributes' =&gt; 0, 'externalFileAttributes' =&gt; 2176057344, 'localFileHeaderOffset' =&gt; $fileOffset, 'filename' =&gt; $filename, ]; } $EOCD = [ 'signature' =&gt; 0x06054b50, 'diskNumber' =&gt; 0, 'startDiskNumber' =&gt; 0, 'numberCentralDirectoryRecord' =&gt; $records = count($dictionary), 'totalCentralDirectoryRecord' =&gt; $records, 'sizeOfCentralDirectory' =&gt; 0, 'centralDirectoryOffset' =&gt; $written, 'commentLength' =&gt; 0 ]; foreach ($dictionary as $entryInfo) { $CDFH = pack('LSSSSSSLLLSSSSSLLa*', ...array_values($entryInfo)); $written += fwrite($handle, $CDFH); } $EOCD['sizeOfCentralDirectory'] = $written - $EOCD['centralDirectoryOffset']; $EOCD = pack('LSSSSLLS', ...array_values($EOCD)); $written += fwrite($handle, $EOCD); fclose($handle); echo '  : ' . memory_get_peak_usage(true) . ' ' . PHP_EOL; echo '  : ' . $written . ' ' . PHP_EOL; echo '   `unzip -tq ' . $destination . '`: ' . PHP_EOL; echo '&gt; ' . exec('unzip -tq ' . $destination) . PHP_EOL; echo PHP_EOL;</span></span></code> </pre> </div></div><br>  Como resultado, obtuve un archivo de 360183 bytes de tamaño (nuestro archivo de 100 MB se comprimió muy bien, lo que probablemente sea solo un conjunto de bytes idénticos), y <i>descomprimir</i> mostró que no se encontraron errores en el archivo. <br><br><h3>  Conclusión </h3><br><p>  Si tengo suficiente energía y tiempo para otro artículo, intentaré mostrar cómo y, lo más importante, por qué se puede usar todo esto. <br><br>  Si está interesado en algo más sobre este tema, sugiéralo en los comentarios, intentaré responder a su pregunta.  Lo más probable es que no tratemos con el cifrado, porque el script ya ha crecido, y en la vida real, según me parece, estos archivos no se usan con mucha frecuencia. </p><br><br><p>  Gracias por su atención y por sus comentarios. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/472966/">https://habr.com/ru/post/472966/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../472956/index.html">La historia de la construcción de un robot oruga</a></li>
<li><a href="../472958/index.html">Cómo crear programas de Windows en Arduino</a></li>
<li><a href="../472960/index.html">La mejor lente de calidad / precio de Sony</a></li>
<li><a href="../472962/index.html">Publicación de video: experimentos como una forma de visualización científica</a></li>
<li><a href="../472964/index.html">Situación: cada vez más empresas de código abierto están cambiando las licencias: discutimos opiniones de expertos</a></li>
<li><a href="../472970/index.html">Críticas al protocolo de Telegram y enfoques organizacionales. Parte 1, técnica: la experiencia de escribir un cliente desde cero - TL, MT</a></li>
<li><a href="../472972/index.html">Trabajamos con cookies como una clase javascript</a></li>
<li><a href="../472978/index.html">Curso de autor Arduino para su propio hijo</a></li>
<li><a href="../472980/index.html">Pantalones cortos Belokamentseva</a></li>
<li><a href="../472982/index.html">“Escucha para encontrar un desglose”: se publican grabaciones de audio de máquinas industriales fallidas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>