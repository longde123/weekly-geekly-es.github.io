<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§¥ üèæ üë®üèæ‚Äçüöí Qt wrapper alrededor del marco gRPC en C ++ üë®üèª‚Äçüíª ‚úçüèº üßùüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola a todos Hoy veremos c√≥mo puede vincular el marco gRPC en C ++ y la biblioteca Qt. El art√≠culo proporciona un c√≥digo que resume el uso de los cuat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Qt wrapper alrededor del marco gRPC en C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420237/"><p>  Hola a todos  Hoy veremos c√≥mo puede vincular el marco gRPC en C ++ y la biblioteca Qt.  El art√≠culo proporciona un c√≥digo que resume el uso de los cuatro modos de interacci√≥n en gRPC.  Adem√°s, se proporciona un c√≥digo que permite el uso de gRPC a trav√©s de se√±ales y ranuras Qt.  El art√≠culo puede ser de inter√©s principalmente para los desarrolladores de Qt interesados ‚Äã‚Äãen usar gRPC.  Sin embargo, una generalizaci√≥n de los cuatro modos operativos de gRPC est√° escrita en C ++ sin usar Qt, lo que permitir√° a los desarrolladores que no est√°n relacionados con Qt adaptar el c√≥digo.  Le pregunto a todos los interesados ‚Äã‚Äãbajo cat. </p><a name="habracut"></a><br><h2>  Antecedentes </h2><br><p>  Hace unos seis meses, dos proyectos me colgaron, usando las partes cliente y servidor de gRPC.  Ambos proyectos cayeron en producci√≥n.  Estos proyectos fueron escritos por desarrolladores que ya han renunciado.  La √∫nica buena noticia fue que particip√© activamente en la escritura del servidor gRPC y el c√≥digo del cliente.  Pero eso fue hace aproximadamente un a√±o.  Por lo tanto, como siempre, tuve que lidiar con todo desde cero. </p><br><p>  El c√≥digo del servidor gRPC se escribi√≥ con la expectativa de que el archivo .proto lo generar√° a√∫n m√°s.  El c√≥digo fue bien escrito.  Sin embargo, el servidor ten√≠a un gran inconveniente: solo un cliente pod√≠a conectarse a √©l. </p><br><p>  El cliente gRPC fue escrito simplemente horrible. </p><br><p>  Descubr√≠ el c√≥digo de cliente y servidor gRPC solo unos d√≠as despu√©s.  Y me di cuenta de que si tomaba un proyecto durante un par de semanas, tendr√≠a que volver a tratar con el servidor y el cliente gRPC. </p><br><p>  Fue entonces cuando decid√≠ que era hora de escribir y depurar el cliente y el servidor gRPC para que: </p><br><ul><li><p>  Podr√≠as dormir tranquilo por la noche; </p></li><li><p>  No era necesario recordar c√≥mo funciona esto cada vez que necesita escribir un cliente o servidor gRPC; </p></li><li><p>  Puede usar el cliente y servidor gRPC escrito en otros proyectos. </p></li></ul><br><p>  Al escribir c√≥digo, me guiaron los siguientes requisitos: </p><br><ul><li><p>  Tanto el cliente como el servidor gRPC pueden operar utilizando las se√±ales y ranuras de la biblioteca Qt de forma natural; </p></li><li><p>  El c√≥digo de cliente y servidor gRPC no necesita repararse al cambiar el archivo .proto; </p></li><li><p>  El cliente gRPC deber√≠a poder indicarle al c√≥digo del cliente el estado de la conexi√≥n al servidor. </p></li></ul><br><p>  La estructura del art√≠culo es la siguiente.  Primero, habr√° una breve descripci√≥n de los resultados de trabajar con el c√≥digo del cliente y algunas explicaciones.  Al final de la revisi√≥n, un enlace al repositorio.  Adem√°s habr√° cosas generales sobre arquitectura.  Luego, una descripci√≥n del c√≥digo del servidor y del cliente (lo que est√° debajo del cap√≥) y una conclusi√≥n. </p><br><h2>  Breve rese√±a </h2><br><p>  El archivo pingproto.proto m√°s simple se us√≥ como un archivo .proto, en el que se definieron los RPC de todos los tipos de interacci√≥n: </p><br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">syntax</span></span> = <span class="hljs-string"><span class="hljs-string">"proto3"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">package</span></span> pingpong; <span class="hljs-attribute"><span class="hljs-attribute">service</span></span> ping { <span class="hljs-attribute"><span class="hljs-attribute">rpc</span></span> SayHello (PingRequest) returns (PingReply) {} <span class="hljs-attribute"><span class="hljs-attribute">rpc</span></span> GladToSeeMe(PingRequest) returns (stream PingReply){} <span class="hljs-attribute"><span class="hljs-attribute">rpc</span></span> GladToSeeYou(stream PingRequest) returns (PingReply){} <span class="hljs-attribute"><span class="hljs-attribute">rpc</span></span> BothGladToSee(stream PingRequest) returns (stream PingReply){} } <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> PingRequest { <span class="hljs-attribute"><span class="hljs-attribute">string</span></span> name = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">string</span></span> message = <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> PingReply { <span class="hljs-attribute"><span class="hljs-attribute">string</span></span> message = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><p>  El archivo pingpong.proto repite el archivo helloworld.proto del art√≠culo sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">modos asincr√≥nicos de gRPC en C ++</a> con el nombre exacto. </p><br><p>  Como resultado, un servidor escrito se puede usar as√≠: </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QObject { Q_OBJECT; QpingServerService pingservice; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: A() { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_ok; is_ok = connect(&amp;pingservice, SIGNAL(SayHelloRequest(SayHelloCallData*)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, SLOT(onSayHello(SayHelloCallData*))); assert(is_ok); is_ok = connect(&amp;pingservice, SIGNAL(GladToSeeMeRequest(GladToSeeMeCallData*)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, SLOT(onGladToSeeMe(GladToSeeMeCallData*))); assert(is_ok); is_ok = connect(&amp;pingservice, SIGNAL(GladToSeeYouRequest(GladToSeeYouCallData*)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, SLOT(onGladToSeeYou(GladToSeeYouCallData*))); assert(is_ok); is_ok = connect(&amp;pingservice, SIGNAL(BothGladToSeeRequest(BothGladToSeeCallData*)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, SLOT(onBothGladToSee(BothGladToSeeCallData*))); assert(is_ok); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> slots: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSayHello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SayHelloCallData* cd)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"["</span></span> &lt;&lt; cd-&gt;peer() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"][11]: request: "</span></span> &lt;&lt; cd-&gt;request.name() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; cd-&gt;reply.set_message(<span class="hljs-string"><span class="hljs-string">"hello "</span></span> + cd-&gt;request.name()); cd-&gt;Finish(); } <span class="hljs-comment"><span class="hljs-comment">//etc. };</span></span></code> </pre><br><p>  Cuando un cliente llama a RPC, el servidor gRPC notifica el c√≥digo del cliente (en este caso, clase A) con la se√±al adecuada. </p><br><p>  El cliente gRPC se puede usar as√≠: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> B : <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> QObject { Q_OBJECT QpingClientService pingPongSrv; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span>: B() { <span class="hljs-type"><span class="hljs-type">bool</span></span> c = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; c = <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(&amp;pingPongSrv, SIGNAL(SayHelloResponse(SayHelloCallData*)), this, SLOT(onSayHelloResponse(SayHelloCallData*))); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(c); c = <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(&amp;pingPongSrv, SIGNAL(GladToSeeMeResponse(GladToSeeMeCallData*)), this, SLOT(onGladToSeeMeResponse(GladToSeeMeCallData*))); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(c); c = <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(&amp;pingPongSrv, SIGNAL(GladToSeeYouResponse(GladToSeeYouCallData*)), this, SLOT(onGladToSeeYouResponse(GladToSeeYouCallData*))); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(c); c = <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(&amp;pingPongSrv, SIGNAL(BothGladToSeeResponse(BothGladToSeeCallData*)), this, SLOT(onBothGladToSeeResponse(BothGladToSeeCallData*))); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(c); c = <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(&amp;pingPongSrv, SIGNAL(channelStateChanged(<span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span>)), this, SLOT(onPingPongStateChanged(<span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span>))); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(c); } <span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">usage</span></span>() { //Unary PingRequest request; request.set_name("user"); request.set_message("user"); pingPongSrv.SayHello(request); //<span class="hljs-keyword"><span class="hljs-keyword">Server</span></span> streaming PingRequest request2; request2.set_name("user"); pingPongSrv.GladToSeeMe(request2); //etc. } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> slots: <span class="hljs-type"><span class="hljs-type">void</span></span> SayHelloResponse(SayHelloCallData* response) { std::cout &lt;&lt; "[11]: reply: " &lt;&lt; response-&gt;reply.message() &lt;&lt; std::endl; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response-&gt;CouldBeDeleted()) <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> response; } //etc. };</code> </pre><br><p>  El cliente gRPC le permite llamar a RPC directamente y suscribirse a la respuesta del servidor utilizando las se√±ales apropiadas. </p><br><p>  El cliente gRPC tambi√©n tiene una se√±al: <br><br></p><pre> <code class="hljs objectivec">channelStateChanged(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>);</code> </pre><br>  que informa sobre los estados de conexi√≥n del servidor pasados ‚Äã‚Äãy actuales.  Todo el c√≥digo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">muestra</a> est√° en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el repositorio qgrpc</a> . <br><br><h2>  Como funciona </h2><br><p>  El principio de incluir el cliente y el servidor gRPC en el proyecto se muestra en la figura. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/i3/h9/ad/i3h9ad3c3joddotb7akq1iagpnc.jpeg"></div><br><p>  En el archivo de proyecto .pro, se especifican los archivos .proto, en funci√≥n de los cuales funcionar√° gRPC.  El archivo grpc.pri contiene comandos para generar archivos gRPC y QgRPC.  El compilador de protocolos genera archivos gRPC [protofile] .grpc.pb.h y [protofile] .grpc.pb.cc.  [protofile] es el nombre del archivo .proto pasado a la entrada del compilador. </p><br><p>  La generaci√≥n de archivos QgRPC [protofile] .qgrpc. [Config] .h es manejada por el script genQGrpc.py.  [config] es "servidor" o "cliente". <br><br>  Los archivos QgRPC generados contienen un contenedor Qt alrededor de las clases gRPC y las llamadas con las se√±ales correspondientes.  En los ejemplos anteriores, las clases QpingServerService y QpingClientService se declaran en los archivos generados pingpong.qgrpc.server.h y pingpong.qgrpc.client.h respectivamente.  Los archivos QgRPC generados se agregan al procesamiento moc. </p><br><p>  En los archivos QgRPC generados, se incluyen los archivos QGrpc [config] .h, en los que se lleva a cabo todo el trabajo principal.  Lea m√°s sobre esto a continuaci√≥n. </p><br><p>  Para conectar toda esta construcci√≥n al proyecto, debe incluir el archivo grpc.pri en el archivo .pro del proyecto y especificar tres variables.  La variable GRPC define archivos .proto que se transferir√°n a las entradas del compilador de protocolos y el script genQGrpc.py.  La variable QGRPC_CONFIG define el valor de configuraci√≥n de los archivos QgRPC generados y puede contener los valores "servidor" o "cliente".  Tambi√©n puede definir la variable opcional GRPC_VERSION para indicar la versi√≥n de gRPC. </p><br><p>  Para obtener m√°s informaci√≥n sobre todo lo dicho, lea el archivo grpc.pri y los archivos de ejemplo .pro. </p><br><h2>  Arquitectura del servidor </h2><br><p>  El diagrama de clase del servidor se muestra en la figura. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nd/ec/ae/ndecaezqpvmh1kn9iviw6yuic9i.jpeg"></div><br><p>  Las flechas gruesas muestran la jerarqu√≠a de la herencia de clases, y las flechas delgadas muestran la membres√≠a de miembros y m√©todos en las clases.  En general, la clase Q [servicename] ServerService se genera para el servicio, donde servicename es el nombre del servicio declarado en el archivo .proto.  RPCCallData son estructuras de control generadas para cada RPC en el servicio.  En el constructor de la clase QpingServerService, la clase base QGrpcServerService se inicializa con el servicio asincr√≥nico pingpong :: ping :: AsyncService de gRPC.  Para iniciar el servicio, debe llamar al m√©todo Start () con la direcci√≥n y el puerto en el que se ejecutar√° el servicio.  La funci√≥n Start () implementa el procedimiento est√°ndar para iniciar un servicio. </p><br><p>  Al final de la funci√≥n Start (), se llama a la funci√≥n virtual pura makeRequests (), que se implementa en la clase QpingServerService generada: </p><br><pre> <code class="hljs xml">void makeRequests() { needAnotherCallData<span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">SayHello_RPCtypes</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">SayHelloCallData</span></span></span><span class="hljs-tag"> &gt;</span></span>(); needAnotherCallData<span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">GladToSeeMe_RPCtypes</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">GladToSeeMeCallData</span></span></span><span class="hljs-tag"> &gt;</span></span>(); needAnotherCallData<span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">GladToSeeYou_RPCtypes</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">GladToSeeYouCallData</span></span></span><span class="hljs-tag"> &gt;</span></span>(); needAnotherCallData<span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">BothGladToSee_RPCtypes</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">BothGladToSeeCallData</span></span></span><span class="hljs-tag"> &gt;</span></span>(); }</code> </pre><br><p>  El segundo par√°metro de plantilla de la funci√≥n needAnotherCallData son las estructuras RPCCallData generadas.  Las mismas estructuras son los par√°metros de las se√±ales en la clase Qt generada del servicio. </p><br><p>  Las estructuras RPCCallData generadas heredan de la clase ServerCallData.  A su vez, la clase ServerCallData se hereda del servidor de respuesta ServerResponder.  Por lo tanto, la creaci√≥n de un objeto de estructuras coherentes conduce a la creaci√≥n de un objeto respondedor. </p><br><p>  El constructor para la clase ServerCallData toma dos par√°metros: signal_func y request_func.  signal_func es una se√±al generada que se llama despu√©s de recibir una etiqueta de la cola.  request_func es una funci√≥n que deber√≠a llamarse al crear un nuevo respondedor.  Por ejemplo, en este caso puede ser la funci√≥n RequestSayHello ().  La llamada request_func ocurre en la funci√≥n needAnotherCallData ().  Esto se hace para que la gesti√≥n de los encuestados (creaci√≥n y eliminaci√≥n) tenga lugar en el servicio. </p><br><p>  El c√≥digo de la funci√≥n needAnotherCallData () consiste en crear un objeto respondedor y llamar a una funci√≥n que conecta al respondedor a una llamada RPC: </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RPCCallData</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RPCTypes</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">needAnotherCallData</span></span></span><span class="hljs-class">() {</span></span> RPCCallData* cd = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RPCCallData(); <span class="hljs-comment"><span class="hljs-comment">//... RequestRPC&lt;RPCTypes::kind, ...&gt; (service_, cd-&gt;request_func_, cd-&gt;responder, ..., (void*)cd); }</span></span></code> </pre><br><p>  Las funciones RequestRPC () son funciones de plantilla para cuatro tipos de interacci√≥n.  Como resultado, llamar a RequestRPC () se reduce a una llamada: </p><br><pre> <code class="hljs lisp">service_-&gt;(<span class="hljs-name"><span class="hljs-name">cd-&gt;request_func_</span></span>)(...,cd-&gt;responder, (<span class="hljs-name"><span class="hljs-name">void*</span></span>)cd)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br><p>  donde service_ es el servicio gRPC.  En este caso, es pingpong :: ping :: AsyncService. </p><br><p>  Para verificar de forma sincr√≥nica o asincr√≥nica la cola de eventos, debe llamar a las funciones CheckCQ () o AsyncCheckCQ (), respectivamente.  El c√≥digo de la funci√≥n CheckCQ () se reduce a las llamadas a la etiqueta s√≠ncrona desde la cola y el procesamiento de esta etiqueta: </p><br><pre> <code class="hljs pgsql">virtual <span class="hljs-type"><span class="hljs-type">void</span></span> CheckCQ() override { <span class="hljs-type"><span class="hljs-type">void</span></span>* tag; <span class="hljs-type"><span class="hljs-type">bool</span></span> ok; server_cq_-&gt;Next(&amp;tag, &amp;ok); //tagActions_ <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!tag) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; AbstractCallData* cd = (AbstractCallData*)tag; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!started_.<span class="hljs-keyword"><span class="hljs-keyword">load</span></span>()) { destroyCallData(cd); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } cd-&gt;cqReaction(this, ok); }</code> </pre><br><p>  Despu√©s de recibir la etiqueta de la cola, se verifica la validez de la etiqueta y el inicio del servidor.  Si el servidor est√° apagado, la etiqueta ya no es necesaria; se puede eliminar.  Despu√©s de eso, la funci√≥n cqReaction () definida en la clase ServerCallData se llama: </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cqReaction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QGrpcServerService* service_, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ok)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!first_time_reaction_) { first_time_reaction_ = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; service_-&gt;needAnotherCallData&lt;RPC, RPCCallData&gt;(); } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> genRpcCallData = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;RPCCallData*&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* tag = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*&gt;(genRpcCallData); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;CouldBeDeleted()) { service_-&gt;destroyCallData(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;processEvent(tag, ok)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-comment"><span class="hljs-comment">//call generated service signal with generated call data argument service_-&gt;(*signal_func_)(genRpcCallData); }</span></span></code> </pre><br><p>  El indicador first_time_reaction_ indica que necesita crear un nuevo respondedor para el RPC llamado.  Las funciones couldBeDeleted () y ProcessEvent () se heredan de la clase de respuesta ServerResponder correspondiente.  La funci√≥n couldBeDeleted () devuelve una se√±al de que el objeto de respuesta puede ser eliminado.  La funci√≥n processEvent () procesa la etiqueta y el indicador ok.  Entonces, por ejemplo, para un respondedor de tipo Streaming de cliente, la funci√≥n se ve as√≠: </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* tag, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ok</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;tag_ = tag; read_mode_ = ok; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br><p>  La funci√≥n ProcessEvent (), independientemente del tipo de respondedor, siempre devuelve verdadero.  El valor de retorno de esta funci√≥n se deja para una posible extensi√≥n de funcionalidad y, en teor√≠a, para eliminar errores. </p><br><p>  Despu√©s de procesar el evento, la llamada sigue: <br><br></p><pre> <code class="hljs lisp">service_-&gt;(<span class="hljs-name"><span class="hljs-name">*signal_func_</span></span>)(<span class="hljs-name"><span class="hljs-name">genRpcCallData</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br><p>  La variable service_ es una instancia del servicio generado, en nuestro caso QpingServerService.  La variable signal_func_ es una se√±al de servicio correspondiente a un RPC espec√≠fico.  Por ejemplo, SayHelloRequest ().  La variable genRpcCallData es un objeto de respuesta del tipo correspondiente.  Desde el punto de vista del c√≥digo de llamada, la variable genRpcCallData es un objeto de una de las estructuras RPCCallData generadas. <br></p><br><h2>  Arquitectura del cliente </h2><br><p>  Siempre que sea posible, los nombres de las clases y funciones del cliente coinciden con los nombres de las clases y funciones del servidor.  El diagrama de clase del cliente se muestra en la figura. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4u/ak/xe/4uakxee1iettn1zm_7fooerdosc.jpeg"></div><br><p>  Las flechas gruesas muestran la jerarqu√≠a de la herencia de clases, y las flechas delgadas muestran la membres√≠a de miembros y m√©todos en las clases.  En general, para el servicio, se genera la clase Q [servicename] ClientService, donde servicename es el nombre del servicio declarado en el archivo .proto.  RPCCallData son estructuras de control generadas para cada RPC en el servicio.  Para llamar a un RPC, la clase generada proporciona funciones cuyos nombres coinciden exactamente con el RPC declarado en el archivo .proto.  En nuestro ejemplo, en el archivo .proto RPC, SayHello () se declara como: <br><br></p><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">rpc </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SayHello</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PingRequest</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returns</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PingReply</span></span></span><span class="hljs-function">)</span></span> {}</code> </pre><br><p>  En la clase QpingClientService generada, la funci√≥n RPC correspondiente se ve as√≠: </p><br><pre> <code class="hljs vbscript">void SayHello(PingRequest <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!connected()) return; SayHelloCallData* <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SayHelloCallData; <span class="hljs-keyword"><span class="hljs-keyword">call</span></span>-&gt;<span class="hljs-built_in"><span class="hljs-built_in">request</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">call</span></span>-&gt;responder = stub_-&gt;AsyncSayHello(&amp;<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>-&gt;context, <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>, &amp;cq_); <span class="hljs-keyword"><span class="hljs-keyword">call</span></span>-&gt;responder-&gt;Finish(&amp;<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>-&gt;reply, &amp;<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>-&gt;status, (void*)<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>); }</code> </pre><br><p>  Las estructuras RPCCallData generadas, como en el caso del servidor, finalmente se heredan de la clase ClientResponder.  Por lo tanto, la creaci√≥n de un objeto de la estructura generada conduce a la creaci√≥n de un respondedor.  Despu√©s de crear el respondedor, se llama al RPC y el respondedor se asocia con el evento de recibir una respuesta del servidor.  En t√©rminos de c√≥digo de cliente, una llamada RPC se ve as√≠: </p><br><pre> <code class="hljs vbscript">void ToSayHello() { PingRequest <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>.set_name(<span class="hljs-string"><span class="hljs-string">"user"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>.set_message(<span class="hljs-string"><span class="hljs-string">"user"</span></span>); pingPongSrv.SayHello(<span class="hljs-built_in"><span class="hljs-built_in">request</span></span>); }</code> </pre><br><p>  A diferencia de la clase de servidor QpingServerService generada, la clase QpingClientService hereda de dos clases de plantilla: ConnectivityFeatures y MonitorFeatures. </p><br><p>  La clase ConnectivityFeatures es responsable del estado de la conexi√≥n cliente-servidor y proporciona tres funciones para su uso: grpc_connect (), grpc_disconnect (), grpc_reconnect ().  La funci√≥n grpc_disconnect () simplemente elimina todas las estructuras de datos responsables de interactuar con el servidor.  La llamada a grpc_connect se reduce a llamadas a la funci√≥n grpc_connect_ (), que crea estructuras de datos de control: </p><br><pre> <code class="hljs php">void grpc_connect_() { channel_ = grpc::CreateChannel(target_, creds_); stub_ = GRPCService::NewStub(channel_); channelFeatures_ = std::make_unique&lt;ChannelFeatures&gt;(channel_); channelFeatures_-&gt;checkChannelState(); }</code> </pre><br><p>  La clase ChannelFeatures supervisa el estado de la comunicaci√≥n <em>channel_</em> channel con el servidor.  La clase ConnectivityFeatures encapsula un objeto de la clase ChannelFeatures e implementa las funciones abstractas channelState (), checkChannelState () y conectado () utilizando este objeto.  La funci√≥n channelState () devuelve el √∫ltimo estado observado del canal de comunicaci√≥n con el servidor.  La funci√≥n checkChannelState (), de hecho, devuelve el estado actual del canal.  La funci√≥n connected () devuelve el signo del cliente que se conecta al servidor. <br></p><br><p>  La clase MonitorFeatures es responsable de recibir y procesar eventos del servidor y proporciona la funci√≥n CheckCQ () para su uso: </p><br><pre> <code class="hljs ruby">bool CheckCQ() { auto service<span class="hljs-number"><span class="hljs-number">_</span></span> = dynamic_cast&lt; SERVICE* &gt;(this); <span class="hljs-regexp"><span class="hljs-regexp">//connection</span></span> state auto old_state = conn<span class="hljs-number"><span class="hljs-number">_</span></span>-&gt;channelState(); auto new_state = conn<span class="hljs-number"><span class="hljs-number">_</span></span>-&gt;checkChannelState(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (old_state != new_state) service-&gt;*channelStateChangedSignal<span class="hljs-number"><span class="hljs-number">_</span></span>(old_state, new_state); <span class="hljs-regexp"><span class="hljs-regexp">//end</span></span> of connection state void* tag; bool ok = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; grpc::CompletionQueue::NextStatus st; st = cq<span class="hljs-number"><span class="hljs-number">_</span></span>.AsyncNext(&amp;tag, &amp;ok, deadlineFromMSec(<span class="hljs-number"><span class="hljs-number">100</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((st == grpc::CompletionQueue::SHUTDOWN) <span class="hljs-params"><span class="hljs-params">||</span></span> (st == grpc::CompletionQueue::TIMEOUT)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; (AbstractCallData&lt; SERVICE &gt;*)(tag)-&gt;cqActions(service<span class="hljs-number"><span class="hljs-number">_</span></span>, ok); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br><p>  La estructura del c√≥digo es la misma que en el caso del servidor.  A diferencia del servidor, se agrega al cliente un bloque de c√≥digo responsable de procesar el estado actual.  Si el estado del canal de comunicaci√≥n ha cambiado, se llama a la se√±al channelStateChangedSignal_ ().  En todos los servicios generados, esta es una se√±al: <br><br></p><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">channelStateChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  Adem√°s, a diferencia del servidor, la funci√≥n AsyncNext () se usa aqu√≠ en lugar de Next ().  Esto se ha hecho por varias razones.  En primer lugar, cuando se utiliza AsyncNext (), el c√≥digo del cliente tiene la capacidad de aprender sobre el cambio en el estado del canal de comunicaci√≥n.  En segundo lugar, cuando se utiliza AsyncNext (), es posible llamar a varios RPC en el c√≥digo del cliente varias veces.  El uso de la funci√≥n Next () en este caso bloquear√° el hilo hasta que se reciba un evento de la cola y, como resultado, perder√° las dos caracter√≠sticas descritas. <br><br><p>  Despu√©s de recibir el evento desde la cola, como en el caso del servidor, la funci√≥n cqReaction (), definida en la clase ClientCallData, se llama: </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cqActions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RPC::Service* service, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ok)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> response = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;RPCCallData*&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* tag = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*&gt;(response); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;processEvent(tag, ok)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; service-&gt;*func_( response ); }</code> </pre><br><p>  Al igual que con el servidor, la funci√≥n processEvent () procesa la etiqueta y el indicador ok y siempre devuelve verdadero.  Como en el caso del servidor, despu√©s de procesar el evento, se debe llamar a la se√±al del servicio generado.  Sin embargo, hay dos diferencias significativas con respecto a la funci√≥n del servidor del mismo nombre.  La primera diferencia es que los respondedores no se crean en esta funci√≥n.  La creaci√≥n de respondedores, como se muestra arriba, ocurre cuando se llama al RPC.  La segunda diferencia es que los respondedores no se eliminan en esta funci√≥n.  La ausencia de la eliminaci√≥n de los respondedores se realiza por dos razones.  Primero, el c√≥digo del cliente puede usar punteros para generar estructuras RPCCallData para sus propios fines.  Eliminar el contenido de este puntero, oculto del c√≥digo del cliente, puede tener consecuencias desagradables.  En segundo lugar, la eliminaci√≥n del respondedor conducir√° al hecho de que no se generar√° una se√±al con datos.  Por lo tanto, el c√≥digo del cliente no recibir√° el √∫ltimo mensaje del servidor.  Entre varias alternativas para resolver los problemas indicados, se tom√≥ la decisi√≥n de cambiar la eliminaci√≥n del respondedor (estructuras generadas) al c√≥digo del cliente.  Por lo tanto, las funciones del controlador de se√±al (ranuras) deben contener el siguiente c√≥digo: </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResponseHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RPCCallData* response)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response-&gt;CouldBeDeleted()) <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> response; <span class="hljs-comment"><span class="hljs-comment">//process response }</span></span></code> </pre><br><p>  La ausencia de la eliminaci√≥n del respondedor en el c√≥digo del cliente conducir√° no solo a una p√©rdida de memoria, sino tambi√©n a posibles problemas con el canal de comunicaci√≥n.  Los manejadores de se√±ales de todo tipo de interacciones RPC se implementan en el c√≥digo de muestra. </p><br><h2>  Conclusi√≥n </h2><br><p>  En conclusi√≥n, llamamos la atenci√≥n sobre dos puntos.  El primer punto est√° relacionado con la llamada a las funciones CheckCQ () del cliente y el servidor.  Funcionan, como se muestra arriba, de acuerdo con un principio: si hay un evento en la cola, se emite una se√±al con la estructura RPCCallData generada correspondiente.  Puede llamar a esta funci√≥n manualmente y verificar (en el caso de un cliente) un evento.  Pero inicialmente hubo una idea de transferir toda la parte de la red asociada con gRPC a otro hilo.  Para estos fines, se escribieron las clases auxiliares QGrpcSrvMonitor para el servidor gRPC y QGrpcCliServer para el cliente gRPC.  Ambas clases funcionan seg√∫n el mismo principio: crean una secuencia separada, colocan el servicio generado en esta secuencia y llaman peri√≥dicamente a la funci√≥n CheckCQ () de este servicio.  Por lo tanto, cuando se usan ambas clases auxiliares, no hay necesidad de llamar a las funciones CheckCQ () en el c√≥digo del cliente.  Las se√±ales del servicio generado, en este caso, "provienen" de otro flujo.  Los ejemplos de cliente y servidor se implementan utilizando estas clases auxiliares. </p><br><p>  El segundo punto concierne a la mayor√≠a de los desarrolladores que no usan la biblioteca Qt en su trabajo.  Las clases Qt y las macros en QgRPC se usan solo en dos lugares: en archivos de servicio generados y en archivos que contienen clases auxiliares: QGrpcServerMonitor.h y QGrpcClientMonitor.h.  Los archivos restantes con la biblioteca Qt no est√°n asociados de ninguna manera.  Se plane√≥ agregar el ensamblaje usando cmake y tropezar algunas directivas Qt.  En particular, la clase QObject y la macro Q_OBJECT.  Pero las manos simplemente no llegaron a esto.  Por lo tanto, cualquier sugerencia es bienvenida. </p><br><p>  Eso es todo.  Gracias a todos! </p><br><h2>  Referencias </h2><br><ul><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Repositorio con C√≥digo QgRPC</a> </p></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GRPC as√≠ncrono en C ++</a> </p></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es420237/">https://habr.com/ru/post/es420237/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es420225/index.html">Melod√≠a algor√≠tmica infinita basada en n√∫meros primos</a></li>
<li><a href="../es420227/index.html">El presidente turco anuncia la prohibici√≥n de importar productos electr√≥nicos en EE. UU.</a></li>
<li><a href="../es420229/index.html">¬øPueden los ni√±os de las aldeas convertirse en programadores si en las cercan√≠as solo ense√±an trabajadores ferroviarios? Conversaci√≥n con el "C√≠rculo"</a></li>
<li><a href="../es420233/index.html">UE4 | Equipo para multijugador # 5 | Transferencia de informaci√≥n entre servidor y cliente</a></li>
<li><a href="../es420235/index.html">Zenject: c√≥mo un contenedor de IoC puede matar la inyecci√≥n de dependencia en su proyecto</a></li>
<li><a href="../es420239/index.html">Desarrollo m√≥vil. Swift: el misterio de los protocolos</a></li>
<li><a href="../es420243/index.html">Filantrop√≠a revolucionaria: proyectos humanitarios innovadores</a></li>
<li><a href="../es420245/index.html">C√≥mo evitar el desbordamiento de memoria al usar colecciones Java</a></li>
<li><a href="../es420251/index.html">Apple afirma que el complejo de la sede de la compa√±√≠a cuesta solo $ 200</a></li>
<li><a href="../es420253/index.html">C√≥mo las API de banca abierta est√°n cambiando el mundo financiero</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>