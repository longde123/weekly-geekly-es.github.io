<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚¨ÖÔ∏è üéØ üî∂ Optimisation du travail avec des prototypes dans les moteurs JavaScript üèóÔ∏è üë®üèø‚Äçü§ù‚Äçüë®üèæ üëá</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le mat√©riel, dont nous publions la traduction aujourd'hui, a √©t√© pr√©par√© par Matthias Binens et Benedict Meirer. Ils travaillent sur le moteur V8 JS d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimisation du travail avec des prototypes dans les moteurs JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/422321/">  Le mat√©riel, dont nous publions la traduction aujourd'hui, a √©t√© pr√©par√© par Matthias Binens et Benedict Meirer.  Ils travaillent sur le moteur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V8</a> JS de Google.  Cet article est consacr√© √† certains m√©canismes de base qui sont caract√©ristiques non seulement pour le V8, mais aussi pour d'autres moteurs.  La connaissance de la structure interne de ces m√©canismes permet aux personnes impliqu√©es dans le d√©veloppement de JavaScript de mieux naviguer les probl√®mes de performances du code.  En particulier, nous parlerons ici des caract√©ristiques des pipelines d'optimisation du moteur et de la fa√ßon d'acc√©l√©rer l'acc√®s aux propri√©t√©s des prototypes d'objets. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/za/lq/gg/zalqgg3vwvoc-wprqwob9r0fosq.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Niveaux d'optimisation de code et compromis</font> </h2><br>  Le processus de conversion des textes des programmes √©crits en JavaScript en code appropri√© pour l'ex√©cution est approximativement le m√™me dans diff√©rents moteurs. <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/534/0ab/f1e/5340abf1e4b0dfa64f1e2bb294765560.png"></div> <i><font color="#999999">Le processus de conversion du code source JS en code ex√©cutable</font></i> <br><br>  Les d√©tails peuvent √™tre trouv√©s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  En outre, il convient de noter que bien que, √† un niveau √©lev√©, les pipelines de conversion du code source en ex√©cutable soient tr√®s similaires pour diff√©rents moteurs, leurs syst√®mes d'optimisation de code diff√®rent souvent.  Pourquoi en est-il ainsi?  Pourquoi certains moteurs ont-ils plus de niveaux d'optimisation que d'autres?  Il s'av√®re que les moteurs doivent compromettre d'une mani√®re ou d'une autre, ce qui consiste en ce qu'ils peuvent soit g√©n√©rer rapidement du code qui n'est pas le plus efficace mais adapt√© √† l'ex√©cution, ou passer plus de temps √† cr√©er un tel code, mais pour cette raison, atteindre des performances optimales. <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c56/e35/973/c56e359735f983dae9b32294192bd26d.png"></div>  <i><font color="#999999">Pr√©paration rapide du code pour l'ex√©cution et code optimis√© qui prend plus de temps mais s'ex√©cute plus rapidement</font></i> <br><br>  L'interpr√©teur est capable de g√©n√©rer rapidement du bytecode, mais un tel code n'est g√©n√©ralement pas tr√®s efficace.  Le compilateur d'optimisation, en revanche, a besoin de plus de temps pour g√©n√©rer le code, mais au final, il obtient un code machine optimis√© et plus rapide. <br><br>  C'est ce mod√®le de pr√©paration du code pour l'ex√©cution qui est utilis√© dans la V8.  L'interpr√©teur V8 s'appelle Ignition, c'est le plus rapide des interpr√®tes existants (en termes d'ex√©cution du bytecode source).  Le compilateur d'optimisation V8 est appel√© TurboFan, qui est responsable de la cr√©ation de code machine hautement optimis√©. <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e2b/624/62a/e2b62462a5f2563b27a6c362d031b7f2.png"></div>  <i><font color="#999999">Interpr√©teur d'allumage et compilateur d'optimisation TurboFan</font></i> <br><br>  Le compromis entre le retard dans le d√©marrage du programme et la vitesse d'ex√©cution est la raison pour laquelle certains moteurs JS ont des niveaux d'optimisation suppl√©mentaires.  Par exemple, dans SpiderMonkey, entre l'interpr√©teur et le compilateur d'optimisation IonMonkey, il existe un niveau interm√©diaire repr√©sent√© par le compilateur de base (il est appel√© ¬´The Baseline Compiler¬ª dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation de</a> Mozilla, mais ¬´baseline¬ª n'est pas un nom propre). <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c8/212/702/0c821270298b4860ab99918d2dd575a3.png"></div>  <i><font color="#999999">Niveaux d'optimisation du code SpiderMonkey</font></i> <br><br>  L'interpr√©teur g√©n√®re rapidement du bytecode, mais ce code est ex√©cut√© relativement lentement.  Le compilateur de base prend plus de temps pour g√©n√©rer le code, mais ce code est d√©j√† plus rapide.  Enfin, l'optimisation du compilateur IonMonkey prend le plus de temps pour g√©n√©rer du code machine, mais ce code peut √™tre ex√©cut√© tr√®s efficacement. <br><br>  Jetons un coup d'≈ìil √† un exemple sp√©cifique et examinons comment les pipelines de divers moteurs g√®rent le code.  Dans l'exemple pr√©sent√© ici, il y a une boucle ¬´chaude¬ª contenant du code qui se r√©p√®te tant de fois. <br><br><pre><code class="hljs matlab">let result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; <span class="hljs-number"><span class="hljs-number">4242424242</span></span>; ++<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>) {    result += <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>; } console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(result);</code> </pre> <br>  V8 commence √† ex√©cuter le bytecode dans l'interpr√©teur Ignition.  √Ä un moment donn√©, le moteur d√©couvre que le code est ¬´chaud¬ª et lance le frontend TurboFan, qui fait partie de TurboFan travaillant avec les donn√©es de profilage et cr√©ant une repr√©sentation de base du code machine.  Les donn√©es sont ensuite transmises √† l'optimiseur TurboFan, fonctionnant dans un flux s√©par√©, pour de nouvelles am√©liorations. <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db3/20b/52a/db320b52a7d116d205dc13004852418c.png"></div>  <i><font color="#999999">Optimisation de code √† chaud dans V8</font></i> <br><br>  Pendant l'optimisation, V8 continue d'ex√©cuter le bytecode dans Ignition.  Lorsque l'optimiseur est termin√©, nous avons un code machine ex√©cutable qui peut √™tre utilis√© √† l'avenir. <br><br>  Le moteur SpiderMonkey commence √©galement √† ex√©cuter le bytecode dans l'interpr√©teur.  Mais il a un niveau suppl√©mentaire repr√©sent√© par le compilateur de base, ce qui conduit au fait que le code "√† chaud" arrive d'abord √† ce compilateur.  Il g√©n√®re le code de base dans le thread principal, la transition vers l'ex√©cution de ce code se fait lorsqu'il est pr√™t. <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef4/782/299/ef4782299d5b523414d85adc16f79d07.png"></div>  <i><font color="#999999">Optimisation de code √† chaud dans SpiderMonkey</font></i> <br><br>  Si le code de base fonctionne suffisamment longtemps, SpiderMonkey lance finalement le frontend et l'optimiseur IonMonkey, qui est tr√®s similaire √† ce qui se passe dans la V8.  Le code de base continue de s'ex√©cuter dans le cadre du processus d'optimisation de code effectu√© par IonMonkey.  Par cons√©quent, lorsque l'optimisation est termin√©e, le code optimis√© est ex√©cut√© √† la place du code de base. <br><br>  L'architecture du moteur Chakra est tr√®s similaire √† l'architecture de SpiderMonkey, mais Chakra s'efforce d'obtenir un niveau de concurrence plus √©lev√© afin d'√©viter de bloquer le thread principal.  Au lieu de r√©soudre toutes les t√¢ches de compilation dans le thread principal, Chakra copie et envoie le bytecode et les donn√©es de profilage dont le compilateur est susceptible d'avoir besoin dans un processus de compilation s√©par√©. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f44/6f7/5e8/f446f75e844d7be0086fde0237f63b9d.png"></div>  <i><font color="#999999">Optimisation de code chaud dans Chakra</font></i> <br><br>  Lorsque le code g√©n√©r√© pr√©par√© par SimpleJIT est pr√™t, le moteur l'ex√©cute au lieu de bytecode.  Ce processus est r√©p√©t√© pour proc√©der √† l'ex√©cution du code pr√©par√© par FullJIT.  L'avantage de cette approche est que les pauses associ√©es √† la copie des donn√©es sont g√©n√©ralement beaucoup plus courtes que celles provoqu√©es par le fonctionnement d'un compilateur √† part enti√®re (frontal).  Cependant, le inconv√©nient de cette approche est le fait que les algorithmes de copie heuristique peuvent manquer certaines informations qui peuvent √™tre utiles pour une sorte d'optimisation.  Nous voyons ici un exemple de compromis entre la qualit√© du code re√ßu et les retards. <br><br>  Dans JavaScriptCore, toutes les t√¢ches d'optimisation de la compilation sont effectu√©es en parall√®le avec le thread principal responsable de l'ex√©cution du code JavaScript.  Cependant, il n'y a pas d'√©tape de copie.  Au lieu de cela, le thread principal appelle simplement les t√¢ches de compilation dans un autre thread.  Le compilateur utilise ensuite un sch√©ma de verrouillage complexe pour acc√©der aux donn√©es de profilage √† partir du thread principal. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f7/0ab/101/2f70ab101c3ea308d1275a44bde4eecd.png"></div>  <i><font color="#999999">Optimisation du code "√† chaud" dans JavaScriptCore</font></i> <br><br>  L'avantage de cette approche est qu'elle r√©duit le blocage forc√© du thread principal provoqu√© par le fait qu'elle effectue des t√¢ches d'optimisation de code.  Les inconv√©nients de cette architecture sont que sa mise en ≈ìuvre n√©cessite la solution de t√¢ches complexes de traitement de donn√©es multi-thread, et qu'au cours du travail, pour effectuer diverses op√©rations, il faut recourir √† des verrous. <br><br>  Nous venons de discuter des compromis que les moteurs sont oblig√©s de faire, en choisissant entre la g√©n√©ration de code rapide √† l'aide d'interpr√®tes et la cr√©ation de code rapide √† l'aide de compilateurs d'optimisation.  Cependant, ce sont loin de tous les probl√®mes auxquels sont confront√©s les moteurs.  La m√©moire est une autre ressource syst√®me lors de son utilisation et vous devez recourir √† des solutions de compromis.  Pour le d√©montrer, consid√©rez un programme JS simple qui ajoute des nombres. <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y; } add(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br>  Voici le bytecode de la fonction d' <code>add</code> g√©n√©r√©e par l'interpr√©teur Ignition dans la V8: <br><br><pre> <code class="hljs pgsql">StackCheck Ldar a1 <span class="hljs-keyword"><span class="hljs-keyword">Add</span></span> a0, [<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">Return</span></span></code> </pre> <br>  Vous ne pouvez pas entrer dans le sens de ce bytecode, en fait, son contenu ne nous int√©resse pas particuli√®rement.  L'essentiel ici est qu'il n'a que quatre instructions. <br><br>  Lorsqu'un tel morceau de code est ¬´chaud¬ª, TurboFan est utilis√©, ce qui g√©n√®re le code machine hautement optimis√© suivant: <br><br><pre> <code class="hljs powershell">leaq rcx,[<span class="hljs-type"><span class="hljs-type">rip</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">x0</span></span>] movq rcx,[<span class="hljs-type"><span class="hljs-type">rcx</span></span>-<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">x37</span></span>] testb [<span class="hljs-type"><span class="hljs-type">rcx</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">xf</span></span>],<span class="hljs-number"><span class="hljs-number">0</span></span>x1 jnz CompileLazyDeoptimizedCode push rbp movq rbp,rsp push rsi push rdi cmpq rsp,[<span class="hljs-type"><span class="hljs-type">r13</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">xe88</span></span>] jna StackOverflow movq rax,[<span class="hljs-type"><span class="hljs-type">rbp</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">x18</span></span>] test al,<span class="hljs-number"><span class="hljs-number">0</span></span>x1 jnz Deoptimize movq rbx,[<span class="hljs-type"><span class="hljs-type">rbp</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">x10</span></span>] testb rbx,<span class="hljs-number"><span class="hljs-number">0</span></span>x1 jnz Deoptimize movq rdx,rbx shrq rdx, <span class="hljs-number"><span class="hljs-number">32</span></span> movq rcx,rax shrq rcx, <span class="hljs-number"><span class="hljs-number">32</span></span> addl rdx,rcx jo Deoptimize shlq rdx, <span class="hljs-number"><span class="hljs-number">32</span></span> movq rax,rdx movq rsp,rbp pop rbp ret <span class="hljs-number"><span class="hljs-number">0</span></span>x18</code> </pre> <br>  Comme vous pouvez le voir, le volume de code, par rapport √† l'exemple ci-dessus de quatre instructions, est tr√®s important.  Typiquement, le bytecode est beaucoup plus compact que le code machine, et en particulier le code machine optimis√©.  D'un autre c√¥t√©, un interpr√©teur est n√©cessaire pour ex√©cuter le bytecode, et le code optimis√© peut √™tre ex√©cut√© directement sur le processeur. <br>  C'est l'une des principales raisons pour lesquelles les moteurs JavaScript n'optimisent pas absolument tout le code.  Comme nous l'avons vu pr√©c√©demment, la cr√©ation de code machine optimis√© prend beaucoup de temps, et de plus, comme nous venons de le d√©couvrir, il faut plus de m√©moire pour stocker du code machine optimis√©. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f0b/c84/e9a/f0bc84e9ac477b1e85eb19f306c99597.png"></div>  <i><font color="#999999">Utilisation de la m√©moire et niveau d'optimisation</font></i> <br><br>  En cons√©quence, nous pouvons dire que la raison pour laquelle les moteurs JS ont diff√©rents niveaux d'optimisation est le probl√®me fondamental de choisir entre la g√©n√©ration de code rapide, par exemple, en utilisant un interpr√©teur, et la g√©n√©ration de code rapide, qui sont ex√©cut√©es au moyen du compilateur d'optimisation.  Si nous parlons des niveaux d'optimisation de code utilis√©s dans les moteurs, alors plus il y en a, plus les optimisations sont subtiles auxquelles le code peut √™tre soumis, mais cela est d√ª √† la complexit√© des moteurs et √† la charge suppl√©mentaire sur le syst√®me.  De plus, il ne faut pas oublier ici que le niveau d'optimisation du code affecte la quantit√© de m√©moire que ce code occupe.  C'est pourquoi les moteurs JS essaient d'optimiser uniquement les fonctions "√† chaud". <br><br><h2>  <font color="#3AC1EF">Optimisation de l'acc√®s aux propri√©t√©s du prototype d'objet</font> </h2><br>  Les moteurs JavaScript optimisent l'acc√®s aux propri√©t√©s des objets gr√¢ce √† l'utilisation de formes d'objets (Shape) et de caches en ligne (Inline Cache, IC).  Les d√©tails √† ce sujet peuvent √™tre lus dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce</a> document, mais pour le dire en bref, nous pouvons dire que le moteur stocke la forme de l'objet s√©par√©ment des valeurs de l'objet. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c63/861/ba8/c63861ba87ef40cdeea866edefe8b000.png"></div>  <i><font color="#999999">Objets de m√™me forme</font></i> <br><br>  L'utilisation de formes d'objets permet d'effectuer une optimisation appel√©e mise en cache en ligne.  L'utilisation conjointe de formulaires d'objets et de caches en ligne vous permet d'acc√©l√©rer les op√©rations r√©p√©t√©es d'acc√®s aux propri√©t√©s des objets, effectu√©es au m√™me endroit dans le code. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mr/5n/cn/mr5ncnmioer4qo4o-aiwlqslo_q.png"></div>  <i><font color="#999999">Acc√©l√©rer l'acc√®s √† une propri√©t√© d'objet</font></i> <br><br><h2>  <font color="#3AC1EF">Classes et prototypes</font> </h2><br>  Maintenant que nous savons comment acc√©l√©rer l'acc√®s aux propri√©t√©s des objets en JavaScript, jetez un ≈ìil √† l'une des r√©centes innovations JavaScript - les classes.  Voici √† quoi ressemble la d√©claration de classe: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) {       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x;   }   getX() {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x;   } }</code> </pre> <br>  Bien que cela puisse ressembler √† l'apparition dans JS d'un concept compl√®tement nouveau, les classes ne sont en fait que du sucre syntaxique pour le syst√®me prototype de construction d'objets, qui a toujours √©t√© pr√©sent dans JavaScript: <br><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; } Bar.prototype.getX = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getX</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; };</code> </pre> <br>  Ici, nous √©crivons la fonction dans la propri√©t√© <code>getX</code> de l'objet <code>getX</code> .  Cette op√©ration fonctionne exactement de la m√™me mani√®re que lors de la cr√©ation des propri√©t√©s de tout autre objet, car les prototypes en JavaScript sont des objets.  Dans les langages bas√©s sur l'utilisation de prototypes, tels que JavaScript, les m√©thodes qui peuvent √™tre partag√©es par tous les objets d'un certain type sont stock√©es dans des prototypes, et les champs des objets individuels sont stock√©s dans leurs instances. <br><br>  Voyons ce qui se passe, pour ainsi dire, dans les coulisses lorsque nous cr√©ons une nouvelle instance de l'objet <code>Bar</code> , en l'affectant au <code>foo</code> constant. <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br>  Apr√®s avoir ex√©cut√© un tel code, l'instance de l'objet cr√©√© ici aura un formulaire contenant une seule propri√©t√© <code>x</code> .  Le prototype de l'objet <code>foo</code> est <code>Bar.prototype</code> , qui appartient √† la classe <code>Bar</code> . <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/26b/52a/630/26b52a63051f760544368abc000ff13d.png"></div>  <i><font color="#999999">Objet et son prototype</font></i> <br><br>  <code>Bar.prototype</code> a sa propre forme contenant une seule propri√©t√© <code>getX</code> dont la valeur est une fonction qui, lorsqu'elle est appel√©e, renvoie la valeur de <code>this.x</code>  Le prototype prototype <code>Bar.prototype</code> est <code>Object.prototype</code> , qui fait partie du langage.  <code>Object.prototype</code> est l'√©l√©ment racine de l'arborescence du prototype, donc son prototype est <code>null</code> . <br><br>  Voyons maintenant ce qui se passe si vous cr√©ez un autre objet de type <code>Bar</code> . <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a0/972/b2f/7a0972b2f7e264f2e58e399d7f29f5c6.png"></div>  <i><font color="#999999">Plusieurs objets du m√™me type</font></i> <br><br>  Comme vous pouvez le voir, l'objet <code>foo</code> et l'objet <code>qux</code> , qui sont des instances de la classe <code>Bar</code> , comme nous l'avons d√©j√† dit, utilisent la m√™me forme de l'objet.  Les deux utilisent le m√™me prototype - l'objet <code>Bar.prototype</code> . <br><br><h2>  <font color="#3AC1EF">Acc√©der aux propri√©t√©s du prototype</font> </h2><br>  Alors maintenant, nous savons ce qui se passe lorsque nous d√©clarons une nouvelle classe et l'instancions.  Et qu'en est-il de l'appel √† la m√©thode de l'objet?  Consid√©rez l'extrait de code suivant: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; }   getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = new Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = foo.getX(); <span class="hljs-comment"><span class="hljs-comment">//        ^^^^^^^^^^</span></span></code> </pre> <br>  Un appel de m√©thode peut √™tre compris comme une op√©ration compos√©e de deux √©tapes: <br><br><pre> <code class="hljs ruby">const x = foo.getX(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>         : const $getX = foo.getX; const x = $getX.call(foo);</code> </pre> <br>  √Ä la premi√®re √©tape, la m√©thode est charg√©e, qui n'est qu'une propri√©t√© du prototype (dont la valeur est la fonction).  Dans la deuxi√®me √©tape, une fonction est appel√©e avec <code>this</code> ensemble.  Consid√©rez la premi√®re √©tape du chargement de la m√©thode <code>getX</code> partir de l'objet <code>foo</code> : <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b94/46f/291/b9446f291449153c1de7b7f6fafcbb5b.png"></div>  <i><font color="#999999">Chargement de la m√©thode getX √† partir de l'objet foo</font></i> <br><br>  Le moteur analyse l'objet <code>foo</code> et d√©couvre qu'il n'y a pas de propri√©t√© <code>getX</code> sous la forme de l'objet <code>foo</code> .  Cela signifie que le moteur doit examiner la cha√Æne prototype de l'objet afin de trouver cette m√©thode.  Le moteur acc√®de au prototype <code>Bar.prototype</code> et examine la forme de l'objet de ce prototype.  L√†, il trouve la propri√©t√© souhait√©e √† l'offset 0. Ensuite, la valeur stock√©e √† cet offset dans <code>Bar.prototype</code> , <code>JSFunction</code> <code>getX</code> est d√©tect√©e - et c'est exactement ce que nous recherchons.  Ceci termine la recherche de la m√©thode. <br><br>  La flexibilit√© de JavaScript permet de changer les cha√Ænes de prototypes.  Par exemple, comme ceci: <br><br><pre> <code class="hljs pgsql">const foo = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Bar(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); foo.getX(); // <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.setPrototypeOf(foo, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); foo.getX(); // Uncaught TypeError: foo.getX <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">function</span></span></code> </pre> <br>  Dans cet exemple, nous appelons la m√©thode <code>foo.getX()</code> deux fois, mais chacun de ces appels a une signification et un r√©sultat compl√®tement diff√©rents.  C'est pourquoi, bien que les prototypes JavaScript ne soient que des objets, l'acc√©l√©ration de l'acc√®s aux propri√©t√©s du prototype est encore plus difficile pour les moteurs JS que l'acc√©l√©ration de l'acc√®s √† leurs propres propri√©t√©s d'objets ordinaires. <br><br>  Si nous regardons des programmes r√©els, il s'av√®re que le chargement des propri√©t√©s d'un prototype est une op√©ration tr√®s courante.  Il est ex√©cut√© chaque fois qu'une m√©thode est appel√©e. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; }   getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = new Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = foo.getX(); <span class="hljs-comment"><span class="hljs-comment">//        ^^^^^^^^^^</span></span></code> </pre> <br>  Un peu plus t√¥t, nous avons expliqu√© comment les moteurs optimisent le chargement des propri√©t√©s r√©guli√®res et personnalis√©es des objets gr√¢ce √† l'utilisation de formulaires d'objet et de caches en ligne.  Comment optimiser le chargement r√©p√©t√© des propri√©t√©s du prototype pour des objets de m√™me forme?  Ci-dessus, nous avons vu comment les propri√©t√©s sont charg√©es. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/020/076/65c/02007665c3b9d613e5ccb1daa53a55cd.png"></div>  <i><font color="#999999">Chargement de la m√©thode getX √† partir de l'objet foo</font></i> <br><br>  Afin d'acc√©l√©rer l'acc√®s √† la m√©thode avec des appels r√©p√©t√©s, dans notre cas, vous devez conna√Ætre les √©l√©ments suivants: <br><br><ol><li>  La forme de l'objet <code>foo</code> ne contient pas la m√©thode <code>getX</code> et ne change pas.  Cela signifie que l'objet <code>foo</code> n'est pas modifi√© en y ajoutant des propri√©t√©s ou en les supprimant ou en modifiant les attributs des propri√©t√©s. </li><li>  Le prototype <code>foo</code> est toujours le <code>Bar.prototype</code> original.  Cela signifie que le prototype <code>foo</code> ne change pas √† l'aide de la m√©thode <code>Object.setPrototypeOf()</code> ou en affectant un nouveau prototype √† la propri√©t√© sp√©ciale <code>_proto_</code> . </li><li>  Le formulaire <code>Bar.prototype</code> contient <code>getX</code> et ne change pas.  Autrement dit, <code>Bar.prototype</code> pas modifi√© en supprimant des propri√©t√©s, en les ajoutant ou en modifiant leurs attributs. </li></ol><br>  Dans le cas g√©n√©ral, cela signifie que nous devons effectuer 1 v√©rification de l'objet lui-m√™me et 2 v√©rifications pour chaque prototype jusqu'au prototype qui stocke la propri√©t√© que nous recherchons.  Autrement dit, vous devez effectuer des v√©rifications 1 + 2N (o√π N est le nombre de prototypes test√©s), ce qui dans ce cas ne semble pas si mauvais, car la cha√Æne de prototypes est assez courte.  Cependant, les moteurs doivent souvent fonctionner avec des cha√Ænes de prototypes beaucoup plus longues.  Ceci, par exemple, est typique des √©l√©ments DOM ordinaires.  Voici un exemple: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> anchor = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'a'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// HTMLAnchorElement const title = anchor.getAttribute('title');</span></span></code> </pre> <br>  Ici, nous avons <code>HTMLAnchorElement</code> et nous appelons sa m√©thode <code>getAttribute()</code> .  La cha√Æne de prototypes de cet √©l√©ment simple repr√©sentant un lien HTML comprend 6 prototypes!  La plupart des m√©thodes DOM int√©ressantes ne sont pas dans leur propre prototype <code>HTMLAnchorElement</code> .  Ils sont dans des prototypes situ√©s plus bas dans la cha√Æne. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/753/e76/10d/753e7610da32acbfd576fd0c61226bc7.png"></div>  <i><font color="#999999">Cha√Æne prototype</font></i> <br><br>  La m√©thode <code>getAttribute()</code> se trouve dans <code>Element.prototype</code> .  Cela signifie qu'√† chaque fois que la m√©thode <code>anchor.getAttribute()</code> est <code>anchor.getAttribute()</code> , le moteur est oblig√© d'effectuer les actions suivantes: <br><br><ol><li>  V√©rifie l'objet d' <code>anchor</code> lui-m√™me pour <code>getAttribute</code> . </li><li>  V√©rification que le prototype direct de l'objet est <code>HTMLAnchorElement.prototype</code> . </li><li>  <code>HTMLAnchorElement.prototype</code> que <code>HTMLAnchorElement.prototype</code> n'a pas de m√©thode <code>getAttribute</code> . </li><li>  V√©rification que le prochain prototype est <code>HTMLElement.prototype</code> . </li><li>  D√©couvrir qu'il n'y a pas de m√©thode n√©cessaire ici. </li><li>  Enfin, d√©couvrir que le prochain prototype est <code>Element.prototype</code> . </li><li>  <code>getAttribute</code> qu'il existe une m√©thode <code>getAttribute</code> . </li></ol><br>  Comme vous pouvez le voir, 7 contr√¥les sont effectu√©s ici.  Comme ce code est tr√®s courant dans la programmation Web, les moteurs utilisent des optimisations pour r√©duire le nombre de v√©rifications n√©cessaires pour charger les propri√©t√©s du prototype. <br><br>  Si nous revenons √† l'un des exemples pr√©c√©dents, nous pouvons nous rappeler que lorsque nous appelons la m√©thode <code>getX</code> de l'objet <code>getX</code> , nous effectuons 3 v√©rifications: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; }   getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = new Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> $getX = foo.getX;</code> </pre> <br>  Pour chaque objet qui se trouve dans la cha√Æne de prototype, jusqu'√† celui qui contient la propri√©t√© souhait√©e, nous devons v√©rifier la forme de l'objet uniquement pour d√©couvrir l'absence de ce que nous recherchons.  Ce serait bien si nous pouvions r√©duire le nombre de v√©rifications en r√©duisant la v√©rification du prototype √† la v√©rification de la pr√©sence ou de l'absence de ce que nous recherchons.  C'est ce que fait le moteur avec un simple mouvement: au lieu de stocker le lien prototype dans l'instance elle-m√™me, le moteur le stocke sous la forme d'un objet. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/643/1d0/c33/6431d0c33d2d03bea86e6adfffed4569.png"></div>  <i><font color="#999999">Stockage de r√©f√©rence de prototype</font></i> <br><br>  Chaque formulaire a un lien vers un prototype.  Cela signifie √©galement que chaque fois que le prototype change, le moteur se d√©place vers la nouvelle forme de l'objet.  Il nous suffit maintenant de v√©rifier la forme de l'objet pour la pr√©sence d'une propri√©t√© et de prendre soin de prot√©ger le lien prototype. <br><br>  Gr√¢ce √† cette approche, nous pouvons r√©duire le nombre de contr√¥les de 1 + 2N √† 1 + N, ce qui acc√©l√©rera l'acc√®s aux propri√©t√©s des prototypes.  Cependant, de telles op√©rations n√©cessitent encore beaucoup de ressources, car il existe une relation lin√©aire entre leur nombre et la longueur de la cha√Æne prototype.  Les moteurs ont mis en place diff√©rents m√©canismes visant √† garantir que le nombre de contr√¥les ne d√©pende pas de la longueur de la cha√Æne prototype, exprim√©e en constante.  Cela est particuli√®rement vrai dans les situations o√π le chargement de la m√™me propri√©t√© est effectu√© plusieurs fois. <br><br><h2>  <font color="#3AC1EF">Propri√©t√© ValidityCell</font> </h2><br>  V8 fait r√©f√©rence aux formes de prototypes sp√©cifiquement pour le but ci-dessus.  Chaque prototype a une forme unique qui n'est pas partag√©e avec d'autres objets (en particulier, avec d'autres prototypes), et chacune des formes d'objet prototype a une propri√©t√© <code>ValidityCell</code> qui leur est associ√©e. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7fb/f9c/3f9/7fbf9c3f987b8def69855e849c71c01a.png"></div>  <i><font color="#999999">Propri√©t√© ValidityCell</font></i> <br><br>  Cette propri√©t√© est d√©clar√©e invalide lors de la modification du prototype associ√© au formulaire ou de tout prototype sus-jacent.  Consid√©rez ce m√©canisme plus en d√©tail. <br><br>  Afin d'acc√©l√©rer les op√©rations s√©quentielles de chargement des propri√©t√©s √† partir des prototypes, V8 utilise un cache en ligne contenant quatre champs: <code>ValidityCell</code> , <code>Prototype</code> , <code>Shape</code> , <code>Offset</code> . <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ba/a3b/04f/0baa3b04faebad191e769279c6eb1cd8.png"></div>  <i><font color="#999999">Champs de cache en ligne</font></i> <br><br>  Lors de l'√©chauffement du cache en ligne lors de la premi√®re ex√©cution du code, V8 se souvient du d√©calage auquel la propri√©t√© a √©t√© trouv√©e dans le prototype, du prototype dans lequel la propri√©t√© a √©t√© trouv√©e (dans cet exemple, <code>Bar.prototype</code> ), de la forme de l'objet ( <code>foo</code> dans ce cas) et, en outre, un lien vers le param√®tre <code>ValidityCell</code> actuel du prototype imm√©diat, un lien vers lequel se pr√©sente sous la forme d'un objet (dans ce cas, il s'agit √©galement de <code>Bar.prototype</code> ). <br><br>  La prochaine fois que vous acc√©derez au cache en ligne, le moteur devra v√©rifier la forme de l'objet et de <code>ValidityCell</code> .  Si <code>ValidityCell</code> est toujours valide, le moteur peut profiter directement du d√©calage pr√©c√©demment enregistr√© dans le prototype sans effectuer d'op√©rations de recherche suppl√©mentaires. <br><br>  Lorsque le prototype change, un nouveau formulaire est cr√©√© et la propri√©t√© <code>ValidityCell</code> pr√©c√©dente est d√©clar√©e non valide.  Par cons√©quent, la prochaine fois que vous tenterez d'acc√©der au cache en ligne, cela n'apportera aucun avantage, ce qui entra√Ænera de mauvaises performances. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c95/c30/c97/c95c30c97ee0429bf1400163309c6354.png"></div>  <i><font color="#999999">Les cons√©quences du changement de prototype</font></i> <br><br>  Si nous revenons √† l'exemple avec l'√©l√©ment DOM, cela signifie que toute modification, par exemple, dans le prototype d' <code>Object.prototype</code> , conduira non seulement √† invalider le cache en ligne pour <code>Object.prototype</code> lui-m√™me, mais aussi pour tous les prototypes situ√©s en dessous dans la cha√Æne de prototypes y compris <code>EventTarget.prototype</code> , <code>Node.prototype</code> , <code>Element.prototype</code> , etc., jusqu'√† <code>HTMLAnchorElement.prototype</code> . <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/444/5f7/ff7/4445f7ff7b11c00e40aeac4fd1945ae1.png"></div>  <i><font color="#999999">Implications de la modification du prototype Object.prototype</font></i> <br><br>  En fait, modifier <code>Object.prototype</code> pendant l'ex√©cution de code signifie nuire gravement aux performances.  Ne fais pas √ßa. <br><br>  Nous √©tudions ce qui pr√©c√®de avec un exemple.  Supposons que nous ayons la classe <code>Bar</code> et la fonction <code>loadX</code> , qui appelle la m√©thode des objets cr√©√©s √† partir de la classe <code>Bar</code> .  Nous appelons la fonction <code>loadX</code> plusieurs fois, en lui passant des instances de la m√™me classe. <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadX</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bar)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bar.getX(); // IC  <span class="hljs-string"><span class="hljs-string">'getX'</span></span>   `Bar`. } loadX(new Bar(true)); loadX(new Bar(false)); // IC  `loadX`    `ValidityCell`  // `Bar.prototype`. Object.prototype.newMethod = y =&gt; y; // `ValidityCell`  IC `loadX`   //    `Object.prototype`  .</code> </pre> <br>  Le cache en <code>loadX</code> dans <code>loadX</code> pointe d√©sormais vers <code>ValidityCell</code> pour <code>Bar.prototype</code> .  , ,  <code>Object.prototype</code> ‚Äî    JavaScript,   <code>ValidityCell</code>  ,   -          ,     . <br><br>  <code>Object.prototype</code> ‚Äî   ,        -      ,       .     ,    : <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.foo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ‚Ä¶ */</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//    : someObject.foo(); //     . delete Object.prototype.foo;</span></span></code> </pre> <br>   <code>Object.prototype</code> ,     - ,   .     ,    .      -   ,          .       , ¬´  ¬ª,   ,  . <br><br> ,  ,  .             .    <code>Object.prototype</code> ,   ,   -            . <br><br>       ,    ‚Äî   , JS-    -  ,       .        .       ,     ,      .  ,   ,       ,      . <br><br><h2>  <font color="#3AC1EF">R√©sum√©</font> </h2><br>       ,  JS-    ,  ,   , -,  <code>ValidityCell</code>   ,     .            JavaScript,    ,       (       , ,  ,        ). <br><br>  <b>Chers lecteurs!</b>       ,    - ,   JS,          ? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr422321/">https://habr.com/ru/post/fr422321/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr422309/index.html">Comment prot√©ger les donn√©es dans les r√©seaux de neurones cloud - une nouvelle m√©thode de cryptage est propos√©e</a></li>
<li><a href="../fr422311/index.html">Int√©ressant et utilit√© de python. 2e partie</a></li>
<li><a href="../fr422315/index.html">Comment survivre √† un chasseur d'insectes: lutte quotidienne pour le revenu</a></li>
<li><a href="../fr422317/index.html">Pourquoi les TPU sont-ils si bons pour l'apprentissage en profondeur?</a></li>
<li><a href="../fr422319/index.html">Pour la premi√®re fois, l'√©quipe russe est entr√©e dans le plus grand acc√©l√©rateur scientifique IndieBio</a></li>
<li><a href="../fr422323/index.html">Hackers: Russie et Chine</a></li>
<li><a href="../fr422325/index.html">DevDay √† propos des tests: D√©tendez-vous. Testez-le facilement</a></li>
<li><a href="../fr422327/index.html">Calendrier du projet vs backlog: bataille sans chance</a></li>
<li><a href="../fr422329/index.html">S√©curit√© de l'information des paiements bancaires sans esp√®ces. Partie 8 - Mod√®les de menaces typiques</a></li>
<li><a href="../fr422331/index.html">Comment le comptoir de paiement automatique hybride augmente l'efficacit√© du magasin</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>