<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⬅️ 🎯 🔶 Optimisation du travail avec des prototypes dans les moteurs JavaScript 🏗️ 👨🏿‍🤝‍👨🏾 👇</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le matériel, dont nous publions la traduction aujourd'hui, a été préparé par Matthias Binens et Benedict Meirer. Ils travaillent sur le moteur V8 JS d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimisation du travail avec des prototypes dans les moteurs JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/422321/">  Le matériel, dont nous publions la traduction aujourd'hui, a été préparé par Matthias Binens et Benedict Meirer.  Ils travaillent sur le moteur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V8</a> JS de Google.  Cet article est consacré à certains mécanismes de base qui sont caractéristiques non seulement pour le V8, mais aussi pour d'autres moteurs.  La connaissance de la structure interne de ces mécanismes permet aux personnes impliquées dans le développement de JavaScript de mieux naviguer les problèmes de performances du code.  En particulier, nous parlerons ici des caractéristiques des pipelines d'optimisation du moteur et de la façon d'accélérer l'accès aux propriétés des prototypes d'objets. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/za/lq/gg/zalqgg3vwvoc-wprqwob9r0fosq.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Niveaux d'optimisation de code et compromis</font> </h2><br>  Le processus de conversion des textes des programmes écrits en JavaScript en code approprié pour l'exécution est approximativement le même dans différents moteurs. <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/534/0ab/f1e/5340abf1e4b0dfa64f1e2bb294765560.png"></div> <i><font color="#999999">Le processus de conversion du code source JS en code exécutable</font></i> <br><br>  Les détails peuvent être trouvés <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  En outre, il convient de noter que bien que, à un niveau élevé, les pipelines de conversion du code source en exécutable soient très similaires pour différents moteurs, leurs systèmes d'optimisation de code diffèrent souvent.  Pourquoi en est-il ainsi?  Pourquoi certains moteurs ont-ils plus de niveaux d'optimisation que d'autres?  Il s'avère que les moteurs doivent compromettre d'une manière ou d'une autre, ce qui consiste en ce qu'ils peuvent soit générer rapidement du code qui n'est pas le plus efficace mais adapté à l'exécution, ou passer plus de temps à créer un tel code, mais pour cette raison, atteindre des performances optimales. <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c56/e35/973/c56e359735f983dae9b32294192bd26d.png"></div>  <i><font color="#999999">Préparation rapide du code pour l'exécution et code optimisé qui prend plus de temps mais s'exécute plus rapidement</font></i> <br><br>  L'interpréteur est capable de générer rapidement du bytecode, mais un tel code n'est généralement pas très efficace.  Le compilateur d'optimisation, en revanche, a besoin de plus de temps pour générer le code, mais au final, il obtient un code machine optimisé et plus rapide. <br><br>  C'est ce modèle de préparation du code pour l'exécution qui est utilisé dans la V8.  L'interpréteur V8 s'appelle Ignition, c'est le plus rapide des interprètes existants (en termes d'exécution du bytecode source).  Le compilateur d'optimisation V8 est appelé TurboFan, qui est responsable de la création de code machine hautement optimisé. <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e2b/624/62a/e2b62462a5f2563b27a6c362d031b7f2.png"></div>  <i><font color="#999999">Interpréteur d'allumage et compilateur d'optimisation TurboFan</font></i> <br><br>  Le compromis entre le retard dans le démarrage du programme et la vitesse d'exécution est la raison pour laquelle certains moteurs JS ont des niveaux d'optimisation supplémentaires.  Par exemple, dans SpiderMonkey, entre l'interpréteur et le compilateur d'optimisation IonMonkey, il existe un niveau intermédiaire représenté par le compilateur de base (il est appelé «The Baseline Compiler» dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation de</a> Mozilla, mais «baseline» n'est pas un nom propre). <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c8/212/702/0c821270298b4860ab99918d2dd575a3.png"></div>  <i><font color="#999999">Niveaux d'optimisation du code SpiderMonkey</font></i> <br><br>  L'interpréteur génère rapidement du bytecode, mais ce code est exécuté relativement lentement.  Le compilateur de base prend plus de temps pour générer le code, mais ce code est déjà plus rapide.  Enfin, l'optimisation du compilateur IonMonkey prend le plus de temps pour générer du code machine, mais ce code peut être exécuté très efficacement. <br><br>  Jetons un coup d'œil à un exemple spécifique et examinons comment les pipelines de divers moteurs gèrent le code.  Dans l'exemple présenté ici, il y a une boucle «chaude» contenant du code qui se répète tant de fois. <br><br><pre><code class="hljs matlab">let result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; <span class="hljs-number"><span class="hljs-number">4242424242</span></span>; ++<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>) {    result += <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>; } console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(result);</code> </pre> <br>  V8 commence à exécuter le bytecode dans l'interpréteur Ignition.  À un moment donné, le moteur découvre que le code est «chaud» et lance le frontend TurboFan, qui fait partie de TurboFan travaillant avec les données de profilage et créant une représentation de base du code machine.  Les données sont ensuite transmises à l'optimiseur TurboFan, fonctionnant dans un flux séparé, pour de nouvelles améliorations. <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db3/20b/52a/db320b52a7d116d205dc13004852418c.png"></div>  <i><font color="#999999">Optimisation de code à chaud dans V8</font></i> <br><br>  Pendant l'optimisation, V8 continue d'exécuter le bytecode dans Ignition.  Lorsque l'optimiseur est terminé, nous avons un code machine exécutable qui peut être utilisé à l'avenir. <br><br>  Le moteur SpiderMonkey commence également à exécuter le bytecode dans l'interpréteur.  Mais il a un niveau supplémentaire représenté par le compilateur de base, ce qui conduit au fait que le code "à chaud" arrive d'abord à ce compilateur.  Il génère le code de base dans le thread principal, la transition vers l'exécution de ce code se fait lorsqu'il est prêt. <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef4/782/299/ef4782299d5b523414d85adc16f79d07.png"></div>  <i><font color="#999999">Optimisation de code à chaud dans SpiderMonkey</font></i> <br><br>  Si le code de base fonctionne suffisamment longtemps, SpiderMonkey lance finalement le frontend et l'optimiseur IonMonkey, qui est très similaire à ce qui se passe dans la V8.  Le code de base continue de s'exécuter dans le cadre du processus d'optimisation de code effectué par IonMonkey.  Par conséquent, lorsque l'optimisation est terminée, le code optimisé est exécuté à la place du code de base. <br><br>  L'architecture du moteur Chakra est très similaire à l'architecture de SpiderMonkey, mais Chakra s'efforce d'obtenir un niveau de concurrence plus élevé afin d'éviter de bloquer le thread principal.  Au lieu de résoudre toutes les tâches de compilation dans le thread principal, Chakra copie et envoie le bytecode et les données de profilage dont le compilateur est susceptible d'avoir besoin dans un processus de compilation séparé. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f44/6f7/5e8/f446f75e844d7be0086fde0237f63b9d.png"></div>  <i><font color="#999999">Optimisation de code chaud dans Chakra</font></i> <br><br>  Lorsque le code généré préparé par SimpleJIT est prêt, le moteur l'exécute au lieu de bytecode.  Ce processus est répété pour procéder à l'exécution du code préparé par FullJIT.  L'avantage de cette approche est que les pauses associées à la copie des données sont généralement beaucoup plus courtes que celles provoquées par le fonctionnement d'un compilateur à part entière (frontal).  Cependant, le inconvénient de cette approche est le fait que les algorithmes de copie heuristique peuvent manquer certaines informations qui peuvent être utiles pour une sorte d'optimisation.  Nous voyons ici un exemple de compromis entre la qualité du code reçu et les retards. <br><br>  Dans JavaScriptCore, toutes les tâches d'optimisation de la compilation sont effectuées en parallèle avec le thread principal responsable de l'exécution du code JavaScript.  Cependant, il n'y a pas d'étape de copie.  Au lieu de cela, le thread principal appelle simplement les tâches de compilation dans un autre thread.  Le compilateur utilise ensuite un schéma de verrouillage complexe pour accéder aux données de profilage à partir du thread principal. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f7/0ab/101/2f70ab101c3ea308d1275a44bde4eecd.png"></div>  <i><font color="#999999">Optimisation du code "à chaud" dans JavaScriptCore</font></i> <br><br>  L'avantage de cette approche est qu'elle réduit le blocage forcé du thread principal provoqué par le fait qu'elle effectue des tâches d'optimisation de code.  Les inconvénients de cette architecture sont que sa mise en œuvre nécessite la solution de tâches complexes de traitement de données multi-thread, et qu'au cours du travail, pour effectuer diverses opérations, il faut recourir à des verrous. <br><br>  Nous venons de discuter des compromis que les moteurs sont obligés de faire, en choisissant entre la génération de code rapide à l'aide d'interprètes et la création de code rapide à l'aide de compilateurs d'optimisation.  Cependant, ce sont loin de tous les problèmes auxquels sont confrontés les moteurs.  La mémoire est une autre ressource système lors de son utilisation et vous devez recourir à des solutions de compromis.  Pour le démontrer, considérez un programme JS simple qui ajoute des nombres. <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y; } add(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br>  Voici le bytecode de la fonction d' <code>add</code> générée par l'interpréteur Ignition dans la V8: <br><br><pre> <code class="hljs pgsql">StackCheck Ldar a1 <span class="hljs-keyword"><span class="hljs-keyword">Add</span></span> a0, [<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">Return</span></span></code> </pre> <br>  Vous ne pouvez pas entrer dans le sens de ce bytecode, en fait, son contenu ne nous intéresse pas particulièrement.  L'essentiel ici est qu'il n'a que quatre instructions. <br><br>  Lorsqu'un tel morceau de code est «chaud», TurboFan est utilisé, ce qui génère le code machine hautement optimisé suivant: <br><br><pre> <code class="hljs powershell">leaq rcx,[<span class="hljs-type"><span class="hljs-type">rip</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">x0</span></span>] movq rcx,[<span class="hljs-type"><span class="hljs-type">rcx</span></span>-<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">x37</span></span>] testb [<span class="hljs-type"><span class="hljs-type">rcx</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">xf</span></span>],<span class="hljs-number"><span class="hljs-number">0</span></span>x1 jnz CompileLazyDeoptimizedCode push rbp movq rbp,rsp push rsi push rdi cmpq rsp,[<span class="hljs-type"><span class="hljs-type">r13</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">xe88</span></span>] jna StackOverflow movq rax,[<span class="hljs-type"><span class="hljs-type">rbp</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">x18</span></span>] test al,<span class="hljs-number"><span class="hljs-number">0</span></span>x1 jnz Deoptimize movq rbx,[<span class="hljs-type"><span class="hljs-type">rbp</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">x10</span></span>] testb rbx,<span class="hljs-number"><span class="hljs-number">0</span></span>x1 jnz Deoptimize movq rdx,rbx shrq rdx, <span class="hljs-number"><span class="hljs-number">32</span></span> movq rcx,rax shrq rcx, <span class="hljs-number"><span class="hljs-number">32</span></span> addl rdx,rcx jo Deoptimize shlq rdx, <span class="hljs-number"><span class="hljs-number">32</span></span> movq rax,rdx movq rsp,rbp pop rbp ret <span class="hljs-number"><span class="hljs-number">0</span></span>x18</code> </pre> <br>  Comme vous pouvez le voir, le volume de code, par rapport à l'exemple ci-dessus de quatre instructions, est très important.  Typiquement, le bytecode est beaucoup plus compact que le code machine, et en particulier le code machine optimisé.  D'un autre côté, un interpréteur est nécessaire pour exécuter le bytecode, et le code optimisé peut être exécuté directement sur le processeur. <br>  C'est l'une des principales raisons pour lesquelles les moteurs JavaScript n'optimisent pas absolument tout le code.  Comme nous l'avons vu précédemment, la création de code machine optimisé prend beaucoup de temps, et de plus, comme nous venons de le découvrir, il faut plus de mémoire pour stocker du code machine optimisé. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f0b/c84/e9a/f0bc84e9ac477b1e85eb19f306c99597.png"></div>  <i><font color="#999999">Utilisation de la mémoire et niveau d'optimisation</font></i> <br><br>  En conséquence, nous pouvons dire que la raison pour laquelle les moteurs JS ont différents niveaux d'optimisation est le problème fondamental de choisir entre la génération de code rapide, par exemple, en utilisant un interpréteur, et la génération de code rapide, qui sont exécutées au moyen du compilateur d'optimisation.  Si nous parlons des niveaux d'optimisation de code utilisés dans les moteurs, alors plus il y en a, plus les optimisations sont subtiles auxquelles le code peut être soumis, mais cela est dû à la complexité des moteurs et à la charge supplémentaire sur le système.  De plus, il ne faut pas oublier ici que le niveau d'optimisation du code affecte la quantité de mémoire que ce code occupe.  C'est pourquoi les moteurs JS essaient d'optimiser uniquement les fonctions "à chaud". <br><br><h2>  <font color="#3AC1EF">Optimisation de l'accès aux propriétés du prototype d'objet</font> </h2><br>  Les moteurs JavaScript optimisent l'accès aux propriétés des objets grâce à l'utilisation de formes d'objets (Shape) et de caches en ligne (Inline Cache, IC).  Les détails à ce sujet peuvent être lus dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce</a> document, mais pour le dire en bref, nous pouvons dire que le moteur stocke la forme de l'objet séparément des valeurs de l'objet. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c63/861/ba8/c63861ba87ef40cdeea866edefe8b000.png"></div>  <i><font color="#999999">Objets de même forme</font></i> <br><br>  L'utilisation de formes d'objets permet d'effectuer une optimisation appelée mise en cache en ligne.  L'utilisation conjointe de formulaires d'objets et de caches en ligne vous permet d'accélérer les opérations répétées d'accès aux propriétés des objets, effectuées au même endroit dans le code. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mr/5n/cn/mr5ncnmioer4qo4o-aiwlqslo_q.png"></div>  <i><font color="#999999">Accélérer l'accès à une propriété d'objet</font></i> <br><br><h2>  <font color="#3AC1EF">Classes et prototypes</font> </h2><br>  Maintenant que nous savons comment accélérer l'accès aux propriétés des objets en JavaScript, jetez un œil à l'une des récentes innovations JavaScript - les classes.  Voici à quoi ressemble la déclaration de classe: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) {       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x;   }   getX() {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x;   } }</code> </pre> <br>  Bien que cela puisse ressembler à l'apparition dans JS d'un concept complètement nouveau, les classes ne sont en fait que du sucre syntaxique pour le système prototype de construction d'objets, qui a toujours été présent dans JavaScript: <br><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; } Bar.prototype.getX = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getX</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; };</code> </pre> <br>  Ici, nous écrivons la fonction dans la propriété <code>getX</code> de l'objet <code>getX</code> .  Cette opération fonctionne exactement de la même manière que lors de la création des propriétés de tout autre objet, car les prototypes en JavaScript sont des objets.  Dans les langages basés sur l'utilisation de prototypes, tels que JavaScript, les méthodes qui peuvent être partagées par tous les objets d'un certain type sont stockées dans des prototypes, et les champs des objets individuels sont stockés dans leurs instances. <br><br>  Voyons ce qui se passe, pour ainsi dire, dans les coulisses lorsque nous créons une nouvelle instance de l'objet <code>Bar</code> , en l'affectant au <code>foo</code> constant. <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br>  Après avoir exécuté un tel code, l'instance de l'objet créé ici aura un formulaire contenant une seule propriété <code>x</code> .  Le prototype de l'objet <code>foo</code> est <code>Bar.prototype</code> , qui appartient à la classe <code>Bar</code> . <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/26b/52a/630/26b52a63051f760544368abc000ff13d.png"></div>  <i><font color="#999999">Objet et son prototype</font></i> <br><br>  <code>Bar.prototype</code> a sa propre forme contenant une seule propriété <code>getX</code> dont la valeur est une fonction qui, lorsqu'elle est appelée, renvoie la valeur de <code>this.x</code>  Le prototype prototype <code>Bar.prototype</code> est <code>Object.prototype</code> , qui fait partie du langage.  <code>Object.prototype</code> est l'élément racine de l'arborescence du prototype, donc son prototype est <code>null</code> . <br><br>  Voyons maintenant ce qui se passe si vous créez un autre objet de type <code>Bar</code> . <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a0/972/b2f/7a0972b2f7e264f2e58e399d7f29f5c6.png"></div>  <i><font color="#999999">Plusieurs objets du même type</font></i> <br><br>  Comme vous pouvez le voir, l'objet <code>foo</code> et l'objet <code>qux</code> , qui sont des instances de la classe <code>Bar</code> , comme nous l'avons déjà dit, utilisent la même forme de l'objet.  Les deux utilisent le même prototype - l'objet <code>Bar.prototype</code> . <br><br><h2>  <font color="#3AC1EF">Accéder aux propriétés du prototype</font> </h2><br>  Alors maintenant, nous savons ce qui se passe lorsque nous déclarons une nouvelle classe et l'instancions.  Et qu'en est-il de l'appel à la méthode de l'objet?  Considérez l'extrait de code suivant: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; }   getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = new Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = foo.getX(); <span class="hljs-comment"><span class="hljs-comment">//        ^^^^^^^^^^</span></span></code> </pre> <br>  Un appel de méthode peut être compris comme une opération composée de deux étapes: <br><br><pre> <code class="hljs ruby">const x = foo.getX(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>         : const $getX = foo.getX; const x = $getX.call(foo);</code> </pre> <br>  À la première étape, la méthode est chargée, qui n'est qu'une propriété du prototype (dont la valeur est la fonction).  Dans la deuxième étape, une fonction est appelée avec <code>this</code> ensemble.  Considérez la première étape du chargement de la méthode <code>getX</code> partir de l'objet <code>foo</code> : <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b94/46f/291/b9446f291449153c1de7b7f6fafcbb5b.png"></div>  <i><font color="#999999">Chargement de la méthode getX à partir de l'objet foo</font></i> <br><br>  Le moteur analyse l'objet <code>foo</code> et découvre qu'il n'y a pas de propriété <code>getX</code> sous la forme de l'objet <code>foo</code> .  Cela signifie que le moteur doit examiner la chaîne prototype de l'objet afin de trouver cette méthode.  Le moteur accède au prototype <code>Bar.prototype</code> et examine la forme de l'objet de ce prototype.  Là, il trouve la propriété souhaitée à l'offset 0. Ensuite, la valeur stockée à cet offset dans <code>Bar.prototype</code> , <code>JSFunction</code> <code>getX</code> est détectée - et c'est exactement ce que nous recherchons.  Ceci termine la recherche de la méthode. <br><br>  La flexibilité de JavaScript permet de changer les chaînes de prototypes.  Par exemple, comme ceci: <br><br><pre> <code class="hljs pgsql">const foo = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Bar(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); foo.getX(); // <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.setPrototypeOf(foo, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); foo.getX(); // Uncaught TypeError: foo.getX <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">function</span></span></code> </pre> <br>  Dans cet exemple, nous appelons la méthode <code>foo.getX()</code> deux fois, mais chacun de ces appels a une signification et un résultat complètement différents.  C'est pourquoi, bien que les prototypes JavaScript ne soient que des objets, l'accélération de l'accès aux propriétés du prototype est encore plus difficile pour les moteurs JS que l'accélération de l'accès à leurs propres propriétés d'objets ordinaires. <br><br>  Si nous regardons des programmes réels, il s'avère que le chargement des propriétés d'un prototype est une opération très courante.  Il est exécuté chaque fois qu'une méthode est appelée. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; }   getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = new Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = foo.getX(); <span class="hljs-comment"><span class="hljs-comment">//        ^^^^^^^^^^</span></span></code> </pre> <br>  Un peu plus tôt, nous avons expliqué comment les moteurs optimisent le chargement des propriétés régulières et personnalisées des objets grâce à l'utilisation de formulaires d'objet et de caches en ligne.  Comment optimiser le chargement répété des propriétés du prototype pour des objets de même forme?  Ci-dessus, nous avons vu comment les propriétés sont chargées. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/020/076/65c/02007665c3b9d613e5ccb1daa53a55cd.png"></div>  <i><font color="#999999">Chargement de la méthode getX à partir de l'objet foo</font></i> <br><br>  Afin d'accélérer l'accès à la méthode avec des appels répétés, dans notre cas, vous devez connaître les éléments suivants: <br><br><ol><li>  La forme de l'objet <code>foo</code> ne contient pas la méthode <code>getX</code> et ne change pas.  Cela signifie que l'objet <code>foo</code> n'est pas modifié en y ajoutant des propriétés ou en les supprimant ou en modifiant les attributs des propriétés. </li><li>  Le prototype <code>foo</code> est toujours le <code>Bar.prototype</code> original.  Cela signifie que le prototype <code>foo</code> ne change pas à l'aide de la méthode <code>Object.setPrototypeOf()</code> ou en affectant un nouveau prototype à la propriété spéciale <code>_proto_</code> . </li><li>  Le formulaire <code>Bar.prototype</code> contient <code>getX</code> et ne change pas.  Autrement dit, <code>Bar.prototype</code> pas modifié en supprimant des propriétés, en les ajoutant ou en modifiant leurs attributs. </li></ol><br>  Dans le cas général, cela signifie que nous devons effectuer 1 vérification de l'objet lui-même et 2 vérifications pour chaque prototype jusqu'au prototype qui stocke la propriété que nous recherchons.  Autrement dit, vous devez effectuer des vérifications 1 + 2N (où N est le nombre de prototypes testés), ce qui dans ce cas ne semble pas si mauvais, car la chaîne de prototypes est assez courte.  Cependant, les moteurs doivent souvent fonctionner avec des chaînes de prototypes beaucoup plus longues.  Ceci, par exemple, est typique des éléments DOM ordinaires.  Voici un exemple: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> anchor = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'a'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// HTMLAnchorElement const title = anchor.getAttribute('title');</span></span></code> </pre> <br>  Ici, nous avons <code>HTMLAnchorElement</code> et nous appelons sa méthode <code>getAttribute()</code> .  La chaîne de prototypes de cet élément simple représentant un lien HTML comprend 6 prototypes!  La plupart des méthodes DOM intéressantes ne sont pas dans leur propre prototype <code>HTMLAnchorElement</code> .  Ils sont dans des prototypes situés plus bas dans la chaîne. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/753/e76/10d/753e7610da32acbfd576fd0c61226bc7.png"></div>  <i><font color="#999999">Chaîne prototype</font></i> <br><br>  La méthode <code>getAttribute()</code> se trouve dans <code>Element.prototype</code> .  Cela signifie qu'à chaque fois que la méthode <code>anchor.getAttribute()</code> est <code>anchor.getAttribute()</code> , le moteur est obligé d'effectuer les actions suivantes: <br><br><ol><li>  Vérifie l'objet d' <code>anchor</code> lui-même pour <code>getAttribute</code> . </li><li>  Vérification que le prototype direct de l'objet est <code>HTMLAnchorElement.prototype</code> . </li><li>  <code>HTMLAnchorElement.prototype</code> que <code>HTMLAnchorElement.prototype</code> n'a pas de méthode <code>getAttribute</code> . </li><li>  Vérification que le prochain prototype est <code>HTMLElement.prototype</code> . </li><li>  Découvrir qu'il n'y a pas de méthode nécessaire ici. </li><li>  Enfin, découvrir que le prochain prototype est <code>Element.prototype</code> . </li><li>  <code>getAttribute</code> qu'il existe une méthode <code>getAttribute</code> . </li></ol><br>  Comme vous pouvez le voir, 7 contrôles sont effectués ici.  Comme ce code est très courant dans la programmation Web, les moteurs utilisent des optimisations pour réduire le nombre de vérifications nécessaires pour charger les propriétés du prototype. <br><br>  Si nous revenons à l'un des exemples précédents, nous pouvons nous rappeler que lorsque nous appelons la méthode <code>getX</code> de l'objet <code>getX</code> , nous effectuons 3 vérifications: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; }   getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = new Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> $getX = foo.getX;</code> </pre> <br>  Pour chaque objet qui se trouve dans la chaîne de prototype, jusqu'à celui qui contient la propriété souhaitée, nous devons vérifier la forme de l'objet uniquement pour découvrir l'absence de ce que nous recherchons.  Ce serait bien si nous pouvions réduire le nombre de vérifications en réduisant la vérification du prototype à la vérification de la présence ou de l'absence de ce que nous recherchons.  C'est ce que fait le moteur avec un simple mouvement: au lieu de stocker le lien prototype dans l'instance elle-même, le moteur le stocke sous la forme d'un objet. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/643/1d0/c33/6431d0c33d2d03bea86e6adfffed4569.png"></div>  <i><font color="#999999">Stockage de référence de prototype</font></i> <br><br>  Chaque formulaire a un lien vers un prototype.  Cela signifie également que chaque fois que le prototype change, le moteur se déplace vers la nouvelle forme de l'objet.  Il nous suffit maintenant de vérifier la forme de l'objet pour la présence d'une propriété et de prendre soin de protéger le lien prototype. <br><br>  Grâce à cette approche, nous pouvons réduire le nombre de contrôles de 1 + 2N à 1 + N, ce qui accélérera l'accès aux propriétés des prototypes.  Cependant, de telles opérations nécessitent encore beaucoup de ressources, car il existe une relation linéaire entre leur nombre et la longueur de la chaîne prototype.  Les moteurs ont mis en place différents mécanismes visant à garantir que le nombre de contrôles ne dépende pas de la longueur de la chaîne prototype, exprimée en constante.  Cela est particulièrement vrai dans les situations où le chargement de la même propriété est effectué plusieurs fois. <br><br><h2>  <font color="#3AC1EF">Propriété ValidityCell</font> </h2><br>  V8 fait référence aux formes de prototypes spécifiquement pour le but ci-dessus.  Chaque prototype a une forme unique qui n'est pas partagée avec d'autres objets (en particulier, avec d'autres prototypes), et chacune des formes d'objet prototype a une propriété <code>ValidityCell</code> qui leur est associée. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7fb/f9c/3f9/7fbf9c3f987b8def69855e849c71c01a.png"></div>  <i><font color="#999999">Propriété ValidityCell</font></i> <br><br>  Cette propriété est déclarée invalide lors de la modification du prototype associé au formulaire ou de tout prototype sus-jacent.  Considérez ce mécanisme plus en détail. <br><br>  Afin d'accélérer les opérations séquentielles de chargement des propriétés à partir des prototypes, V8 utilise un cache en ligne contenant quatre champs: <code>ValidityCell</code> , <code>Prototype</code> , <code>Shape</code> , <code>Offset</code> . <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ba/a3b/04f/0baa3b04faebad191e769279c6eb1cd8.png"></div>  <i><font color="#999999">Champs de cache en ligne</font></i> <br><br>  Lors de l'échauffement du cache en ligne lors de la première exécution du code, V8 se souvient du décalage auquel la propriété a été trouvée dans le prototype, du prototype dans lequel la propriété a été trouvée (dans cet exemple, <code>Bar.prototype</code> ), de la forme de l'objet ( <code>foo</code> dans ce cas) et, en outre, un lien vers le paramètre <code>ValidityCell</code> actuel du prototype immédiat, un lien vers lequel se présente sous la forme d'un objet (dans ce cas, il s'agit également de <code>Bar.prototype</code> ). <br><br>  La prochaine fois que vous accéderez au cache en ligne, le moteur devra vérifier la forme de l'objet et de <code>ValidityCell</code> .  Si <code>ValidityCell</code> est toujours valide, le moteur peut profiter directement du décalage précédemment enregistré dans le prototype sans effectuer d'opérations de recherche supplémentaires. <br><br>  Lorsque le prototype change, un nouveau formulaire est créé et la propriété <code>ValidityCell</code> précédente est déclarée non valide.  Par conséquent, la prochaine fois que vous tenterez d'accéder au cache en ligne, cela n'apportera aucun avantage, ce qui entraînera de mauvaises performances. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c95/c30/c97/c95c30c97ee0429bf1400163309c6354.png"></div>  <i><font color="#999999">Les conséquences du changement de prototype</font></i> <br><br>  Si nous revenons à l'exemple avec l'élément DOM, cela signifie que toute modification, par exemple, dans le prototype d' <code>Object.prototype</code> , conduira non seulement à invalider le cache en ligne pour <code>Object.prototype</code> lui-même, mais aussi pour tous les prototypes situés en dessous dans la chaîne de prototypes y compris <code>EventTarget.prototype</code> , <code>Node.prototype</code> , <code>Element.prototype</code> , etc., jusqu'à <code>HTMLAnchorElement.prototype</code> . <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/444/5f7/ff7/4445f7ff7b11c00e40aeac4fd1945ae1.png"></div>  <i><font color="#999999">Implications de la modification du prototype Object.prototype</font></i> <br><br>  En fait, modifier <code>Object.prototype</code> pendant l'exécution de code signifie nuire gravement aux performances.  Ne fais pas ça. <br><br>  Nous étudions ce qui précède avec un exemple.  Supposons que nous ayons la classe <code>Bar</code> et la fonction <code>loadX</code> , qui appelle la méthode des objets créés à partir de la classe <code>Bar</code> .  Nous appelons la fonction <code>loadX</code> plusieurs fois, en lui passant des instances de la même classe. <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadX</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bar)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bar.getX(); // IC  <span class="hljs-string"><span class="hljs-string">'getX'</span></span>   `Bar`. } loadX(new Bar(true)); loadX(new Bar(false)); // IC  `loadX`    `ValidityCell`  // `Bar.prototype`. Object.prototype.newMethod = y =&gt; y; // `ValidityCell`  IC `loadX`   //    `Object.prototype`  .</code> </pre> <br>  Le cache en <code>loadX</code> dans <code>loadX</code> pointe désormais vers <code>ValidityCell</code> pour <code>Bar.prototype</code> .  , ,  <code>Object.prototype</code> —    JavaScript,   <code>ValidityCell</code>  ,   -          ,     . <br><br>  <code>Object.prototype</code> —   ,        -      ,       .     ,    : <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.foo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* … */</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//    : someObject.foo(); //     . delete Object.prototype.foo;</span></span></code> </pre> <br>   <code>Object.prototype</code> ,     - ,   .     ,    .      -   ,          .       , «  »,   ,  . <br><br> ,  ,  .             .    <code>Object.prototype</code> ,   ,   -            . <br><br>       ,    —   , JS-    -  ,       .        .       ,     ,      .  ,   ,       ,      . <br><br><h2>  <font color="#3AC1EF">Résumé</font> </h2><br>       ,  JS-    ,  ,   , -,  <code>ValidityCell</code>   ,     .            JavaScript,    ,       (       , ,  ,        ). <br><br>  <b>Chers lecteurs!</b>       ,    - ,   JS,          ? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr422321/">https://habr.com/ru/post/fr422321/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr422309/index.html">Comment protéger les données dans les réseaux de neurones cloud - une nouvelle méthode de cryptage est proposée</a></li>
<li><a href="../fr422311/index.html">Intéressant et utilité de python. 2e partie</a></li>
<li><a href="../fr422315/index.html">Comment survivre à un chasseur d'insectes: lutte quotidienne pour le revenu</a></li>
<li><a href="../fr422317/index.html">Pourquoi les TPU sont-ils si bons pour l'apprentissage en profondeur?</a></li>
<li><a href="../fr422319/index.html">Pour la première fois, l'équipe russe est entrée dans le plus grand accélérateur scientifique IndieBio</a></li>
<li><a href="../fr422323/index.html">Hackers: Russie et Chine</a></li>
<li><a href="../fr422325/index.html">DevDay à propos des tests: Détendez-vous. Testez-le facilement</a></li>
<li><a href="../fr422327/index.html">Calendrier du projet vs backlog: bataille sans chance</a></li>
<li><a href="../fr422329/index.html">Sécurité de l'information des paiements bancaires sans espèces. Partie 8 - Modèles de menaces typiques</a></li>
<li><a href="../fr422331/index.html">Comment le comptoir de paiement automatique hybride augmente l'efficacité du magasin</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>