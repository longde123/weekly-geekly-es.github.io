<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äç‚ù§Ô∏è‚Äçüë® üèÇüèæ ü¶é Multithreading .NET: quando o desempenho est√° ausente üôÖüèº üîÖ üë©üèº‚Äçü§ù‚Äçüë®üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A plataforma .NET fornece muitas primitivas de sincroniza√ß√£o pr√©-criadas e cole√ß√µes seguras para threads. Se voc√™ precisar implementar, por exemplo, u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Multithreading .NET: quando o desempenho est√° ausente</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/468611/"><img src="https://habrastorage.org/webt/rn/su/tj/rnsutjjvg7sllluahknu8brlnbc.jpeg"><br><br>  A plataforma .NET fornece muitas primitivas de sincroniza√ß√£o pr√©-criadas e cole√ß√µes seguras para threads.  Se voc√™ precisar implementar, por exemplo, um cache seguro de thread ou uma fila de solicita√ß√µes ao desenvolver um aplicativo, essas solu√ß√µes prontas geralmente s√£o usadas, √†s vezes v√°rias ao mesmo tempo.  Em alguns casos, isso leva a problemas de desempenho: uma longa espera por bloqueios, consumo excessivo de mem√≥ria e longa coleta de lixo. <br><br>  Esses problemas podem ser resolvidos se levarmos em conta que as solu√ß√µes padr√£o s√£o generalizadas - elas podem ter uma sobrecarga em nossos cen√°rios que √© redundante.  Assim, voc√™ pode escrever, por exemplo, sua pr√≥pria cole√ß√£o eficaz de thread-safe para um caso espec√≠fico. <br><br>  Sob a cena, h√° um v√≠deo e uma transcri√ß√£o do meu relat√≥rio da confer√™ncia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DotNext</a> , onde analiso v√°rios exemplos em que o uso de ferramentas da biblioteca .NET padr√£o (Task.Delay, SemaphoreSlim, ConcurrentDictionary) levou a quedas de desempenho e proponho solu√ß√µes personalizadas para tarefas espec√≠ficas e desprovidas de essas defici√™ncias. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/-tNeYjRNJtY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Na √©poca do relat√≥rio, ele trabalhava em Kontur.  A Kontur desenvolve v√°rios aplicativos de neg√≥cios, e a equipe em que trabalhei lida com infraestrutura e desenvolve v√°rios servi√ßos de suporte e bibliotecas para ajudar desenvolvedores de outras equipes a criar servi√ßos de produtos. <br><br>  A equipe de infraestrutura constr√≥i seu data warehouse, um sistema de hospedagem de aplicativos para Windows e v√°rias bibliotecas para o desenvolvimento de microsservi√ßos.  Nossos aplicativos s√£o baseados em uma arquitetura de microsservi√ßo - todos os servi√ßos interagem entre si pela rede e, √© claro, eles usam bastante c√≥digo ass√≠ncrono e multithread.  Alguns desses aplicativos s√£o bastante cr√≠ticos para o desempenho, pois precisam ser capazes de lidar com muitas solicita√ß√µes. <br><br>  Sobre o que vamos falar hoje? <br><br><ul><li>  Multithreading e assincronia no .NET; </li><li>  Primitivas e cole√ß√µes de sincroniza√ß√£o de enchimento; </li><li>  O que fazer se as abordagens padr√£o n√£o puderem lidar com a carga? </li></ul><br>  Vamos analisar alguns recursos do trabalho com c√≥digo multithread e ass√≠ncrono no .NET.  Vamos dar uma olhada em algumas primitivas de sincroniza√ß√£o e cole√ß√µes simult√¢neas, ver como elas s√£o organizadas.  Discutiremos o que fazer se n√£o houver desempenho suficiente, se as classes padr√£o n√£o puderem lidar com a carga e se algo pode ser feito nessa situa√ß√£o. <br><br>  Vou contar quatro hist√≥rias que aconteceram em nosso local de produ√ß√£o. <br><br><h2>  Hist√≥rico 1: Task.Delay &amp; TimerQueue </h2><br>  Esta hist√≥ria j√° √© bastante conhecida, inclusive sobre ela no DotNext anterior.  No entanto, obteve uma sequ√™ncia bastante interessante, ent√£o eu a adicionei.  Ent√£o qual √© o objetivo? <br><br><h3>  1.1 Vota√ß√£o e sondagem longa </h3><br>  O servidor executa opera√ß√µes longas, o cliente espera por elas. <br>  <b>Pesquisa: o</b> cliente pergunta periodicamente ao servidor sobre o resultado. <br>  <b>Pesquisa longa: o</b> cliente envia uma solicita√ß√£o com um tempo limite longo e o servidor responde quando a opera√ß√£o √© conclu√≠da. <br><br>  Vantagens: <br><br><ul><li>  Menos tr√°fego </li><li>  O cliente aprende sobre o resultado mais rapidamente </li></ul><br>  Imagine que temos um servidor que pode lidar com algumas solicita√ß√µes longas, por exemplo, um aplicativo que converte arquivos XML em PDF, e h√° clientes que executam essas tarefas para processamento e desejam aguardar o resultado de forma ass√≠ncrona.  Como essa expectativa pode ser realizada? <br><br>  A primeira maneira √© <b>pesquisar</b> .  O cliente inicia a tarefa no servidor e verifica periodicamente o status dessa tarefa, enquanto o servidor retorna o status da tarefa ("conclu√≠do" / "falhou" / "conclu√≠do com erro").  O cliente envia periodicamente solicita√ß√µes at√© o resultado aparecer. <br><br>  A segunda maneira √© a <b>pesquisa longa</b> .  A diferen√ßa aqui √© que o cliente envia solicita√ß√µes com tempos limite longos.  O servidor, recebendo essa solicita√ß√£o, n√£o informar√° imediatamente que a tarefa n√£o foi conclu√≠da, mas tentar√° esperar um pouco para que o resultado apare√ßa. <br>  Ent√£o, qual √© a vantagem da pesquisa longa sobre a pesquisa regular?  Em primeiro lugar, menos tr√°fego √© gerado.  Fazemos menos solicita√ß√µes de rede - menos tr√°fego est√° sendo perseguido pela rede.  Al√©m disso, o cliente poder√° descobrir o resultado mais rapidamente do que com a pesquisa regular, porque ele n√£o precisa esperar pelo intervalo entre v√°rias solicita√ß√µes de pesquisa.  O que queremos obter √© compreens√≠vel.  Como vamos implementar isso no c√≥digo? <br><blockquote>  Tarefa: tempo limite <br>  Queremos esperar a tarefa com um tempo limite <br>  aguarde SendAsync (); </blockquote>  Por exemplo, temos uma tarefa que envia uma solicita√ß√£o ao servidor e queremos aguardar o resultado com um tempo limite, ou seja, retornaremos o resultado dessa tarefa ou enviaremos algum tipo de erro.  O c√≥digo C # ficar√° assim: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sendTask = SendAsync(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> delayTask = Task.Delay(timeout); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> task = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.WhenAny(sendTask, delayTask); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (task == delayTask) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Timeout;</code> </pre> <br>  Esse c√≥digo inicia nossa tarefa, cujo resultado queremos aguardar, e Task.Delay.  Em seguida, usando Task.WhenAny, estamos aguardando nossa Task ou Task.Delay.  Se o Task.Delay for executado primeiro, o tempo acabou e temos um tempo limite, devemos retornar um erro. <br><br>  Este c√≥digo, √© claro, n√£o √© perfeito e pode ser aprimorado.  Por exemplo, n√£o faria mal cancelar o Task.Delay se o SendAsync retornasse mais cedo, mas isso n√£o √© muito interessante para n√≥s agora.  A conclus√£o √© que, se escrevermos esse c√≥digo e aplic√°-lo para pesquisas longas com tempos limite longos, teremos alguns problemas de desempenho. <br><br><h3>  1.2 Problemas com pesquisas longas </h3><br><ul><li>  Timeouts grandes </li><li>  Muitas consultas simult√¢neas </li><li>  =&gt; Alta utiliza√ß√£o da CPU </li></ul><br>  Nesse caso, o problema √© o alto consumo de recursos do processador.  Pode acontecer que o processador esteja totalmente carregado em 100% e o aplicativo geralmente pare de funcionar.  Parece que n√£o consumimos recursos do processador: realizamos algumas opera√ß√µes ass√≠ncronas, aguardamos uma resposta do servidor e o processador ainda est√° carregado conosco. <br><br>  Quando enfrentamos essa situa√ß√£o, removemos um despejo de mem√≥ria do nosso aplicativo: <br><br><pre> <code class="cs hljs"> ~*e!clrstack System.Threading.Monitor.Enter(System.Object) System.Threading.TimerQueueTimer.Change(‚Ä¶) System.Threading.Timer.TimerSetup(‚Ä¶) System.Threading.Timer..ctor(‚Ä¶) System.Threading.Tasks.Task.Delay(‚Ä¶)</code> </pre> <br>  Para analisar o despejo, usamos a ferramenta WinDbg.  N√≥s inserimos um comando que mostra rastreamentos de pilha de todos os threads gerenciados e vimos esse resultado.  Temos muitos threads em processo que aguardam algum bloqueio.  O m√©todo Monitor.Enter √© o que a constru√ß√£o de bloqueio em C # expande.  Esse bloqueio √© capturado dentro de classes chamadas Timer e TimerQueueTimer.  No Timer, viemos do Task.Delay quando tentamos cri√°-los.  O que √© isso?  Quando o Task.Delay √© iniciado, o bloqueio dentro do TimerQueue √© capturado. <br><br><h3>  1.3 Comboio de bloqueio </h3><br><ul><li>  Muitos threads tentam bloquear um bloqueio </li><li>  Sob o bloqueio, pouco c√≥digo √© executado </li><li>  O tempo √© gasto na sincroniza√ß√£o do encadeamento, n√£o na execu√ß√£o do c√≥digo. </li><li>  Blocos de segmentos est√£o bloqueados - eles n√£o s√£o infinitos </li></ul><br>  Tivemos um comboio de trava no aplicativo.  Muitos threads tentam capturar o mesmo bloqueio.  Sob esse bloqueio, um pouco de c√≥digo √© executado.  Os recursos do processador aqui n√£o s√£o gastos no pr√≥prio c√≥digo do aplicativo, mas em opera√ß√µes para sincronizar threads entre si nesse bloqueio.  Tamb√©m vale a pena notar um recurso relacionado ao .NET: os threads que participam do comboio de bloqueio s√£o threads do pool de threads. <br><br>  Portanto, se os encadeamentos do conjunto de encadeamentos estiverem bloqueados, eles poder√£o terminar - o n√∫mero de encadeamentos no conjunto de encadeamentos √© limitado.  Pode ser configurado, mas ainda h√° um limite superior.  Depois de atingido, todos os threads do conjunto de threads participar√£o do comboio de bloqueio e qualquer c√≥digo que envolva o conjunto de threads deixar√° de ser executado no aplicativo.  Isso piora bastante a situa√ß√£o. <br><br><h3>  1.4 TimerQueue </h3><br><ul><li>  Gerencia temporizadores em um aplicativo .NET. </li><li>  Os temporizadores s√£o usados ‚Äã‚Äãem: <br>  - Task.Delay <br>  - CancellationTocken.CancelAfter <br>  - HttpClient </li></ul><br>  TimerQueue √© uma classe que gerencia todos os cron√¥metros em um aplicativo .NET.  Se voc√™ programou uma vez no WinForms, pode ter criado temporizadores manualmente.  Para quem n√£o sabe o que s√£o os cron√¥metros: eles s√£o usados ‚Äã‚Äãno Task.Delay (esse √© apenas o nosso caso), eles tamb√©m s√£o usados ‚Äã‚Äãdentro do CancellationToken, no m√©todo CancelAfter.  Ou seja, substituir Task.Delay por CancellationToken.CancelAfter n√£o nos ajudaria de forma alguma.  Al√©m disso, os cron√¥metros s√£o usados ‚Äã‚Äãem v√°rias classes internas do .NET, por exemplo, no HttpClient. <br><br>  At√© onde eu sei, algumas implementa√ß√µes de manipuladores HttpClient possuem temporizadores.  Mesmo se voc√™ n√£o os usar explicitamente, n√£o inicie o Task.Delay, provavelmente, voc√™ ainda os usa de qualquer maneira. <br><br>  Agora vamos ver como o TimerQueue est√° organizado por dentro. <br><br><ul><li>  Estado global (por dom√≠nio de aplicativo): <br>  - Lista vinculada dupla de TimerQueueTimer <br>  - Bloquear objeto </li><li>  Retornos de chamada do temporizador de rotina </li><li>  Temporizadores n√£o ordenados por tempo de resposta </li><li>  Adicionando um timer: O (1) + bloqueio </li><li>  Remo√ß√£o do temporizador: O (1) + bloqueio </li><li>  Temporizadores de in√≠cio: O (N) + bloqueio </li></ul><br>  Dentro de TimerQueue, existe um estado global, √© uma lista duplamente vinculada de objetos do tipo TimerQueueTimer.  TimerQueueTimer cont√©m um link para outro TimerQueueTimer, vizinho em uma lista vinculada, mas tamb√©m cont√©m a hora do timer e o retorno de chamada, que ser√£o chamados quando o timer for disparado.  Essa lista duplamente vinculada √© protegida por um objeto de bloqueio, exatamente aquele no qual o comboio de bloqueio aconteceu em nosso aplicativo.  Tamb√©m dentro do TimerQueue, h√° uma Rotina que lan√ßa retornos de chamada vinculados aos nossos timers. <br><br>  Os temporizadores n√£o s√£o ordenados pelo tempo de resposta, toda a estrutura √© otimizada para adicionar / remover novos temporizadores.  Quando o Rotina inicia, ele percorre toda a lista duplamente vinculada, seleciona os cron√¥metros que devem funcionar e os chama de volta. <br><br>  A complexidade da opera√ß√£o aqui √© tal.  Adicionar e remover um cron√¥metro ocorre O por unidade e o in√≠cio dos cron√¥metros ocorre por linha.  Al√©m disso, se tudo √© aceit√°vel com a complexidade algor√≠tmica, h√° um problema: todas essas opera√ß√µes capturam o bloqueio, o que n√£o √© muito bom. <br><br>  Que situa√ß√£o pode acontecer?  Temos muitos timers acumulados no TimerQueue; portanto, quando o Rotine inicia, ele bloqueia sua longa opera√ß√£o linear; naquele momento, aqueles que tentam iniciar ou remover timers do TimerQueue n√£o podem fazer nada a respeito.  Por esse motivo, o comboio de trava ocorre.  Este problema foi corrigido no .NET Core. <br><blockquote>  Reduzir a conten√ß√£o de bloqueio do timer (coreclr # 14527) <br><ul><li>  Fragmento de bloqueio <br>  - Environment.ProcessorCount TimerQueue's TimerQueueTimer </li><li>  Filas separadas para temporizadores de curta / longa dura√ß√£o </li><li>  Temporizador curto: tempo &lt;= 1/3 segundo </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/dotnet/coreclr/issues/14462</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/dotnet/coreclr/pull/14527</a> <br></blockquote>  Como foi consertado?  Eles invadiram o TimerQueue: em vez de um TimerQueue, que era est√°tico para todo o AppDomain, para todo o aplicativo, v√°rios TimerQueue foram feitos.  Quando os encadeamentos chegam l√° e tentam iniciar seus cron√¥metros, esses cron√¥metros caem em um TimerQueue aleat√≥rio e os encadeamentos t√™m menos chance de colidir em um bloqueio. <br><br>  Tamb√©m no .NET Core aplicamos algumas otimiza√ß√µes.  Os cron√¥metros foram divididos em TimerQueue de vida longa e de curta dura√ß√£o, agora s√£o usados ‚Äã‚Äãpara eles.  O temporizador de curta dura√ß√£o √© selecionado para ser menor que 1/3 de segundo.  N√£o sei por que essa constante foi escolhida.  No .NET Core, n√£o conseguimos detectar problemas com os cron√¥metros. <br><br><img src="https://habrastorage.org/webt/f_/am/cv/f_amcv6bohiq54ciyuunvtrr0ei.jpeg"><br><br>  <a href="">https://github.com/Microsoft/dotnet-framework-early-access/blob/master/release-notes/NET48/dotnet-48-changes.md</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/dotnet/coreclr/labels/netfx-port-consider</a> <br><br>  Esta corre√ß√£o foi portada para o .NET Framework, vers√£o 4.8.  A tag netfx-port-consider √© indicada no link acima, se voc√™ for ao reposit√≥rio .NET Core, CoreCLR, CoreFX, poder√° procurar esse problema que ser√° portado para o .NET Framework, agora existem cerca de cinquenta deles.  Ou seja, o c√≥digo-fonte aberto .NET ajudou muito, alguns bugs foram corrigidos.  Voc√™ pode ler o changelog .NET Framework 4.8: muitos erros foram corrigidos, muito mais do que em outras vers√µes do .NET.  Curiosamente, essa corre√ß√£o est√° desativada por padr√£o no .NET Framework 4.8.  Ele est√° inclu√≠do no arquivo inteiro que voc√™ conhece chamado App.config <br><br>  A configura√ß√£o no App.config que habilita essa corre√ß√£o √© chamada UseNetCoreTimer.  Antes do lan√ßamento do .NET Framework 4.8, para que nosso aplicativo funcionasse e n√£o entrasse em um comboio de trava, voc√™ precisava usar sua implementa√ß√£o do Task.Delay.  Nele, tentamos usar um heap bin√°rio para entender com mais efici√™ncia quais timers devem ser chamados agora. <br><br><h3>  1.5 Task.Delay: implementa√ß√£o nativa </h3><br><ul><li>  Binaryheap </li><li>  Sharding </li><li>  Ajudou, mas n√£o em todos os casos </li></ul><br>  O uso de um heap bin√°rio permite otimizar a Rotina, que chama retornos de chamada, mas piora o tempo necess√°rio para remover um cron√¥metro arbitr√°rio da fila - para isso, √© necess√°rio reconstruir o heap.  √â mais prov√°vel que o .NET use uma lista duplamente vinculada.  Obviamente, apenas o uso de uma pilha bin√°ria n√£o nos ajudaria aqui, tamb√©m tivemos que trabalhar com o TimerQueue.  Essa solu√ß√£o funcionou por um tempo, mas ainda assim caiu novamente no bloqueio, devido ao fato de que os timers s√£o usados ‚Äã‚Äãn√£o apenas onde s√£o executados explicitamente no c√≥digo, mas tamb√©m em bibliotecas de terceiros e no c√≥digo .NET.  Para corrigir completamente esse problema, voc√™ deve atualizar para o .NET Framework vers√£o 4.8 e habilitar a corre√ß√£o dos desenvolvedores do .NET. <br><br><h3>  1.6 Tarefa. Atraso: conclus√µes </h3><br><ul><li>  Armadilhas em todos os lugares - mesmo nas coisas mais usadas </li><li>  Fa√ßa testes de estresse </li><li>  Mude para o Core, obtenha primeiro corre√ß√µes de bugs (e novos bugs) :) </li></ul><br>  Quais s√£o as conclus√µes de toda essa hist√≥ria?  Em primeiro lugar, as armadilhas podem estar localizadas em qualquer lugar, mesmo nas classes que voc√™ usa todos os dias, sem pensar, por exemplo, na mesma tarefa, Task.Delay. <br><br>  Eu recomendo realizar testes de estresse de suas propostas.  Esse problema acabamos de identificar na fase de teste de carga.  Em seguida, filmamos v√°rias vezes na produ√ß√£o em outras aplica√ß√µes, mas, no entanto, o teste de estresse nos ajudou a adiar o tempo antes de encontrarmos esse problema na realidade. <br><br>  Alterne para o .NET Core - voc√™ ser√° o primeiro a receber corre√ß√µes de bugs (e novos bugs).  Onde sem novos bugs? <br><br>  A hist√≥ria sobre os temporizadores acabou e passamos para a pr√≥xima. <br><br><h2>  Hist√≥ria 2: SemaphoreSlim </h2><br>  A hist√≥ria a seguir √© sobre o conhecido SemaphoreSlim. <br><br><h3>  2.1 Limita√ß√£o do servidor </h3><br><ul><li>  √â necess√°rio limitar o n√∫mero de solicita√ß√µes processadas simultaneamente no servidor </li></ul><br>  Quer√≠amos implementar a otimiza√ß√£o no servidor.  O que √© isso  Voc√™ provavelmente conhece a limita√ß√£o da CPU: quando o processador superaquece, diminui sua frequ√™ncia para esfriar, e isso limita seu desempenho.  Ent√£o est√° aqui.  Sabemos que nosso servidor pode processar solicita√ß√µes de N em paralelo e n√£o cair.  O que queremos fazer?  Limite o n√∫mero de solicita√ß√µes processadas simultaneamente a essa constante e fa√ßa com que, se houver mais solicita√ß√µes, elas enfileirem e aguardem at√© que as solicita√ß√µes que vieram anteriormente sejam executadas.  Como esse problema pode ser resolvido?  √â necess√°rio usar algum tipo de primitiva de sincroniza√ß√£o. <br><br>  O sem√°foro √© uma primitiva de sincroniza√ß√£o na qual voc√™ pode esperar N vezes, ap√≥s o qual quem chega ao N + primeiro e assim por diante o aguardar√° at√© que aqueles que entraram nele lan√ßem o Semaphore.  Acontece algo assim: dois segmentos de execu√ß√£o, dois trabalhadores ficaram sob o Sem√°foro, o resto ficou na fila. <br><br><img src="https://habrastorage.org/webt/6s/bu/h7/6sbuh77p4temzi5yiofjlh-rxoi.png"><br><br>  √â claro que o Semaphore n√£o √© muito adequado para n√≥s, √© no .NET s√≠ncrono, ent√£o pegamos o SemaphoreSlim e escrevemos este c√≥digo: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> semaphore = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SemaphoreSlim(N); ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> semaphore.WaitAsync(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> HandleRequestAsync(request); semaphore.Release();</code> </pre> <br>  Criamos o SemaphoreSlim, espere, sob o Semaphore processamos sua solicita√ß√£o e depois lan√ßamos o Semaphore.  Parece que essa √© uma implementa√ß√£o ideal da otimiza√ß√£o do servidor e n√£o pode mais ser melhor.  Mas tudo √© muito mais complicado. <br><br><h3>  2.2 Limita√ß√£o do servidor: complica√ß√£o </h3><br><ul><li>  Processando solicita√ß√µes na ordem LIFO </li><li>  SemaphoreSlim </li><li>  Pilha simult√¢nea </li><li>  TaskCompletionSource </li></ul><br>  Esquecemos um pouco da l√≥gica de neg√≥cios.  Os pedidos que chegam √† limita√ß√£o s√£o pedidos HTTP reais.  Como regra, eles t√™m algum tempo limite, definido por quem enviou essa solicita√ß√£o automaticamente, ou um tempo limite do usu√°rio que pressiona F5 ap√≥s algum tempo.  Portanto, se voc√™ processar solicita√ß√µes em uma ordem da fila, como um sem√°foro regular, primeiro as solicita√ß√µes da fila que atingiram o tempo limite j√° poder√£o ser processadas.  Se voc√™ trabalha em ordem de pilha - processe primeiro todas as solicita√ß√µes que vieram na √∫ltima, esse problema n√£o surgir√°. <br><br>  Al√©m do SemaphoreSlim, tivemos que usar o ConcurrentStack, TaskCompletionSource, para envolver muito c√≥digo em torno de tudo isso, para que tudo funcionasse na ordem que precis√°vamos.  TaskCompletionSource √© uma coisa semelhante a CancellationTokenSource, mas n√£o para CancellationToken, mas para Task.  Voc√™ pode criar um TaskCompletionSource, retir√°-lo, distribu√≠-lo e informar ao TaskCompletionSource que voc√™ precisa definir o resultado dessa tarefa, e quem est√° esperando por essa tarefa descobrir√° esse resultado. <br><br>  Todos n√≥s o implementamos.  O c√≥digo √© horr√≠vel.  e, pior de tudo, acabou sendo inoperante. <br><br>  Alguns meses ap√≥s o in√≠cio de seu uso em um aplicativo bastante carregado, encontramos um problema.  Da mesma forma que no caso anterior, o consumo da CPU aumentou para 100%.  Fizemos o mesmo, removemos o despejo, o analisamos no WinDbg e novamente encontramos o comboio de trava. <br><br><img src="https://habrastorage.org/webt/h_/ef/as/h_efasuul34r0fm7vwopo2hm1bc.jpeg"><br><br>  Desta vez, o comboio de bloqueio ocorreu dentro de SemaphoreSlim.WaitAsync e SemaphoreSlim.Release.  Verificou-se que existe um bloqueio dentro do SemaphoreSlim, que n√£o √© livre de bloqueio.  Isso acabou sendo uma desvantagem bastante s√©ria para n√≥s. <br><br><img src="https://habrastorage.org/webt/0h/-k/qq/0h-kqqxojlujm3dglokmacabvwq.jpeg"><br><br>  Dentro do SemaphoreSlim, h√° um estado interno (um contador de quantos trabalhadores ainda podem passar por ele) e uma lista duplamente vinculada daqueles que est√£o esperando nesse sem√°foro.  As id√©ias aqui s√£o as mesmas: voc√™ pode esperar neste sem√°foro, voc√™ pode cancelar sua expectativa - para sair desta fila.  H√° uma fechadura que acabou de arruinar nossas vidas. <br><br>  Decidimos: com todo o c√≥digo terr√≠vel que tivemos que escrever. <br><br><img src="https://habrastorage.org/webt/ax/ls/3i/axls3iseuxmgjt-vqkeiqs7hvtq.jpeg"><br><br>  Vamos escrever nosso Sem√°foro, que ser√° imediatamente livre de bloqueios e que funcionar√° imediatamente em ordem de pilha.  Cancelar a espera n√£o √© importante para n√≥s. <br><br><img src="https://habrastorage.org/webt/rv/rg/wv/rvrgwv8apebibtiymhxpvm5giti.jpeg"><br><br>  Defina esta condi√ß√£o.  Aqui ser√° o n√∫mero currentCount - este √© o n√∫mero de lugares restantes no Sem√°foro.  Se n√£o houver vagas no Sem√°foro, esse n√∫mero ser√° negativo e mostrar√° quantos trabalhadores est√£o na fila.  Tamb√©m haver√° um ConcurrentStack, consistindo em TaskCompletionSource'ov - essa √© apenas uma pilha de waiter'ov da qual eles ser√£o extra√≠dos, se necess√°rio.  Vamos escrever o m√©todo WaitAsync. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> decrementedCount = Interlocked.Decrement(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> currentCount); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (decrementedCount &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.CompletedTask; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> waiter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskCompletionSource&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;(); waiters.Push(waiter); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> waiter.Task;</code> </pre> <br>  Primeiro, diminu√≠mos o balc√£o, ocupamos um lugar no sem√°foro por conta pr√≥pria, se tiv√©ssemos lugares livres, e depois dizemos: ‚Äú√â isso a√≠, voc√™ foi para o sem√°foro‚Äù. <br><br>  Se n√£o houver lugares no Sem√°foro, criamos um TaskCompletionSource, jogamos na pilha de waiter'ov e devolvemos a Tarefa para o mundo externo.  Quando chegar a hora, esta tarefa funcionar√°, e o trabalhador poder√° continuar seu trabalho e ficar√° sob o Sem√°foro. <br><br>  Agora vamos escrever o m√©todo Release. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> countBefore = Interlocked.Increment(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> currentCount) - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (countBefore &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (waiters.TryPop(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> waiter)) waiter.TrySetResult(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); }</code> </pre> <br>  O m√©todo Release √© o seguinte: <br><br><ul><li>  Um assento gr√°tis no sem√°foro </li><li>  Incrementar currentCount </li></ul><br>  Se pudermos dizer por currentCount se h√° gar√ßom dentro da pilha sobre o qual precisamos sinalizar, puxamos esse gar√ßom para fora da pilha e sinal.  Aqui o gar√ßom √© um TaskCompletionSource.  Pergunta para este c√≥digo: parece l√≥gico, mas funciona?  Que problemas existem?  H√° uma nuance relacionada a onde a continua√ß√£o e o TaskCompletionSource s√£o lan√ßados. <br><br><img src="https://habrastorage.org/webt/_1/zo/hu/_1zohu07rqeiemrkwrcubv7gwhe.png"><br><br>  Considere este c√≥digo.  Criamos um TaskCompletionSource e lan√ßamos duas tarefas.  A primeira tarefa exibe uma unidade, define o resultado como TaskCompletionSource e, em seguida, exibe um empate no console.  A segunda tarefa aguarda este TaskCompletionSource, em sua tarefa e, em seguida, bloqueia seu encadeamento para sempre do pool de encadeamentos. <br><br>  O que vai acontecer aqui?  A tarefa 2 na compila√ß√£o ser√° dividida em dois m√©todos, o segundo dos quais √© uma continua√ß√£o que cont√©m Thread.Sleep.  Ap√≥s definir o resultado do TaskCompletionSource, essa continua√ß√£o ser√° executada no mesmo encadeamento em que a primeira tarefa foi executada.  Consequentemente, o fluxo da primeira tarefa ser√° bloqueado para sempre e o empate no console n√£o ser√° mais impresso. <br><br>  Curiosamente, tentei alterar esse c√≥digo e, se removi a sa√≠da da unidade do console, a continua√ß√£o foi iniciada em outro encadeamento do conjunto de encadeamentos e o empate foi impresso.  Em quais casos a continua√ß√£o ser√° executada no mesmo encadeamento e em que - chegar√° ao pool de encadeamentos - uma pergunta para os leitores. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tcs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskCompletionSource&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;( TaskCreationOptions.RunContinuationsAsynchronously); <span class="hljs-comment"><span class="hljs-comment">/* OR */</span></span> Task.Run(() =&gt; tcs.TrySetResult(<span class="hljs-literal"><span class="hljs-literal">true</span></span>));</code> </pre> <br>  Para resolver esse problema, podemos criar um TaskCompletionSource com o sinalizador RunContinuationsAsynchronously correspondente ou chamar o m√©todo TrySetResult em Task.Run/ThreadPool.QueueUserWorkItem para que n√£o seja executado em nosso thread.  Se for executado em nosso segmento, podemos ter efeitos colaterais indesejados.  Al√©m disso, h√° um segundo problema, vamos abordar mais detalhadamente. <br><br><img src="https://habrastorage.org/webt/m9/x8/gx/m9x8gxz7x5tw3mjcps7nygdmkjs.jpeg"><br><br>  Veja os m√©todos WaitAsync e Release e tente encontrar outro problema no m√©todo Release. <br><br>  Muito provavelmente, encontr√°-la simplesmente imposs√≠vel.  H√° uma corrida aqui. <br><br><img src="https://habrastorage.org/webt/cs/1e/4q/cs1e4q3yaz4d3084_24z2ucsd6y.jpeg"><br><br>  Isso se deve ao fato de que, no m√©todo WaitAsync, a altera√ß√£o de estado n√£o √© at√¥mica.  Primeiro diminu√≠mos o balc√£o e s√≥ depois empurramos o gar√ßom para a pilha.  Se acontecer que o Release seja executado entre decremento e push, ele poder√° sair para que n√£o puxe nada da pilha.  Isso deve ser levado em considera√ß√£o e, no m√©todo Release, aguarde o gar√ßom aparecer na pilha. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> countBefore = Interlocked.Increment(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> currentCount) - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (countBefore &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Waiter waiter; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> spinner = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpinWait(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!waiter.TryPop(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> waiter)) spinner.SpinOnce(); waiter.TrySetResult(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); }</code> </pre> <br>  Aqui fazemos isso em um loop at√© conseguirmos retir√°-lo.  Para n√£o desperdi√ßar os ciclos do processador novamente, usamos o SpinWait. <br><br>  Nas primeiras itera√ß√µes, ele girar√° em um loop.  Se houver muitas itera√ß√µes, o gar√ßom n√£o aparecer√° por um longo per√≠odo de tempo, ent√£o nosso encadeamento ir√° para Thread.Sleep, para n√£o desperdi√ßar recursos da CPU novamente. <br><br>  De fato, o sem√°foro de ordem LIFO n√£o √© apenas nossa ideia. <br><blockquote>  <b>LowLevelLifoSemaphore</b> <br><ul><li>  S√≠ncrona </li><li>  No Windows, usa a porta IO Completion como uma pilha do Windows </li></ul><br>  <a href="">https://github.com/dotnet/corert/blob/master/src/System.Private.CoreLib/src/System/Threading/LowLevelLifoSemaphore.cs</a> </blockquote>  Existe esse sem√°foro no pr√≥prio .NET, mas n√£o no CoreCLR, n√£o no CoreFX, mas no CoreRT.  √Äs vezes, √© bastante √∫til espreitar o reposit√≥rio .NET.  Existe um sem√°foro chamado LowLevelLifoSemaphore.  Este sem√°foro n√£o seria adequado para n√≥s de qualquer maneira: √© s√≠ncrono. <br><br>  Notavelmente, no Windows, ele funciona atrav√©s das portas de conclus√£o de E / S.  Eles t√™m a propriedade de que os threads podem esperar por eles e ser√£o liberados apenas na ordem LIFO.  Esse recurso √© usado l√°, √© realmente de baixo n√≠vel. <br><br><h3>  2.3 Conclus√µes: </h3><br><ul><li>  N√£o espere que o preenchimento da estrutura sobreviva sob sua carga </li><li>  √â mais f√°cil resolver um problema espec√≠fico do que o caso geral. </li><li>  O teste de estresse nem sempre ajuda </li><li>  Cuidado com o bloqueio </li></ul><br>  Quais s√£o as conclus√µes de toda essa hist√≥ria?  Primeiro de tudo, n√£o espere que algumas classes da estrutura que voc√™ usa da biblioteca padr√£o possam lidar com sua carga.  N√£o quero dizer que o SemaphoreSlim √© ruim, acabou sendo inadequado especificamente nesse cen√°rio. <br><br>  Achamos muito mais f√°cil escrever nosso sem√°foro para uma tarefa espec√≠fica.  Por exemplo, ele n√£o suporta cancelamento de espera.  Esse recurso est√° dispon√≠vel no SemaphoreSlim usual, n√£o o temos, mas isso nos permitiu simplificar o c√≥digo. <br><br>  O teste de carga, embora ajude, nem sempre pode ajudar. <br><br> .NET  ,           ‚Äî   .        lock,  : ¬´    ?¬ª     CPU 100%,     lock', , ,   -  .NET.      . <br><br>    . <br><br><h2>  3: (A)sync IO </h2><br>    /,      . <br><br><img src="https://habrastorage.org/webt/84/qh/sz/84qhsz9je7twmgbswt5so0dfx2q.jpeg"><br><br>    lock convoy,    stack trace     Overlapped  PinnableBufferCache.   lock.     : Overlapped  PinnableBufferCache? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">OVERLAPPED</a> ‚Äî    Windows,      /.      ,        .        ,  .       ,     lock convoy.   ,      lock convoy,    ,   . <br><br><img src="https://habrastorage.org/webt/if/j_/fc/ifj_fclqmvkfgfff7zedxpj63mo.jpeg"><br><br>  ,       ,   .NET 4.5.1  4.5.2.     .NET 4.5.2,     ,    .NET 4.5.2.  .NET 4.5.1     OverlappedDataCache,      Overlapped ‚Äî ,       ,   .    ,  lock-free,   ConcurrentStack,       .  .NET 4.5.2     :  OverlappedDataCache   PinnableBufferCache. <br><br>   ? PinnableBufferCache     ,   Overlapped     ,    ,       ‚Äî      . ,     ,      . PinnableBufferCache     .   , lock-free,   ConcurrentStack.     ,      .        ,        ,  -    lock-free    list  lock'. <br><br><h3> 3.1 PinnableBufferCache </h3><br> LockConvoy: <br><br><ul><li>    </li><li>      </li></ul><br>  lock convoy  ,   -     .        list      ,     lock   ,  ,                . <br><br>     PinnableBufferCache  ,         .    : <br><br><pre> <code class="plaintext hljs">PinnableBufferCache_System.ThreadingOverlappedData_MinCount</code> </pre> <br>      ,      .  : ¬´ !         -  ¬ª.         -: <br><br><pre> <code class="cs hljs">Environment.SetEnvironmentVariable( <span class="hljs-string"><span class="hljs-string">"PinnableBufferCache_System.Threading.OverlappedData_MinCount"</span></span>, <span class="hljs-string"><span class="hljs-string">"10000"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Overlapped().GetHashCode(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; i++) GC.Collect(GC.MaxGeneration, GCCollectionMode.Forced);</code> </pre> <br>    ?     ,    Overlapped  ,   ,        .     ,   ,     ,     ,  PinnableBufferCache      lock convoy'.    ,           . <br><br>  .NET Core  PinnableBufferCache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> ,   OverlappedData   . ,        , Garbage collector     ,      .     .NET Core  .  .NET Framework,   ,     . <br><br><h3> 3.2 : </h3><br><ul><li>      </li><li>      </li><li>   .NET Core </li></ul><br>      ,     .   ,   .NET            ,       . ,  ,  .NET Core. ,     ,         -. <br><br>    key-value . <br><br><h2>  4: Concurrent key-value collections </h2><br>  .NET   concurrent-.  lock-free  ConcurrentStack  ConcurrentQueu,       .   ConcurrentDictionary,    .   lock-free  ,   ,      .    ConcurrentDictionary? <br><br><h3> 4.1 ConcurrentDictionary </h3><br> : <br><br><ul><li>  </li><li>  </li></ul><br>  Pr√≥s: <br><br><ul><li>     </li><li>   (TryAdd/TryUpdate/AddOrUpdate) </li><li> Lock-free  </li><li> Lock-free enumeration </li></ul><br>      , memory-,  ,        .    ,    ,    .NET Framework.            . ,  ,      (enumeration) lock-free. ,   . <br><br>  ,   ,   -  .NET.  key-value    -    : <br><br><img src="https://habrastorage.org/webt/ff/9f/g_/ff9fg_qzzuzvafep8c-p3seyigm.jpeg"><br><br>  -,     bucket'.      bucket',    .   ,    bucket   ,       . <br><br>    ‚Äî   ,  ConcurrentDictionary.  ConcurrentDictionary    ¬´-¬ª   .    ,      ,   ,       memory traffic.     ConcurrentDictionary,   lock'.   ‚Äî   . <br><br>    ,    Dictionary. <br><br><img src="https://habrastorage.org/webt/-_/dw/jo/-_dwjoxswmd1kecoi3aln8m7bow.jpeg"><br><br>  Dictionary  ,  Concurrent,      .     :  buckets,  entries.   buckets       bucket'   entries.   ¬´-¬ª    entries.          .      ¬´-¬ª   int,     bucket'. <br><br>   memory overhead,     ConcurrentDictionary   Dictionary. <br><br><img src="https://habrastorage.org/webt/em/aa/ch/emaachor-z_xxt7m_1wc7ntqupm.jpeg"><br><br>    Dictionary. Memory overhea'    ,       .    Dictionary  overhead  -    ,  int'.  8 . <br><br>    ConcurrentDictionary.  ConcurrentDictionary     ConcurrentDictionary.Node.   , .     int hashCode        .       ,    table (  16 ),  int hashCode     .      ,   64-    28  overhead'.       Dictionary. <br><br>  memory overhead', ConcurrentDictionary     GC   ,       .     Benchmark.   ConcurrentDictionary  ,       GC.Collect.    ? <br><br><img src="https://habrastorage.org/webt/on/yj/uq/onyjuq1rqgfkv8iav5x4z8nrnq8.jpeg"><br><br>     .       ConcurrentDictionary  10  ,        ,             ,      .   Dictionary   .      ,   ,  ,    .       . <br><br>     ,     ConcurrentDictionary? <br><br><h3> 4.2   </h3><br><ul><li>    </li><li> TTL </li><li> Dictionary+lock </li><li> Sharding </li></ul><br>     .      ConcurrentDictionary.        10  .   ,     .   TTL  ,    .        Dictionary  lock'. ,  ,  lock    .       Dictionary  lock'      ,   -     ,           lock.      ,     . <br><br><h3> 4.3  </h3><br><ul><li>   in-memory  &lt;Guid,Guid&gt; </li><li>   &gt;10 <sup>6</sup>  </li><li>       </li><li>   </li><li>        </li></ul><br>     .      ‚Äî      ,       in-memory   Guid'  Guid,     .       .     - - ,     .  ,            15    .   .     Semaphore     ConcurrentDictionary. <br><br><img src="https://habrastorage.org/webt/u4/kw/kt/u4kwkttmxwpyelqlqoqp9zxahaa.jpeg"><br><br> ,    lock-free    ,    overhead      GC.   ,          .      ,    ,       ,   .   ,     -  ,       ,    .  ,  ,      Large Object Heap.    ? <br><br>       ,     ,     Dictionary   . <br><br><img src="https://habrastorage.org/webt/kx/yn/oi/kxynoiatsy8zcyrc5dei-xohlk4.jpeg"><br><br>   Dictionary   bucket',  Entry.  Entry  , ,   ,   . <br><br><img src="https://habrastorage.org/webt/n8/7a/5r/n87a5rlkgdk62nw82qysi3fmi18.png"><br><br>  Dictionary   ,   ,      . ,     - . <br><br>      ,  -     ? -,  ,       ,     ,      .     .    Dictionary,     , buckets, entries,              Interlocked. ,         . <br><blockquote> <b>Dictionary</b> <br><ul><li>   ,    </li><li>     ,   ? <br> ‚Äî  Resize  buckets  entries   <br> ‚Äî      - <br> ‚Äî    Dictionary.Entry <br> ‚Äî   -   </li></ul><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://blogs.msdn.microsoft.com/tess/2009/12/21/high-cpu-in-net-app-using-a-static-generic-dictionary/</a> </blockquote>     ,       Dictionary       -  bucket'.       ,      .    ,     ,        .       ,       ,    . <br><br>      Entry  Dictionary.     - -    .  ,     . <br><br><img src="https://habrastorage.org/webt/4p/xb/aq/4pxbaqil2cd4jaxnayxjqz-5yae.jpeg"><br><br>    .NET Framework  1.1.     Hashtable,   Dictionary,    object'.     MSDN ,      .  ,             -.   .  ,  Hashtable  .  ,      . <br><br><h3> 4.4    Dictionary.Entry </h3><br><img src="https://habrastorage.org/webt/y2/ww/rs/y2wwrslyuqpioqcalmpnt8dh6cw.jpeg"><br>    ? Dictionary.Entry ,  ,  8 , ,  ,   ,     .   ? <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> writing; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> version; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.writing = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; buckets[index] = ‚Ä¶; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.version++; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.writing = <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br>   :  (    ,    )  int-.   ,  .   ,     , ,  ,  . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> writing; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> version; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> version = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.version; bucket = bickets[index]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.writing || version != <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.version) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br>    ,     ,         .       ,   .       ,  8 . <br><br><h3> 4.5   -   </h3><br>  ,   . <br><br><img src="https://habrastorage.org/webt/hh/bp/0l/hhbp0leb95qndz4bmg-2gtvmeue.jpeg"><br><br>  Dictionary     bucket    ,     . <br><br>  Dictionary,    .      : 0  2.   bucket, 1       2.   ?     0.   ,       ,    2.     .   ,  2,       , , 1. 1       2 ‚Äî     bucket.   ,      ,   .    1 ‚Äî ,     bucket.  Hashtable     ,     bucket'  -.        ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">double hashing</a> . <br><br><h3> 4.6   </h3><br><ul><li>     </li><li>      </li></ul><br> <b></b> <br><br><ul><li>        </li><li>    ,  resize </li></ul><br> <b></b> <br><br><ul><li>     ,      </li></ul><br>        .         ,       Buckets,     Entries (   Buckets,     Entries).   -  ,       ,   ,          ,    . <br><br>             .    ,    . <br><br>  :     ,      ,    ,     ,     . ,       ,   . <br><br><img src="https://habrastorage.org/webt/pm/lo/ah/pmloah0wlfbq7ilvlnrvbh3pyuu.png"><br><br>     ,   , ‚Äî  . <br><br>   ?   ,  -    2.   -   Capacity  ,            .    ‚Äî 2.       ,   .      2.    ?  ,  ,     ,   .    -  ,        ,       3. ,    ,  ,    ,  ,  . <br><br>  ,    Hashtable,  .   ,     double hashing.     ,       ,   ,     . <br><br>   ,      ,     ‚Äî   ,            .     Hashtable.   ,    ‚Äî     ‚Äî       .                 .  ,     bucket',       -  ,       .  . <br><br>     ,  ,   lock-free      LOH. <br><br><img src="https://habrastorage.org/webt/pg/2b/6b/pg2b6bbfkm_3nnkds27g2krziz8.jpeg"><br><br>   lock-free ?  MSDN    Hashtable ,      .    ,            ,            . <br><br><img src="https://habrastorage.org/webt/yu/sg/he/yusghe0crfu9ywaic0aozpr7wri.jpeg"><br><br>      ,     ,        ,   bucket'.         Dictionary  bucket',  -,   bucket'      .    -    bucket,  bucket  .      ,     . <br><br>  ,       Large Object Heap. <br><br><img src="https://habrastorage.org/webt/wf/po/8o/wfpo8ou1_fpzhdkgcdbjzw-7u9q.jpeg"><br><br>      .  CustomDictionary  CustomDictionarySegment    .   Dictionary,    ,      .   ‚Äî   Dictionary,      .       ,      Large Object Heap.        ,   bucket'   . ,      ,    ,   bucket,     - - . <br><br>           .       ConcurrentDictionary,     .NET,        ,      . <br><br><h3> 4.7  </h3><br><ul><li> .NET   </li><li>    </li><li>   </li><li> ,     </li><li>   </li><li>   </li></ul><br>     ? .NET  .   .   ,     ,       .    -   ‚Äî   - .   ,  , ,     . <br><br>  -   , ,   ,     ,   .   ,   ,   ,        , ,          .   ‚Äî   , ,   . <br><br><h3>   </h3><br><ul><li>   ConcurrentDictionary: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://habr.com/ru/company/skbkontur/blog/348508/</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/vostok/commons.threading</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/epeshk/dotnext-2019-threading</a> </li></ul><br>   ‚Äî          ConcurrentDictionary. ,      ,   ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Diafilm</a> ),       . <br><br>      GitHub.   ‚Äî     ,    ,    LIFO-Semaphore,    .       ,    . <br><blockquote> 6-7     <b>DotNext 2019 Moscow</b>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">¬´.NET:  ¬ª</a>    ,        .NET Framework  .NET Core,  ,        . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt468611/">https://habr.com/ru/post/pt468611/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt468601/index.html">Estimativa do prazo do projeto. Por que quase sempre √© muito discreto e o que fazer sobre isso</a></li>
<li><a href="../pt468603/index.html">O Rutracker incluiu o eSNI. Fim da era do DPI e fim dos bloqueios</a></li>
<li><a href="../pt468605/index.html">Ponteiros constantes para ponteiros para ponteiros ...</a></li>
<li><a href="../pt468607/index.html">Android para o engenheiro de r√°dio (parte dois)</a></li>
<li><a href="../pt468609/index.html">O desempenho incompreens√≠vel da programa√ß√£o m√∫ltipla</a></li>
<li><a href="../pt468615/index.html">Os 10 principais idiomas para localiza√ß√£o de aplicativos</a></li>
<li><a href="../pt468621/index.html">Traduzimos a rede dom√©stica para DoH, ou outro clique no nariz do filtro</a></li>
<li><a href="../pt468623/index.html">Quero resenhas sobre Habr</a></li>
<li><a href="../pt468625/index.html">Sem servidor: 15% mais lento e oito vezes mais caro</a></li>
<li><a href="../pt468627/index.html">M√≥dulos de E / S ADAM-6200</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>