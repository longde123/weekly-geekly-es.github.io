<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📚 🐓 🍘 Pemikiran fungsional. Bagian 10 😜 ⬜️ 👨🏼‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bisakah Anda bayangkan ini adalah kesepuluh siklus! Meskipun narasi sebelumnya berfokus pada gaya yang murni fungsional, kadang-kadang nyaman untuk be...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pemikiran fungsional. Bagian 10</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/433410/"><p>  Bisakah Anda bayangkan ini adalah kesepuluh siklus!  Meskipun narasi sebelumnya berfokus pada gaya yang murni fungsional, kadang-kadang nyaman untuk beralih ke gaya berorientasi objek.  Dan salah satu fitur utama gaya berorientasi objek adalah kemampuan untuk melampirkan fungsi ke kelas dan mengakses kelas melalui titik untuk mendapatkan perilaku yang diinginkan. </p><br><p><img src="https://habrastorage.org/webt/7j/cd/7x/7jcd7xzdvnhpyxuebjvbzb1uiqs.jpeg"></p><br><ul><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian pertama</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian kedua</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian ketiga</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian keempat</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian kelima</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian keenam</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian ketujuh</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian kedelapan</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian kesembilan</a></strong> <a name="habracut"></a></li></ul><br><hr><br><p>  Dalam F #, ini dimungkinkan dengan fitur yang disebut "ketik ekstensi".  Jenis F # apa pun, bukan hanya kelas, dapat memiliki fungsi terlampir. </p><br><p>  Berikut adalah contoh melampirkan fungsi ke tipe rekaman. </p><br><pre><code class="plaintext hljs">module Person = type T = {First:string; Last:string} with // -,     member this.FullName = this.First + " " + this.Last //  let create first last = {First=first; Last=last} let person = Person.create "John" "Doe" let fullname = person.FullName</code> </pre> <br><p>  Poin-poin penting untuk diperhatikan: </p><br><ul><li>  Kata kunci <code>with</code> menunjukkan awal daftar anggota. </li><li>  Kata kunci <code>member</code> menunjukkan bahwa fungsinya adalah anggota (yaitu metode) </li><li>  Kata <code>this</code> adalah label dari objek yang disebut metode ini (juga disebut "pengenal diri").  Kata ini adalah awalan dari nama fungsi, dan di dalam fungsi Anda dapat menggunakannya untuk merujuk ke instance saat ini.  Tidak ada persyaratan untuk kata-kata yang digunakan sebagai pengenal diri, itu cukup bahwa mereka stabil.  Anda dapat menggunakan <code>this</code> , <code>self</code> , <code>me</code> atau kata lain yang biasanya digunakan sebagai referensi untuk diri sendiri. </li></ul><br><p>  Tidak perlu menambahkan anggota bersama dengan deklarasi tipe, Anda selalu dapat menambahkannya nanti dalam modul yang sama: </p><br><pre> <code class="plaintext hljs">module Person = type T = {First:string; Last:string} with // ,     member this.FullName = this.First + " " + this.Last //  let create first last = {First=first; Last=last} //  ,   type T with member this.SortableName = this.Last + ", " + this.First let person = Person.create "John" "Doe" let fullname = person.FullName let sortableName = person.SortableName</code> </pre> <br><p>  Contoh-contoh ini menunjukkan panggilan ke "ekstensi intrinsik".  Mereka dikompilasi menjadi suatu tipe dan akan tersedia dimanapun tipe tersebut digunakan.  Mereka juga akan ditampilkan saat menggunakan refleksi. </p><br><p>  Ekstensi internal bahkan memungkinkan Anda untuk membagi definisi tipe menjadi beberapa file, selama semua komponen menggunakan namespace yang sama dan kompilasi menjadi satu rakitan.  Seperti kelas parsial dalam C #, ini dapat berguna untuk memisahkan kode yang dihasilkan dan ditulis tangan. </p><br><h2>  Ekstensi opsional </h2><br><p>  Alternatifnya adalah menambahkan anggota tambahan dari modul yang sama sekali berbeda.  Itu disebut "ekstensi opsional."  Mereka tidak dikompilasi di dalam kelas, dan memerlukan modul lingkup yang berbeda untuk bekerja dengannya (perilaku ini menyerupai metode ekstensi dari C #). </p><br><p>  Misalnya, biarkan tipe <code>Person</code> didefinisikan: </p><br><pre> <code class="plaintext hljs">module Person = type T = {First:string; Last:string} with // ,     member this.FullName = this.First + " " + this.Last //  let create first last = {First=first; Last=last} //   ,   type T with member this.SortableName = this.Last + ", " + this.First</code> </pre> <br><p>  Contoh di bawah ini menunjukkan cara menambahkan ekstensi <code>UppercaseName</code> ke dalam modul lain: </p><br><pre> <code class="plaintext hljs">//    module PersonExtensions = type Person.T with member this.UppercaseName = this.FullName.ToUpper()</code> </pre> <br><p>  Sekarang Anda dapat mencoba ekstensi ini: </p><br><pre> <code class="plaintext hljs">let person = Person.create "John" "Doe" let uppercaseName = person.UppercaseName</code> </pre> <br><p>  Ups, kami mendapat kesalahan.  Itu terjadi karena <code>PersonExtensions</code> tidak dalam ruang lingkup.  Seperti dalam C #, untuk menggunakan ekstensi apa pun, Anda harus memasukkannya dalam ruang lingkup. </p><br><p>  Setelah kami melakukan ini, itu akan berhasil: </p><br><pre> <code class="plaintext hljs">//    ! open PersonExtensions let person = Person.create "John" "Doe" let uppercaseName = person.UppercaseName</code> </pre> <br><h2>  Ekstensi Jenis Sistem </h2><br><p>  Anda juga dapat memperluas jenis dari .NET libraries.  Tetapi harus diingat bahwa ketika memperluas jenis, Anda harus menggunakan nama aslinya, dan bukan alias. </p><br><p>  Misalnya, jika Anda mencoba untuk memperluas <code>int</code> , tidak akan ada yang berhasil, karena  <code>int</code> bukan nama yang valid untuk jenis: </p><br><pre> <code class="plaintext hljs">type int with member this.IsEven = this % 2 = 0</code> </pre> <br><p>  Sebagai gantinya, gunakan <code>System.Int32</code> : </p><br><pre> <code class="plaintext hljs">type System.Int32 with member this.IsEven = this % 2 = 0 let i = 20 if i.IsEven then printfn "'%i' is even" i</code> </pre> <br><h2>  Anggota statis </h2><br><p>  Anda dapat membuat fungsi anggota statis menggunakan: </p><br><ul><li>  tambahkan <code>static</code> </li><li>  hapus tag <code>this</code> </li></ul><br><pre> <code class="plaintext hljs">module Person = type T = {First:string; Last:string} with // ,     member this.FullName = this.First + " " + this.Last //   static member Create first last = {First=first; Last=last} let person = Person.T.Create "John" "Doe" let fullname = person.FullName</code> </pre> <br><p>  Anda dapat membuat anggota statis untuk tipe sistem: </p><br><pre> <code class="plaintext hljs">type System.Int32 with static member IsOdd x = x % 2 = 1 type System.Double with static member Pi = 3.141 let result = System.Int32.IsOdd 20 let pi = System.Double.Pi</code> </pre> <br><h2>  Melampirkan fitur yang ada </h2><br><p>  Pola yang sangat umum adalah perlekatan fungsi independen yang ada ke suatu jenis.  Ini memberikan beberapa keuntungan: </p><br><ul><li>  Selama pengembangan, Anda dapat mendeklarasikan fungsi independen yang merujuk fungsi independen lainnya.  Ini akan menyederhanakan pengembangan, karena inferensi tipe bekerja jauh lebih baik dengan gaya fungsional daripada dengan yang berorientasi objek ("point to point"). </li><li>  Tetapi beberapa fungsi utama dapat dilampirkan ke suatu jenis.  Ini memungkinkan pengguna untuk memilih gaya mana yang akan digunakan - fungsional atau berorientasi objek. </li></ul><br><p>  Contoh dari solusi tersebut adalah fungsi dari perpustakaan F #, yang menghitung panjang daftar.  Anda dapat menggunakan fungsi independen dari modul <code>List</code> atau menyebutnya sebagai metode instan. </p><br><pre> <code class="plaintext hljs">let list = [1..10] //   let len1 = List.length list // -  let len2 = list.Length</code> </pre> <br><p>  Dalam contoh berikut, tipe awalnya tidak memiliki anggota, kemudian beberapa fungsi didefinisikan, dan akhirnya fungsi <code>fullName</code> dilampirkan ke tipe. </p><br><pre> <code class="plaintext hljs">module Person = // ,     type T = {First:string; Last:string} //  let create first last = {First=first; Last=last} //   let fullName {First=first; Last=last} = first + " " + last //       type T with member this.FullName = fullName this let person = Person.create "John" "Doe" let fullname = Person.fullName person //  let fullname2 = person.FullName // </code> </pre> <br><p>  Fungsi <code>fullName</code> memiliki satu parameter, <code>person</code> .  Anggota terlampir menerima parameter dari tautan-sendiri. </p><br><h3>  Menambahkan Fungsi yang Ada dengan Beberapa Parameter </h3><br><p>  Ada fitur bagus lainnya.  Jika suatu fungsi yang didefinisikan sebelumnya mengambil beberapa parameter, maka ketika Anda melampirkannya ke suatu jenis, Anda tidak perlu membuat daftar semua parameter ini lagi.  Cukup menentukan parameter <code>this</code> terlebih dahulu. </p><br><p>  Pada contoh di bawah ini, fungsi <code>hasSameFirstAndLastName</code> memiliki tiga parameter.  Namun, ketika melampirkan sudah cukup untuk menyebutkan hanya satu! </p><br><pre> <code class="plaintext hljs">module Person = //    type T = {First:string; Last:string} //  let create first last = {First=first; Last=last} //   let hasSameFirstAndLastName (person:T) otherFirst otherLast = person.First = otherFirst &amp;&amp; person.Last = otherLast //      type T with member this.HasSameFirstAndLastName = hasSameFirstAndLastName this let person = Person.create "John" "Doe" let result1 = Person.hasSameFirstAndLastName person "bob" "smith" //  let result2 = person.HasSameFirstAndLastName "bob" "smith" // </code> </pre> <br><p>  Mengapa ini berhasil?  Petunjuk: pikirkan tentang currying dan penggunaan parsial! </p><br><h2>  Metode Tuple </h2><br><p>  Saat kami memiliki metode dengan lebih dari satu parameter, Anda harus membuat keputusan: </p><br><ul><li>  kita dapat menggunakan formulir standar (curried), di mana parameter dipisahkan oleh spasi, dan sebagian aplikasi didukung. </li><li>  atau kita bisa melewatkan <em>semua</em> parameter sekaligus dalam bentuk tuple yang dipisahkan oleh koma. </li></ul><br><p>  Bentuk kari lebih fungsional, sedangkan bentuk tuple lebih berorientasi objek. </p><br><p>  Formulir tuple juga digunakan untuk berinteraksi dengan F # dengan pustaka .NET standar, jadi Anda harus mempertimbangkan pendekatan ini secara lebih rinci. </p><br><p>  Situs pengujian kami akan menjadi tipe <code>Product</code> dengan dua metode, yang masing-masing diimplementasikan oleh salah satu metode yang dijelaskan di atas.  Metode <code>CurriedTotal</code> dan <code>TupleTotal</code> melakukan hal yang sama: mereka menghitung total biaya produk untuk jumlah dan diskon tertentu. </p><br><pre> <code class="plaintext hljs">type Product = {SKU:string; Price: float} with //   member this.CurriedTotal qty discount = (this.Price * float qty) - discount //   member this.TupleTotal(qty,discount) = (this.Price * float qty) - discount</code> </pre> <br><p>  Kode uji: </p><br><pre> <code class="plaintext hljs">let product = {SKU="ABC"; Price=2.0} let total1 = product.CurriedTotal 10 1.0 let total2 = product.TupleTotal(10,1.0)</code> </pre> <br><p>  Sejauh ini tidak ada banyak perbedaan. </p><br><p>  Tetapi kita tahu bahwa versi kari dapat diterapkan sebagian: </p><br><pre> <code class="plaintext hljs">let totalFor10 = product.CurriedTotal 10 let discounts = [1.0..5.0] let totalForDifferentDiscounts = discounts |&gt; List.map totalFor10</code> </pre> <br><p>  Di sisi lain, versi tuple mampu melakukan sesuatu yang tidak dapat digulung, yaitu: </p><br><ul><li>  Parameter yang Dinamai </li><li>  Parameter opsional </li><li>  Kelebihan </li></ul><br><h3>  Dinamai parameter dengan parameter dalam bentuk tuple </h3><br><p>  Pendekatan tuple mendukung parameter bernama: </p><br><pre> <code class="plaintext hljs">let product = {SKU="ABC"; Price=2.0} let total3 = product.TupleTotal(qty=10,discount=1.0) let total4 = product.TupleTotal(discount=1.0, qty=10)</code> </pre> <br><p>  Seperti yang Anda lihat, ini memungkinkan Anda untuk mengubah urutan argumen dengan secara eksplisit menyebutkan nama. </p><br><p>  Perhatian: jika hanya beberapa parameter yang memiliki nama, maka parameter ini harus selalu di akhir. </p><br><h3>  Parameter opsional dengan parameter dalam bentuk tuple </h3><br><p>  Untuk metode dengan parameter dalam bentuk tuple, Anda dapat menandai parameter sebagai opsional menggunakan awalan dalam bentuk tanda tanya di depan nama parameter. </p><br><ul><li>  Jika parameter diatur, maka <code>Some value</code> akan diteruskan ke fungsi </li><li>  Kalau tidak, tidak <code>None</code> akan datang </li></ul><br><p>  Contoh: </p><br><pre> <code class="plaintext hljs">type Product = {SKU:string; Price: float} with //   member this.TupleTotal2(qty,?discount) = let extPrice = this.Price * float qty match discount with | None -&gt; extPrice | Some discount -&gt; extPrice - discount</code> </pre> <br><p>  Dan tesnya: </p><br><pre> <code class="plaintext hljs">let product = {SKU="ABC"; Price=2.0} //    let total1 = product.TupleTotal2(10) //   let total2 = product.TupleTotal2(10,1.0)</code> </pre> <br><p>  Memeriksa secara eksplisit untuk <code>None</code> dan <code>Some</code> dapat membosankan, tetapi ada solusi yang lebih elegan untuk menangani parameter opsional. </p><br><p>  Ada fungsi <code>defaultArg</code> yang menggunakan nama parameter sebagai argumen pertama dan nilai default sebagai argumen kedua.  Jika parameter diatur, nilai yang sesuai akan dikembalikan, jika tidak, nilai default. </p><br><p>  Kode yang sama menggunakan <code>defaulArg</code> : </p><br><pre> <code class="plaintext hljs">type Product = {SKU:string; Price: float} with //   member this.TupleTotal2(qty,?discount) = let extPrice = this.Price * float qty let discount = defaultArg discount 0.0 extPrice - discount</code> </pre> <br><h3>  Metode kelebihan beban </h3><br><p>  Di C #, Anda dapat membuat beberapa metode dengan nama yang sama yang berbeda dalam tanda tangannya (misalnya, berbagai jenis parameter dan / atau jumlahnya). </p><br><p>  Dalam model yang murni fungsional, ini tidak masuk akal - fungsinya bekerja dengan tipe argumen tertentu (domain) dan tipe nilai pengembalian spesifik (rentang).  Fungsi yang sama tidak dapat berinteraksi dengan domain dan rentang lain. </p><br><p>  Namun, F # mendukung metode overloading, tetapi hanya untuk metode (yang terlampir pada jenis) dan hanya yang ditulis dalam gaya tuple. </p><br><p>  Ini adalah contoh dengan variasi lain dari metode <code>TupleTotal</code> ! </p><br><pre> <code class="plaintext hljs">type Product = {SKU:string; Price: float} with //   member this.TupleTotal3(qty) = printfn "using non-discount method" this.Price * float qty //   member this.TupleTotal3(qty, discount) = printfn "using discount method" (this.Price * float qty) - discount</code> </pre> <br><p>  Sebagai aturan, kompiler F # bersumpah bahwa ada dua metode dengan nama yang sama, tetapi dalam kasus ini ini dapat diterima, karena  mereka dinyatakan dalam notasi tuple dan tanda tangan mereka berbeda.  (Untuk memperjelas metode mana yang dipanggil, saya menambahkan pesan kecil untuk debugging) </p><br><p>  Contoh penggunaan: </p><br><pre> <code class="plaintext hljs">let product = {SKU="ABC"; Price=2.0} //    let total1 = product.TupleTotal3(10) //   let total2 = product.TupleTotal3(10,1.0)</code> </pre> <br><h2>  Hai!  Tidak begitu cepat ... Kerugian menggunakan metode </h2><br><p>  Berasal dari dunia berorientasi objek, Anda dapat tergoda untuk menggunakan metode di mana saja, karena itu adalah sesuatu yang akrab.  Tetapi Anda harus berhati-hati, karena  mereka memiliki sejumlah kelemahan serius: </p><br><ul><li>  Metode tidak bekerja dengan baik dengan inferensi tipe </li><li>  Metode tidak berfungsi dengan baik dengan fungsi tingkat tinggi </li></ul><br><p>  Bahkan, dengan menyalahgunakan metode, Anda dapat kehilangan aspek pemrograman yang paling kuat dan berguna di F #. </p><br><p>  Mari kita lihat apa yang saya maksud. </p><br><h3>  Metode berinteraksi buruk dengan inferensi tipe </h3><br><p>  Mari kita kembali ke contoh dengan <code>Person</code> , di mana logika yang sama diimplementasikan dalam fungsi independen dan metode: </p><br><pre> <code class="plaintext hljs">module Person = //    type T = {First:string; Last:string} //  let create first last = {First=first; Last=last} //   let fullName {First=first; Last=last} = first + " " + last // - type T with member this.FullName = fullName this</code> </pre> <br><p>  Sekarang mari kita lihat seberapa baik tipe inferensi bekerja dengan masing-masing metode.  Misalkan saya ingin mencetak nama lengkap seseorang, maka saya akan mendefinisikan fungsi <code>printFullName</code> , yang <code>printFullName</code> <code>person</code> sebagai parameter. </p><br><p>  Kode menggunakan fungsi independen dari modul: </p><br><pre> <code class="plaintext hljs">open Person //    let printFullName person = printfn "Name is %s" (fullName person) //    // val printFullName : Person.T -&gt; unit</code> </pre> <br><p>  Ini mengkompilasi tanpa masalah, dan ketik inferensi dengan benar mengidentifikasi parameter sebagai <code>Person</code> . </p><br><p>  Sekarang coba versi melalui titik: </p><br><pre> <code class="plaintext hljs">open Person //    " " let printFullName2 person = printfn "Name is %s" (person.FullName)</code> </pre> <br><p>  Kode ini tidak dikompilasi sama sekali, karena  type inference tidak memiliki informasi yang cukup untuk menentukan tipe parameter.  Objek apa pun dapat mengimplementasikan <code>.FullName</code> - ini tidak cukup untuk output. </p><br><p>  Ya, kami dapat membuat anotasi fungsi dengan tipe parameter, tetapi karena ini, seluruh titik inferensi tipe otomatis hilang. </p><br><h3>  Metode berjalan buruk dengan fungsi tingkat tinggi </h3><br><p>  Masalah serupa muncul dalam fungsi tingkat tinggi.  Misalnya, ada daftar orang, dan kita perlu mendapatkan daftar nama lengkap mereka. </p><br><p>  Dalam kasus fungsi independen, solusinya sepele: </p><br><pre> <code class="plaintext hljs">open Person let list = [ Person.create "Andy" "Anderson"; Person.create "John" "Johnson"; Person.create "Jack" "Jackson"] //     list |&gt; List.map fullName</code> </pre> <br><p>  Dalam hal metode objek, Anda harus membuat lambda khusus di mana-mana: </p><br><pre> <code class="plaintext hljs">open Person let list = [ Person.create "Andy" "Anderson"; Person.create "John" "Johnson"; Person.create "Jack" "Jackson"] //    list |&gt; List.map (fun p -&gt; p.FullName)</code> </pre> <br><p>  Tetapi ini masih merupakan contoh yang cukup sederhana.  Metode objek cukup dapat diterima untuk komposisi, tidak nyaman dalam pipa, dll. </p><br><p>  Karena itu, jika Anda baru mengenal pemrograman fungsional, maka saya mendorong Anda: jika Anda bisa, jangan gunakan metode, terutama dalam proses pembelajaran.  Mereka akan menjadi penopang yang tidak akan memungkinkan Anda untuk mengekstrak manfaat maksimal dari pemrograman fungsional. </p><br><h1>  Sumber Daya Tambahan </h1><br><p>  Ada banyak tutorial untuk F #, termasuk materi untuk mereka yang datang dengan pengalaman C # atau Java.  Tautan berikut mungkin berguna saat Anda masuk lebih dalam ke F #: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panduan F #</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">F # untuk Kesenangan dan Keuntungan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">F # Wiki</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Belajar X dalam Y Menit: F #</a> </li></ul><br><p>  Beberapa cara lain <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuk mulai belajar F #</a> juga dijelaskan. </p><br><p>  Akhirnya, komunitas F # sangat ramah pemula.  Ada obrolan yang sangat aktif di Slack, didukung oleh F # Software Foundation, dengan kamar pemula yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dapat</a> Anda <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gabung dengan bebas</a> .  Kami sangat menyarankan Anda melakukan ini! </p><br><p>  Jangan lupa untuk mengunjungi situs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komunitas berbahasa Rusia F #</a> !  Jika Anda memiliki pertanyaan tentang belajar bahasa, dengan senang hati kami akan membahasnya di ruang obrolan: </p><br><ul><li>  kamar <code>#ru_general</code> di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">F # Software Foundation Slack Chat</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengobrol di Telegram</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengobrol dalam gitter</a> </li><li>  kamar #en_general di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">F # Software Foundation Slack Chat</a> </li></ul><br><h2>  Tentang penulis terjemahan </h2><br><p>  Diterjemahkan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>@kleidemos</em></a> <br><img src="https://habrastorage.org/getpro/habr/post_images/f95/c6d/92c/f95c6d92c5b1126b093792a43955aa43.png" width="56" height="56">  Perubahan terjemahan dan editorial dilakukan oleh upaya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komunitas pengembang F # berbahasa Rusia</a> .  Kami juga berterima kasih kepada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>@schvepsss</em></a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>@shwars</em></a> karena telah menyiapkan artikel ini untuk dipublikasikan. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id433410/">https://habr.com/ru/post/id433410/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id433400/index.html">React Tutorial Bagian 2: Komponen Fungsional</a></li>
<li><a href="../id433402/index.html">Pemikiran fungsional. Bagian 8</a></li>
<li><a href="../id433404/index.html">Bereaksi Tutorial Bagian 3: File Komponen, Struktur Proyek</a></li>
<li><a href="../id433406/index.html">Pemikiran fungsional. Bagian 9</a></li>
<li><a href="../id433408/index.html">Penanganan memori yang efisien di Node.js</a></li>
<li><a href="../id433412/index.html">Pemikiran fungsional. Bagian 11: Final</a></li>
<li><a href="../id433414/index.html">Menguji Monitor Jaringan PRTG dan membandingkannya dengan Zabbix</a></li>
<li><a href="../id433420/index.html">Hasil ZeroNights 2018</a></li>
<li><a href="../id433424/index.html">Apakah mungkin memuat level yang tidak bisa dilewati di Super Mario Maker?</a></li>
<li><a href="../id433428/index.html">Dari mana kreativitas berasal: analisis aktivitas gelombang alpha otak selama tes RAT</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>