<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍🔬 👨🏾‍🤝‍👨🏼 👐 反应：提升状态将杀死您的应用程序 🧚🏼 📫 👩🏼‍🎤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="您听说过“提起国家”吗？ 我想你有，这就是为什么你在这里。 React官方文档中列出的12个主要概念之一可能会导致性能下降吗？ 在本文中，我们将考虑实际情况。 
 步骤1：提起 


 我建议您创建一个简单的井字游戏。 对于游戏，我们需要： 


- 一些游戏状态。 没有真正的游戏逻辑来找出我们是输...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>反应：提升状态将杀死您的应用程序</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471300/"><p><img src="https://habrastorage.org/webt/gd/9i/zn/gd9iznyftdnoffeagz18yy8aqeu.jpeg" alt="封面"></p><br><p> 您听说过“提起国家”吗？ 我想你有，这就是为什么你在这里。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">React官方文档中列出的12个主要概念之一</a>可能会导致性能下降吗？ 在本文中，我们将考虑实际情况。 </p><a name="habracut"></a><br><h2 id="step-1-lift-it-up"> 步骤1：提起 </h2><br><p> 我建议您创建一个简单的井字游戏。 对于游戏，我们需要： </p><br><ul><li><p>一些游戏状态。 没有真正的游戏逻辑来找出我们是输是赢。 只是一个简单的二维数组，其中填充了<code>undefined</code> ， <code>"x"</code>或<code>"0".</code> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> size = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-comment"><span class="hljs-comment">// Two-dimensional array (size * size) filled with `undefined`. Represents an empty field. const initialField = new Array(size).fill(new Array(size).fill(undefined))</span></span></code> </pre> <br></li><li><p> 一个父容器来托管我们的游​​戏状态。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [field, setField] = useState(initialField) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;div&gt; {field.map((row, rowI</span></span></span><span class="hljs-function">) =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {row.map((cell, cellI) =&gt; ( </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Cell</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">content</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{cell}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">setContent</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{</span></span></span></span><span class="xml"><span class="hljs-tag"> // </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Update</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">a</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">single</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">cell</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">of</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">a</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">two-dimensional</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">array</span></span></span></span><span class="xml"><span class="hljs-tag"> // </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">and</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">return</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">a</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">new</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">two</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">dimensional</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">array</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">newContent</span></span></span></span><span class="xml"><span class="hljs-tag">) =&gt;</span></span></span><span class="xml"> setField([ // Copy rows before our target row ...field.slice(0, rowI), [ // Copy cells before our target cell ...field[rowI].slice(0, cellI), newContent, // Copy cells after our target cell ...field[rowI].slice(cellI + 1), ], // Copy rows after our target row ...field.slice(rowI + 1), ]) } /&gt; ))} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ))} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ) }</code> </pre> <br></li><li><p> 显示单个单元格状态的子组件。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> randomContent = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() &gt; <span class="hljs-number"><span class="hljs-number">0.5</span></span> ? <span class="hljs-string"><span class="hljs-string">'x'</span></span> : <span class="hljs-string"><span class="hljs-string">'0'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Cell = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ content, setContent }</span></span></span><span class="hljs-function">) =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{()</span></span></span></span><span class="xml"><span class="hljs-tag"> =&gt;</span></span></span><span class="xml"> setContent(randomContent())}&gt;{content}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> )</code> </pre> <br></li></ul><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">现场演示＃1</a> </p><br><p> 到目前为止看起来还不错。 您可以以光速交互的完美反应场：)让我们增大尺寸。 假设是100。是的，是时候单击该演示链接并在最顶部更改<code>size</code>变量了。 还是为您快速？ 尝试200或使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Chrome内置的CPU节流</a> 。 您现在看到单击单元格的时间和其内容更改的时间之间有很大的滞后吗？ </p><br><p> 让我们将<code>size</code>更改回10，并添加一些配置文件以调查原因。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Cell = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ content, setContent }</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'cell rendered'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{()</span></span></span></span><span class="xml"><span class="hljs-tag"> =&gt;</span></span></span><span class="xml"> setContent(randomContent())}&gt;{content}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">现场演示＃2</a> </p><br><p> 是的，就是这样。 只要在每个渲染器上运行，简单的<code>console.log</code>就足够了。 </p><br><p> 那我们看到了什么？ 根据控制台中“单元格渲染”语句的数量（对于<code>size</code> = N，应为N），似乎每次单个单元格更改时都会重新渲染整个字段。 </p><br><p> 最明显的事情是按照<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">React文档的建议</a>添加一些密钥。 </p><br><pre> <code class="javascript hljs">&lt;div&gt; {field.map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">row, rowI</span></span></span><span class="hljs-function">) =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">key</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{rowI}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {row.map((cell, cellI) =&gt; ( </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Cell</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">key</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{</span></span></span></span><span class="xml"><span class="hljs-tag">`</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">row</span></span></span></span><span class="xml"><span class="hljs-tag">${</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">rowI</span></span></span></span><span class="xml"><span class="hljs-tag">}</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">cell</span></span></span></span><span class="xml"><span class="hljs-tag">${</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">cellI</span></span></span></span><span class="xml"><span class="hljs-tag">}`} </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">content</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{cell}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">setContent</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{(newContent)</span></span></span></span><span class="xml"><span class="hljs-tag"> =&gt;</span></span></span><span class="xml"> setField([ ...field.slice(0, rowI), [ ...field[rowI].slice(0, cellI), newContent, ...field[rowI].slice(cellI + 1), ], ...field.slice(rowI + 1), ]) } /&gt; ))} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ))} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">现场演示＃3</a> </p><br><p> 但是，再次增大<code>size</code>后，我们发现该问题仍然存在。 只要能看清为什么要渲染任何组件……幸运的是，我们可以在惊人的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">React DevTools的</a>帮助下获得帮助。 它能够记录为什么渲染组件。 但是，您必须手动启用它。 </p><br><p><img src="https://habrastorage.org/webt/36/ms/b4/36msb4eskbqe6txnqv5j3phjfda.png" alt="React DevTools设置"></p><br><p> 启用后，我们可以看到所有单元都被重新渲染，因为它们的道具发生了变化，特别是<code>setContent</code>道具。 </p><br><p><img src="https://habrastorage.org/webt/nv/3o/on/nv3oon4uvu6om8oea4fnnaun8m4.png" alt="React DevTools报告＃1"></p><br><p> 每个单元都有两个道具： <code>content</code>和<code>setContent</code> 。 如果单元格[0] [0]更改，则单元格[0] [1]的内容不变。 另一方面， <code>setContent</code>在其闭包中捕获<code>field</code> ， <code>cellI</code>和<code>rowI</code> 。  <code>cellI</code>和<code>rowI</code>保持不变，但是<code>field</code>随任何单元格的每次更改而改变。 </p><br><p> 让我们重构我们的代码，并保持<code>setContent</code>不变。 </p><br><p> 为了使对<code>setContent</code>的引用相同，我们应该删除闭包。 我们可以通过使<code>Cell</code>显式地将<code>cellI</code>和<code>rowI</code>传递给<code>setContent</code>来消除<code>cellI</code>和<code>rowI</code>闭包。 对于<code>field</code> ，我们可以利用<code>setState</code>的简洁功能- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">它接受回调</a> 。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [field, setField] = useState(initialField) <span class="hljs-comment"><span class="hljs-comment">// `useCallback` keeps reference to `setCell` the same. const setCell = useCallback( (rowI, cellI, newContent) =&gt; setField((oldField) =&gt; [ ...oldField.slice(0, rowI), [ ...oldField[rowI].slice(0, cellI), newContent, ...oldField[rowI].slice(cellI + 1), ], ...oldField.slice(rowI + 1), ]), [], )</span></span></code> </pre> <br><p> 这使得<code>App</code>看起来像这样 </p><br><pre> <code class="javascript hljs">&lt;div&gt; {field.map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">row, rowI</span></span></span><span class="hljs-function">) =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">key</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{rowI}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {row.map((cell, cellI) =&gt; ( </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Cell</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">key</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{</span></span></span></span><span class="xml"><span class="hljs-tag">`</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">row</span></span></span></span><span class="xml"><span class="hljs-tag">${</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">rowI</span></span></span></span><span class="xml"><span class="hljs-tag">}</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">cell</span></span></span></span><span class="xml"><span class="hljs-tag">${</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">cellI</span></span></span></span><span class="xml"><span class="hljs-tag">}`} </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">content</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{cell}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">rowI</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{rowI}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">cellI</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{cellI}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">setContent</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{setCell}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> ))} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ))} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br><p> 现在， <code>Cell</code>必须将<code>cellI</code>和<code>rowI</code>传递给<code>setContent</code> 。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Cell = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ content, rowI, cellI, setContent }</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'cell render'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;div onClick={(</span></span></span><span class="hljs-function">) =&gt;</span></span> setContent(rowI, cellI, randomContent())}&gt; {content} &lt;<span class="hljs-regexp"><span class="hljs-regexp">/div&gt; ) }</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">现场演示＃4</a> </p><br><p> 让我们看一下DevTools报告。 </p><br><p><img src="https://habrastorage.org/webt/63/i5/po/63i5poiao3t3rt62mr_zubgycjw.png" alt="React DevTools报告＃2"></p><br><p> 什么 为什么说“父母的道具变了”？ 所以事情是，每次我们的领域更新时， <code>App</code>都会重新渲染。 因此，其子组件将被重新渲染。 好啦  stackoverflow是否说了一些有关React性能优化的有用信息？  Internet建议使用<code>shouldComponentUpdate</code>或其近亲： <code>PureComponent</code>和<code>memo</code> 。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Cell = memo(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ content, rowI, cellI, setContent }</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'cell render'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;div onClick={(</span></span></span><span class="hljs-function">) =&gt;</span></span> setContent(rowI, cellI, randomContent())}&gt; {content} &lt;<span class="hljs-regexp"><span class="hljs-regexp">/div&gt; ) })</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">现场演示＃5</a> </p><br><p> 耶 现在，一旦其内容更改，仅一个单元会被重新渲染。 但是等等...有什么惊喜吗？ 我们遵循最佳实践，并获得了预期的结果。 </p><br><p> 本来应该有一个邪恶的笑声。 由于我不在您身边，请尽量尝试想象一下。 继续并在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Live demo＃5中</a>增加<code>size</code> 。 这次，您可能需要使用更大的数字。 但是，滞后仍然存在。 为什么??? </p><br><p> 让我们再次查看DebTools报告。 </p><br><p><img src="https://habrastorage.org/webt/ls/w8/gs/lsw8gsgvp_bnjvnxjramglhrnng.png" alt="React DevTools报告＃3"></p><br><p> 只有一个<code>Cell</code>渲染，而且速度相当快，但是还有一个<code>App</code>渲染，这花费了很多时间。 问题是，每次重新渲染<code>App</code>每个<code>Cell</code>都必须将其新道具与以前的道具进行比较。 即使决定不渲染（这正是我们的情况），该比较仍然需要时间。  O（1），但是O（1）出现<code>size</code> *大小乘以！ </p><br><h2 id="step-2-move-it-down"> 步骤2：将其向下移 </h2><br><p> 我们可以做些什么来解决呢？ 如果渲染<code>App</code>花费太多，我们必须停止渲染<code>App</code> 。 如果继续使用<code>useState</code>在<code>App</code>托管我们的状态是<code>useState</code> ，因为这正是触发重新渲染的原因。 因此，我们必须向下移动状态，并让每个<code>Cell</code>自己订阅该状态。 </p><br><p> 让我们创建一个专用的类，该类将成为我们状态的容器。 </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Field</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(fieldSize) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size = fieldSize <span class="hljs-comment"><span class="hljs-comment">// Copy-paste from `initialState` this.data = new Array(this.size).fill(new Array(this.size).fill(undefined)) } cellContent(rowI, cellI) { return this.data[rowI][cellI] } // Copy-paste from old `setCell` setCell(rowI, cellI, newContent) { console.log('setCell') this.data = [ ...this.data.slice(0, rowI), [ ...this.data[rowI].slice(0, cellI), newContent, ...this.data[rowI].slice(cellI + 1), ], ...this.data.slice(rowI + 1), ] } map(cb) { return this.data.map(cb) } } const field = new Field(size)</span></span></code> </pre> <br><p> 然后我们的<code>App</code>可能看起来像这样： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;div&gt; {</span></span><span class="hljs-regexp"><span class="hljs-function"><span class="hljs-params"><span class="hljs-regexp">//</span></span></span></span><span class="hljs-function"><span class="hljs-params"> As you can see we still need to iterate over our state to get indexes. field.map((row, rowI</span></span></span><span class="hljs-function">) =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">key</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{rowI}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {row.map((cell, cellI) =&gt; ( </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Cell</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">key</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{</span></span></span></span><span class="xml"><span class="hljs-tag">`</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">row</span></span></span></span><span class="xml"><span class="hljs-tag">${</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">rowI</span></span></span></span><span class="xml"><span class="hljs-tag">}</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">cell</span></span></span></span><span class="xml"><span class="hljs-tag">${</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">cellI</span></span></span></span><span class="xml"><span class="hljs-tag">}`} </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">rowI</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{rowI}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">cellI</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{cellI}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> ))} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ))} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ) }</code> </pre> <br><p> 并且我们的<code>Cell</code>可以自行显示<code>field</code>的内容： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Cell = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ rowI, cellI }</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'cell render'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> content = field.cellContent(rowI, cellI) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;div onClick={(</span></span></span><span class="hljs-function">) =&gt;</span></span> field.setCell(rowI, cellI, randomContent())}&gt; {content} &lt;<span class="hljs-regexp"><span class="hljs-regexp">/div&gt; ) }</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">现场演示＃6</a> </p><br><p> 至此，我们可以看到正在渲染的字段。 但是，如果单击单元格，则什么也不会发生。 在日志中，我们可以看到每次点击都显示“ setCell”，但是该单元格保持空白。 这里的原因是没有任何内容告诉单元重新渲染。  React之外的状态会发生变化，但是React对此一无所知。 那必须改变。 </p><br><p> 我们如何以编程方式触发渲染？ </p><br><p> 对于类，我们具有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">forceUpdate</a> 。 这是否意味着我们必须将代码重新编写为类？ 不完全是 我们可以对功能组件执行的操作是引入一些虚拟状态，我们仅对其进行更改以迫使我们的组件重新呈现。 </p><br><p> 这是我们如何创建自定义挂钩以强制重新渲染的方法。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> useForceRender = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [, setDummy] = useState(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> forceRender = useCallback(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> setDummy(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">oldVal</span></span></span><span class="hljs-function">) =&gt;</span></span> oldVal + <span class="hljs-number"><span class="hljs-number">1</span></span>), []) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> forceRender }</code> </pre> <br><p> 要在字段更新时触发重新渲染，我们必须知道它何时更新。 这意味着我们必须能够以某种方式订阅现场更新。 </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Field</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(fieldSize) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size = fieldSize <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size).fill(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size).fill(<span class="hljs-literal"><span class="hljs-literal">undefined</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.subscribers = {} } _cellSubscriberId(rowI, cellI) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`row</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${rowI}</span></span></span><span class="hljs-string">cell</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${cellI}</span></span></span><span class="hljs-string">`</span></span> } cellContent(rowI, cellI) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data[rowI][cellI] } setCell(rowI, cellI, newContent) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'setCell'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data = [ ...this.data.slice(<span class="hljs-number"><span class="hljs-number">0</span></span>, rowI), [ ...this.data[rowI].slice(<span class="hljs-number"><span class="hljs-number">0</span></span>, cellI), newContent, ...this.data[rowI].slice(cellI + <span class="hljs-number"><span class="hljs-number">1</span></span>), ], ...this.data.slice(rowI + <span class="hljs-number"><span class="hljs-number">1</span></span>), ] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cellSubscriber = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.subscribers[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._cellSubscriberId(rowI, cellI)] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellSubscriber) { cellSubscriber() } } map(cb) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data.map(cb) } <span class="hljs-comment"><span class="hljs-comment">// Note that we subscribe not to updates of the whole filed, but to updates of one cell only subscribeCellUpdates(rowI, cellI, onSetCellCallback) { this.subscribers[this._cellSubscriberId(rowI, cellI)] = onSetCellCallback } }</span></span></code> </pre> <br><p> 现在我们可以订阅现场更新。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Cell = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ rowI, cellI }</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'cell render'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> forceRender = useForceRender() useEffect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> field.subscribeCellUpdates(rowI, cellI, forceRender), [ forceRender, ]) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> content = field.cellContent(rowI, cellI) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;div onClick={(</span></span></span><span class="hljs-function">) =&gt;</span></span> field.setCell(rowI, cellI, randomContent())}&gt; {content} &lt;<span class="hljs-regexp"><span class="hljs-regexp">/div&gt; ) }</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">现场演示＃7</a> </p><br><p> 让我们来看看这个实现的<code>size</code> 。 尝试将其增加到以前感觉很落后的值。 而且...是时候打开一瓶好香槟了！ 我们得到了一个仅当一个单元格的状态发生变化时才渲染一个单元格和一个单元格的应用程序！ </p><br><p> 让我们看一下DevTools报告。 </p><br><p><img src="https://habrastorage.org/webt/qm/yw/3y/qmyw3yetdbimipruhngx5pa_chu.png" alt="React DevTools报告＃4"></p><br><p> 正如我们现在所看到的，只有<code>Cell</code>会被渲染，而且很快就疯狂了。 </p><br><p> 如果说现在我们的<code>Cell</code>代码是内存泄漏的潜在原因怎么办？ 如您所见，在<code>useEffect</code>我们订阅了单元格更新，但我们从未取消订阅。 这意味着，即使<code>Cell</code>被销毁，其订阅仍然有效。 让我们改变它。 </p><br><p> 首先，我们需要告诉<code>Field</code>退订的含义。 </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Field</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... unsubscribeCellUpdates(rowI, cellI) { delete this.subscribers[this._cellSubscriberId(rowI, cellI)] } }</span></span></code> </pre> <br><p> 现在我们可以将<code>unsubscribeCellUpdates</code>应用于我们的<code>Cell</code> 。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Cell = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ rowI, cellI }</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'cell render'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> forceRender = useForceRender() useEffect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { field.subscribeCellUpdates(rowI, cellI, forceRender) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> field.unsubscribeCellUpdates(rowI, cellI) }, [forceRender]) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> content = field.cellContent(rowI, cellI) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;div onClick={(</span></span></span><span class="hljs-function">) =&gt;</span></span> field.setCell(rowI, cellI, randomContent())}&gt; {content} &lt;<span class="hljs-regexp"><span class="hljs-regexp">/div&gt; ) }</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">现场演示＃8</a> </p><br><p> 那么这是什么教训？ 什么时候在组件树中向下移动状态？ 永不！ 好吧，不是真的:)坚持最佳实践，直到它们失败并且不做任何过早的优化。 坦率地说，我们在上面考虑的情况有些特定，但是，如果您需要显示非常大的列表，希望您能重新收集它。 </p><br><h2 id="bonus-step-real-world-refactoring"> 奖励步骤：真实世界中的重构 </h2><br><p> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">现场演示＃8中，</a>我们使用了global <code>field</code> ，在实际应用中应该不是这种情况。 为了解决这个问题，我们可以在<code>App</code>托管<code>field</code> ，然后使用[context]（）将其传递到树上。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AppContext = createContext() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Note how we used a factory to initialize our state here. // Field creation could be quite expensive for big fields. // So we don't want to create it each time we render and block the event loop. const [field] = useState(() =&gt; new Field(size)) return ( &lt;AppContext.Provider value={field}&gt; &lt;div&gt; {field.map((row, rowI) =&gt; ( &lt;div key={rowI}&gt; {row.map((cell, cellI) =&gt; ( &lt;Cell key={`row${rowI}cell${cellI}`} rowI={rowI} cellI={cellI} /&gt; ))} &lt;/div&gt; ))} &lt;/div&gt; &lt;/AppContext.Provider&gt; ) }</span></span></code> </pre> <br><p> 现在我们可以从<code>Cell</code>的上下文中消费<code>field</code> 。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Cell = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ rowI, cellI }</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'cell render'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> forceRender = useForceRender() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> field = useContext(AppContext) useEffect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { field.subscribeCellUpdates(rowI, cellI, forceRender) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> field.unsubscribeCellUpdates(rowI, cellI) }, [forceRender]) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> content = field.cellContent(rowI, cellI) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;div onClick={(</span></span></span><span class="hljs-function">) =&gt;</span></span> field.setCell(rowI, cellI, randomContent())}&gt; {content} &lt;<span class="hljs-regexp"><span class="hljs-regexp">/div&gt; ) }</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">现场演示＃9</a> </p><br><p> 希望您已经找到了对您的项目有用的东西。 随时向我传达您的反馈！ 我非常感谢任何批评和疑问。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN471300/">https://habr.com/ru/post/zh-CN471300/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN471282/index.html">使用Fast.ai在X光片中寻找肺炎</a></li>
<li><a href="../zh-CN471288/index.html">为“ OnAir”游戏创建角色的头像</a></li>
<li><a href="../zh-CN471294/index.html">关于Haskell，C ++和程序员的诗</a></li>
<li><a href="../zh-CN471296/index.html">精益制造-效率工具</a></li>
<li><a href="../zh-CN471298/index.html">比伯和碧兰挥笔。 AI现在正在唱歌</a></li>
<li><a href="../zh-CN471302/index.html">中国的用户验证和社会信用</a></li>
<li><a href="../zh-CN471304/index.html">帝国ERP。 娱乐会计：总账，科目，余额</a></li>
<li><a href="../zh-CN471306/index.html">用于Sailfish OS的Continent-AP VPN插件的开发</a></li>
<li><a href="../zh-CN471310/index.html">我对专业的看法非常主观，而不仅仅是IT教育</a></li>
<li><a href="../zh-CN471312/index.html">准备春季专业认证。 春季靴</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>