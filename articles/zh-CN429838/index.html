<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍰 🌦️ 🧚🏽 JavaScript指南第3部分：变量，数据类型，表达式，对象 👍🏾 💮 🚴</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="今天，在JavaScript手册的翻译的第三部分中，我们将讨论声明变量的不同方法，数据类型，表达式以及使用对象的功能。 

 → 第1部分：第一个程序，语言功能，标准 
 → 第2部分：代码样式和程序结构 
 → 第3部分：变量，数据类型，表达式，对象 
 → 第4部分：功能 
 → 第5部分：数组...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript指南第3部分：变量，数据类型，表达式，对象</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/429838/"> 今天，在JavaScript手册的翻译的第三部分中，我们将讨论声明变量的不同方法，数据类型，表达式以及使用对象的功能。 <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第1部分：第一个程序，语言功能，标准</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第2部分：代码样式和程序结构</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第3部分：变量，数据类型，表达式，对象</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第4部分：功能</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第5部分：数组和循环</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第6部分：异常，分号，通配符文字</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第7部分：严格模式，此关键字，事件，模块，数学计算</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第8部分：ES6功能概述</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第9部分：ES7，ES8和ES9标准概述</a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/jf/eo/1s/jfeo1s-pygp9g5pazca5kjwvwoa.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">变数</font> </h2><br> 变量是分配了值的标识符。 可以在程序中访问变量，以这种方式使用为其分配的值。 <br><br>  JavaScript本身的变量不包含有关将存储在其中的值类型的信息。 这意味着通过写入变量（例如字符串），以后可以在其中写入数字。 这样的操作不会引起程序错误。 因此，JavaScript有时被称为“非类型化”语言。 <br><br> 在使用变量之前，必须使用<code>var</code>或<code>let</code>关键字对其进行声明。 当涉及常量时，将使用<code>const</code>关键字。 在不使用这些关键字的情况下，可以声明变量并为其分配一个特定值，但是不建议这样做。 <br><br><h3>  <font color="#3AC1EF">▍关键字var</font> </h3><br> 在ES2015标准之前，使用<code>var</code>关键字是声明变量的唯一方法。 <br><br><pre> <code class="plaintext hljs">var a = 0</code> </pre> <br> 如果在此构造中省略<code>var</code> ，则该值将分配给未声明的变量。 该操作的结果取决于程序运行的模式。 <br><br> 因此，如果启用了所谓的严格模式，则将导致错误。 如果未启用严格模式，则将发生隐式变量声明，并将其分配给全局对象。 特别是，这意味着即使在函数完成工作后，在某个函数中以这种方式隐式声明的变量也将可用。 通常，期望函数中声明的变量不会“超出”其限制。 看起来像这样： <br><br><pre> <code class="plaintext hljs">function notVar() { bNotVar = 1 //    } notVar() console.log(bNotVar)</code> </pre> <br> 它会<code>1</code>控制台上得到<code>1</code> ，通常没有人期望程序会出现这种行为，表达式<code>bNotVar = 1</code>看起来并不像尝试声明和初始化变量，而是试图访问在函数外部<code>bNotVar = 1</code>的变量（这是很正常的）。 结果，变量的隐式声明会使读取代码的人感到困惑，并可能导致程序异常。 稍后我们将讨论功能和范围，现在，当表达式的含义是声明变量时，请始终尝试使用专用关键字。 如果在此示例中，函数主体被重写为<code>var bNotVar = 1</code> ，则尝试启动上述代码片段将导致错误消息（可以在浏览器控制台中看到）。 <br><br> 例如，它可能看起来像这样： <code>Uncaught ReferenceError: bNotVar is not defined</code> 。 其含义可以归结为以下事实：程序无法使用不存在的变量运行。 初次启动程序时，看到这样的错误消息比编写无法理解的，可能表现异常的代码要好得多。 <br><br> 如果在声明变量时未对其进行初始化，未为其分配任何值，则将自动为其分配<code>undefined</code>的值。 <br><br><pre> <code class="plaintext hljs">var a //typeof a === 'undefined'</code> </pre> <br> 通过使用<code>var</code>关键字声明的变量可以通过为它们分配新的值来重复声明（但这会使读取代码的人感到困惑）。 <br><br><pre> <code class="plaintext hljs">var a = 1 var a = 2</code> </pre> <br> 您可以在一个表达式中声明几个变量： <br><br><pre> <code class="plaintext hljs">var a = 1, b = 2</code> </pre> <br> 变量的范围称为程序的范围，在该程序中可以访问（可见）此变量。 <br><br> 使用函数外部的<code>var</code>关键字初始化的变量分配给全局对象。 它具有全局范围，可从程序中的任何位置访问。 如果使用函数内部的<code>var</code>关键字声明了变量，则该变量仅在该函数内部可见，是该函数的局部变量。 <br><br> 如果在使用<code>var</code>的函数中声明了变量，且其名称与全局范围内某个变量的名称匹配，则它将“覆盖”全局变量。 也就是说，在函数内部访问此类变量时，它将使用其本地版本。 <br><br> 重要的是要理解，块（用大括号括起来的代码区域）不会创建新的可见性区域。 调用函数时会创建一个新的作用域。  <code>var</code>关键字具有所谓的功能范围，而不是功能块。 <br><br> 如果在功能代码中声明了变量，则整个功能代码都可以看到该变量。 即使在函数代码的末尾用<code>var</code>声明了变量，您也可以在代码的开头引用它，因为引发变量（提升）的机制在JavaScript中起作用。 该机制“提高”变量声明，但不提高其初始化操作。 这可能会引起混乱，因此将其作为在函数开始时声明变量的规则。 <br><br><h3>  <font color="#3AC1EF">let关键字let</font> </h3><br>  let关键字出现在ES2015中，可以简化为<code>var</code>的“块”版本。 使用<code>let</code>关键字声明的变量的范围仅限于声明了它的块，运算符或表达式以及嵌套块。 <br><br> 如果“ let”一词本身看起来不太清楚，则可以想象使用了“ let”一词。 然后，可以将表达式<code>let color = 'red'</code>转换为英语：“让颜色为红色”，并转换为俄语：“使颜色为红色”。 <br><br> 通过使用<code>let</code>关键字，您可以消除与<code>var</code>关键字相关联的歧义（例如，您不能使用<code>let</code>两次声明相同的变量）。 例如，在初始化循环时，在函数外部使用<code>let</code>不会创建全局变量。 <br><br> 例如，这样的代码将导致错误： <br><br><pre> <code class="plaintext hljs">for (let i = 0; i &lt; 5; i++) {   console.log(i) } console.log(i)</code> </pre> <br> 如果在初始化循环时使用计数器<code>var</code>声明计数器<code>i</code> ，则在完成循环后， <code>i</code>将在循环外部可用。 <br><br> 如今，在基于现代标准开发JS程序时，您可以完全放弃<code>var</code>而仅使用<code>let</code>和<code>const</code>关键字。 <br><br><h3>  <font color="#3AC1EF">▍关键字const</font> </h3><br> 使用<code>var</code>或<code>let</code>关键字声明的变量可以被覆盖。 如果使用<code>const</code>代替这些关键字，则不能为通过常量帮助声明和初始化的常量分配新值。 <br><br><pre> <code class="plaintext hljs">const a = 'test'</code> </pre> <br> 在此示例中，不能为常数<code>a</code>分配新值。 但应注意，如果<code>a</code>不是原始值（例如数字），而是对象，则使用<code>const</code>关键字不会保护该对象不受更改。 <br><br> 当他们说将对象写入变量时，实际上是指变量引用该对象。 此链接无法更改，并且链接可以指向的对象也可以更改。 <br><br>  <code>const</code>关键字不会使对象不可变。 它只是防止以相应的常量编写的对其引用的更改。 看起来是这样的： <br><br><pre> <code class="plaintext hljs">const obj = {} console.log(obj.a) obj.a = 1 // console.log(obj.a) //obj = 5 // </code> </pre> <br> 在<code>obj</code>常量中，初始化后会写入一个新的空对象。 尝试访问其不存在的属性<code>a</code>不会导致错误。 控制台变得<code>undefined</code> 。 之后，我们向对象添加一个新属性，然后再次尝试访问它。 这次，此属性的值<code>1</code>进入控制台。 如果取消注释示例的最后一行，则尝试执行此代码将导致错误。 <br><br>  <code>const</code>关键字与<code>let</code>非常相似，尤其是它具有块作用域。 <br><br> 在现代条件下，完全可以接受使用<code>const</code>关键字，仅在特殊情况下才允许使用，声明其值不打算更改的所有实体。 怎么了 事实是，最好努力使用最简单的可用结构，以免使程序复杂化并避免错误。 <br><br><h2>  <font color="#3AC1EF">资料类型</font> </h2><br>  JavaScript有时被称为“非类型化”语言，但事实并非如此。 确实可以将不同类型的值写入变量，但是JavaScript中还是有数据类型。 特别是，我们正在谈论原始和对象数据类型。 <br><br> 为了确定某个值的数据类型，可以使用<code>typeof</code>运算符。 它返回一个指示操作数类型的字符串。 <br><br><h3>  <font color="#3AC1EF">▍原始数据类型</font> </h3><br> 以下是原始JavaScript数据类型的列表： <br><br><ul><li>  <code>number</code> </li><li>  <code>string</code> （字符串） </li><li>  <code>boolean</code> （布尔值） </li><li>  <code>null</code> （特殊<code>null</code>值） </li><li>  <code>undefined</code> （特殊值<code>undefined</code> ） </li><li>  <code>symbol</code> （在特殊情况下使用的符号，出现在ES6中） </li></ul><br> 此处，数据类型的名称以<code>typeof</code>运算符返回它们的形式给出。 <br><br> 让我们讨论一下此列表中最常用的数据类型。 <br><br><h4> 类型编号 </h4><br>  JavaScript中<code>number</code>类型的值表示为64位双精度浮点数。 <br><br> 在代码中，数字文字在十进制系统中表示为整数和小数。 您可以使用其他方法来记录数字。 例如，如果在数字文字的开头有前缀<code>0x</code>它被视为以十六进制表示的数字。 数字也可以用指数符号表示（在这种数字中，您可以找到字母<code>e</code> ）。 <br><br> 以下是整数条目的示例： <br><br><pre> <code class="plaintext hljs">10 5354576767321 0xCC //  </code> </pre> <br> 这是分数。 <br><br><pre> <code class="plaintext hljs">3.14 .1234 5.2e4 //5.2 * 10^4</code> </pre> <br> 数值文字（此行为也是某些其他原始类型的特征），当您尝试将它们作为对象访问时，在操作期间会自动将其转换为相应的对象，这些对象称为“对象包装器”。 在这种情况下，我们正在谈论对象包装器<code>Number</code> 。 <br><br> 例如，此处看起来像是尝试访问变量<code>a</code> ，其中在谷歌浏览器控制台中将数字文字作为对象写入其中。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5d6/775/b97/5d6775b97a38b1ba71d05c32b212e14f.png"></div><br>  <i><font color="#999999">数字对象换行工具提示</font></i> <br><br> 例如，如果您使用<code>Number</code>类型的对象的<code>toString()</code>方法，它将返回数字的字符串表示形式。 看起来像可以在浏览器控制台（以及常规代码）中执行的相应命令，如下所示： <br><br><pre> <code class="plaintext hljs">a.toString()</code> </pre> <br> 注意方法名称后面的双括号。 如果您不放置它们，则系统不会给出错误，但是，控制台将显示一些与数字5完全不同的东西，而不是预期的输出。 <br><br> 全局<code>Number</code>对象可以以构造函数的形式使用，可以在其帮助下创建新的数字（尽管这种形式几乎从未使用过），也可以将其用作独立实体，而无需创建它的实例（即，一些数字表示）帮助）。 例如，其<code>Number.MAX_VALUE</code>属性包含可以用JavaScript表示的最大数值。 <br><br><h4> 类型字符串 </h4><br>  <code>string</code>类型的值是<code>string</code>序列。 这些值被指定为用单引号或双引号引起来的字符串文字。 <br><br><pre> <code class="plaintext hljs">'A string' "Another string"</code> </pre> <br> 可以使用反斜杠字符将字符串值分为几部分。 <br><br><pre> <code class="plaintext hljs">"A \ string"</code> </pre> <br> 字符串可能包含所谓的转义序列，当将字符串打印到控制台时会对其进行解释。 例如，序列<code>\n</code>表示换行符。 反斜杠字符还可以用于将引号添加到包含在同一引号中的字符串。 用<code>\</code>转义引号字符会导致系统无法将其视为特殊字符。 <br><br><pre> <code class="plaintext hljs">'I\'ma developer'</code> </pre> <br> 可以使用<code>+</code>运算符来连接字符串。 <br><br><pre> <code class="plaintext hljs">"A " + "string"</code> </pre> <br><h4> 模板文字 </h4><br>  ES2015引入了所谓的模式文字或模式字符串。 它们是用反引号（ <code>`</code> ）括起来的字符串，并具有一些有趣的属性。 <br><br><pre> <code class="plaintext hljs">`a string`</code> </pre> <br> 例如，在模板文字中，您可以替换某些值，这些值是评估JavaScript表达式的结果。 <br><br><pre> <code class="plaintext hljs">`a string with ${something}` `a string with ${something+somethingElse}` `a string with ${obj.something()}`</code> </pre> <br> 使用反引号使编写多行字符串文字变得容易： <br><br><pre> <code class="plaintext hljs">`a string with ${something}`</code> </pre> <br><h4> 布尔型 </h4><br>  JavaScript有两个使用布尔值的保留字-分别为<code>true</code> （true）和<code>false</code> （false）。 比较运算（例如<code>==</code> ， <code>===</code> ， <code>&lt;</code> ， <code>&gt;</code> ）返回<code>true</code>或<code>false</code> 。 <br><br> 逻辑表达式用于<code>if</code>和<code>while</code>等构造中，有助于控制程序的进度。 <br><br> 应该注意的是，在期望为<code>true</code>或<code>false</code>情况下，您可以使用语言自动将其视为真（真）或假（假）的其他值。 <br><br> 特别是，以下是错误值： <br><br><pre> <code class="plaintext hljs">0 -0 NaN undefined null '' // </code> </pre> <br> 其余值为true。 <br><br><h4> 输入空值 </h4><br>  JavaScript具有一个特殊的<code>null</code>值，该值指示不存在值。 其他语言也使用类似的含义。 <br><br><h4> 类型未定义 </h4><br> 写入某个变量的<code>undefined</code>值表示该变量未初始化，并且没有任何值。 <br><br> 该值是从没有使用<code>return</code>关键字显式返回结果的函数中自动返回的。 如果函数接受未指定的参数，则在调用该参数时未将其设置为<code>undefined</code> 。 <br><br> 为了检查<code>undefined</code>的值，可以使用以下构造。 <br><br><pre> <code class="plaintext hljs">typeof variable === 'undefined'</code> </pre> <br><h3>  <font color="#3AC1EF">▍物件</font> </h3><br> 所有不是基本值的值都具有对象类型。 我们在谈论函数，数组，所谓的“对象”以及许多其他实体。 所有这些数据类型都是基于<code>object</code>类型的，尽管它们在很多方面都存在差异，但是它们有很多共同点。 <br><br><h2>  <font color="#3AC1EF">表达方式</font> </h2><br> 表达式是代码片段，可以根据执行的计算将特定值处理并获得。  JavaScript有几种类别的表达式。 <br><br><h4> 算术表达式 </h4><br> 计算结果为数字的表达式属于此类别。 <br><br><pre> <code class="plaintext hljs">1 / 2 i++ i -= 2 i * 2</code> </pre> <br><h4> 字符串表达式 </h4><br> 计算此类表达式的结果是字符串。 <br><br><pre> <code class="plaintext hljs">'A ' + 'string' 'A ' += 'string'</code> </pre> <br><h4> 主要表达 </h4><br> 文字，常量和对标识符的引用都属于此类。 <br><br><pre> <code class="plaintext hljs">2 0.02 'something' true false this // ,     undefined i // i    </code> </pre> <br> 这还包括JavaScript的一些关键字和构造。 <br><br><pre> <code class="plaintext hljs">function class function* // yield // /   yield* //     async function* //   await //     /pattern/i //  () //</code> </pre> <br><h4> 数组和对象初始化表达式 </h4><br><pre> <code class="plaintext hljs">[] //  {} //  [1,2,3] {a: 1, b: 2} {a: {b: 1}}</code> </pre> <br><h4> 逻辑表达式 </h4><br> 在逻辑表达式中，使用逻辑运算符，其计算结果为逻辑值。 <br><br><pre> <code class="plaintext hljs">a &amp;&amp; b a || b !a</code> </pre> <br><h4> 属性访问表达式 </h4><br> 这些表达式使您可以访问对象的属性和方法。 <br><br><pre> <code class="plaintext hljs">object.property //   ( )  object[property] object['property']</code> </pre> <br><h4> 对象创建表达式 </h4><br><pre> <code class="plaintext hljs">new object() new a(1) new MyRectangle('name', 2, {a: 4})</code> </pre> <br><h4> 函数声明表达式 </h4><br><pre> <code class="plaintext hljs">function() {} function(a, b) { return a * b } (a, b) =&gt; a * b a =&gt; a * 2 () =&gt; { return 2 }</code> </pre> <br><h4> 呼叫表达 </h4><br> 这样的表达式用于调用对象的函数或方法。 <br><br><pre> <code class="plaintext hljs">ax(2) window.resize()</code> </pre> <br><h2>  <font color="#3AC1EF">处理对象</font> </h2><br> 上面我们已经遇到对象，谈论对象文字，调用它们的方法，访问它们的属性。 在这里，我们更详细地讨论对象，尤其是考虑原型继承机制和<code>class</code>关键字的使用。 <br><br><h3>  <font color="#3AC1EF">▍原型继承</font> </h3><br>  JavaScript在现代编程语言中脱颖而出，因为它支持原型继承。 大多数面向对象的语言都使用基于类的继承模型。 <br><br> 每个JavaScript对象都有一个特殊的属性（ <code>__proto__</code> ），该属性指向其原型的另一个对象。 一个对象继承了原型的属性和方法。 <br><br> 假设我们有一个使用对象文字创建的对象。 <br><br><pre> <code class="plaintext hljs">const car = {}</code> </pre> <br> 或者我们使用<code>Object</code>构造函数创建了一个对象。 <br><br><pre> <code class="plaintext hljs">const car = new Object()</code> </pre> <br> 在上述任何一种情况下， <code>car</code>对象的原型都是<code>Object.prototype</code> 。 <br><br> 如果创建也是对象的数组，则其原型为<code>Array.prototype</code>对象。 <br><br><pre> <code class="plaintext hljs">const list = [] //  const list = new Array()</code> </pre> <br> 您可以如下验证。 <br><br><pre> <code class="plaintext hljs">car.__proto__ == Object.prototype //true car.__proto__ == new Object().__proto__ //true list.__proto__ == Object.prototype //false list.__proto__ == Array.prototype //true list.__proto__ == new Array().__proto__ //true</code> </pre> <br> 在这里，我们使用了<code>__proto__</code>属性，开发人员不必使用它，但是您通常可以访问它。 应该注意的是，获取对象原型的一种更可靠的方法是使用全局<code>Object</code>的<code>getPrototypeOf()</code>方法。 <br><br><pre> <code class="plaintext hljs">Object.getPrototypeOf(new Object())</code> </pre> <br> 具有该原型的对象可以访问该原型的所有属性和方法。 例如，在这里看起来像他们的数组列表。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3d4/9e5/abf/3d49e5abf535b680cdd52d4749bbe61b.png"></div><br>  <i><font color="#999999">数组提示</font></i> <br><br> 所有对象的基本原型是<code>Object.prototype</code> 。 <br><br><pre> <code class="plaintext hljs">Array.prototype.__proto__ == Object.prototype</code> </pre> <br>  <code>Object.prototype</code>原型。 <br><br> 我们上面看到的是原型链的示例。 <br><br> 尝试访问对象的属性或方法时，如果对象本身不具有此类属性或方法，则在其原型中搜索对象，然后在原型原型中进行搜索，依此类推，直到找到所需的对象或直到原型链不会结束。 <br><br> 除了使用<code>new</code>运算符以及使用对象常量或数组常量创建对象之外，还可以使用<code>Object.create()</code>方法创建对象的实例。 传递给此方法的第一个参数是一个对象，它将成为使用该方法创建的对象的原型。 <br><br><pre> <code class="plaintext hljs">const car = Object.create(Object.prototype)</code> </pre> <br> 您可以使用<code>isPrototypeOf()</code>方法检查某个对象是否是另一个对象的原型链的一部分。 <br><br><pre> <code class="plaintext hljs">const list = [] Array.prototype.isPrototypeOf(list)</code> </pre> <br><h4> 构造函数 </h4><br> 上面，我们使用该语言中已经可用的构造函数创建了新对象（调用它们时，将使用<code>new</code>关键字）。      .  . <br><br><pre> <code class="plaintext hljs">function Person(name) { this.name = name } Person.prototype.hello = function() { console.log(this.name) } let person = new Person('Flavio') person.hello() console.log(Person.prototype.isPrototypeOf(person))</code> </pre> <br>    -.      ,      <code>this</code>   .       <code>name</code>     ,   .      .   -    ,  <code>name</code>    ,      . <br><br>         ,        <code>name</code> ,     .  ,     ,       ,          <code>hello()</code> .   ,      <code>Person</code>     <code>hello()</code>        (       ). <br><br><h3> <font color="#3AC1EF">▍</font> </h3><br>   ES6  JavaScript     «». <br><br>    JavaScript        .      ,   JS   .      , ,  ,  « »    .  ,  ,   ,  ,    ,  . <br><br><h4>   </h4><br>     . <br><br><pre> <code class="plaintext hljs">class Person { constructor(name) {   this.name = name } hello() {   return 'Hello, I am ' + this.name + '.' } }</code> </pre> <br>    ,           <code>new ClassIdentifier()</code> . <br><br>       <code>constructor</code> ,   . <br><br>     .    <code>hello()</code> —  ,     ,    .          <code>Person</code> . <br><br><pre> <code class="plaintext hljs">const flavio = new Person('Flavio') flavio.hello()</code> </pre> <br><h4> ,    </h4><br>     . ,     ,      ,  ,    . <br><br>  ,    (  )  ,     ,    -,      . <br><br><pre> <code class="plaintext hljs">class Programmer extends Person { hello() {   return super.hello() + ' I am a programmer.' } } const flavio = new Programmer('Flavio') flavio.hello()</code> </pre> <br>    <code>hello()</code>       <code>Hello, I am Flavio. I am a programmer</code> . <br><br>       (),          . <br><br>            <code>super</code> . <br><br><h4>   </h4><br> ,   ,  ,   ,     ,     .  ( <code>static</code> )   ,    . <br><br><h4>   </h4><br>  JavaScript   ,     (, ) .    , ,   . <br><br><h4>    </h4><br>     ,     <code>get</code>  <code>set</code> .         — ,        ,    .       -,   —       . <br><br><pre> <code class="plaintext hljs">class Person {   constructor(name) {     this.userName = name   }   set name(value) {     this.userName = value   }   get name() {     return this.userName   } }</code> </pre> <br><h2>  <font color="#3AC1EF">总结</font> </h2><br>       ,   ,         JavaScript.      . <br><br>  <b>亲爱的读者们！</b>       JS,    ,          class. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN429838/">https://habr.com/ru/post/zh-CN429838/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN429824/index.html">前端配置项：Gitlab，Traefik，Docker</a></li>
<li><a href="../zh-CN429826/index.html">可穿戴的“电池”：基于PEDOT-Cl的纺织微型超级电容器</a></li>
<li><a href="../zh-CN429828/index.html">（不仅）新生：大学教学2.0</a></li>
<li><a href="../zh-CN429832/index.html">Andrew Un的书《机器学习的激情》第28-29章的翻译</a></li>
<li><a href="../zh-CN429836/index.html">再见，电子。 您好台式机PWA</a></li>
<li><a href="../zh-CN429840/index.html">如何创建矢量街机Atari Asteroids</a></li>
<li><a href="../zh-CN429842/index.html">如何教人工智能卖</a></li>
<li><a href="../zh-CN429844/index.html">菜单，网格或引导菜单，方便使用</a></li>
<li><a href="../zh-CN429848/index.html">人工智能与骚扰和沮丧：机器人如何使世界变得更美好</a></li>
<li><a href="../zh-CN429850/index.html">我们邀请您参加：cloud-Yandex.Cloud团队的首个云技术活动</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>