<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💗 🐸 🧛🏾 从高Ceph延迟到使用eBPF / BCC的内核补丁 🦊 🦏 📫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在Linux中有很多用于调试内核和用户空间程序的工具。 它们中的大多数会影响性能，并且不能轻松地在生产环境中运行。 几年前， 开发了 eBPF，它提供了以低开销跟踪内核和用户空间的功能，而无需重新编译程序或加载内核模块。 

 现在有很多使用eBPF的工具，在本文中，我们将说明如何使用PythonB...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>从高Ceph延迟到使用eBPF / BCC的内核补丁</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/selectel/blog/450818/"><img src="https://habrastorage.org/webt/-8/ok/na/-8okna9qfyroicvgoz-zenv7-si.png"><br><br> 在Linux中有很多用于调试内核和用户空间程序的工具。 它们中的大多数会影响性能，并且不能轻松地在生产环境中运行。 几年前， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">开发了</a> eBPF，它提供了以低开销跟踪内核和用户空间的功能，而无需重新编译程序或加载内核模块。 <br><br> 现在有很多使用eBPF的工具，在本文中，我们将说明如何使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PythonBCC库</a>编写自己的分析工具。 本文基于生产环境中的实际问题。 我们将引导您解决问题，并说明在某些情况下如何使用现有的密件抄送工具。 <br><a name="habracut"></a><br><h2>  Ceph很慢 </h2><br> 新平台已添加到ceph集群。 将某些数据迁移到平台后，写入请求的等待时间比其他服务器上的等待时间长。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uk/de/-l/ukde-lsu9sjqnmci1ix942xzgie.png"></div><br><br> 该平台具有一个新的缓存虚拟设备-bcache（我们之前未在此集群中使用过）和一个新内核-4.15，该内核在该集群中的其他任何地方均未使用。 问题的根源可能在任何地方，因此让我们更深入地研究一下。 <br><br><h3> 调查主机 </h3><br> 让我们看看ceph-osd进程内部发生了什么。 我们使用跟踪工具<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">perf</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Flamescope</a>来构建火焰图： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ch/5k/nn/ch5knn22cmukd1oldmcozpxe98i.png"></div><br><br> 从火焰图可以看出， <b>fdatasync（）</b>花了很多时间在<b>generic_make_request（）</b>函数中提交bio。 因此，我们问题的根源不在ceph守护程序之外。 可能是内核，bcache或磁盘问题。  iostat输出显示bcache设备的高延迟。 <br><br> 另一个可疑的发现是systemd-udevd守护程序正在消耗CPU；它是CPU。 在多个CPU上大约占20％。 这是奇怪的行为，所以我们必须找出正在发生的事情。 由于systemd-udevd可与uevents一起使用，因此我们必须使用<b>udevadm Monitor</b>来确定系统中是否有任何uevents。 检查后，我们发现系统中的每个块设备都将生成许多“更改”事件。 <br><br> 这是不寻常的，因此我们将找出导致所有这些事件发送的原因。 <br><br>
<h3> 使用BCC工具包 </h3><br> 众所周知，内核（和ceph守护程序）花费大量时间来执行<b>generic_make_requst（）</b>函数。 让我们使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">BCC工具包中的</a> <b>funclatency</b>来衡量其延迟，以确保我们走在正确的道路上。 我们将以1秒的间隔（-i）跟踪ceph守护程序的PID（-p参数），并以毫秒（-m）显示延迟。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4c/cj/za/4ccjza8x8bq0vqkxfol2j5d9sva.png"></div><br><br> 此功能通常运行非常快。 它所做的只是将生物结构提交到设备驱动程序的队列中。 <br><br>  <b>Bcache</b>是一个复杂的设备； 实际上，它由3个设备组成：一个后备设备，在我们的例子中是慢速硬盘； 缓存设备，即NVMe驱动器的分区； 以及应用程序使用的bcache虚拟设备。 我们知道提交速度很慢，但是使用哪种设备？ 我们稍后会讨论这一点。 <br><br> 到目前为止，我们知道uevent会在ceph守护进程中导致问题，我们必须找到触发uevent的软件，要找到导致uevent生成的原因并不容易。 我们假设它是仅定期运行的软件。 要查看系统上正在执行什么，我们使用BCC工具箱中的<b>execsnoop</b> 。 我们可以运行它并将<b>stdout</b>重定向到文件。 <br><br> 例如： <br><br><pre><code class="bash hljs">/usr/share/bcc/tools/execsnoop | tee ./execdump</code> </pre> <br> 我们不会在此处提供完整的execsnoop输出，但是我们发现其中一个有趣的字符串是： <br><br><pre> <code class="bash hljs">sh 1764905 5802 0 sudo arcconf getconfig 1 AD | grep Temperature | awk -F <span class="hljs-string"><span class="hljs-string">'[:/]'</span></span> <span class="hljs-string"><span class="hljs-string">'{print $2}'</span></span> | sed <span class="hljs-string"><span class="hljs-string">'s/^ \([0-9]*\) C.*/\1/'</span></span></code> </pre> <br> 第三列是流程的PPID。 我们检查了5802是什么，并发现它是我们的监视守护程序线程之一。 进一步查看监视系统配置，我们发现一个错误的参数。 每30秒钟检索一次HBA温度，这种情况经常发生。 将检查间隔更改为更合适的值后，我们看到我们的ceph延迟与其他平台匹配。 <br><br> 但是我们仍然不知道为什么bcache延迟如此之高。 我们建立了具有相同配置的测试平台，并尝试在bcache设备上重现fio问题，同时使用udevadm trigger命令触发udev。 <br><br><h3> 编写基于BCC的工具 </h3><br> 我们在这里要做的是编写一个简单的工具，该工具可以跟踪最慢的generic_make_request（）调用，并打印该函数所需要的磁盘的名称。 <br><br> 该计划很简单： <br><br><ul><li> 在<b>generic_make_request（）</b>上注册<b>kprobe</b> ： <br><ul><li> 保存函数名称中可用的磁盘名称 </li><li> 保存当前时间戳 </li></ul></li><li> 在<b>generic_make_request（）</b>返回语句上注册<b>kretprobe</b> ： <br><ul><li> 检索当前时间戳 </li><li> 查找以前保存的时间戳并将其与当前时间戳进行比较 </li><li> 如果结果高于阈值，请查找先前保存的磁盘名称，并将其与其他信息一起打印到终端上 </li></ul></li></ul><br>  <b>Kprobes</b>和<b>kretprobes</b>使用断点在运行时更改函数的代码。 您可以找到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档</a>以及关于此的很好的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文章</a> 。 如果查看不同<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">BCC工具</a>的代码，就会发现它们都具有相同的结构。 我们将跳过参数解析，而将重点放在BPF程序本身上。 <br><br> 我们程序的文本将在python中定义如下： <br><br><pre> <code class="python hljs">bpf_text = “”” <span class="hljs-comment"><span class="hljs-comment"># Here will be the bpf program code “””</span></span></code> </pre> <br>  BPF程序使用<a href="">哈希图</a>在不同功能之间共享数据。 我们将使用PID作为键，并使用自定义结构作为值。 <br><br><pre> <code class="python hljs">struct data_t { u64 pid; u64 ts; char comm[TASK_COMM_LEN]; u64 lat; char disk[DISK_NAME_LEN]; }; BPF_HASH(p, u64, struct data_t); BPF_PERF_OUTPUT(events);</code> </pre> <br> 在这里，我们使用<b>u64</b>键类型和<b>struct data_t</b>值类型注册一个名为<b>p</b>的哈希映射。 可从我们的BPF程序上下文访问此地图。  <b>BPF_PERF_OUTPUT</b>宏注册另一个称为<b>事件的</b>映射，该映射用于<a href="">将数据推</a>送到用户空间。 <br><br> 在测量函数调用与其返回之间或一个函数调用与另一个函数调用之间的等待时间时，必须确保保存并稍后访问的数据与同一上下文相关。 换句话说，您必须知道同一功能的任何其他并行执行。 可以跟踪一个进程的函数调用与另一个进程的同一函数的返回之间的延迟，但这对我们没有帮助。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">生物延迟工具</a>就是一个很好的例子，其中将指向<b>结构请求的</b>指针用作哈希映射键。 <br><br> 接下来，我们必须编写将通过kprobe机制在函数调用上执行的代码： <br><br><pre> <code class="python hljs">void start(struct pt_regs *ctx, struct bio *bio) { u64 pid = bpf_get_current_pid_tgid(); struct data_t data = {}; u64 ts = bpf_ktime_get_ns(); data.pid = pid; data.ts = ts; bpf_probe_read_str(&amp;data.disk, sizeof(data.disk), (void*)bio-&gt;bi_disk-&gt;disk_name); p.update(&amp;pid, &amp;data); }</code> </pre> <br> 在这里，我们有第一个<a href="">generic_make_request（）参数</a>作为函数的第二个参数。 然后，我们以纳秒为单位获取PID和当前时间戳，并将其写入新分配的<b>struct data_t data中</b> 。 我们从bio结构中获取磁盘名称，并将其传递给<b>generic_make_request（）</b> ，并将其保存到我们的<b>数据中</b> 。 最后一步是将条目添加到我们之前描述的哈希图中。 <br><br> 该函数将在<b>generic_make_request（）</b>返回时执行： <br><br><pre> <code class="python hljs">void stop(struct pt_regs *ctx) { u64 pid = bpf_get_current_pid_tgid(); u64 ts = bpf_ktime_get_ns(); struct data_t* data = p.lookup(&amp;pid); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data != <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; data-&gt;ts &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { bpf_get_current_comm(&amp;data-&gt;comm, sizeof(data-&gt;comm)); data-&gt;lat = (ts - data-&gt;ts)/<span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data-&gt;lat &gt; MIN_US) { FACTOR data-&gt;pid &gt;&gt;= <span class="hljs-number"><span class="hljs-number">32</span></span>; events.perf_submit(ctx, data, sizeof(struct data_t)); } p.delete(&amp;pid); } }</code> </pre> <br> 我们从先前的输出中获得PID和时间戳，并在哈希图中查找其中<b>key == current PID</b>的值。 如果找到它，我们将得到正在运行的进程的名称，并将其添加到<b>数据</b>结构中。 我们在这里使用<b>data-&gt; pid</b>所做的事情为我们提供了线程组ID。 先前调用的<a href="">bpf_get_current_pid_tgid（）函数</a>以相同的64位值返回进程的线程GID和PID。 <br><br> 我们对每个线程的ID都不感兴趣，但是我们想知道主线程的PID。 在检查了延迟是否超过阈值之后，我们通过<b>事件</b>映射将<b>数据</b>结构提交给用户空间，然后最后删除哈希映射条目。 <br><br> 在我们的python脚本中，我们必须根据想要的阈值和想要在结果中看到的时间单位来替换<b>MIN_US</b>和<b>FACTOR</b> ： <br><br><pre> <code class="python hljs">bpf_text = bpf_text.replace(<span class="hljs-string"><span class="hljs-string">'MIN_US'</span></span>,str(min_usec)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> args.milliseconds: bpf_text = bpf_text.replace(<span class="hljs-string"><span class="hljs-string">'FACTOR'</span></span>,<span class="hljs-string"><span class="hljs-string">'data-&gt;lat /= 1000;'</span></span>) label = <span class="hljs-string"><span class="hljs-string">"msec"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: bpf_text = bpf_text.replace(<span class="hljs-string"><span class="hljs-string">'FACTOR'</span></span>,<span class="hljs-string"><span class="hljs-string">''</span></span>) label = <span class="hljs-string"><span class="hljs-string">"usec"</span></span></code> </pre><br> 然后，我们必须使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">BPF（）宏</a>准备BPF程序并注册探针： <br><br><pre> <code class="python hljs">b = BPF(text=bpf_text) b.attach_kprobe(event=<span class="hljs-string"><span class="hljs-string">"generic_make_request"</span></span>,fn_name=<span class="hljs-string"><span class="hljs-string">"start"</span></span>) b.attach_kretprobe(event=<span class="hljs-string"><span class="hljs-string">"generic_make_request"</span></span>,fn_name=<span class="hljs-string"><span class="hljs-string">"stop"</span></span>)</code> </pre><br> 我们还需要在脚本中定义与<b>struct data_t</b>相同的结构，以从BPF程序中读取数据： <br><br><pre> <code class="python hljs">TASK_COMM_LEN = <span class="hljs-number"><span class="hljs-number">16</span></span> <span class="hljs-comment"><span class="hljs-comment"># linux/sched.h DISK_NAME_LEN = 32 # linux/genhd.h class Data(ct.Structure): _fields_ = [("pid", ct.c_ulonglong), ("ts", ct.c_ulonglong), ("comm", ct.c_char * TASK_COMM_LEN), ("lat", ct.c_ulonglong), ("disk",ct.c_char * DISK_NAME_LEN)]</span></span></code> </pre> <br> 最后一步是打印所需的数据： <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_event</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cpu, data, size)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> start event = ct.cast(data, ct.POINTER(Data)).contents <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> start == <span class="hljs-number"><span class="hljs-number">0</span></span>: start = event.ts time_s = (float(event.ts - start)) / <span class="hljs-number"><span class="hljs-number">1000000000</span></span> print(<span class="hljs-string"><span class="hljs-string">"%-18.9f %-16s %-6d %-1s %s %s"</span></span> % (time_s, event.comm, event.pid, event.lat, label, event.disk)) b[<span class="hljs-string"><span class="hljs-string">"events"</span></span>].open_perf_buffer(print_event) <span class="hljs-comment"><span class="hljs-comment"># format output start = 0 while 1: try: b.perf_buffer_poll() except KeyboardInterrupt: exit()</span></span></code> </pre><br> 完整脚本可在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub上获得</a> 。 让我们运行脚本并在fio写入bcache设备时触发udev事件： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tk/ly/vf/tklyvf6i8rws0xu4gy3jothbxbi.png"></div><br><br> 成功！ 现在，我们看到bcache的高延迟实际上是其后备设备的<b>generic_make_request（）</b>延迟。 <br><br><h3> 挖掘内核 </h3><br> 提交请求时会拖累什么？ 我们看到在请求计费开始之前就出现了延迟高峰。 可以通过在问题期间运行iostat或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">biolatency BCC脚本</a> （基于记帐请求启动）来轻松检查此问题，因此这两种工具都不会显示磁盘问题。 <br><br> 如果我们看一下<b>generic_make_request（）</b> ，就会发现在开始记帐之前有两个函数正在运行。 第一个是<b>generic_make_request_checks（）</b> ，它很轻巧，并根据设备设置等检查生物。 第二个是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">blk_queue_enter（）</a> ，它具有一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">wait_event_interruptible（）</a>调用： <br><br><pre> <code class="python hljs">ret = wait_event_interruptible(q-&gt;mq_freeze_wq, (atomic_read(&amp;q-&gt;mq_freeze_depth) == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; (preempt || !blk_queue_preempt_only(q))) || blk_queue_dying(q));</code> </pre><br> 在这里，内核等待直到队列被冻结为止。 让我们测量一下blk_queue_enter（）的延迟： <br><br><pre> <code class="bash hljs">~<span class="hljs-comment"><span class="hljs-comment"># /usr/share/bcc/tools/funclatency blk_queue_enter -i 1 -m Tracing 1 functions for "blk_queue_enter"... Hit Ctrl-C to end. msecs : count distribution 0 -&gt; 1 : 341 |****************************************| msecs : count distribution 0 -&gt; 1 : 316 |****************************************| msecs : count distribution 0 -&gt; 1 : 255 |****************************************| 2 -&gt; 3 : 0 | | 4 -&gt; 7 : 0 | | 8 -&gt; 15 : 1 | |</span></span></code> </pre><br> 看来我们接近了。 用于冻结/解冻队列的函数是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">blk_mq_freeze_queue</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">blk_mq_unfreeze_queue</a> 。 它们用于更改队列设置，这可能会影响当前正在运行的io请求。 调用<b>blk_mq_freeze_queue（）时</b> ， <b>q-&gt; mq_freeze_depth</b>在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">blk_freeze_queue_start（）中</a>递增。 之后，内核在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">blk_mq_freeze_queue_wait（）中</a>等待队列为空。 <br><br> 此等待时间等于磁盘延迟，因为内核必须等待所有io操作完成。 当队列为空时，可以进行更改。 最后一步是调用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">blk_mq_unfreeze_queue（）</a> ，这会减少<b>Frozen_depth</b>计数器。 <br><br> 现在我们知道足以解决此问题。  udevadm trigger命令更改块设备的设置。 这些设置在udev规则中进行了描述。 我们可以通过sysfs或查看内核源代码来更改冻结队列的设置。 另外，我们可以从BCC工具箱中<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">调用trace</a>来为每个<b>blk_freeze_queue</b>调用打印内核和用户堆栈： <br><br><pre> <code class="bash hljs">~<span class="hljs-comment"><span class="hljs-comment"># /usr/share/bcc/tools/trace blk_freeze_queue -K -U PID TID COMM FUNC 3809642 3809642 systemd-udevd blk_freeze_queue blk_freeze_queue+0x1 [kernel] elevator_switch+0x29 [kernel] elv_iosched_store+0x197 [kernel] queue_attr_store+0x5c [kernel] sysfs_kf_write+0x3c [kernel] kernfs_fop_write+0x125 [kernel] __vfs_write+0x1b [kernel] vfs_write+0xb8 [kernel] sys_write+0x55 [kernel] do_syscall_64+0x73 [kernel] entry_SYSCALL_64_after_hwframe+0x3d [kernel] __write_nocancel+0x7 [libc-2.23.so] [unknown] 3809631 3809631 systemd-udevd blk_freeze_queue blk_freeze_queue+0x1 [kernel] queue_requests_store+0xb6 [kernel] queue_attr_store+0x5c [kernel] sysfs_kf_write+0x3c [kernel] kernfs_fop_write+0x125 [kernel] __vfs_write+0x1b [kernel] vfs_write+0xb8 [kernel] sys_write+0x55 [kernel] do_syscall_64+0x73 [kernel] entry_SYSCALL_64_after_hwframe+0x3d [kernel] __write_nocancel+0x7 [libc-2.23.so] [unknown]</span></span></code> </pre> <br>  Udev规则不会经常更改，因此即使将已经存在的值分配给某些参数也会导致应用程序的提交延迟高峰。 当然，当设备的配置没有任何变化（没有连接或分离设备）时生成udev事件不是一个好习惯。 尽管如此，如果没有理由，我们可以防止内核冻结队列。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">三个</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">小的</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">提交</a>解决了该问题。 <br><br><h2> 结论 </h2><br>  eBPF是高度灵活且功能强大的工具。 在本文中，我们仅研究了一种情况，并演示了其功能。 如果您对开发基于BCC的工具感兴趣，则应查看<a href="">官方教程</a> ，其中描述了其基本概念。 <br><br> 还有其他有趣的基于eBPF的工具可用于性能分析和调试。 其中之一是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">bpftrace</a> ，它使您可以使用类似于awk的语言编写功能强大的oneliners和小程序。 另一个是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ebpf_exporter</a> ，它具有强大的可视化和警报功能，可以为您的prometheus服务器收集低级别的高分辨率指标。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN450818/">https://habr.com/ru/post/zh-CN450818/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN450806/index.html">当环境变量将过程加快40倍时</a></li>
<li><a href="../zh-CN450810/index.html">面试前快速检查IT专家能力的7种方法</a></li>
<li><a href="../zh-CN450812/index.html">PSR-14-PHP中的主要事件</a></li>
<li><a href="../zh-CN450814/index.html">BGP如何工作</a></li>
<li><a href="../zh-CN450816/index.html">负责的开发人员的HTTP标头</a></li>
<li><a href="../zh-CN450820/index.html">FrontendConf计划委员会：框架，视野，世界经验和会议使命</a></li>
<li><a href="../zh-CN450822/index.html">消失的框架</a></li>
<li><a href="../zh-CN450824/index.html">CSS的状态</a></li>
<li><a href="../zh-CN450826/index.html">如何与JS中的微控制器对话</a></li>
<li><a href="../zh-CN450828/index.html">当城市入睡时...</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>