<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸš ğŸ”– ğŸ›´ Virtual Cube - Alih-alih OLAP ğŸ›¬ ğŸˆ ğŸ¤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ketika Anda melakukan yang sebaliknya dan mendapatkan yang sama ... 

 Memiliki tugas pemrosesan data analitis (komputasi / agregasi), Anda harus mene...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Virtual Cube - Alih-alih OLAP</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452154/"><blockquote>  <em>Ketika Anda melakukan yang sebaliknya dan mendapatkan yang sama ...</em> </blockquote><p>  Memiliki tugas pemrosesan data analitis (komputasi / agregasi), Anda harus menemukan kompromi antara responsif, kecepatan, dan kenyamanan. </p><br><p>  Beberapa sistem diindeks dan ditemukan dengan baik, yang lain dapat dengan cepat menghitung dan mengumpulkan data, sementara yang lain sederhana.  Di suatu tempat, perlu untuk mengatur preloading dan pengindeksan data dengan semua kesulitan yang menyertainya, dan di suatu tempat, pengguna diberikan abstraksi model sumber dan data agregatnya di atas penyimpanan fisik dan database fisik bawaan dan eksternal yang digunakan secara langsung selama perhitungan.  Bagaimanapun, pengguna, dari pemrogram hingga analis, harus melakukan pekerjaan yang relatif besar, mulai dengan menyiapkan data mentah dan menyusun kueri, menghitung model, berakhir dengan memvisualisasikan hasil pada widget, tentu saja, "Seksi" - cantik, responsif, dan dapat dipahami - jika tidak semua pekerjaan yang dilakukan akan sia-sia.  Dan seringkali, seperti keberuntungan, melalui pergolakan dalam memilih solusi, kita melihat bagaimana tugas yang sederhana dan dapat dimengerti pada awalnya tumbuh menjadi monster yang menyeramkan, yang tidak berguna untuk bertarung dengan cara yang tersedia, dan kita perlu segera menciptakan sesuatu - sepeda "dengan blackjack dan pelacur" Â©  Sepeda kami melaju, bahkan berputar dengan baik dan mengatasi rintangan yang hanya bisa ditebak orang sebelumnya. <br> <a href=""><img src="https://habrastorage.org/webt/_c/yq/kp/_cyqkpcr3okpjz01osvwajd-pje.png"></a> </p><br><p>  Di bawah ini akan dijelaskan satu sisi dari perangkat internal asli fiksi "Rubik's Cube" - pemrosesan komputasi untuk visualisasi data interaktif. </p><a name="habracut"></a><br><blockquote>  <em>Tugas sederhana harus diselesaikan dengan sederhana, dan yang sulit juga harus sederhana, tetapi lebih lama ...</em> </blockquote><p>  Mulai membuat sistem dengan kekuatan kecil, kami beralih dari sederhana ke kompleks.  Menciptakan konstruktor, kami yakin secara internal bahwa kami memahami dengan baik tujuan sistem, bertarung secara bersamaan dengan keinginan untuk tidak melakukan terlalu banyak dan keinginan yang berlawanan untuk mengotomatisasi segala sesuatu dan segalanya, menciptakan kerangka kerja untuk segalanya.  Selain itu, salah satu kerangka kerja kami yang luar biasa siap dan bahkan diuji dalam produksi - jsBeans.  Jadi, kami mulai mengembangkan sistem pemrosesan data berikutnya, yang telah berkembang dan sekarang pada saat yang sama merupakan produk mandiri - seorang desainer dan platform untuk mengembangkan seluruh kelas sistem pemrosesan data.  Secara kondisional, dalam artikel kami akan menyebutnya "Rubik's Cube" untuk melakukan tanpa iklan, tetapi untuk menggambarkan menarik, menurut pendapat kami, solusi. </p><br><h2 id="kub-srez-izmerenie">  Kubus, irisan, pengukuran </h2><br><p>  Tugas utama - memiliki set data yang tidak terkait, termasuk database dan file eksternal yang heterogen, untuk membentuk model multidimensi dari elemen yang saling berhubungan dari data sumber dan hasil dari pemrosesan analitis mereka untuk visualisasi pada dashboard dinamis dan widget yang saling berhubungan. </p><br><p>  Sederhananya, misalnya, sebagai dasbor yang dapat diklik: </p><br><p><img src="https://habrastorage.org/webt/9r/1u/w1/9r1uw1pcuwqt4i_l0dbav0bqhsk.png" alt="Contoh dashboard sekolah dinilai"></p><br><p>  Model data multidimensi seperti itu dalam sistem kami disebut "Cube" dan secara harfiah mewakili koleksi abstrak kumpulan data yang dapat berubah yang disebut "Slice", yang saling terkait oleh bidang / kolom keluaran umum (ditampilkan) atau bidang internal yang disebut "Dimensi" dan digunakan untuk menyaring dan menghubungkan irisan satu sama lain. </p><br><p>  Iris dapat direpresentasikan sebagai tabel atau tampilan virtual ( <abbr title="Ekspresi tabel umum">CTE</abbr> ) dengan parameter dan badan permintaan variabel, tergantung pada kondisi penyaringan.  Yang utama adalah bahwa data output berubah, tergantung pada kondisi pencarian konteks (di dalam widget) dan filter global, yang dibangun dengan memilih nilai pada widget dan menggunakan fungsi logika dasar (DAN / ATAU / TIDAK) dan kombinasi. </p><br><p>  Filter global memungkinkan Anda untuk "memutar Rubik's Cube", seperti dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">video</a> : </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Wxvey5PByQQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Jika bidang keluaran dari irisan adalah sekaligus pengukuran di irisan lain, memiliki nama yang sama, maka nilai-nilai bidang ini dirasakan oleh sistem sebagai "fakta" (jika kita berbicara tentang <abbr title="Pemrosesan Analitis Online, Pemrosesan Analitik Interaktif">OLAP</abbr> ), atur dalam bentuk filter global yang mengubah set data asli selama kalkulasi dan agregasi .  Akibatnya, ada interaksi dinamis widget, di mana nilai indikator yang ditampilkan tergantung pada elemen dan filter yang dipilih. </p><br><p>  Sepotong adalah sekumpulan data yang dapat diubah "dengan pengukuran" â€” awal atau hasil perhitungan analitik;  dicirikan oleh bidang / kolom keluaran, daftar pengukuran yang didukung dan satu set parameter dengan nilai default;  dijelaskan oleh permintaan yang relatif elegan dalam editor visual yang mendukung pemfilteran, pengurutan, pengelompokan / agregasi, persimpangan (GABUNG), serikat pekerja (UNION), rekursi, dan manipulasi lainnya. </p><br><p>  Irisan yang saling menggunakan sebagai sumber menggambarkan struktur internal sebuah kubus, misalnya: </p><br><p><img src="https://habrastorage.org/webt/u5/ev/ay/u5evay1gcdf76whlfgmdxijmu_0.jpeg" alt="Contoh Struktur Kubus"></p><br><p>  Contoh alat pengiris di editor: </p><br><p><img src="https://habrastorage.org/webt/ow/p_/on/owp_onr465vphjta2gginzvywf8.png" alt="Contoh editor permintaan alat pengiris"></p><br><p>  Sepotong mendukung kedua pengukuran yang ditentukan secara eksplisit di bidang output dan mewarisi pengukuran dari sumber kueri - ini berarti bahwa output dari irisan dapat diubah bahkan sebagai akibat dari perubahan di sumber-sumber irisan lainnya.  Dengan kata lain, hasil dari irisan dapat disaring tidak hanya oleh bidang output, tetapi juga oleh bidang internal-pengukuran sumber, di suatu tempat di kedalaman permintaan, hingga tabel database primer. </p><br><p>  Struktur kueri diperluas dan diubah oleh sistem secara otomatis pada saat eksekusi, tergantung pada filter global dan parameter input saat ini, menyeretnya lebih dalam ke dalam kueri sesuai dengan model kubus, pengukuran yang dinyatakan, dan irisan. </p><br><p>  Contoh filter global sederhana, secara harfiah, ketika pengguna telah melakukan atau memilih nilai pada beberapa widget: </p><br><p><img src="https://habrastorage.org/webt/vd/aj/li/vdajlihvw-uymjxya7qr565mx_8.png" alt="Contoh filter global di dasbor"></p><br><p>  Filter global disimpan dalam permintaan JSON: </p><br><p><img src="https://habrastorage.org/webt/t0/uu/lb/t0uulbpjpqaf_pndtyczt3mvt6k.png" alt="Contoh JSON dari filter global di badan permintaan"></p><br><p>  Permintaan datang ke sumber utama (ke database) yang sudah dalam bentuk siap, setelah melewati beberapa tahap utama: </p><br><ul><li>  Meminta perakitan, termasuk pemilihan dan penyisipan irisan optimal, dengan mempertimbangkan filter global saat ini (ketika filter tidak ada atau sederhana, Anda dapat memilih irisan sederhana / cepat; ketika filter kompleks - irisan dengan struktur yang kompleks dan pengukuran tambahan); </li><li>  Menanamkan filter global dan menambahkan filter ke badan kueri dan subkueri; </li><li>  Menyematkan makro dan ekspresi kueri templat; </li><li>  Optimasi kueri, termasuk penghapusan bidang dan ekspresi yang tidak digunakan; </li><li>  Operasi tambahan dengan kueri untuk spesifik basis data primer (misalnya, jika kita berbicara tentang SQL dan basis data tidak berisi DENGAN, maka kueri bernama yang disematkan). </li></ul><br><p>  Dan tahap terakhir adalah terjemahan permintaan ke format sumber utama, misalnya, dalam SQL: </p><br><p><img src="https://habrastorage.org/webt/ui/rd/ls/uirdlsovx8idhgtxgyovng8gg2a.png" alt="Contoh permintaan akhir dengan filter terintegrasi"></p><br><h2 id="kogda-istochniki-raznye">  Ketika sumber berbeda </h2><br><p>  Sebagai aturan, semuanya sederhana dan jelas ketika Anda harus bekerja dengan satu gudang data.  Tetapi, ketika ada beberapa dari mereka dan mereka pada dasarnya berbeda - Anda harus menerapkan trik yang berbeda untuk setiap tugas tertentu.  Dan Anda selalu ingin memiliki solusi universal yang selalu cocok, lebih disukai di luar kotak, dengan modifikasi kecil maksimal.  Untuk melakukan ini, abstraksi lain memintanya: lebih dari gudang data, pertama, mewujudkan koordinasi format dan bahasa query, dan kedua, memastikan saling ketergantungan data, setidaknya pada tingkat kondisi penyaringan tambahan dalam permintaan ke satu sumber dengan nilai dari sumber lain. </p><br><p>  Untuk melakukan ini, kami telah mengembangkan bahasa permintaan universal, cocok untuk mewakili model virtual data kubus dan untuk bekerja dengan penyimpanan sewenang-wenang dengan syarat dengan menerjemahkan permintaan ke format dan bahasa yang diinginkan.  Secara kebetulan, bahasa query, yang awalnya dimaksudkan untuk pemetaan sederhana dan penyaringan data dari berbagai sumber, dengan mudah tumbuh menjadi pencarian data dan bahasa pemrosesan yang lengkap, yang memungkinkan seseorang untuk membangun konstruksi komputasi dari yang paling sederhana hingga yang paling kompleks di beberapa halaman dan dengan banyak subquery. </p><br><p>  Sumber dapat dibagi menjadi tiga jenis: </p><br><ol><li>  file data yang perlu diunduh ke sistem; </li><li>  Basis data yang mendukung pemrosesan data lengkap dan operasi lainnya; </li><li>  penyimpanan yang hanya mendukung ekstraksi data dengan atau tanpa penyaringan, termasuk berbagai jenis layanan eksternal. </li></ol><br><p>  Semuanya tidak ambigu dengan tipe pertama - modul impor terintegrasi dalam sistem, yang mem-parsing berbagai format input dan membenamkan hasil dalam repositori.  Untuk impor, konstruktor khusus juga telah dikembangkan, yang harus dibahas secara terpisah. </p><br><p>  Tipe kedua adalah basis data mandiri, di mana Anda hanya perlu menerjemahkan permintaan asli ke format dan bahasa yang diinginkan dari permintaan, dialek. </p><br><p>  Tipe ketiga membutuhkan setidaknya data pasca pemrosesan.  Dan semua jenis pada saat yang sama juga dapat membutuhkan pemrosesan pasca - persimpangan, serikat pekerja, agregasi dan perhitungan akhir.  Ini terjadi ketika pemrosesan data dalam satu database perlu dilakukan dengan mempertimbangkan hasil penyaringan di eksternal lain. </p><br><p>  <em>Contoh paling sederhana adalah ketika pencarian fuzzy dilakukan dalam satu database, dan pada output itu diperlukan untuk memperoleh agregasi indikator yang disimpan dalam database lain di server lain, dengan mempertimbangkan hasil pencarian.</em> </p><br><p>  Untuk mengimplementasikan pekerjaan skema semacam itu, algoritma sederhana diimplementasikan dalam sistem kami - permintaan awal disiapkan secara simultan oleh beberapa penerjemah, yang masing-masing dapat menolak untuk mengeksekusi permintaan ketika itu tidak kompatibel, atau mengembalikan iterator dengan data, atau mengonversi permintaan dan memulai pekerjaan dari rantai persiapan permintaan berikutnya oleh juru bahasa lain .  Akibatnya, untuk satu permintaan, kami mendapatkan dari satu hingga beberapa iterator malas yang membentuk hasil yang sama, tetapi dengan cara yang berbeda, dari mana yang terbaik dipilih (sesuai dengan berbagai kriteria yang ditentukan oleh pengembang dalam konfigurasi). </p><br><p>  Strategi pemilihan iterator ditentukan dalam konfigurasi atau parameter kueri.  Saat ini, beberapa strategi utama didukung: </p><br><ul><li>  pertama, setiap, terakhir; </li><li>  menurut jenis basis data prioritas; </li><li>  dengan prioritas rantai yang membentuk iterator; </li><li>  oleh fungsi berat "permintaan bobot"; </li><li>  menurut hasil pertama - semua iterator diluncurkan secara paralel dan hasil pertama diharapkan, sebagai akibatnya, iterator tercepat digunakan, sisanya ditutup. </li></ul><br><p>  Sebagai hasil dari kombinasi tersebut untuk satu permintaan input, kami mendapatkan beberapa opsi untuk pelaksanaannya, baik menggunakan sumber yang berbeda dan dengan strategi eksekusi yang berbeda - memilih basis data utama / target di mana bagian utama dari permintaan akan dieksekusi dan hasil akhir perakitan. </p><br><p>  Jika target DBMS mendukung koneksi sumber eksternal, maka menjadi mungkin untuk membuat sirkuit terbalik di mana DBMS terhubung ke sistem API untuk menerima sejumlah kecil data dari sistem, misalnya, untuk menyaring volume besar "di tempat".  Integrasi tersebut transparan bagi pengguna akhir dan analis - model kubus tidak berubah, dan semua operasi dilakukan secara otomatis oleh sistem. </p><br><p><img src="https://habrastorage.org/webt/az/ie/vx/azievxht98zpnyahcnoymfdcgr8.png" alt="Diagram urutan sederhana ketika menanyakan beberapa basis data terintegrasi dalam satu permintaan"></p><br><p>  Untuk kasus yang lebih kompleks, sistem mengimplementasikan interpreter kueri dalam-memori internal pada mesin database Embedded H2 yang luar biasa, yang memungkinkan pengintegrasian setiap basis data yang didukung di luar kotak.  Secara harfiah, ini berfungsi seperti ini - permintaan dibagi menjadi beberapa bagian oleh kelompok sumber, dikirim untuk dieksekusi, setelah itu perakitan dan pemrosesan akhir hasilnya dilakukan dalam memori, dalam H2. </p><br><p>  Sepintas, skema integrasi data seperti itu pada level interpreter internal tampaknya â€œsulitâ€, dan ini benar jika Anda harus bekerja dengan volume besar data input dan kebutuhan untuk melakukan perhitungan setelah persimpangan dan asosiasi set dari sumber eksternal.  Bahkan, keadaan ini sebagian diratakan - pada saat yang sama, permintaan dijalankan oleh beberapa penangan dalam versi yang berbeda, oleh karena itu, penerjemah hanya digunakan dalam kasus yang paling ekstrim, sebagai solusi universal di luar kotak.  Pada akhirnya, setiap integrasi dibatasi oleh biaya transportasi khas untuk persiapan, transmisi melalui jaringan dan menerima data, dan ini adalah tugas yang sama sekali berbeda. </p><br><h2 id="tehnicheskaya-storona">  Sisi teknis </h2><br><p>  Dari sisi teknis, yang, mungkin, tidak bisa dihilangkan, menyentuh topik ini, sistem juga diatur sesuai dengan prinsip - untuk melakukan lebih banyak, tetapi sederhanakan segala sesuatu sebanyak mungkin. </p><br><p>  Sistem pemrosesan data diimplementasikan di atas kerangka klien-server jsBeans sebagai satu set modul tambahan dan proyek perakitan khusus.  jsBeans, pada gilirannya, diimplementasikan di Jawa, berfungsi sebagai server aplikasi, pada umumnya merupakan sekelompok Rhino, Jetty dan Akka, dan juga mencakup teknologi kacang client-server yang dikembangkan oleh tim kami, dan perpustakaan kaya komponen yang dirakit selama beberapa tahun aplikasi yang sukses. </p><br><p>  Rubik's Cube sepenuhnya dan sepenuhnya diimplementasikan dalam JavaScript dalam bentuk banyak js-bins (* .jsb file), beberapa di antaranya hanya beroperasi di server.  Bagian lainnya adalah pada klien, dan sisanya adalah komponen komponen, berfungsi sebagai keseluruhan terdistribusi, bagian-bagian yang saling berinteraksi, transparan kepada pengembang, tetapi di bawah kendalinya.  Js-bins dapat memiliki strategi kehidupan yang berbeda, misalnya, dengan atau tanpa sesi pengguna, dan banyak lagi.  Kacang isomorfik, memungkinkan klien dan server untuk bekerja dengannya sebagai instance virtual dari kelas reguler.  Nampan dijelaskan oleh satu file dan mencakup tiga bagian - untuk bidang dan metode yang berjalan pada klien, untuk bidang server, serta bagian bidang yang disinkronkan secara umum. </p><br><p>  Karena artikel tersebut telah berubah menjadi kata yang tidak membuat pembaca bosan, sekarang saatnya untuk melanjutkan sampai selesai, dengan maksud untuk segera menggambarkan detail dan solusi arsitektur yang paling menarik dalam implementasi JsBeans dan proyek-proyek kami berdasarkan itu - subsistem visualisasi yang dibangun, proses analitik, perancang ontologis bidang studi, bahasa kueri, impor data, dan lainnya ... </p><br><h2 id="pochemu-tak">  Kenapa begitu </h2><br><blockquote>  <em>Ini belum pernah terjadi sebelumnya, dan di sini lagi ...</em> </blockquote><p>  Awalnya, ada beberapa set data primer.  Bidang dan tugas subjek sepenuhnya ditentukan.  Tampaknya, mengapa siksaan seperti itu?  Tugasnya terlihat sederhana, semua orang ingin mendapatkan hasilnya segera - terutama ketika solusi cepat muncul di permukaan, dan yang tepat membutuhkan ketekunan dan keputusan yang seimbang, mengamati pengaturan asli.  Kami pergi ke arah yang berlawanan, dari solusi yang rumit dan panjang untuk yang sederhana dan cepat, di sepanjang jalan generalisasi masalah tertentu. </p><br><p>  Syarat utama adalah bahwa dasbor baru harus dibangun dengan cepat, bahkan jika area subjek baru dan kebutuhan analitis sangat berbeda dari yang sebelumnya.  Jelas Anda tidak akan menebak bahkan setengah dari persyaratan di masa depan, sistem harus lentur di tempat pertama.  Menyempurnakan pustaka komponen, algoritma analitik, menghubungkan jenis sumber baru adalah bagian integral dari adaptasi sistem.  Dengan kata lain, banyak yang telah bekerja - analis membangun permintaan dan dasbor, dan programmer dengan cepat menyadari kebutuhan baru untuk mereka.  Dan kami, sebagai programmer, awalnya berusaha menyederhanakan pekerjaan kami di masa depan, berusaha untuk tidak merusak kegunaan. </p><br><p>  Dan sistem itu segera dibuat universal dan adaptif - kami membangun "konstruktor dengan konstruktor", mengembangkan kerangka kerja di atas kerangka kerja yang sebelumnya dibuat dengan tujuan yang serupa, tetapi bahkan lebih umum. </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Peringkat sekolah Moskow berdasarkan hasil Unified State Examination dan Olympiads</a></strong> adalah contoh dashboard yang dibuat dengan cara yang dijelaskan di atas dari pembongkaran dari portal data terbuka Pemerintah Moskow. </p><br><p>  <strong>Cube-Rubik</strong> adalah platform dasar untuk pengembangan sistem informasi dan analisis.  Dirancang sebagai cabang dan kelanjutan logis dari jsBeans.  Ini mencakup semua modul yang diperlukan untuk menyelesaikan masalah pengumpulan, pemrosesan, analisis (komputasi dan berorientasi proses) dan visualisasi. </p><br><p>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jsBeans</a></strong> adalah kerangka kerja web penuh-tumpukan isomorfik yang mengimplementasikan teknologi kacang JavaScript server-klien, yang dikembangkan dengan lisensi terbuka sebagai alat universal.  Selama penggunaan, itu telah membuktikan dirinya dengan baik, dalam banyak kasus, idealnya pas ke tugas-tugas sebelum kita. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id452154/">https://habr.com/ru/post/id452154/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id452138/index.html">13. Periksa Titik Memulai R80.20. Perizinan</a></li>
<li><a href="../id452140/index.html">Mengapa CFO beralih ke model biaya operasional di TI</a></li>
<li><a href="../id452142/index.html">Bagaimana kita berurusan dengan menyalin konten, atau serangan permusuhan pertama di prod</a></li>
<li><a href="../id452146/index.html">Jadi apa yang akan terjadi dengan otentikasi dan kata sandi? Bagian 2 dari Laporan Status Otentikasi Kuat Javelin</a></li>
<li><a href="../id452152/index.html">Solusi apa yang dimiliki Rostelecom untuk IIoT</a></li>
<li><a href="../id452158/index.html">TOPchik - plugin WordPress terbuka untuk verifikasi posisi situs gratis untuk permintaan pencarian, melalui API Yandex.XML</a></li>
<li><a href="../id452162/index.html">Bot untuk VK di Python dengan MySQL dalam satu jam, bagian 1</a></li>
<li><a href="../id452164/index.html">ModLook - pemindai register ModBus. Merayakan ulang tahun ke 20 dari program ini</a></li>
<li><a href="../id452168/index.html">Membuat game ritme di Unity</a></li>
<li><a href="../id452172/index.html">Sistem yang kompleks. Mencapai level kritis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>