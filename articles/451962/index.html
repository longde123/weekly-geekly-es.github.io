<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游뗺游낗 丘勇 游꼺 Cree herramientas en proyectos de aprendizaje autom치tico, una descripci칩n general 游놏 游놊游낕 游쓇릞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Me preguntaba sobre la estructura del proyecto de aprendizaje autom치tico / ciencia de datos / flujo de trabajo y estaba leyendo diferentes opiniones s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cree herramientas en proyectos de aprendizaje autom치tico, una descripci칩n general</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451962/"> Me preguntaba sobre la estructura del proyecto de aprendizaje autom치tico / ciencia de datos / flujo de trabajo y estaba leyendo diferentes opiniones sobre el tema.  Y cuando las personas comienzan a hablar sobre el flujo de trabajo, quieren que sus flujos de trabajo sean reproducibles.  Hay muchas publicaciones que sugieren usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">make</a> para mantener el flujo de trabajo reproducible.  Aunque <code>make</code> es muy estable y ampliamente utilizado, personalmente me gustan las soluciones multiplataforma.  Despu칠s de todo, es 2019, no 1977. Se puede argumentar que hacerse es multiplataforma, pero en realidad tendr치 problemas y pasar치 tiempo arreglando su herramienta en lugar de hacer el trabajo real.  As칤 que decid칤 echar un vistazo y ver qu칠 otras herramientas est치n disponibles.  S칤, decid칤 dedicar algo de tiempo a las herramientas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aff/fbf/656/afffbf6566a6e67ea6427d28d76d7eea.png" alt="imagen"></div><br>  Esta publicaci칩n es m치s una invitaci칩n a un di치logo que un tutorial.  Quiz치s tu soluci칩n sea perfecta.  Si es as칤, ser치 interesante escucharlo. <br><br>  En esta publicaci칩n usar칠 un peque침o proyecto de Python y har칠 las mismas tareas de automatizaci칩n con diferentes sistemas: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CMake</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Pybuilder</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pynt</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Adoqu칤n</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">doit</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Luigi</a> </li></ul><br>  Habr치 una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tabla de comparaci칩n</a> al final de la publicaci칩n. <br><a name="habracut"></a><br>  La mayor칤a de las herramientas que analizar칠 se conocen como <em>software de automatizaci칩n de</em> <em>compilaci칩n</em> o <em>sistemas de compilaci칩n</em> .  Hay miles de ellos en todos los sabores, tama침os y complejidades.  La idea es la misma: el desarrollador define reglas para producir algunos resultados de manera automatizada y consistente.  Por ejemplo, un resultado podr칤a ser una imagen con un gr치fico.  Para hacer esta imagen, uno necesitar칤a descargar los datos, limpiar los datos y hacer algunas manipulaciones de datos (ejemplo cl치sico, realmente).  Puede comenzar con un par de scripts de shell que har치n el trabajo.  Una vez que regrese al proyecto un a침o despu칠s, ser치 dif칤cil recordar todos los pasos y el orden que debe seguir para crear esa imagen.  La soluci칩n obvia es documentar todos los pasos.  Buenas noticias!  Los sistemas de construcci칩n le permiten documentar los pasos en forma de programa de computadora.  Algunos sistemas de compilaci칩n son como sus scripts de shell, pero con campanas y silbatos adicionales. <br><br>  La base de esta publicaci칩n es una serie de publicaciones de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mateusz Bednarski</a> sobre flujo de trabajo automatizado para un proyecto de aprendizaje autom치tico.  Mateusz explica sus puntos de vista y proporciona recetas para usar <code>make</code> .  Te animo a que vayas y revises sus publicaciones primero.  Usar칠 principalmente su c칩digo, pero con diferentes sistemas de compilaci칩n. <br><br>  Si desea obtener m치s informaci칩n sobre <code>make</code> , a continuaci칩n encontrar치 referencias para un par de publicaciones.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Brooke Kennedy</a> ofrece una descripci칩n general de alto nivel en 5 sencillos pasos para hacer que su proyecto de ciencia de datos sea reproducible.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Zachary Jones</a> brinda m치s detalles sobre la sintaxis y las capacidades junto con los enlaces a otras publicaciones.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">David Stevens</a> escribe una publicaci칩n muy publicitaria sobre por qu칠 absolutamente tienes que comenzar a usar <code>make</code> inmediato.  Proporciona buenos ejemplos que comparan <i>la manera antigua</i> y <i>la nueva</i> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Samuel Lampa</a> , por otro lado, escribe sobre por qu칠 usar <code>make</code> es una mala idea. <br><br>  Mi selecci칩n de sistemas de compilaci칩n no es exhaustiva ni imparcial.  Si desea hacer su lista, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Wikipedia</a> podr칤a ser un buen punto de partida.  Como se indic칩 anteriormente, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cubrir칠</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CMake</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PyBuilder</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pynt</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Paver</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">doit</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Luigi</a> .  La mayor칤a de las herramientas en esta lista est치n basadas en Python y tiene sentido ya que el proyecto est치 en Python.  Esta publicaci칩n no cubrir치 c칩mo instalar las herramientas.  Supongo que eres bastante competente en Python. <br><br>  Estoy principalmente interesado en probar esta funcionalidad: <br><br><ol><li>  Especificar un par de objetivos con dependencias.  Quiero ver c칩mo hacerlo y lo f치cil que es. </li><li>  Verificando si son posibles las construcciones incrementales.  Esto significa que el sistema de compilaci칩n no reconstruir치 lo que no ha cambiado desde la 칰ltima ejecuci칩n, es decir, no necesita volver a descargar sus datos sin procesar.  Otra cosa que buscar칠 es compilaciones incrementales cuando cambie la dependencia.  Imagina que tenemos un gr치fico de dependencias <code>A -&gt; B -&gt; C</code>  쯉e reconstruir치 el objetivo <code>C</code> si <code>B</code> cambia?  Si a? </li><li>  Verificando si la reconstrucci칩n se activar치 si se cambia el c칩digo fuente, es decir, si cambiamos el par치metro del gr치fico generado, la pr칩xima vez que construyamos la imagen debe reconstruirse. </li><li>  Verificando las formas de limpiar los artefactos de compilaci칩n, es decir, eliminar los archivos que se crearon durante la compilaci칩n y volver al c칩digo fuente limpio. </li></ol><br>  No usar칠 todos los objetivos de compilaci칩n de la publicaci칩n de Mateusz, solo tres de ellos para ilustrar los principios. <br><br>  Todo el c칩digo est치 disponible en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> . <br><br><h2><a name="CMake"></a>  CMake </h2><br>  CMake es un generador de scripts de compilaci칩n, que genera archivos de entrada para varios sistemas de compilaci칩n.  Y su nombre significa marca multiplataforma.  CMake es una herramienta de ingenier칤a de software.  Su principal preocupaci칩n es la construcci칩n de ejecutables y bibliotecas.  Entonces CMake sabe c칩mo construir <i>objetivos a</i> partir del c칩digo fuente en los idiomas compatibles.  CMake se ejecuta en dos pasos: configuraci칩n y generaci칩n.  Durante la configuraci칩n, es posible configurar la compilaci칩n futura seg칰n las necesidades.  Por ejemplo, las variables proporcionadas por el usuario se dan durante este paso.  La generaci칩n normalmente es sencilla y produce archivos con los que los sistemas de compilaci칩n pueden trabajar.  Con CMake, a칰n puede usar <code>make</code> , pero en lugar de escribir makefile directamente, escribe un archivo CMake, que generar치 el makefile por usted. <br><br>  Otro concepto importante es que CMake fomenta <i>las compilaciones fuera de la fuente</i> .  Las compilaciones fuera de la fuente mantienen el c칩digo fuente alejado de cualquier artefacto que produzca.  Esto tiene mucho sentido para los ejecutables donde la base de c칩digo de fuente 칰nica puede compilarse bajo diferentes arquitecturas de CPU y sistemas operativos.  Sin embargo, este enfoque puede contradecir la forma en que trabajan muchos cient칤ficos de datos.  Me parece que la comunidad de ciencia de datos tiende a tener un alto acoplamiento de datos, c칩digo y resultados. <br><br>  Veamos qu칠 necesitamos para lograr nuestros objetivos con CMake.  Hay dos posibilidades para definir cosas personalizadas en CMake: objetivos personalizados y comandos personalizados.  Desafortunadamente, necesitaremos usar ambos, lo que da como resultado una mayor tipificaci칩n en comparaci칩n con el archivo MAKE vanila.  Se considera que un objetivo personalizado siempre est치 desactualizado, es decir, si hay un objetivo para descargar datos sin procesar, CMake siempre lo volver치 a descargar.  Una combinaci칩n de comando personalizado con objetivo personalizado permite mantener los objetivos actualizados. <br><br>  Para nuestro proyecto crearemos un archivo llamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CMakeLists.txt</a> y lo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">colocaremos</a> en la ra칤z del proyecto.  Veamos el contenido: <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">cmake_minimum_required</span></span>(VERSION <span class="hljs-number"><span class="hljs-number">3.14</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> FATAL_ERROR) <span class="hljs-keyword"><span class="hljs-keyword">project</span></span>(Cmake_in_ml VERSION <span class="hljs-number"><span class="hljs-number">0.1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> LANGUAGES NONE)</code> </pre><br>  Esta parte es b치sica.  La segunda l칤nea define el nombre de su proyecto, versi칩n y especifica que no usaremos ning칰n soporte de lenguaje incorporado (llamaremos scripts Python). <br><br>  Nuestro primer objetivo descargar치 el conjunto de datos IRIS: <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(IRIS_URL <span class="hljs-string"><span class="hljs-string">"https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data"</span></span> CACHE <span class="hljs-keyword"><span class="hljs-keyword">STRING</span></span> <span class="hljs-string"><span class="hljs-string">"URL to the IRIS data"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(IRIS_DIR <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span>/data/raw) <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(IRIS_FILE <span class="hljs-variable"><span class="hljs-variable">${IRIS_DIR}</span></span>/iris.csv) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_COMMAND</span></span>(OUTPUT <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> <span class="hljs-variable"><span class="hljs-variable">${CMAKE_COMMAND}</span></span> -E echo <span class="hljs-string"><span class="hljs-string">"Downloading IRIS."</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> python src/data/download.py <span class="hljs-variable"><span class="hljs-variable">${IRIS_URL}</span></span> <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> <span class="hljs-variable"><span class="hljs-variable">${CMAKE_COMMAND}</span></span> -E echo <span class="hljs-string"><span class="hljs-string">"Done. Checkout ${IRIS_FILE}."</span></span> WORKING_DIRECTORY <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_TARGET</span></span>(rawdata ALL DEPENDS <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span>)</code> </pre><br>  La primera l칤nea define el par치metro <code>IRIS_URL</code> , que se expone al usuario durante el paso de configuraci칩n.  Si usa CMake GUI, puede establecer esta variable a trav칠s de la GUI: <br><br><img src="https://habrastorage.org/webt/oo/za/pj/oozapjujvjg_q86ndg6r7c5u36a.png"><br><br>  A continuaci칩n, definimos variables con la ubicaci칩n descargada del conjunto de datos IRIS.  Luego agregamos un comando personalizado, que producir치 <code>IRIS_FILE</code> como su salida.  Al final, definimos un <code>rawdata</code> destino personalizado que depende de <code>IRIS_FILE</code> lo que significa que para construir <code>rawdata</code> <code>IRIS_FILE</code> debe construir <code>rawdata</code> .  La opci칩n <code>ALL</code> del objetivo personalizado dice que los datos <code>rawdata</code> ser치n uno de los objetivos predeterminados para construir.  Tenga en cuenta que uso <code>CMAKE_CURRENT_SOURCE_DIR</code> para mantener los datos descargados en la carpeta de origen y no en la carpeta de compilaci칩n.  Esto es solo para que sea lo mismo que Mateusz. <br><br>  Muy bien, veamos c칩mo podemos usarlo.  Actualmente lo estoy ejecutando en Windows con el compilador MinGW instalado.  Es posible que deba ajustar la configuraci칩n del generador seg칰n sus necesidades (ejecute <code>cmake --help</code> para ver la lista de generadores disponibles).  Encienda la terminal y vaya a la carpeta principal del c칩digo fuente, luego: <br><br><pre> <code class="bash hljs">mkdir overcome-the-chaos-build <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> overcome-the-chaos-build cmake -G <span class="hljs-string"><span class="hljs-string">"MinGW Makefiles"</span></span> ../overcome-the-chaos</code> </pre><br><div class="spoiler">  <b class="spoiler_title">resultado</b> <div class="spoiler_text">  - Configuraci칩n realizada <br>  - Generando hecho <br>  - Los archivos de compilaci칩n se han escrito en: C: / home / workspace / superar-el-caos-build <br></div></div><br>  Con CMake moderno podemos construir el proyecto directamente desde CMake.  Este comando invocar치 el comando <code>build all</code> : <br><br><pre> <code class="bash hljs">cmake --build .</code> </pre><br><div class="spoiler">  <b class="spoiler_title">resultado</b> <div class="spoiler_text">  An치lisis de dependencias de rawdata de destino <br>  [100%] Datos de destino construidos <br></div></div><br>  Tambi칠n podemos ver la lista de objetivos disponibles: <br><br><pre> <code class="bash hljs">cmake --build . --target <span class="hljs-built_in"><span class="hljs-built_in">help</span></span></code> </pre><br>  Y podemos eliminar el archivo descargado por: <br><br><pre> <code class="bash hljs">cmake --build . --target clean</code> </pre><br>  Vea que no necesitamos crear el objetivo limpio manualmente. <br><br>  Ahora pasemos al siguiente objetivo: datos IRIS preprocesados.  Mateusz crea dos archivos desde una sola funci칩n: <code>processed.pickle</code> y <code>processed.xlsx</code> .  Puede ver c칩mo se va con la limpieza de este archivo de Excel utilizando <code>rm</code> con comod칤n.  Creo que este no es un muy buen enfoque.  En CMake, tenemos dos opciones de c칩mo tratarlo.  La primera opci칩n es usar la propiedad de directorio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ADDITIONAL_MAKE_CLEAN_FILES</a> .  El c칩digo ser치: <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(PROCESSED_FILE <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span>/data/processed/processed.pickle) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_COMMAND</span></span>(OUTPUT <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> python src/data/preprocess.py <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span> --excel data/processed/processed.xlsx WORKING_DIRECTORY <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span> DEPENDS rawdata <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_TARGET</span></span>(preprocess DEPENDS <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span>) <span class="hljs-comment"><span class="hljs-comment"># Additional files to clean set_property(DIRECTORY PROPERTY ADDITIONAL_MAKE_CLEAN_FILES ${CMAKE_CURRENT_SOURCE_DIR}/data/processed/processed.xlsx )</span></span></code> </pre><br>  La segunda opci칩n es especificar una lista de archivos como salida de comando personalizada: <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">LIST</span></span>(APPEND PROCESSED_FILE <span class="hljs-string"><span class="hljs-string">"${CMAKE_CURRENT_SOURCE_DIR}/data/processed/processed.pickle"</span></span> <span class="hljs-string"><span class="hljs-string">"${CMAKE_CURRENT_SOURCE_DIR}/data/processed/processed.xlsx"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_COMMAND</span></span>(OUTPUT <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> python src/data/preprocess.py <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> data/processed/processed.pickle --excel data/processed/processed.xlsx WORKING_DIRECTORY <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span> DEPENDS rawdata <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> src/data/preprocess.py ) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_TARGET</span></span>(preprocess DEPENDS <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span>)</code> </pre><br>  Vea que en este caso cre칠 la lista, pero no la utilic칠 dentro del comando personalizado.  No conozco una manera de hacer referencia a los argumentos de salida del comando personalizado dentro de 칠l. <br><br>  Otra cosa interesante a tener en cuenta es que el uso de <code>depends</code> en este comando personalizado.  Establecemos la dependencia no solo de un objetivo personalizado, sino tambi칠n su salida y el script de Python.  Si no agregamos dependencia a <code>IRIS_FILE</code> , la modificaci칩n manual de <code>iris.csv</code> no dar치 como resultado la reconstrucci칩n del objetivo <code>IRIS_FILE</code> al <code>IRIS_FILE</code> .  Bueno, no debes modificar los archivos en tu directorio de compilaci칩n manualmente en primer lugar.  Solo dej치ndote saber.  M치s detalles en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la publicaci칩n de Sam Thursday</a> .  La dependencia del script python es necesaria para reconstruir el destino si el script python cambia. <br><br>  Y finalmente el tercer objetivo: <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(EXPLORATORY_IMG <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span>/reports/figures/exploratory.png) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_COMMAND</span></span>(OUTPUT <span class="hljs-variable"><span class="hljs-variable">${EXPLORATORY_IMG}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> python src/visualization/exploratory.py <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span> <span class="hljs-variable"><span class="hljs-variable">${EXPLORATORY_IMG}</span></span> WORKING_DIRECTORY <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span> DEPENDS <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span> src/visualization/exploratory.py ) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_TARGET</span></span>(exploratory DEPENDS <span class="hljs-variable"><span class="hljs-variable">${EXPLORATORY_IMG}</span></span>)</code> </pre><br>  Este objetivo es b치sicamente el mismo que el segundo. <br><br>  Para terminar.  CMake parece desordenado y m치s dif칤cil que Make.  De hecho, mucha gente critica a CMake por su sintaxis.  En mi experiencia, la comprensi칩n llegar치 y es absolutamente posible dar sentido incluso a los archivos CMake muy complicados. <br><br>  Todav칤a se pegar치 mucho, ya que deber치 pasar las variables correctas.  No veo una manera f치cil de hacer referencia a la salida de un comando personalizado en otro.  Parece que es posible hacerlo a trav칠s de objetivos personalizados. <br><br><h2><a name="PyBuilder"></a>  Pybuilder </h2><br>  La parte de PyBuilder es muy corta.  Utilic칠 Python 3.7 en mi proyecto y la versi칩n actual de PyBuilder 0.11.17 no lo admite.  La soluci칩n propuesta es usar la versi칩n de desarrollo.  Sin embargo, esa versi칩n est치 limitada a pip v9.  Pip es v19.3 en el momento de la escritura.  Bummer  Despu칠s de jugar un poco con eso, no me funcion칩 en absoluto.  La evaluaci칩n de PyBuilder fue de corta duraci칩n. <br><br><h2><a name="pynt"></a>  pynt </h2><br>  Pynt est치 basado en Python, lo que significa que podemos usar las funciones de Python directamente.  No es necesario ajustarlos con un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">clic</a> y proporcionar una interfaz de l칤nea de comandos.  Sin embargo, pynt tambi칠n es capaz de ejecutar comandos de shell.  Usar칠 las funciones de Python. <br><br>  Los comandos de compilaci칩n se dan en un archivo <code>build.py</code> .  Los objetivos / tareas se crean con decoradores de funciones.  Las dependencias de tareas se proporcionan a trav칠s del mismo decorador. <br><br>  Como me gustar칤a usar las funciones de Python, necesito importarlas en el script de compilaci칩n.  Pynt no incluye el directorio actual como script de Python, por lo que escribir algo as칤: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> src.data.download <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pydownload_file</code> </pre><br>  No funcionar치.  Tenemos que hacer: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys sys.path.append(os.path.join(os.path.dirname(__file__), <span class="hljs-string"><span class="hljs-string">'.'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> src.data.download <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pydownload_file</code> </pre><br>  Mi archivo <code>build.py</code> inicial era as칤: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/python import os import sys sys.path.append(os.path.join(os.path.dirname(__file__), '.')) from pynt import task from path import Path import glob from src.data.download import pydownload_file from src.data.preprocess import pypreprocess iris_file = 'data/raw/iris.csv' processed_file = 'data/processed/processed.pickle' @task() def rawdata(): '''Download IRIS dataset''' pydownload_file('https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data', iris_file) @task() def clean(): '''Clean all build artifacts''' patterns = ['data/raw/*.csv', 'data/processed/*.pickle', 'data/processed/*.xlsx', 'reports/figures/*.png'] for pat in patterns: for fl in glob.glob(pat): Path(fl).remove() @task(rawdata) def preprocess(): '''Preprocess IRIS dataset''' pypreprocess(iris_file, processed_file, 'data/processed/processed.xlsx')</span></span></code> </pre><br>  Y el objetivo del <code>preprocess</code> no funcion칩.  Constantemente se quejaba de los argumentos de entrada de la funci칩n <code>pypreprocess</code> .  Parece que Pynt no maneja muy bien los argumentos de funciones opcionales.  Tuve que eliminar el argumento para hacer el archivo de Excel.  Tenga esto en cuenta si su proyecto tiene funciones con argumentos opcionales. <br><br>  Podemos ejecutar pynt desde la carpeta del proyecto y enumerar todos los objetivos disponibles: <br><br><pre> <code class="bash hljs">pynt -l</code> </pre><br><div class="spoiler">  <b class="spoiler_title">resultado</b> <div class="spoiler_text"><pre> <code class="bash hljs">Tasks <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> build file build.py: clean Clean all build artifacts exploratory Make an image with pairwise distribution preprocess Preprocess IRIS dataset rawdata Download IRIS dataset Powered by pynt 0.8.2 - A Lightweight Python Build Tool.</code> </pre><br></div></div><br>  Hagamos la distribuci칩n por pares: <br><br><pre> <code class="bash hljs">pynt exploratory</code> </pre><br><div class="spoiler">  <b class="spoiler_title">resultado</b> <div class="spoiler_text"><pre> <code class="bash hljs">[ build.py - Starting task <span class="hljs-string"><span class="hljs-string">"rawdata"</span></span> ] Downloading from https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data to data/raw/iris.csv [ build.py - Completed task <span class="hljs-string"><span class="hljs-string">"rawdata"</span></span> ] [ build.py - Starting task <span class="hljs-string"><span class="hljs-string">"preprocess"</span></span> ] Preprocessing data [ build.py - Completed task <span class="hljs-string"><span class="hljs-string">"preprocess"</span></span> ] [ build.py - Starting task <span class="hljs-string"><span class="hljs-string">"exploratory"</span></span> ] Plotting pairwise distribution... [ build.py - Completed task <span class="hljs-string"><span class="hljs-string">"exploratory"</span></span> ]</code> </pre><br></div></div><br>  Si ahora ejecutamos el mismo comando nuevamente (es decir, <code>pynt exploratory</code> ) habr치 una reconstrucci칩n completa.  Pynt no hizo un seguimiento de que nada ha cambiado. <br><br><h2><a name="Paver"></a>  Adoqu칤n </h2><br>  Pavimentadora se ve casi exactamente como Pynt.  Es ligeramente diferente en una forma en que uno define dependencias entre objetivos (otro decorador <code>@needs</code> ).  Paver realiza una reconstrucci칩n completa cada vez y no funciona bien con funciones que tienen argumentos opcionales.  Las instrucciones de compilaci칩n se encuentran en el archivo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pavement.py</a> . <br><br><h2><a name="doit"></a>  doit </h2><br>  Doit parece un intento de crear una verdadera herramienta de automatizaci칩n de compilaci칩n en python.  Puede ejecutar c칩digo python y comandos de shell.  Se ve bastante prometedor.  Lo que parece perderse (en el contexto de nuestros objetivos espec칤ficos) es la capacidad de manejar las dependencias entre objetivos.  Digamos que queremos hacer una peque침a tuber칤a donde la salida del objetivo A se usa como entrada del objetivo B. Y digamos que estamos usando archivos como salidas, por lo que el objetivo A crea un archivo llamado <code>outA</code> . <br><br><img src="https://habrastorage.org/webt/xh/te/ol/xhteolpanywbjxanltb8uxdsoly.png"><br><br>  Para hacer esta canalizaci칩n, necesitaremos especificar el archivo <code>outA</code> dos veces en el objetivo A (como resultado de un objetivo, pero tambi칠n devolver su nombre como parte de la ejecuci칩n del objetivo).  Luego, tendremos que especificarlo como entrada para el objetivo B. Por lo tanto, hay 3 lugares en total en los que necesitamos proporcionar informaci칩n sobre la <code>outA</code> archivo <code>outA</code>  E incluso despu칠s de hacerlo, la modificaci칩n del archivo <code>outA</code> no conducir치 a la reconstrucci칩n autom치tica del objetivo B. Esto significa que si le pedimos a Doit que construya el objetivo B, solo verificar치 si el objetivo B est치 actualizado sin verificar ninguna de las dependencias  Para superar esto, necesitaremos especificar <code>outA</code> 4 veces, tambi칠n como dependencia de archivo del objetivo B. Veo esto como un inconveniente.  Tanto Make como CMake pueden manejar tales situaciones correctamente. <br><br>  Las dependencias en doit se basan en archivos y se expresan como cadenas.  Esto significa que las dependencias <code>./myfile.txt</code> y <code>myfile.txt</code> se consideran diferentes.  Como escrib칤 anteriormente, me parece un poco extra침o la forma de pasar informaci칩n de un objetivo a otro (cuando se usan objetivos de Python).  El objetivo tiene una lista de artefactos que va a producir, pero otro objetivo no puede usarlo.  En cambio, la funci칩n python, que constituye el objetivo, debe devolver un diccionario, al que se puede acceder desde otro objetivo.  Ve치moslo en un ejemplo: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">task_preprocess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Preprocess IRIS dataset"""</span></span> pickle_file = <span class="hljs-string"><span class="hljs-string">'data/processed/processed.pickle'</span></span> excel_file = <span class="hljs-string"><span class="hljs-string">'data/processed/processed.xlsx'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-string"><span class="hljs-string">'file_dep'</span></span>: [<span class="hljs-string"><span class="hljs-string">'src/data/preprocess.py'</span></span>], <span class="hljs-string"><span class="hljs-string">'targets'</span></span>: [pickle_file, excel_file], <span class="hljs-string"><span class="hljs-string">'actions'</span></span>: [doit_pypreprocess], <span class="hljs-string"><span class="hljs-string">'getargs'</span></span>: {<span class="hljs-string"><span class="hljs-string">'input_file'</span></span>: (<span class="hljs-string"><span class="hljs-string">'rawdata'</span></span>, <span class="hljs-string"><span class="hljs-string">'filename'</span></span>)}, <span class="hljs-string"><span class="hljs-string">'clean'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, }</code> </pre><br>  Aqu칤 el <code>preprocess</code> objetivo depende de los datos sin <code>rawdata</code> .  La dependencia se proporciona a trav칠s de la propiedad <code>getargs</code> .  Dice que el argumento <code>input_file</code> de la funci칩n <code>doit_pypreprocess</code> es el <code>filename</code> de <code>filename</code> de salida de los datos <code>rawdata</code> destino.  Eche un vistazo al ejemplo completo en el archivo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dodo.py.</a> <br><br>  Puede valer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la</a> pena leer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">las historias</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">칠xito</a> del uso de doit.  Definitivamente tiene caracter칤sticas agradables como la capacidad de proporcionar una verificaci칩n de objetivos actualizada personalizada. <br><br><h2><a name="Luigi"></a>  Luigi </h2><br>  Luigi se mantiene alejado de otras herramientas, ya que es un sistema para construir tuber칤as complejas.  Apareci칩 en mi radar despu칠s de que un colega me dijo que intent칩 hacer Make, que nunca pudo usarlo en Windows / Linux y se mud칩 a Luigi. <br><br>  Luigi apunta a sistemas listos para la producci칩n.  Viene con un servidor, que se puede utilizar para visualizar sus tareas o para obtener un historial de ejecuciones de tareas.  El servidor se llama un programador <em>central</em> .  Un planificador local est치 disponible para fines de depuraci칩n. <br><br>  Luigi tambi칠n es diferente de otros sistemas en la forma en que se crean las tareas.  Lugi no act칰a en alg칰n archivo predefinido (como <code>dodo.py</code> , <code>dodo.py</code> o makefile).  M치s bien, uno tiene que pasar un nombre de m칩dulo de Python.  Entonces, si intentamos usarlo de manera similar a otras herramientas (colocar un archivo con tareas en la ra칤z del proyecto), no funcionar치.  Tenemos que instalar nuestro proyecto o modificar la variable de entorno <code>PYTHONPATH</code> agregando la ruta al proyecto. <br><br>  Lo bueno de luigi es la forma de especificar dependencias entre tareas.  Cada tarea es una clase.  La <code>output</code> m칠todo le dice a Luigi d칩nde terminar치n los resultados de la tarea.  Los resultados pueden ser un solo elemento o una lista.  El m칠todo <code>requires</code> especifica dependencias de tareas (otras tareas; aunque es posible hacer una dependencia de s칤 mismo).  Y ya est치.  Lo que se especifica como <code>output</code> en la tarea A se pasar치 como entrada a la tarea B si la tarea B se basa en la tarea A. <br><img src="https://habrastorage.org/getpro/habr/post_images/ba2/95c/bb9/ba295cbb9b744767e709aa7b3a0e358f.png"><br><br>  A Luigi no le importan las modificaciones de archivos.  Se preocupa por la existencia de archivos.  Por lo tanto, no es posible activar reconstrucciones cuando cambia el c칩digo fuente.  Luigi no tiene una funcionalidad <i>limpia</i> incorporada. <br><br>  Las tareas de Luigi para este proyecto est치n disponibles en el archivo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">luigitasks.py</a> .  Los ejecuto desde la terminal: <br><br><pre> <code class="plaintext hljs">luigi --local-scheduler --module luigitasks Exploratory</code> </pre><br><h2><a name="Comparison"></a>  Comparaci칩n </h2><br>  La siguiente tabla resume c칩mo funcionan los diferentes sistemas con respecto a nuestros objetivos espec칤ficos. <br><div class="scrollable-table"><table><tbody><tr><th></th><th>  Definir objetivo con dependencia </th><th>  Construcciones incrementales </th><th>  Compilaciones incrementales si se cambia el c칩digo fuente </th><th>  Capacidad para descubrir qu칠 artefactos eliminar durante <code>clean</code> comando de <code>clean</code> </th></tr><tr><td>  <strong>CMake</strong> </td><td>  si </td><td>  si </td><td>  si </td><td>  si </td></tr><tr><td>  <strong>Pynt</strong> </td><td>  si </td><td>  no </td><td>  no </td><td>  no </td></tr><tr><td>  <strong>Adoqu칤n</strong> </td><td>  si </td><td>  no </td><td>  no </td><td>  no </td></tr><tr><td>  <strong>doit</strong> </td><td>  Algo si </td><td>  si </td><td>  si </td><td>  si </td></tr><tr><td>  <strong>Luigi</strong> </td><td>  si </td><td>  no </td><td>  no </td><td>  no </td></tr></tbody></table></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/451962/">https://habr.com/ru/post/451962/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../451950/index.html">Plantas de energ칤a virtuales. 쮼s posible gestionar las fuentes de energ칤a "verde"?</a></li>
<li><a href="../451954/index.html">M치s telegramas secretos</a></li>
<li><a href="../451956/index.html">Uso de AppDynamics con Red Hat OpenShift v3</a></li>
<li><a href="../451958/index.html">Vemos torrents en la televisi칩n inteligente sin SMS y registro</a></li>
<li><a href="../451960/index.html">90 vulnerabilidades de ejecuci칩n remota de c칩digo en mayo Actualizaci칩n martes</a></li>
<li><a href="../451966/index.html">Los dispositivos modernos de E / S son m치s r치pidos que los procesadores. Resumen del art칤culo</a></li>
<li><a href="../451968/index.html">Top 3D Academy: formaci칩n en tecnolog칤as aditivas en empresas rusas l칤deres</a></li>
<li><a href="../451970/index.html">Thrangrycat: la vulnerabilidad cr칤tica en el firmware del dispositivo Cisco permite a los hackers instalar puertas traseras en ellos</a></li>
<li><a href="../451972/index.html">QuadCast - Suena Real</a></li>
<li><a href="../451974/index.html">Historia de AMD: 50 a침os de r치pido desarrollo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>