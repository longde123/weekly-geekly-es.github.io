<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙇🏽 ⚓️ 🍯 Cree herramientas en proyectos de aprendizaje automático, una descripción general 👹 👴🏻 👲🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Me preguntaba sobre la estructura del proyecto de aprendizaje automático / ciencia de datos / flujo de trabajo y estaba leyendo diferentes opiniones s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cree herramientas en proyectos de aprendizaje automático, una descripción general</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451962/"> Me preguntaba sobre la estructura del proyecto de aprendizaje automático / ciencia de datos / flujo de trabajo y estaba leyendo diferentes opiniones sobre el tema.  Y cuando las personas comienzan a hablar sobre el flujo de trabajo, quieren que sus flujos de trabajo sean reproducibles.  Hay muchas publicaciones que sugieren usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">make</a> para mantener el flujo de trabajo reproducible.  Aunque <code>make</code> es muy estable y ampliamente utilizado, personalmente me gustan las soluciones multiplataforma.  Después de todo, es 2019, no 1977. Se puede argumentar que hacerse es multiplataforma, pero en realidad tendrá problemas y pasará tiempo arreglando su herramienta en lugar de hacer el trabajo real.  Así que decidí echar un vistazo y ver qué otras herramientas están disponibles.  Sí, decidí dedicar algo de tiempo a las herramientas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aff/fbf/656/afffbf6566a6e67ea6427d28d76d7eea.png" alt="imagen"></div><br>  Esta publicación es más una invitación a un diálogo que un tutorial.  Quizás tu solución sea perfecta.  Si es así, será interesante escucharlo. <br><br>  En esta publicación usaré un pequeño proyecto de Python y haré las mismas tareas de automatización con diferentes sistemas: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CMake</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Pybuilder</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pynt</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Adoquín</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">doit</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Luigi</a> </li></ul><br>  Habrá una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tabla de comparación</a> al final de la publicación. <br><a name="habracut"></a><br>  La mayoría de las herramientas que analizaré se conocen como <em>software de automatización de</em> <em>compilación</em> o <em>sistemas de compilación</em> .  Hay miles de ellos en todos los sabores, tamaños y complejidades.  La idea es la misma: el desarrollador define reglas para producir algunos resultados de manera automatizada y consistente.  Por ejemplo, un resultado podría ser una imagen con un gráfico.  Para hacer esta imagen, uno necesitaría descargar los datos, limpiar los datos y hacer algunas manipulaciones de datos (ejemplo clásico, realmente).  Puede comenzar con un par de scripts de shell que harán el trabajo.  Una vez que regrese al proyecto un año después, será difícil recordar todos los pasos y el orden que debe seguir para crear esa imagen.  La solución obvia es documentar todos los pasos.  Buenas noticias!  Los sistemas de construcción le permiten documentar los pasos en forma de programa de computadora.  Algunos sistemas de compilación son como sus scripts de shell, pero con campanas y silbatos adicionales. <br><br>  La base de esta publicación es una serie de publicaciones de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mateusz Bednarski</a> sobre flujo de trabajo automatizado para un proyecto de aprendizaje automático.  Mateusz explica sus puntos de vista y proporciona recetas para usar <code>make</code> .  Te animo a que vayas y revises sus publicaciones primero.  Usaré principalmente su código, pero con diferentes sistemas de compilación. <br><br>  Si desea obtener más información sobre <code>make</code> , a continuación encontrará referencias para un par de publicaciones.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Brooke Kennedy</a> ofrece una descripción general de alto nivel en 5 sencillos pasos para hacer que su proyecto de ciencia de datos sea reproducible.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Zachary Jones</a> brinda más detalles sobre la sintaxis y las capacidades junto con los enlaces a otras publicaciones.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">David Stevens</a> escribe una publicación muy publicitaria sobre por qué absolutamente tienes que comenzar a usar <code>make</code> inmediato.  Proporciona buenos ejemplos que comparan <i>la manera antigua</i> y <i>la nueva</i> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Samuel Lampa</a> , por otro lado, escribe sobre por qué usar <code>make</code> es una mala idea. <br><br>  Mi selección de sistemas de compilación no es exhaustiva ni imparcial.  Si desea hacer su lista, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Wikipedia</a> podría ser un buen punto de partida.  Como se indicó anteriormente, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cubriré</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CMake</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PyBuilder</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pynt</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Paver</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">doit</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Luigi</a> .  La mayoría de las herramientas en esta lista están basadas en Python y tiene sentido ya que el proyecto está en Python.  Esta publicación no cubrirá cómo instalar las herramientas.  Supongo que eres bastante competente en Python. <br><br>  Estoy principalmente interesado en probar esta funcionalidad: <br><br><ol><li>  Especificar un par de objetivos con dependencias.  Quiero ver cómo hacerlo y lo fácil que es. </li><li>  Verificando si son posibles las construcciones incrementales.  Esto significa que el sistema de compilación no reconstruirá lo que no ha cambiado desde la última ejecución, es decir, no necesita volver a descargar sus datos sin procesar.  Otra cosa que buscaré es compilaciones incrementales cuando cambie la dependencia.  Imagina que tenemos un gráfico de dependencias <code>A -&gt; B -&gt; C</code>  ¿Se reconstruirá el objetivo <code>C</code> si <code>B</code> cambia?  Si a? </li><li>  Verificando si la reconstrucción se activará si se cambia el código fuente, es decir, si cambiamos el parámetro del gráfico generado, la próxima vez que construyamos la imagen debe reconstruirse. </li><li>  Verificando las formas de limpiar los artefactos de compilación, es decir, eliminar los archivos que se crearon durante la compilación y volver al código fuente limpio. </li></ol><br>  No usaré todos los objetivos de compilación de la publicación de Mateusz, solo tres de ellos para ilustrar los principios. <br><br>  Todo el código está disponible en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> . <br><br><h2><a name="CMake"></a>  CMake </h2><br>  CMake es un generador de scripts de compilación, que genera archivos de entrada para varios sistemas de compilación.  Y su nombre significa marca multiplataforma.  CMake es una herramienta de ingeniería de software.  Su principal preocupación es la construcción de ejecutables y bibliotecas.  Entonces CMake sabe cómo construir <i>objetivos a</i> partir del código fuente en los idiomas compatibles.  CMake se ejecuta en dos pasos: configuración y generación.  Durante la configuración, es posible configurar la compilación futura según las necesidades.  Por ejemplo, las variables proporcionadas por el usuario se dan durante este paso.  La generación normalmente es sencilla y produce archivos con los que los sistemas de compilación pueden trabajar.  Con CMake, aún puede usar <code>make</code> , pero en lugar de escribir makefile directamente, escribe un archivo CMake, que generará el makefile por usted. <br><br>  Otro concepto importante es que CMake fomenta <i>las compilaciones fuera de la fuente</i> .  Las compilaciones fuera de la fuente mantienen el código fuente alejado de cualquier artefacto que produzca.  Esto tiene mucho sentido para los ejecutables donde la base de código de fuente única puede compilarse bajo diferentes arquitecturas de CPU y sistemas operativos.  Sin embargo, este enfoque puede contradecir la forma en que trabajan muchos científicos de datos.  Me parece que la comunidad de ciencia de datos tiende a tener un alto acoplamiento de datos, código y resultados. <br><br>  Veamos qué necesitamos para lograr nuestros objetivos con CMake.  Hay dos posibilidades para definir cosas personalizadas en CMake: objetivos personalizados y comandos personalizados.  Desafortunadamente, necesitaremos usar ambos, lo que da como resultado una mayor tipificación en comparación con el archivo MAKE vanila.  Se considera que un objetivo personalizado siempre está desactualizado, es decir, si hay un objetivo para descargar datos sin procesar, CMake siempre lo volverá a descargar.  Una combinación de comando personalizado con objetivo personalizado permite mantener los objetivos actualizados. <br><br>  Para nuestro proyecto crearemos un archivo llamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CMakeLists.txt</a> y lo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">colocaremos</a> en la raíz del proyecto.  Veamos el contenido: <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">cmake_minimum_required</span></span>(VERSION <span class="hljs-number"><span class="hljs-number">3.14</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> FATAL_ERROR) <span class="hljs-keyword"><span class="hljs-keyword">project</span></span>(Cmake_in_ml VERSION <span class="hljs-number"><span class="hljs-number">0.1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> LANGUAGES NONE)</code> </pre><br>  Esta parte es básica.  La segunda línea define el nombre de su proyecto, versión y especifica que no usaremos ningún soporte de lenguaje incorporado (llamaremos scripts Python). <br><br>  Nuestro primer objetivo descargará el conjunto de datos IRIS: <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(IRIS_URL <span class="hljs-string"><span class="hljs-string">"https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data"</span></span> CACHE <span class="hljs-keyword"><span class="hljs-keyword">STRING</span></span> <span class="hljs-string"><span class="hljs-string">"URL to the IRIS data"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(IRIS_DIR <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span>/data/raw) <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(IRIS_FILE <span class="hljs-variable"><span class="hljs-variable">${IRIS_DIR}</span></span>/iris.csv) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_COMMAND</span></span>(OUTPUT <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> <span class="hljs-variable"><span class="hljs-variable">${CMAKE_COMMAND}</span></span> -E echo <span class="hljs-string"><span class="hljs-string">"Downloading IRIS."</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> python src/data/download.py <span class="hljs-variable"><span class="hljs-variable">${IRIS_URL}</span></span> <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> <span class="hljs-variable"><span class="hljs-variable">${CMAKE_COMMAND}</span></span> -E echo <span class="hljs-string"><span class="hljs-string">"Done. Checkout ${IRIS_FILE}."</span></span> WORKING_DIRECTORY <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_TARGET</span></span>(rawdata ALL DEPENDS <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span>)</code> </pre><br>  La primera línea define el parámetro <code>IRIS_URL</code> , que se expone al usuario durante el paso de configuración.  Si usa CMake GUI, puede establecer esta variable a través de la GUI: <br><br><img src="https://habrastorage.org/webt/oo/za/pj/oozapjujvjg_q86ndg6r7c5u36a.png"><br><br>  A continuación, definimos variables con la ubicación descargada del conjunto de datos IRIS.  Luego agregamos un comando personalizado, que producirá <code>IRIS_FILE</code> como su salida.  Al final, definimos un <code>rawdata</code> destino personalizado que depende de <code>IRIS_FILE</code> lo que significa que para construir <code>rawdata</code> <code>IRIS_FILE</code> debe construir <code>rawdata</code> .  La opción <code>ALL</code> del objetivo personalizado dice que los datos <code>rawdata</code> serán uno de los objetivos predeterminados para construir.  Tenga en cuenta que uso <code>CMAKE_CURRENT_SOURCE_DIR</code> para mantener los datos descargados en la carpeta de origen y no en la carpeta de compilación.  Esto es solo para que sea lo mismo que Mateusz. <br><br>  Muy bien, veamos cómo podemos usarlo.  Actualmente lo estoy ejecutando en Windows con el compilador MinGW instalado.  Es posible que deba ajustar la configuración del generador según sus necesidades (ejecute <code>cmake --help</code> para ver la lista de generadores disponibles).  Encienda la terminal y vaya a la carpeta principal del código fuente, luego: <br><br><pre> <code class="bash hljs">mkdir overcome-the-chaos-build <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> overcome-the-chaos-build cmake -G <span class="hljs-string"><span class="hljs-string">"MinGW Makefiles"</span></span> ../overcome-the-chaos</code> </pre><br><div class="spoiler">  <b class="spoiler_title">resultado</b> <div class="spoiler_text">  - Configuración realizada <br>  - Generando hecho <br>  - Los archivos de compilación se han escrito en: C: / home / workspace / superar-el-caos-build <br></div></div><br>  Con CMake moderno podemos construir el proyecto directamente desde CMake.  Este comando invocará el comando <code>build all</code> : <br><br><pre> <code class="bash hljs">cmake --build .</code> </pre><br><div class="spoiler">  <b class="spoiler_title">resultado</b> <div class="spoiler_text">  Análisis de dependencias de rawdata de destino <br>  [100%] Datos de destino construidos <br></div></div><br>  También podemos ver la lista de objetivos disponibles: <br><br><pre> <code class="bash hljs">cmake --build . --target <span class="hljs-built_in"><span class="hljs-built_in">help</span></span></code> </pre><br>  Y podemos eliminar el archivo descargado por: <br><br><pre> <code class="bash hljs">cmake --build . --target clean</code> </pre><br>  Vea que no necesitamos crear el objetivo limpio manualmente. <br><br>  Ahora pasemos al siguiente objetivo: datos IRIS preprocesados.  Mateusz crea dos archivos desde una sola función: <code>processed.pickle</code> y <code>processed.xlsx</code> .  Puede ver cómo se va con la limpieza de este archivo de Excel utilizando <code>rm</code> con comodín.  Creo que este no es un muy buen enfoque.  En CMake, tenemos dos opciones de cómo tratarlo.  La primera opción es usar la propiedad de directorio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ADDITIONAL_MAKE_CLEAN_FILES</a> .  El código será: <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(PROCESSED_FILE <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span>/data/processed/processed.pickle) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_COMMAND</span></span>(OUTPUT <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> python src/data/preprocess.py <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span> --excel data/processed/processed.xlsx WORKING_DIRECTORY <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span> DEPENDS rawdata <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_TARGET</span></span>(preprocess DEPENDS <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span>) <span class="hljs-comment"><span class="hljs-comment"># Additional files to clean set_property(DIRECTORY PROPERTY ADDITIONAL_MAKE_CLEAN_FILES ${CMAKE_CURRENT_SOURCE_DIR}/data/processed/processed.xlsx )</span></span></code> </pre><br>  La segunda opción es especificar una lista de archivos como salida de comando personalizada: <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">LIST</span></span>(APPEND PROCESSED_FILE <span class="hljs-string"><span class="hljs-string">"${CMAKE_CURRENT_SOURCE_DIR}/data/processed/processed.pickle"</span></span> <span class="hljs-string"><span class="hljs-string">"${CMAKE_CURRENT_SOURCE_DIR}/data/processed/processed.xlsx"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_COMMAND</span></span>(OUTPUT <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> python src/data/preprocess.py <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> data/processed/processed.pickle --excel data/processed/processed.xlsx WORKING_DIRECTORY <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span> DEPENDS rawdata <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> src/data/preprocess.py ) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_TARGET</span></span>(preprocess DEPENDS <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span>)</code> </pre><br>  Vea que en este caso creé la lista, pero no la utilicé dentro del comando personalizado.  No conozco una manera de hacer referencia a los argumentos de salida del comando personalizado dentro de él. <br><br>  Otra cosa interesante a tener en cuenta es que el uso de <code>depends</code> en este comando personalizado.  Establecemos la dependencia no solo de un objetivo personalizado, sino también su salida y el script de Python.  Si no agregamos dependencia a <code>IRIS_FILE</code> , la modificación manual de <code>iris.csv</code> no dará como resultado la reconstrucción del objetivo <code>IRIS_FILE</code> al <code>IRIS_FILE</code> .  Bueno, no debes modificar los archivos en tu directorio de compilación manualmente en primer lugar.  Solo dejándote saber.  Más detalles en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la publicación de Sam Thursday</a> .  La dependencia del script python es necesaria para reconstruir el destino si el script python cambia. <br><br>  Y finalmente el tercer objetivo: <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(EXPLORATORY_IMG <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span>/reports/figures/exploratory.png) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_COMMAND</span></span>(OUTPUT <span class="hljs-variable"><span class="hljs-variable">${EXPLORATORY_IMG}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> python src/visualization/exploratory.py <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span> <span class="hljs-variable"><span class="hljs-variable">${EXPLORATORY_IMG}</span></span> WORKING_DIRECTORY <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span> DEPENDS <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span> src/visualization/exploratory.py ) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_TARGET</span></span>(exploratory DEPENDS <span class="hljs-variable"><span class="hljs-variable">${EXPLORATORY_IMG}</span></span>)</code> </pre><br>  Este objetivo es básicamente el mismo que el segundo. <br><br>  Para terminar.  CMake parece desordenado y más difícil que Make.  De hecho, mucha gente critica a CMake por su sintaxis.  En mi experiencia, la comprensión llegará y es absolutamente posible dar sentido incluso a los archivos CMake muy complicados. <br><br>  Todavía se pegará mucho, ya que deberá pasar las variables correctas.  No veo una manera fácil de hacer referencia a la salida de un comando personalizado en otro.  Parece que es posible hacerlo a través de objetivos personalizados. <br><br><h2><a name="PyBuilder"></a>  Pybuilder </h2><br>  La parte de PyBuilder es muy corta.  Utilicé Python 3.7 en mi proyecto y la versión actual de PyBuilder 0.11.17 no lo admite.  La solución propuesta es usar la versión de desarrollo.  Sin embargo, esa versión está limitada a pip v9.  Pip es v19.3 en el momento de la escritura.  Bummer  Después de jugar un poco con eso, no me funcionó en absoluto.  La evaluación de PyBuilder fue de corta duración. <br><br><h2><a name="pynt"></a>  pynt </h2><br>  Pynt está basado en Python, lo que significa que podemos usar las funciones de Python directamente.  No es necesario ajustarlos con un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">clic</a> y proporcionar una interfaz de línea de comandos.  Sin embargo, pynt también es capaz de ejecutar comandos de shell.  Usaré las funciones de Python. <br><br>  Los comandos de compilación se dan en un archivo <code>build.py</code> .  Los objetivos / tareas se crean con decoradores de funciones.  Las dependencias de tareas se proporcionan a través del mismo decorador. <br><br>  Como me gustaría usar las funciones de Python, necesito importarlas en el script de compilación.  Pynt no incluye el directorio actual como script de Python, por lo que escribir algo así: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> src.data.download <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pydownload_file</code> </pre><br>  No funcionará.  Tenemos que hacer: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys sys.path.append(os.path.join(os.path.dirname(__file__), <span class="hljs-string"><span class="hljs-string">'.'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> src.data.download <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pydownload_file</code> </pre><br>  Mi archivo <code>build.py</code> inicial era así: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/python import os import sys sys.path.append(os.path.join(os.path.dirname(__file__), '.')) from pynt import task from path import Path import glob from src.data.download import pydownload_file from src.data.preprocess import pypreprocess iris_file = 'data/raw/iris.csv' processed_file = 'data/processed/processed.pickle' @task() def rawdata(): '''Download IRIS dataset''' pydownload_file('https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data', iris_file) @task() def clean(): '''Clean all build artifacts''' patterns = ['data/raw/*.csv', 'data/processed/*.pickle', 'data/processed/*.xlsx', 'reports/figures/*.png'] for pat in patterns: for fl in glob.glob(pat): Path(fl).remove() @task(rawdata) def preprocess(): '''Preprocess IRIS dataset''' pypreprocess(iris_file, processed_file, 'data/processed/processed.xlsx')</span></span></code> </pre><br>  Y el objetivo del <code>preprocess</code> no funcionó.  Constantemente se quejaba de los argumentos de entrada de la función <code>pypreprocess</code> .  Parece que Pynt no maneja muy bien los argumentos de funciones opcionales.  Tuve que eliminar el argumento para hacer el archivo de Excel.  Tenga esto en cuenta si su proyecto tiene funciones con argumentos opcionales. <br><br>  Podemos ejecutar pynt desde la carpeta del proyecto y enumerar todos los objetivos disponibles: <br><br><pre> <code class="bash hljs">pynt -l</code> </pre><br><div class="spoiler">  <b class="spoiler_title">resultado</b> <div class="spoiler_text"><pre> <code class="bash hljs">Tasks <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> build file build.py: clean Clean all build artifacts exploratory Make an image with pairwise distribution preprocess Preprocess IRIS dataset rawdata Download IRIS dataset Powered by pynt 0.8.2 - A Lightweight Python Build Tool.</code> </pre><br></div></div><br>  Hagamos la distribución por pares: <br><br><pre> <code class="bash hljs">pynt exploratory</code> </pre><br><div class="spoiler">  <b class="spoiler_title">resultado</b> <div class="spoiler_text"><pre> <code class="bash hljs">[ build.py - Starting task <span class="hljs-string"><span class="hljs-string">"rawdata"</span></span> ] Downloading from https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data to data/raw/iris.csv [ build.py - Completed task <span class="hljs-string"><span class="hljs-string">"rawdata"</span></span> ] [ build.py - Starting task <span class="hljs-string"><span class="hljs-string">"preprocess"</span></span> ] Preprocessing data [ build.py - Completed task <span class="hljs-string"><span class="hljs-string">"preprocess"</span></span> ] [ build.py - Starting task <span class="hljs-string"><span class="hljs-string">"exploratory"</span></span> ] Plotting pairwise distribution... [ build.py - Completed task <span class="hljs-string"><span class="hljs-string">"exploratory"</span></span> ]</code> </pre><br></div></div><br>  Si ahora ejecutamos el mismo comando nuevamente (es decir, <code>pynt exploratory</code> ) habrá una reconstrucción completa.  Pynt no hizo un seguimiento de que nada ha cambiado. <br><br><h2><a name="Paver"></a>  Adoquín </h2><br>  Pavimentadora se ve casi exactamente como Pynt.  Es ligeramente diferente en una forma en que uno define dependencias entre objetivos (otro decorador <code>@needs</code> ).  Paver realiza una reconstrucción completa cada vez y no funciona bien con funciones que tienen argumentos opcionales.  Las instrucciones de compilación se encuentran en el archivo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pavement.py</a> . <br><br><h2><a name="doit"></a>  doit </h2><br>  Doit parece un intento de crear una verdadera herramienta de automatización de compilación en python.  Puede ejecutar código python y comandos de shell.  Se ve bastante prometedor.  Lo que parece perderse (en el contexto de nuestros objetivos específicos) es la capacidad de manejar las dependencias entre objetivos.  Digamos que queremos hacer una pequeña tubería donde la salida del objetivo A se usa como entrada del objetivo B. Y digamos que estamos usando archivos como salidas, por lo que el objetivo A crea un archivo llamado <code>outA</code> . <br><br><img src="https://habrastorage.org/webt/xh/te/ol/xhteolpanywbjxanltb8uxdsoly.png"><br><br>  Para hacer esta canalización, necesitaremos especificar el archivo <code>outA</code> dos veces en el objetivo A (como resultado de un objetivo, pero también devolver su nombre como parte de la ejecución del objetivo).  Luego, tendremos que especificarlo como entrada para el objetivo B. Por lo tanto, hay 3 lugares en total en los que necesitamos proporcionar información sobre la <code>outA</code> archivo <code>outA</code>  E incluso después de hacerlo, la modificación del archivo <code>outA</code> no conducirá a la reconstrucción automática del objetivo B. Esto significa que si le pedimos a Doit que construya el objetivo B, solo verificará si el objetivo B está actualizado sin verificar ninguna de las dependencias  Para superar esto, necesitaremos especificar <code>outA</code> 4 veces, también como dependencia de archivo del objetivo B. Veo esto como un inconveniente.  Tanto Make como CMake pueden manejar tales situaciones correctamente. <br><br>  Las dependencias en doit se basan en archivos y se expresan como cadenas.  Esto significa que las dependencias <code>./myfile.txt</code> y <code>myfile.txt</code> se consideran diferentes.  Como escribí anteriormente, me parece un poco extraño la forma de pasar información de un objetivo a otro (cuando se usan objetivos de Python).  El objetivo tiene una lista de artefactos que va a producir, pero otro objetivo no puede usarlo.  En cambio, la función python, que constituye el objetivo, debe devolver un diccionario, al que se puede acceder desde otro objetivo.  Veámoslo en un ejemplo: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">task_preprocess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Preprocess IRIS dataset"""</span></span> pickle_file = <span class="hljs-string"><span class="hljs-string">'data/processed/processed.pickle'</span></span> excel_file = <span class="hljs-string"><span class="hljs-string">'data/processed/processed.xlsx'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-string"><span class="hljs-string">'file_dep'</span></span>: [<span class="hljs-string"><span class="hljs-string">'src/data/preprocess.py'</span></span>], <span class="hljs-string"><span class="hljs-string">'targets'</span></span>: [pickle_file, excel_file], <span class="hljs-string"><span class="hljs-string">'actions'</span></span>: [doit_pypreprocess], <span class="hljs-string"><span class="hljs-string">'getargs'</span></span>: {<span class="hljs-string"><span class="hljs-string">'input_file'</span></span>: (<span class="hljs-string"><span class="hljs-string">'rawdata'</span></span>, <span class="hljs-string"><span class="hljs-string">'filename'</span></span>)}, <span class="hljs-string"><span class="hljs-string">'clean'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, }</code> </pre><br>  Aquí el <code>preprocess</code> objetivo depende de los datos sin <code>rawdata</code> .  La dependencia se proporciona a través de la propiedad <code>getargs</code> .  Dice que el argumento <code>input_file</code> de la función <code>doit_pypreprocess</code> es el <code>filename</code> de <code>filename</code> de salida de los datos <code>rawdata</code> destino.  Eche un vistazo al ejemplo completo en el archivo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dodo.py.</a> <br><br>  Puede valer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la</a> pena leer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">las historias</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">éxito</a> del uso de doit.  Definitivamente tiene características agradables como la capacidad de proporcionar una verificación de objetivos actualizada personalizada. <br><br><h2><a name="Luigi"></a>  Luigi </h2><br>  Luigi se mantiene alejado de otras herramientas, ya que es un sistema para construir tuberías complejas.  Apareció en mi radar después de que un colega me dijo que intentó hacer Make, que nunca pudo usarlo en Windows / Linux y se mudó a Luigi. <br><br>  Luigi apunta a sistemas listos para la producción.  Viene con un servidor, que se puede utilizar para visualizar sus tareas o para obtener un historial de ejecuciones de tareas.  El servidor se llama un programador <em>central</em> .  Un planificador local está disponible para fines de depuración. <br><br>  Luigi también es diferente de otros sistemas en la forma en que se crean las tareas.  Lugi no actúa en algún archivo predefinido (como <code>dodo.py</code> , <code>dodo.py</code> o makefile).  Más bien, uno tiene que pasar un nombre de módulo de Python.  Entonces, si intentamos usarlo de manera similar a otras herramientas (colocar un archivo con tareas en la raíz del proyecto), no funcionará.  Tenemos que instalar nuestro proyecto o modificar la variable de entorno <code>PYTHONPATH</code> agregando la ruta al proyecto. <br><br>  Lo bueno de luigi es la forma de especificar dependencias entre tareas.  Cada tarea es una clase.  La <code>output</code> método le dice a Luigi dónde terminarán los resultados de la tarea.  Los resultados pueden ser un solo elemento o una lista.  El método <code>requires</code> especifica dependencias de tareas (otras tareas; aunque es posible hacer una dependencia de sí mismo).  Y ya está.  Lo que se especifica como <code>output</code> en la tarea A se pasará como entrada a la tarea B si la tarea B se basa en la tarea A. <br><img src="https://habrastorage.org/getpro/habr/post_images/ba2/95c/bb9/ba295cbb9b744767e709aa7b3a0e358f.png"><br><br>  A Luigi no le importan las modificaciones de archivos.  Se preocupa por la existencia de archivos.  Por lo tanto, no es posible activar reconstrucciones cuando cambia el código fuente.  Luigi no tiene una funcionalidad <i>limpia</i> incorporada. <br><br>  Las tareas de Luigi para este proyecto están disponibles en el archivo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">luigitasks.py</a> .  Los ejecuto desde la terminal: <br><br><pre> <code class="plaintext hljs">luigi --local-scheduler --module luigitasks Exploratory</code> </pre><br><h2><a name="Comparison"></a>  Comparación </h2><br>  La siguiente tabla resume cómo funcionan los diferentes sistemas con respecto a nuestros objetivos específicos. <br><div class="scrollable-table"><table><tbody><tr><th></th><th>  Definir objetivo con dependencia </th><th>  Construcciones incrementales </th><th>  Compilaciones incrementales si se cambia el código fuente </th><th>  Capacidad para descubrir qué artefactos eliminar durante <code>clean</code> comando de <code>clean</code> </th></tr><tr><td>  <strong>CMake</strong> </td><td>  si </td><td>  si </td><td>  si </td><td>  si </td></tr><tr><td>  <strong>Pynt</strong> </td><td>  si </td><td>  no </td><td>  no </td><td>  no </td></tr><tr><td>  <strong>Adoquín</strong> </td><td>  si </td><td>  no </td><td>  no </td><td>  no </td></tr><tr><td>  <strong>doit</strong> </td><td>  Algo si </td><td>  si </td><td>  si </td><td>  si </td></tr><tr><td>  <strong>Luigi</strong> </td><td>  si </td><td>  no </td><td>  no </td><td>  no </td></tr></tbody></table></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/451962/">https://habr.com/ru/post/451962/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../451950/index.html">Plantas de energía virtuales. ¿Es posible gestionar las fuentes de energía "verde"?</a></li>
<li><a href="../451954/index.html">Más telegramas secretos</a></li>
<li><a href="../451956/index.html">Uso de AppDynamics con Red Hat OpenShift v3</a></li>
<li><a href="../451958/index.html">Vemos torrents en la televisión inteligente sin SMS y registro</a></li>
<li><a href="../451960/index.html">90 vulnerabilidades de ejecución remota de código en mayo Actualización martes</a></li>
<li><a href="../451966/index.html">Los dispositivos modernos de E / S son más rápidos que los procesadores. Resumen del artículo</a></li>
<li><a href="../451968/index.html">Top 3D Academy: formación en tecnologías aditivas en empresas rusas líderes</a></li>
<li><a href="../451970/index.html">Thrangrycat: la vulnerabilidad crítica en el firmware del dispositivo Cisco permite a los hackers instalar puertas traseras en ellos</a></li>
<li><a href="../451972/index.html">QuadCast - Suena Real</a></li>
<li><a href="../451974/index.html">Historia de AMD: 50 años de rápido desarrollo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>