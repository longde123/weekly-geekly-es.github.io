<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😽 👫 👨🏻 Como escrever programas polimórficos usando o Arrow ✌🏾 🉐 🎅🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Olá Habr! 

 Meu nome é Artyom Dobrovinsky, trabalho para Finch . Sugiro a leitura de um artigo de um dos pais da biblioteca de programação funcional ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como escrever programas polimórficos usando o Arrow</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/447234/"><img src="https://habrastorage.org/webt/va/-y/jh/va-yjhqxdrghleli7gqzgt553r0.png"><br><br>  Olá Habr! <br><br>  Meu nome é Artyom Dobrovinsky, trabalho para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Finch</a> .  Sugiro a leitura de um artigo de um dos pais da biblioteca de programação funcional <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>Arrow</code></a> sobre como escrever programas polimórficos.  Muitas vezes, as pessoas que estão começando a escrever em um estilo funcional não têm pressa em abandonar hábitos antigos e, de fato, escrevem um imperativo um pouco mais elegante, com recipientes e herança de DI.  A idéia de reutilizar funções, independentemente dos tipos que elas usam, pode levar muitos a pensar na direção certa. <br><p>  Aproveite! </p><a name="habracut"></a><br><h3>  *** </h3><br><p>  E se pudéssemos escrever aplicativos sem pensar nos tipos de dados que serão usados ​​em tempo de execução, mas simplesmente descrever como esses dados serão processados? </p><br><p>  Imagine que temos um aplicativo que funciona com o tipo <code>Observable</code> da biblioteca RxJava.  Esse tipo nos permite escrever cadeias de chamadas e manipulações com dados, mas no final, esse <code>Observable</code> não será apenas um contêiner com propriedades adicionais? </p><br><p>  A mesma história com tipos como <code>Flowable</code> , Adiado (Coroutines), <code>Future</code> , <code>IO</code> e muitos outros. </p><br><p>  Conceitualmente, todos esses tipos representam uma operação (já executada ou planejada para ser implementada no futuro) que suporta manipulações como converter um valor interno para outro tipo ( <code>map</code> ), usando <code>flatMap</code> para criar uma cadeia de operações de um tipo semelhante, combinando-se com outras instâncias do mesmo tipo ( <code>zip</code> ) etc. </p><br><p>  Para escrever programas com base nesses comportamentos, mantendo uma descrição declarativa e também para tornar seus programas independentes de tipos de dados específicos como <code>Observable</code> basta que os tipos de dados utilizados correspondam a determinados contratos, como <code>map</code> , <code>flatMap</code> e outros . </p><br><p>  Essa abordagem pode parecer estranha ou muito complicada, mas tem vantagens interessantes.  Primeiro, considere um exemplo simples e depois fale sobre eles. </p><cut></cut><br><h3 id="kanonicheskaya-problema">  Problema canônico </h3><br><p>  Suponha que tenhamos um aplicativo com uma lista de tarefas, e gostaríamos de extrair uma lista de objetos do tipo <code>Task</code> do cache local.  Se eles não forem encontrados no armazenamento local, tentaremos consultá-los pela rede.  Precisamos de um contrato único para ambas as fontes de dados, para que ambas possam obter uma lista de objetos do tipo <code>Task</code> para um objeto <code>User</code> adequado, independentemente da fonte: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataSource</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Observable&lt;List&lt;Task&gt;&gt; }</code> </pre> <br><p>  Aqui, por simplicidade, retornamos <code>Observable</code> , mas pode ser <code>Single</code> , <code>Maybe</code> , <code>Flowable</code> , <code>Deferred</code> - qualquer coisa adequada para alcançar a meta. </p><br><p>  Adicione algumas implementações mocha de fontes de dados, uma para <code></code> e outra para <code></code> . </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalDataSource</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DataSource { private val localCache: Map</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">User, List&lt;Task</span></span></span><span class="hljs-class">&gt;&gt; = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mapOf</span></span></span></span>(User(UserId(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>)) to listOf(Task(<span class="hljs-string"><span class="hljs-string">"LocalTask assigned to user1"</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Observable&lt;List&lt;Task&gt;&gt; = Observable.create { emitter -&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cachedUser = localCache[user] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cachedUser != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { emitter.onNext(cachedUser) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { emitter.onError(UserNotInLocalStorage(user)) } } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RemoteDataSource</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DataSource { private val internetStorage: Map</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">User, List&lt;Task</span></span></span><span class="hljs-class">&gt;&gt; = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mapOf</span></span></span></span>(User(UserId(<span class="hljs-string"><span class="hljs-string">"user2"</span></span>)) to listOf(Task(<span class="hljs-string"><span class="hljs-string">"Remote Task assigned to user2"</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Observable&lt;List&lt;Task&gt;&gt; = Observable.create { emitter -&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> networkUser = internetStorage[user] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (networkUser != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { emitter.onNext(networkUser) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { emitter.onError(UserNotInRemoteStorage(user)) } } }</code> </pre> <br><p>  As implementações de ambas as fontes de dados são quase idênticas.  Essas são simplesmente versões simuladas dessas fontes que, idealmente, extraem dados do armazenamento local ou da API da rede.  Nos dois casos, o <code>Map&lt;User, List&lt;Task&gt;&gt;</code> é usado para armazenar dados. </p><br><p>  Porque  temos duas fontes de dados, precisamos coordená-las de alguma forma.  Crie um repositório: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TaskRepository</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> localDS: DataSource, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> remoteDS: RemoteDataSource) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Observable&lt;List&lt;Task&gt;&gt; = localDS.allTasksByUser(user) .subscribeOn(Schedulers.io()) .observeOn(Schedulers.computation()) .onErrorResumeNext { _: Throwable -&gt; remoteDS.allTasksByUser(user) } }</code> </pre> <br><p>  Ele apenas tenta carregar a <code>List&lt;Task&gt;</code> do <code>LocalDataSource</code> e, se não for encontrado, tenta solicitá-los da rede usando <code>RemoteDataSource</code> . </p><br><p>  Vamos criar um módulo simples para fornecer dependências sem usar nenhuma estrutura para injeção de dependência (DI): </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Module</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> localDataSource: LocalDataSource = LocalDataSource() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> remoteDataSource: RemoteDataSource = RemoteDataSource() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> repository: TaskRepository = TaskRepository(localDataSource, remoteDataSource) }</code> </pre> <br><p>  E, finalmente, precisamos de um teste simples que execute toda a pilha de operações: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> test { <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user1 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user2 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user2"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user3 = User(UserId(<span class="hljs-string"><span class="hljs-string">"unknown user"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dependenciesModule = Module() dependenciesModule.run { repository.allTasksByUser(user1).subscribe({ println(it) }, { println(it) }) repository.allTasksByUser(user2).subscribe({ println(it) }, { println(it) }) repository.allTasksByUser(user3).subscribe({ println(it) }, { println(it) }) } } }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Todo o código acima pode ser encontrado no github</a> . </p><br><p>  Este programa compõe a cadeia de execução para três usuários e depois assina o <code>Observable</code> resultante. </p><br><p>  Os dois primeiros objetos do tipo <code>User</code> estão disponíveis, com isso tivemos sorte.  <code>User1</code> está disponível no <code>DataSource</code> local e <code>User2</code> está disponível no controle remoto. </p><br><p>  Mas há um problema com o <code>User3</code> , porque ele não está disponível no armazenamento local.  O programa tentará fazer o download de um serviço remoto - mas também não está lá.  A pesquisa falhará e exibiremos uma mensagem de erro no console. </p><br><p>  Aqui está o que será exibido no console para todos os três casos: </p><br><pre> <code class="plaintext hljs">&gt; [Task(value=LocalTask assigned to user1)] &gt; [Task(value=Remote Task assigned to user2)] &gt; UserNotInRemoteStorage(user=User(userId=UserId(value=unknown user)))</code> </pre> <br><p>  Terminamos com um exemplo.  Agora vamos tentar programar essa lógica no estilo do <code> </code> . </p><br><h3 id="abstragirovanie-tipov-dannyh">  Abstração de tipo de dados </h3><br><p>  Agora, o contrato para a interface <code>DataSource</code> ficará assim: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataSource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Kind&lt;F, List&lt;Task&gt;&gt; }</code> </pre> <br><p>  Tudo parece ser semelhante, mas há duas diferenças importantes: </p><br><ul><li>  Existe uma dependência do tipo generalizado (genérico) <code>F</code> </li><li>  O tipo retornado pela função agora é <code>Kind&lt;F, List&lt;Task&gt;&gt;</code> . </li></ul><br><p>  <code>Kind</code> é como a Arrow codifica o que é comumente chamado de <code>  (higher kind)</code> . <br>  Vou explicar esse conceito com um exemplo simples. </p><br><p>  <code>Observable&lt;A&gt;</code> tem 2 partes: </p><br><ul><li>  <code>Observable</code> : contêiner, tipo fixo. </li><li>  <code>A</code> : argumento de um tipo genérico.  Uma abstração para a qual outros tipos podem ser transmitidos. </li></ul><br><p>  Estamos acostumados a usar tipos genéricos como <code>A</code> como abstrações.  Mas poucas pessoas sabem que também podemos abstrair tipos de contêineres como <code>Observable</code> .  Para isso, existem tipos altos. </p><br><p>  A idéia é que podemos ter um construtor como <code>F&lt;A&gt;</code> no qual <code>F</code> e <code>A</code> podem ser do tipo genérico.  Essa sintaxe ainda não é suportada pelo compilador Kotlin ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ainda?</a> ). Portanto, nós a imitaremos com uma abordagem semelhante. </p><br><p>  O Arrow suporta isso através do uso de uma meta interface intermediária <code>Kind&lt;F, A&gt;</code> , que contém links para ambos os tipos, e também gera conversores em ambas as direções durante a compilação, para que você possa seguir o caminho de <code>Kind&lt;Observable, List&lt;Task&gt;&gt;</code> para <code>Observable&lt;List&lt;Task&gt;&gt;</code> e vice-versa.  Não é uma solução ideal, mas funcional. </p><br><p>  Então, novamente, veja a interface do nosso repositório: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataSource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Kind&lt;F, List&lt;Task&gt;&gt; }</code> </pre> <br><p>  A função <code>DataSource</code> retorna um tipo alto: <code>Kind&lt;F, List&lt;Task&gt;&gt;</code> .  Ele se traduz em <code>F&lt;List&lt;Task&gt;&gt;</code> , onde <code>F</code> permanece generalizado. </p><br><p>  Capturamos apenas a <code>List&lt;Task&gt;</code> na assinatura.  Em outras palavras, não nos importamos com o contêiner do tipo <code>F</code> , desde que contenha uma <code>List&lt;Task&gt;</code> .  Podemos passar diferentes contêineres de dados para a função.  Já está claro?  Vá em frente. </p><br><p>  Vamos dar uma olhada no <code>DataSource</code> implementado dessa maneira, mas desta vez para cada um individualmente.  Primeiro ao local: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalDataSource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">&gt;</span></span>(A: ApplicativeError&lt;F, Throwable&gt;) : DataSource&lt;F&gt;, ApplicativeError&lt;F, Throwable&gt; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> A { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> localCache: Map&lt;User, List&lt;Task&gt;&gt; = mapOf(User(UserId(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>)) to listOf(Task(<span class="hljs-string"><span class="hljs-string">"LocalTask assigned to user1"</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Kind&lt;F, List&lt;Task&gt;&gt; = Option.fromNullable(localCache[user]).fold( { raiseError(UserNotInLocalStorage(user)) }, { just(it) } ) }</code> </pre> <br><p>  Muitas coisas novas foram adicionadas, analisaremos tudo passo a passo. </p><br><p>  Este <code>DataSource</code> retém o tipo genérico <code>F</code> porque implementa um <code>DataSource&lt;F&gt;</code> .  Queremos manter a possibilidade de transmitir esse tipo de fora. </p><br><p>  Agora, esqueça o <code>ApplicativeError</code> possivelmente desconhecido no construtor e concentre-se na função <code>allTasksByUser()</code> .  E retornaremos ao <code>ApplicativeError</code> . </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Kind&lt;F, List&lt;Task&gt;&gt; = Option.fromNullable(localCache[user]).fold( { raiseError(UserNotInLocalStorage(user)) }, { just(it) } )</code> </pre> <br><p>  Pode-se ver que ele retorna <code>Kind&lt;F, List&lt;Task&gt;&gt;</code> .  Ainda não nos importamos com o contêiner <code>F</code> , contanto que contenha uma <code>List&lt;Task&gt;</code> . </p><br><p>  Mas há um problema.  Dependendo de encontrar ou não a lista de objetos de <code>Task</code> para o usuário desejado no armazenamento local, queremos relatar um erro (nenhuma <code>Task</code> encontrada) ou retornar a <code>Task</code> já encapsulada em <code>F</code> ( <code>Task</code> encontrada). </p><br><p>  E para ambos os casos, precisamos retornar: <code>Kind&lt;F, List&lt;Task&gt;&gt;</code> . </p><br><p>  Em outras palavras: existe um tipo sobre o qual não sabemos nada ( <code>F</code> ) e precisamos de uma maneira de retornar um erro envolvido nesse tipo.  Além disso, precisamos de uma maneira de criar uma instância desse tipo, na qual o valor obtido após a conclusão bem-sucedida da função seja agrupado.  Parece algo impossível? </p><br><p>  Vamos voltar à declaração de classe e observar que <code>ApplicativeError</code> é passado para o construtor e, em seguida, usado como delegado para a classe ( <code>by A</code> ). </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalDataSource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">&gt;</span></span>(A: ApplicativeError&lt;F, Throwable&gt;) : DataSource&lt;F&gt;, ApplicativeError&lt;F, Throwable&gt; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> A { <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>ApplicativeError</code></a> herdado de <code>Applicative</code> , ambos são classes de tipos. </p><br><p>  As classes de tipo definem comportamentos (contratos).  Eles são codificados como interfaces que funcionam com argumentos na forma de tipos genéricos, como em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>Monad&lt;F&gt;</code></a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>Functor&lt;F&gt;</code></a> e muitos outros.  Este <code>F</code> é um tipo de dados.  Dessa forma, podemos passar tipos como <code>Either</code> , <code>Option</code> , <code>IO</code> , <code>Observable</code> , <code>Flowable</code> e muitos mais. </p><br><p>  Então, voltando aos nossos dois problemas: </p><br><ul><li>  Quebra o valor obtido após a função ser concluída com êxito em <code>Kind&lt;F, List&lt;Task&gt;&gt;</code> </li></ul><br><p>  Para isso, podemos usar uma classe do tipo <code>Applicative</code> .  Como <code>ApplicativeError</code> herdado, podemos delegar suas propriedades. </p><br><p>  <code>Applicative</code> just fornece a função <code>just(a)</code> .  <code>just(a)</code> agrupa o valor no contexto de qualquer tipo alto.  Assim, se tivermos o <code>Applicative&lt;F&gt;</code> , ele pode chamar <code>just(a)</code> para agrupar o valor no contêiner <code>F</code> , qualquer que seja esse valor.  Digamos que usamos <code>Observable</code> , teremos um <code>Applicative&lt;Observable&gt;</code> que sabe como agrupar <code>a</code> em um <code>Observable</code> , para obtermos <code>Observable.just(a)</code> . </p><br><ul><li>  Quebra do erro na instância <code>Kind&lt;F, List&lt;Task&gt;&gt;</code> </li></ul><br><p>  Para isso, podemos usar <code>ApplicativeError</code> .  Ele fornece uma função <code>raiseError(e)</code> , que envolve o erro em um contêiner do tipo <code>F</code>  Para o exemplo <code>Observable</code> , um erro criará algo como <code>Observable.error&lt;A&gt;(t)</code> , em que <code>t</code> é <code>Throwable</code> , pois declaramos nosso tipo de erro como uma classe do tipo <code>ApplicativeError&lt;F, Throwable&gt;</code> . </p><br><p>  Dê uma olhada em nossa implementação abstrata de <code>LocalDataSource&lt;F&gt;</code> . </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalDataSource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">&gt;</span></span>(A: ApplicativeError&lt;F, Throwable&gt;) : DataSource&lt;F&gt;, ApplicativeError&lt;F, Throwable&gt; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> A { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> localCache: Map&lt;User, List&lt;Task&gt;&gt; = mapOf(User(UserId(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>)) to listOf(Task(<span class="hljs-string"><span class="hljs-string">"LocalTask assigned to user1"</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Kind&lt;F, List&lt;Task&gt;&gt; = Option.fromNullable(localCache[user]).fold( { raiseError(UserNotInLocalStorage(user)) }, { just(it) } ) }</code> </pre> <br><p>  O <code>Map&lt;User, List&lt;Task&gt;&gt;</code> armazenado na memória permanece o mesmo, mas agora a função faz algumas coisas que podem ser novas para você: </p><br><ul><li><p>  Ela tenta carregar a lista de <code>Task</code> do cache local e, como o valor de retorno pode ser <code>null</code> (a <code>Task</code> pode não ser encontrada), modelamos isso usando <code>Option</code> .  Se não estiver claro como o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>Option</code></a> funciona, ele modela a presença ou a ausência do valor envolvido nele. </p><br></li><li><p>  Depois de receber o valor opcional, chamamos <code>fold</code> em cima dele.  Isso equivale a usar a <code>when</code> sobre um valor opcional.  Se o valor estiver faltando, a <code>Option</code> oculta o erro no tipo de dados <code>F</code> (primeiro lambda passado).  E se o valor estiver presente, o <code>Option</code> criará uma instância do wrapper para o tipo de dados <code>F</code> (segundo lambda).  Nos dois casos, as propriedades <code>ApplicativeError</code> mencionadas anteriormente são usadas: <code>raiseError()</code> e <code>just()</code> . </p><br></li></ul><br><p>  Assim, abstraímos a implementação de fontes de dados usando classes para que elas não saibam qual contêiner será usado para o tipo <code>F</code> . </p><br><p>  A implementação de um <code>DataSource</code> rede se parece com isso: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RemoteDataSource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">&gt;</span></span>(A: Async&lt;F&gt;) : DataSource&lt;F&gt;, Async&lt;F&gt; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> A { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> internetStorage: Map&lt;User, List&lt;Task&gt;&gt; = mapOf(User(UserId(<span class="hljs-string"><span class="hljs-string">"user2"</span></span>)) to listOf(Task(<span class="hljs-string"><span class="hljs-string">"Remote Task assigned to user2"</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Kind&lt;F, List&lt;Task&gt;&gt; = async { callback: (Either&lt;Throwable, List&lt;Task&gt;&gt;) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> -&gt; Option.fromNullable(internetStorage[user]).fold( { callback(UserNotInRemoteStorage(user).left()) }, { callback(it.right()) } ) } }</code> </pre> <br><p>  Mas há uma pequena diferença: em vez de delegar para a instância <code>ApplicativeError</code> , usamos outra classe como: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>Async</code></a> . </p><br><p>  Isso ocorre porque as chamadas de rede são de natureza assíncrona.  Queremos escrever código que será executado de forma assíncrona; é lógico usar uma classe de tipo projetada para isso. </p><br><p>  <code>Async</code> usado para simular operações assíncronas.  Pode simular qualquer operação de retorno de chamada.  Observe que ainda não conhecemos os tipos de dados específicos; simplesmente descrevemos uma operação de natureza assíncrona. </p><br><p>  Considere a seguinte função: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Kind&lt;F, List&lt;Task&gt;&gt; = async { callback: (Either&lt;Throwable, List&lt;Task&gt;&gt;) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> -&gt; Option.fromNullable(internetStorage[user]).fold( { callback(UserNotInRemoteStorage(user).left()) }, { callback(it.right()) } ) }</code> </pre> <br><p>  Podemos usar a função <code>async {}</code> , que é fornecida com uma classe do tipo <code>Async</code> para simular a operação e criar uma instância do tipo <code>Kind&lt;F, List&lt;Task&gt;&gt;</code> que será criada de forma assíncrona. </p><br><p>  Se <code>Async.async {}</code> um tipo de dados fixo como <code>Observable</code> , <code>Async.async {}</code> seria equivalente a <code>Observable.create()</code> , ou seja,  criando uma operação que pode ser chamada a partir de código síncrono ou assíncrono, como <code>Thread</code> ou <code>AsyncTask</code> . </p><br><p>  O parâmetro de <code>callback</code> é usado para vincular os retornos de chamada resultantes ao contexto do contêiner <code>F</code> , que é do tipo alto. </p><br><p>  Assim, nosso <code>RemoteDataSource</code> abstraído e depende do contêiner ainda desconhecido do tipo <code>F</code> </p><br><p>  Vamos subir para o nível de abstração e dar uma nova olhada no nosso repositório.  Se você se lembra, primeiro precisamos procurar objetos <code>Task</code> em <code>LocalDataSource</code> e somente depois (se não foram encontrados localmente) para solicitá-los ao <code>RemoteLocalDataSource</code> . </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TaskRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">&gt;</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> localDS: DataSource&lt;F&gt;, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> remoteDS: RemoteDataSource&lt;F&gt;, AE: ApplicativeError&lt;F, Throwable&gt;) : ApplicativeError&lt;F, Throwable&gt; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> AE { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Kind&lt;F, List&lt;Task&gt;&gt; = localDS.allTasksByUser(user).handleErrorWith { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (it) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> UserNotInLocalStorage -&gt; remoteDS.allTasksByUser(user) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; raiseError(UnknownError(it)) } } }</code> </pre> <br><p>  <code>ApplicativeError&lt;F, Throwable&gt;</code> está conosco novamente!  Ele também fornece uma função <code>handleErrorWith()</code> que funciona sobre qualquer receptor high-end. </p><br><p>  É assim: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;A&gt;</span></span></span><span class="hljs-function"> Kind</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;F, A&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleErrorWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">E</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; Kind&lt;F, A&gt;): Kind&lt;F, A&gt;</code> </pre> <br><p>  Porque  <code>localDS.allTasksByUser(user)</code> retorna <code>Kind&lt;F, List&lt;Task&gt;&gt;</code> , que pode ser considerado como <code>F&lt;List&lt;Task&gt;&gt;</code> , onde <code>F</code> permanece um tipo genérico, podemos chamar <code>handleErrorWith()</code> sobre ele. </p><br><p>  <code>handleErrorWith()</code> permite responder a erros usando a lambda passada.  Vamos dar uma olhada na função: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allTasksByUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Kind&lt;F, List&lt;Task&gt;&gt; = localDS.allTasksByUser(user).handleErrorWith { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (it) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> UserNotInLocalStorage -&gt; remoteDS.allTasksByUser(user) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; raiseError(UnknownError(it)) } }</code> </pre> <br><p>  Assim, obtemos o resultado da primeira operação, exceto quando uma exceção foi lançada.  A exceção será tratada pelo lambda.  Se o erro pertencer ao tipo <code>UserNotInLocalStorage</code> , tentaremos encontrar objetos do tipo <code>Tasks</code> no <code>DataSource</code> remoto.  Em todos os outros casos, envolvemos o erro desconhecido em um contêiner do tipo <code>F</code> </p><br><p>  O módulo de dependência permanece muito semelhante à versão anterior: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Module</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">&gt;</span></span>(A: Async&lt;F&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> localDataSource: LocalDataSource&lt;F&gt; = LocalDataSource(A) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> remoteDataSource: RemoteDataSource&lt;F&gt; = RemoteDataSource(A) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> repository: TaskRepository&lt;F&gt; = TaskRepository(localDataSource, remoteDataSource, A) }</code> </pre> <br><p>  A única diferença é que agora é abstrato e depende de <code>F</code> , que permanece polimórfico.  Eu deliberadamente não prestei atenção a isso para reduzir o nível de ruído, mas o <code>Async</code> herda de <code>ApplicativeError</code> ; portanto, ele pode ser usado como instância em todos os níveis de execução do programa. </p><br><h3 id="testiruya-polimorfizm">  Teste de polimorfismo </h3><br><p>  Finalmente, nosso aplicativo é completamente abstraído do uso de tipos de dados específicos para contêineres ( <code>F</code> ) e podemos nos concentrar em testar o polformismo em tempo de execução.  Testaremos o mesmo trecho de código que passa diferentes tipos de dados para o tipo <code>F</code>  O cenário é o mesmo de quando usamos o <code>Observable</code> . </p><br><p>  O programa é escrito de tal maneira que nos livramos completamente dos limites das abstrações e podemos transmitir os detalhes da implementação, conforme desejado. </p><br><p>  Primeiro, vamos tentar usar o <code>F</code> <code>Single</code> do RxJava como um contêiner. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> test { <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user1 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user2 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user2"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user3 = User(UserId(<span class="hljs-string"><span class="hljs-string">"unknown user"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> singleModule = Module(SingleK.async()) singleModule.run { repository.allTasksByUser(user1).fix().single.subscribe(::println, ::println) repository.allTasksByUser(user2).fix().single.subscribe(::println, ::println) repository.allTasksByUser(user3).fix().single.subscribe(::println, ::println) } } }</code> </pre> <br><p>  Para compatibilidade, o Arrow fornece wrappers para tipos de dados de biblioteca conhecidos.  Por exemplo, existe um invólucro <code>SingleK</code> conveniente.  Esses wrappers permitem usar classes de tipos em conjunto com tipos de dados como tipos altos. </p><br><p>  O seguinte será exibido no console: </p><br><pre> <code class="plaintext hljs">[Task(value=LocalTask assigned to user1)] [Task(value=Remote Task assigned to user2)] UserNotInRemoteStorage(user=User(userId=UserId(value=unknown user)))</code> </pre> <br><p>  O mesmo resultado será se usar <code>Observable</code> . </p><br><p>  Agora vamos trabalhar com o <code>Maybe</code> , para o qual o wrapper <code>MaybeK</code> está <code>MaybeK</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user1 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user2 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user2"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user3 = User(UserId(<span class="hljs-string"><span class="hljs-string">"unknown user"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> maybeModule = Module(MaybeK.async()) maybeModule.run { repository.allTasksByUser(user1).fix().maybe.subscribe(::println, ::println) repository.allTasksByUser(user2).fix().maybe.subscribe(::println, ::println) repository.allTasksByUser(user3).fix().maybe.subscribe(::println, ::println) } }</code> </pre> <br><p>  O mesmo resultado será exibido no console, mas agora usando um tipo de dados diferente: </p><br><pre> <code class="kotlin hljs">[Task(value=LocalTask assigned to user1)] [Task(value=Remote Task assigned to user2)] UserNotInRemoteStorage(user=User(userId=UserId(value=unknown user)))</code> </pre> <br><p>  E o <code>ObservableK</code> / <code>FlowableK</code> ? <br>  Vamos tentar: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> test { <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user1 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user2 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user2"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user3 = User(UserId(<span class="hljs-string"><span class="hljs-string">"unknown user"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> observableModule = Module(ObservableK.async()) observableModule.run { repository.allTasksByUser(user1).fix().observable.subscribe(::println, ::println) repository.allTasksByUser(user2).fix().observable.subscribe(::println, ::println) repository.allTasksByUser(user3).fix().observable.subscribe(::println, ::println) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> flowableModule = Module(FlowableK.async()) flowableModule.run { repository.allTasksByUser(user1).fix().flowable.subscribe(::println) repository.allTasksByUser(user2).fix().flowable.subscribe(::println) repository.allTasksByUser(user3).fix().flowable.subscribe(::println, ::println) } } }</code> </pre> <br><p>  Vamos ver no console: </p><br><pre> <code class="plaintext hljs">[Task(value=LocalTask assigned to user1)] [Task(value=Remote Task assigned to user2)] UserNotInRemoteStorage(user=User(userId=UserId(value=unknown user))) [Task(value=LocalTask assigned to user1)] [Task(value=Remote Task assigned to user2)] UserNotInRemoteStorage(user=User(userId=UserId(value=unknown user)))</code> </pre> <br><p>  Tudo funciona como esperado. </p><br><p>  Vamos tentar usar o <code>DeferredK</code> , um wrapper para o tipo <code>kotlinx.coroutines.Deferred</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> test { <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user1 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user2 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user2"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user3 = User(UserId(<span class="hljs-string"><span class="hljs-string">"unknown user"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deferredModule = Module(DeferredK.async()) deferredModule.run { runBlocking { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { println(repository.allTasksByUser(user1).fix().deferred.await()) println(repository.allTasksByUser(user2).fix().deferred.await()) println(repository.allTasksByUser(user3).fix().deferred.await()) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: UserNotInRemoteStorage) { println(e) } } } } }</code> </pre> <br><p>  Como você sabe, o tratamento de exceções ao usar corutin deve ser explicitamente prescrito.   ,        ,        . </p><br><p>   —   : </p><br><pre> <code class="plaintext hljs">[Task(value=LocalTask assigned to user1)] [Task(value=Remote Task assigned to user2)] UserNotInRemoteStorage(user=User(userId=UserId(value=unknown user)))</code> </pre> <br><p>  Arrow   API     <code>DeferredK</code> .     <code>runBlocking</code>     : </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> test { <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user1 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user2 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user2"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user3 = User(UserId(<span class="hljs-string"><span class="hljs-string">"unknown user"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deferredModuleAlt = Module(DeferredK.async()) deferredModuleAlt.run { println(repository.allTasksByUser(user1).fix().unsafeAttemptSync()) println(repository.allTasksByUser(user2).fix().unsafeAttemptSync()) println(repository.allTasksByUser(user3).fix().unsafeAttemptSync()) } } }</code> </pre> <br><p>      [ <code>Try</code> ]({{ '/docs/arrow/core/try/ru' | relative_url }}) (..,   <code>Success</code>  <code>Failure</code> ). </p><br><pre> <code class="plaintext hljs">Success(value=[Task(value=LocalTask assigned to user1)]) Success(value=[Task(value=Remote Task assigned to user2)]) Failure(exception=UserNotInRemoteStorage(user=User(userId=UserId(value=unknown user))))</code> </pre> <br><p> ,          ,  <code>IO</code> . <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>IO</code></a> ,   in/out ,      ,       . </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> test { <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user1 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user2 = User(UserId(<span class="hljs-string"><span class="hljs-string">"user2"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user3 = User(UserId(<span class="hljs-string"><span class="hljs-string">"unknown user"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> ioModule = Module(IO.async()) ioModule.run { println(repository.allTasksByUser(user1).fix().attempt().unsafeRunSync()) println(repository.allTasksByUser(user2).fix().attempt().unsafeRunSync()) println(repository.allTasksByUser(user3).fix().attempt().unsafeRunSync()) } } }</code> </pre> <br><pre> <code class="plaintext hljs">Right(b=[Task(value=LocalTask assigned to user1)]) Right(b=[Task(value=Remote Task assigned to user2)]) Left(a=UserNotInRemoteStorage(user=User(userId=UserId(value=unknown user))))</code> </pre> <br><p> <code>IO</code> —  .          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>Either&lt;L,R&gt;</code></a> (   ).  , ""  <code>Either</code>    ,  ""    ,    .          <code>Right(...)</code> ,  ,  <code>Left(...)</code> . </p><br><p>      . </p><br><p> ,   .   ,         ,      ,           . </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">       </a> . </p><br><h3 id="vsyo-eto-otlichno-zvuchitno-stoit-li-ono-togo">    …     ? </h3><br><p>    ,    ,      .     . </p><br><ul><li><p>       : ,      (,  ),   — .  ,     . </p><br></li><li><p>         ,    .         .        ()   (   )  ,   . </p><br></li><li><p>      (),   ,          ().         ,         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">    </a> . </p><br></li><li><p>   ,         . ,            (      ). </p><br></li><li><p>       ,      API     .       (        <code>map</code> , <code>flatMap</code> , <code>fold</code> ,        ). ,     ,       Kotlin,  Arrow —   . </p><br></li><li><p>          DI ( ), ..,    DI " ".         ,         ,              .        DI, ..,     ,        . </p><br></li><li><p>   ,     ,     .      , ..,    ,         . </p><br></li></ul><br><h3 id="dopolnitelno">  </h3><br><p>       ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">   </a> . <br>   ,         ,   ,      ,   . </p><br><p>   ,    .     —   Twitter: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">@JorgeCastilloPR</a> . </p><br><p>     (,  )    : </p><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Kotlin Functional Programming: Does it make sense?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Jorge Castillo</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Kotlin purity and Function Memoization</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Jorge Castillo</a> </li></ul><br><p>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">FP to the max</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">John De Goes</a>     <code>FpToTheMax.kt</code> ,    <code>arrow-examples</code> .          ,   ,          . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt447234/">https://habr.com/ru/post/pt447234/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt447218/index.html">Análise do JPoint 2019</a></li>
<li><a href="../pt447220/index.html">Noções básicas do mecanismo JavaScript: formulários gerais e cache embutido. Parte 2</a></li>
<li><a href="../pt447222/index.html">Quest do Linux. Parabéns aos vencedores e converse sobre a solução de problemas</a></li>
<li><a href="../pt447226/index.html">Entrevista com o popularizador da ciência, diretor da única escola particular de astronomia da Rússia, Pavel Skripnichenko</a></li>
<li><a href="../pt447232/index.html">Experiência pessoal. Como conectamos a telefonia internacional: comparação de 6 trocas virtuais</a></li>
<li><a href="../pt447236/index.html">Criando um farm de dispositivos Android usando o Open STF</a></li>
<li><a href="../pt447240/index.html">Aprenda táticas, técnicas e conhecimentos comuns do adversário (ATT @ CK). Táticas corporativas. Parte 10</a></li>
<li><a href="../pt447242/index.html">Automação do servidor Jenkins SQL: retornando o resultado lindamente</a></li>
<li><a href="../pt447244/index.html">C301 e miniOTP-3, novos tokens programáveis ​​do Token2</a></li>
<li><a href="../pt447246/index.html">Protótipo em 1 dia em vez de 2 a 3 semanas: impressão 3D na preocupação Okeanpribor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>