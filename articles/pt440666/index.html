<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôèüèø ‚ôíÔ∏è üëÉüèº Classifica√ß√£o de desenhos manuscritos. Relat√≥rio em Yandex üßóüèª üö∂ üò©</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="H√° alguns meses, nossos colegas do Google realizaram um concurso no Kaggle para criar um classificador para as imagens recebidas no aclamado jogo "Qui...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Classifica√ß√£o de desenhos manuscritos. Relat√≥rio em Yandex</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/440666/">  H√° alguns meses, nossos colegas do Google <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">realizaram</a> um concurso no Kaggle para criar um classificador para as imagens recebidas no aclamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">jogo</a> "Quick, Draw!".  A equipe, na qual o desenvolvedor de Yandex Roman Vlasov participou, ficou em quarto lugar na competi√ß√£o.  Na sess√£o de treinamento em aprendizado de m√°quina de janeiro, Roman compartilhou as id√©ias de sua equipe, a implementa√ß√£o final do classificador e pr√°ticas interessantes de seus rivais. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HO8ymjF-UTw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  - Ol√° pessoal!  Meu nome √© Roma Vlasov, hoje vou falar sobre o Quick, Draw!  Desafio de reconhecimento do Doodle. <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/hw/xb/vc/hwxbvcwdjtsmvlzi9q9zly8khwe.jpeg"><br><br>  Havia cinco pessoas em nossa equipe.  Entrei para ela bem na frente do prazo de mesclagem.  T√≠nhamos azar, est√°vamos um pouco abalados, mas est√°vamos sombreados por dinheiro, e eles eram da posi√ß√£o de ouro.  E conquistamos um quarto lugar honroso. <br><br>  (Durante a competi√ß√£o, as equipes observaram-se na classifica√ß√£o, formada de acordo com os resultados mostrados em uma parte do conjunto de dados proposto. A classifica√ß√£o final, por sua vez, foi formada na outra parte do conjunto de dados. Isso √© feito para que os participantes da competi√ß√£o n√£o ajustem seus algoritmos a dados espec√≠ficos. Portanto, nas finais, ao alternar entre classifica√ß√µes, as posi√ß√µes "tremem" um pouco (do ingl√™s para cima - embaralhe): em outros dados e o resultado pode ser diferente. A equipe de Roman foi a primeira entre as tr√™s primeiras.  AU troika - √© dinheiro, zona rankings de dinheiro, uma vez que apenas os tr√™s primeiros locais baseou pr√™mio Depois que a equipe "agita√ß√£o apa' j√° estava no quarto lugar da mesma forma a outra equipe perdeu a vit√≥ria, a posi√ß√£o de ouro -... Ed) .. <br><br><img src="https://habrastorage.org/webt/4x/zs/9d/4xzs9dipspiteybhjdudb9kdj7g.jpeg"><br><br>  A competi√ß√£o tamb√©m foi significativa porque Yevgeny Babakhnin recebeu grandes mestres para ele, Ivan Sosin - mestres, Roman Solovyov permaneceu um grande mestre, Alex Parinov recebeu um mestre, me tornei um especialista, e agora j√° sou mestre. <br><br><img src="https://habrastorage.org/webt/fy/-v/gv/fy-vgvzvgssn2kmnn3slpjajo5a.jpeg"><br><br>  O que √© isso Quick, Draw?  Este √© um servi√ßo do Google.  O Google pretendia popularizar a IA e, com esse servi√ßo, queria mostrar como as redes neurais funcionam.  Voc√™ vai l√°, clique em Vamos desenhar, e uma nova p√°gina aparece onde voc√™ recebe instru√ß√µes: desenhe um zigue-zague, voc√™ tem 20 segundos para fazer isso.  Voc√™ tenta desenhar um zigue-zague em 20 segundos, como aqui, por exemplo.  Se tudo der certo para voc√™, a rede diz que √© um zigue-zague e voc√™ segue em frente.  Existem apenas seis dessas imagens. <br><br>  Se a rede do Google n√£o reconhecer o que voc√™ desenhou, uma cruz foi colocada na tarefa.  Mais tarde, vou lhe dizer o que significa no futuro se o desenho √© reconhecido pela rede ou n√£o. <br><br>  Este servi√ßo reuniu um n√∫mero bastante grande de usu√°rios e todas as imagens que os usu√°rios desenharam foram registradas. <br><br><img src="https://habrastorage.org/webt/ni/kl/on/niklonrxxlfht_gy0u4yzg3k5og.jpeg"><br><br>  Foi poss√≠vel coletar quase 50 milh√µes de fotos.  A partir disso, a data do trem e do teste para nossa competi√ß√£o foi formada.  A prop√≥sito, a quantidade de dados no teste e o n√∫mero de classes n√£o s√£o em v√£o em negrito.  Eu vou falar sobre eles um pouco mais tarde. <br><br>  O formato dos dados foi o seguinte.  Essas n√£o s√£o apenas imagens RGB, mas, grosso modo, o log de tudo o que o usu√°rio fez.  A palavra √© nosso alvo, o c√≥digo do pa√≠s √© de onde o doodle √©, o carimbo de data e hora √© a hora.  A etiqueta reconhecida apenas mostra se a rede do Google reconheceu a imagem ou n√£o.  E desenhar em si √© uma sequ√™ncia, uma aproxima√ß√£o da curva que o usu√°rio desenha com pontos.  E hor√°rios.  Este √© o tempo desde o in√≠cio do desenho da imagem. <br><br><img src="https://habrastorage.org/webt/xw/_y/zw/xw_yzwjp5d8osd1ejay6gcncywu.jpeg"><br><br>  Os dados foram apresentados em dois formatos.  Este √© o primeiro formato e o segundo √© simplificado.  Eles mediram os intervalos a partir da√≠ e aproximaram esse conjunto de pontos com um conjunto menor de pontos.  Para fazer isso, eles usaram <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o algoritmo Douglas-Pecker</a> .  Voc√™ tem um grande conjunto de pontos que simplesmente se aproxima de uma linha reta e pode realmente aproximar essa linha com apenas dois pontos.  Essa √© a ideia do algoritmo. <br><br>  Os dados foram distribu√≠dos da seguinte forma.  Tudo √© uniforme, mas existem alguns valores discrepantes.  Quando resolvemos o problema, n√£o olhamos para ele.  O principal √© que n√£o havia classes realmente poucas, n√£o precis√°vamos fazer amostradores ponderados e sobreamostragem de dados. <br><br><img src="https://habrastorage.org/webt/cp/_z/8y/cp_z8ydmx3m7gaptzpm9pvfglvu.jpeg"><br><br>  Como eram as fotos?  Esta √© a classe de aeronave e os exemplos s√£o rotulados como reconhecidos e n√£o reconhecidos.  A propor√ß√£o deles estava entre 1 e 9. Como voc√™ pode ver, os dados s√£o bastante barulhentos.  Eu sugeriria que este √© um avi√£o.  Se voc√™ olhar para n√£o reconhecido, na maioria dos casos, √© apenas ru√≠do.  Algu√©m at√© tentou escrever "avi√£o", mas aparentemente em franc√™s. <br><br>  A maioria dos participantes simplesmente pegou grades, renderizou dados dessa sequ√™ncia de linhas como imagens RGB e as jogou na rede.  Eu pintei aproximadamente da mesma maneira: peguei uma paleta de cores, pintei a primeira linha com uma cor, que estava no in√≠cio desta paleta, a √∫ltima com outra, que estava no final da paleta e em todos os lugares interpolados nessa paleta.  A prop√≥sito, isso deu um resultado melhor do que se voc√™ desenhar como no primeiro slide - apenas preto. <br><br>  Outros membros da equipe, como Ivan Sosin, tentaram abordagens ligeiramente diferentes do desenho.  Com um canal, ele simplesmente desenhou uma imagem cinza, com outro canal, desenhava cada tra√ßado com um gradiente do come√ßo ao fim, de 32 a 255, e o terceiro canal desenhava um gradiente em todos os tra√ßados de 32 a 255. <br><br>  Outra coisa interessante √© que Alex Parinov lan√ßou informa√ß√µes na rede via c√≥digo do pa√≠s. <br><br><img src="https://habrastorage.org/webt/wm/z0/iw/wmz0iw6jp4sxzqm2z3zqtafkhbo.jpeg"><br><br>  A m√©trica usada na competi√ß√£o √© Precis√£o M√©dia M√©dia.  Qual √© a ess√™ncia dessa m√©trica para a competi√ß√£o?  Voc√™ pode fornecer tr√™s preditores e, se esses tr√™s preditores n√£o estiverem corretos, voc√™ obt√©m 0. Se houver um preditivo correto, sua ordem ser√° levada em considera√ß√£o.  E o resultado para o destino ser√° considerado 1, dividido pela ordem da sua previs√£o.  Por exemplo, voc√™ fez tr√™s previs√µes, e a primeira √© a correta, ent√£o voc√™ divide 1 por 1 e obt√©m 1. Se o preditor estiver correto e sua ordem for 2, ent√£o 1 divis√£o por 2, obt√©m 0,5.  Bem, etc. <br><br><img src="https://habrastorage.org/webt/ar/fm/7k/arfm7knnnynq6iekr-ykcnxvdr8.jpeg"><br><br>  Com o pr√©-processamento de dados - como desenhar figuras e assim por diante - decidimos um pouco.  Quais arquiteturas usamos?  Tentamos usar arquiteturas arrojadas, como PNASNet, SENet e j√° arquiteturas cl√°ssicas como SE-Res-NeXt, elas est√£o cada vez mais entrando em novas competi√ß√µes.  Havia tamb√©m ResNet e DenseNet. <br><br><img src="https://habrastorage.org/webt/rr/4p/ku/rr4pkuestkfvwxz4l-7absymotq.jpeg"><br><br><img src="https://habrastorage.org/webt/yz/4z/9_/yz4z9_fybssrwzh3recxexbrkbg.jpeg"><br><br><img src="https://habrastorage.org/webt/hw/eg/p9/hwegp98dpudcisrhvfbqx-92648.jpeg"><br><br>  Como n√≥s ensinamos isso?  Todos os modelos que adotamos, n√≥s nos treinamos previamente na imagenet.  Embora existam muitos dados, 50 milh√µes de fotos, mas ainda assim, se voc√™ usar uma rede pr√©-treinada na imagenet, ela apresentou um resultado melhor do que se voc√™ a treinasse do zero. <br><br>  Que t√©cnicas de treinamento usamos?  Este √© o Custeio de Recozimento com Reinicializa√ß√µes Quentes, falarei um pouco mais tarde.  Esta √© uma t√©cnica que uso em quase todas as minhas √∫ltimas competi√ß√µes e, com elas, resulta muito bem treinar as redes, atingir um bom m√≠nimo. <br><br><img src="https://habrastorage.org/webt/9v/ch/ht/9vchht1fyo2sahp7bbxv7nnks3a.jpeg"><br><br>  Em seguida, reduza a taxa de aprendizado no plat√¥.  Voc√™ come√ßa a treinar a rede, define uma taxa de aprendizado espec√≠fica, aprende e depois a perda converge gradualmente para algum valor espec√≠fico.  Voc√™ verifica isso, por exemplo, mais de dez √©pocas, a perda n√£o foi alterada.  Voc√™ reduz sua taxa de aprendizado por algum valor e continua aprendendo.  Novamente, ele cai um pouco, converge em um determinado m√≠nimo e, novamente, voc√™ reduz a taxa de aprendizado e assim por diante, at√© que sua rede finalmente converge. <br><br>  Outra t√©cnica interessante: n√£o decaia a taxa de aprendizado, aumente o tamanho do lote.  Existe um artigo com o mesmo nome.  Quando voc√™ treina a rede, n√£o precisa diminuir a taxa de aprendizado, basta aumentar o tamanho do lote. <br><br>  Essa t√©cnica, ali√°s, foi usada por Alex Parinov.  Ele come√ßou com um lote igual a 408 e, quando a rede chegou a algum patamar, ele simplesmente dobrou o tamanho do lote, etc. <br><br>  Na verdade, n√£o me lembro de que valor o tamanho do lote alcan√ßou, mas, curiosamente, havia equipes no Kaggle que usavam a mesma t√©cnica, o tamanho do lote era de cerca de 10.000. Ali√°s, estruturas modernas de aprendizado profundo, como O PyTorch, por exemplo, permite que voc√™ fa√ßa isso de maneira muito simples.  Voc√™ gera seu lote e o envia para a rede n√£o como est√° na sua totalidade, mas o divide em peda√ßos para que se encaixe na sua placa de v√≠deo, conte os gradientes e, depois de calcular o gradiente para todo o lote, voc√™ atualiza as escalas. <br><br>  A prop√≥sito, grandes tamanhos de lote ainda entraram nessa competi√ß√£o, porque os dados eram muito barulhentos e um tamanho de lote grande ajudou a aproximar com mais precis√£o o gradiente. <br><br>  Pseudo-dabbing tamb√©m foi usado, na maioria das vezes, foi usado por Roman Soloviev.  Ele coletou metade dos dados do teste e, nesses lotes, treinou a grade. <br><br>  O tamanho das fotos desempenhou um papel importante, mas o fato √© que voc√™ possui muitos dados, precisa treinar por um longo tempo e, se o tamanho da foto for muito grande, voc√™ treinar√° por um longo tempo.  Mas isso n√£o trouxe muito para a qualidade do seu classificador final; portanto, valeu a pena usar algumas trocas.  E eles tentaram apenas fotos de tamanho n√£o muito grande. <br><br>  Como tudo isso aprendeu?  A princ√≠pio, foram tiradas fotos de tamanho pequeno, v√°rias √©pocas foram executadas, rapidamente levou tempo.  Em seguida, foram fornecidas imagens grandes, a rede aprendeu, e ainda mais, ainda mais, para n√£o trein√°-la do zero e n√£o gastar muito tempo. <br><br>  Sobre otimizadores.  Usamos SGD e Adam.  Dessa forma, foi poss√≠vel obter um modelo √∫nico, que proporcionava uma velocidade de 0,941-0,946 em uma tabela de classifica√ß√£o p√∫blica, o que √© muito bom. <br><br>  Se voc√™ montar os modelos de alguma forma, chegar√° a algum lugar em 0,951.  Se voc√™ aplicar outra t√©cnica, obter√° a velocidade final no quadro p√∫blico 0,954, conforme recebemos.  Mas mais sobre isso mais tarde.  A seguir, mostrarei como montamos os modelos e como essa velocidade final foi alcan√ßada. <br><br>  Em seguida, eu gostaria de falar sobre o recozimento de custo com reinicializa√ß√µes a quente ou descida estoc√°stica por gradiente com reinicializa√ß√µes a quente.  Grosso modo, em princ√≠pio, voc√™ pode manter qualquer otimizador, mas o ponto principal √© este: se voc√™ treinar uma rede e gradualmente convergir para um m√≠nimo, tudo estar√° bem, voc√™ obter√° uma rede, cometer√° alguns erros, mas voc√™ pode ensin√°-la um pouco diferente.  Voc√™ definir√° uma taxa de aprendizado inicial e diminuir√° gradualmente de acordo com esta f√≥rmula.  Voc√™ o subestima, sua rede chega a um determinado m√≠nimo, depois economiza pesos e define novamente a taxa de aprendizado, que estava no in√≠cio do treinamento, desse modo suba a algum lugar e subestime novamente sua taxa de aprendizado. <br><br>  Assim, voc√™ pode visitar v√°rios pontos baixos ao mesmo tempo, nos quais ter√° a perda mais ou menos a mesma.  Mas o fato √© que redes com esses pesos apresentar√£o erros diferentes em sua data.  Ao calcul√°-los, voc√™ obter√° uma certa aproxima√ß√£o e sua velocidade ser√° maior. <br><br><img src="https://habrastorage.org/webt/ra/5d/mz/ra5dmzx9mcelguiqckvaihllrkc.jpeg"><br><br>  Sobre como montamos nossos modelos.  No in√≠cio da apresenta√ß√£o, eu disse para prestar aten√ß√£o na quantidade de dados no teste e no n√∫mero de aulas.  Se voc√™ adicionar 1 ao n√∫mero de destinos no conjunto de testes e dividir pelo n√∫mero de classes, obter√° o n√∫mero 330 e foi escrito sobre isso no f√≥rum - que as classes no teste s√£o equilibradas.  Isso pode ser usado. <br><br>  Com base nisso, Roman Solovyov inventou a m√©trica, denominada Proxy Score, que se correlacionava muito bem com a tabela de classifica√ß√£o.  A linha inferior √©: voc√™ faz uma previs√£o, pega o top 1 das suas previs√µes e conta o n√∫mero de objetos para cada classe.  Subtraia 330 de cada valor e adicione os valores absolutos resultantes. <br><br>  Tais valores acabaram.  Isso nos ajudou a n√£o fazer um placar de teste, mas a validar localmente e selecionar coeficientes para nossos conjuntos. <br><br>  Com o conjunto, voc√™ pode obter essa velocidade.  O que mais fazer?  Suponha que voc√™ tenha usado as informa√ß√µes de que as classes em seu teste s√£o equilibradas. <br><br>  O equil√≠brio foi diferente.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Um exemplo de um deles</a> √© o equil√≠brio entre os caras que conquistaram o primeiro lugar. <br><br>  O que n√≥s fizemos?  Nosso balanceamento foi bastante simples, foi proposto por Evgeny Babakhnin.  Primeiro, classificamos nossas previs√µes pelo top 1 e selecionamos candidatos a partir deles - para que o n√∫mero de classes n√£o excedesse 330. Mas para algumas classes, verifica-se que h√° menos previs√µes do que 330. Ok, vamos classificar pelo top 2 e top 3, e tamb√©m escolher candidatos. <br><br>  Como nosso equil√≠brio diferia do equil√≠brio em primeiro lugar?  Eles usaram uma abordagem iterativa, pegaram a classe mais popular e reduziram as probabilidades para essa classe em um n√∫mero pequeno - at√© que essa classe n√£o se tornou a mais popular.  Eles fizeram a pr√≥xima aula mais popular.  T√£o mais longe e reduzido at√© o n√∫mero de todas as classes se tornar igual. <br><br>  Todos usaram uma abordagem de mais ou menos uma para treinar redes, mas nem todos usaram o balanceamento.  Usando o balanceamento, voc√™ pode entrar em ouro e, se tiver sorte, ent√£o em mani. <br><br>  Como pr√©-processar uma data?  Todos pr√©-processaram a data mais-menos da mesma maneira - eles criaram recursos artesanais, tentaram codificar hor√°rios com cores diferentes de tra√ßos, etc. Alexey Nozdrin-Plotnitsky, que ficou em 8¬∫ lugar, estava falando sobre isso. <br><br><img src="https://habrastorage.org/webt/lq/jg/yb/lqjgybopsgcacrtnubcet3jub9e.jpeg"><br><br>  Ele fez diferente.  Ele disse que todos esses recursos artesanais n√£o funcionam, voc√™ n√£o precisa fazer isso, sua rede deve aprender tudo isso sozinho.  E, em vez disso, ele criou m√≥dulos de aprendizado que pr√©-processavam seus dados.  Ele jogou neles os dados de origem sem pr√©-processamento - as coordenadas de pontos e tempos. <br><br>  Al√©m disso, ele pegou a diferen√ßa nas coordenadas e calculou a m√©dia ao longo dos tempos.  E ele tem uma matriz bastante longa.  Ele usou a convolu√ß√£o 1D v√°rias vezes para obter uma matriz 64xn, onde n √© o n√∫mero total de pontos e 64 √© feito para alimentar a matriz resultante a uma camada de alguma rede convolucional que aceita 64 canais. acabou sendo uma matriz de 64xn; da√≠, foi necess√°rio compor um tensor de algum tamanho para que o n√∫mero de canais fosse 64. Ele normalizou todos os pontos X, Y no intervalo de 0 a 32 para criar um tensor de tamanho 32x32.  N√£o sei por que ele queria 32x32, aconteceu.  E nessa coordenada ele colocou um fragmento dessa matriz de tamanho 64xn.  Assim, ele simplesmente recebeu o tensor 32x32x64, que poderia ser colocado ainda mais na sua rede neural convolucional.  Eu tenho tudo </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt440666/">https://habr.com/ru/post/pt440666/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt440654/index.html">Aprendendo Python: m√≥dulo argparse</a></li>
<li><a href="../pt440656/index.html">Cont√™iner profissional de aplicativos Node.js. usando o Docker</a></li>
<li><a href="../pt440658/index.html">Explorando o Docker, parte 4: reduzindo o tamanho das imagens e acelerando sua montagem</a></li>
<li><a href="../pt440660/index.html">Docker de aprendizagem, parte 5: comandos</a></li>
<li><a href="../pt440662/index.html">Tutorial Reagir Parte 18: A sexta fase do trabalho em um aplicativo TODO</a></li>
<li><a href="../pt440670/index.html">O Banco Central publicou recomenda√ß√µes sobre a prote√ß√£o criptogr√°fica do EBS</a></li>
<li><a href="../pt440672/index.html">M√©todos de racionalidade e o tapete de ora√ß√£o do Magrebe</a></li>
<li><a href="../pt440674/index.html">Usando gr√°ficos de dispers√£o para visualizar dados</a></li>
<li><a href="../pt440676/index.html">O dia em que Dodo parou. Script s√≠ncrono</a></li>
<li><a href="../pt440678/index.html">DIY router CNC passatempo. Humanidades para as humanidades. Parte 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>