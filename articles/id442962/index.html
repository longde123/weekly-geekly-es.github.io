<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😇 📭 👩🏾‍🤝‍👨🏿 Artikel lain tentang masa hidup di Rust 👨‍🚒 🚗 👨‍🔧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bulan-bulan pertama seorang perusuh pemula biasanya datang ke header tentang konsep seumur hidup dan kepemilikan. Beberapa orang merinci hal ini, teta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Artikel lain tentang masa hidup di Rust</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442962/"><p> Bulan-bulan pertama seorang perusuh pemula biasanya datang ke header tentang konsep seumur hidup dan kepemilikan.  Beberapa orang merinci hal ini, tetapi bagi mereka yang mampu bertahan, ini tidak lagi tampak tidak biasa atau salah.  Saya akan menjelaskan poin-poin kunci yang, menurut saya, telah membantu untuk beradaptasi lebih cepat dan lebih baik dengan konsep kehidupan dan harta. <img src="https://habrastorage.org/webt/vm/qw/p5/vmqwp5m_uwm9ghbbtcm5be3xqre.png" align="right"></p><br><p>  Tentu saja, buletin resmi lebih penuh dan lebih rinci, tetapi juga membutuhkan lebih banyak waktu dan kesabaran untuk sepenuhnya memahami dan menyerap semua informasi.  Saya mencoba untuk menghindari sejumlah besar detail dan menyajikan semuanya dalam rangka meningkatkan kompleksitas, dalam upaya untuk membuat artikel ini lebih mudah diakses oleh mereka yang baru mulai menonton pesta, atau tidak benar-benar memahami saat-saat awal dari papan buletin resmi. </p><br><p>  Itu juga membuat saya menulis bahwa, misalnya, dari monad, Anda dapat menemukan beberapa materi pelatihan resmi, tetapi mereka tidak selalu dipahami dengan baik, dan pemahaman muncul hanya setelah membaca sesuatu seperti "pengantar lain" pada topik ini. </p><br><h3 id="vremya-zhizni-lifetime">  Seumur hidup </h3><br><p>  Pertama kita perlu merasa nyaman dengan dua hal - akhir blok dan memindahkan nilainya ke blok lain.  Nanti kita akan mulai memperumitnya dengan menambahkan “pinjaman”, “mutabilitas” dan “mutabilitas tersembunyi”. </p><a name="habracut"></a><br><p>  Pertama-tama, umur suatu nilai ditentukan oleh segmen berikut: </p><br><ul><li>  Awal Kehidupan: Menciptakan Nilai.  Ini umum untuk sebagian besar bahasa pemrograman, sehingga tidak membawa muatan yang tidak biasa. </li><li>  Akhir hidup.  Di sinilah Rust akan secara otomatis memanggil destructor dan melupakan nilainya.  Di blok ruang lingkup, ini akan terjadi di akhir blok ini tanpa bergerak.  Ini adalah pelacakan mental dari akhir kehidupan yang, menurut pendapat saya, adalah kunci untuk interaksi yang sukses dengan peminjam. </li></ul><cut></cut><br><p>  Saya akan menambahkan detail yang mungkin berguna: jika ada beberapa nilai dalam ruang lingkup, maka mereka akan dihancurkan dalam urutan terbalik penciptaan. </p><br><p>  Poin lain: Saya akan membuat string, karena tidak memiliki penanda Salin, dan nilai-nilai yang memiliki penanda ini tidak bergerak tetapi disalin, yang dianggap sebagai operasi yang lebih murah, tetapi mengubah perilaku gerakan (dan membuatnya lebih mudah untuk bekerja dengan tipe primitif), tetapi lebih lanjut tentang itu nanti. </p><br><p>  Contoh dapat dijalankan di sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://play.rust-lang.org/</a> </p><br><pre><code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { { <span class="hljs-comment"><span class="hljs-comment">//    let a = "a".to_string(); // &lt;-   "a" let b = 100; // &lt;-   "b" // &lt;-   b // &lt;-   a } //    //     "a"  "b" }</span></span></code> </pre> <br><p>  Dengan blok sederhana, semuanya relatif sederhana, tahap berikutnya terjadi ketika kita menggunakan hal-hal yang tampaknya sederhana seperti fungsi dan penutupan: </p><br><h3 id="peremeschenie">  Bergerak </h3><br><p>  Tambahkan konsep seperti memindahkan nilai.  Dengan kata sederhana, "bergerak" berarti bahwa blok saat ini tidak lagi tertarik pada nasib nilai dan melupakannya, dan nasibnya ditransfer ke blok lain, misalnya, ke fungsi lain, atau ke penutupan, atau hanya ke nilai lain. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>&lt;T: std::fmt::Display&gt;(x: T) { <span class="hljs-comment"><span class="hljs-comment">//   ,         . println!("{}", x); // &lt;-  ,   "a",    . } fn main() { let a = "a".to_string(); // "a"    let b = 2; f(a); //   "a"  f //        f(a) -   ,    "a"        .    a  b,    ,      Copy   . // "b" . }</span></span></code> </pre> <br><p>  Dengan penutupan. </p><br><p>  Agar penutupan untuk memindahkan nilai yang ditangkap ke bloknya, gerakan kata kunci digunakan, jika Anda tidak menulis langkah, nilainya dipinjam, yang akan saya tulis segera. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-string"><span class="hljs-string">"a"</span></span>.to_string(); <span class="hljs-comment"><span class="hljs-comment">// "a"    let b = 2; let f_1 = move || {println!("{}", a)}; //   "a" //    "a"    . // let f_2 = move || {println!("{}", a)}; f_1(); }</span></span></code> </pre> <br><p>  Anda bisa memindahkan keduanya ke fungsi dan dari fungsi atau ke nilai lain. </p><br><p>  Contoh ini menunjukkan bagaimana melacak cara nilai bergerak untuk hidup damai dengan peminjam. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>(x: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> { x + <span class="hljs-string"><span class="hljs-string">" and x"</span></span> <span class="hljs-comment"><span class="hljs-comment">//    x   +,     . //  +   String,    . } fn main() { let a = "a".to_string(); //  "a" let b = f(a); //  "a"  "f",  f     b. println!("{}", b); // "a"   . }</span></span></code> </pre> <br><h3 id="odalzhivanie">  Pinjaman </h3><br><p>  Kami memperkenalkan konsep baru ini: tidak seperti bergerak, ini berarti bahwa blok saat ini mengendalikan kontrol nilai, itu hanya memungkinkan blok lain untuk menggunakan nilainya. </p><br><p>  Saya perhatikan bahwa pinjaman juga terjadi di mana ia berakhir, yang tidak terlalu penting dalam contoh-contoh ini, tetapi akan muncul di paragraf berikutnya. </p><br><p>  Catatan: Saya tidak akan menulis tentang cara menentukan umur langsung di fungsi, karena karat modern melakukan ini secara otomatis lebih baik daripada di masa lalu, dan pengungkapan semua ini adalah beberapa halaman lagi. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>(x: &amp;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//   &amp;,    . println!("{}", x); // &lt;-  ,  "x"     } fn main() { let a = "a".to_string(); // "a"    f(&amp;a); //   "a"  f //   f(&amp;a); //    -  . println!("{}", a); //   // "a"  . }</span></span></code> </pre> <br><p>  Dengan penutupan yang sama: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> a = <span class="hljs-string"><span class="hljs-string">"a"</span></span>.to_string(); <span class="hljs-comment"><span class="hljs-comment">// "a"    let f_1 = || a.push_str("and x"); //   "a" let f_2 = || a.push_str("and x"); //   f_1(); f_2(); println!("{}", a); // "a"  . }</span></span></code> </pre> <br><p>  Sebenarnya, di sebagian besar konstruksi sederhana ini, pengguna hanya perlu memutuskan di mana ia ingin mengakhiri umur nilai: di akhir blok saat ini dan meminjamkannya ke beberapa fungsi, atau, jika kita tahu bahwa kita tidak lagi membutuhkan nilai, kemudian pindahkan ke fungsi di akhir dengan mana itu sendiri akan dihancurkan, semakin cepat kita membebaskan memori, tetapi nilainya tidak akan lagi tersedia di blok saat ini. </p><br><h3 id="mutabelnost">  Mutabilitas </h3><br><p>  Dalam rasta, seperti, misalnya, di kotlin, ada pembagian ke dalam nilai yang bisa berubah dan tidak stabil.  Tetapi timbul masalah bahwa ketidakstabilan berdampak pada peminjaman: <br>  Anda dapat meminjam nilai yang tidak stabil berkali-kali, dan nilai yang dapat berubah dapat dipinjam satu kali saja.  Anda tidak dapat mengubah nilai yang sudah dipinjam sebelumnya. </p><br><p>  Contoh yang tidak terkait dengan yang sebelumnya, ketika konsep ini menyelamatkan kita dari masalah dengan melarang peminjaman yang simultan dan tidak stabil: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> a = <span class="hljs-string"><span class="hljs-string">"abc"</span></span>.to_string(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a.chars() { <span class="hljs-comment"><span class="hljs-comment">//   a.push_str(" and "); //  .  . a.push(x); } }</span></span></code> </pre> <br><p>  Di sini sudah perlu untuk menyimpan berbagai trik untuk memuaskan, sebagian besar, klaim rasta yang adil.  Pada contoh di atas, yang paling mudah adalah mengkloning "a" -&gt; klon akan memiliki pinjaman yang tidak stabil, dan tidak berhubungan dengan "a" yang asli. </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a.clone().chars() { <span class="hljs-comment"><span class="hljs-comment">//  ,   . a.push_str(" and "); //  .      -   .</span></span></code> </pre> <br><p>  Tapi saya lebih baik kembali ke contoh kita untuk menjaga konsistensi.  Kita perlu mengubah "a" dan kita tidak bisa melakukannya. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> a = <span class="hljs-string"><span class="hljs-string">"a"</span></span>.to_string(); <span class="hljs-comment"><span class="hljs-comment">// "a"    let mut f_1 = || a.push_str(" and x"); //   "a".   - ,  mut  mut. //      ,   f_1  . let mut f_2 = || a.push_str(" and y"); //     : second mutable borrow occurs here f_1(); f_2(); println!("{}", a); }</span></span></code> </pre> <br><h3 id="skrytoe-mutirovanie">  Mutasi tersembunyi </h3><br><p>  Secara teoritis, penutupan dapat diteruskan ke beberapa fungsi yang memproses, misalnya, secara asinkron di utas lainnya, dan kemudian kita benar-benar akan mengalami masalah, tetapi dalam kasus ini, peminjam cek direasuransikan, meskipun ini tidak membatalkan fakta bahwa kita perlu menyetujui dengan suatu cara . </p><br><p>  Intinya: kita membutuhkan dua pinjaman bermutasi, tetapi yang terakhir hanya memungkinkan satu hal, tetapi penemu licik dari rasta datang dengan "mutasi tersembunyi": RefCell. </p><br><p>  RefCell - apa yang kita bungkus dalam RefCell - raster menganggapnya nemable, namun, menggunakan fungsi meminjam_mut () kita dapat mengekstraksi sementara tautan yang dapat diubah untuk sementara waktu yang dapat mengubah nilai, <strong>tetapi ada nuansa penting</strong> : tautan hanya dapat diperoleh ketika RefCell saat runtime memastikan bahwa tidak ada yang lain pinjaman aktif, jika tidak, dia akan panik, atau mengembalikan kesalahan jika try_borrow_mut () digunakan.  Yaitu  di sini pertumbuhan memberikan semua kekhawatiran tentang pemberian pinjaman kepada pengguna, dan dia sendiri harus memastikan bahwa dia tidak meminjam nilai dari beberapa tempat sekaligus. </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::cell::RefCell; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = RefCell::new(<span class="hljs-string"><span class="hljs-string">"a"</span></span>.to_string()); <span class="hljs-comment"><span class="hljs-comment">// "a"    let f_1 = || a.borrow_mut().push_str(" and x"); //    "a" let f_2 = || a.borrow_mut().push_str(" and y"); //    f_1(); //      a.borrow_mut() ,           mut    . f_2(); //   . println!("{}", a.borrow()); //         . }</span></span></code> </pre> <br><h3 id="schyotchik-ssylok-rc">  Penghitung Tautan Rc </h3><br><p>  Konstruksi ini dikenal dalam banyak bahasa, dan digunakan dalam rast, ketika, misalnya, kami tidak dapat meminjam nilai karena suatu alasan, dan ada kebutuhan untuk memiliki beberapa nilai referensi untuk satu nilai tunggal.  Rc, seperti namanya, hanyalah penghitung referensi yang memiliki nilai, Rc dapat meminjam tautan yang tidak dapat diandalkan, menghitung jumlah mereka, dan segera setelah nomornya diatur ulang, Rc akan menghancurkan nilai itu sendiri.  Ternyata Rc memungkinkan, seolah-olah, untuk secara diam-diam memperluas umur dari nilai yang terkandung di dalamnya. </p><br><p>  Saya akan menambahkan bahwa rast dapat secara otomatis melakukan deref untuk struktur yang didefinisikan, yang berarti bahwa untuk bekerja dengan Rc, sebagai aturan, Anda tidak memerlukan ekstraksi tambahan dari nilai internal dan kami hanya bekerja dengan Rc seperti halnya dengan nilai di dalamnya. </p><br><p>  Di sini contoh sederhana dianggap agak sulit, mari kita coba meniru bahwa penutupan dari contoh di atas tidak ingin menerima &amp; T atau &amp; String, tetapi hanya ingin String: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>(x: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//  String,    &amp;String println!("{}", x); } fn main() { let a = "a".to_string(); let f_1 = move || f(a); //   move,    ... let f_2 = move || f(a); // ...     ,           f_1(); f_2(); println!("{}", a); }</span></span></code> </pre> <br><p>  Masalah ini akan mudah dipecahkan jika kita dapat mengubah fungsi menjadi <code>fn f(x: &amp;String)</code> (atau &amp; str), tetapi mari kita bayangkan bahwa karena alasan tertentu kita tidak dapat menggunakan &amp; </p><br><p>  Kami menggunakan Rc </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::rc::Rc; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>(x: Rc&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt;) { <span class="hljs-comment"><span class="hljs-comment">//       Rc println!("{}", x); //     ,  println          ,           ,       ,    . } fn main() { let a_rc = Rc::new("a".to_string()); //  Rc   let a_ref_1 = a.clone(); //   -,  . let a_ref_2 = a.clone(); //   let f_1 = move || f(a_ref_1); //      - let f_2 = move || f(a_ref_2); //  f_1(); f_2(); println!("{}", a_rc); //     Rc  . //    a_rc       . }</span></span></code> </pre> <br><p>  Saya akan menambahkan contoh terakhir, karena salah satu pasangan wadah yang paling sering ditemukan adalah Rc &lt;RefCell&gt; <br></p><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::rc::Rc; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::cell::RefCell; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>(x: Rc&lt;RefCell&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt;&gt;) { x.borrow_mut().push_str(<span class="hljs-string"><span class="hljs-string">" and x"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//      ,       ,   . } fn main() { let a = Rc::new(RefCell::new("a".to_string())); //      let a_ref_1 = a.clone(); let a_ref_2 = a.clone(); let f_1 = move || f(a_ref_1); let f_2 = move || f(a_ref_2); f_1(); f_2(); println!("{}", a.borrow()); // Rc   ,   RefCell   }</span></span></code> </pre> <br><p>  Lebih lanjut, akan logis untuk memindahkan tutorial ini ke analog thread-safe Rc-Arc dan kemudian melanjutkan tentang Mutex, tetapi Anda tidak akan berbicara tentang keamanan thread dan peminjam pinjaman dalam satu paragraf, dan tidak jelas apakah jenis artikel ini diperlukan sama sekali, karena ada utas resmi.  Jadi saya menyimpulkan. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id442962/">https://habr.com/ru/post/id442962/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id442948/index.html">Diberhentikan melalui otomatisasi</a></li>
<li><a href="../id442950/index.html">Ulas Cutra Wonder Cutter</a></li>
<li><a href="../id442952/index.html">Hackathon baru di Tinkoff.ru</a></li>
<li><a href="../id442954/index.html">Menggunakan SQLite in Unity (Unity + SQLite)</a></li>
<li><a href="../id442958/index.html">Nikita Shamgunov memberi tahu The Bell tentang bekerja di Microsoft dan Facebook, berbicara dengan Gates dan database MemSQL</a></li>
<li><a href="../id442964/index.html">Seni parsing atau do-it-yourself DOM</a></li>
<li><a href="../id442966/index.html">Bitcoin untuk Starbucks Coffee Poses Masalah Pengajuan Pajak Signifikan</a></li>
<li><a href="../id442968/index.html">Memperoleh CPE untuk Mendukung Sertifikasi Profesional (Studi Kasus ISACA)</a></li>
<li><a href="../id442970/index.html">Permainan papan untuk mempelajari dasar-dasar sirkuit listrik. Kenapa tidak</a></li>
<li><a href="../id442974/index.html">RUU tentang memerangi informasi palsu disahkan dalam bacaan ketiga</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>