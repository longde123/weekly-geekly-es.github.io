<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ½â€ğŸ’¼ ğŸ‘¨ğŸ¼â€ğŸ³ ğŸ‘ğŸ¿ Sebuah kisah tentang V8, React dan penurunan kinerja. Bagian 2 ğŸ‘‰ğŸ¾ ğŸ¥› ğŸ‘‡ğŸ¿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari ini kami menerbitkan bagian kedua dari terjemahan materi yang ditujukan untuk mekanisme internal V8 dan penyelidikan masalah kinerja Bereaksi. 

...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sebuah kisah tentang V8, React dan penurunan kinerja. Bagian 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/467249/">  Hari ini kami menerbitkan bagian kedua dari terjemahan materi yang ditujukan untuk mekanisme internal V8 dan penyelidikan masalah kinerja Bereaksi. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/de/g6/0r/deg60r8mwme-o8ihiv3mlbuqhmq.jpeg"></a> <br><br>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian pertama</a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Usang dan migrasi bentuk objek</font> </h2><br>  Bagaimana jika bidang awalnya berisi <code>Smi</code> , dan kemudian situasinya berubah dan perlu menyimpan nilai yang representasi <code>Smi</code> tidak cocok?  Misalnya, seperti dalam contoh berikut, ketika dua objek direpresentasikan menggunakan bentuk yang sama dari objek di mana <code>x</code> awalnya disimpan sebagai <code>Smi</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//  `x`       `Smi` bx = 0.2; //  `bx`     `Double` y = ax;</span></span></code> </pre> <br>  Pada awal contoh, kita memiliki dua objek, untuk representasi yang kita gunakan bentuk objek yang sama di mana format <code>Smi</code> digunakan untuk menyimpan <code>x</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a0/02d/43f/7a002d43f6d9e7b6e702173b32256513.png"></div><br>  <i><font color="#999999">Bentuk yang sama digunakan untuk mewakili objek</font></i> <br><br>  Ketika properti <code>bx</code> berubah dan Anda harus menggunakan format <code>Double</code> untuk mewakilinya, V8 mengalokasikan ruang memori untuk bentuk objek yang baru, di mana <code>x</code> ditugaskan representasi <code>Double</code> , dan yang menunjukkan formulir kosong.  V8 juga membuat entitas yang <code>MutableHeapNumber</code> , yang digunakan untuk menyimpan nilai 0,2 dari properti <code>x</code> .  Kemudian kami memperbarui objek <code>b</code> sehingga merujuk ke formulir baru ini dan mengubah slot di objek sehingga <code>MutableHeapNumber</code> pada entitas <code>MutableHeapNumber</code> dibuat sebelumnya pada offset 0. Akhirnya, kami menandai bentuk objek yang lama sebagai usang dan melepaskannya dari pohon transisi.  Ini dilakukan dengan membuat transisi baru untuk <code>'x'</code> dari formulir kosong ke yang baru saja kita buat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7c/8f0/361/e7c8f03616b29cd8c1bea799c6527546.png"></div><br>  <i><font color="#999999">Konsekuensi Penugasan Nilai Baru ke Properti Obyek</font></i> <br><br>  Saat ini, kami tidak dapat sepenuhnya menghapus formulir lama, karena masih digunakan oleh objek <code>a</code> .  Selain itu, akan sangat mahal untuk memotong semua memori dalam mencari semua objek yang merujuk ke bentuk lama, dan segera memperbarui keadaan objek-objek ini.  Sebaliknya, V8 menggunakan pendekatan "malas" di sini.  Yaitu, semua operasi membaca atau menulis properti objek <code>a</code> pertama kali ditransfer ke penggunaan bentuk baru.  Gagasan di balik tindakan ini adalah untuk akhirnya membuat bentuk objek yang usang menjadi tidak dapat dicapai.  Ini akan menyebabkan pengumpul sampah menanganinya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/656/bfa/7a3/656bfa7a3138ace8f68a09553b718af6.png"></div><br>  <i><font color="#999999">Memori out-of-form membebaskan pengumpul sampah</font></i> <br><br>  Hal-hal yang lebih rumit dalam situasi di mana bidang yang mengubah tampilan bukanlah yang terakhir dalam rantai: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> o = {  <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>,  <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>,  <span class="hljs-attr"><span class="hljs-attr">z</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, }; oy = <span class="hljs-number"><span class="hljs-number">0.1</span></span>;</code> </pre> <br>  Dalam hal ini, V8 perlu menemukan apa yang disebut bentuk split.  Ini adalah bentuk terakhir dalam rantai, yang terletak sebelum formulir di mana properti terkait muncul.  Di sini kita mengubah <code>y</code> , yaitu - kita perlu menemukan bentuk terakhir di mana tidak ada <code>y</code> .  Dalam contoh kita, ini adalah bentuk di mana <code>x</code> muncul. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/042/210/2e3/0422102e38310aa94fecc13f38048222.png"></div><br>  <i><font color="#999999">Cari formulir terakhir di mana tidak ada nilai yang berubah</font></i> <br><br>  Di sini, dimulai dengan formulir ini, kami membuat rantai transisi baru untuk <code>y</code> yang mereproduksi semua transisi sebelumnya.  Hanya sekarang properti <code>'y'</code> akan direpresentasikan sebagai <code>Double</code> .  Sekarang kita menggunakan rantai transisi baru ini untuk <code>y</code> , menandainya sebagai subtree lama yang sudah usang.  Pada langkah terakhir, kami memigrasikan instance objek <code>o</code> ke bentuk baru, sekarang menggunakan entitas <code>MutableHeapNumber</code> untuk menyimpan nilai <code>y</code> .  Dengan pendekatan ini, objek baru tidak akan menggunakan fragmen dari pohon transisi lama dan, setelah semua referensi ke bentuk lama telah hilang, bagian pohon yang usang juga akan menghilang. <br><br><h2>  <font color="#3AC1EF">Ekstensibilitas dan Integritas Transisi</font> </h2><br>  Perintah <code>Object.preventExtensions()</code> memungkinkan Anda untuk sepenuhnya mencegah penambahan properti baru ke objek.  Jika Anda memproses objek dengan perintah ini dan mencoba menambahkan properti baru ke dalamnya, pengecualian akan dibuang.  (Benar, jika kode tidak dieksekusi dalam mode ketat, pengecualian tidak akan dibuang, namun, upaya untuk menambahkan properti tidak akan menimbulkan konsekuensi apa pun).  Berikut ini sebuah contoh: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.preventExtensions(object); object.y = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">// TypeError: Cannot add property y; //      object is not extensible</span></span></code> </pre> <br>  Metode <code>Object.seal()</code> bertindak pada objek dengan cara yang sama seperti <code>Object.preventExtensions()</code> , tetapi juga menandai semua properti sebagai tidak dapat dikonfigurasi.  Ini berarti bahwa mereka tidak dapat dihapus, atau sifat mereka tidak dapat diubah mengenai kemungkinan daftar, pengaturan atau penulisan ulang mereka. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.seal(object); object.y = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">// TypeError: Cannot add property y; //      object is not extensible delete object.x; // TypeError: Cannot delete property x</span></span></code> </pre> <br>  Metode <code>Object.freeze()</code> melakukan tindakan yang sama seperti <code>Object.seal()</code> , tetapi penggunaannya, selain itu, mengarah pada fakta bahwa nilai-nilai properti yang ada tidak dapat diubah.  Mereka ditandai sebagai properti di mana nilai-nilai baru tidak dapat ditulis. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.freeze(object); object.y = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">// TypeError: Cannot add property y; //      object is not extensible delete object.x; // TypeError: Cannot delete property x object.x = 3; // TypeError: Cannot assign to read-only property x</span></span></code> </pre> <br>  Pertimbangkan contoh spesifik.  Kami memiliki dua objek, yang masing-masing memiliki nilai unik <code>x</code> .  Kemudian kami melarang ekstensi objek kedua: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.preventExtensions(b);</code> </pre> <br>  Pemrosesan kode ini dimulai dengan tindakan yang sudah kita ketahui.  Yaitu, transisi dibuat dari bentuk kosong objek ke bentuk baru, yang berisi properti <code>'x'</code> (diwakili sebagai entitas <code>Smi</code> ).  Ketika kita melarang ekspansi objek <code>b</code> , ini mengarah ke transisi khusus ke bentuk baru, yang ditandai sebagai tidak dapat diperluas.  Transisi khusus ini tidak mengarah pada penampilan beberapa properti baru.  Ini sebenarnya hanya penanda. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/958/2f4/94a/9582f494ae02d57ddc0c17db4749f767.png"></div><br>  <i><font color="#999999">Hasil dari pemrosesan objek menggunakan metode Object.preventExtensions ()</font></i> <br><br>  Harap dicatat bahwa kami tidak dapat hanya mengubah formulir yang ada dengan nilai <code>x</code> di dalamnya, karena diperlukan oleh objek lain, yaitu objek <code>a</code> , yang masih dapat dikembangkan. <br><br><h2>  <font color="#3AC1EF">Bereaksi masalah kinerja</font> </h2><br>  Sekarang mari kita kumpulkan semua yang kita bicarakan dan gunakan pengetahuan yang telah kita peroleh untuk memahami esensi dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">masalah</a> kinerja Bereaksi baru-baru ini.  Ketika tim Bereaksi membuat profil aplikasi nyata, mereka melihat penurunan kinerja V8 aneh yang bertindak pada inti Bereaksi.  Berikut adalah reproduksi bagian masalah yang disederhanakan dari kode: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> o = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.preventExtensions(o); oy = <span class="hljs-number"><span class="hljs-number">0.2</span></span>;</code> </pre> <br>  Kami memiliki objek dengan dua bidang yang direpresentasikan sebagai entitas <code>Smi</code> .  Kami mencegah perluasan objek lebih lanjut, dan kemudian melakukan tindakan yang mengarah pada fakta bahwa bidang kedua harus diwakili dalam format <code>Double</code> . <br><br>  Kami telah menemukan bahwa larangan ekspansi objek mengarah ke situasi berikut. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf7/d6e/3b8/bf7d6e3b8783a06c2923e76aa830f64b.png"></div><br>  <i><font color="#999999">Konsekuensi dari larangan ekspansi objek</font></i> <br><br>  Untuk mewakili kedua properti objek, entitas <code>Smi</code> , dan transisi terakhir diperlukan untuk menandai bentuk objek sebagai non-extensible. <br><br>  Sekarang kita perlu mengubah cara properti <code>y</code> diwakili oleh <code>Double</code> .  Ini berarti bahwa kita perlu mulai mencari bentuk pemisahan.  Dalam hal ini, ini adalah bentuk di mana properti <code>x</code> muncul.  Tapi sekarang V8 bingung.  Faktanya adalah bahwa bentuk pemisahan dapat diperpanjang, dan bentuk saat ini ditandai sebagai tidak dapat diperpanjang.  V8 tidak tahu bagaimana mereproduksi proses transisi dalam situasi yang sama.  Akibatnya, mesin menolak untuk mencoba mencari tahu semuanya.  Sebagai gantinya, itu hanya membuat formulir terpisah yang tidak terhubung ke pohon formulir saat ini dan tidak dibagikan dengan objek lain.  Ini adalah sesuatu seperti bentuk objek yatim. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/abc/581/82d/abc58182dd6e657649af6e934aef04f7.png"></div><br>  <i><font color="#999999">Bentuk yatim</font></i> <br><br>  Mudah ditebak bahwa ini, jika ini terjadi pada banyak objek, sangat buruk.  Faktanya adalah bahwa ini membuat seluruh sistem objek V8 tidak berguna. <br><br>  Ketika masalah Bereaksi terjadi, berikut ini terjadi.  Setiap objek dari kelas <code>FiberNode</code> memiliki bidang yang dimaksudkan untuk menyimpan stempel waktu saat pembuatan profil diaktifkan. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FiberNode</span></span></span><span class="hljs-class"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actualStartTime = <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.preventExtensions(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);  } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> node1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FiberNode(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> node2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FiberNode();</code> </pre> <br>  Bidang-bidang ini (misalnya, <code>actualStartTime</code> ) diinisialisasi ke 0 atau -1.  Hal ini menyebabkan fakta bahwa entitas <code>Smi</code> digunakan untuk mewakili maknanya secara <code>Smi</code> .  Namun kemudian, mereka menyimpan prangko waktu nyata dalam format angka floating-point yang dikembalikan oleh metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">performance.now ().</a>  Ini mengarah pada fakta bahwa nilai-nilai ini tidak lagi dapat diwakili dalam bentuk <code>Smi</code> .  Untuk mewakili bidang ini, Entitas <code>Double</code> sekarang diperlukan.  Di atas semua ini, Bereaksi juga mencegah perluasan instance dari kelas <code>FiberNode</code> . <br><br>  Awalnya, contoh sederhana kami dapat disajikan dalam bentuk berikut. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7db/972/e7f/7db972e7fc38fe7ffe228a765a401509.png"></div><br>  <i><font color="#999999">Keadaan awal sistem</font></i> <br><br>  Ada dua contoh kelas yang berbagi pohon transisi yang sama dari bentuk objek.  Sebenarnya, ini adalah tujuan dari sistem bentuk objek di V8.  Tetapi kemudian, ketika perangko waktu nyata disimpan dalam objek, V8 tidak dapat memahami bagaimana perangko dapat menemukan bentuk pemisahan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b6/443/bc9/6b6443bc9ea1c84dcc88ed9b6e9a0a03.png"></div><br>  <i><font color="#999999">V8 bingung</font></i> <br><br>  V8 memberikan formulir yatim baru ke <code>node1</code> .  Hal yang sama terjadi sedikit kemudian dengan objek <code>node2</code> .  Sebagai hasilnya, kami sekarang memiliki dua bentuk "yatim", yang masing-masing digunakan hanya oleh satu objek.  Dalam banyak aplikasi Bereaksi nyata, jumlah objek tersebut jauh lebih dari dua.  Ini bisa berupa puluhan atau bahkan ribuan objek dari kelas <code>FiberNode</code> .  Sangat mudah untuk memahami bahwa situasi ini tidak mempengaruhi kinerja V8 dengan sangat baik. <br><br>  Untungnya, kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memperbaiki</a> masalah ini di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V8 v7.4</a> , dan kami sedang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menjajaki</a> kemungkinan membuat operasi mengubah representasi bidang objek kurang intensif sumber daya.  Ini akan memungkinkan kami untuk menyelesaikan masalah kinerja yang tersisa yang muncul dalam situasi seperti itu.  V8, berkat perbaikannya, sekarang berperilaku dengan benar dalam situasi masalah yang dijelaskan di atas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/23e/556/574/23e556574e5e5b2a462adc3e983d8f37.png"></div><br>  <i><font color="#999999">Keadaan awal sistem</font></i> <br><br>  Ini tampilannya.  Dua contoh referensi kelas <code>FiberNode</code> bentuk non-extensible.  Dalam hal ini, <code>'actualStartTime'</code> direpresentasikan sebagai bidang <code>Smi</code> .  Ketika operasi pertama memberikan nilai ke properti <code>node1.actualStartTime</code> , rantai transisi baru dibuat, dan rantai sebelumnya ditandai sebagai usang. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/81b/34f/c12/81b34fc121c16ff52582f33cd01e1389.png"></div><br>  <i><font color="#999999">Hasil Menetapkan Nilai Baru ke Properti Node1.actualStartTime</font></i> <br><br>  Harap dicatat bahwa transisi ke formulir yang tidak dapat diperluas sekarang direproduksi dengan benar di rantai baru.  Inilah yang masuk ke sistem setelah mengubah nilai <code>node2.actualStartTime</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/834/dbf/25c/834dbf25c0436caa37a871d3b985dc5a.png"></div><br>  <i><font color="#999999">Hasil menetapkan nilai baru ke properti node2.actualStartTime</font></i> <br><br>  Setelah nilai baru ditetapkan ke properti <code>node2.actualStartTime</code> , kedua objek merujuk ke formulir baru, dan bagian usang dari pohon transisi dapat dihancurkan oleh pengumpul sampah. <br><br>  Harap perhatikan bahwa operasi untuk menandai bentuk objek sebagai usang dan migrasi mereka mungkin terlihat seperti sesuatu yang rumit.  Bahkan - apa adanya.  Kami menduga bahwa di situs web asli ini tidak lebih berbahaya (dalam hal kinerja, penggunaan memori, kompleksitas) daripada yang baik.  Terutama - setelah, dalam kasus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kompresi pointer</a> , kita tidak bisa lagi menggunakan pendekatan ini untuk menyimpan bidang <code>Double</code> dalam bentuk nilai yang tertanam dalam objek.  Sebagai hasilnya, kami berharap untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sepenuhnya meninggalkan</a> mekanisme usang bentuk objek V8 dan membuat mekanisme ini sendiri menjadi usang. <br><br>  Perlu dicatat bahwa tim Bereaksi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memecahkan</a> masalah ini sendiri, memastikan bahwa bidang dalam objek kelas <code>FiberNodes</code> awalnya diwakili oleh nilai ganda: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FiberNode</span></span></span><span class="hljs-class"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() {    <span class="hljs-comment"><span class="hljs-comment">//     `Double`   .    this.actualStartTime = Number.NaN;    //       ,  :    this.actualStartTime = 0;    Object.preventExtensions(this);  } } const node1 = new FiberNode(); const node2 = new FiberNode();</span></span></code> </pre> <br>  Di sini, alih-alih <code>Number.NaN</code> , nilai floating-point apa pun yang tidak cocok dengan rentang <code>Smi</code> dapat digunakan.  Di antara nilai-nilai ini adalah <code>Number.MIN_VALUE</code> , <code>Number.MIN_VALUE</code> , -0 dan <code>Infinity</code> . <br><br>  Perlu dicatat bahwa masalah yang dijelaskan dalam Bereaksi khusus untuk V8, dan bahwa ketika membuat beberapa kode, pengembang tidak perlu berusaha untuk mengoptimalkannya berdasarkan versi spesifik dari mesin JavaScript tertentu.  Namun, berguna untuk dapat memperbaiki sesuatu dengan mengoptimalkan kode jika penyebab beberapa kesalahan berakar pada fitur-fitur mesin. <br><br>  Perlu diingat bahwa di perut mesin-JS ada banyak hal menakjubkan.  Pengembang JS dapat membantu semua mekanisme ini, jika mungkin tanpa menetapkan nilai variabel yang sama dari jenis yang berbeda.  Misalnya, Anda tidak boleh menginisialisasi bidang numerik ke <code>null</code> , karena ini akan meniadakan semua keuntungan dari mengamati representasi bidang dan meningkatkan keterbacaan kode: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   ! class Point {  x = null;  y = null; } const p = new Point(); px = 0.1; py = 402;</span></span></code> </pre> <br>  Dengan kata lain - tulis kode yang dapat dibaca, dan kinerja akan datang dengan sendirinya! <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Dalam artikel ini, kami memeriksa masalah-masalah penting berikut: <br><br><ul><li>  JavaScript membedakan antara nilai "primitif" dan "objek", dan hasil <code>typeof</code> tidak dapat dipercaya. </li><li>  Nilai-nilai genap yang memiliki tipe JavaScript yang sama dapat direpresentasikan dengan berbagai cara di perut mesin. </li><li>  V8 berusaha menemukan cara terbaik untuk mewakili setiap properti objek yang digunakan dalam program JS. </li><li>  Dalam situasi tertentu, V8 melakukan operasi pada menandai bentuk objek sebagai usang dan melakukan migrasi bentuk.  Termasuk - mengimplementasikan transisi yang terkait dengan larangan ekspansi objek. </li></ul><br>  Berdasarkan hal tersebut di atas, kami dapat memberikan beberapa tips pemrograman JavaScript praktis yang dapat membantu meningkatkan kinerja kode: <br><br><ul><li>  Selalu inisialisasi objek Anda dengan cara yang sama.  Ini berkontribusi pada kerja efektif dengan bentuk-bentuk objek. </li><li>  Pilih nilai awal untuk bidang objek secara bertanggung jawab.  Ini akan membantu mesin JavaScript dalam memilih cara mewakili nilai-nilai ini secara internal. </li></ul><br>  <b>Pembaca yang budiman!</b>  Apakah Anda pernah mengoptimalkan kode Anda berdasarkan fitur internal mesin JavaScript tertentu? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/it/t5/3p/itt53pns2iucwylb3bwn1fmmtnu.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id467249/">https://habr.com/ru/post/id467249/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id467237/index.html">Naikkan server DNS-over-HTTPS Anda</a></li>
<li><a href="../id467239/index.html">Perbedaan antara Data Scientist dan seorang remaja dalam mobil sport</a></li>
<li><a href="../id467241/index.html">Troli truk ROS. Bagian 4. Membuat simulasi robot menggunakan editor rviz dan gazebo</a></li>
<li><a href="../id467245/index.html">Dmitry Matskevich, Dbrain: tentang kewirausahaan sebagai cacat mental, AI, dan keamanan emosional</a></li>
<li><a href="../id467247/index.html">Sebuah kisah tentang V8, React dan penurunan kinerja. Bagian 1</a></li>
<li><a href="../id467251/index.html">Sandera COBOL dan Matematika. Bagian 1</a></li>
<li><a href="../id467253/index.html">Sandera COBOL dan Matematika. Bagian 2</a></li>
<li><a href="../id467255/index.html">Tiga Kesalahan Umum tentang Keamanan Yang Harus Diketahui Setiap Pengembang Tentang</a></li>
<li><a href="../id467257/index.html">Jangan menyimpan semua telur Anda dalam satu keranjang sekaligus</a></li>
<li><a href="../id467259/index.html">DPI (inspeksi SSL) bertentangan dengan makna kriptografi, tetapi perusahaan menerapkannya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>