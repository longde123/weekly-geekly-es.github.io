<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚ÄçüöÄ üë©üèø‚Äç‚öïÔ∏è üì¶ Machine Learning: previs√£o de pre√ßos de a√ß√µes no mercado de a√ß√µes üë©‚Äçüè´ üìè üôéüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A tradutora Polina Kabirova, especificamente para Netologia, adaptou um artigo do engenheiro da Universidade de Cambridge Vivek Palaniappan sobre como...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Machine Learning: previs√£o de pre√ßos de a√ß√µes no mercado de a√ß√µes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/netologyru/blog/428227/">  <i>A tradutora Polina Kabirova, especificamente para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Netologia,</a> adaptou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um artigo</a> do engenheiro da Universidade de Cambridge Vivek Palaniappan sobre como criar um modelo usando redes neurais que podem prever os pre√ßos das a√ß√µes em uma bolsa de valores.</i> <br><br>  O aprendizado autom√°tico e profundo tornou-se uma nova estrat√©gia eficaz que muitos fundos de investimento usam para aumentar a renda.  No artigo, explicarei como as redes neurais ajudam a prever a situa√ß√£o no mercado de a√ß√µes - por exemplo, o pre√ßo das a√ß√µes (ou o √≠ndice).  O texto √© baseado no meu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">projeto</a> escrito em Python.  O c√≥digo completo e o guia do programa podem ser encontrados no GitHub.  Leia outros artigos relacionados no Blog <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">M√©dio</a> . <br><a name="habracut"></a><br><h2>  Redes neurais em economia </h2><br>  As mudan√ßas no campo das finan√ßas n√£o s√£o lineares e, √†s vezes, pode parecer que os pre√ßos das a√ß√µes s√£o formados de maneira completamente aleat√≥ria.  Os m√©todos tradicionais de s√©ries temporais, como os modelos ARIMA e GARCH, s√£o eficazes quando a s√©rie √© estacion√°ria - suas propriedades b√°sicas n√£o mudam ao longo do tempo.  E isso requer que a s√©rie tenha sido pr√©-processada usando <code>log returns</code> ou levada √† estacionariedade de maneira diferente.  No entanto, o principal problema surge quando esses modelos s√£o implementados em um sistema de negocia√ß√£o real, pois a estacionariedade n√£o √© garantida ao adicionar novos dados. <br><br>  A solu√ß√£o para esse problema pode ser redes neurais que n√£o requerem estacionariedade.  As redes neurais s√£o inicialmente muito eficazes para encontrar relacionamentos entre os dados e s√£o capazes de prever (ou classificar) novos dados com base neles. <br><br>  Normalmente, um projeto de ci√™ncia de dados consiste nas seguintes opera√ß√µes: <br><br><ol><li>  Coleta de dados - fornece um conjunto de propriedades necess√°rias. </li><li>  O pr√©-processamento de dados geralmente √© uma etapa assustadora, mas necess√°ria, antes de usar os dados. </li><li>  O desenvolvimento e implementa√ß√£o do modelo √© a escolha do tipo de rede neural e seus par√¢metros. </li><li>  Modelos de backtesting (teste de dados hist√≥ricos) s√£o uma etapa fundamental em qualquer estrat√©gia de negocia√ß√£o. </li><li>  Otimiza√ß√£o - procure por par√¢metros adequados. </li></ol><br>  Entrada para nossa rede neural - dados sobre pre√ßos de a√ß√µes nos √∫ltimos 10 dias.  Com a ajuda deles, preveremos os pre√ßos no dia seguinte. <br><br><h2>  Coleta de dados </h2><br>  Felizmente, os dados necess√°rios para este projeto podem ser encontrados no Yahoo Finance.  Os dados podem ser coletados usando a API Python <code>pdr.get_yahoo_data(ticker, start_date, end_date)</code> ou diretamente do site. <br><br><h2>  Pr√©-processamento de dados </h2><br>  No nosso caso, os dados precisam ser divididos em conjuntos de treinamento que consistem em 10 pre√ßos anteriores e no dia seguinte.  Para isso, defini a classe <code>Preprocessing</code> - <code>Preprocessing</code> , que funcionar√° com os dados de treinamento e teste.  Dentro da classe, eu defini o <code>get_train(self, seq_len)</code> , que converte dados de entrada e sa√≠da de treinamento em matrizes <code>NumPy</code> , definindo um comprimento de janela espec√≠fico (no nosso caso 10).  O c√≥digo inteiro fica assim: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gen_train</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, seq_len)</span></span></span><span class="hljs-function">:</span></span>  <span class="hljs-string"><span class="hljs-string">"""  Generates training data  :param seq_len: length of window  :return: X_train and Y_train  """</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range((len(self.stock_train)//seq_len)*seq_len - seq_len - <span class="hljs-number"><span class="hljs-number">1</span></span>):      x = np.array(self.stock_train.iloc[i: i + seq_len, <span class="hljs-number"><span class="hljs-number">1</span></span>])      y = np.array([self.stock_train.iloc[i + seq_len + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>]], np.float64)      self.input_train.append(x)      self.output_train.append(y)  self.X_train = np.array(self.input_train)  self.Y_train = np.array(self.output_train)</code> </pre> <br>  Da mesma forma, eu defini um m√©todo que converte os dados de teste <code>X_test</code> e <code>Y_test</code> . <br><br><h2>  Modelos de redes neurais </h2><br>  Para o projeto, usei dois modelos de redes neurais: o Multilayer Perceptron (MLP) e o Long Short Term Model (LSTM).  Vou falar brevemente sobre como esses modelos funcionam.  Leia mais sobre MLP em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">outro artigo</a> e sobre o trabalho de LSTM em Jacob Aungiers. <br><br>  MLP √© a forma mais simples de redes neurais.  Os dados de entrada caem no modelo e, usando determinados pesos, os valores s√£o transmitidos atrav√©s de camadas ocultas para obter dados de sa√≠da.  Aprender o algoritmo vem da propaga√ß√£o de volta atrav√©s de camadas ocultas para alterar os valores de peso de cada neur√¥nio.  O problema com este modelo √© a falta de "mem√≥ria".  √â imposs√≠vel determinar quais eram os dados anteriores e como eles podem e devem afetar os novos.  No contexto do nosso modelo, diferen√ßas de 10 dias entre os dados de dois conjuntos de dados podem ser importantes, mas os MLPs n√£o conseguem analisar esses relacionamentos. <br><br>  Para fazer isso, use LSTM ou Redes Neurais Recorrentes (RNN).  As RNNs armazenam certas informa√ß√µes de dados para uso posterior; isso ajuda a rede neural a analisar a estrutura complexa das rela√ß√µes entre os dados do pre√ßo das a√ß√µes.  Mas com a RNN, surge o problema de um gradiente de desbotamento.  O gradiente diminui porque o n√∫mero de camadas aumenta e o n√≠vel de treinamento (um valor menor que a unidade) √© multiplicado v√°rias vezes.  Resolva esse problema de LSTM aumentando a efici√™ncia. <br><br><h2>  Implementa√ß√£o do modelo </h2><br>  Para implementar o modelo, usei o <code>Keras</code> , porque as camadas s√£o adicionadas gradualmente e n√£o definem toda a rede de uma s√≥ vez.  Assim, podemos mudar rapidamente o n√∫mero e o tipo de camadas, otimizando a rede neural. <br><br>  Um passo importante no trabalho com os pre√ßos das a√ß√µes √© a normaliza√ß√£o dos dados.  Geralmente, para isso, voc√™ subtrai o erro m√©dio e divide pelo erro padr√£o.  Mas precisamos que esse sistema seja usado em negocia√ß√µes reais por um determinado per√≠odo de tempo.  Portanto, o uso de estat√≠sticas pode n√£o ser a maneira mais precisa de normalizar os dados.  Ent√£o, acabei de dividir todos os dados em 200 (um n√∫mero arbitr√°rio comparado ao qual todos os outros n√∫meros s√£o pequenos).  E embora pare√ßa que essa normaliza√ß√£o n√£o seja justificada e n√£o fa√ßa sentido, √© eficaz garantir que os pesos na rede neural n√£o sejam muito grandes. <br><br>  Vamos come√ßar com um modelo mais simples - MLP.  Keras constr√≥i uma sequ√™ncia e adiciona camadas densas sobre ela.  O c√≥digo completo fica assim: <br><br><pre> <code class="python hljs">model = tf.keras.models.Sequential() model.add(tf.keras.layers.Dense(<span class="hljs-number"><span class="hljs-number">100</span></span>, activation=tf.nn.relu)) model.add(tf.keras.layers.Dense(<span class="hljs-number"><span class="hljs-number">100</span></span>, activation=tf.nn.relu)) model.add(tf.keras.layers.Dense(<span class="hljs-number"><span class="hljs-number">1</span></span>, activation=tf.nn.relu)) model.compile(optimizer=<span class="hljs-string"><span class="hljs-string">"adam"</span></span>, loss=<span class="hljs-string"><span class="hljs-string">"mean_squared_error"</span></span>)</code> </pre> <br>  Usando Keras em cinco linhas de c√≥digo, criamos MLP com camadas ocultas, cem neur√¥nios em cada uma.  E agora um pouco sobre o otimizador.  O m√©todo Adam (estimativa do momento adaptativo) est√° ganhando popularidade - um algoritmo de otimiza√ß√£o mais eficiente em compara√ß√£o com a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">descida do gradiente estoc√°stico</a> .  Existem duas outras extens√µes de descida de gradiente estoc√°stico - as vantagens de Adam s√£o imediatamente vis√≠veis no contexto: <br><br>  <b>AdaGrad</b> - mant√©m uma velocidade de aprendizado definida, que melhora os resultados quando os gradientes divergem (por exemplo, com problemas de linguagem natural e vis√£o computacional). <br><br>  <b>RMSProp</b> - mant√©m uma velocidade de treinamento definida, que pode variar dependendo dos valores m√©dios dos gradientes recentes de peso (por exemplo, a rapidez com que ele muda).  Isso significa que o algoritmo lida bem com problemas n√£o estacion√°rios (por exemplo, ru√≠do). <br><br>  O Adam combina os benef√≠cios dessas extens√µes, ent√£o eu o escolhi. <br><br>  Agora, ajustamos o modelo aos nossos dados de treinamento.  Keras simplifica a tarefa novamente, apenas o seguinte c√≥digo √© necess√°rio: <br><br><pre> <code class="python hljs">model.fit(X_train, Y_train, epochs=<span class="hljs-number"><span class="hljs-number">100</span></span>)</code> </pre> <br>  Quando o modelo estiver pronto, voc√™ precisar√° verific√°-lo nos dados de teste para determinar como ele funcionou.  Isso √© feito assim: <br><br><pre> <code class="python hljs">model.evaluate(X_test, Y_test)</code> </pre> <br>  As informa√ß√µes obtidas na verifica√ß√£o podem ser usadas para avaliar a capacidade do modelo de prever os pre√ßos das a√ß√µes. <br><br>  Um procedimento semelhante √© usado para o modelo LSTM, ent√£o mostrarei o c√≥digo e o explicarei um pouco: <br><br><pre> <code class="python hljs">model = tf.keras.Sequential() model.add(tf.keras.layers.LSTM(<span class="hljs-number"><span class="hljs-number">20</span></span>, input_shape=(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), return_sequences=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)) model.add(tf.keras.layers.LSTM(<span class="hljs-number"><span class="hljs-number">20</span></span>)) model.add(tf.keras.layers.Dense(<span class="hljs-number"><span class="hljs-number">1</span></span>, activation=tf.nn.relu)) model.compile(optimizer=<span class="hljs-string"><span class="hljs-string">"adam"</span></span>, loss=<span class="hljs-string"><span class="hljs-string">"mean_squared_error"</span></span>) model.fit(X_train, Y_train, epochs=<span class="hljs-number"><span class="hljs-number">50</span></span>) model.evaluate(X_test, Y_test)</code> </pre> <br>  Observe que o Keras precisa de dados de um determinado tamanho, dependendo do seu modelo.  √â muito importante alterar a forma da matriz usando o NumPy. <br><br><h2>  Modelos de backtesting </h2><br>  Quando preparamos nossos modelos usando dados de treinamento e os testamos em dados de teste, podemos testar o modelo em dados hist√≥ricos.  Isso √© feito da seguinte maneira: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">back_test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(strategy, seq_len, ticker, start_date, end_date, dim)</span></span></span><span class="hljs-function">:</span></span>  <span class="hljs-string"><span class="hljs-string">"""  A simple back test for a given date period  :param strategy: the chosen strategy. Note to have already formed the model, and fitted with training data.  :param seq_len: length of the days used for prediction  :param ticker: company ticker  :param start_date: starting date  :type start_date: "YYYY-mm-dd"  :param end_date: ending date  :type end_date: "YYYY-mm-dd"  :param dim: dimension required for strategy: 3dim for LSTM and 2dim for MLP  :type dim: tuple  :return: Percentage errors array that gives the errors for every test in the given date range  """</span></span>  data = pdr.get_data_yahoo(ticker, start_date, end_date)  stock_data = data[<span class="hljs-string"><span class="hljs-string">"Adj Close"</span></span>]  errors = []  <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range((len(stock_data)//<span class="hljs-number"><span class="hljs-number">10</span></span>)*<span class="hljs-number"><span class="hljs-number">10</span></span> - seq_len - <span class="hljs-number"><span class="hljs-number">1</span></span>):      x = np.array(stock_data.iloc[i: i + seq_len, <span class="hljs-number"><span class="hljs-number">1</span></span>]).reshape(dim) / <span class="hljs-number"><span class="hljs-number">200</span></span>      y = np.array(stock_data.iloc[i + seq_len + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>]) / <span class="hljs-number"><span class="hljs-number">200</span></span>      predict = strategy.predict(x)      <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> predict == <span class="hljs-number"><span class="hljs-number">0</span></span>:          predict = strategy.predict(x)      error = (predict - y) / <span class="hljs-number"><span class="hljs-number">100</span></span>      errors.append(error)      total_error = np.array(errors)  print(<span class="hljs-string"><span class="hljs-string">f"Average error = </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{total_error.mean()}</span></span></span><span class="hljs-string">"</span></span>)</code> </pre> <br>  No entanto, esta √© uma vers√£o simplificada do teste.  Para um sistema completo de backtesting, fatores como ‚Äúvi√©s de sobreviv√™ncia‚Äù, vi√©s (vi√©s do futuro), mudan√ßas nas condi√ß√µes de mercado e custos de transa√ß√£o devem ser considerados.  Como este √© apenas um projeto educacional, basta fazer um backtest simples. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qw/_9/hy/qw_9hyxncpkhgxv_rvsxxtxrhlk.png"></div><br>  <i>Previs√£o do meu modelo LSTM para os pre√ßos das a√ß√µes da Apple em fevereiro</i> <br><br>  Para um modelo LSTM simples sem otimiza√ß√£o, este √© um resultado muito bom.  Isso mostra que redes neurais e modelos de aprendizado de m√°quina s√£o capazes de criar conex√µes complexas e est√°veis ‚Äã‚Äãentre par√¢metros. <br><br><h2>  Otimiza√ß√£o de hiperpar√¢metros </h2><br>  Muitas vezes, √© necess√°ria otimiza√ß√£o para melhorar os resultados do modelo ap√≥s o teste.  N√£o o inclu√≠ na vers√£o de c√≥digo aberto para que os leitores possam tentar otimizar o modelo.  Quem n√£o souber otimizar ter√° que encontrar hiperpar√¢metros que melhorar√£o o desempenho do modelo.  Existem v√°rios m√©todos para encontrar hiperpar√¢metros: da sele√ß√£o de par√¢metros em uma grade aos m√©todos estoc√°sticos. <br><br>  Estou certo de que, com a otimiza√ß√£o dos modelos, o conhecimento no campo do aprendizado de m√°quina passa para um novo n√≠vel.  Tente otimizar o modelo para que ele funcione melhor que o meu.  Compare o resultado com o gr√°fico acima. <br><br><h2>  Conclus√£o </h2><br>  O aprendizado de m√°quina est√° em constante evolu√ß√£o - novos m√©todos est√£o surgindo todos os dias, por isso √© muito importante aprender constantemente.  A melhor maneira de fazer isso √© criar projetos interessantes, por exemplo, criar modelos para prever os pre√ßos das a√ß√µes.  E embora meu modelo LSTM n√£o seja bom o suficiente para uso em negocia√ß√µes reais, a base lan√ßada no desenvolvimento de um modelo desse tipo pode ajudar no futuro. <br><br><h2>  Dos editores </h2><br>  Cursos de netologia sobre o tema: <br><br><ul><li>  Profiss√£o Online de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Analista de Dados</a> </li><li>  profiss√£o online <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Data Scientist</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt428227/">https://habr.com/ru/post/pt428227/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt428217/index.html">Milh√µes de v√≠deo chamadas por dia ou "Ligue para a m√£e!"</a></li>
<li><a href="../pt428219/index.html">De onde veio a pr√°tica de realoca√ß√£o em massa de pessoal qualificado?</a></li>
<li><a href="../pt428221/index.html">Gera√ß√£o AI de rostos realistas</a></li>
<li><a href="../pt428223/index.html">Cidades e seus Big Data</a></li>
<li><a href="../pt428225/index.html">Como fazer an√°lises da Web para SaaS por meio do Google Analytics: introdu√ß√£o e rastreamento de um funil</a></li>
<li><a href="../pt428229/index.html">Como Lisp se tornou uma linguagem de programa√ß√£o para Deus</a></li>
<li><a href="../pt428231/index.html">Bonito e limpo: ferramentas que ajudam a obter um c√≥digo quase perfeito</a></li>
<li><a href="../pt428233/index.html">Cinco raz√µes para amar as partes regionais de TI</a></li>
<li><a href="../pt428235/index.html">Por que eles me ligaram da NSA no meio da noite e pediram a fonte</a></li>
<li><a href="../pt428237/index.html">Scrum-mitap com jogo de tabuleiro: convide para o Scrum Values ‚Äã‚ÄãGame</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>