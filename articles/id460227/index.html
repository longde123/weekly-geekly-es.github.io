<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕶️ 🧤 🙍🏿 Alat refactoring khusus: Swift 🚐 🌔 👨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Setiap insinyur berusaha membuat proses kerjanya seoptimal mungkin. Sebagai pengembang iOS seluler, kami sangat sering harus bekerja dengan struktur b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Alat refactoring khusus: Swift</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sberbank/blog/460227/"> Setiap insinyur berusaha membuat proses kerjanya seoptimal mungkin.  Sebagai pengembang iOS seluler, kami sangat sering harus bekerja dengan struktur bahasa yang seragam.  Apple sedang meningkatkan alat pengembang dengan melakukan banyak upaya agar nyaman bagi kita untuk memprogram: penyorotan bahasa, metode pelengkapan otomatis dan banyak fitur IDE lainnya yang memungkinkan jari kita mengikuti ide di kepala kita. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4b6/69d/e24/4b669de249e57f8f8d7ad2da21df22a3.png"><br><br>  Apa yang dilakukan seorang insinyur ketika alat yang dibutuhkan hilang?  Benar, dia akan melakukan semuanya sendiri!  Sebelumnya kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berbicara</a> tentang membuat alat khusus kami, sekarang mari kita bicara tentang cara memodifikasi Xcode dan membuatnya berfungsi sesuai aturan Anda. <br><a name="habracut"></a><br>  Kami mengambil tugas dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JIRA Swift</a> dan membuat alat yang mengubah <b>jika dibiarkan</b> menjadi <b>penjaga yang</b> setara. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d68/6b7/ad5/d686b7ad5d24b87b61df2bb6d87299eb.gif"><br><br>  Sejak versi kesembilan, Xcode menyediakan mekanisme refactoring baru yang dapat mengkonversi kode secara lokal, dalam file sumber Swift yang sama, atau secara global ketika Anda mengganti nama metode atau properti yang terjadi dalam banyak file, bahkan jika mereka dalam bahasa yang berbeda. <br><br>  Refactoring lokal sepenuhnya diimplementasikan dalam kompiler dan kerangka kerja SourceKit, fitur ini ada dalam repositori Swift open source dan ditulis dalam C ++.  Modifikasi refactoring global saat ini tidak dapat diakses oleh orang biasa, karena basis kode Xcode ditutup.  Karena itu, kita akan membahas sejarah lokal dan berbicara tentang cara mengulang pengalaman kita. <br><br>  Apa yang Anda butuhkan untuk membuat alat sendiri untuk refactoring lokal: <br><br><ol><li>  Memahami C ++ <br></li><li>  Pengetahuan dasar tentang kompiler <br></li><li>  Memahami apa itu AST dan bagaimana cara mengatasinya <br></li><li>  Kode sumber cepat <br></li><li>  Panduan <a href="">swift / docs / refactoring / SwiftLocalRefactoring.md</a> <br></li><li>  Banyak kesabaran <br></li></ol><br><h2>  Sedikit tentang AST </h2><br>  Sedikit dasar teoretis sebelum terjun dalam praktik.  Mari kita lihat bagaimana arsitektur kompiler Swift bekerja.  Pertama-tama, kompiler bertanggung jawab untuk mengubah kode menjadi kode mesin yang dapat dieksekusi. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/00b/9e7/f23/00b9e7f23d9d1c1b3e02d14905179ef2.png"><br><br>  Dari tahapan transformasi yang disajikan, yang paling menarik bagi kami adalah pembuatan pohon sintaksis abstrak (AST) - grafik di mana simpulnya adalah operator dan daunnya adalah operan mereka. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/350/269/29f/35026929fee03914b2689ee5b20fa6f8.png"><br><br>  Sintaksis pohon digunakan dalam pengurai.  AST digunakan sebagai representasi internal dalam kompiler / juru bahasa program komputer untuk mengoptimalkan dan menghasilkan kode. <br><br>  Setelah AST dibuat, parsing dilakukan untuk membuat AST dengan pemeriksaan tipe yang telah diterjemahkan ke dalam Bahasa Menengah Swift.  SIL dikonversi, dioptimalkan, diturunkan ke LLVM IR, yang akhirnya dikompilasi menjadi kode mesin. <br><br>  Untuk membuat alat refactoring, kita perlu memahami AST dan dapat bekerja dengannya.  Jadi alat akan dapat beroperasi dengan benar dengan bagian-bagian kode yang ingin kita proses. <br><br>  Untuk menghasilkan AST file, jalankan perintah: swiftc -dump-ast <i>MyFile.swift</i> <i><br><br></i>  <i>Di bawah ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">output ke konsol</a> AST <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari</a> fungsi <b>if let</b> , yang disebutkan sebelumnya.</i> <i><br><br><img src="https://habrastorage.org/getpro/habr/post_images/901/276/7b6/9012767b6955ddd58dfc221181e8a70b.png"></i> <br><br>  Ada tiga jenis utama simpul di Swift AST: <br><br><ul><li>  deklarasi (subclass dari tipe Decl), <br></li><li>  ekspresi (subclass dari tipe Expr), <br></li><li>  operator (subkelas dari tipe Stmt). <br></li></ul><br>  Mereka sesuai dengan tiga entitas yang digunakan dalam bahasa Swift itu sendiri.  Nama fungsi, struktur, parameter adalah deklarasi.  Ekspresi adalah entitas yang mengembalikan nilai;  misalnya fungsi panggilan.  Operator adalah bagian dari bahasa yang menentukan aliran kontrol eksekusi kode, tetapi tidak mengembalikan nilai (misalnya, jika atau lakukan-tangkap). <br><br>  Ini adalah minimum yang cukup yang perlu Anda ketahui tentang AST untuk pekerjaan mendatang Anda. <br><br><h2>  Bagaimana alat refactoring bekerja secara teori </h2><br>  Untuk menerapkan alat refactoring, Anda memerlukan informasi spesifik tentang area kode yang akan Anda ubah.  Pengembang diberikan entitas tambahan yang mengakumulasikan data.  Yang pertama, ResolvedCursorInfo (refactoring berbasis kursor), memberi tahu Anda jika kita berada di awal ekspresi.  Jika demikian, objek kompilator yang sesuai dari ekspresi ini dikembalikan.  Entitas kedua, RangeInfo (refactoring berbasis rentang), merangkum data tentang rentang asli (misalnya, berapa banyak titik masuk dan keluar yang dimilikinya). <br><br>  Refactoring berbasis kursor dimulai oleh lokasi kursor dalam file sumber.  Tindakan refactoring menerapkan metode yang digunakan mekanisme refactoring untuk menampilkan tindakan yang tersedia di IDE dan untuk melakukan transformasi.  Contoh tindakan berdasarkan kursor: Melompat ke definisi, bantuan cepat, dll. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fce/30f/c9d/fce30fc9de1ab5b473ff9ac14795c462.png"><br><br>  Pertimbangkan tindakan biasa dari sisi teknis: <br><br><ol><li>  Saat Anda memilih lokasi dari editor Xcode, permintaan dibuat ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sourcekitd</a> (kerangka kerja yang bertanggung jawab untuk penyorotan, penyelesaian kode, dll.) Untuk menampilkan tindakan refactoring yang tersedia. <br></li><li>  Setiap tindakan yang tersedia diminta oleh objek ResolvedCursorInfo untuk memeriksa apakah tindakan ini berlaku untuk kode yang dipilih. <br></li><li>  Daftar tindakan yang berlaku dikembalikan sebagai respons dari sourcekitd dan ditampilkan dalam Xcode. <br></li><li>  Xcode kemudian menerapkan perubahan pada alat refactoring. <br></li></ol><br>  Refactoring berbasis rentang dimulai dengan memilih rentang kode kontinu dalam file sumber. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/670/987/f65/670987f65cedaec71b072c3d2c721315.png"><br><br>  Dalam hal ini, alat refactoring akan melalui rantai panggilan serupa yang dijelaskan.  Perbedaannya adalah bahwa ketika diimplementasikan, inputnya adalah RangeInfo, bukan ResolvedCursorInfo.  Pembaca yang tertarik dapat merujuk ke <a href="">Refactoring.cpp</a> untuk informasi lebih lanjut tentang contoh-contoh toolkit Apple. <br><br>  Dan sekarang untuk praktik menciptakan alat. <br><br><h2>  Persiapan </h2><br>  Pertama-tama, Anda perlu mengunduh dan membangun kompiler Swift.  Instruksi terperinci ada di repositori resmi ( <a href="">readme.md</a> ).  Berikut adalah perintah utama untuk kloning kode: <br><br><pre><code class="swift hljs">mkdir swift-source cd swift-source git clone https:<span class="hljs-comment"><span class="hljs-comment">//github.com/apple/swift.git ./swift/utils/update-checkout --clone</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cmake</a> digunakan untuk menggambarkan struktur dan dependensi proyek.  Dengan menggunakannya, Anda dapat menghasilkan proyek untuk Xcode (lebih mudah) atau untuk ninja (lebih cepat) karena salah satu perintah: <br><br><pre> <code class="swift hljs">./utils/build-script --debug --xcode</code> </pre> <br>  atau <br><pre> <code class="swift hljs">swift/utils/build-script --debug-debuginfo</code> </pre> <br>  Kompilasi yang berhasil membutuhkan versi terbaru Xcode beta (10.2.1 pada saat penulisan) - tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs web resmi Apple</a> .  Untuk menggunakan Xcode baru untuk membangun proyek, Anda harus mendaftarkan jalur menggunakan utilitas pilih-xcode: <br><br><pre> <code class="bash hljs">sudo xcode-select -s /Users/username/Xcode.app</code> </pre> <br>  Jika kita menggunakan flag --xcode untuk membangun proyek untuk Xcode, masing-masing, kemudian setelah beberapa jam kompilasi (kita mendapat lebih dari dua) di folder build, kita akan menemukan file Swift.xcodeproj.  Membuka proyek, kita akan melihat Xcode yang akrab dengan pengindeksan, breakpoints. <br><br>  Untuk membuat instrumen baru, kita perlu menambahkan kode dengan logika instrumen ke file: lib / IDE / Refactoring.cpp dan tentukan dua metode, dapat diterapkan dan performChange.  Pada metode pertama, kami memutuskan apakah akan mengeluarkan opsi refactoring untuk kode yang dipilih.  Dan yang kedua - bagaimana mengkonversi kode yang dipilih untuk menerapkan refactoring. <br><br>  Setelah persiapan selesai, tetap menerapkan langkah-langkah berikut: <br><br><ol><li>  Mengembangkan logika alat (pengembangan dapat dilakukan dengan beberapa cara - melalui toolchain, melalui Ninja, melalui Xcode; semua opsi akan dijelaskan di bawah) <br></li><li>  Menerapkan dua metode: isApplicable dan performChange (mereka bertanggung jawab untuk akses ke alat dan operasinya) <br></li><li>  Diagnosis dan uji alat yang sudah jadi sebelum mengirim PR ke repositori Swift resmi. <br></li></ol><br><h2>  Uji operasi alat melalui toolchain </h2><br>  Metode pengembangan ini akan membawa Anda banyak waktu karena perakitan komponen yang lama, tetapi hasilnya langsung terlihat dalam Xcode - cara untuk memverifikasi secara manual. <br><br>  Untuk memulai, mari kita membangun rantai alat Swift menggunakan perintah: <br><br><pre> <code class="plaintext hljs">./utils/build-toolchain some_bundle_id</code> </pre> <br>  Mengkompilasi toolchain akan lebih lama dari kompilasi dan dependensi.  Outputnya adalah file swift-LOCAL-yyyy-mm-dd.xctoolchain di folder swift-nightly-install, yang perlu Anda transfer ke Xcode: / Library / Developer / Toolchains /.  Selanjutnya, dalam pengaturan IDE, pilih toolchain baru, restart Xcode. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b67/402/ead/b67402ead1fd1e4470886c8a8ad2f3c2.png"><br><br>  Pilih sepotong kode yang harus diproses alat, dan cari alat di menu konteks. <br><br><h2>  Pengembangan melalui tes dengan Ninja </h2><br>  Jika proyek ini dibangun untuk Ninja dan Anda memilih jalur TDD, maka pengembangan melalui tes dengan Ninja adalah salah satu opsi yang cocok untuk Anda.  Kontra - Anda tidak dapat mengatur breakpoints, seperti dalam pengembangan melalui Xcode. <br><br>  Jadi, kita perlu memeriksa bahwa alat baru ditampilkan dalam Xcode ketika pengguna memilih konstruksi penjaga dalam kode sumber.  Kami menulis tes dalam file test / refactoring / RefactoringKind / basic.swift yang ada: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testConvertToGuardExpr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(idxOpt: Int?)</span></span></span></span> {    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> idx = idxOpt {        <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(idx)    } } <span class="hljs-comment"><span class="hljs-comment">//     . // RUN: %refactor -source-filename %s -pos=266:3 -end-pos=268:4 | %FileCheck %s -check-prefix=CHECK-CONVERT-TO-GUARD-EXPRESSION // CHECK-CONVERT-TO-GUARD-EXPRESSION: Convert To Guard Expression</span></span></code> </pre> <br><br>  Kami menunjukkan bahwa saat menyorot kode antara 266 kolom 3 baris dan 268 baris 4 kolom, kami mengharapkan tampilan item menu dengan alat baru. <br><br>  Menggunakan skrip <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lit.py</a> dapat memberikan umpan balik yang lebih cepat ke siklus pengembangan Anda.  Anda dapat menentukan jenis tes yang diinginkan.  Dalam kasus kami, suite ini akan menjadi RefactoringKind: <br><br> <code>./llvm/utils/lit/lit.py -sv ./build/Ninja-RelWithDebInfoAssert/swift-macosx-x86_64/test-macosx-x86_64/refactoring/RefactoringKind/</code> <br>  Akibatnya, tes hanya file ini yang akan diluncurkan.  Implementasi mereka akan memakan waktu beberapa detik.  Informasi lebih lanjut tentang lit.py akan dibahas nanti di bagian Diagnostik dan Pengujian. <br>  Tes gagal, yang normal untuk paradigma TDD.  Bagaimanapun, sejauh ini kami belum menulis satu baris kode pun dengan logika alat. <br><br><h2>  Pengembangan melalui debugging dan Xcode </h2><br>  Dan akhirnya, metode pengembangan terakhir ketika proyek dibangun di bawah Xcode.  Kelebihan utama adalah kemampuan untuk mengatur breakpoint dan mengontrol debugging. <br><br>  Ketika membangun proyek di bawah Xcode, file Swift.xcodeproj dibuat di folder build / Xcode-DebugAssert / swift-macosx-x86_64 /.  Saat Anda membuka file ini untuk pertama kalinya, lebih baik memilih untuk membuat skema secara manual untuk menghasilkan ALL_BUILD dan swift-refactor sendiri: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f7d/7cb/458/f7d7cb4587c345d03bc77fc62cd615a9.png"><br><br>  Selanjutnya, kami membangun proyek dengan ALL_BUILD sekali, setelah itu kami menggunakan skema swift-refactor. <br><br>  Alat refactoring dikompilasi menjadi file yang dapat dieksekusi terpisah - swift-refactor.  Bantuan untuk file ini dapat ditampilkan menggunakan flag –help.  Parameter yang paling menarik bagi kami adalah: <br><br><pre> <code class="swift hljs">-source-filename=&lt;string&gt; <span class="hljs-comment"><span class="hljs-comment">//   -pos=&lt;string&gt; //   -end-pos=&lt;string&gt; //   -kind //  </span></span></code> </pre> <br>  Mereka dapat ditentukan dalam skema sebagai argumen.  Sekarang Anda dapat mengatur breakpoint untuk berhenti di tempat-tempat menarik ketika memulai alat.  Dengan cara biasa, menggunakan perintah <i>p</i> dan <i>po</i> di konsol Xcode, menampilkan nilai-nilai variabel yang sesuai. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/329/254/23c/32925423cba91d5951178b9be63a70d5.png"><br><br><h2>  Implementasi yang berlaku </h2><br>  Metode isApplicable menerima ResolvedRangeInfo dengan informasi tentang AST node dari fragmen kode yang dipilih pada input.  Pada keluaran metode, diputuskan apakah akan menampilkan alat atau tidak dalam menu konteks Xcode.  Antarmuka <a href="">ResolvedRangeInfo</a> lengkap dapat ditemukan di file <a href="">include / swift / IDE / Utils.h</a> . <br><br>  Pertimbangkan bidang kelas ResolvedRangeInfo yang paling berguna dalam kasus kami: <br><br><ul><li>  RangeKind - hal pertama yang harus dilakukan adalah memeriksa jenis area yang dipilih.  Jika area tidak valid (Tidak Valid), Anda dapat mengembalikan false.  Jika jenisnya sesuai dengan kita, misalnya, SingleStatement atau MultiStatement, maka pindah; <br></li></ul><br><ul><li>  ContainedNodes - array elemen AST yang termasuk dalam rentang yang dipilih.  Kami ingin memastikan bahwa pengguna memilih rentang yang akan dimasukkan oleh konstruksi if.  Untuk melakukan ini, kita mengambil elemen pertama dari array dan memeriksa apakah elemen ini sesuai dengan IfStmt (kelas yang mendefinisikan simpul AST dari simpul pernyataan dari subtipe if).  Selanjutnya, lihat kondisinya.  Untuk menyederhanakan implementasi, kami akan menampilkan alat hanya untuk ekspresi dengan satu syarat.  Berdasarkan jenis kondisi (CK_PatternBinding) kami menentukan bahwa ini dibiarkan. <br></li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/e7f/ba1/e70/e7fba1e70c05ada9602ba90164c67db8.png"><br><br>  Untuk menguji apakah dapat diterapkan, tambahkan kode sampel ke file <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">test / refactoring / RefactoringKind / basic.swift</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0a1/663/046/0a1663046435877088f58d14329123f5.png"><br><br>  Agar tes dapat mensimulasikan panggilan ke alat kami, Anda perlu menambahkan baris di file <a href="">tools / swift-refactor / swift-refactor.cpp</a> . <a href="">&nbsp;</a><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a38/3a9/b3d/a383a9b3d80613dda377d5cd7f43411c.png"><br><br><h2>  Kami menerapkan performChange </h2><br>  Metode ini dipanggil ketika alat refactoring dipilih dalam menu konteks.  Metode ini memiliki akses ke ResolvedRangeInfo, serta di isApplicable.  Kami menggunakan ResolvedRangeInfo dan menulis logika alat konversi kode. <br><br>  Saat membuat kode untuk token statis (diatur oleh sintaks bahasa), Anda dapat menggunakan entitas dari tok namespace.  Misalnya, untuk kata kunci penjaga, gunakan tok :: kw_guard.  Untuk token dinamis (dimodifikasi oleh pengembang, misalnya, nama fungsi), Anda harus memilihnya dari larik elemen AST. <br><br>  Untuk menentukan di mana kode yang dikonversi dimasukkan, kami menggunakan rentang yang dipilih penuh menggunakan konstruk RangeInfo.ContentRange. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/893/d2b/c31/893d2bc311ceba6313fad5d474f6ea2e.png"><br><br><h2>  Diagnostik dan pengujian </h2><br>  Sebelum Anda selesai mengerjakan alat, Anda perlu memeriksa kebenaran pekerjaannya lagi.  Tes akan membantu kita lagi.  Tes dapat dijalankan satu per satu atau dengan semua cakupan yang tersedia.  Cara termudah untuk menjalankan seluruh rangkaian uji Swift adalah dengan perintah --test pada utils / build-script, yang akan menjalankan rangkaian uji utama.  Menggunakan utils / build-script akan membangun kembali semua target, yang secara signifikan dapat meningkatkan waktu siklus debugging. <br><br>  Pastikan untuk menjalankan utils / build-script - tes validasi uji validasi sebelum membuat perubahan besar pada kompiler atau API. <br><br>  Ada cara lain untuk menjalankan semua unit test dari kompiler - melalui ninja, ninja check-swift dari build / preset / swift-macosx-x86_64.  Ini akan memakan waktu sekitar 15 menit. <br><br>  Dan akhirnya, opsi ketika Anda perlu menjalankan tes secara terpisah.  Untuk secara langsung memanggil skrip lit.py dari LLVM, Anda harus mengonfigurasinya untuk menggunakan direktori build lokal.  Sebagai contoh: <br><br><pre> <code class="swift hljs">% $ {<span class="hljs-type"><span class="hljs-type">LLVM_SOURCE_ROOT</span></span>} /utils/lit/lit.py -sv $ {<span class="hljs-type"><span class="hljs-type">SWIFT_BUILD_DIR</span></span>} / test-macosx-x86_64 / <span class="hljs-type"><span class="hljs-type">Parse</span></span> /</code> </pre> <br>  Ini akan menjalankan tes di direktori 'test / Parse /' untuk macOS 64-bit.  Opsi -sv menyediakan indikator pelaksanaan tes dan menunjukkan hasil hanya tes yang gagal. <br><br>  Lit.py memiliki beberapa fitur berguna lainnya, seperti tes timing dan pengujian latensi.  Anda dapat melihat ini dan fitur lainnya dengan lit.py -h.  Yang paling berguna dapat ditemukan di <a href="">sini</a> . <br><br>  Untuk menjalankan satu tes, tulis: <br><br><pre> <code class="swift hljs"> ./llvm/utils/lit/lit.py -sv ./build/<span class="hljs-type"><span class="hljs-type">Ninja</span></span>-<span class="hljs-type"><span class="hljs-type">RelWithDebInfoAssert</span></span>/swift-macosx-x86_64/test-macosx-x86_64/refactoring/<span class="hljs-type"><span class="hljs-type">RefactoringKind</span></span>/basic.swift</code> </pre> <br>  Jika kita perlu menarik perubahan kompiler terbaru, maka kita perlu memperbarui semua dependensi dan melakukan rebase.  Untuk meningkatkan, jalankan ./utils/update-checkout. <br><br><h2>  Kesimpulan </h2><br>  Kami berhasil mencapai tujuan kami - untuk membuat alat yang sebelumnya tidak ada dalam IDE untuk mengoptimalkan pekerjaan.  Jika Anda juga memiliki ide tentang cara meningkatkan produk Apple dan membuat hidup lebih mudah untuk seluruh komunitas iOS, silakan mengambil counter-branding, karena lebih mudah daripada yang terlihat pada pandangan pertama! <br><br>  Pada 2015, Apple mengunggah kode sumber Swift ke domain publik, yang memungkinkannya masuk ke detail implementasi kompilernya.  Selain itu, dengan Xcode 9, Anda dapat menambahkan alat refactoring lokal.  Pengetahuan dasar tentang C ++ dan perangkat kompiler sudah cukup untuk membuat IDE favorit Anda sedikit lebih nyaman. <br><br>  Pengalaman yang dijelaskan bermanfaat bagi kami - selain menciptakan alat yang menyederhanakan proses pengembangan, kami memperoleh pengetahuan yang benar-benar hardcore tentang bahasa tersebut.  Kotak Pandora yang sedikit terbuka dengan proses tingkat rendah memungkinkan Anda melihat tugas sehari-hari dari sudut pandang baru. <br><br>  Kami berharap bahwa pengetahuan yang diperoleh juga akan memperkaya pemahaman Anda tentang pengembangan! <br><br>  Materi ini ditulis bersama dengan @victoriaqb - Victoria Kashlina, pengembang iOS. <br><br><h2>  Sumber </h2><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Perangkat kompiler Swift.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana cara membuat alat berbasis Swift Compiler?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panduan langkah demi langkah</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Membuang AST Swift untuk Proyek iOS</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memperkenalkan Stress Tester sourcekitd</a> <br></li><li>  <a href="">Menguji dengan cepat</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">[SR-5744] Tindakan refactoring untuk mengonversi if-let to guard-let dan sebaliknya # 24566</a> <br></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id460227/">https://habr.com/ru/post/id460227/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id460213/index.html">Cara membeli tiket semurah mungkin atau terpukul oleh pemantauan harga dinamis</a></li>
<li><a href="../id460215/index.html">Ilmuwan komputer memperluas cakupan pengetahuan pengujian</a></li>
<li><a href="../id460221/index.html">Bagaimana cara mengajukan pertanyaan jika Anda seorang spesialis IT pemula</a></li>
<li><a href="../id460223/index.html">Dari web dan bank hingga pengembangan iOS: pengalaman pribadi apiqa programmer</a></li>
<li><a href="../id460225/index.html">Tentang meja kerja berdiri, kesehatan tulang belakang, dan efektivitas pribadi</a></li>
<li><a href="../id460231/index.html">OpenGear - Mengurangi Waktu Henti Bisnis Menggunakan Server Konsol dengan Manajemen Out-of-Band</a></li>
<li><a href="../id460233/index.html">Game Cities: Skylines ternyata Turing-complete: kami membuat penambah 4-bit</a></li>
<li><a href="../id460237/index.html">Scammers EBay (satu cerita curang)</a></li>
<li><a href="../id460239/index.html">Cara mendapatkan NextGen Firewall sendiri di rumah benar-benar gratis</a></li>
<li><a href="../id460241/index.html">Neraka atau air tinggi: sejarah literatur sains populer Rusia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>