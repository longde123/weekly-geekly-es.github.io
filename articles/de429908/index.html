<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•ã üéª ü§≤üèæ Wie man Coroutinen in Lebensmitteln verwendet und nachts ruhig schl√§ft üëä üêÆ üë®üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Coroutinen sind ein leistungsstarkes Tool f√ºr die asynchrone Codeausf√ºhrung. Sie arbeiten parallel, kommunizieren miteinander und verbrauchen nur weni...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie man Coroutinen in Lebensmitteln verwendet und nachts ruhig schl√§ft</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/429908/">  Coroutinen sind ein leistungsstarkes Tool f√ºr die asynchrone Codeausf√ºhrung.  Sie arbeiten parallel, kommunizieren miteinander und verbrauchen nur wenige Ressourcen.  Es scheint, dass ohne Angst Coroutinen in die Produktion eingef√ºhrt werden k√∂nnen.  Aber es gibt √Ñngste und sie st√∂ren. <br><br>  <strong>Vladimir Ivanovs</strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bericht</a> auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AppsConf besagt,</a> dass der Teufel nicht so schlimm ist und dass Sie jetzt Coroutinen verwenden k√∂nnen: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">warum Coroutinen, nicht RxJava</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Welche √Ñngste behindern Entwickler</a> ? </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wie man einen Cache mit Coroutinen erstellt</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wie man richtig mit Fehlern umgeht</a> . </li></ul><br><iframe width="560" height="315" src="https://www.youtube.com/embed/1lEG1CPkRaw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>√úber den Redner</strong> : Vladimir Ivanov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">dzigoro</a> ) ist ein f√ºhrender Android-Entwickler bei <strong>EPAM</strong> mit 7 Jahren Erfahrung, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">mag</a> L√∂sungsarchitektur, React Native und iOS-Entwicklung und verf√ºgt √ºber ein <strong>Google Cloud Architect-</strong> Zertifikat. <br><a name="habracut"></a><br><blockquote>  Alles, was Sie lesen, ist ein Produkt aus Erfahrungswerten und verschiedenen Studien. Nehmen Sie es also so, wie es ist, ohne jegliche Garantie. <br></blockquote><h2><a name="coroutine"></a>  Coroutinen, Kotlin und RxJava </h2><br>  Zur Information: Der aktuelle Status von Corutin befindet sich in der Version, Beta verlassen.  <strong>Kotlin 1.3</strong> wurde ver√∂ffentlicht, Coroutinen werden f√ºr stabil erkl√§rt und es gibt Frieden auf der Welt. <br><br><img src="https://habrastorage.org/webt/it/jm/db/itjmdbtgjewt6v1kihv_5urqxie.png"><br><br>  Ich habe k√ºrzlich auf Twitter eine Umfrage durchgef√ºhrt, bei der Benutzer von Coroutine: <br><br><ul><li>  13% der Coroutinen in Lebensmitteln.  Alles ist gut; </li><li>  25% probieren sie im Haustierprojekt aus; </li><li>  24% - Was ist Kotlin? </li><li>  Der Gro√üteil von 38% RxJava ist √ºberall. </li></ul><br>  Statistiken sind nicht gl√ºcklich.  Ich glaube, dass <strong>RxJava ein zu komplexes Tool</strong> f√ºr Aufgaben ist, in denen es h√§ufig von Entwicklern verwendet wird.  Coroutinen eignen sich besser zur Steuerung des asynchronen Betriebs. <br><br>  In meinen vorherigen Berichten habe ich dar√ºber gesprochen, wie man von RxJava zu Coroutinen in Kotlin umgestaltet, daher werde ich nicht im Detail darauf eingehen, sondern nur an die Hauptpunkte erinnern. <br><br><h3>  Warum verwenden wir Coroutinen? </h3><br>  Denn wenn wir RxJava verwenden, sehen die √ºblichen Implementierungsbeispiele folgenderma√üen aus: <br><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApiClientRx</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(auth: Authorization)</span></span></span><span class="hljs-function"> : Single&lt;GithubUser&gt; fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRepositories</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reposUrl: String, auth: Authorization)</span></span></span><span class="hljs-function"> : Single&lt;List&lt;GithubRepository&gt;&gt; } </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//RxJava 2 implementation</span></span></span></span></code> </pre> <br>  Wir haben eine Schnittstelle, zum Beispiel schreiben wir einen GitHub-Client und m√∂chten einige Operationen daf√ºr ausf√ºhren: <br><br><ol><li>  Benutzer anmelden. <br></li><li>  Holen Sie sich eine Liste der GitHub-Repositorys. <br></li></ol><br>  In beiden F√§llen geben Funktionen einzelne Gesch√§ftsobjekte zur√ºck: GitHubUser oder eine Liste von GitHubRepository. <br><br>  Der Implementierungscode f√ºr diese Schnittstelle lautet wie folgt: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attemptLoginRx</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ showProgress(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) compositeDisposable.add(apiClient.login(auth) .flatMap { user -&gt; apiClient.getRepositories(user.repos_url, auth) } .map { list -&gt; list.map { it.full_name } } .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .doFinally { showProgress(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) } .subscribe( { list -&gt; showRepositories(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, list) }, { error -&gt; Log.e(<span class="hljs-string"><span class="hljs-string">"TAG"</span></span>, <span class="hljs-string"><span class="hljs-string">"Failed to show repos"</span></span>, error) } )) }</code> </pre><br>  - Wir nehmen <strong>CompositeDisposable,</strong> damit kein Speicherverlust auftritt. <br>  - F√ºgen Sie der ersten Methode einen Aufruf hinzu. <br>  - Wir verwenden bequeme Operatoren, um den Benutzer zu erreichen, zum Beispiel <strong>flatMap</strong> . <br>  - Wir erhalten eine Liste der Repositories. <br>  - Wir schreiben eine <strong>Boilerplate</strong> so, dass sie auf den richtigen Threads <strong>l√§uft</strong> . <br>  - Wenn alles fertig ist, zeigen wir die Liste der Repositorys f√ºr den angemeldeten Benutzer. <br><br>  <strong>RxJava-Code-Schwierigkeiten:</strong> <br><br><ul><li>  <strong>Komplexit√§t</strong>  Meiner Meinung nach ist der Code zu kompliziert f√ºr die einfache Aufgabe, zwei Netzwerkanrufe durchzuf√ºhren und etwas auf der <strong>Benutzeroberfl√§che</strong> anzuzeigen. </li><li>  <strong>Ungebundene Stapelspuren.</strong>  Stapelspuren h√§ngen fast nicht mit dem Code zusammen, den Sie schreiben. </li><li>  <strong>Ressourcen ausgeben</strong> <strong>.</strong>  RxJava generiert viele Objekte unter der Haube und die Leistung kann abnehmen. </li></ul><br>  <strong>Was ist der gleiche Code mit Coroutinen bis Version 0.26?</strong> <br><br>  Bei 0,26 hat sich die API ge√§ndert, und wir sprechen √ºber die Produktion.  Bisher hat es noch niemand geschafft, 0,26 im Produkt anzuwenden, aber wir arbeiten daran. <br><br>  <strong>Mit Coroutinen wird sich unsere Benutzeroberfl√§che erheblich √§ndern</strong> .  Die Funktionen geben keine Singles und andere Hilfsobjekte mehr zur√ºck.  Sie geben sofort Gesch√§ftsobjekte zur√ºck: GitHubUser und eine Liste von GitHubRepository.  Die Funktionen GitHubUser und GitHubRepository verf√ºgen √ºber <strong>Suspend-</strong> Modifikatoren.  Das ist gut so, denn Suspend verpflichtet uns fast zu nichts: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApiClient</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">suspend fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(auth: Authorization)</span></span></span><span class="hljs-function"> : GithubUser suspend fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRepositories</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reposUrl: String, auth: Authorization)</span></span></span><span class="hljs-function"> : List&lt;GithubRepository&gt; } </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//Base interface</span></span></span></span></code> </pre><br>  Wenn Sie sich den Code ansehen, der die Implementierung dieser Schnittstelle bereits verwendet, wird sich dieser im Vergleich zu RxJava erheblich √§ndern: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attemptLogin</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ launch(UI) { val auth = BasicAuthorization(login, pass) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { showProgress(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) val userlnfo = async { apiClient.login(auth) }.await() val repoUrl = userlnfo.repos_url val list = async { apiClient.getRepositories(repoUrl, auth) }.await() showRepositories( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, list.map { it -&gt; it.full_name } ) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: RuntimeException) { showToast(<span class="hljs-string"><span class="hljs-string">"Oops!"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { showProgress(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) } } }</code> </pre><br>  - Die Hauptaktion findet statt, bei der wir den <strong>Coroutine Builder als asynchron bezeichnen</strong> , auf eine Antwort warten und <strong>userlnfo erhalten</strong> . <br>  - Wir verwenden Daten von diesem Objekt. <br>  - Machen Sie einen weiteren <strong>asynchronen</strong> Anruf und <strong>warten Sie</strong> . <br><br>  Alles sieht so aus, als ob keine asynchrone Arbeit stattfindet, und wir schreiben einfach die Befehle in die Spalte und sie werden ausgef√ºhrt.  Am Ende tun wir, was auf der Benutzeroberfl√§che zu tun ist. <br><br>  <strong>Warum sind Coroutinen besser?</strong> <br><br><ul><li>  Dieser Code ist leichter zu lesen.  Es ist so geschrieben, als ob es konsistent w√§re. </li><li>  H√∂chstwahrscheinlich ist die Leistung dieses Codes besser als bei RxJava. </li><li>  Es ist sehr einfach, Tests zu schreiben, aber wir werden etwas sp√§ter darauf zur√ºckkommen. </li></ul><br><h2>  2 Schritte zur Seite <br></h2><br>  Lassen Sie uns ein wenig abschweifen, es gibt ein paar Dinge, die noch besprochen werden m√ºssen. <br><br><h3>  Schritt 1. withContext vs launch / async <br></h3><br>  Zus√§tzlich zum <strong>asynchronen</strong> <strong>Coroutine Builder</strong> gibt es den <strong>Coroutine Builder withContext</strong> . <br><br>  <strong>Durch Starten</strong> oder <strong>Asynchronisieren wird</strong> ein neuer <strong>Coroutine-Kontext erstellt</strong> , was nicht immer erforderlich ist.  Wenn Sie einen Coroutine-Kontext haben, den Sie in der gesamten Anwendung verwenden m√∂chten, m√ºssen Sie ihn nicht neu erstellen.  Sie k√∂nnen eine vorhandene einfach wiederverwenden.  Dazu ben√∂tigen Sie einen Coroutine Builder mit Kontext.  Der vorhandene Coroutine-Kontext wird einfach wiederverwendet.  Es wird 2-3 mal schneller sein, aber jetzt ist es eine prinzipienlose Frage.  Wenn die genauen Zahlen interessant sind, dann ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier die Frage</a> zum <strong>Stapel√ºberlauf</strong> mit Benchmarks und Details. <br><br><blockquote>  <strong>Allgemeine Regel:</strong> Verwenden Sie withContext ohne Zweifel dort, wo es semantisch passt.  Wenn Sie jedoch parallel laden m√ºssen, z. B. mehrere Bilder oder Daten, k√∂nnen Sie zwischen asynchron und warten w√§hlen. <br></blockquote><br><h3>  Schritt 2. Refactoring <br></h3><br>  Was ist, wenn Sie eine wirklich komplexe RxJava-Kette umgestalten?  Ich bin in der Produktion darauf gesto√üen: <br><br><pre> <code class="java hljs">observable1.getSubject().zipWith(observable2.getSubject(), (t1, t2) -&gt; { <span class="hljs-comment"><span class="hljs-comment">// side effects return true; }).doOnError { // handle errors } .zipWith(observable3.getSubject(), (t3, t4) -&gt; { // side effects return true; }).doOnComplete { // gather data } .subscribe()</span></span></code> </pre><br>  Ich hatte eine komplizierte Kette mit einem <strong>√∂ffentlichen Thema</strong> , mit <strong>Rei√üverschluss</strong> und <strong>Nebenwirkungen</strong> in jedem <strong>Rei√üverschluss</strong> , die etwas anderes zum <strong>Eventbus</strong> schickten.  Die Aufgabe bestand zumindest darin, den Eventbus loszuwerden.  Ich sa√ü einen Tag da, konnte aber den Code nicht umgestalten, um das Problem zu l√∂sen.  <strong>Die richtige Entscheidung stellte sich heraus, alles rauszuwerfen und den Code auf Coroutine in 4 Stunden neu zu schreiben</strong> . <br><br>  Der folgende Code ist dem, was ich bekommen habe, sehr √§hnlich: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { val firstChunkJob = async { call1 } val secondChunkJob = async { call2 } val thirdChunkJob = async { call3 } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Result( firstChunkJob.await(), secondChunkJob.await(), thirdChunkJob.await()) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: Exception) { <span class="hljs-comment"><span class="hljs-comment">// handle errors }</span></span></code> </pre><br>  - Wir machen Async f√ºr eine Aufgabe, f√ºr die zweite und dritte. <br>  - Wir warten auf das Ergebnis und f√ºgen alles in ein Objekt ein. <br>  - Fertig! <br><br>  Wenn Sie komplexe Ketten haben und es Coroutinen gibt, dann √ºberarbeiten Sie einfach.  Es ist sehr schnell. <br><br><h2><a name="fear"></a>  Was hindert Entwickler daran, Coroutinen in Prod zu verwenden? <br></h2><br>  Meiner Meinung nach werden wir als Entwickler derzeit nur aus Angst vor etwas Neuem daran gehindert, Coroutinen zu verwenden: <br><br><ul><li>  Wir wissen nicht, was wir mit dem <strong>Lebenszyklus</strong> , der <strong>Aktivit√§t</strong> und dem Fragmentlebenszyklus anfangen sollen.  Wie arbeite ich in diesen F√§llen mit Coroutinen? </li><li>  Es gibt keine Erfahrung in der L√∂sung allt√§glicher komplexer Aufgaben in der Produktion mit Corutin. </li><li>  Nicht genug Werkzeuge.  F√ºr RxJava wurde eine Reihe von Bibliotheken und Funktionen geschrieben.  Zum Beispiel <strong>RxFCM</strong> .  RxJava selbst hat viele Operatoren, was gut ist, aber was ist mit Coroutine? </li><li>  Wir verstehen nicht wirklich, wie man Coroutinen testet. </li></ul><br><blockquote>  Wenn wir diese vier √Ñngste loswerden, k√∂nnen wir nachts ruhig schlafen und Coroutinen in der Produktion verwenden. <br></blockquote><br>  Lassen Sie uns Punkt f√ºr Punkt. <br><br><h3>  1. Lebenszyklusmanagement <br></h3><br><ul><li>  Coroutinen k√∂nnen als <strong>Einweg-</strong> oder <strong>AsyncTask auslaufen</strong> .  Dieses Problem muss manuell gel√∂st werden. </li><li>  Um zuf√§llige <strong>Nullzeigerausnahmen</strong> zu vermeiden <strong>,</strong> m√ºssen Coroutinen gestoppt werden. </li></ul><br><h4>  H√∂r auf <br></h4><br>  <strong>Kennen</strong> Sie <strong>Thread.stop ()</strong> ?  Wenn Sie es benutzt haben, dann nicht lange.  In <strong>JDK 1.1 wurde die</strong> Methode sofort f√ºr veraltet erkl√§rt, da es unm√∂glich ist, einen bestimmten Code zu √ºbernehmen und zu stoppen, und es keine Garantie daf√ºr gibt, dass er korrekt ausgef√ºhrt wird.  H√∂chstwahrscheinlich erhalten Sie nur <strong>Speicherbesch√§digungen</strong> . <br><br>  Daher <strong>funktioniert Thread.stop () nicht</strong> .  Die Stornierung muss kooperativ sein, dh der Code auf der anderen Seite, um zu wissen, dass Sie sie stornieren. <br><br>  Wie wenden wir Stopps mit RxJava an: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> val compositeDisposable = CompositeDisposable() <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestSmth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ compositeDisposable.add( apiClientRx.requestSomething() .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(result -&gt; {}) } <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ compositeDisposable.dispose() }</code> </pre><br><br>  In RxJava verwenden wir <strong>CompositeDisposable</strong> . <br><br>  - F√ºgen Sie der Aktivit√§t im Fragment oder im Presenter, in dem wir RxJava verwenden, die Variable <strong>CompositeDisposable</strong> hinzu. <br>  - <strong>F√ºgen Sie</strong> in <strong>onDestro</strong> y <strong>Dispose hinzu</strong> und alle Ausnahmen <strong>verschwinden</strong> von selbst. <br><br>  Ungef√§hr das gleiche Prinzip bei Coroutinen: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> val job: Job? = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">null</span></span></span><span class="hljs-function"> fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestSmth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ job = launch(UI) { val user = apiClient.requestSomething() ‚Ä¶ } } <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ job?.cancel() }</code> </pre><br>  Betrachten Sie ein Beispiel f√ºr eine <strong>einfache Aufgabe</strong> . <br><br>  In der Regel geben <strong>Coroutine-Builder</strong> einen <strong>Job zur√ºck</strong> und werden in einigen F√§llen zur√ºckgestellt. <br><br>  - Wir k√∂nnen uns diesen Job merken. <br>  - Geben Sie den Befehl <strong>"Launch"</strong> <strong>Coroutine Builder</strong> .  Der Prozess beginnt, etwas passiert, das Ergebnis der Ausf√ºhrung wird gespeichert. <br>  - Wenn wir nichts anderes √ºbergeben, startet "Starten" die Funktion und gibt uns einen Link zum Job zur√ºck. <br>  - Job wird erinnert, und in onDestroy sagen wir <strong>"Abbrechen"</strong> und alles funktioniert gut. <br><br>  <strong>Was ist das Problem des Ansatzes?</strong>  Jeder Job braucht ein Feld.  Sie m√ºssen eine Liste von Jobs f√ºhren, um sie alle zusammen abzubrechen.  Der Ansatz f√ºhrt zu einer Duplizierung des Codes. Tun Sie dies nicht. <br><br>  Die gute Nachricht ist, dass wir <strong>Alternativen haben</strong> : <strong>CompositeJob</strong> und <strong>Lifecycle-f√§higer Job</strong> . <br><br>  CompositeJob ist ein Analogon von CompositeDisposable.  Es sieht ungef√§hr so ‚Äã‚Äãaus <strong>:</strong> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> val job: CompositeJob = CompositeJob() <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestSmth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ job.add(launch(UI) { val user = apiClient.requestSomething() ... }) } <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ job.cancel() }</code> </pre><br>  - F√ºr ein Fragment starten wir einen Job. <br>  - Wir setzen alle <strong>Jobs</strong> in CompositeJob und geben den Befehl: <strong>"job.cancel () f√ºr alle!"</strong>  . <br><br>  Der Ansatz l√§sst sich leicht in 4 Zeilen implementieren, wobei die Klassendeklaration nicht ber√ºcksichtigt wird: <br><br><pre> <code class="java hljs">Class CompositeJob { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> val map = hashMapOf&lt;String, Job&gt;() <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(job: Job, key: String = job.hashCode()</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">) </span></span>= map.put(key, job)?.cancel() <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key: String)</span></span></span><span class="hljs-function"> </span></span>= map[key]?.cancel() <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= map.forEach { _ ,u -&gt; u.cancel() } }</code> </pre><br><br>  Sie ben√∂tigen: <br><br>  - <strong>Karte</strong> mit einem String-Schl√ºssel, <br>  - Methode <strong>hinzuf√ºgen</strong> , in der Sie Job hinzuf√ºgen, <br>  - optionaler <strong>Schl√ºsselparameter</strong> . <br><br>  Wenn Sie denselben Schl√ºssel f√ºr denselben Job verwenden m√∂chten, bitte.  Wenn nicht, l√∂st <strong>hashCode</strong> unser Problem.  F√ºgen Sie den Auftrag zur Karte hinzu, die wir √ºbergeben haben, und brechen Sie den vorherigen mit demselben Schl√ºssel ab.  Wenn wir die Aufgabe √ºbererf√ºllen, interessiert uns das vorherige Ergebnis nicht.  Wir stornieren es und fahren es wieder. <br><br>  Abbrechen ist einfach: Wir erhalten den Auftrag per Schl√ºssel und stornieren.  Der zweite Abbruch f√ºr die gesamte Karte bricht alles ab.  Der gesamte Code wird in einer halben Stunde in vier Zeilen geschrieben und funktioniert.  Wenn Sie nicht schreiben m√∂chten, nehmen Sie das obige Beispiel. <br><br><h4>  Lebenszyklusbewusster Job </h4><br>  Haben Sie <strong>Android Lifecycle</strong> , <strong>Lifecycle-Besitzer</strong> oder <strong>Beobachter verwendet</strong> ? <br><img src="https://habrastorage.org/webt/ud/pi/eq/udpieqn_xba30yasl2buwbs2bay.png"><br><br>  Unsere <strong>Aktivit√§ten</strong> und <strong>Fragmente</strong> haben bestimmte Zust√§nde.  Highlights: <strong>erstellt,</strong> <strong>gestartet</strong> und <strong>fortgesetzt</strong> .  Es gibt verschiedene √úberg√§nge zwischen Zust√§nden.  <strong>Mit LifecycleObserver</strong> k√∂nnen Sie diese √úberg√§nge abonnieren und etwas tun, wenn einer der √úberg√§nge auftritt. <br><br>  Es sieht ganz einfach aus: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyObserver</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LifecycleObserver</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@OnLifecycleEvent</span></span>(Lifecycle.Event.ON_RESUME) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connectListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-meta"><span class="hljs-meta">@OnLifecycleEvent</span></span>(Lifecycle.Event.ON_PAUSE) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">disconnectListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ } }</code> </pre><br>  Sie legen die Annotation mit einigen Parametern f√ºr die Methode auf und sie wird mit dem entsprechenden √úbergang aufgerufen.  Verwenden Sie einfach diesen Ansatz f√ºr Coroutine: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AndroidJob</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lifecycle</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lifecycle</span></span></span><span class="hljs-class">) : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Job</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">by</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Job</span></span></span><span class="hljs-class">(), </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LifecycleObserver</span></span></span><span class="hljs-class"> </span></span>{ init { lifecycle.addObserver(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } <span class="hljs-meta"><span class="hljs-meta">@OnLifecycleEvent</span></span>(Lifecycle.Event.ON_DESTROY) <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Log.d(<span class="hljs-string"><span class="hljs-string">"AndroidJob"</span></span>, <span class="hljs-string"><span class="hljs-string">"Cancelling a coroutine"</span></span>) cancel() } }</code> </pre><br>  - Sie k√∂nnen die Basisklasse <strong>AndroidJob</strong> schreiben. <br>  - Wir √ºbertragen den <strong>Lebenszyklus in die</strong> Klasse. <br>  - Die <strong>LifecycleObserver-</strong> Schnittstelle implementiert den Job. <br><br>  Alles was wir brauchen: <br><br>  - F√ºgen Sie im Konstruktor Lifecycle als Observer hinzu. <br>  - Abonnieren Sie <strong>ON_DESTROY</strong> oder alles andere, was uns interessiert. <br>  - Abbrechen in ON_DESTROY. <br>  - <strong>Holen Sie sich</strong> einen <strong>ParentJob</strong> in Ihr Fragment. <br>  - Rufen Sie den Konstruktor <strong>Joy Jobs</strong> oder den <strong>Lebenszyklus</strong> Ihres Aktivit√§tsfragments auf.  Egal. <br>  - <strong>√úbergeben Sie</strong> diesen <strong>parentJob</strong> als <strong>√ºbergeordneten</strong> <strong>Job</strong> . <br><br>  Der fertige Code sieht folgenderma√üen aus: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> parentJob = AndroidJob(lifecycle) <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ job = launch(UI, parent = parentJob) { <span class="hljs-comment"><span class="hljs-comment">// code } }</span></span></code> </pre><br>  Wenn Sie √ºbergeordnete Elemente abbrechen, werden alle untergeordneten Coroutinen abgebrochen, und Sie m√ºssen nichts mehr in das Fragment schreiben.  Alles geschieht automatisch, nicht mehr ON_DESTROY.  Die Hauptsache <strong>,</strong> vergessen Sie nicht, <strong>parent = parentJob zu √ºbergeben</strong> . <br><br><blockquote>  Wenn Sie verwenden, k√∂nnen Sie eine einfache Flusenregel schreiben, die Sie hervorhebt: "Oh, Sie haben Ihre Eltern vergessen!" <br></blockquote><br>  Mit <strong>&nbsp;</strong>  Lebenszyklusmanagement aussortiert.  Wir haben einige Tools, mit denen Sie dies einfach und bequem erledigen k√∂nnen. <br><br>  Was ist mit komplexen Szenarien und nicht trivialen Aufgaben in der Produktion? <br><br><h3>  2. Komplexe Anwendungsf√§lle <br></h3><br>  Komplexe Szenarien und nicht triviale Aufgaben sind: <br><br>  - <strong>Operatoren</strong> - Komplexe Operatoren in RxJava: flatMap, Debounce usw. <br>  - Fehlerbehandlung <strong>-</strong> komplexe Fehlerbehandlung.  Nicht nur <strong>try..catch</strong> , sondern zum Beispiel verschachtelt. <br>  - <strong>Caching</strong> <strong>ist eine</strong> nicht triviale Aufgabe.  In der Produktion stie√üen wir auf einen Cache und wollten ein Tool, mit dem wir das Caching-Problem mit Coroutinen einfach l√∂sen k√∂nnen. <br><br><h4>  Wiederholen </h4><br>  Als wir √ºber die Operatoren f√ºr Coroutine <strong>nachdachten</strong> , war die erste Option <strong>repeatWhen ()</strong> . <br><br>  Wenn etwas schief gelaufen ist und Corutin den Server im Inneren nicht erreichen konnte, m√∂chten wir es mehrmals mit einem exponentiellen Fallback erneut versuchen.  M√∂glicherweise liegt der Grund in einer schlechten Verbindung, und wir erzielen das gew√ºnschte Ergebnis, indem wir den Vorgang mehrmals wiederholen. <br><br>  Mit Coroutinen ist diese Aufgabe einfach zu implementieren: <br><br><pre> <code class="java hljs">suspend fun &lt;T&gt; retryDeferredWithDelay( deferred: () -&gt; Deferred&lt;T&gt;, tries: Int = <span class="hljs-number"><span class="hljs-number">3</span></span>, timeDelay: Long = <span class="hljs-number"><span class="hljs-number">1000L</span></span> ): T { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i in <span class="hljs-number"><span class="hljs-number">1</span></span>..tries) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> deferred().await() } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: Exception) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; tries) delay(timeDelay) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> e } } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> UnsupportedOperationException() }</code> </pre><br><br>  Bedienerimplementierung: <br><br>  - Er nimmt <strong>aufgeschoben</strong> . <br>  - Sie m√ºssen <strong>asynchron</strong> aufrufen, um dieses Objekt zu erhalten. <br>  - Anstelle von <strong>Zur√ºckgestellt k√∂nnen</strong> Sie sowohl einen Suspend-Block als auch im Allgemeinen jede <strong>Suspend-Funktion √ºbergeben.</strong> <br>  - Die <strong>for-</strong> Schleife - Sie warten auf das Ergebnis Ihrer Coroutine.  Wenn etwas passiert und der Wiederholungsz√§hler nicht ersch√∂pft ist, versuchen Sie es erneut mit <strong>Delay</strong> .  Wenn nicht, dann nein. <br><br>  Die Funktion kann einfach angepasst werden: Setzen Sie eine exponentielle Verz√∂gerung oder √ºbergeben Sie eine Lambda-Funktion, die die Verz√∂gerung abh√§ngig von den Umst√§nden berechnet. <br><br>  Verwenden Sie es, es funktioniert! <br><br><h4>  Rei√üverschl√ºsse </h4><br>  Wir begegnen ihnen auch oft.  Auch hier ist alles einfach: <br><br><pre> <code class="java hljs">suspend fun &lt;T1, T2, R&gt; zip( source1: Deferred&lt;T1&gt;, source2: Deferred&lt;T2&gt;, zipper: BiFunction&lt;T1, T2, R&gt;): R { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> zipper.apply(sourcel.await(), source2.await()) } suspend fun &lt;T1, T2, R&gt; Deferred&lt;T1&gt;.zipWith( other: Deferred&lt;T2&gt;, zipper: BiFunction&lt;T1, T2, R&gt;): R { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> zip(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, other, zipper) }</code> </pre><br>  - Verwenden Sie den <strong>Rei√üverschluss</strong> und warten Sie auf Ihren Deferred. <br>  - Anstelle von "Zur√ºckgestellt" k√∂nnen Sie die Funktion "Suspend" und den Coroutine Builder mit withContext verwenden.  Sie vermitteln den Kontext, den Sie ben√∂tigen. <br><br>  Das funktioniert wieder und ich hoffe, dass ich diese Angst beseitigt habe. <br><br><a name="cache"></a><h3>  Cache </h3><br><br>  Haben Sie eine Cache-Implementierung in der Produktion mit RxJava?  Wir verwenden RxCache. <br><img src="https://habrastorage.org/webt/tz/ym/tn/tzymtn1tykponnxcmz0qqi_qjmi.png"><br><br>  Im Diagramm links: <strong>View</strong> und <strong>ViewModel</strong> .  Rechts sind die Datenquellen: Netzwerkanrufe und die Datenbank. <br><br>  Wenn etwas zwischengespeichert werden soll, ist der Cache eine weitere Datenquelle. <br><br>  Arten von Cache: <br><br><ul><li>  <strong>Netzwerkquelle</strong> f√ºr Netzwerkanrufe. </li><li>  <strong>In-Memory-Cache</strong> . </li><li>  <strong>Permanenter Cache</strong> mit Ablauf, der auf der Festplatte gespeichert werden soll, damit der Cache den Neustart der Anwendung √ºberlebt. </li></ul><br>  Schreiben wir einen einfachen und primitiven <strong>Cache</strong> f√ºr den dritten Fall.  Der Coroutine Builder withContext kommt wieder zur Rettung. <br><br><pre> <code class="java hljs">launch(UI) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data = withContext(dispatcher) { persistence.getData() } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { data = withContext(dispatcher) { memory.getData() } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { data = withContext(dispatcher) { network.getData() } memory.cache(url, data) persistence.cache(url, data) } } }</code> </pre><br>  - Sie f√ºhren jede Operation mit withContext aus und pr√ºfen, ob Daten eingehen. <br>  - Wenn die Daten aus der <strong>Persistenz</strong> nicht kommen, versuchen Sie, sie aus <strong>memory.cache abzurufen</strong> . <br>  - Wenn auch kein memory.cache vorhanden ist, wenden Sie sich an die <strong>Netzwerkquelle</strong> und rufen Sie Ihre Daten ab.  Vergessen Sie nat√ºrlich nicht, alle Caches einzutragen. <br><br>  Dies ist eine eher primitive Implementierung und es gibt viele Fragen, aber die Methode funktioniert, wenn Sie einen Cache an einem Ort ben√∂tigen.  F√ºr Produktionsaufgaben reicht dieser Cache nicht aus.  Es wird etwas Komplizierteres ben√∂tigt. <br><br><h4>  Rx hat RxCache </h4><br>  F√ºr diejenigen, die noch RxJava verwenden, k√∂nnen Sie RxCache verwenden.  Wir benutzen es auch noch.  <strong>RxCache</strong> ist eine spezielle Bibliothek.  Erm√∂glicht das Zwischenspeichern von Daten und das Verwalten des Lebenszyklus. <br><br>  Sie m√∂chten beispielsweise sagen, dass diese Daten nach 15 Minuten ablaufen: "Bitte senden Sie nach dieser Zeit keine Daten aus dem Cache, sondern senden Sie mir neue Daten." <br><br>  Die Bibliothek ist insofern wunderbar, als sie das Team deklarativ unterst√ºtzt.  Die Erkl√§rung ist sehr √§hnlich zu dem, was Sie mit <strong>Retrofit machen</strong> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FeatureConfigCacheProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@ProviderKey</span></span>(<span class="hljs-string"><span class="hljs-string">"features"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@LifeCache</span></span>(duration = <span class="hljs-number"><span class="hljs-number">15</span></span>, timeUnit = TimeUnit.MINUTES) <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFeatures</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( result: Observable&lt;Features&gt;, cacheName: DynamicKey )</span></span></span><span class="hljs-function">: Observable&lt;Reply&lt;Features&gt;&gt; }</span></span></code> </pre><br>  - Sie sagen, dass Sie einen <strong>CacheProvider haben</strong> . <br>  - Starten Sie eine Methode und sagen Sie, dass die <strong>LifeCache-</strong> Lebensdauer 15 Minuten <strong>betr√§gt</strong> .  Der Schl√ºssel, mit dem es verf√ºgbar sein wird, ist <strong>Funktionen</strong> . <br>  - Gibt <strong>Observable &lt;Reply zur√ºck</strong> , wobei <strong>Reply</strong> ein Hilfsbibliotheksobjekt f√ºr die Arbeit mit dem Cache ist. <br><br>  Die Verwendung ist recht einfach: <br><br><pre> <code class="java hljs">val restObservable = configServiceRestApi.getFeatures() val features = featureConfigCacheProvider.getFeatures( restObservable, DynamicKey(CACHE_KEY) )</code> </pre><br>  - <strong>Greifen</strong> Sie √ºber den Rx-Cache auf <strong>RestApi zu</strong> . <br>  - <strong>Wenden Sie sich</strong> an <strong>CacheProvider</strong> . <br>  - F√ºttere ihn mit einem Observable. <br>  - Die Bibliothek selbst wird herausfinden, was zu tun ist: Gehen Sie in den Cache oder nicht. Wenn die Zeit abl√§uft, wenden Sie sich an <strong>Observable</strong> und f√ºhren Sie einen weiteren Vorgang aus. <br><br>  Die Nutzung der Bibliothek ist sehr praktisch und ich m√∂chte eine √§hnliche f√ºr Coroutine erhalten. <br><br><h4>  Coroutine Cache in Entwicklung </h4><br>  In EPAM schreiben wir die <strong>Coroutine-Cache-</strong> Bibliothek, die alle Funktionen von RxCache ausf√ºhrt.  Wir haben die erste Version geschrieben und innerhalb des Unternehmens ausgef√ºhrt.  Sobald die erste Ver√∂ffentlichung herauskommt, werde ich sie gerne auf meinem Twitter ver√∂ffentlichen.  Es wird so aussehen: <br><br><pre> <code class="java hljs">val restFunction = configServiceRestApi.getFeatures() val features = withCache(CACHE_KEY) { restFunction() }</code> </pre><br>  Wir werden eine Suspend-Funktion <strong>getFeatures haben</strong> .  Wir werden die Funktion als Block an eine spezielle Funktion h√∂herer Ordnung mit <strong>Cache √ºbergeben</strong> , die <strong>herausfindet</strong> , was zu tun ist. <br><br>  Vielleicht machen wir die gleiche Schnittstelle, um deklarative Funktionen zu unterst√ºtzen. <br><br><a name="err"></a><h3>  Fehlerbehandlung <br></h3><br><img src="https://habrastorage.org/webt/sd/qq/uc/sdqqucxxckqchfozdoknxa3vi-k.png"><br><br>  Eine einfache Fehlerbehandlung wird h√§ufig von Entwicklern gefunden und normalerweise ganz einfach gel√∂st.  Wenn Sie keine komplizierten Dinge haben, fangen Sie in catch eine <strong>Ausnahme ab</strong> und sehen sich an, was dort passiert ist, schreiben in das Protokoll oder zeigen dem Benutzer einen Fehler an.  Auf der Benutzeroberfl√§che k√∂nnen Sie dies problemlos tun. <br><br>  In einfachen F√§llen ist alles erwartungsgem√§√ü einfach - die Fehlerbehandlung mit Coroutinen erfolgt durch <strong>try-catch-finally</strong> . <br><br>  In der Produktion gibt es neben einfachen F√§llen: <br><br>  - Verschachtelter <strong>Versuch</strong> , <br>  - Viele verschiedene Arten von <strong>Ausnahmen</strong> , <br>  - Fehler im Netzwerk oder in der Gesch√§ftslogik, <br>  - Benutzerfehler.  Er hat wieder etwas falsch gemacht und war f√ºr alles verantwortlich. <br><br>  Darauf m√ºssen wir vorbereitet sein. <br><br>  Es gibt zwei L√∂sungen: <strong>CoroutineExceptionHandler</strong> und den Ansatz mit <strong>Ergebnisklassen</strong> . <br><br><h3>  Coroutine-Ausnahmebehandlungsroutine <br></h3><br>  Dies ist eine spezielle Klasse f√ºr die Behandlung komplexer Fehlerf√§lle.  <strong>Mit ExceptionHandler</strong> k√∂nnen Sie Ihre <strong>Ausnahme</strong> als Argument als Fehler betrachten und damit umgehen. <br><br>  Wie gehen wir normalerweise mit komplexen Fehlern um? <br><br>  Der Benutzer dr√ºckte etwas, die Taste funktionierte nicht.  Er muss sagen, was schief gelaufen ist, und es auf eine bestimmte Aktion hinweisen: √úberpr√ºfen Sie das Internet, WLAN, versuchen Sie es sp√§ter oder l√∂schen Sie die Anwendung und verwenden Sie sie nie wieder.  Dies dem Benutzer zu sagen ist ganz einfach: <br><br><pre> <code class="java hljs">val handler = CoroutineExceptionHandler(handler = { , error -&gt; hideProgressDialog() val defaultErrorMsg = <span class="hljs-string"><span class="hljs-string">"Something went wrong"</span></span> val errorMsg = when (error) { is ConnectionException -&gt; userFriendlyErrorMessage(error, defaultErrorMsg) is HttpResponseException -&gt; userFriendlyErrorMessage(Endpoint.EndpointType.ENDPOINT_SYNCPLICITY, error) is EncodingException -&gt; <span class="hljs-string"><span class="hljs-string">"Failed to decode data, please try again"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; defaultErrorMsg } Toast.makeText(context, errorMsg, Toast.LENGTH_SHORT).show() })</code> </pre><br>  - Lassen Sie uns die Standardmeldung erhalten: "Etwas ist schief gelaufen!"  und analysieren Sie die Ausnahme. <br>  - Wenn dies eine <strong>ConnectionException ist,</strong> nehmen wir eine lokalisierte Nachricht aus den Ressourcen: ‚ÄûMann, schalten Sie Wi-Fi ein und Ihre Probleme werden verschwinden.  Ich garantiere es. " <br>  - Wenn der <strong>Server etwas Falsches gesagt hat</strong> , m√ºssen Sie dem Client mitteilen: "Abmelden und erneut anmelden" oder "Tun Sie dies nicht in Moskau, tun Sie es in einem anderen Land" oder "Entschuldigung, Genosse.  Ich kann nur sagen, dass etwas schief gelaufen ist. ‚Äú <br>  - Wenn dies ein v√∂llig <strong>anderer Fehler ist</strong> , zum Beispiel <strong>aus dem Ged√§chtnis heraus</strong> , sagen wir: "Es ist etwas schiefgegangen, es tut mir leid." <br>  - Alle Meldungen werden angezeigt. <br><br>  Was Sie in den <strong>CoroutineExceptionHandler</strong> schreiben, wird auf demselben <strong>Dispatcher</strong> ausgef√ºhrt, auf dem Sie die Coroutine ausf√ºhren.  Wenn Sie daher den Befehl zum Starten der Benutzeroberfl√§che eingeben, geschieht alles auf der Benutzeroberfl√§che.  Sie ben√∂tigen keinen separaten <strong>Versand,</strong> was sehr praktisch ist. <br><br>  Die Verwendung ist einfach: <br><br><pre> <code class="java hljs">launch(uiDispatcher + handler) { ... }</code> </pre><br>  Es gibt einen <strong>Plus-</strong> Operator.  F√ºgen Sie im Coroutine-Kontext einen <strong>Handler hinzu,</strong> und alles funktioniert, was sehr praktisch ist.  Wir haben das eine Weile benutzt. <br><br><h3>  Ergebnisklassen <br></h3><br>  Sp√§ter stellten wir fest, dass der CoroutineExceptionHandler m√∂glicherweise fehlt.  Das Ergebnis, das durch die Arbeit von Coroutine entsteht, kann aus mehreren Daten aus verschiedenen Teilen bestehen oder mehrere Situationen verarbeiten. <br><br>  Der Ansatz der <strong>Ergebnisklassen</strong> hilft, dieses Problem zu l√∂sen: <br><br><pre> <code class="java hljs">sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Result</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">data class </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Success</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val payload: String)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> data class </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val exception: Exception)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> }</span></span></code> </pre><br>  - In Ihrer Gesch√§ftslogik starten Sie eine <strong>Ergebnisklasse</strong> . <br>  - Als <strong>versiegelt markieren</strong> . <br>  - Sie erben von der Klasse zwei weitere Datenklassen: <strong>Erfolg</strong> und <strong>Fehler</strong> . <br>  - √úbertragen Sie in <strong>Success</strong> Ihre Daten, die als Ergebnis der Coroutine-Ausf√ºhrung generiert wurden. <br> ‚Äî  <strong>Error</strong>  exception. <br><br>     -  : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">override suspend fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: Result </span></span>= withContext(CommonPool) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !isSessionValidForTask() ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span><span class="hljs-meta"><span class="hljs-meta">@withContext</span></span> Result.Error(Exception()) } ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Result.Success(restApi.call()) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: Exception) { Result.Error(e) } }</code> </pre><br>  Coroutine context ‚Äî Coroutine builder withContex     . <br><br> ,  : <br><br> ‚Äî   ,   error.     . <br> ‚Äî   RestApi   -. <br> ‚Äî   ,   <strong>Result.Success</strong> . <br> ‚Äî   ,  <strong>Result.Error</strong> . <br><br>      - ,  ExceptionHandler   . <br><br> Result classes ,   .   Result classes,      ExceptionHandler  try-catch. <br><br><h3> 3.  <br></h3><br> ,       .    <strong>unit-</strong> ,   ,    .       unit-. <br><br> ,   .   ,   unit-,    2 : <br><br><ol><li> <strong>Replacing context</strong> .   ,    ; </li><li> <strong>Mocking coroutines</strong> .   . </li></ol><br><h4> Replacing context <br></h4><br>   presenter: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">val </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ launch(UI) { ‚Ä¶ } }</code> </pre><br> ,    <strong>login</strong>    ,     UI-.      ,        ,  <strong>         </strong> .    ,    ,   unit-. <br><br>   : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">val </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val coroutineContext = UI)</span></span></span><span class="hljs-function"> </span></span>{ launch(coroutineContext) { ... } }</code> </pre><br> ‚Äî   login   coroutineContext. ,            .  Kotlin   ,     UI  . <br> ‚Äî   Coroutine builder   Coroutine Contex,    . <br><br>  unit-   : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testLogin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ val presenter = LoginPresenter () presenter.login(Unconfined) }</code> </pre><br><br> ‚Äî    <strong>LoginPresenter</strong>   login   - , ,  Unconfined. <br> ‚Äî <strong>Unconfined</strong> ,      ,    .         . <br><br><h4> Mocking coroutines <br></h4><br>   ‚Äî  .    <strong>Mockk</strong>  unit-.     unit-    Kotlin,      .  suspend-        <strong>coEvery</strong>        -. <br><br>   login     <strong>githubUser</strong> : <br><br><pre> <code class="java hljs">coEvery { apiClient.login(any()) } returns githubUser</code> </pre><br>    <strong>Mockito-kotlin</strong> ,     ‚Äî    . ,    ,     : <br><br><pre> <code class="java hljs">given { runBlocking { apiClient.login(any()) } }.willReturn (githubUser)</code> </pre><br>    <strong>runBlocking</strong> .  <strong>given-</strong>    ,    . <br><br>        <strong>Presenter</strong> : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testLogin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ val githubUser = GithubUser(<span class="hljs-string"><span class="hljs-string">'login'</span></span>) val presenter = LoginPresenter(mockApi) presenter.login (Unconfined) assertEquals(githubUser, presenter.user()) }</code> </pre><br> ‚Äî   -, , <strong>GitHubUser</strong> . <br> ‚Äî  LoginPresenter      API,     .      . <br> ‚Äî   <strong>presenter.login</strong>  Unconfined   ,   Presenter    ,   . <br><br>  Und alle!    . <br><br><h2>   <br></h2><br><br><ul><li> <strong> Rx-   .</strong>      .      ,  RxJava  RxJava.     -  ‚Äî   ,   . </li><li> <strong>   .</strong>   ,       . Unit- ‚Äî       ,  ,     ,    .  ‚Äî welcome! </li><li> <strong>   .</strong>   ,  ,   ,   ,      .       . </li></ul><br><br><h3>  N√ºtzliche Links <br></h3><br><ul><li>      ,      Android GDE   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Android Coroutine Recipes</a> .     ,      : lifeCircle, coroutineContexts,   Coroutine builders   . </li><li> <a href="">  </a>  GitHub. </li><li>     Android  Kotlin,      ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> <strong>Codelab</strong></a> . </li><li>           .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Twitter</a>       . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong> Medium</strong></a>     ¬´¬ª      Android,   async-   . </li></ul><br><blockquote>  <strong>Nachrichten</strong> <br><br> 30    Mail.ru   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a>      .  ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . <br><br>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AppsConf</a>   ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a>   . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  </a> ,   ,       ,       . <br><br>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">youtube-</a>       AppsConf 2018 ‚Äî    :) <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de429908/">https://habr.com/ru/post/de429908/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de429892/index.html">xonsh - Python als Shell-Ersatz</a></li>
<li><a href="../de429894/index.html">Verwenden eines Fischauges auf einem Raspberry Pi 3 mit ROS - Teil 2</a></li>
<li><a href="../de429898/index.html">DMS (Dealership Management System) - Implementierung von Information EcoSystems f√ºr das Dealer Network Management</a></li>
<li><a href="../de429902/index.html">Seitenrang im Web 2.0-Zeitalter - Teil 1</a></li>
<li><a href="../de429904/index.html">Lustige und traurige Geschichten √ºber die Entwicklung von Computerspielen</a></li>
<li><a href="../de429910/index.html">AppsConf steigt</a></li>
<li><a href="../de429912/index.html">Bibliotheksentwicklung: von der API bis zur Ver√∂ffentlichung</a></li>
<li><a href="../de429914/index.html">OpenSceneGraph: Szenendiagramm und intelligente Zeiger</a></li>
<li><a href="../de429916/index.html">Wie man baut und baut</a></li>
<li><a href="../de429918/index.html">Virtuelle Welt Intel. Teil 2: SMP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>