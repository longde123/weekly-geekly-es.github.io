<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍾 👩🏽‍🤝‍👨🏼 📤 Redes neurais e aprendizado profundo, capítulo 4: Prova visual de que as redes neurais podem calcular qualquer função 👨🏼‍🍳 👩🏿‍🤝‍👩🏽 ⛴️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Neste capítulo, dou uma explicação simples e principalmente visual do teorema da universalidade. Para seguir o material deste capítulo, você não preci...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Redes neurais e aprendizado profundo, capítulo 4: Prova visual de que as redes neurais podem calcular qualquer função</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461659/">  Neste capítulo, dou uma explicação simples e principalmente visual do teorema da universalidade.  Para seguir o material deste capítulo, você não precisa ler os anteriores.  Está estruturado como um ensaio independente.  Se você possui o entendimento mais básico do NS, deve poder entender as explicações. <br><br><div class="spoiler">  <b class="spoiler_title">Conteúdo</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Capítulo 1: usando redes neurais para reconhecer números manuscritos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Capítulo 2: como o algoritmo de retropropagação funciona</a> </li><li>  Capítulo 3: <ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1: aprimorando o método de treinamento de redes neurais</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2: Por que a regularização ajuda a reduzir a reciclagem?</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3: como escolher hiperparâmetros de redes neurais?</a> <br></li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Capítulo 4: prova visual de que as redes neurais são capazes de computar qualquer função</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Capítulo 5: por que as redes neurais profundas são tão difíceis de treinar?</a> </li><li>  Capítulo 6: <ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1: Aprendizado Profundo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2: progresso recente no reconhecimento de imagens</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Posfácio: existe um algoritmo simples para criar inteligência?</a> </li></ul></div></div><br>  Um dos fatos mais surpreendentes sobre as redes neurais é que elas podem calcular qualquer função.  Ou seja, digamos que alguém lhe dê algum tipo de função complexa e sinuosa f (x): <br><br><img src="https://habrastorage.org/webt/yi/ot/sl/yiotslaplbwh6savahfpzfwdyum.png"><br><a name="habracut"></a><br>  E, independentemente dessa função, é garantida uma rede neural que, para qualquer entrada x, o valor f (x) (ou alguma aproximação próxima a ela) será a saída dessa rede, ou seja: <br><br><img src="https://habrastorage.org/webt/eb/ud/zc/ebudzc72xyiytdvkf4ulx-u7onq.png"><br><br>  Isso funciona mesmo que seja uma função de muitas variáveis ​​f = f (x <sub>1</sub> , ..., x <sub>m</sub> ) e com muitos valores.  Por exemplo, aqui está uma rede que calcula uma função com m = 3 entradas en = 2 saídas: <br><br><img src="https://habrastorage.org/webt/1g/01/i7/1g01i7vpnwo-mlm1r2brhd9al9m.png"><br><br>  Esse resultado sugere que as redes neurais têm uma certa universalidade.  Independentemente da função que queremos calcular, sabemos que existe uma rede neural que pode fazer isso. <br><br>  Além disso, o teorema da universalidade se mantém mesmo se restringirmos a rede a uma única camada entre os neurônios de entrada e saída - os chamados  em uma camada oculta.  Assim, mesmo redes com uma arquitetura muito simples podem ser extremamente poderosas. <br><br>  O teorema da universalidade é bem conhecido pelas pessoas que usam redes neurais.  Mas, embora seja assim, uma compreensão desse fato não é tão difundida.  E a maioria das explicações para isso é tecnicamente complexa demais.  Por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um dos primeiros trabalhos que</a> comprova esse resultado usou o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">teorema de Hahn - Banach</a> , o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">teorema de representação de Riesz</a> e algumas análises de Fourier.  Se você é matemático, é fácil entender essas evidências, mas para a maioria das pessoas não é tão fácil.  É uma pena, porque as razões básicas da universalidade são simples e bonitas. <br><br>  Neste capítulo, dou uma explicação simples e principalmente visual do teorema da universalidade.  Vamos seguir passo a passo as idéias subjacentes.  Você entenderá por que as redes neurais podem realmente calcular qualquer função.  Você entenderá algumas das limitações deste resultado.  E você entenderá como o resultado está associado ao NS profundo. <br><br>  Para seguir o material deste capítulo, você não precisa ler os anteriores.  Está estruturado como um ensaio independente.  Se você possui o entendimento mais básico do NS, deve poder entender as explicações.  Às vezes, porém, fornecerei links para material anterior para ajudar a preencher as lacunas de conhecimento. <br><br>  Os teoremas da universalidade são freqüentemente encontrados na ciência da computação, então às vezes até esquecemos o quão incrível eles são.  Mas vale lembrar: a capacidade de calcular qualquer função arbitrária é realmente incrível.  Quase todo processo que você pode imaginar pode ser reduzido ao cálculo de uma função.  Considere a tarefa de encontrar o nome de uma composição musical com base em uma breve passagem.  Isso pode ser considerado um cálculo de função.  Ou considere a tarefa de traduzir um texto chinês para o inglês.  E isso pode ser considerado um cálculo de função (de fato, muitas funções, pois existem muitas opções aceitáveis ​​para traduzir um único texto).  Ou considere a tarefa de gerar uma descrição do enredo do filme e a qualidade da atuação com base no arquivo mp4.  Isso também pode ser considerado como o cálculo de uma determinada função (a observação feita sobre as opções de tradução de texto também está correta aqui).  Universalidade significa que, em princípio, os NSs podem executar todas essas tarefas e muitas outras. <br><br>  Obviamente, apenas pelo fato de sabermos que existem NSs capazes de, por exemplo, traduzir do chinês para o inglês, não se segue que temos boas técnicas para criar ou mesmo reconhecer uma rede desse tipo.  Essa restrição também se aplica aos teoremas tradicionais da universalidade para modelos como esquemas booleanos.  Mas, como já vimos neste livro, o NS possui algoritmos poderosos para funções de aprendizado.  A combinação de algoritmos de aprendizagem e versatilidade é uma mistura atraente.  Até agora, no livro, nos concentramos em algoritmos de treinamento.  Neste capítulo, focaremos na versatilidade e no que isso significa. <br><br><h2>  Dois truques </h2><br>  Antes de explicar por que o teorema da universalidade é verdadeiro, quero mencionar dois truques contidos na declaração informal "uma rede neural pode calcular qualquer função". <br><br>  Primeiro, isso não significa que a rede possa ser usada para calcular com precisão qualquer função.  Só podemos obter uma aproximação tão boa quanto precisamos.  Ao aumentar o número de neurônios ocultos, melhoramos a aproximação.  Por exemplo, eu ilustrei anteriormente uma rede que computa uma determinada função f (x) usando três neurônios ocultos.  Para a maioria das funções, usando três neurônios, apenas uma aproximação de baixa qualidade pode ser obtida.  Ao aumentar o número de neurônios ocultos (digamos, até cinco), geralmente podemos obter uma aproximação melhorada: <br><br><img src="https://habrastorage.org/webt/x2/nt/zw/x2ntzw4ykxb450nexszfsd-qz08.png"><br><br>  E para melhorar a situação aumentando ainda mais o número de neurônios ocultos. <br><br>  Para esclarecer esta afirmação, digamos que recebemos uma função f (x), que queremos calcular com a precisão necessária ε&gt; 0.  Há uma garantia de que, ao usar um número suficiente de neurônios ocultos, sempre podemos encontrar um NS cuja saída g (x) satisfaça a equação | g (x) −f (x) | &lt;ε para qualquer x.  Em outras palavras, a aproximação será alcançada com a precisão desejada para qualquer valor de entrada possível. <br><br>  O segundo problema é que as funções que podem ser aproximadas pelo método descrito pertencem a uma classe contínua.  Se a função for interrompida, ou seja, ocorrer saltos bruscos repentinos, no caso geral, será impossível aproximar com a ajuda do NS.  E isso não é surpreendente, já que nossos NSs calculam funções contínuas de dados de entrada.  No entanto, mesmo que a função que realmente precisamos calcular seja descontínua, a aproximação geralmente é bastante contínua.  Se sim, então podemos usar o NS.  Na prática, essa limitação geralmente não é importante. <br><br>  Como resultado, uma declaração mais precisa do teorema da universalidade será que NS com uma camada oculta pode ser usado para aproximar qualquer função contínua com a precisão desejada.  Neste capítulo, provamos uma versão um pouco menos rigorosa desse teorema, usando duas camadas ocultas em vez de uma.  Nas tarefas, descreverei brevemente como essa explicação pode ser adaptada, com pequenas alterações, a uma prova que usa apenas uma camada oculta. <br><br><h2>  Versatilidade com uma entrada e um valor de saída </h2><br>  Para entender por que o teorema da universalidade é verdadeiro, começamos entendendo como criar uma função de aproximação NS com apenas uma entrada e um valor de saída: <br><br><img src="https://habrastorage.org/webt/yi/ot/sl/yiotslaplbwh6savahfpzfwdyum.png"><br><br>  Acontece que essa é a essência da tarefa da universalidade.  Depois que entendermos esse caso especial, será bastante fácil estendê-lo para funções com muitos valores de entrada e saída. <br><br>  Para criar um entendimento de como construir uma rede para contar f, começamos com uma rede contendo uma única camada oculta com dois neurônios ocultos e com uma camada de saída contendo um neurônio de saída: <br><br><img src="https://habrastorage.org/webt/b7/cz/ql/b7czqllzyyxbpzeq7gs3h6a2338.png"><br><br>  Para imaginar como os componentes de rede funcionam, nos concentramos no neurônio oculto superior.  No diagrama do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo original,</a> você pode alterar interativamente o peso com o mouse, clicando em "w" e ver imediatamente como a função calculada pelo neurônio oculto superior muda: <br><br><img src="https://habrastorage.org/webt/mh/r0/dz/mhr0dzpmf_zop4a3bwi2of04qtu.png"><br><br>  Como aprendemos anteriormente no livro, um neurônio oculto conta σ (wx + b), onde σ (z) ≡ 1 / (1 + e <sup>-z</sup> ) é um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sigmóide</a> .  Até agora, usamos essa forma algébrica com bastante frequência.  No entanto, para provar a universalidade, seria melhor ignorarmos completamente essa álgebra e, em vez disso, manipularmos e observarmos a forma no gráfico.  Isso não apenas o ajudará a sentir melhor o que está acontecendo, mas também nos fornecerá uma prova de universalidade aplicável a outras funções de ativação além do sigmóide. <br><br>  A rigor, a abordagem visual que escolhi não é tradicionalmente considerada evidência.  Mas acredito que a abordagem visual fornece mais informações sobre a verdade do resultado final do que as provas tradicionais.  E, é claro, esse entendimento é o real objetivo da prova.  Nas evidências que proponho, as lacunas ocasionalmente aparecerão;  Darei evidências visuais razoáveis, mas nem sempre rigorosas.  Se isso o incomoda, considere sua tarefa preencher essas lacunas.  No entanto, não perca de vista o objetivo principal: entender por que o teorema da universalidade é verdadeiro. <br><br>  Para começar com essa prova, clique no deslocamento b no diagrama original e arraste para a direita para aumentá-lo.  Você verá que, com um aumento no deslocamento, o gráfico se move para a esquerda, mas não muda de forma. <br><br>  Em seguida, arraste-o para a esquerda para reduzir o deslocamento.  Você verá que o gráfico está se movendo para a direita sem alterar a forma. <br><br>  Reduza o peso para 2-3.  Você verá que, à medida que o peso diminui, a curva se endireita.  Para que a curva não fuja do gráfico, talvez seja necessário corrigir o deslocamento. <br><br>  Por fim, aumente o peso para valores maiores que 100. A curva se tornará mais íngreme e, eventualmente, se aproximará da etapa.  Tente ajustar o deslocamento para que seu ângulo fique na região do ponto x = 0,3.  O vídeo abaixo mostra o que deve acontecer: <br><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Seu navegador não suporta vídeo HTML5. <source src="http://neuralnetworksanddeeplearning.com/movies/create_step_function.mp4" type="video/mp4"></video></div></div></div><br><br>  Podemos simplificar bastante nossa análise aumentando o peso, para que o resultado seja realmente uma boa aproximação da função step.  Abaixo, construí a saída do neurônio oculto superior para o peso w = 999.  Esta é uma imagem estática: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/94c/24e/8a8/94c24e8a8a262c06c102b97bef033e99.jpg"><br><br>  Usar funções de passo é um pouco mais fácil do que com o sigmóide típico.  A razão é que as contribuições de todos os neurônios ocultos são adicionadas na camada de saída.  A soma de várias funções de etapa é fácil de analisar, mas é mais difícil falar sobre o que acontece quando várias curvas são adicionadas na forma de um sigmóide.  Portanto, será muito mais simples supor que nossos neurônios ocultos produzam funções graduais.  Mais precisamente, fazemos isso fixando o peso w em um valor muito grande e atribuindo a posição da etapa através do deslocamento.  Obviamente, trabalhar com uma saída como uma função step é uma aproximação, mas é muito bom, e até agora trataremos a função como uma verdadeira função step.  Mais tarde, voltarei a discutir o efeito dos desvios dessa aproximação. <br><br>  Qual o valor de x é o passo?  Em outras palavras, como a posição do degrau depende do peso e do deslocamento? <br><br>  Para responder à pergunta, tente alterar o peso e o deslocamento no gráfico interativo.  Você consegue entender como a posição do passo depende de eb?  Ao praticar um pouco, você pode se convencer de que sua posição é proporcional a be inversamente proporcional a w. <br><br>  De fato, o passo é s = −b / w, como será visto se ajustarmos o peso e o deslocamento com os seguintes valores: <br><br><img src="https://habrastorage.org/webt/ee/d9/zo/eed9zodaxp8ot33ip8y8j-sdcqg.png"><br><br>  Nossas vidas serão bastante simplificadas se descrevermos os neurônios ocultos com um único parâmetro, s, isto é, pela posição do passo, s = −b / w.  No diagrama interativo a seguir, você pode simplesmente alterar s: <br><br><img src="https://habrastorage.org/webt/uy/g6/9h/uyg69hokiufnmt7zwwmysjof5uc.png"><br><br>  Como observado acima, atribuímos um peso w na entrada a um valor muito grande - suficientemente grande para que a função step se torne uma boa aproximação.  E podemos facilmente transformar o neurônio parametrizado dessa maneira de volta à sua forma usual, escolhendo o viés b = -ws. <br><br>  Até agora, concentramo-nos apenas na produção do neurônio oculto superior.  Vejamos o comportamento de toda a rede.  Suponha que os neurônios ocultos calculem as funções do passo definidas pelos parâmetros dos passos s <sub>1</sub> (neurônio superior) es <sub>2</sub> (neurônio inferior).  Seus respectivos pesos de saída são w <sub>1</sub> e w <sub>2</sub> .  Aqui está a nossa rede: <br><br><img src="https://habrastorage.org/webt/6u/ot/ns/6uotnsmlecwfh8iaqz1eb5p5tjo.png"><br><br>  À direita, está um gráfico da saída ponderada w <sub>1</sub> a <sub>1</sub> + w <sub>2</sub> a <sub>2 da</sub> camada oculta.  Aqui <sub>1</sub> e <sub>2</sub> são as saídas dos neurônios ocultos superior e inferior, respectivamente.  Eles são indicados por "a", como costumam ser chamados de ativações neuronais. <br><br>  A propósito, notamos que a saída de toda a rede é σ (w <sub>1</sub> a <sub>1</sub> + w <sub>2</sub> a <sub>2</sub> + b), onde b é o viés do neurônio de saída.  Obviamente, isso não é o mesmo que a saída ponderada da camada oculta, cujo gráfico estamos construindo.  Mas, por enquanto, vamos nos concentrar na saída equilibrada da camada oculta e só mais tarde pensar em como ela se relaciona com a saída de toda a rede. <br><br>  Tente aumentar e diminuir a etapa <sub>1 do</sub> neurônio oculto superior no diagrama interativo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no artigo original</a> .  Veja como isso altera a saída ponderada da camada oculta.  É especialmente útil entender o que acontece quando s <sub>1</sub> excede s <sub>2</sub> .  Você verá que o gráfico nesses casos muda de forma, à medida que passamos de uma situação na qual o neurônio oculto superior é ativado primeiro para uma situação na qual o neurônio oculto inferior é ativado primeiro. <br><br>  Da mesma forma, tente manipular a etapa s <sub>2 do</sub> neurônio oculto inferior e veja como isso altera a produção geral dos neurônios ocultos. <br><br>  Tente reduzir e aumentar os pesos de saída.  Observe como isso aumenta a contribuição dos neurônios ocultos correspondentes.  O que acontece se um dos pesos for igual a 0? <br><br>  Por fim, tente definir w <sub>1</sub> a 0,8 e w <sub>2</sub> a -0,8.  O resultado é uma função de “protrusão”, com início em s <sub>1</sub> , final em s <sub>2</sub> e altura de 0,8.  Por exemplo, uma saída ponderada pode ser assim: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/84d/9be/e75/84d9bee755d8a57bbdb3aed20d07da78.jpg"><br><br>  Obviamente, a protrusão pode ser dimensionada para qualquer altura.  Vamos usar um parâmetro, h, denotando altura.  Além disso, por simplicidade, vou me livrar da notação "s <sub>1</sub> = ..." e "w <sub>1</sub> = ...". <br><br><img src="https://habrastorage.org/webt/io/by/7l/ioby7lcd1whqowsw0ak9j1td16q.png"><br><br>  Tente aumentar e diminuir o valor h para ver como a altura da saliência muda.  Tente fazer h negativo.  Tente alterar os pontos das etapas para observar como isso muda a forma da saliência. <br><br>  Você verá que usamos nossos neurônios não apenas como primitivas gráficas, mas também como unidades mais familiares aos programadores - algo como uma instrução if-then-else na programação: <br><br>  se input&gt; = início da etapa: <br>  adicione 1 à saída ponderada <br>  mais: <br>  adicione 0 à saída ponderada <br><br>  Na maior parte, vou me ater à notação gráfica.  No entanto, às vezes será útil mudar para a exibição "se-então-outro" e refletir sobre o que está acontecendo nesses termos. <br><br>  Podemos usar nosso truque de protrusão colando duas partes de neurônios ocultos na mesma rede: <br><br><img src="https://habrastorage.org/webt/4w/4p/pz/4w4ppzryydmyz3f3dglgzcwisfm.png"><br><br>  Aqui eu larguei os pesos simplesmente anotando os valores de h para cada par de neurônios ocultos.  Tente jogar com ambos os valores de h e veja como isso muda o gráfico.  Mova as guias, alterando os pontos das etapas. <br><br>  Em um caso mais geral, essa ideia pode ser usada para obter qualquer número desejado de picos de qualquer altura.  Em particular, podemos dividir o intervalo [0,1] em um grande número de (N) subintervalos e usar N pares de neurônios ocultos para obter picos de qualquer altura desejada.  Vamos ver como isso funciona para N = 5.  Isso já é um monte de neurônios, então eu sou uma apresentação um pouco mais restrita.  Desculpe pelo diagrama complexo - eu poderia esconder a complexidade por trás de abstrações adicionais, mas parece-me que vale um pouco de tormento com complexidade, a fim de sentir melhor como as redes neurais funcionam. <br><br><img src="https://habrastorage.org/webt/do/2t/x-/do2tx-fp-h-w83rnboapp8w-o98.png"><br><br>  Veja bem, temos cinco pares de neurônios ocultos.  Os pontos das etapas dos pares correspondentes estão localizados em 0,1 / 5, depois em 1 / 5,2 / 5 e assim por diante, até 4 / 5,5 / 5.  Esses valores são fixos - obtemos cinco saliências de igual largura no gráfico. <br><br>  Cada par de neurônios tem um valor h associado a ele.  Lembre-se de que as conexões dos neurônios de saída têm pesos heh.  No artigo original no gráfico, você pode clicar nos valores de h e movê-los para a esquerda-direita.  Com uma mudança de altura, a programação também muda.  Alterando os pesos de saída, construímos a função final! <br><br>  No diagrama, você ainda pode clicar no gráfico e arrastar a altura das etapas para cima ou para baixo.  Quando você altera sua altura, vê como a altura do h correspondente é alterada.  Os pesos de saída + he –h mudam de acordo.  Em outras palavras, manipulamos diretamente uma função cujo gráfico é mostrado à direita e vemos essas alterações nos valores de h à esquerda.  Você também pode manter pressionado o botão do mouse em uma das saliências e arrastar o mouse para a esquerda ou direita, e as saliências serão ajustadas à altura atual. <br><br>  É hora de fazer o trabalho. <br><br>  Lembre-se da função que eu desenhei no início do capítulo: <br><br><img src="https://habrastorage.org/webt/yi/ot/sl/yiotslaplbwh6savahfpzfwdyum.png"><br><br>  Então eu não mencionei isso, mas na verdade é assim: <br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>f</mi><mo stretchy=&quot;false&quot;>(</mo><mi>x</mi><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><mn>0</mn><mo>,</mo><mn>2</mn><mo>+</mo><mn>0</mn><mo>,</mo><mn>4</mn><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>0</mn><mo>,</mo><mn>3</mn><mi>x</mi><mtext>&amp;#xA0;</mtext><mi>s</mi><mi>i</mi><mi>n</mi><mo stretchy=&quot;false&quot;>(</mo><mn>15</mn><mi>x</mi><mo stretchy=&quot;false&quot;>)</mo><mo>+</mo><mn>0</mn><mo>,</mo><mn>05</mn><mtext>&amp;#xA0;</mtext><mi>c</mi><mi>o</mi><mi>s</mi><mo stretchy=&quot;false&quot;>(</mo><mn>50</mn><mi>x</mi><mo stretchy=&quot;false&quot;>)</mo><mtext>&amp;#xA0;</mtext><mi>t</mi><mi>a</mi><mi>g</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>113</mn></mrow></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="60.204ex" height="3.021ex" viewBox="0 -987.6 25921 1300.8" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhj1i4KOa4v0cvXxy7mi7CA6if7dDw#MJMATHI-66" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhj1i4KOa4v0cvXxy7mi7CA6if7dDw#MJMAIN-28" x="550" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhj1i4KOa4v0cvXxy7mi7CA6if7dDw#MJMATHI-78" x="940" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhj1i4KOa4v0cvXxy7mi7CA6if7dDw#MJMAIN-29" x="1512" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhj1i4KOa4v0cvXxy7mi7CA6if7dDw#MJMAIN-3D" x="2179" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhj1i4KOa4v0cvXxy7mi7CA6if7dDw#MJMAIN-30" x="3236" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhj1i4KOa4v0cvXxy7mi7CA6if7dDw#MJMAIN-2C" x="3736" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhj1i4KOa4v0cvXxy7mi7CA6if7dDw#MJMAIN-32" x="4181" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhj1i4KOa4v0cvXxy7mi7CA6if7dDw#MJMAIN-2B" x="4904" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhj1i4KOa4v0cvXxy7mi7CA6if7dDw#MJMAIN-30" x="5905" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhj1i4KOa4v0cvXxy7mi7CA6if7dDw#MJMAIN-2C" x="6405" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhj1i4KOa4v0cvXxy7mi7CA6if7dDw#MJMAIN-34" x="6850" y="0"></use><g transform="translate(7351,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhj1i4KOa4v0cvXxy7mi7CA6if7dDw#MJMATHI-78" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhj1i4KOa4v0cvXxy7mi7CA6if7dDw#MJMAIN-32" x="809" y="583"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhj1i4KOa4v0cvXxy7mi7CA6if7dDw#MJMAIN-2B" x="8599" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhj1i4KOa4v0cvXxy7mi7CA6if7dDw#MJMAIN-30" x="9600" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhj1i4KOa4v0cvXxy7mi7CA6if7dDw#MJMAIN-2C" x="10101" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhj1i4KOa4v0cvXxy7mi7CA6if7dDw#MJMAIN-33" x="10546" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhj1i4KOa4v0cvXxy7mi7CA6if7dDw#MJMATHI-78" x="11046" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhj1i4KOa4v0cvXxy7mi7CA6if7dDw#MJMATHI-73" x="11869" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhj1i4KOa4v0cvXxy7mi7CA6if7dDw#MJMATHI-69" x="12338" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhj1i4KOa4v0cvXxy7mi7CA6if7dDw#MJMATHI-6E" x="12684" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhj1i4KOa4v0cvXxy7mi7CA6if7dDw#MJMAIN-28" x="13284" y="0"></use><g transform="translate(13674,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhj1i4KOa4v0cvXxy7mi7CA6if7dDw#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhj1i4KOa4v0cvXxy7mi7CA6if7dDw#MJMAIN-35" x="500" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhj1i4KOa4v0cvXxy7mi7CA6if7dDw#MJMATHI-78" x="14675" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhj1i4KOa4v0cvXxy7mi7CA6if7dDw#MJMAIN-29" x="15247" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhj1i4KOa4v0cvXxy7mi7CA6if7dDw#MJMAIN-2B" x="15859" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhj1i4KOa4v0cvXxy7mi7CA6if7dDw#MJMAIN-30" x="16860" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhj1i4KOa4v0cvXxy7mi7CA6if7dDw#MJMAIN-2C" x="17360" y="0"></use><g transform="translate(17805,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhj1i4KOa4v0cvXxy7mi7CA6if7dDw#MJMAIN-30"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhj1i4KOa4v0cvXxy7mi7CA6if7dDw#MJMAIN-35" x="500" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhj1i4KOa4v0cvXxy7mi7CA6if7dDw#MJMATHI-63" x="19056" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhj1i4KOa4v0cvXxy7mi7CA6if7dDw#MJMATHI-6F" x="19490" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhj1i4KOa4v0cvXxy7mi7CA6if7dDw#MJMATHI-73" x="19975" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhj1i4KOa4v0cvXxy7mi7CA6if7dDw#MJMAIN-28" x="20445" y="0"></use><g transform="translate(20834,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhj1i4KOa4v0cvXxy7mi7CA6if7dDw#MJMAIN-35"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhj1i4KOa4v0cvXxy7mi7CA6if7dDw#MJMAIN-30" x="500" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhj1i4KOa4v0cvXxy7mi7CA6if7dDw#MJMATHI-78" x="21835" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhj1i4KOa4v0cvXxy7mi7CA6if7dDw#MJMAIN-29" x="22408" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhj1i4KOa4v0cvXxy7mi7CA6if7dDw#MJMATHI-74" x="23047" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhj1i4KOa4v0cvXxy7mi7CA6if7dDw#MJMATHI-61" x="23409" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhj1i4KOa4v0cvXxy7mi7CA6if7dDw#MJMATHI-67" x="23938" y="0"></use><g transform="translate(24419,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhj1i4KOa4v0cvXxy7mi7CA6if7dDw#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhj1i4KOa4v0cvXxy7mi7CA6if7dDw#MJMAIN-31" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/461659/&amp;usg=ALkJrhj1i4KOa4v0cvXxy7mi7CA6if7dDw#MJMAIN-33" x="1001" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn><mo>,</mo><mn>2</mn><mo>+</mo><mn>0</mn><mo>,</mo><mn>4</mn><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>0</mn><mo>,</mo><mn>3</mn><mi>x</mi><mtext>&nbsp;</mtext><mi>s</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mn>15</mn><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mn>0</mn><mo>,</mo><mn>05</mn><mtext>&nbsp;</mtext><mi>c</mi><mi>o</mi><mi>s</mi><mo stretchy="false">(</mo><mn>50</mn><mi>x</mi><mo stretchy="false">)</mo><mtext>&nbsp;</mtext><mi>t</mi><mi>a</mi><mi>g</mi><mrow class="MJX-TeXAtom-ORD"><mn>113</mn></mrow></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> f (x) = 0,2 + 0,4 x ^ 2 + 0,3x \ sin (15 x) + 0,05 \ cos (50 x) \ tag {113} </script></p><br><br>  Ele é construído para valores x de 0 a 1, e os valores ao longo do eixo y variam de 0 a 1. <br><br>  Obviamente, essa função não é trivial.  E você precisa descobrir como calculá-lo usando redes neurais. <br><br>  Nas redes neurais acima, analisamos uma combinação ponderada - <sub>j</sub> w <sub>j</sub> a <sub>j</sub> da produção de neurônios ocultos.  Sabemos como obter controle significativo sobre esse valor.  Mas, como observei anteriormente, esse valor não é igual à saída da rede.  A saída da rede é σ (w <sub>j</sub> w <sub>j</sub> a <sub>j</sub> + b), onde b é o deslocamento do neurônio de saída.  Podemos obter controle diretamente sobre a saída da rede? <br><br>  A solução é desenvolver uma rede neural na qual a saída ponderada da camada oculta seja dada pela equação σ <sup>−1</sup> ⋅ f (x), onde σ <sup>−1</sup> é a função inversa de σ.  Ou seja, queremos que a saída ponderada da camada oculta seja assim: <br><br><img src="https://habrastorage.org/webt/sk/bu/bw/skbubwnwkrrpukeblqe9a1qo8cw.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se isso der certo, a saída de toda a rede será uma boa aproximação de f (x) (defino o deslocamento do neurônio de saída como 0). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Então sua tarefa é desenvolver um NS que se aproxime da função objetivo mostrada acima. Para entender melhor o que está acontecendo, recomendo que você solucione esse problema duas vezes. Pela primeira vez no </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artigo original,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> clique no gráfico e ajuste diretamente as alturas das diferentes saliências. Será bastante fácil você obter uma boa aproximação à função objetivo. O grau de aproximação é estimado pelo desvio médio, a diferença entre a função objetivo e a função que a rede calcula. Sua tarefa é trazer o desvio médio para um valor mínimo. A tarefa é considerada concluída quando o desvio médio não excede 0,40.</font></font><br><br><img src="https://habrastorage.org/webt/jb/qh/j8/jbqhj8kul1dtc6o-nyrm0qxhh_0.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois de obter sucesso, pressione o botão Redefinir, que altera as guias aleatoriamente. Na segunda vez, não toque no gráfico, mas altere os valores h no lado esquerdo do diagrama, tentando elevar o desvio médio para um valor de 0,40 ou menos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E assim, você encontrou todos os elementos necessários para a rede calcular aproximadamente a função f (x)! A aproximação acabou sendo difícil, mas podemos melhorar facilmente o resultado simplesmente aumentando o número de pares de neurônios ocultos, o que aumentará o número de saliências. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em particular, é fácil transformar todos os dados encontrados de volta na visualização padrão com a parametrização usada para o NS. Deixe-me lembrá-lo rapidamente de como isso funciona. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na primeira camada, todos os pesos têm um grande valor constante, por exemplo, w = 1000.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os deslocamentos dos neurônios ocultos são calculados através de b = −s. Assim, por exemplo, para o segundo neurônio oculto, s = 0,2 se transforma em b = -1000 × 0,2 = −200. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A última camada da escala é determinada pelos valores de h. Assim, por exemplo, o valor escolhido para o primeiro h, h = -0,2, significa que os pesos de saída dos dois neurônios ocultos superiores são -0,2 e 0,2, respectivamente. E assim por diante, para toda a camada de pesos de saída. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, o deslocamento do neurônio de saída é 0. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E é isso: temos uma descrição completa do NS, que calcula bem a função objetivo inicial. E entendemos como melhorar a qualidade da aproximação, melhorando o número de neurônios ocultos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Além disso, em nossa função objetivo original f (x) = 0,2 + 0,4x </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ 0,3sin (15x) + 0,05cos (50x) não é nada de especial. </font><font style="vertical-align: inherit;">Um procedimento semelhante pode ser usado para qualquer função contínua nos intervalos de [0,1] a [0,1]. </font><font style="vertical-align: inherit;">De fato, usamos nosso NS de camada única para criar uma tabela de pesquisa para uma função. </font><font style="vertical-align: inherit;">E podemos tomar essa idéia como base para obter uma prova generalizada da universalidade.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Função de muitos parâmetros </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estendemos nossos resultados ao caso de um conjunto de variáveis ​​de entrada. Parece complicado, mas todas as idéias que precisamos já podem ser entendidas para o caso com apenas duas variáveis ​​recebidas. Portanto, consideramos o caso com duas variáveis ​​recebidas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos começar examinando o que acontece quando um neurônio tem duas entradas: </font></font><br><br><img src="https://habrastorage.org/webt/k5/cm/a9/k5cma9i-bgfwxnp2ao9h1wiwfz0.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Temos entradas x e y, com os pesos correspondentes w </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e w </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e deslocamento b do neurônio. Definimos o peso de w </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> como 0 e brincamos com o primeiro, w </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , e deslocamos b para ver como eles afetam a saída do neurônio: </font></font><br><br><img src="https://habrastorage.org/webt/bl/71/6p/bl716pdfanpkwighwk2dc6m20ey.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como você pode ver, com w </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 0, a entrada y não afeta a saída do neurônio. Tudo acontece como se x fosse a única entrada.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diante disso, o que você acha que acontecerá quando aumentarmos o peso de w </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a w </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 100 e w </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> deixar 0? Se isso não estiver claro imediatamente, pense um pouco sobre esse problema. Assista ao vídeo a seguir, que mostra o que vai acontecer:</font></font><br><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Seu navegador não suporta vídeo HTML5. <source src="http://neuralnetworksanddeeplearning.com/movies/step_3d.mp4" type="video/mp4"></video></div></div></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como antes, com um aumento no peso de entrada, a saída se aproxima da forma da etapa. A diferença é que nossa função de etapa agora está localizada em três dimensões. Como antes, podemos mover a localização das etapas alterando o deslocamento. O ângulo estará no ponto s </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ≡ - b / w1. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos refazer o diagrama para que o parâmetro seja o local da etapa: </font></font><br><br><img src="https://habrastorage.org/webt/aw/qs/59/awqs59ahvnac-1i9piafzg2jbpi.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assumimos que o peso de entrada de x seja de grande importância - usei w </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 1000 - e o peso w </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 0. O número no neurônio é a posição do passo, e o x acima nos lembra que movemos o passo ao longo do eixo x. Naturalmente, é bem possível obter uma função de passo ao longo do eixo y, aumentando o peso recebido por y (por exemplo, w </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= 1000), e o peso de x é 0, w </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 0: </font></font><br><br><img src="https://habrastorage.org/webt/xg/zw/y0/xgzwy0jgsj5q1gl3oqgygzqv0nq.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O número no neurônio indica novamente a posição do passo, e y acima dele nos lembra que movemos o passo ao longo do eixo y. Eu poderia designar diretamente os pesos para x e y, mas não o fiz, porque isso iria desarrumar o gráfico. Mas lembre-se de que o marcador y indica que o peso de y é grande e de x é 0. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos usar as funções de etapa que acabamos de projetar para calcular a função de protrusão tridimensional. Para fazer isso, usamos dois neurônios, cada um dos quais calculará uma função de etapa ao longo do eixo x. Em seguida, combinamos essas funções de etapa com os pesos heh, onde h é a altura de protrusão desejada. Tudo isso pode ser visto no diagrama a seguir:</font></font><br><br><img src="https://habrastorage.org/webt/5s/qn/wk/5sqnwkfmm7_uzs3jchov90ylyz8.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tente alterar o valor de h. Veja como isso se relaciona com os pesos da rede. E como ela altera a altura da função de protrusão à direita. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tente também alterar o ponto da etapa, cujo valor é definido como 0,30 no neurônio oculto superior. Veja como ele muda a forma da saliência. O que acontece se você o mover além do ponto 0,70 associado ao neurônio oculto inferior? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aprendemos como construir a função de protrusão ao longo do eixo x. Naturalmente, podemos facilmente fazer a função de protrusão ao longo do eixo y, usando duas funções de passo ao longo do eixo y. Lembre-se de que podemos fazer isso fazendo grandes pesos na entrada ye definindo o peso 0 na entrada x. E então, o que acontece:</font></font><br><br><img src="https://habrastorage.org/webt/ic/uu/fq/icuufqisf9gjv8zccnkg0f0bevc.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parece quase idêntico à rede anterior! A única mudança visível são pequenos marcadores nos neurônios ocultos. Eles nos lembram que produzem funções de passo para y, e não para x, portanto, o peso na entrada y é muito grande, e na entrada x é zero, e não vice-versa. Como antes, decidi não mostrá-lo diretamente, para não confundir a imagem. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos ver o que acontece se adicionarmos duas funções de protrusão, uma ao longo do eixo x, a outra ao longo do eixo y, ambas de altura h: </font></font><br><br><img src="https://habrastorage.org/webt/7f/u7/fc/7fu7fcn8xnl5r4zffk3tpunuedg.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para simplificar o diagrama de conexão com peso zero, eu o omiti. Até agora, deixei pequenos marcadores x e y em neurônios ocultos para lembrar em quais direções as funções de protrusão são calculadas. Mais tarde, nós os recusaremos, pois eles estão implícitos na variável de entrada.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tente alterar o parâmetro h. </font><font style="vertical-align: inherit;">Como você pode ver, por causa disso, os pesos de saída mudam, assim como os pesos de ambas as funções de protrusão, xey. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nossa </font></font><br><br><img src="https://habrastorage.org/webt/ad/le/ww/adlewwyzmc3zhrk-fm9a9yvx6zo.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">criação é um </font><font style="vertical-align: inherit;">pouco como uma "função de torre": </font><font style="vertical-align: inherit;">se podemos criar essas funções de torre, podemos usá-las para aproximar funções arbitrárias simplesmente adicionando torres de várias alturas em lugares diferentes: </font></font><br><br><img src="https://habrastorage.org/webt/u1/lv/xv/u1lvxvdmfi4xxsqgpjabiwofr2k.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">é claro, ainda não alcançamos a criação de uma função de torre arbitrária. </font><font style="vertical-align: inherit;">Até agora, construímos algo como uma torre central de altura 2h, com um platô de altura h ao seu redor. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas podemos fazer uma torre funcionar. </font><font style="vertical-align: inherit;">Lembre-se de que mostramos anteriormente como os neurônios podem ser usados ​​para implementar a instrução if-then-else:</font></font><br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>  &gt;= :  <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>:  <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  Era um neurônio de uma entrada.  E precisamos aplicar uma idéia semelhante à produção combinada de neurônios ocultos: <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>     &gt;= :  <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>:  <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  Se escolhermos o limiar certo - por exemplo, 3h / 2, espremido entre a altura do platô e a altura da torre central - podemos esmagar o platô até zero e deixar apenas uma torre. <br><br>  Imagine como fazer isso?  Tente experimentar a seguinte rede.  Agora, estamos plotando a saída de toda a rede, e não apenas a saída ponderada da camada oculta.  Isso significa que adicionamos o termo de deslocamento à saída ponderada da camada oculta e aplicamos o sigmóide.  Você pode encontrar os valores de he para os quais você obtém uma torre?  Se você ficar preso nesse momento, aqui estão duas dicas: (1) para o neurônio de saída mostrar um comportamento se-então-outro, precisamos que os pesos recebidos (todos h ou –h) sejam grandes;  (2) o valor de b determina a escala do limiar se-então-outro. <br><br><img src="https://habrastorage.org/webt/ys/k-/1u/ysk-1uvu-jo68ikk5rqu274u7wc.png"><br><br>  Com parâmetros padrão, a saída é semelhante a uma versão nivelada do diagrama anterior, com uma torre e um platô.  Para obter o comportamento desejado, você precisa aumentar o valor de h.  Isso nos dará o comportamento do limite do if-then-else.  Em segundo lugar, para definir corretamente o limite, é necessário escolher b −3h / 2. <br><br>  Aqui está o que parece para h = 10: <br><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Seu navegador não suporta vídeo HTML5. <source src="http://neuralnetworksanddeeplearning.com/movies/tower_construction.mp4" type="video/mp4"></video></div></div></div><br>  Mesmo para valores relativamente modestos de h, obtemos uma boa função de torre.  E, é claro, podemos obter um resultado arbitrariamente bonito aumentando h ainda mais e mantendo o viés no nível b = −3h / 2. <br><br>  Vamos tentar colar duas redes para contar duas funções diferentes da torre.  Para esclarecer os respectivos papéis das duas sub-redes, coloquei-os em retângulos separados: cada um deles calcula a função da torre usando a técnica descrita acima.  O gráfico à direita mostra a saída ponderada da segunda camada oculta, ou seja, a combinação ponderada das funções da torre. <br><br><img src="https://habrastorage.org/webt/8-/cl/ke/8-clkebo6vphf1-0_jgoaf3exts.png"><br><br>  Em particular, pode-se observar que, alterando o peso na última camada, é possível alterar a altura das torres de saída. <br><br>  A mesma idéia permite que você calcule quantas torres quiser.  Podemos torná-los arbitrariamente magros e altos.  Como resultado, garantimos que a saída ponderada da segunda camada oculta se aproxime de qualquer função desejada de duas variáveis: <br><br><img src="https://habrastorage.org/webt/ig/0u/5z/ig0u5zbzifftdfq4ww4y9a4r7du.png"><br><br>  Em particular, fazendo com que a saída ponderada da segunda camada oculta se aproxime σ <sup>−1</sup> ⋅ de poço, garantimos que a saída da nossa rede seja uma boa aproximação da função desejada f. <br><br>  E as funções de muitas variáveis? <br><br>  Vamos tentar pegar três variáveis, x <sub>1</sub> , x <sub>2</sub> , x <sub>3</sub> .  A rede a seguir pode ser usada para calcular a função da torre em quatro dimensões? <br><br><img src="https://habrastorage.org/webt/wg/ki/kn/wgkiknicnzeoaept0d-cemw0sd0.png"><br><br>  Aqui x <sub>1</sub> , x <sub>2</sub> , x <sub>3</sub> denotam a entrada de rede.  s <sub>1</sub> , t <sub>1</sub> e assim por diante - os pontos de referência para os neurônios - ou seja, todos os pesos na primeira camada são grandes e as compensações são atribuídas para que os pontos de referência sejam s <sub>1</sub> , t <sub>1</sub> , s <sub>2</sub> , ... Os pesos na segunda camada se alternam, + h, −h, onde h é um número muito grande.  O deslocamento da saída é de -5h / 2. <br><br>  A rede calcula uma função igual a 1 em três condições: x <sub>1</sub> está entre s <sub>1</sub> e t <sub>1</sub> ;  x2 está entre s2 e t2;  x <sub>3</sub> está entre s <sub>3</sub> e t <sub>3</sub> .  A rede é 0 em todos os outros lugares.  Esta é uma torre na qual 1 é uma pequena porção do espaço de entrada e 0 é todo o resto. <br><br>  Ao colar muitas dessas redes, podemos obter quantas torres quisermos e aproximar uma função arbitrária de três variáveis.  A mesma idéia funciona em m dimensões.  Somente o deslocamento da saída (−m + 1/2) h é alterado para comprimir adequadamente os valores desejados e remover o platô. <br><br>  Bem, agora sabemos como usar o NS para aproximar a função real de muitas variáveis.  E as funções vetoriais f (x <sub>1</sub> , ..., x <sub>m</sub> ) ∈ R <sup>n</sup> ?  Obviamente, essa função pode ser considerada simplesmente como n funções reais separadas f1 (x <sub>1</sub> , ..., x <sub>m</sub> ), f2 (x <sub>1</sub> , ..., x <sub>m</sub> ) e assim por diante.  E então apenas colamos todas as redes juntas.  Portanto, é fácil descobrir isso. <br><br><h3>  Desafio </h3><br><ul><li>  Vimos como usar redes neurais com duas camadas ocultas para aproximar uma função arbitrária.  Você pode provar que isso é possível com uma camada oculta?  Dica - tente trabalhar com apenas duas variáveis ​​de saída e mostre que: (a) é possível obter as funções das etapas não apenas ao longo dos eixos x ou y, mas também em uma direção arbitrária;  (b) somando muitas construções da etapa (a), é possível aproximar a função de uma torre redonda e não retangular;  © usando torres redondas, é possível aproximar uma função arbitrária.  A etapa © será mais fácil de usar usando o material apresentado neste capítulo, um pouco abaixo. </li></ul><br><h2>  Indo além dos neurônios sigmóides </h2><br>  Provamos que uma rede de neurônios sigmóides pode calcular qualquer função.  Lembre-se de que em um neurônio sigmóide, as entradas x <sub>1</sub> , x <sub>2</sub> , ... se transformam na saída em σ (w <sub>j</sub> w <sub>j</sub> x <sub>j j</sub> + b), onde w <sub>j</sub> são os pesos, b é o viés e σ é o sigmóide. <br><br><img src="https://habrastorage.org/webt/0h/ut/93/0hut93wneejtjvxvxiwnfwpmo40.png"><br><br>  E se olharmos para outro tipo de neurônio usando uma função de ativação diferente, s (z): <br><br><img src="https://habrastorage.org/webt/ua/0-/it/ua0-itpxz-uwkpnptxfsvszqabg.png"><br><br>  Ou seja, assumimos que se um neurônio tem x <sub>1</sub> , x <sub>2</sub> , ... pesos w <sub>1</sub> , w <sub>2</sub> , ... e viés b, então s (∑ <sub>j</sub> w <sub>j</sub> x <sub>j</sub> + b) será emitido. <br><br>  Nós podemos usar esta função de ativação para sermos pisados, assim como no caso do sigmóide.  Tente (no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo original</a> ) no diagrama elevar o peso para, digamos, w = 100: <br><br><img src="https://habrastorage.org/webt/vz/-v/mu/vz-vmulc79w1g7xxom_btmnfyow.png"><br><br><img src="https://habrastorage.org/webt/nf/aq/iz/nfaqiznhl2klhebfc33iiy6htrg.png"><br><br>  Como no caso do sigmóide, por causa disso, a função de ativação é compactada e, como resultado, se transforma em uma aproximação muito boa da função de passo.  Tente alterar o deslocamento, e você verá que podemos alterar a localização da etapa para qualquer.  Portanto, podemos usar todos os mesmos truques de antes para calcular qualquer função desejada. <br><br>  Quais propriedades s (z) devem ter para que isso funcione?  Precisamos assumir que s (z) está bem definido como z → − e z → ∞.  Esses limites são dois valores aceitos pela nossa função step.  Também precisamos assumir que esses limites são diferentes.  Se eles não diferissem, as etapas não funcionariam; simplesmente haveria um horário fixo!  Mas se a função de ativação s (z) satisfaz essas propriedades, os neurônios baseados nela são universalmente adequados para cálculos. <br><br><h3>  As tarefas </h3><br><ul><li>  No início do livro, encontramos um tipo diferente de neurônio - um neurônio linear endireitado ou uma unidade linear retificada, ReLU.  Explique por que esses neurônios não satisfazem as condições necessárias para a universalidade.  Encontre evidências de versatilidade, mostrando que as ReLUs são universalmente adequadas para computação. </li><li>  Suponha que estamos considerando neurônios lineares, com a função de ativação s (z) = z.  Explique por que os neurônios lineares não satisfazem as condições da universalidade.  Mostre que esses neurônios não podem ser usados ​​para computação universal. </li></ul><br><h2>  Função de correção de etapa </h2><br>  Por enquanto, assumimos que nossos neurônios produzem funções precisas de passos.  Esta é uma boa aproximação, mas apenas uma aproximação.  De fato, há uma lacuna estreita de falha, mostrada no gráfico a seguir, onde as funções não se comportam como uma função de etapa: <br><br><img src="https://habrastorage.org/webt/mr/0t/ng/mr0tng4l1giob-gsuhyo_oh_vk0.png"><br><br>  Nesse período de fracasso, minha explicação da universalidade não funciona. <br><br>  O fracasso não é tão assustador.  Ao definir pesos de entrada suficientemente grandes, podemos reduzir esses espaços arbitrariamente pequenos.  Podemos torná-los muito menores do que no gráfico, invisíveis aos olhos.  Talvez não tenhamos que nos preocupar com esse problema. <br><br>  No entanto, eu gostaria de ter uma maneira de resolvê-lo. <br><br>  Acontece que é fácil de resolver.  Vamos analisar esta solução para calcular as funções do NS com apenas uma entrada e saída.  As mesmas idéias trabalharão para resolver o problema com um grande número de entradas e saídas. <br><br>  Em particular, suponha que queremos que nossa rede calcule alguma função f.  Como antes, tentamos fazer isso projetando a rede para que a saída ponderada da camada oculta de neurônios seja σ <sup>−1</sup> ⋅ f (x): <br><br><img src="https://habrastorage.org/webt/sk/bu/bw/skbubwnwkrrpukeblqe9a1qo8cw.png"><br><br>  Se fizermos isso usando a técnica descrita acima, forçaremos os neurônios ocultos a produzir uma sequência de funções de protrusão: <br><br><img src="https://habrastorage.org/webt/71/uc/x_/71ucx_26mzx0_isj6dlob9wdacq.png"><br><br>  É claro que exagerei o tamanho dos intervalos de falha, para que fosse mais fácil ver.  Deve ficar claro que, se somarmos todas essas funções das saliências, obteremos uma aproximação bastante boa de σ <sup>−1</sup> ⋅ f (x) em todos os lugares, exceto nos intervalos de falha. <br><br>  Mas suponha que, em vez de usar a aproximação descrita, usamos um conjunto de neurônios ocultos para calcular a aproximação de metade da nossa função objetivo original, ou seja, σ <sup>−1</sup> ⋅ f (x) / 2.  Obviamente, será parecido com uma versão em escala do gráfico mais recente: <br><br><img src="https://habrastorage.org/webt/8-/0b/fv/8-0bfvrf5njiwum-w6d8edu4dro.png"><br><br>  E suponha que façamos mais um conjunto de neurônios ocultos calcular a aproximação de σ <sup>−1</sup> ⋅ f (x) / 2, no entanto, em sua base, as saliências serão deslocadas pela metade de sua largura: <br><br><img src="https://habrastorage.org/webt/dj/cz/7n/djcz7nxhhm98yhiq94uluglvm-m.png"><br><br>  Agora temos duas aproximações diferentes para σ - 1⋅f (x) / 2.  Se somarmos essas duas aproximações, obteremos uma aproximação geral para σ - 1⋅f (x).  Essa aproximação geral ainda terá imprecisões em pequenos intervalos.  Mas o problema será menor do que antes - porque os pontos que caem nos intervalos da falha da primeira aproximação não caem nos intervalos da falha da segunda aproximação.  Portanto, a aproximação nesses intervalos será aproximadamente duas vezes melhor. <br><br>  Podemos melhorar a situação adicionando um número grande, M, de aproximações sobrepostas da função σ - 1⋅f (x) / M.  Se todos os intervalos de falha forem estreitos o suficiente, qualquer corrente estará em apenas um deles.  Se você usar um número suficientemente grande de aproximações sobrepostas de M, o resultado será uma excelente aproximação geral. <br><br><h2>  Conclusão </h2><br>  A explicação da universalidade discutida aqui definitivamente não pode ser chamada de uma descrição prática de como contar funções usando redes neurais!  Nesse sentido, é mais uma prova da versatilidade dos portões lógicos da NAND e muito mais.  Portanto, eu basicamente tentei tornar esse design claro e fácil de seguir, sem otimizar seus detalhes.  No entanto, tentar otimizar esse design pode ser um exercício interessante e instrutivo para você. <br><br>  Embora o resultado obtido não possa ser usado diretamente para criar o NS, é importante porque remove a questão da computabilidade de qualquer função específica usando o NS.  A resposta para essa pergunta sempre será positiva.  Portanto, é correto perguntar se alguma função é computável, mas qual é a maneira correta de calculá-la. <br><br>  Nosso design universal usa apenas duas camadas ocultas para calcular uma função arbitrária.  Como discutimos, é possível obter o mesmo resultado com uma única camada oculta.  Diante disso, você pode se perguntar por que precisamos de redes profundas, ou seja, redes com um grande número de camadas ocultas.  Não podemos simplesmente substituir essas redes por redes rasas que possuem uma camada oculta? <br><br>  Embora, em princípio, seja possível, existem boas razões práticas para o uso de redes neurais profundas.  Conforme descrito no Capítulo 1, os NSs profundos têm uma estrutura hierárquica que lhes permite adaptar-se bem ao estudo do conhecimento hierárquico, que é útil para resolver problemas reais.  Mais especificamente, ao resolver problemas como o reconhecimento de padrões, é útil usar um sistema que compreenda não apenas pixels individuais, mas também conceitos cada vez mais complexos: de bordas a formas geométricas simples e além, a cenas complexas envolvendo vários objetos.  Em capítulos posteriores, veremos evidências a favor do fato de que NSs profundas serão mais capazes de lidar com o estudo de tais hierarquias de conhecimento do que as rasas.  Resumindo: a universalidade nos diz que o NS pode calcular qualquer função;  evidências empíricas sugerem que NSs profundas são melhor adaptadas ao estudo de funções úteis para resolver muitos problemas do mundo real. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt461659/">https://habr.com/ru/post/pt461659/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt461649/index.html">Como vou salvar o mundo</a></li>
<li><a href="../pt461651/index.html">Frontend Weekly Digest (22 a 28 de julho de 2019)</a></li>
<li><a href="../pt461653/index.html">Rádio definido por software - como funciona? Parte 10</a></li>
<li><a href="../pt461655/index.html">O resumo de materiais frescos do mundo do front-end da última semana n ° 373 (22 a 28 de julho de 2019)</a></li>
<li><a href="../pt461657/index.html">Comprando a Red Hat: Ajudará a luta gigante azul pela liderança em nuvens híbridas</a></li>
<li><a href="../pt461661/index.html">Guia de Desenvolvimento Baseado em Componentes</a></li>
<li><a href="../pt461663/index.html">A história de como o Linux trouxe o Windows</a></li>
<li><a href="../pt461665/index.html">Zen2. A evolução da plataforma AM4 no exemplo da Ryzen 7 3700x</a></li>
<li><a href="../pt461669/index.html">PHP Digest No. 161 (15 a 29 de julho de 2019)</a></li>
<li><a href="../pt461673/index.html">8 dicas para programadores iniciantes ou uma retrospectiva da minha carreira</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>