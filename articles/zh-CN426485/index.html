<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😑 🌆 👩🏼‍⚖️ PVS-Studio进行的第三次Qt 5测试 🕵🏼 🌘 👰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我们的团队会不时地重新检查我们已经写过的项目。 另一个经过重新检查的项目是Qt。 我们上一次在2014年用PVS-Studio测试它。 自2014年以来，在Coverity的帮助下开始定期检查该项目。 这很有趣。 让我们看看是否现在可以使用PVS-Studio查找任何有趣的错误。 

 t 
 以前...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PVS-Studio进行的第三次Qt 5测试</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/426485/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dd9/87d/907/dd987d90784865f850555bc198a97b81.png" alt="PVS-Studio和Qt"></div><br> 我们的团队会不时地重新检查我们已经写过的项目。 另一个经过重新检查的项目是Qt。 我们上一次在2014年用PVS-Studio测试它。 自2014年以来，在Coverity的帮助下开始定期检查该项目。 这很有趣。 让我们看看是否现在可以使用PVS-Studio查找任何有趣的错误。 <br><a name="habracut"></a><br><h2>  t </h2><br> 以前的文章： <br><br><ul><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">如何减少在编写代码阶段出现错误的可能性</a> ”，2011年7月。 </li><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Qt 5框架检查</a> ”，2014年4月。 </li></ul><br> 这次测试了<a href="">Qt Base</a> （Core，Gui，Widgets，Network等）和<a href="">Qt5超级模块</a> 。 关于Qt Creator，我们计划稍后再写一篇单独的文章。 为了进行验证，我们使用了PVS-Studio静态分析仪，您可以从网站上<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">下载</a>其试用版。 <br><br> 在我看来，Qt代码已经变得更好。 自上次测试以来，多年来，PVS-Studio分析仪中出现了许多新的诊断方法。 尽管如此，在对警告的回顾研究中，我发现这个规模的项目没有太多错误。 我再说一遍，这是我个人的印象。 我那时或现在都没有对错误的密度做任何特殊的研究。 <br><br> 最有可能的是，使用Coverity静态分析器进行的定期检查很可能会影响代码的质量。  2014年，在Coverity的帮助下，开始检查Qt项目（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">qt-project</a> ），并在2016年检查了Qt Creator（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">qt-creator</a> ）。 我的看法：如果您正在开发一个开源项目，那么<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Coverity Scan</a>可以是一个很好的免费解决方案，它将显着提高项目的质量和可靠性。 <br><br> 但是，正如读者可以猜测的那样，如果我没有在PVS-Studio报告中注意到任何有趣的事情，那么就不会有文章了：）。 既然有一篇文章，那就是缺陷。 让我们看看它们。 总共我写出96个错误。 <br><br><h2> 复制粘贴和错字不成功 </h2><br> 让我们从流派的经典开始，当错误的原因是注意力不集中时。 这些错误被程序员低估了。 对于那些尚未阅读的人，建议您阅读以下两篇文章： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">最后一行效果</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">邪恶生活在比较功能中</a> </li></ul><br> 这些错误是中间语言。 例如，第二篇文章提供了许多用C，C ++和C＃编写的比较函数中的错误示例。 现在，在PVS-Studio中实现Java语言支持时，我们会遇到相同的错误模式。 例如，这是我们最近在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Hibernate</a>库中发现的错误： <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object other)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (other instanceof Id) { Id that = (Id) other; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> purchaseSequence.equals(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.purchaseSequence) &amp;&amp; that.purchaseNumber == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.purchaseNumber; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br> 如果仔细观察，结果是将<i>purchaseSequence</i>字段与其自身进行了比较。 正确的选项： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> that.purchaseSequence.equals(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.purchaseSequence) &amp;&amp; that.purchaseNumber == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.purchaseNumber;</code> </pre> <br> 总的来说，一切都一如既往，PVS-Studio分析仪将不得不在Java项目中“夺取Augean马“”。 顺便说一下，我们邀请所有人参加测试PVS-Studio for Java的Beta版，该版本将在不久的将来出现。 为此，请<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">写信给我们</a> （选择“我想要Java的分析器”）。 <br><br> 现在回到Qt项目中的错误。 <br><br>  <b>缺陷N1</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">windowDpiAwareness</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HWND hwnd)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QWindowsContext::user32dll.getWindowDpiAwarenessContext &amp;&amp; QWindowsContext::user32dll.getWindowDpiAwarenessContext ? QWindowsContext::user32dll.getAwarenessFromDpiAwarenessContext( QWindowsContext::user32dll.getWindowDpiAwarenessContext(hwnd)) : <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre> <br>  PVS-Studio警告：V501 CWE-571在'&amp;&amp;'运算符的左侧和右侧有相同的子表达式'QWindowsContext :: user32dll.getWindowDpiAwarenessContext'。  qwindowscontext.cpp 150 <br><br> 除了分析仪消息外，此处不需要任何特殊说明。 在我看来，该表达式应该像这样： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QWindowsContext::user32dll.getAwarenessFromDpiAwarenessContext &amp;&amp; QWindowsContext::user32dll.getWindowDpiAwarenessContext ? QWindowsContext::user32dll.getAwarenessFromDpiAwarenessContext( QWindowsContext::user32dll.getWindowDpiAwarenessContext(hwnd)) : <span class="hljs-number"><span class="hljs-number">-1</span></span>;</code> </pre> <br>  <b>缺陷N2，N3</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> QReadWriteLockPrivate::release() { Q_ASSERT(!recursive); Q_ASSERT(!waitingReaders &amp;&amp; !waitingReaders &amp;&amp; !readerCount &amp;&amp; !writerCount); freelist-&gt;release(id); }</code> </pre> <br>  PVS-Studio警告：V501 CWE-571'&amp;&amp;'运算符的左侧和右侧有相同的子表达式：！WaitingReaders &amp;&amp; !! WaitingReaders qreadwritelock.cpp 632 <br><br> 该错误在<i>Q_ASSERT</i>宏<i>条件</i>内部，因此不重要。 但这仍然是一个错误。  <i>仔细</i>检查了<i>waitingReaders</i>变量。 显然他们忘记了检查其他变量。 <br><br> 在qreadwritelock.cpp文件的625行中发现了相同的错误。 复制粘贴万岁！  :) <br><br>  <b>缺陷N4</b> <br><br><pre> <code class="cpp hljs">QString QGraphicsSceneBspTree::debug(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node-&gt;type == Node::Horizontal) { tmp += debug(firstChildIndex(index)); tmp += debug(firstChildIndex(index) + <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { tmp += debug(firstChildIndex(index)); tmp += debug(firstChildIndex(index) + <span class="hljs-number"><span class="hljs-number">1</span></span>); } .... }</code> </pre> <br>  PVS-Studio警告：V523 CWE-691'then'语句等效于'else'语句。  qgraphicsscene_bsp.cpp 179 <br><br> 最有可能复制了该文本块，但他们忘记了对其进行更正。 <br><br>  <b>缺陷N5</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> FillRule { OddEvenFill, WindingFill }; QDataStream &amp;<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;&gt;(QDataStream &amp;s, QPainterPath &amp;p) { .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fillRule; s &gt;&gt; fillRule; Q_ASSERT(fillRule == Qt::OddEvenFill || Qt::WindingFill); .... }</code> </pre> <br>  PVS-Studio警告：V768 CWE-571枚举常量'WindingFill'用作布尔型变量。  qpainterpath.cpp 2479 <br><br> 同意，这是一个美丽的家伙！  <i>Q_ASSERT</i>不检查任何内容，因为条件始终为true。 条件成立，因为命名常量<i>Qt :: WindingFill</i>为1。 <br><br>  <b>缺陷N6</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> QVariant::canConvert(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> targetTypeId) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentType == QMetaType::SChar || currentType == QMetaType::Char) currentType = QMetaType::UInt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (targetTypeId == QMetaType::SChar || currentType == QMetaType::Char) targetTypeId = QMetaType::UInt; .... }</code> </pre> <br> 阅读警告之前，请尝试自己找出一个错字。 通过添加图片，我将帮助您不要立即阅读分析器消息:)。 <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/86f/f1d/7c5/86ff1d7c55cdc0fb71cbce45f2f84f05.png" alt="该思考了"></div><br><br>  PVS-Studio警告：V560 CWE-570条件表达式的一部分始终为false：currentType == QMetaType :: Char。  qvariant.cpp 3529 <br><br> 在条件<i>if</i>中首先检查条件“ currentType == QMetaType :: Char”。 如果满足条件，则为变量<i>currentType</i>分配值<i>QMetaType :: UInt</i> 。 因此，变量<i>currentType</i>不再可以等于<i>QMetaType :: Char</i> 。 因此，分析器报告第二个子表达式“ currentType == QMetaType :: Char”始终为假。 <br><br> 实际上，第二个<i>if</i>应该是这样的： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (targetTypeId == QMetaType::SChar || targetTypeId == QMetaType::Char) targetTypeId = QMetaType::UInt;</code> </pre> <br><br>  <b>V560诊断说明</b> <br><br> 该报告发现了许多V560警告。 但是，一旦发现这篇文章的有趣案例，我就不再查看它们了，该案例在上面被认为是缺陷N6。 <br><br> 绝大多数消息V560不能被称为假，但是它们没有用。 换句话说，在文章中描述它们并不有趣。 为了弄清楚我到底是什么意思，请考虑一种这样的情况。 <br><br><pre> <code class="cpp hljs">QString QTextHtmlExporter::findUrlForImage(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QTextDocument *doc, ....) { QString url; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!doc) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> url; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (QTextDocument *parent = qobject_cast&lt;QTextDocument *&gt;(doc-&gt;parent())) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> findUrlForImage(parent, cacheKey, isPixmap); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (doc &amp;&amp; doc-&gt;docHandle()) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... }</span></span></code> </pre> <br> 警告PVS-Stuidio：V560 CWE-571条件表达式的一部分始终为true：doc。  qtextdocument.cpp 2992 <br><br> 分析器是绝对正确的，它在重新检查时<i>doc</i>指针并不总是为<i>nullptr</i> 。 但这不是一个错误，只是程序员是安全的。 您可以通过编写以下代码来简化代码： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (doc-&gt;docHandle()) {</code> </pre> <br>  <b>缺陷N7</b> <br><br> 最后一种情况，可以归类为错别字。 出现错误是由于常量名称混乱，仅在首字母不同的情况下。 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QWindowsCursor</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QPlatformCursor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> CursorState { CursorShowing, CursorHidden, CursorSuppressed }; .... } QWindowsCursor::CursorState QWindowsCursor::cursorState() { <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { cursorShowing = <span class="hljs-number"><span class="hljs-number">0x1</span></span>, cursorSuppressed = <span class="hljs-number"><span class="hljs-number">0x2</span></span> }; CURSORINFO cursorInfo; cursorInfo.cbSize = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(CURSORINFO); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GetCursorInfo(&amp;cursorInfo)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cursorInfo.flags &amp; CursorShowing) .... }</code> </pre> <br>  PVS-Studio警告：V616 CWE-480在按位操作中使用名为“ CursorShowing”的常量，值为0。  qwindowscursor.cpp 669 <br><br> 更详细地讲，我已经在一个单独的小笔记中分析了此错误：“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">再次证明，PVS-Studio分析仪</a>比<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">人更专心</a> 。” <br><br><h2> 安全漏洞 </h2><br> 实际上，本文中讨论的所有错误都可以称为安全缺陷。 它们均根据<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">常见弱点枚举</a>进行分类（请参阅分析器消息中的CWE ID）。 如果将错误分类为CWE，则可能存在安全风险。 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PVS-Studio SAST页</a>上对此进行了详细说明。 <br><br> 但是，我想将一些错误归为一个单独的小组。 让我们看看它们。 <br><br>  <b>缺陷N8，N9</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> QLocalServerPrivate::addListener() { .... SetSecurityDescriptorOwner(pSD.data(), pTokenUser-&gt;User.Sid, FALSE); SetSecurityDescriptorGroup(pSD.data(), pTokenGroup-&gt;PrimaryGroup, FALSE); .... }</code> </pre> <br>  PVS-Studio警告： <br><br><ul><li>  V530 CWE-252需要使用函数'SetSecurityDescriptorOwner'的返回值。  qlocalserver_win.cpp 167 </li><li>  V530 CWE-252需要使用功能'SetSecurityDescriptorGroup'的返回值。  qlocalserver_win.cpp 168 </li></ul><br> 有与访问控制有关的各种功能。 函数<i>SetSecurityDescriptorOwner</i>和<i>SetSecurityDescriptorGroup</i>就在其中。 <br><br> 使用此类功能，您需要非常小心地工作。 例如，您必须检查它们返回的状态。 如果对这些函数的调用失败，会发生什么？ 猜测不是必需的，有必要编写代码来处理这种情况。 <br><br> 不必利用缺乏验证的优势并将此类错误转化为漏洞。 但是，在任何情况下都不存在风险，您需要编写更安全的代码。 <br><br>  <b>缺陷N10</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> QLocalServerPrivate::addListener() { .... InitializeAcl(acl, aclSize, ACL_REVISION_DS); .... }</code> </pre> <br>  PVS-Studio警告：V530 CWE-252需要使用函数“ InitializeAcl”的返回值。  qlocalserver_win.cpp 144 <br><br> 这种情况类似于上面讨论的情况。 <br><br>  <b>缺陷N11，N12</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sha1ProcessChunk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... quint8 chunkBuffer[<span class="hljs-number"><span class="hljs-number">64</span></span>]; .... <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> SHA1_WIPE_VARIABLES .... memset(chunkBuffer, 0, 64); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre> <br>  PVS-Studio警告：V597 CWE-14编译器可能会删除“ memset”函数调用，该函数调用用于刷新“ chunkBuffer”缓冲区。  RtlSecureZeroMemory（）函数应用于擦除私有数据。 第189章 <br><br> 编译器将删除<i>memset</i>函数调用。 我已经在文章中多次分析了这种情况。 我不想重复自己。 我指的是“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">安全清除私有数据</a> ”一文。 <br><br> 另一个错误是在同一个sha1.cpp文件中，在第247行。 <br><br><h2> 空指针 </h2><br> 现在该谈论指针了。 在这个话题上有很多错误。 <br><br>  <b>缺陷N13</b> <br><br><pre> <code class="cpp hljs">QByteArray &amp;QByteArray::append(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *str, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (len &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) len = qstrlen(str); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (str &amp;&amp; len) { .... }</code> </pre> <br>  PVS-Studio警告：V595 CWE-476在针对nullptr进行验证之前，已使用了'str'指针。 检查行：2118，2119。qbytearray.cpp 2118 <br><br> 典型的情况是，在开始时使用指针，然后检查<i>nullptr是否</i>相等。 这是一个非常常见的错误模式，我们几乎在所有项目中都经常<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">看到</a>它。 <br><br>  <b>缺陷N14，N15</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> QMetaObjectPrivate *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">priv</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uint* data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QMetaObjectPrivate*&gt;(data); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> QMetaEnum::isFlag() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset = priv(mobj-&gt;d.data)-&gt;revision &gt;= <span class="hljs-number"><span class="hljs-number">8</span></span> ? <span class="hljs-number"><span class="hljs-number">2</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mobj &amp;&amp; mobj-&gt;d.data[handle + offset] &amp; EnumIsFlag; }</code> </pre> <br>  PVS-Studio警告：V595 CWE-476在针对nullptr进行验证之前，已使用了'mobj'指针。 检查行：2671，2672。qmetaobject.cpp 2671 <br><br> 以防万一，我带来了<i>priv</i>函数的主体。 由于某些原因，有时读者会想出代码可以工作的情况。 我不知道这种不信任来自何处，也不希望看到错误的棘手功能:)。 例如，某人可能在评论中建议<i>priv</i>是以下形式的宏： <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> priv(A) foo(sizeof(A))</span></span></code> </pre> <br> 然后一切都会正常。 <br><br> 为了避免此类讨论，我尝试引用代码片段，其中提供了所有确认错误存在的信息。 <br><br> 因此， <i>modj</i>指针<i>被</i>取消引用，然后检查。 <br><br> 现场还出现了“强大而可怕的”复制粘贴。 由于在<i>isScoped</i>函数中检测到完全相同的错误，因此： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> QMetaEnum::isScoped() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset = priv(mobj-&gt;d.data)-&gt;revision &gt;= <span class="hljs-number"><span class="hljs-number">8</span></span> ? <span class="hljs-number"><span class="hljs-number">2</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mobj &amp;&amp; mobj-&gt;d.data[handle + offset] &amp; EnumIsScoped; }</code> </pre> <br>  PVS-Studio警告：V595 CWE-476在针对nullptr进行验证之前，已使用了'mobj'指针。 检查行：2683、2684。qmetaobject.cpp 2683 <br><br>  <b>缺陷N16-N21</b> <br><br> 考虑另一个例子，我认为足够了。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> QTextCursor::insertFragment(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QTextDocumentFragment &amp;fragment) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!d || !d-&gt;priv || fragment.isEmpty()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; d-&gt;priv-&gt;beginEditBlock(); d-&gt;remove(); fragment.d-&gt;insert(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); d-&gt;priv-&gt;endEditBlock(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fragment.d &amp;&amp; fragment.d-&gt;doc) d-&gt;priv-&gt;mergeCachedResources(fragment.d-&gt;doc-&gt;docHandle()); }</code> </pre> <br>  PVS-Studio警告：V595 CWE-476在对nullptr进行验证之前，已使用了'fragment.d'指针。 检查行：2238、2241。qtextcursor.cpp 2238 <br><br> 都一样 注意存储在变量<i>fragment.d中</i>的指针的工作顺序。 <br><br> 此类型的其他错误： <br><br><ul><li>  V595 CWE-476在针对nullptr验证之前使用了“窗口”指针。 检查行：1846、1848。qapplication.cpp 1846 </li><li>  V595 CWE-476在针对nullptr验证之前使用了“窗口”指针。 检查行：1858、1860。qapplication.cpp 1858 </li><li>  V595 CWE-476在针对nullptr进行验证之前，已使用了“答复”指针。 检查行：492、502。qhttpnetworkconnectionchannel.cpp 492 </li><li>  V595 CWE-476在针对nullptr对其进行验证之前，已使用了'newHandle'指针。 检查行：877，883。qsplitter.cpp 877 </li><li>  V595 CWE-476在针对nullptr对其进行验证之前，已使用了“小部件”指针。 检查行：2320、2322。qwindowsvistastyle.cpp 2320 </li><li> 实际上，还有更多错误。 我很快就厌倦了学习V595警告，对于这篇文章，我已经写出了足够的代码片段。 </li></ul><br>  <b>缺陷N22-N33</b> <br><br> 在代码中检查了<i>新</i>操作符返回的指针。 在很多地方不检查<i>malloc</i>函数结果的情况下，这尤其有趣（请参阅以下错误组）。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> QTranslatorPrivate::do_load(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString &amp;realname, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString &amp;directory) { .... d-&gt;unmapPointer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[d-&gt;unmapLength]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d-&gt;unmapPointer) { file.seek(<span class="hljs-number"><span class="hljs-number">0</span></span>); qint64 readResult = file.read(d-&gt;unmapPointer, d-&gt;unmapLength); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (readResult == qint64(unmapLength)) ok = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } .... }</code> </pre> <br>  PVS-Studio警告：V668 CWE-571对'd-&gt; unmap Pointer'指针针对null进行测试没有任何意义，因为使用'new'运算符分配了内存。 如果内存分配错误，将生成异常。  qtranslator.cpp 596 <br><br> 检查指针没有意义，因为在发生内存分配错误的情况下，将<i>引发</i>异常<i>std :: bad_alloc</i> 。 如果要让<i>新</i>运算符在没有足够内存的情况下返回<i>nullptr</i> ，则应编写： <br><br><pre> <code class="cpp hljs">d-&gt;unmapPointer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::nothrow) <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[d-&gt;unmapLength];</code> </pre> <br> 分析器知道使用<i>新</i>运算符的情况，在这种情况下不会发出警告。 <br><br> 其他错误：我将给他们<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">qt-V668.txt文件</a> 。 <br><br>  <b>缺陷N34-N70</b> <br><br> 如所承诺的，现在轮到它们不检查调用<i>malloc</i> ， <i>calloc</i> ， <i>strdup</i>等函数的结果时了。 这些错误比乍看之下要严重得多。 更多详细信息：“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">检查malloc函数返回什么为什么很重要</a> 。” <br><br><pre> <code class="cpp hljs">SourceFiles::SourceFiles() { nodes = (SourceFileNode**)<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(SourceFileNode*)*(num_nodes=<span class="hljs-number"><span class="hljs-number">3037</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = <span class="hljs-number"><span class="hljs-number">0</span></span>; n &lt; num_nodes; n++) nodes[n] = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; }</code> </pre> <br>  PVS-Studio警告：V522 CWE-690可能会取消引用潜在的空指针“节点”。 检查行：138，136。makefiledeps.cpp 138 <br><br> 该指针无需事先验证即可使用。 <br><br> 所有这些错误属于同一类型，因此我将不对其进行详细介绍。 我将给出其他警告列表： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">qt-V522-V575.txt</a> 。 <br><br><h2> 条件中的逻辑错误 </h2><br>  <b>缺陷N71</b> <br><br><pre> <code class="cpp hljs">QString QEdidParser::parseEdidString(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> quint8 *data) { <span class="hljs-function"><span class="hljs-function">QByteArray </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">reinterpret_cast</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *&gt;(data), </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">13</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// Erase carriage return and line feed buffer = buffer.replace('\r', '\0').replace('\n', '\0'); // Replace non-printable characters with dash for (int i = 0; i &lt; buffer.count(); ++i) { if (buffer[i] &lt; '\040' &amp;&amp; buffer[i] &gt; '\176') buffer[i] = '-'; } return QString::fromLatin1(buffer.trimmed()); }</span></span></code> </pre> <br>  PVS-Studio警告：V547 CWE-570表达式'buffer [i] &lt;'\ 040'&amp;&amp; buffer [i]&gt;'\ 176'始终为假。  qedidparser.cpp 169 <br><br> 该功能必须执行以下操作“用破折号替换不可打印的字符”。 但是，她没有。 让我们仔细看看这种情况： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer[i] &lt; <span class="hljs-string"><span class="hljs-string">'\040'</span></span> &amp;&amp; buffer[i] &gt; <span class="hljs-string"><span class="hljs-string">'\176'</span></span>)</code> </pre> <br> 这没有道理。 字符不能同时小于“ \ 040”并大于“ \ 176”。 在这种情况下，必须使用运算符“ ||”。 正确的代码是： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer[i] &lt; <span class="hljs-string"><span class="hljs-string">'\040'</span></span> || buffer[i] &gt; <span class="hljs-string"><span class="hljs-string">'\176'</span></span>)</code> </pre> <br>  <b>缺陷N72</b> <br><br> 由于Windows用户不走运，出现了类似的错误。 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(Q_OS_WIN) static QString driveSpec(const QString &amp;path) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (path.size() </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; 2) return QString(); char c = path.at(0).toLatin1(); if (c &lt; 'a' &amp;&amp; c &gt; 'z' &amp;&amp; c &lt; 'A' &amp;&amp; c &gt; 'Z') return QString(); if (path.at(1).toLatin1() != ':') return QString(); return path.mid(0, 2); } #endif</span></span></span></span></code> </pre> <br> 分析仪立即生成两个警告： <br><br><ul><li>  V590 CWE-571考虑检查'c &lt;'a'&amp;&amp; c&gt;'z'&amp;&amp; c &lt;'A'&amp;&amp; c&gt;'Z''表达式。 表达式过多或打印错误。  qdir.cpp 77 </li><li>  V560 CWE-570条件表达式的一部分始终为false：c&gt;'z'。  qdir.cpp 77 </li></ul><br> 逻辑错误处于以下情况： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c &lt; <span class="hljs-string"><span class="hljs-string">'a'</span></span> &amp;&amp; c &gt; <span class="hljs-string"><span class="hljs-string">'z'</span></span> &amp;&amp; c &lt; <span class="hljs-string"><span class="hljs-string">'A'</span></span> &amp;&amp; c &gt; <span class="hljs-string"><span class="hljs-string">'Z'</span></span>)</code> </pre> <br> 据我了解，程序员希望找到一个不是拉丁字母的字符。 在这种情况下，条件应如下所示： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((c &lt; <span class="hljs-string"><span class="hljs-string">'a'</span></span> || c &gt; <span class="hljs-string"><span class="hljs-string">'z'</span></span>) &amp;&amp; (c &lt; <span class="hljs-string"><span class="hljs-string">'A'</span></span> || c &gt; <span class="hljs-string"><span class="hljs-string">'Z'</span></span>))</code> </pre> <br>  <b>缺陷N73</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> SelectionMode { NoSelection, SingleSelection, MultiSelection, ExtendedSelection, ContiguousSelection }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> QAccessibleTableCell::unselectCell() { QAbstractItemView::SelectionMode selectionMode = view-&gt;selectionMode(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_index.isValid() || (selectionMode &amp; QAbstractItemView::NoSelection)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; .... }</code> </pre> <br>  PVS-Studio警告：V616 CWE-480在按位运算中使用名为“ QAbstractItemView :: NoSelection”的常量（值为0）。  itemviews.cpp 976 <br><br> 命名常量<i>QAbstractItemView :: NoSelection</i>为零。 因此，子表达式<i>（selectionMode和QAbstractItemView :: NoSelection）</i>没有意义。 永远为0。 <br><br> 我认为应该在这里写： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_index.isValid() || (selectionMode == QAbstractItemView::NoSelection))</code> </pre> <br>  <b>缺陷N74</b> <br><br> 以下代码使我难以理解。 他错了，但我不知道他应该是什么。 对函数进行注释也无济于事。 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Re-engineered from the inline function _com_error::ErrorMessage(). // We cannot use it directly since it uses swprintf_s(), which is not // present in the MSVCRT.DLL found on Windows XP (QTBUG-35617). static inline QString errorMessageFromComError(const _com_error &amp;comError) { TCHAR *message = nullptr; FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, DWORD(comError.Error()), MAKELANGID(LANG_NEUTRAL,SUBLANG_DEFAULT), message, 0, NULL); if (message) { const QString result = QString::fromWCharArray(message).trimmed(); LocalFree(static_cast&lt;HLOCAL&gt;(message)); return result; } if (const WORD wCode = comError.WCode()) return QString::asprintf("IDispatch error #%u", uint(wCode)); return QString::asprintf("Unknown error 0x0%x", uint(comError.Error())); }</span></span></code> </pre> <br>  PVS-Studio警告：V547 CWE-570表达式“消息”始终为假。  qwindowscontext.cpp 802 <br><br> 程序员可能假设<i>FormatMessage</i>函数将更改<i>消息</i>指针的值。 但是事实并非如此。  <i>FormatMessage函数</i>不能更改指针的值，因为它是按值传递给函数的。 这是此函数的原型： <br><br><pre> <code class="cpp hljs">DWORD __<span class="hljs-function"><span class="hljs-function">stdcall </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FormatMessageW</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPWSTR lpBuffer, DWORD nSize, va_list *Arguments )</span></span></span></span>;</code> </pre> <br><br><h2> 潜在的内存泄漏 </h2><br>  <b>缺陷N75-N92</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SourceDependChildren</span></span></span><span class="hljs-class"> {</span></span> SourceFile **children; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num_nodes, used_nodes; SourceDependChildren() : children(<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>), num_nodes(<span class="hljs-number"><span class="hljs-number">0</span></span>), used_nodes(<span class="hljs-number"><span class="hljs-number">0</span></span>) { } ~SourceDependChildren() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (children) <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(children); children = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addChild</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SourceFile *s)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(num_nodes &lt;= used_nodes) { num_nodes += <span class="hljs-number"><span class="hljs-number">200</span></span>; children = (SourceFile**)<span class="hljs-built_in"><span class="hljs-built_in">realloc</span></span>(children, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(SourceFile*)*(num_nodes)); } children[used_nodes++] = s; } };</code> </pre> <br>  PVS-Studio警告：V701 CWE-401 realloc（）可能泄漏：当realloc（）分配内存失败时，原始指针'children'丢失。 考虑将realloc（）分配给一个临时指针。  makefiledeps.cpp 103 <br><br> 缓冲区扩展以危险的方式实现。 如果<i>realloc</i>函数无法分配内存，它将返回<i>NULL</i> 。 此<i>NULL</i>将立即放置在<i>children</i>变量中，并且不可能以某种方式释放较早分配的缓冲区。 将会发生内存泄漏。 <br><br> 类似错误： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">qt-701.txt</a> 。 <br><br><h2> 杂项 </h2><br>  <b>缺陷N93</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GradientBase</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typename</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BlendType</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">inline</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BlendType</span></span></span><span class="hljs-class"> * </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QT_FASTCALL</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">qt_fetch_linear_gradient_template</span></span></span><span class="hljs-class">(....) {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t+inc*length &lt; qreal(INT_MAX &gt;&gt; (FIXPT_BITS + <span class="hljs-number"><span class="hljs-number">1</span></span>)) &amp;&amp; t+inc*length &gt; qreal(INT_MIN &gt;&gt; (FIXPT_BITS + <span class="hljs-number"><span class="hljs-number">1</span></span>))) { .... }</code> </pre> <br>  PVS-Studio警告：V610 CWE-758未指定的行为。 检查移位运算符“ &gt;&gt;”。 左操作数'（-2147483647-1）'为负。  qdrawhelper.cpp 4015 <br><br>  <i>INT_MIN</i>的负值不能移位。 这是未指定的行为，因此您不能依赖此操作的结果。 最高有效位可以等于0或1。 <br><br>  <b>缺陷N94</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> QObjectPrivate::addConnection(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> signal, Connection *c) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (signal &gt;= connectionLists-&gt;count()) connectionLists-&gt;resize(signal + <span class="hljs-number"><span class="hljs-number">1</span></span>); ConnectionList &amp;connectionList = (*connectionLists)[signal]; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (signal &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... }</code> </pre> <br>  PVS-Studio警告：V781 CWE-129使用后，将检查“信号”变量的值。 程序逻辑中可能有一个错误。 检查行：397，413。qobject.cpp 397 <br><br> 校验<i>（信号&lt;0）</i>表示<i>信号自</i>变量的值可能为负。 但是，此参数以前曾用于索引数组。 事实证明，检查执行得太迟了。 该程序将被破坏。 <br><br>  <b>缺陷N95</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> QXmlStreamWriterPrivate::finishStartElement(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> contents) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inEmptyElement) { write(<span class="hljs-string"><span class="hljs-string">"/&gt;"</span></span>); QXmlStreamWriterPrivate::Tag &amp;tag = tagStack_pop(); lastNamespaceDeclaration = tag.namespaceDeclarationsSize; lastWasStartElement = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { write(<span class="hljs-string"><span class="hljs-string">"&gt;"</span></span>); } inStartElement = inEmptyElement = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; lastNamespaceDeclaration = namespaceDeclarations.size(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hadSomethingWritten; }</code> </pre> <br>  PVS-Studio警告：V519 CWE-563'lastNamespaceDeclaration'变量已连续两次分配值。 也许这是一个错误。 检查行：3188、3194。qxmlstream.cpp 3194 <br><br> 我将强调错误的实质： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inEmptyElement) { lastNamespaceDeclaration = tag.namespaceDeclarationsSize; } lastNamespaceDeclaration = namespaceDeclarations.size();</code> </pre> <br>  <b>缺陷N96</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> QRollEffect::scroll() { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentHeight != totalHeight) { currentHeight = totalHeight * (elapsed/duration) + (<span class="hljs-number"><span class="hljs-number">2</span></span> * totalHeight * (elapsed%duration) + duration) / (<span class="hljs-number"><span class="hljs-number">2</span></span> * duration); <span class="hljs-comment"><span class="hljs-comment">// equiv. to int((totalHeight*elapsed) / duration + 0.5) done = (currentHeight &gt;= totalHeight); } done = (currentHeight &gt;= totalHeight) &amp;&amp; (currentWidth &gt;= totalWidth); .... }</span></span></code> </pre> <br>  V519 CWE-563“完成”变量连续两次分配了值。 也许这是一个错误。 检查行：509、511。qeffects.cpp 511 <br><br> 一切与前面的情况相同。 注意<i>完成</i>变量。 <br><br><h2> 结论 </h2><br> 即使从表面上浏览报告，我也写出了近100个错误。 我对PVS-Studio的结果感到满意。 <br><br> 当然，这种罕见的代码检查与提高代码的质量和可靠性无关。 它们仅演示代码分析器的功能。 静态分析工具应定期使用。 在这种情况下，它们减少了修复错误的成本，并保护了应用程序免受许多潜在漏洞的侵害。 <br><br> 谢谢您的关注。 为了与我们的新出版物保持同步，我邀请您订阅我们的一种渠道： <ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">VK.com：pvsstudio_rus</a> </li><li>  “老派” RSS： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">viva64-blog-ru</a> </li><li> 推特： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@pvsstudio_rus</a> </li><li>  Instagram的： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@pvsstudio_rus</a> </li><li> 电报： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@pvsstudio_rus</a> </li></ol><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br> 如果您想与说英语的读者分享这篇文章，请使用以下链接：Andrey Karpov。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用PVS-Studio对Qt 5进行第三次检查</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN426485/">https://habr.com/ru/post/zh-CN426485/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN426475/index.html">宫-智能手机助手</a></li>
<li><a href="../zh-CN426477/index.html">关于RTOS的全部真相。 第十五条 内存分区：服务和数据结构</a></li>
<li><a href="../zh-CN426479/index.html">自制主板测试台</a></li>
<li><a href="../zh-CN426481/index.html">Unity中的六边形图：路径查找器，播放器小队，动画</a></li>
<li><a href="../zh-CN426483/index.html">一个超越特斯拉的人。 为了更有利可图</a></li>
<li><a href="../zh-CN426487/index.html">从头开始测试自动化。 第一部分</a></li>
<li><a href="../zh-CN426489/index.html">关于素数和无理数的关系</a></li>
<li><a href="../zh-CN426491/index.html">安全周39：关于Google+的死亡</a></li>
<li><a href="../zh-CN426493/index.html">VPS和VPS托管服务商的固定折扣。</a></li>
<li><a href="../zh-CN426495/index.html">独奏设计师。 独自工作时如何建立事业</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>