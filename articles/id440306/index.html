<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✍️ 🤲🏽 ↔️ Penskalaan basis data dalam sistem yang sangat dimuat 👩‍👩‍👧‍👦 👩🏾‍🤝‍👨🏼 👨🏼‍🏭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada reli internal terakhir Pyrus, kami berbicara tentang penyimpanan terdistribusi modern, dan Maxim Nalsky, CEO dan pendiri Pyrus, berbagi kesan per...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Penskalaan basis data dalam sistem yang sangat dimuat</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440306/"> Pada reli internal terakhir Pyrus, kami berbicara tentang penyimpanan terdistribusi modern, dan Maxim Nalsky, CEO dan pendiri Pyrus, berbagi kesan pertamanya tentang FoundationDB.  Pada artikel ini, kita berbicara tentang nuansa teknis yang Anda hadapi ketika memilih teknologi untuk meningkatkan skala penyimpanan data terstruktur. <br><br>  Ketika layanan tidak tersedia untuk pengguna selama beberapa waktu, itu sangat tidak menyenangkan, tetapi masih tidak mematikan.  Tetapi kehilangan data pelanggan sama sekali tidak bisa diterima.  Oleh karena itu, kami dengan cermat mengevaluasi teknologi apa pun untuk menyimpan data dengan dua hingga tiga lusin parameter. <a name="habracut"></a>  Beberapa dari mereka menentukan beban saat ini pada layanan. <br><br><img src="https://habrastorage.org/webt/1c/p2/gm/1cp2gmh6pjentlkkocm1k2msgay.png">  <font color="#777777">Beban saat ini.</font>  <font color="#777777">Kami memilih teknologi dengan mempertimbangkan pertumbuhan indikator-indikator ini.</font> <br><br><h2>  Arsitektur server klien </h2><br>  Model client-server klasik adalah contoh paling sederhana dari sistem terdistribusi.  Server adalah titik sinkronisasi, memungkinkan beberapa klien untuk melakukan sesuatu bersama secara terkoordinasi. <br><br><img src="https://habrastorage.org/webt/jq/hy/ee/jqhyeeqxfebgrvhzvkwsrz58jhy.png">  <font color="#777777">Skema interaksi client-server yang sangat disederhanakan.</font> <br><br>  Apa yang tidak dapat diandalkan dalam arsitektur client-server?  Jelas, server mungkin macet.  Dan ketika server macet, semua klien tidak dapat bekerja.  Untuk menghindari hal ini, orang-orang datang dengan koneksi master-slave (yang sekarang secara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">politis benar disebut leader-follower</a> ).  Intinya adalah ada dua server, semua klien berkomunikasi dengan yang utama, dan pada kedua semua data hanya direplikasi. <br><br><img src="https://habrastorage.org/webt/tk/bo/vu/tkbovuwxni03qjfpkx7m5iwmfie.png">  <font color="#777777">Arsitektur client-server dengan replikasi data ke pengikut.</font> <br><br>  Jelas bahwa ini adalah sistem yang lebih andal: jika server utama macet, maka salinan semua data ada di pengikut dan dapat dengan cepat dinaikkan. <br><br>  Penting untuk memahami cara kerja replikasi.  Jika sinkron, maka transaksi harus disimpan secara bersamaan pada pemimpin dan pada pengikut, dan ini bisa lambat.  Jika replikasi asinkron, Anda bisa kehilangan beberapa data setelah gagal. <br><br>  Dan apa yang akan terjadi jika pemimpin jatuh pada malam hari ketika semua orang tidur?  Ada data tentang pengikut, tetapi tidak ada yang mengatakan kepadanya bahwa ia sekarang adalah seorang pemimpin, dan klien tidak terhubung dengannya.  OKE, mari beri para pengikut logika bahwa dia mulai menganggap dirinya hal utama ketika koneksi dengan pemimpin terputus.  Kemudian kita dapat dengan mudah mendapatkan otak yang terpecah - konflik ketika hubungan antara pemimpin dan pengikut terputus, dan keduanya berpikir bahwa mereka adalah yang utama.  Ini benar-benar terjadi pada banyak sistem, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">seperti RabbitMQ</a> , teknologi antrian paling populer saat ini. <br><br>  Untuk mengatasi masalah ini, atur failover otomatis - tambahkan server ketiga (saksi, saksi).  Ini memastikan bahwa kita hanya memiliki satu pemimpin.  Dan jika pemimpin jatuh, maka pengikut menyala secara otomatis dengan downtime minimum, yang dapat dikurangi menjadi beberapa detik.  Tentu saja, klien dalam skema ini harus mengetahui terlebih dahulu alamat dari pemimpin dan pengikut dan menerapkan logika penyambungan kembali otomatis di antara mereka. <br><br><img src="https://habrastorage.org/webt/n1/ve/aq/n1veaqz67xiw-ozn0cnsudwx7cw.png">  <font color="#777777">Saksi menjamin bahwa hanya ada satu pemimpin.</font>  <font color="#777777">Jika pemimpin jatuh, maka pengikut menyala secara otomatis.</font> <br><br>  Sistem seperti itu sekarang bekerja dengan kita.  Ada database utama, database cadangan, ada saksi dan ya - kadang-kadang kita datang di pagi hari dan melihat bahwa saklar terjadi di malam hari. <br><br>  Tetapi skema ini juga memiliki kelemahan.  Bayangkan Anda menginstal paket layanan atau memperbarui OS pada server pemimpin.  Sebelum itu, Anda secara manual mengaktifkan beban pada pengikut dan kemudian ... jatuh!  Bencana, layanan Anda tidak tersedia.  Apa yang harus dilakukan untuk melindungi diri dari ini?  Tambahkan server cadangan ketiga - pengikut lain.  Tiga adalah sejenis angka ajaib.  Jika Anda ingin sistem bekerja dengan andal, dua server tidak cukup, Anda perlu tiga.  Satu untuk pemeliharaan, yang kedua jatuh, yang ketiga tetap. <br><br><img src="https://habrastorage.org/webt/57/et/ao/57etao8c03-skbgh4_evsna3vwu.png">  <font color="#777777">Server ketiga menyediakan operasi yang andal jika dua yang pertama tidak tersedia.</font> <br><br>  Untuk meringkas, redundansi harus sama dengan dua.  Redundansi satu saja tidak cukup.  Untuk alasan ini, dalam array disk, orang-orang mulai menggunakan skema RAID6 alih-alih RAID5, selamat dari jatuhnya dua disk sekaligus. <br><br><h2>  Transaksi </h2><br>  Empat persyaratan transaksi dasar yang terkenal: atomicity, konsistensi, isolasi, dan daya tahan (Atomicity, Consistency, Isolasi, Durability - ACID). <br><br>  Ketika kita berbicara tentang database terdistribusi, kita berarti bahwa data harus diskalakan.  Membaca skala sangat baik - ribuan transaksi dapat membaca data secara paralel tanpa masalah.  Tetapi ketika transaksi lain menulis data pada saat yang sama dengan membaca, berbagai efek yang tidak diinginkan mungkin terjadi.  Sangat mudah untuk mendapatkan situasi di mana satu transaksi akan membaca nilai yang berbeda dari catatan yang sama.  Berikut ini beberapa contohnya. <br><br>  <b>Kotor berbunyi.</b>  Dalam transaksi pertama, kami mengirim permintaan yang sama dua kali: mengambil semua pengguna dengan ID = 1. Jika transaksi kedua mengubah baris ini dan kemudian mengembalikan, database tidak akan melihat perubahan di satu sisi, tetapi di sisi lain transaksi pertama akan membaca nilai umur Joe yang berbeda. <br><br><img src="https://habrastorage.org/webt/qj/zl/d6/qjzld6frtj0ogu9lpfoss5wva2k.png"><br><br>  <b>Bacaan tidak dapat diulang.</b>  Kasus lain adalah jika transaksi tulis selesai dengan sukses, dan transaksi baca menerima data yang berbeda selama pelaksanaan permintaan yang sama. <br><br><img src="https://habrastorage.org/webt/85/wd/ug/85wdugy_ypmk0cfxpxl1hy5pf-s.png"><br><br>  Dalam kasus pertama, klien membaca data yang umumnya tidak ada dalam database.  Dalam kasus kedua, klien kedua kali membaca data dari database, tetapi mereka berbeda, meskipun pembacaan terjadi dalam transaksi yang sama. <br><br>  <b>Phantom reads adalah</b> ketika kita membaca ulang rentang dalam transaksi yang sama dan mendapatkan serangkaian garis yang berbeda.  Di suatu tempat di tengah, transaksi lain masuk dan memasukkan atau menghapus catatan. <br><br><img src="https://habrastorage.org/webt/k4/65/yq/k465yqehsgbjd0ertvg7poziaie.png"><br><br>  Untuk menghindari efek yang tidak diinginkan ini, DBMS modern menerapkan mekanisme penguncian (transaksi membatasi akses ke data yang saat ini bekerja dengan transaksi lain) atau kontrol versi multiversion, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MVCC</a> (transaksi tidak pernah mengubah data yang direkam sebelumnya dan selalu membuat versi baru). <br><br>  Standar ANSI / ISO SQL mendefinisikan 4 level isolasi untuk transaksi yang memengaruhi tingkat saling memblokir mereka.  Semakin tinggi tingkat isolasi, semakin sedikit efek yang tidak diinginkan.  Harga untuk ini adalah untuk memperlambat aplikasi (karena transaksi lebih sering menunggu untuk membuka kunci data yang mereka butuhkan) dan meningkatkan kemungkinan kebuntuan. <br><br><img src="https://habrastorage.org/webt/0-/iy/4h/0-iy4hwem9b4-mkupvpetxgc9so.png"><br><br>  Yang paling menyenangkan bagi seorang programmer aplikasi adalah level Serializable - tidak ada efek yang tidak diinginkan dan seluruh kompleksitas memastikan integritas data dialihkan ke DBMS. <br><br>  Mari kita pikirkan tentang implementasi naif dari level Serializable - dengan setiap transaksi, kami hanya memblokir semua orang.  Setiap transaksi tulis dapat dilakukan secara teoritis dalam 50 μs (waktu satu operasi tulis pada disk SSD modern).  Dan kami ingin menyimpan data ke tiga mesin, ingat?  Jika mereka berada di pusat data yang sama, maka perekaman akan memakan waktu 1-3 ms.  Dan jika mereka, untuk keandalan, ada di kota yang berbeda, maka perekaman dapat dengan mudah mengambil 10-12ms (waktu perjalanan paket jaringan dari Moskow ke St. Petersburg dan sebaliknya).  Yaitu, dengan implementasi tingkat Serializable yang naif dengan pencatatan berurutan, kita dapat melakukan tidak lebih dari 100 transaksi per detik.  Sementara SSD terpisah memungkinkan Anda melakukan sekitar 20.000 operasi tulis per detik! <br><br>  Kesimpulan: transaksi tulis harus dilakukan secara paralel, dan untuk menskalakannya, Anda memerlukan mekanisme penyelesaian konflik yang baik. <br><br><h2>  Sharding </h2><br>  Apa yang harus dilakukan ketika data berhenti masuk pada satu server?  Ada dua mekanisme pembesaran standar: <br><br><ul><li>  <b>Tegak</b> ketika kita baru saja menambahkan memori dan disk ke server ini.  Ini memiliki batasnya - dalam hal jumlah inti per prosesor, jumlah prosesor, dan jumlah memori. <br></li><li>  <b>Horisontal,</b> ketika kami menggunakan banyak mesin dan mendistribusikan data di antara mereka.  Set mesin seperti itu disebut cluster.  Untuk memasukkan data ke dalam sebuah cluster, mereka harus di-shard - yaitu, untuk setiap record, tentukan di server mana ia akan berada. <br></li></ul><br>  Kunci sharding adalah parameter yang dengannya data didistribusikan di antara server, misalnya, klien atau pengidentifikasi organisasi. <br><br>  Bayangkan Anda perlu merekam data tentang semua penghuni Bumi dalam sebuah cluster.  Sebagai kunci beling, Anda dapat mengambil, misalnya, tahun kelahiran orang tersebut.  Maka 116 server akan cukup (dan setiap tahun akan perlu untuk menambah server baru).  Atau Anda dapat mengambil sebagai kunci negara tempat orang tersebut tinggal, maka Anda akan membutuhkan sekitar 250 server.  Namun, opsi pertama lebih disukai, karena tanggal lahir orang tersebut tidak berubah, dan Anda tidak perlu mentransfer data tentangnya di antara server. <br><br><img src="https://habrastorage.org/webt/zr/8h/sz/zr8hszqcct-xf5q07gcow3cf7lu.png"><br><br>  Di Pyrus, Anda dapat mengambil organisasi sebagai kunci sharding.  Tetapi mereka sangat berbeda dalam ukuran: ada Sovcombank besar (lebih dari 15 ribu pengguna) dan ribuan perusahaan kecil.  Saat Anda menetapkan suatu organisasi server tertentu, Anda tidak tahu sebelumnya bagaimana itu akan tumbuh.  Jika organisasi besar dan menggunakan layanan secara aktif, maka cepat atau lambat datanya akan berhenti ditempatkan pada satu server, dan Anda harus melakukan pengulangan.  Dan ini tidak mudah jika datanya terabyte.  Bayangkan: sistem dimuat, transaksi berjalan setiap detik, dan dalam kondisi ini Anda perlu memindahkan data dari satu tempat ke tempat lain.  Anda tidak dapat menghentikan sistem, volume seperti itu dapat dipompa selama beberapa jam, dan pelanggan bisnis tidak akan bertahan selama downtime yang lama. <br><br>  Sebagai kunci sharding, lebih baik memilih data yang jarang berubah.  Namun, jauh dari selalu tugas yang diterapkan membuat ini mudah dilakukan. <br><br><h2>  Konsensus dalam cluster </h2><br>  Ketika ada banyak mesin di cluster dan beberapa dari mereka kehilangan kontak dengan yang lain, lalu bagaimana memutuskan siapa yang menyimpan versi terbaru dari data?  Menugaskan server saksi saja tidak cukup, karena itu juga dapat kehilangan kontak dengan seluruh cluster.  Selain itu, dalam situasi otak yang terpecah, beberapa mesin dapat merekam versi berbeda dari data yang sama - dan Anda perlu entah bagaimana menentukan yang mana yang paling relevan.  Untuk mengatasi masalah ini, orang-orang datang dengan algoritma konsensus.  Mereka memungkinkan beberapa mesin identik untuk mencapai hasil tunggal pada masalah apa pun dengan memilih.  Pada tahun 1989, algoritma semacam itu, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Paxos</a> , diterbitkan, dan pada tahun 2014, Stanford datang dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Raft yang</a> lebih sederhana untuk diimplementasikan.  Sebenarnya, agar sekelompok (2N +1) server untuk mencapai konsensus, cukup bahwa pada saat yang sama memiliki tidak lebih dari kegagalan N.  Untuk bertahan dari 2 kegagalan, cluster harus memiliki setidaknya 5 server. <br><br><h2>  Penskalaan DBMS Relasional </h2><br>  Sebagian besar database yang digunakan pengembang untuk bekerja dengan mendukung aljabar relasional.  Data disimpan dalam tabel dan terkadang Anda harus menggabungkan data dari tabel yang berbeda menggunakan operasi JOIN.  Pertimbangkan contoh database dan permintaan sederhana untuk itu. <br><br><img src="https://habrastorage.org/webt/hv/fo/d-/hvfod-guiaz4-52ji4epjhizpaq.png"><br><br>  Asumsikan A.id adalah kunci utama dengan indeks berkerumun.  Kemudian pengoptimal akan membangun rencana yang kemungkinan besar akan memilih catatan yang diperlukan dari tabel A dan kemudian mengambil tautan yang sesuai ke catatan di tabel B dari indeks yang sesuai (A, B). Waktu pelaksanaan kueri ini tumbuh secara logaritmik dari jumlah catatan dalam tabel. <br><br>  Sekarang bayangkan bahwa data didistribusikan di empat server di kluster dan Anda perlu menjalankan kueri yang sama: <br><br><img src="https://habrastorage.org/webt/kr/yw/45/kryw45daubuflf-r14zqswson_o.png"><br><br>  Jika DBMS tidak ingin melihat semua catatan dari seluruh kluster, maka mungkin akan mencoba untuk menemukan catatan dengan A.id sama dengan 128, 129, atau 130 dan menemukan catatan yang sesuai untuk mereka dari tabel B. Tetapi jika A.id bukan kunci beling, maka DBMS di muka tidak dapat mengetahui di server mana data tabel A. aktif. Saya tetap harus menghubungi semua server untuk mengetahui apakah ada catatan A.id yang sesuai dengan kondisi kami.  Kemudian setiap server dapat membuat GABUNG di dalam dirinya sendiri, tetapi ini tidak cukup.  Anda lihat, kita perlu catatan pada simpul 2 dalam sampel, tetapi tidak ada catatan dengan A.id = 128?  Jika node 1 dan 2 akan BERGABUNG secara independen, maka hasil kueri tidak akan lengkap - kami tidak akan menerima bagian dari data. <br><br>  Oleh karena itu, untuk memenuhi permintaan ini, setiap server harus beralih ke yang lain.  Runtime tumbuh secara kuadratik dengan jumlah server.  (Anda beruntung jika Anda dapat shard semua tabel dengan kunci yang sama, maka Anda tidak perlu berkeliling semua server. Namun, dalam praktiknya ini tidak realistis - akan selalu ada pertanyaan di mana pengambilan tidak didasarkan pada kunci shard.) <br><br>  Dengan demikian, skala operasi BERGABUNG secara fundamental buruk dan ini merupakan masalah mendasar dari pendekatan relasional. <br><br><h2>  Pendekatan NoSQL </h2><br>  Kesulitan dengan penskalaan DBMS klasik telah membuat orang membuat database NoSQL yang tidak memiliki operasi BERGABUNG.  Tidak ada yang bergabung - tidak ada masalah.  Tetapi tidak ada properti ACID, tetapi mereka tidak menyebutkan ini dalam materi pemasaran.  Dengan cepat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ditemukan pengrajin</a> yang menguji kekuatan berbagai sistem terdistribusi dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memposting hasilnya secara publik</a> .  Ternyata ada skenario ketika <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cluster Redis kehilangan 45% dari data yang disimpan,</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cluster RabbitMQ - 35% dari pesan</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MongoDB - 9% dari catatan</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cassandra - hingga 5%</a> .  Dan kita berbicara <b>tentang kerugian setelah cluster memberi tahu klien tentang save yang berhasil.</b>  Biasanya Anda mengharapkan tingkat keandalan yang lebih tinggi dari teknologi yang dipilih. <br><br>  Google telah mengembangkan basis data <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Spanner</a> , yang beroperasi secara global di seluruh dunia.  Spanner menjamin properti ACID, Serializability, dan lainnya.  Mereka memiliki jam atom di pusat data yang menyediakan waktu yang akurat, dan ini memungkinkan Anda untuk membangun urutan transaksi global tanpa perlu meneruskan paket jaringan antar benua.  Gagasan Spanner adalah bahwa lebih baik bagi programmer untuk menangani masalah kinerja yang timbul dengan sejumlah besar transaksi daripada kruk di sekitar kurangnya transaksi.  Namun, Spanner adalah teknologi tertutup, itu tidak cocok untuk Anda jika karena alasan tertentu Anda tidak ingin bergantung pada satu vendor. <br><br>  Penduduk asli Google mengembangkan analog open source dari Spanner dan menamainya CockroachDB ("kecoak" dalam bahasa Inggris "kecoak", yang harus melambangkan keberlangsungan database).  Pada Habré <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sudah menulis</a> tentang tidak tersedianya produk untuk produksi, karena cluster kehilangan data.  Kami memutuskan untuk memeriksa versi 2.0 yang lebih baru, dan sampai pada kesimpulan yang sama.  Kami tidak kehilangan data, tetapi beberapa pertanyaan paling sederhana dieksekusi terlalu lama. <br><br><hr><br>  Akibatnya, saat ini ada database relasional yang skalanya baik hanya secara vertikal, yang mahal.  Dan ada solusi NoSQL tanpa transaksi dan tanpa jaminan ACID (jika Anda ingin ACID, tulis kruk). <br><br>  Bagaimana membuat aplikasi mission-critical di mana data tidak muat di satu server?  Solusi baru muncul di pasar, dan tentang salah satunya - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FoundationDB</a> - kami akan memberi tahu Anda lebih banyak di artikel berikutnya. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id440306/">https://habr.com/ru/post/id440306/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id440296/index.html">6 Aplikasi untuk IoT Industri</a></li>
<li><a href="../id440298/index.html">Aplikasi Hari Valentine di Libgdx</a></li>
<li><a href="../id440300/index.html">10 perintah konsol untuk membantu memperdebatkan kode JavaScript seperti PRO</a></li>
<li><a href="../id440302/index.html">CRM - biaya kesuksesan, biaya kesalahan, biaya kepemilikan</a></li>
<li><a href="../id440304/index.html">Mengganggu dari perangkat eksternal dalam sistem x86. Bagian 3. Mengkonfigurasi perutean interupsi dalam chipset menggunakan contoh coreboot</a></li>
<li><a href="../id440308/index.html">Bagilah dan taklukkan, atau tulis dengan lambat - baca dengan cepat</a></li>
<li><a href="../id440310/index.html">Cara mengajar mesin untuk memahami faktur dan mengekstrak data dari mereka</a></li>
<li><a href="../id440312/index.html">Hackquest 2018. Hasil & Tulisan. Hari 4-7</a></li>
<li><a href="../id440314/index.html">Kandidat Rilis JDK 12: Shenandoah, G1, JMH, Arm64. Bug di Swing menyerang balik</a></li>
<li><a href="../id440316/index.html">Distribusi titik yang seragam dalam suatu segitiga</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>