<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👽 🍫 🔲 DynamicData：更改集合，MVVM设计模式和响应式扩展 🐷 👨🏾‍🍳 🚌</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="2019年2月，发布了ReactiveUI 9 ，这是一个用于在Microsoft .NET平台上构建GUI应用程序的跨平台框架。 ReactiveUI是用于将反应式扩展与MVVM设计模式紧密集成的工具。 可以从 Habré上的一系列文章或从文档的首页开始熟悉该框架。 ReactiveUI 9更新包...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>DynamicData：更改集合，MVVM设计模式和响应式扩展</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445098/"> 2019年2月，发布了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ReactiveUI 9</a> ，这是一个用于在Microsoft .NET平台上构建GUI应用程序的跨平台框架。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ReactiveUI</a>是用于将反应式扩展与MVVM设计模式紧密集成的工具。 可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">从</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Habré上</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一系列文章</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">从文档的首页</a>开始熟悉该框架。  ReactiveUI 9更新包括许多<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">修复和改进</a> ，但最有趣和最重要的变化可能是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">与DynamicData框架的紧密集成，该框架</a>允许以响应式样式更改集合。 让我们尝试找出在什么情况下<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DynamicData</a>可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">派上用场，</a>以及如何在内部安排这种强大的反应式框架！ <br><a name="habracut"></a><br><h3> 背景知识 </h3><br> 首先，我们定义<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DynamicData解决</a>的任务范围，并找出为什么使用<code>System.Collections.ObjectModel</code>命名空间中的更改数据集的标准工具不适合我们。 <br><br> 如您所知，MVVM模板涉及模型，表示和应用程序表示模型各层之间的职责划分。 模型层由域实体和服务表示，对表示模型一无所知。 模型层封装了整个复杂的应用程序逻辑，而表示模型则委托了模型的操作，从而通过可观察的属性，命令和集合为视图提供了有关应用程序当前状态信息的视图访问。 用于更改属性的标准工具是<code>INotifyPropertyChanged</code>接口，用于处理用户操作的<code>INotifyPropertyChanged</code>和<code>INotifyCollectionChanged</code>实现集合并实现<code>ObservableCollection</code>和<code>ReadOnlyObservableCollection</code> <code>INotifyCollectionChanged</code> 。 <br><br><img width="500" src="https://habrastorage.org/getpro/habr/post_images/504/c83/ab0/504c83ab04fe2e2d1eed037317b8aa2c.jpg"><br><br>  <code>INotifyPropertyChanged</code>和<code>ICommand</code>的实现通常仍取决于开发人员和所使用的MVVM框架的良知，但是<code>ObservableCollection</code>的使用对我们施加了许多限制！ 例如，如果没有<code>Dispatcher.Invoke</code>或类似的调用，我们将无法从后台线程更改集合，这在处理某些后台操作与服务器同步的数据数组的情况下可能很有用。 应当注意，在惯用的MVVM中，模型层不需要了解所使用的GUI应用程序的体系结构，并且不需要与MVC或MVP中的模型兼容，这就是为什么许多<code>Dispatcher.Invoke</code>允许从运行中的后台线程访问用户界面控件的原因在域服务中，违反了在应用程序层之间分担责任的原则。 <br><br> 当然，在域服务中，可以声明一个事件，并作为事件的参数传递带有已更改数据的块。 然后订阅该事件，将<code>Dispatcher.Invoke</code>调用包装在接口中，以使其不依赖于所使用的GUI框架，将<code>Dispatcher.Invoke</code>移至表示模型并<code>ObservableCollection</code>需要更改<code>ObservableCollection</code> ，但是有一种更简单，更优雅的方法来解决指定范围的任务，而无需编写自行车。 让我们开始学习！ <br><br><h2> 反应性扩展。 管理数据流 </h2><br> 为了完全理解<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DynamicData</a>引入的抽象以及更改反应式数据集的工作原理，让我们回顾一下<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">什么是反应式编程以及如何在Microsoft .NET平台和MVVM设计模式的上下文中应用它</a> 。 组织程序组件之间交互的一种方式可以是交互的和反应性的。 在交互式交互中，使用者功能从提供程序功能（基于拉的方法<code>T</code> ， <code>IEnumerable</code> ）同步接收数据，在响应式交互中，使用者功能异步将数据传递到使用者功能（基于推方法， <code>Task</code> ， <code>IObservable</code> ）。 <br><br><img width="500" src="https://habrastorage.org/webt/mb/ts/mj/mbtsmjfyhjqeeb4tv8ynotvkdms.png"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">反应式编程</a>是使用异步数据流进行编程，而反应式扩展是其实现的特例，它基于System名称空间中的<code>IObservable</code>和<code>IObserver</code> ，该<code>IObserver</code>在<code>IObserver</code>上定义了许多类似于LINQ的操作，称为LINQ over Observable。 反应性扩展支持.NET Standard，并且可以在Microsoft .NET平台工作的任何地方工作。 <br><br><img src="https://habrastorage.org/webt/ue/qe/80/ueqe80neq0ufivj-bq5hipdrldo.gif"><br><br>  ReactiveUI框架邀请应用程序开发人员利用<code>ICommand</code>和<code>INotifyPropertyChanged</code>的响应式实现，提供诸如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>ReactiveCommand&lt;TIn, TOut&gt;</code></a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>WhenAnyValue</code></a>类的强大工具。  <code>WhenAnyValue</code>允许<code>WhenAnyValue</code>将实现INotifyPropertyChanged的类的属性转换为<code>IObservable&lt;T&gt;</code>类型的事件流，从而简化了相关属性的实现。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ExampleViewModel</span></span> : <span class="hljs-title"><span class="hljs-title">ReactiveObject</span></span> { [Reactive] <span class="hljs-comment"><span class="hljs-comment">//  ReactiveUI.Fody,  // -  // OnPropertyChanged   Name. public string Name { get; set; } public ExampleViewModel() { //  OnPropertyChanged("Name"). this.WhenAnyValue(x =&gt; x.Name) //   IObservable&lt;string&gt; .Subscribe(Console.WriteLine); } }</span></span></code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>ReactiveCommand&lt;TIn, TOut&gt;</code></a>允许您使用该命令，以及<code>IObservable&lt;TOut&gt;</code>类型的事件，该事件在命令完成执行时发布。 同样，任何命令都具有类型为<code>IObservable&lt;Exception&gt;</code>的<code>ThrownExceptions</code>属性。 <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// ReactiveCommand&lt;Unit, int&gt; var command = ReactiveCommand.Create(() =&gt; 42); command //   IObservable&lt;int&gt; .Subscribe(Console.WriteLine); command .ThrownExceptions //   IObservable&lt;Exception&gt; .Select(exception =&gt; exception.Message) //   IObservable&lt;string&gt; .Subscribe(Console.WriteLine); command.Execute().Subscribe(); // : 42</span></span></code> </pre><br> 一直以来，我们一直使用<code>IObservable&lt;T&gt;</code> ，并且每当被监视对象的状态发生变化时，事件就会发布类型<code>T</code>的新值。 简而言之， <code>IObservable&lt;T&gt;</code>是事件流，序列随时间延伸。 <br><br> 当然，我们也可以轻松自然地使用集合-每当集合发生更改时，发布具有更改元素的新集合。 在这种情况下，发布的值将为<code>IEnumerable&lt;T&gt;</code>类型或更专业，并且事件本身将为<code>IObservable&lt;IEnumerable&lt;T&gt;&gt;</code> 。 但是，正如具有批判性思维的读者正确指出的那样，这会给应用程序性能带来严重问题，特别是如果我们的收藏中没有十二个元素，而是一百甚至数千个元素！ <br><br><h2>  DynamicData简介 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DynamicData</a>是一个库，可让您在使用集合时充分利用反应式扩展的全部功能。 开箱即用的反应式扩展未提供使用最佳方法来更改数据集，而<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DynamicData的工作</a>就是修复它。 在大多数应用程序中，需要动态更新集合-通常，在应用程序启动时，集合中会填充一些元素，然后异步更新该集合，从而使信息与服务器或数据库同步。 现代应用程序非常复杂，通常需要创建集合投影-过滤，转换或排序元素。 设计DynamicData只是为了摆脱我们管理动态变化的数据集所需的极其复杂的代码。 该工具正在积极开发和定稿中，目前支持60多个操作员进行馆藏工作。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/hn/7j/v3/hn7jv3fv1qgfxlhqrd9g6dokkao.gif"></a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DynamicData</a>不是<code>ObservableCollection&lt;T&gt;</code>的替代实现。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DynamicData</a>体系结构<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">主要</a>基于特定领域编程的概念。 使用的意识形态基于您管理一些数据源这一事实，该数据源是负责同步和更改数据的代码可以访问的集合。 接下来，您对源应用了多个运算符，您可以使用它们以声明方式转换数据，而无需手动创建和修改其他集合。 实际上，使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DynamicData</a>可以将读写操作分开，并且只能以反应方式进行读取-因此，继承的集合将始终与源同步。 <br><br> 代替传统的<code>IObservable&lt;T&gt;</code> ，DynamicData定义了对<code>IObservable&lt;IChangeSet&lt;T&gt;&gt;&gt;</code>和<code>IObservable&lt;IChangeSet&lt;TValue, TKey&gt;&gt;</code> ，其中<code>IChangeSet</code>是一个块，其中包含有关集合更改的信息-更改的类型和受影响的元素。 这种方法可以显着提高代码的性能，以处理以反应式编写的集合。 同时，如果有必要立即处理<code>IObservable&lt;IChangeSet&lt;T&gt;&gt;</code>则始终可以将其转换为常规<code>IObservable&lt;IEnumerable&lt;T&gt;&gt;</code> 。 如果听起来很复杂-不要惊慌，从代码示例中，一切将变得清晰透明！ <br><br><h2>  DynamicData示例 </h2><br> 让我们看一系列示例，以更好地了解DynamicData的工作原理，它与<code>System.Reactive</code>区别以及使用GUI的应用程序软件的普通开发人员可以解决的任务。 让我们从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DynamicData在GitHub上发布</a>的综合示例开始。 在该示例中，数据源是<code>SourceCache&lt;Trade, long&gt;</code> ，其中包含交易的集合。 任务是仅显示活动事务，将模型转换为代理对象，对集合进行排序。 <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//    System.Collections.ObjectModel, //       . ReadOnlyObservableCollection&lt;TradeProxy&gt; list; //   ,   . //   Add, Remove, Insert   . var source = new SourceCache&lt;Trade, long&gt;(trade =&gt; trade.Id); var cancellation = source //      . //   IObservable&lt;IChangeSet&lt;Trade, long&gt;&gt; .Connect() //       . .Filter(trade =&gt; trade.Status == TradeStatus.Live) //    -. //   IObservable&lt;IChangeSet&lt;TrandeProxy, long&gt;&gt; .Transform(trade =&gt; new TradeProxy(trade)) //    . .Sort(SortExpressionComparer&lt;TradeProxy&gt; .Descending(trade =&gt; trade.Timestamp)) //  GUI    . .ObserveOnDispatcher() //    - //    System.Collections.ObjectModel. .Bind(out list) // ,       //    . .DisposeMany() .Subscribe();</span></span></code> </pre><br> 在上面的示例中，当您更改作为数据源的<code>SourceCache</code>时， <code>ReadOnlyObservableCollection</code>也将相应地更改。 在这种情况下，从集合中删除元素时，将调用<code>Dispose</code>方法，该集合将始终仅在GUI流中进行更新，并保持排序和过滤状态。 很酷，没有<code>Dispatcher.Invoke</code>和复杂的代码！ <br><br><h2>  SourceList和SourceCache数据源 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DynamicData</a>提供了两个专用集合，可以用作可变数据源。 这些集合的类型为<code>SourceList</code>和<code>SourceCache&lt;TObject, TKey&gt;</code> 。 建议每当<code>TObject</code>具有唯一键时都使用<code>SourceCache</code> ，否则请使用<code>SourceList</code> 。 这些对象提供了熟悉的.NET开发人员API，用于修改数据- <code>Add</code> ， <code>Remove</code> ， <code>Insert</code>等。 要将数据源转换为<code>IObservable&lt;IChangeSet&lt;T&gt;&gt;</code>或<code>IObservable&lt;IChangeSet&lt;T, TKey&gt;&gt;</code> ，请使用<code>IObservable&lt;IChangeSet&lt;T, TKey&gt;&gt;</code> <code>.Connect()</code>运算符。 例如，如果您有一项在后台更新元素集合的服务，则可以轻松地将这些元素的列表与GUI同步，而无需<code>Dispatcher.Invoke</code>和体系结构方面的麻烦： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BackgroundService</span></span> : <span class="hljs-title"><span class="hljs-title">IBackgroundService</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    . private readonly SourceList&lt;Trade&gt; _trades; //     . //  ,     , //    Publish()  Rx. public IObservable&lt;IChangeSet&lt;Trade&gt;&gt; Connect() =&gt; _trades.Connect(); public BackgroundService() { _trades = new SourceList&lt;Trade&gt;(); _trades.Add(new Trade()); //    ! //    . } }</span></span></code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DynamicData</a>使用内置的.NET类型将数据映射到外界。 使用强大的DynamicData运算符，我们可以将<code>IObservable&lt;IChangeSet&lt;Trade&gt;&gt;</code>转换<code>ReadOnlyObservableCollection</code>我们的视图模型的<code>ReadOnlyObservableCollection</code> 。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TradesViewModel</span></span> : <span class="hljs-title"><span class="hljs-title">ReactiveObject</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ReadOnlyObservableCollection&lt;TradeVm&gt; _trades; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ReadOnlyObservableCollection&lt;TradeVm&gt; Trades =&gt; _trades; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TradesViewModel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IBackgroundService background</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   ,  ,  //     System.Collections.ObjectModel. background.Connect() .Transform(x =&gt; new TradeVm(x)) .ObserveOn(RxApp.MainThreadScheduler) .Bind(out _trades) .DisposeMany() .Subscribe(); } }</span></span></code> </pre><br> 除了<code>Transform</code> ， <code>Filter</code>和<code>Sort</code> ，DynamicData还包含许多其他运算符，支持分组，逻辑运算，使用集合函数对集合进行平滑处理，不包括相同的元素，计数元素，甚至在表示模型级别也没有虚拟化。  <a href="">在GitHub上</a>的<a href="">README项目中</a>了解有关所有运算符的更多信息。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/jy/6-/4a/jy6-4azw__6rou9alucffpjhkrq.gif"></a> <br><br><h2> 单线程集合和变更跟踪 </h2><br> 除了<code>SourceList</code>和<code>SourceCache</code> ，DynamicData库还包括可变集合<code>ObservableCollectionExtended</code>的单线程实现。 要同步视图模型中的两个集合，请将一个声明为<code>ObservableCollectionExtended</code> ，将另一个声明为<code>ReadOnlyObservableCollection</code>然后使用<code>ToObservableChangeSet</code>运算符，其行为与<code>Connect</code>相同，但旨在与<code>ObservableCollection</code> 。 <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//   . ReadOnlyObservableCollection&lt;TradeVm&gt; _derived; //    -. var source = new ObservableCollectionExtended&lt;Trade&gt;(); source.ToObservableChangeSet(trade =&gt; trade.Key) .Transform(trade =&gt; new TradeProxy(trade)) .Filter(proxy =&gt; proxy.IsChecked) .Bind(out _derived) .Subscribe();</span></span></code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DynamicData</a>还支持跟踪实现<code>INotifyPropertyChanged</code>接口的类中的更改。 例如，如果希望每当项目的属性发生更改时就通知集合更改，请使用<code>AutoRefresh</code>然后将所需属性的选择器与参数一起传递。  <code>AutoRefesh</code>和其他DynamicData运算符将使您轻松自然地验证屏幕上显示的大量表单和子表单！ <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//  IObservable&lt;bool&gt; var isValid = databases .ToObservableChangeSet() //      IsValid. .AutoRefresh(database =&gt; database.IsValid) //       . .ToCollection() // ,    . .Select(x =&gt; x.All(y =&gt; y.IsValid)); //   ReactiveUI, IObservable&lt;bool&gt; //     ObservableAsProperty. _isValid = isValid .ObserveOn(RxApp.MainThreadScheduler) .ToProperty(this, x =&gt; x.IsValid);</span></span></code> </pre><br> 基于DynamicData功能，您可以快速创建相当复杂的界面-对于显示大量实时数据的系统，即时消息传递系统和监视系统尤其如此。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/98/nh/ws/98nhws7gl4yzk8kgcovbpvvozoi.gif"></a> <br><br><h2> 结论 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">反应性扩展</a>是一个功能强大的工具，可让您声明性地使用数据和用户界面，编写可移植和受支持的代码，并以简单优雅的方式解决复杂的问题。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ReactiveUI</a>允许.NET开发人员通过提供<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>INotifyPropertyChanged</code></a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>ICommand</code></a>响应式实现，使用MVVM体系结构将响应式扩展紧密集成到他们的项目中，而<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DynamicData</a>通过实现<code>INotifyCollectionChanged</code>来处理集合同步，扩展<code>INotifyCollectionChanged</code>扩展的功能并关注性能。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ReactiveUI</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DynamicData库</a>与.NET平台的大多数流行的GUI框架兼容，包括Windows Presentation Foundation，通用Windows平台，Avalonia，Xamarin.Android，Xamarin Forms，Xamarin.iOS。 您可以从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">相应的ReactiveUI文档页面</a>开始学习DynamicData。 另外，请确保签出<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DynamicData Snippets</a>项目，其中包含在所有场合下使用DynamicData的示例。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN445098/">https://habr.com/ru/post/zh-CN445098/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN445086/index.html">月球任务“ Bereshit”-机载摄像头的第一个视频和外太空的新照片</a></li>
<li><a href="../zh-CN445088/index.html">您生活中的冒险是否比计算机游戏有趣？</a></li>
<li><a href="../zh-CN445090/index.html">YouTube会保持我们了解的方式吗？</a></li>
<li><a href="../zh-CN445092/index.html">HATEOAS深度链接问题</a></li>
<li><a href="../zh-CN445094/index.html">使用IP上的硬件USB集中访问数字签名和其他电子保护密钥</a></li>
<li><a href="../zh-CN445100/index.html">Anycubic：Photon S，4Max Pro和更名</a></li>
<li><a href="../zh-CN445102/index.html">从头开始在Unity3D中进行动画制作。 第一部分，抒情</a></li>
<li><a href="../zh-CN445104/index.html">Klipsch音频品牌的简要历史</a></li>
<li><a href="../zh-CN445106/index.html">圆桌会议：添加剂技术替代传统制造</a></li>
<li><a href="../zh-CN445108/index.html">不是一个猎鹰-根本不同的可重用ESA和ULA项目</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>