<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚪 🥌 🍇 Mengubah FunC menjadi FunCtional dengan Haskell: Bagaimana Serokell memenangkan kompetisi Telegram Blockchain ✋ 👵🏽 👩🏼‍🏭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Anda mungkin pernah mendengar bahwa Telegram akan meluncurkan platform blockchain Ton . Tapi Anda bisa melewatkan berita bahwa belum lama ini Telegram...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengubah FunC menjadi FunCtional dengan Haskell: Bagaimana Serokell memenangkan kompetisi Telegram Blockchain</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/476756/"><p>  Anda mungkin pernah mendengar bahwa Telegram <a href="https://vc.ru/finance/88457-telegram-predlozhil-investoram-podozhdat-zapuska-ton-do-aprelya-2020-goda-ili-vernut-77-ot-summy-vlozheniy-v-proekt">akan meluncurkan platform blockchain Ton</a> .  Tapi Anda bisa melewatkan berita bahwa belum lama ini Telegram <a href="https://habr.com/ru/news/t/468755/">mengumumkan kompetisi</a> untuk implementasi satu atau lebih kontrak pintar untuk platform ini. </p><br><p>  Tim Serokell dengan pengalaman yang kaya dalam mengembangkan proyek-proyek blockchain besar tidak bisa menjauh.  Kami mendelegasikan lima karyawan ke kontes, dan dua minggu kemudian mereka mengambil tempat pertama di bawahnya dengan julukan acak sederhana (tidak) Sexy Chameleon.  Dalam artikel ini saya akan berbicara tentang bagaimana mereka berhasil.  Kami berharap bahwa dalam sepuluh menit ke depan Anda setidaknya akan membaca cerita yang menarik, dan paling banyak Anda akan menemukan sesuatu yang berguna di dalamnya yang dapat Anda terapkan dalam pekerjaan Anda. </p><br><p>  Tapi mari kita mulai dengan sedikit menyelam ke dalam konteksnya. </p><a name="habracut"></a><br><h2 id="konkurs-i-ego-usloviya">  Persaingan dan kondisinya </h2><br><p>  Jadi, tugas utama para peserta adalah implementasi satu atau lebih dari kontrak pintar yang diusulkan, serta membuat proposal untuk meningkatkan ekosistem TON.  Kompetisi diadakan dari 24 September hingga 15 Oktober, dan hasilnya diumumkan hanya pada 15 November.  Untuk waktu yang lama, mengingat bahwa selama ini Telegram berhasil melakukan dan mengumumkan hasil kontes pada desain dan pengembangan aplikasi dalam C ++ untuk menguji dan mengevaluasi kualitas panggilan VoIP di Telegram. </p><br><p>  Kami memilih dua kontrak pintar dari daftar yang diusulkan oleh penyelenggara.  Untuk salah satu dari mereka, kami menggunakan alat yang didistribusikan dengan TON, dan yang kedua kami implementasikan dalam bahasa baru yang dikembangkan oleh para insinyur kami secara khusus untuk TON dan terintegrasi dengan Haskell. </p><br><p>  Pilihan bahasa pemrograman fungsional tidak disengaja.  Di <a href="https://serokell.io/blog">blog korporat</a> kami <a href="https://serokell.io/blog">,</a> kami sering berbicara tentang mengapa kami menganggap kompleksitas bahasa fungsional sebagai hal yang berlebihan dan mengapa kami umumnya memilih mereka untuk berorientasi objek.  Ngomong-ngomong, itu juga berisi yang <a href="https://serokell.io/blog/ton-blockchain-competition">asli dari artikel ini</a> . </p><br><h2 id="pochemu-my-voobsche-reshili-uchastvovat">  Mengapa kami memutuskan untuk berpartisipasi </h2><br><p>  Singkatnya, karena spesialisasi kami adalah proyek non-standar dan kompleks yang memerlukan keterampilan khusus dan seringkali bernilai ilmiah bagi komunitas TI.  Kami dengan hangat mendukung pengembangan open-source dan terlibat dalam popularisasi, serta bekerja sama dengan universitas-universitas terkemuka di Rusia di bidang ilmu komputer dan matematika. </p><br><p>  Tugas-tugas menarik dari kontes dan keterlibatan dalam proyek Telegram, yang sangat kami cintai, dalam diri mereka sendiri adalah motivasi yang sangat baik, tetapi dana hadiah menjadi insentif tambahan.  :) </p><br><h2 id="issledovanie-blokcheyna-ton">  Penelitian TON Blockchain </h2><br><p>  Kami memantau dengan cermat perkembangan baru dalam blockchain, kecerdasan buatan dan pembelajaran mesin dan berusaha untuk tidak melewatkan satu pun rilis signifikan di setiap area tempat kami bekerja.  Karena itu, pada saat kompetisi dimulai, tim kami sudah terbiasa dengan ide-ide dari <a href="https://test.ton.org/ton.pdf">TON white paper</a> .  Namun, sebelum mulai bekerja dengan TON, kami tidak menganalisis dokumentasi teknis dan kode sumber aktual platform, sehingga langkah pertama cukup jelas - studi menyeluruh tentang dokumentasi resmi di <a href="https://test.ton.org/">situs web</a> dan di <a href="https://github.com/ton-blockchain/ton/tree/master/doc">repositori proyek</a> . </p><br><p>  Pada awal kontes, kode sudah diterbitkan, jadi untuk menghemat waktu, kami memutuskan untuk mencari panduan atau memeras yang ditulis oleh <em>pengguna</em> .  Sayangnya, ini tidak memberikan hasil - terlepas dari instruksi untuk membangun platform di Ubuntu, kami tidak menemukan bahan lain. </p><br><p>  Dokumentasi itu sendiri dikembangkan secara menyeluruh, tetapi sulit untuk membacanya di beberapa titik.  Cukup sering, kami harus kembali ke poin-poin tertentu dan beralih dari deskripsi ide abstrak tingkat tinggi ke detail implementasi level rendah. </p><br><p>  Akan lebih mudah jika spesifikasi sama sekali tidak memiliki deskripsi implementasi.  Informasi tentang bagaimana mesin virtual menyajikan tumpukannya lebih mengganggu bagi pengembang yang membuat kontrak pintar untuk platform TON daripada membantu mereka. </p><br><h2 id="nix-sobiraem-proekt">  Nix: membangun proyek </h2><br><p>  Di Serokell, kami adalah penggemar berat <a href="https://nixos.org/nix">Nix</a> .  Kami mengumpulkan proyek kami untuk mereka dan menggunakan mereka menggunakan <a href="https://nixos.org/nixops">NixOps</a> , dan <a href="https://nixos.org/">NixOS</a> diinstal pada semua server kami.  Berkat ini, semua build kami dapat direproduksi dan bekerja di bawah sistem operasi apa pun tempat Nix dapat diinstal. </p><br><p>  Jadi kami mulai dengan membuat <a href="">overlay Nix dengan ekspresi untuk membangun TON</a> .  Menggunakannya untuk mengkompilasi TON sesederhana mungkin: </p><br><pre><code class="plaintext hljs">$ cd ~/.config/nixpkgs/overlays &amp;&amp; git clone https://github.com/serokell/ton.nix $ cd /path/to/ton/repo &amp;&amp; nix-shell [nix-shell]$ cmakeConfigurePhase &amp;&amp; make</code> </pre> <br><p>  Perhatikan bahwa Anda tidak perlu menginstal dependensi apa pun.  Nix secara ajaib akan melakukan segalanya untuk Anda, apakah Anda menggunakan NixOS, Ubuntu atau macOS. </p><br><h2 id="programmirovanie-dlya-ton">  Pemrograman untuk TON </h2><br><p>  Kode kontrak pintar TON Network dijalankan pada TON Virtual Machine (TVM).  TVM lebih rumit daripada kebanyakan mesin virtual lainnya, dan memiliki fungsionalitas yang sangat menarik, misalnya, ia dapat bekerja dengan <em>kelanjutan</em> dan <em>tautan ke data</em> . </p><br><p>  Selain itu, TON guys menciptakan tiga bahasa pemrograman baru: </p><br><p>  <strong>Fift</strong> adalah bahasa pemrograman stack universal yang mengingatkan pada <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25BE%25D1%2580%25D1%2582_(%25D1%258F%25D0%25B7%25D1%258B%25D0%25BA_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">Forth</a> .  Kemampuan supernya adalah kemampuan untuk berinteraksi dengan TVM. </p><br><p>  <strong>FunC</strong> adalah bahasa pemrograman kontrak pintar yang mirip dengan <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B8_(%25D1%258F%25D0%25B7%25D1%258B%25D0%25BA_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">C</a> dan dikompilasi ke bahasa lain - Fift Assembler. </p><br><p>  <strong>Fift Assembler</strong> - Fift library untuk menghasilkan kode biner yang dapat dieksekusi untuk TVM.  Fift Assembler tidak memiliki kompiler.  Ini adalah <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B5%25D0%25B4%25D0%25BC%25D0%25B5%25D1%2582%25D0%25BD%25D0%25BE-%25D0%25BE%25D1%2580%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D0%25B9_%25D1%258F%25D0%25B7%25D1%258B%25D0%25BA">bahasa khusus domain tertanam (eDSL)</a> . </p><br><h2 id="nashi-konkursnye-raboty">  Karya kompetitif kami </h2><br><p>  Akhirnya, saatnya untuk melihat hasil dari upaya kami. </p><br><h3 id="asinhronnyy-platezhnyy-kanal">  <strong>Saluran Pembayaran Asinkron</strong> </h3><br><p>  Saluran pembayaran - kontrak pintar yang memungkinkan dua pengguna untuk mengirim pembayaran di luar blockchain.  Akibatnya, tidak hanya uang yang disimpan (tidak ada komisi), tetapi juga waktu (Anda tidak harus menunggu sampai blok berikutnya diproses).  Pembayaran dapat kecil dan sewenang-wenang dan terjadi sesering yang diperlukan.  Pada saat yang sama, para pihak tidak perlu saling mempercayai, karena keadilan penyelesaian akhir dijamin oleh kontrak yang cerdas. </p><br><p>  Kami menemukan solusi yang cukup sederhana untuk masalah ini.  Dua pihak dapat bertukar pesan yang ditandatangani, masing-masing berisi dua angka - jumlah total yang dibayarkan oleh masing-masing peserta.  Dua angka ini bekerja seperti <a href="https://ru.wikipedia.org/wiki/%25D0%2592%25D0%25B5%25D0%25BA%25D1%2582%25D0%25BE%25D1%2580%25D0%25BD%25D1%258B%25D0%25B5_%25D1%2587%25D0%25B0%25D1%2581%25D1%258B">jam vektor</a> dalam sistem terdistribusi tradisional dan mengatur urutan "terjadi sebelum" pada transaksi.  Dengan menggunakan data ini, kontrak akan dapat menyelesaikan kemungkinan konflik. </p><br><p>  Sebenarnya, untuk mengimplementasikan ide ini, satu angka sudah cukup, tetapi kami meninggalkan keduanya, karena kami dapat membuat antarmuka pengguna yang lebih nyaman.  Selain itu, kami memutuskan untuk memasukkan jumlah pembayaran dalam setiap pesan.  Tanpanya, jika pesan hilang karena beberapa alasan, maka meskipun semua jumlah dan perhitungan akhir akan benar, pengguna mungkin tidak melihat kehilangan. </p><br><p>  Untuk menguji ide kami, kami mencari contoh penggunaan protokol saluran pembayaran yang sederhana dan ringkas.  Yang mengejutkan, kami hanya menemukan dua: </p><br><ol><li>  <a href="https://medium.com/%40matthewdif/ethereum-payment-channel-in-50-lines-of-code-a94fad2704bc">Deskripsi</a> pendekatan yang serupa, hanya untuk saluran searah. </li><li>  <a href="https://programtheblockchain.com/posts/2018/02/23/writing-a-simple-payment-channel/">Tutorial</a> yang menjelaskan ide yang sama dengan kami, tetapi tanpa menjelaskan banyak detail penting, seperti kebenaran umum dan prosedur untuk menyelesaikan konflik. </li></ol><br><p>  Menjadi jelas bahwa masuk akal untuk menggambarkan protokol kami secara rinci, memberikan perhatian khusus pada kebenarannya.  Setelah beberapa iterasi, spesifikasinya sudah siap, dan sekarang Anda juga dapat melihatnya. </p><br><p>  Kami menerapkan kontrak untuk FunC, dan kami menulis utilitas baris perintah untuk berinteraksi dengan kontrak kami di Fift, sesuai rekomendasi panitia.  Kami dapat memilih bahasa lain untuk CLI kami, tetapi menarik bagi kami untuk mencoba Fift untuk melihat bagaimana itu menunjukkan dirinya dalam tindakan. </p><br><p>  Sejujurnya, setelah bekerja dengan Fift, kami melihat tidak ada alasan yang baik untuk memilih bahasa ini daripada bahasa yang populer dan digunakan secara aktif dengan alat dan perpustakaan yang dikembangkan.  Pemrograman dalam bahasa stack agak tidak menyenangkan, karena Anda harus selalu mengingat apa yang ada di stack, dan kompiler tidak membantu. </p><br><p>  Oleh karena itu, satu-satunya, menurut pendapat kami, pembenaran untuk keberadaan Fift adalah perannya sebagai bahasa utama untuk Fift Assembler.  Tapi bukankah lebih baik menanamkan assembler TVM dalam beberapa bahasa yang ada, dan tidak membuat yang baru untuk ini, pada dasarnya satu-satunya tujuan? </p><br><h3 id="tvm-haskell-edsl">  <strong>TVM Haskell eDSL</strong> </h3><br><p>  Sekarang saatnya berbicara tentang kontrak pintar kedua kami.  Kami memutuskan untuk mengembangkan dompet multi-tanda tangan, tetapi menulis kontrak pintar lain di FunC akan terlalu membosankan.  Kami ingin menambahkan beberapa semangat, dan itu menjadi bahasa rakitan kami sendiri untuk TVM. </p><br><p>  Seperti Fift Assembler, bahasa baru kami dapat disematkan, tetapi alih-alih Fift kami memilih Haskell sebagai tuan rumah, yang memungkinkan kami untuk sepenuhnya menggunakan sistem tipe canggihnya.  Ketika bekerja dengan kontrak pintar, di mana harga kesalahan kecil sekalipun bisa sangat tinggi, pengetikan statis, menurut kami, adalah keuntungan besar. </p><br><p>  Untuk menunjukkan seperti apa assembler TVM yang ada di Haskell, kami menerapkan dompet standar di atasnya.  Berikut adalah beberapa hal yang harus diperhatikan: </p><br><ul><li>  Kontrak ini terdiri dari satu fungsi, tetapi Anda dapat menggunakan sebanyak yang Anda suka.  Ketika Anda mendefinisikan fungsi baru dalam bahasa host (yaitu, di Haskell), eDSL kami memungkinkan Anda untuk memilih apakah Anda ingin mengubahnya menjadi subprogram terpisah di TVM atau hanya dibangun di tempat panggilan. </li><li>  Seperti Haskell, fungsi memiliki tipe yang diperiksa pada waktu kompilasi.  Dalam eDSL kami, tipe input fungsi adalah tipe stack yang diharapkan fungsi, dan tipe hasilnya adalah tipe stack yang akan diperoleh setelah panggilan. </li><li>  Kode ini memiliki anotasi <code>stacktype</code> yang menggambarkan tipe stack yang diharapkan pada rekan panggilan.  Dalam kontrak dompet asli, ini hanya komentar, tetapi dalam eDSL kami, mereka sebenarnya adalah bagian dari kode dan diperiksa pada waktu kompilasi.  Mereka dapat berfungsi sebagai dokumentasi atau pernyataan yang membantu pengembang menemukan masalah jika tipe tumpukan berubah seiring perubahan kode.  Tentu saja, anotasi semacam itu tidak memengaruhi kinerja runtime, karena tidak ada kode TVM yang dihasilkan untuknya. </li><li>  Ini masih merupakan prototipe yang ditulis dalam dua minggu, jadi masih banyak pekerjaan yang harus dilakukan pada proyek.  Misalnya, semua instance kelas yang Anda lihat dalam kode di bawah ini harus dihasilkan secara otomatis. </li></ul><br><p>  Inilah yang terlihat seperti implementasi dompet multisig di eDSL kami: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">main</span></span> :: <span class="hljs-type"><span class="hljs-type">IO</span></span> () main = putText $ pretty $ declProgram procedures methods <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> procedures = [ (<span class="hljs-string"><span class="hljs-string">"recv_external"</span></span>, decl recvExternal) , (<span class="hljs-string"><span class="hljs-string">"recv_internal"</span></span>, decl recvInternal) ] methods = [ (<span class="hljs-string"><span class="hljs-string">"seqno"</span></span>, declMethod getSeqno) ] <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Storage</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Storage</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sCnt</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Word32</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sPubKey</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PublicKey</span></span></span><span class="hljs-class"> } instance </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DecodeSlice</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Storage</span></span></span><span class="hljs-class"> where </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DecodeSliceFields</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Storage</span></span></span><span class="hljs-class"> = [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PublicKey</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Word32</span></span></span><span class="hljs-class">] decodeFromSliceImpl = do decodeFromSliceImpl @</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Word32</span></span></span><span class="hljs-class"> decodeFromSliceImpl @</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PublicKey</span></span></span><span class="hljs-class"> instance </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EncodeBuilder</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Storage</span></span></span><span class="hljs-class"> where encodeToBuilder = do encodeToBuilder @</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Word32</span></span></span><span class="hljs-class"> encodeToBuilder @</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PublicKey</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">WalletError</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SeqNoMismatch</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SignatureMismatch</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ord</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Generic</span></span></span><span class="hljs-class">) instance </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Exception</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">WalletError</span></span></span><span class="hljs-class"> instance </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Enum</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">WalletError</span></span></span><span class="hljs-class"> where toEnum 33 = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SeqNoMismatch</span></span></span><span class="hljs-class"> toEnum 34 = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SignatureMismatch</span></span></span><span class="hljs-class"> toEnum _ = error "</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Uknown</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MultiSigError</span></span></span><span class="hljs-class"> id" fromEnum </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SeqNoMismatch</span></span></span><span class="hljs-class"> = 33 fromEnum </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SignatureMismatch</span></span></span><span class="hljs-class"> = 34 recvInternal :: '[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Slice</span></span></span><span class="hljs-class">] :-&gt; '[] recvInternal = drop recvExternal :: '[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Slice</span></span></span><span class="hljs-class">] :-&gt; '[] recvExternal = do decodeFromSlice @</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Signature</span></span></span><span class="hljs-class"> dup preloadFromSlice @</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Word32</span></span></span><span class="hljs-class"> stacktype @[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Word32</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Slice</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Signature</span></span></span><span class="hljs-class">] </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">-- cnt cs sign pushRoot decodeFromCell @Storage stacktype @[PublicKey, Word32, Word32, Slice, Signature] -- pk cnt' cnt cs sign xcpu @1 @2 stacktype @[Word32, Word32, PublicKey, Word32, Slice, Signature] -- cnt cnt' pk cnt cs sign equalInt &gt;&gt; throwIfNot SeqNoMismatch push @2 sliceHash stacktype @[Hash Slice, PublicKey, Word32, Slice, Signature] -- hash pk cnt cs sign xc2pu @0 @4 @4 stacktype @[PublicKey, Signature, Hash Slice, Word32, Slice, PublicKey] -- pubk sign hash cnt cs pubk chkSignU stacktype @[Bool, Word32, Slice, PublicKey] -- ? cnt cs pubk throwIfNot SignatureMismatch accept swap decodeFromSlice @Word32 nip dup srefs @Word8 pushInt 0 if IsEq then ignore else do decodeFromSlice @Word8 decodeFromSlice @(Cell MessageObject) stacktype @[Slice, Cell MessageObject, Word8, Word32, PublicKey] xchg @2 sendRawMsg stacktype @[Slice, Word32, PublicKey] endS inc encodeToCell @Storage popRoot getSeqno :: '[] :-&gt; '[Word32] getSeqno = do pushRoot cToS preloadFromSlice @Word32</span></span></span></span></code> </pre> <br><p>  Kode sumber lengkap dari eDSL kami dan kontrak dompet multi-tanda tangan dapat ditemukan di <a href="https://github.com/serokell/fift-asm-dsl">repositori ini.</a>  Dan secara lebih <a href="https://serokell.io/blog/parsing-typed-edsl">rinci</a> kolega kami George Agapov <a href="https://serokell.io/blog/parsing-typed-edsl">berbicara</a> tentang <a href="https://serokell.io/blog/parsing-typed-edsl">bahasa</a> bawaan. </p><br><h2 id="vyvody-o-konkurse-i-ton">  Kesimpulan tentang kompetisi dan TON </h2><br><p>  Secara total, pekerjaan kami memakan waktu 380 jam (bersama dengan kenalan dengan dokumentasi, pertemuan, dan pengembangan itu sendiri).  Lima pengembang ikut serta dalam kompetisi: STO, pemimpin tim, spesialis platform blockchain, dan pengembang perangkat lunak Haskell. </p><br><p>  Kami menemukan sumber daya untuk berpartisipasi dalam kontes tanpa kesulitan, karena semangat hackathon, kerja tim yang erat, kebutuhan untuk perendaman cepat dalam aspek teknologi baru selalu menarik.  Beberapa malam tanpa tidur untuk mencapai hasil maksimal dalam kondisi sumber daya terbatas dikompensasi oleh pengalaman berharga dan kenangan indah.  Selain itu, mengerjakan tugas-tugas seperti itu selalu merupakan ujian yang baik untuk proses perusahaan, karena sangat sulit untuk mencapai hasil yang benar-benar layak tanpa interaksi internal yang sangat baik. </p><br><p>  Terlepas dari lirik: kami terkesan dengan jumlah pekerjaan yang dilakukan oleh tim TON.  Mereka berhasil membangun sistem kerja yang kompleks, indah, dan yang paling penting.  TON terbukti sebagai platform dengan potensi besar.  Namun, agar ekosistem ini berkembang, masih banyak yang harus dilakukan, baik dalam hal penggunaannya dalam proyek-proyek blockchain maupun dalam hal meningkatkan alat pengembangan.  Kami bangga menjadi bagian dari proses ini sekarang. </p><br><p>  Jika setelah membaca artikel ini Anda masih memiliki pertanyaan atau ide tentang cara menerapkan TON untuk menyelesaikan masalah Anda, <a href="https://serokell.io/">kirimkan kepada kami</a> - kami dengan senang hati akan berbagi pengalaman kami. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id476756/">https://habr.com/ru/post/id476756/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id476740/index.html">Jelajahi kegiatan cybergroup Donot Team</a></li>
<li><a href="../id476742/index.html">Bagaimana kami mengubah status "selalu berhubungan" untuk mencegah kelelahan profesional</a></li>
<li><a href="../id476748/index.html">sekitar teknologi: QATOK</a></li>
<li><a href="../id476752/index.html">Bagaimana lanskap TI di masa depan akan membantu menghubungkan konsumen, penyedia TI dan T & D bersama-sama</a></li>
<li><a href="../id476754/index.html">Cara mendorong akun untuk menggunakan layanan Yandex Maps API ke tetangga, atau mengapa raksasa TI memerlukan kontrol kualitas</a></li>
<li><a href="../id476758/index.html">Bagaimana Cara Memilih Filamen Cetak 3D yang Tepat?</a></li>
<li><a href="../id476760/index.html">Beberapa kata tentang manfaat membaca</a></li>
<li><a href="../id476770/index.html">"Oriole 2.0" - kereta tempat Anda akan bepergian di sepanjang WDC</a></li>
<li><a href="../id476772/index.html">DeepPavlov untuk pengembang: # 2 pengaturan dan penyebaran</a></li>
<li><a href="../id476774/index.html">Ulasan Playme TAU DVR: Mount Magnetic, Murah</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>