<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍🎤 ⏹️ 🧒🏿 Cara Kerja PageRank: Menerapkan dalam R melalui Aljabar Linier dan Metode Daya ☦️ ♐️ 🔁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, warga Habrovsk! 

 Nama saya Alex. Kali ini saya menyiarkan dari tempat kerja di ITAR-TASS. 

 Dalam teks singkat ini, saya akan memperkenalkan ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara Kerja PageRank: Menerapkan dalam R melalui Aljabar Linier dan Metode Daya</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439332/">  Halo, warga Habrovsk! <br><br>  Nama saya Alex.  Kali ini saya menyiarkan dari tempat kerja di ITAR-TASS. <br><br>  Dalam teks singkat ini, saya akan memperkenalkan metode penghitungan PageRank kepada Anda (selanjutnya saya akan menyebutnya PR) menggunakan contoh-contoh sederhana dan mudah dipahami, dalam bahasa R. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Algoritme</a> adalah properti intelektual Google, tetapi, karena kegunaannya untuk tugas analisis data, banyak tugas digunakan , yang dapat direduksi menjadi mencari node besar dalam grafik dan memeringkatnya berdasarkan kepentingan. <br><br>  Menyebutkan perusahaan besar dalam sebuah posting bukanlah iklan. <br><a name="habracut"></a><br>  Karena saya bukan ahli matematika profesional, saya menggunakan - dan merekomendasikan kepada Anda - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> ini dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tutorial</a> ini sebagai panduan. <br><br><h3>  Pemahaman PR yang intuitif </h3><br>  Memahami cara kerjanya tidak sulit.  Ada satu set elemen yang saling berhubungan.  Inilah cara tepatnya mereka terhubung - ini adalah pertanyaan luas: mungkin melalui tautan (seperti Google), mungkin dengan menyebutkan satu sama lain (tautan yang hampir sama), probabilitas transisi antar elemen (matriks proses Markov) dapat menjadi apriori yang ditentukan tanpa menentukan fisik. arti komunikasi.  Saya ingin menugaskan elemen-elemen ini kriteria penting tertentu, yang akan membawa informasi tentang <b>kemungkinan</b> bahwa elemen ini akan dikunjungi oleh beberapa partikel abstrak yang bergerak melalui grafik dalam proses difusi. <br><br>  Um, itu tidak terdengar terlalu jelas.  Lebih mudah membayangkan seorang pria menggunakan laptop dengan <s>opium</s> , menjelajahi halaman hasil pencarian, merokok hookah, mengikuti tautan dari satu halaman ke halaman lainnya dan semakin sering muncul di halaman (atau halaman) yang sama. <br><br>  Ini disebabkan oleh kenyataan bahwa beberapa halaman yang dia kunjungi mengandung informasi menarik di sumber aslinya sehingga halaman lain dipaksa untuk mencetaknya kembali dengan indikasi tautan. <br><br>  Orang seperti itu di Google bernama Surfer acak.  Dia adalah partikel dalam proses difusi: perubahan posisi diskrit pada grafik dari waktu ke waktu.  Dan kemungkinan dia mengunjungi halaman dengan waktu difusi yang cenderung tak terhingga adalah PR. <br><br><h3>  Implementasi sederhana perhitungan PR </h3><br>  Mari kita setuju - kita bekerja dengan 10 elemen, dalam grafik kecil yang kecil dan nyaman. <br><br><pre><code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># clear environment rm(list = ls()); gc() ## load libs library(data.table) library(magrittr) library(markovchain) ## dummy data number_nodes &lt;- 10 node_names &lt;- letters[seq_len(number_nodes)] set.seed(1) nodes &lt;- sapply( seq_len(number_nodes), function(x) { paste( c( node_names[-x] , sample(node_names[-x], sample(1:5, 1), replace = T) ) , collapse = ' ' ) } ) names(nodes) &lt;- node_names print( paste(nodes, collapse = '; ') ) ## make long dt dt &lt;- data.table( citing_node = node_names , cited_node = nodes ) %&gt;% .[, .(cited_node = unlist(strsplit(cited_node, ' '))), by = citing_node] %&gt;% dcast( . , cited_node ~ citing_node , fun.aggregate = length ) dt apply(dt[,-1,with=F], 2, sum) ## affinity matrix A &lt;- as.matrix(dt[, 2:dim(dt)[2]]) A &lt;- sweep(A, 2, colSums(A), `/`) A[is.nan(A)] &lt;- 0 rowSums(A) colSums(A) mark &lt;- new("markovchain", transitionMatrix = t(A), states = node_names, name = "mark") plot(mark)</span></span></code> </pre> <br>  Masing-masing dari 10 elemen (node) berisi 10 hingga 14 referensi ke node lain dalam urutan acak, tidak termasuk dirinya sendiri.  Untuk saat ini, kami hanya memutuskan bahwa data yang disebutkan adalah tautan web. <br><br>  Jelas bahwa beberapa elemen disebutkan lebih sering daripada yang lain.  Lihat ini. <br><blockquote>  Omong-omong, saya sarankan menggunakan paket data.table untuk eksperimen.  Sehubungan dengan prinsip-prinsip Tidyverse, semuanya ternyata efisien dan cepat. </blockquote><img src="https://habrastorage.org/webt/jl/qc/jm/jlqcjm-czf_eyevyiz1uxlssav0.png"><br><br>  Beginilah tampilan matriks tautan kami (paling sering disebut matriks adjacency). <br><br>  Jumlah dalam setiap kolom lebih besar dari nol, yang berarti bahwa ada hubungan dari setiap elemen dengan beberapa elemen lain (ini penting untuk analisis lebih lanjut). <br><blockquote>  &gt; berlaku (dt [, - 1, dengan = F], 2, jumlah) <br>  abcdefghij <br>  11 14 10 10 11 13 11 11 11 12 <br></blockquote><br>  Berdasarkan tabel ini, kita dapat membuat apa yang disebut matriks Afinitas, atau, menurut pendapat kami, matriks kedekatan (dan juga disebut matriks transisi), yang oleh para ahli matematika disebut matriks stokastik (matriks kolom-stokastik): <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sumber utama</a> <br><br>  Tetapkan ke variabel bernama A. <br><br><img src="https://habrastorage.org/webt/xv/x-/f0/xvx-f0z6eow64ngtc4tkofqolj8.png"><br><br>  Yang paling penting sekarang adalah jumlah dalam semua kolom sama dengan satu. <br><blockquote>  &gt; colSums (A) <br>  abcdefghij <br>  1 1 1 1 1 1 1 1 1 1 <br></blockquote><br>  Ini dia - matriks transisi, itu Markov, itu persamaan.  Angka adalah probabilitas transisi dari elemen dalam kolom ke elemen dalam satu baris. <br><br>  Ini, tentu saja, bukan "kesamaan" yang nyata.  Hadiah akan, misalnya, jika kita menghitung kosinus sudut antara penyajian dokumen.  Tetapi penting bahwa matriks transisi direduksi menjadi probabilitas (pseudo-) sehingga jumlah dari setiap kolom sama dengan satu. <br><br>  Mari kita lihat grafik transisi Markov (A kami): <br><br><img src="https://habrastorage.org/webt/s9/yv/br/s9yvbr-kaqvsyfqs0wokofkojpk.png"><br><br>  Semuanya kira-kira sama rata).  Ini karena kami menentukan transisi yang dapat disempurnakan. <br><br>  <b>Dan sekarang adalah waktu untuk sihir!</b> <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">## calculate pagerank ei &lt;- eigen(A) as.numeric(ei$values[1]) pr &lt;- as.numeric(ei$vectors[,1] / sum(ei$vectors[,1])) sum(pr) names(pr) &lt;- node_names print(round(pr, 2))</span></span></code> </pre><br>  Untuk matriks stokastik A, nilai eigen pertama harus sama dengan kesatuan, dan vektor eigen yang sesuai adalah vektor PageRank. <br><blockquote>  &gt; cetak (bulat (pr, 2)) <br>  abcdefghij <br>  0,09 0,11 0,09 0,10 0,10 0,11 0,10 0,11 0,08 0,11 <br></blockquote><br>  Ini adalah vektor dari nilai-nilai PR - ini adalah vektor eigen yang dinormalisasi dari matriks transisi A yang sesuai dengan nilai eigen dari matriks ini sama dengan satu kesatuan - vektor eigen dominan. <br><br>  Sekarang Anda dapat memberi peringkat elemen.  Tetapi karena spesifik dari percobaan, mereka memiliki bobot yang sangat mirip. <br><br><h3>  Masalah dan solusinya menggunakan metode daya </h3><br>  Matriks transisi A mungkin tidak memenuhi kondisi stokastik. <br><br>  <b>Pertama, mungkin ada elemen yang tidak merujuk ke mana pun, yaitu, dengan tidak adanya umpan balik (mereka dapat merujuknya sendiri).</b>  <b>Untuk grafik nyata yang besar, ini kemungkinan masalah.</b>  <b>Ini berarti bahwa salah satu kolom dari matriks hanya akan memiliki nol.</b>  <b>Dalam hal ini, solusi melalui vektor eigen tidak akan berfungsi.</b> <br><br>  Google memecahkan masalah ini dengan mengisi kolom dengan distribusi probabilitas seragam p = 1 / N.  Di mana N adalah jumlah semua elemen. <br><br><pre> <code class="python hljs">dim<span class="hljs-number"><span class="hljs-number">.1</span></span> &lt;- dim(A)[<span class="hljs-number"><span class="hljs-number">1</span></span>] A &lt;- <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>.data.table(A) nul_cols &lt;- apply(A, <span class="hljs-number"><span class="hljs-number">2</span></span>, function(x) sum(x) == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( sum(nul_cols) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) { A[ , (colnames(A)[nul_cols]) := lapply(.SD, function(x) <span class="hljs-number"><span class="hljs-number">1</span></span> / dim<span class="hljs-number"><span class="hljs-number">.1</span></span>) , .SDcols = colnames(A)[nul_cols] ] } A &lt;- <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>.matrix(A)</code> </pre><br>  <b>Kedua, grafik dapat berisi elemen dengan umpan balik satu sama lain, tetapi tidak elemen yang tersisa dari grafik.</b>  <b>Ini juga merupakan masalah yang tidak dapat diatasi untuk aljabar linier karena pelanggaran asumsi.</b> <br><br>  Ini diselesaikan dengan memperkenalkan konstanta yang disebut faktor Redaman, yang menunjukkan probabilitas a priori dari transisi dari elemen apa pun ke elemen lainnya, bahkan jika tidak ada hubungan fisik.  Dengan kata lain, difusi dimungkinkan dalam kondisi apa pun. <br><br><pre> <code class="python hljs">d = <span class="hljs-number"><span class="hljs-number">0.15</span></span> <span class="hljs-comment"><span class="hljs-comment">#damping factor (to ensure algorithm convergence) M &lt;- (1 - d) * A + d * (1 / dim.1 * matrix(1, nrow = dim.1, ncol = dim.1)) # google matrix</span></span></code> </pre><br>  Jika kita menerapkan transformasi ini ke matriks kita, maka itu lagi dapat diselesaikan melalui vektor eigen! <br><br>  <b>Ketiga, matriks klise mungkin tidak persegi, tetapi ini sangat penting!</b>  <b>Saya tidak akan mengingat saat ini, karena saya percaya Anda sendiri yang akan mencari cara untuk memperbaikinya.</b> <br><br>  Tetapi ada metode yang lebih cepat dan lebih akurat, yang juga lebih ekonomis dalam memori (yang mungkin relevan untuk grafik besar): Metode daya. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">## pagerank function (tested on example from tutorial) rm(pagerank_func) pagerank_func &lt;- function( A #transition matrix , eps = 0.00001 #sufficiently small error , d = 0.15 #damping factor (to ensure algorithm convergence) ) { dim.1 &lt;- dim(A)[1] A &lt;- as.data.table(A) nul_cols &lt;- apply(A, 2, function(x) sum(x) == 0) if( sum(nul_cols) &gt; 0 ) { A[ , (colnames(A)[nul_cols]) := lapply(.SD, function(x) 1 / dim.1) , .SDcols = colnames(A)[nul_cols] ] } A &lt;- as.matrix(A) M &lt;- (1 - d) * A + d * (1 / dim.1 * matrix(1, nrow = dim.1, ncol = dim.1)) # google matrix rank = as.numeric(rep(1 / dim.1, dim.1)) ## iterate until convergence while( sum( (rank - M %*% rank) ^ 2 ) &gt; eps ) { rank &lt;- M %*% rank } return(rank) } pr2 &lt;- pagerank_func(A) pr2=as.vector(pr2) names(pr2)=node_names</span></span></code> </pre><br>  Voila! <br><blockquote>  &gt; cetak (bulat (pr, 2)) <br>  abcdefghij <br>  0,09 0,11 0,09 0,10 0,10 0,11 0,10 0,11 0,08 0,11 <br>  &gt; cetak (bulat (pr2, 2)) <br>  abcdefghij <br>  0,09 0,11 0,09 0,10 0,10 0,11 0,10 0,11 0,08 0,11 <br></blockquote><br>  Pada ini saya akan mengakhiri tutorial.  Semoga bermanfaat. <br><br>  Saya lupa mengatakan bahwa untuk membangun matriks transisi (probabilitas), Anda dapat menggunakan kesamaan teks, jumlah referensi, fakta tautan, dan metrik lain yang mengarah pada probabilitas semu atau probabilitas.  Contoh yang agak menarik adalah rangking kalimat dalam teks pada matriks kesamaan kata bags tf-idf untuk menyorot kalimat yang merangkum seluruh teks.  Mungkin ada penggunaan PR lainnya secara kreatif. <br><br>  Saya sarankan Anda mencoba sendiri untuk bermain dengan matriks transisi dan pastikan Anda mendapatkan nilai PR yang keren, yang juga cukup mudah untuk ditafsirkan. <br><br>  Jika Anda melihat ketidakakuratan atau kesalahan dengan saya - tunjukkan di komentar atau pesan, dan saya akan memperbaiki semuanya. <br><br>  Semua kode dikompilasi di sini: <br><br><div class="spoiler">  <b class="spoiler_title">Kode</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># clear environment rm(list = ls()); gc() ## load libs library(data.table) library(magrittr) library(markovchain) ## dummy data number_nodes &lt;- 10 node_names &lt;- letters[seq_len(number_nodes)] set.seed(1) nodes &lt;- sapply( seq_len(number_nodes), function(x) { paste( c( node_names[-x] , sample(node_names[-x], sample(1:5, 1), replace = T) ) , collapse = ' ' ) } ) names(nodes) &lt;- node_names print( paste(nodes, collapse = '; ') ) ## make long dt dt &lt;- data.table( citing_node = node_names , cited_node = nodes ) %&gt;% .[, .(cited_node = unlist(strsplit(cited_node, ' '))), by = citing_node] %&gt;% dcast( . , cited_node ~ citing_node , fun.aggregate = length ) dt apply(dt[,-1,with=F], 2, sum) ## affinity matrix A &lt;- as.matrix(dt[, 2:dim(dt)[2]]) A &lt;- sweep(A, 2, colSums(A), `/`) A[is.nan(A)] &lt;- 0 rowSums(A) colSums(A) mark &lt;- new("markovchain", transitionMatrix = t(A), states = node_names, name = "mark") plot(mark) ## calculate pagerank ei &lt;- eigen(A) as.numeric(ei$values[1]) pr &lt;- as.numeric(ei$vectors[,1] / sum(ei$vectors[,1])) sum(pr) names(pr) &lt;- node_names print(round(pr, 2)) ## pagerank function (tested on example from tutorial) rm(pagerank_func) pagerank_func &lt;- function( A #transition matrix , eps = 0.00001 #sufficiently small error , d = 0.15 #damping factor (to ensure algorithm convergence) ) { dim.1 &lt;- dim(A)[1] A &lt;- as.data.table(A) nul_cols &lt;- apply(A, 2, function(x) sum(x) == 0) if( sum(nul_cols) &gt; 0 ) { A[ , (colnames(A)[nul_cols]) := lapply(.SD, function(x) 1 / dim.1) , .SDcols = colnames(A)[nul_cols] ] } A &lt;- as.matrix(A) M &lt;- (1 - d) * A + d * (1 / dim.1 * matrix(1, nrow = dim.1, ncol = dim.1)) # google matrix rank = as.numeric(rep(1 / dim.1, dim.1)) ## iterate until convergence while( sum( (rank - M %*% rank) ^ 2 ) &gt; eps ) { rank &lt;- M %*% rank } return(rank) } pr2 &lt;- pagerank_func(A) pr2=as.vector(pr2) names(pr2)=node_names print(round(pr, 2)) print(round(pr2, 2))</span></span></code> </pre><br></div></div><br>  PS: seluruh ide ini juga mudah diimplementasikan dalam bahasa lain, setidaknya dengan Python, saya melakukan semuanya tanpa kesulitan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id439332/">https://habr.com/ru/post/id439332/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id439320/index.html">Cara mendiversifikasi pelajaran pemrograman untuk anak-anak dari berbagai usia</a></li>
<li><a href="../id439324/index.html">Menggunakan pohon biner di swift dengan enum menggunakan OCR sebagai contoh</a></li>
<li><a href="../id439326/index.html">Pickup listrik Ford F-150 EV - dalam prototipe dan diuji di jalan</a></li>
<li><a href="../id439328/index.html">Oke Google! Apakah kamu baik atau jahat?</a></li>
<li><a href="../id439330/index.html">Pengakuan angka. Bagaimana kami mendapatkan akurasi 97% untuk angka Ukraina. Bagian 2</a></li>
<li><a href="../id439334/index.html">Sekitar 2 miliar rubel dialokasikan untuk implementasi RUU tentang runet berkelanjutan</a></li>
<li><a href="../id439336/index.html">Kami mencari jarum di tumpukan tanpa menggunakan algoritma yang terkenal</a></li>
<li><a href="../id439338/index.html">Lupakan privasi: Anda masih memiliki penargetan yang buruk</a></li>
<li><a href="../id439340/index.html">Cadangan GDPR - Bagaimana Alat Baru Akan Membantu</a></li>
<li><a href="../id439342/index.html">Pertemuan Musim Dingin DIYorDIE 17 Februari</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>