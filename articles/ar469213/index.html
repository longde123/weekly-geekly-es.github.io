<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚶🏽 ✌🏻 🦋 استكشاف محلل اندماجي مع الصدأ 🏴󠁧󠁢󠁷󠁬󠁳󠁿 👈🏽 😬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="مرحبا يا هبر! أقدم لكم ترجمة المقال "Learning Combinators Parser With Rust" . 


 هذا المقال يعلم أساسيات المحللون التوافقيين للأشخاص الذين هم بالفعل ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>استكشاف محلل اندماجي مع الصدأ</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469213/" style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl">  مرحبا يا هبر!  أقدم لكم ترجمة المقال <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">"Learning Combinators Parser With Rust"</a> . </p><br><p style=";text-align:right;direction:rtl">  <em>هذا المقال يعلم أساسيات المحللون التوافقيين للأشخاص الذين هم بالفعل على دراية الصدأ.</em>  <em>من المفترض أنه ليست هناك حاجة إلى معرفة أخرى ، وسيتم شرح كل ما لا يرتبط مباشرة بالصدأ ، وكذلك بعض الجوانب غير المتوقعة من استخدامه.</em>  <em>لن تساعدك هذه المقالة على تعلم "الصدأ" إذا لم تكن تعرفها بالفعل ، وفي هذه الحالة ، من المرجح أنك لن تفهم جيدًا اللغويين.</em>  <em>إذا كنت تريد أن تتعلم الصدأ ، فإنني أوصي بكتاب <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">"لغة برمجة الصدأ"</a> .</em> </p><a name="habracut"></a><br><h3 id="s-tochki-zreniya-novichka" style=";text-align:right;direction:rtl">  من وجهة نظر المبتدئين </h3><br><p style=";text-align:right;direction:rtl">  في حياة كل مبرمج ، يأتي وقت يحتاج فيه إلى محلل. </p><br><p style=";text-align:right;direction:rtl">  سوف يسأل مبرمج مبتدئ: "ما هو المحلل اللغوي؟" </p><br><p style=";text-align:right;direction:rtl">  سيقول مبرمج المستوى المتوسط: "الأمر بسيط ، سأكتب تعبيرًا منتظمًا." </p><br><p style=";text-align:right;direction:rtl">  سيقول المبرمج الرئيسي: "ابتعد ، أعرف lex و yacc". </p><br><p style=";text-align:right;direction:rtl">  مبتدئ يفكر أفضل من كل شيء. </p><br><p style=";text-align:right;direction:rtl">  ليس هذا التعبيرات العادية سيئة.  (لكن من فضلك ، لا تحاول كتابة محلل معقد كتعبير عادي.) لا يوجد أي فرح في استخدام أدوات قوية مثل المولدات اللغوية والمحلل الذي تم تكريمه على نحو مثالي لآلاف السنين.  لكن تعلم أساسيات المحللون هو <em>متعة</em> .  هذا أيضًا ما ستفتقده إذا شعرت بالهلع عند استخدام التعبيرات المعتادة أو المولدات اللغوية ، وكلاهما مجرد أفكار تجريدية من المشكلة الحقيقية.  في ذهن المبتدئين ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">كما قال الرجل</a> ، هناك العديد من الاحتمالات.  وفقا للخبير ، هناك خيار واحد صحيح فقط. </p><br><p style=";text-align:right;direction:rtl">  في هذه المقالة ، سوف نتعلم كيفية بناء المحلل اللغوي من البداية مع <br>  باستخدام طريقة شائعة في لغات البرمجة الوظيفية المعروفة باسم <em>المحلل اللغوي</em> .  يتمتعون بميزة كونهم أقوياء بشكل مدهش بمجرد فهمهم لفكرتهم الأساسية ، بينما يظلون قريبين جدًا من المبدأ الأساسي.  لأن التجريدات الوحيدة هنا هي تلك التي تنشئها بنفسك.  المجمعات الرئيسية التي ستستخدمها هنا سوف تبني نفسك. </p><br><h3 id="kak-rabotat-s-etoy-statyoy" style=";text-align:right;direction:rtl">  كيفية العمل مع هذه المادة </h3><br><p style=";text-align:right;direction:rtl"> يوصى بشدة أن تبدأ بمشروع Rust جديد وأن تكتب مقتطفات برمجية بـ <code>src/lib.rs</code> أثناء قراءتها (يمكنك لصقها مباشرةً من الصفحة ، ولكن إدخالها بشكل أفضل ، لأن هذا يضمن لك تلقائيًا قراءتها بالكامل).  يتم ترتيب جميع أجزاء التعليمات البرمجية التي تحتاجها بالترتيب في المقالة.  ضع في اعتبارك أنه في بعض الأحيان يتم تقديم إصدارات <em>معدلة</em> من الوظائف التي كتبتها سابقًا ، وفي هذه الحالات يجب استبدال الإصدار القديم بالإصدار الجديد. </p><br><p style=";text-align:right;direction:rtl">  تمت كتابة التعليمات البرمجية لإصدار rustc 1.34.0 باستخدام إصدار اللغة <code>2018</code> .  يمكنك استخدام أي إصدار من المحول البرمجي ، تأكد من أنك تستخدم إصدارًا يدعم إصدار <code>2018</code> (تأكد من أن <code>Cargo.toml</code> يحتوي على <code>edition = "2018"</code> ).  هذا المشروع لا يحتاج التبعيات الخارجية. </p><br><p style=";text-align:right;direction:rtl">  لإجراء الاختبارات المقدمة في المقالة ، كما هو متوقع ، <code>cargo test</code> . </p><br><h3 id="xcruciating-yazyk-razmetki" style=";text-align:right;direction:rtl">  لغة الترميز </h3><br><p style=";text-align:right;direction:rtl">  سنقوم بكتابة محلل لإصدار مبسط من XML.  يبدو مثل هذا: </p><br><pre style=";text-align:right;direction:rtl"> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">parent-element</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">single-element</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">attribute</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"value"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">parent-element</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  يتم فتح عناصر XML مع <code>&lt;</code> حرف ومعرف يتكون من حرف متبوعًا بأي عدد من الأحرف والأرقام و <code>-</code> .  يتبع ذلك مسافات وقائمة اختيارية من أزواج السمات: معرف آخر كما هو محدد مسبقًا ، متبوعًا بعلامة <code>=</code> وسلسلة في علامات اقتباس مزدوجة.  أخيرًا ، يوجد إما رمز إغلاق <code>/&gt;</code> للإشارة إلى عنصر واحد بدون أطفال ، أو <code>&gt;</code> للإشارة إلى وجود السلسلة التالية من العناصر الفرعية ، وعلامة إغلاق تبدأ بـ <code>&lt;/</code> ، متبوعة بمعرف يجب أن يتطابق مع علامة الفتح ، ورمز إغلاق <code>&gt;</code> . </p><br><p style=";text-align:right;direction:rtl">  هذا هو كل ما سندعمه.  لن يكون هناك مساحات أسماء ، ولا توجد نقاط نصية ، <em>وبالتأكيد</em> لن يكون هناك فحص مخطط.  لا داعي للقلق حتى من الفرار من علامات اقتباس للسلاسل - فهي تبدأ مع أول اقتباس مزدوج ، وتنتهي بالرقم التالي ، وهذا كل شيء. </p><br><p style=";text-align:right;direction:rtl">  سنقوم بتحليل هذه العناصر إلى هيكل يشبه هذا: </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Clone, Debug, PartialEq, Eq)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Element</span></span></span></span> { name: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, attributes: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>)&gt;, children: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;Element&gt;, }</code> </pre> <br><p style=";text-align:right;direction:rtl">  لا توجد أنواع فاخرة ، مجرد سلسلة للاسم (هذا هو المعرف في بداية كل علامة) ، وسمات في شكل أزواج من السلاسل (المعرّف والقيمة) وقائمة بالأطفال الذين يشبهون الأصل تمامًا. </p><br><p style=";text-align:right;direction:rtl">  (إذا كنت تطبع ، فتأكد من تضمين قسم <code>derive</code> . ستحتاج إليه لاحقًا.) </p><br><h3 id="opredelenie-parsera" style=";text-align:right;direction:rtl">  تعريف المحلل </h3><br><p style=";text-align:right;direction:rtl">  حسنًا ، لقد حان الوقت لكتابة المحلل اللغوي. </p><br><p style=";text-align:right;direction:rtl">  التحليل هو عملية الحصول على بيانات منظمة من دفق المعلومات.  المحلل اللغوي هو ما يبرز هذا الهيكل. </p><br><p style=";text-align:right;direction:rtl">  في الانضباط الذي سنستكشفه ، المحلل اللغوي ، في أبسط أشكاله ، هو وظيفة تأخذ بعض المدخلات وتُرجع إما المخرجات التي تم تحليلها جنبًا إلى جنب مع بقية المدخلات ، أو خطأً يقول "لا يمكنني تحليل ذلك". </p><br><p style=";text-align:right;direction:rtl">  المحلل اللغوي يبحث أيضًا في أشكاله الأكثر تعقيدًا.  يمكنك تعقيد معنى الإدخال والإخراج والخطأ ، وإذا كنت بحاجة إلى رسائل خطأ جيدة تحتاجها ، إلا أن المحلل اللغوي يظل كما هو: شيء يستهلك المدخلات وينتج نوعًا من الإخراج المحلل مع ما يتبقى من المدخلات أو يتيح لك معرفة أنه لا يمكن تحليل الإدخال إلى الإخراج. </p><br><p style=";text-align:right;direction:rtl">  دعنا اكتبها كنوع من الوظيفة. </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(Input) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(Input, Output), Error&gt;</code> </pre> <br><p style=";text-align:right;direction:rtl">  بشكل أكثر تحديدًا: في حالتنا ، نريد ملء الأنواع والحصول على وظيفة مماثلة لهذه الوظيفة.  كل ما سنقوم به هو تحويل السلسلة إلى بنية <code>Element</code> .  في الوقت الحالي ، لا نريد الدخول في تفاصيل رسائل الخطأ ، ما عليك سوى إرجاع جزء السطر الذي لم نتمكن من تحليله.  نتيجة لذلك ، ستبدو وظيفتنا كما يلي: </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, Element), &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt;</code> </pre> <br><p style=";text-align:right;direction:rtl">  نحن نستخدم شريحة السلسلة لأنها مؤشر فعال لجزء من السلسلة ، ومن ثم يمكننا فصلها كما نحب من خلال "استهلاك" بيانات الإدخال ، واستبعاد الجزء الذي تم تحليله وإرجاع الباقي مع النتيجة. </p><br><p style=";text-align:right;direction:rtl">  قد يكون من <code>&amp;[u8]</code> استخدام <code>&amp;[u8]</code> (شريحة من البايتات تتطابق مع أحرف ASCII) كنوع إدخال ، خاصة وأن شرائح السلسلة تتصرف بشكل مختلف قليلاً عن معظم الشرائح - خاصة وأنك لا تستطيع فهرستها بواحد <code>input[0]</code> الأرقام <code>input[0]</code> ، يجب عليك استخدام جزء <code>input[0..1]</code> .  من ناحية أخرى ، لديهم العديد من الطرق المفيدة لتحليل السلاسل التي لا تحتوي على شرائح بايت. </p><br><p style=";text-align:right;direction:rtl">  في الواقع ، سوف نعتمد على الأساليب ، وليس استخدام فهارس الحروف ، لأن يونيكود.  في UTF-8 ، وجميع سلاسل Rust هي سلاسل UTF-8 صالحة ، هذه المؤشرات لا تتوافق دائمًا مع الأحرف الفردية ، ومن الأفضل لجميع الأطراف المهتمة أن تطلب من المكتبة القياسية العمل معها من أجلنا. </p><br><h3 id="nash-pervyy-parser" style=";text-align:right;direction:rtl">  أول محلل لدينا </h3><br><p style=";text-align:right;direction:rtl">  دعنا نحاول كتابة محلل يبحث فقط عن الحرف الأول في السلسلة <br>  وتقرر ما إذا كانت الرسالة <code>a</code> . </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the_letter_a</span></span></span></span>(input: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, ()), &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> input.chars().next() { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-string"><span class="hljs-string">'a'</span></span>) =&gt; <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((&amp;input[<span class="hljs-string"><span class="hljs-string">'a'</span></span>.len_utf8()..], ())), _ =&gt; <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(input), } }</code> </pre> <br><p style=";text-align:right;direction:rtl">  أولاً ، دعونا نلقي نظرة على أنواع المدخلات والمخرجات: نأخذ شريحة سلسلة كمدخلات <code>Result</code> مع <code>(&amp;str, ())</code> ، أو خطأ مع <code>&amp;str</code> .  الزوج <code>(&amp;str, ())</code> هو نقطة مثيرة للاهتمام: كما قلنا أنه يجب علينا إرجاع مجموعة من المحتوى التالي ، <br>  تحليل النتيجة وبقية المدخلات.  <code>&amp;str</code> هو الإدخال التالي ، والنتيجة هي مجرد نوع كتلة <code>()</code> ، لأنه إذا كان هذا المحلل يعمل بنجاح ، فيمكن أن يكون له نتيجة واحدة فقط (وجدنا الحرف <code>a</code> ) ، ونحن لسنا بحاجة حقًا إلى العودة <br>  الرسالة <code>a</code> في هذه الحالة نحتاج فقط إلى الإشارة إلى أننا تمكنا من العثور عليها. </p><br><p style=";text-align:right;direction:rtl">  لذلك ، دعونا ننظر إلى رمز المحلل اللغوي نفسه.  لم نكن نكتفي بالاعتماد على المكتبة القياسية ، فيمكننا تجنب الصداع باستخدام Unicode: نحصل على مكرر على أحرف السلسلة باستخدام طريقة <code>chars()</code> ونأخذ الحرف الأول منها.  سيكون هذا عنصرًا من النوع <code>char</code> ملفوفًا في <code>Option</code> ، والذي <code>None</code> يعني فيه وجود أننا نحاول سحب <code>char</code> من سلسلة فارغة. </p><br><p style=";text-align:right;direction:rtl">  ومما زاد الطين بلة ، <code>char</code> ليس بالضرورة ما تفكر فيه كحرف يونيكود.  من المحتمل أن يكون هذا هو ما يسميه Unicode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">"مجموعة grapheme"</a> ، والتي يمكن أن تتكون من عدة أحرف <code>char</code> ، والتي هي في الواقع <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">"قيم عددية"</a> ، والتي هي مستويين أدنى من مجموعات grapheme.  ومع ذلك ، يؤدي هذا المسار إلى الجنون ، ولأغراضنا ، من غير المرجح أن نرى <code>chars</code> خارج <code>chars</code> ASCII ، لذلك دعونا نتوقف عند هذا الحد. </p><br><p style=";text-align:right;direction:rtl">  نقوم بالتعيين على نمط <code>Some('a')</code> ، وهي النتيجة المحددة التي نبحث عنها ، وإذا تطابق ذلك ، نرجع قيمة نجاحنا: <br>  <code>Ok((&amp;input['a'.len_utf8()..], ()))</code> .  وهذا يعني أننا نزيل الجزء الذي قمنا بتحليله ( <code>'a'</code> ) من شريحة السطر ونعيد الباقي إلى جانب قيمنا التي تم تحليلها ، والتي تكون خالية فقط <br>  <code>()</code> .  تذكر دائمًا وحش Unicode ، قبل القطع ، اكتشفنا الطول في UTF-8 للشخصية <code>'a'</code> خلال المكتبة القياسية - إنها 1 (لكن لا تنسى وحش Unicode). </p><br><p style=";text-align:right;direction:rtl">  إذا حصلنا على <code>Some(char)</code> الأخرى <code>Some(char)</code> ، أو إذا حصلنا على <code>None</code> ، فإننا نرجع خطأً.  كما تتذكر ، لدينا نوع من الخطأ هو مجرد شريحة سلسلة ، والتي مررنا بها <code>input</code> والتي لا يمكن تحليلها.  لم تبدأ بـ ، لذلك هذا خطأنا.  هذا ليس خطأً كبيراً ، لكنه على الأقل أفضل قليلاً من مجرد "شيء ما خطأ في مكان ما." </p><br><p style=";text-align:right;direction:rtl">  لا نحتاج حقًا إلى هذا المحلل اللغوي لتحليل XML ، ولكن أول شيء يتعين علينا فعله هو العثور على الحرف الافتتاحي ، لذلك نحن بحاجة إلى شيء مشابه جدًا.  سنحتاج أيضًا إلى تحليل <code>&gt;</code> و <code>/</code> و <code>=</code> وجه التحديد ، لذلك ربما يمكننا إنشاء دالة تقوم بإنشاء المحلل اللغوي للشخصية التي نريدها؟ </p><br><h3 id="sozdanie-parsera" style=";text-align:right;direction:rtl">  خلق محلل </h3><br><p style=";text-align:right;direction:rtl">  دعونا نفكر في هذا الأمر: سنقوم بكتابة دالة تقوم بإنشاء محلل لسلسلة ثابتة من <em>أي طول</em> ، وليس مجرد حرف واحد.  هذا أبسط لأن جزء الخط هو بالفعل شريحة سطر UTF-8 صالحة ، ونحن لسنا بحاجة للتفكير في وحش يونيكود. </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">match_literal</span></span></span></span>(expected: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, ()), &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |input| <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> input.get(<span class="hljs-number"><span class="hljs-number">0</span></span>..expected.len()) { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(next) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> next == expected =&gt; { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((&amp;input[expected.len()..], ())) } _ =&gt; <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(input), } }</code> </pre> <br><p style=";text-align:right;direction:rtl">  الآن يبدو مختلفا بعض الشيء. </p><br><p style=";text-align:right;direction:rtl">  بادئ ذي بدء ، دعونا ننظر إلى الأنواع.  الآن تأخذ <code>expected</code> السلسلة <code>expected</code> كوسيطة <em>وتعيد</em> شيئًا مشابهًا للمحلل ، بدلاً من أن تكون محللًا نفسه.  هذه دالة تقوم بإرجاع <em>دالة ذات ترتيب أعلى</em> .  في الأساس ، نكتب وظيفة <em>تجعل</em> وظيفة مشابهة لوظيفة <code>the_letter_a</code> السابقة. </p><br><p style=";text-align:right;direction:rtl">  وبالتالي ، بدلاً من أداء العمل في نص الوظيفة ، نرجع الإغلاق الذي يؤدي هذا العمل والذي يتوافق مع توقيع نوعنا للمحلل من السابق. </p><br><p style=";text-align:right;direction:rtl">  تبدو مطابقة الأنماط كما هي ، باستثناء أنه لا يمكننا مطابقة سلسلة حروفنا بشكل مباشر ، لأننا لا نعرف بالضبط ، لذلك نستخدم شرط المطابقة <code>if next == expected</code> .  خلاف ذلك ، هو بالضبط نفس الشيء كما كان من قبل ، فقط داخل جسم الدائرة. </p><br><h3 id="testirovanie-nashego-parsera" style=";text-align:right;direction:rtl">  اختبار محلل لدينا </h3><br><p style=";text-align:right;direction:rtl">  دعنا نكتب اختبارًا لهذا للتأكد من حصولنا عليه بشكل صحيح. </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">literal_parser</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> parse_joe = match_literal(<span class="hljs-string"><span class="hljs-string">"Hello Joe!"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>( <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((<span class="hljs-string"><span class="hljs-string">""</span></span>, ())), parse_joe(<span class="hljs-string"><span class="hljs-string">"Hello Joe!"</span></span>) ); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>( <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((<span class="hljs-string"><span class="hljs-string">" Hello Robert!"</span></span>, ())), parse_joe(<span class="hljs-string"><span class="hljs-string">"Hello Joe! Hello Robert!"</span></span>) ); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>( <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello Mike!"</span></span>), parse_joe(<span class="hljs-string"><span class="hljs-string">"Hello Mike!"</span></span>) ); }</code> </pre> <br><p style=";text-align:right;direction:rtl">  أولاً نقوم بإنشاء محلل: <code>match_literal("Hello Joe!")</code> .  يجب أن تستهلك السلسلة <code>"Hello Joe!"</code>  وإرجاع بقية السلسلة ، أو فشل وإرجاع السلسلة بأكملها. </p><br><p style=";text-align:right;direction:rtl">  في الحالة الأولى ، نمررها بالصف الدقيق الذي نتوقعه ، ونرى أنه يعرض سلسلة فارغة والقيمة <code>()</code> ، مما يعني "لقد قمنا بتحليل السلسلة المتوقعة ، ولا تحتاج إلى إرجاعها." </p><br><p style=";text-align:right;direction:rtl">  في المجموعة الثانية ، نطعم السلسلة <code>"Hello Joe! Hello Robert!"</code>  ونحن نرى أنه يستخدم حقًا السلسلة <code>"Hello Joe!"</code>  وإرجاع ما تبقى من المدخلات: <code>" Hello Robert!"</code>  (المسافة الرائدة وكل شيء آخر). </p><br><p style=";text-align:right;direction:rtl">  في الثالث ، ندخل الإدخال الخاطئ: <code>"Hello Mike!"</code>  ولاحظ أنه يرفض حقا الإدخال مع وجود خطأ.  ليس أن <code>Mike</code> مخطئ ، عادة ليس فقط ما كان يبحث عنه المحلل اللغوي. </p><br><h3 id="parser-dlya-chego-to-menee-specifichnogo" style=";text-align:right;direction:rtl">  محلل لشيء أقل تحديدا </h3><br><p style=";text-align:right;direction:rtl">  وهذا يتيح لنا تحليل <code>&lt;</code> ، <code>&gt;</code> ، <code>=</code> وحتى <code>&lt;/</code> و <code>/&gt;</code> .  لقد انتهينا تقريبا! </p><br><p style=";text-align:right;direction:rtl">  التالي بعد حرف الفتح <code>&lt;</code> هو اسم العنصر.  لا يمكننا القيام بذلك بمقارنة سلسلة بسيطة.  ولكن يمكننا <em>أن</em> نفعل ذلك مع ريكس ... </p><br><p style=";text-align:right;direction:rtl">  ... ولكن دعنا نقف.  سيكون هذا تعبيرًا عاديًا سيكون من السهل جدًا نسخه في رمز بسيط ، ولهذا لا نحتاج إلى استخدام حزمة <code>regex</code> .  دعونا نرى ما إذا كان بإمكاننا كتابة محلل اللغة الخاص بنا لهذا الغرض ، وذلك باستخدام مكتبة Rust القياسية فقط. </p><br><p style=";text-align:right;direction:rtl">  استرجع القاعدة الخاصة بمعرف اسم العنصر ، تبدو كما يلي: حرف أبجدي واحد ، متبوعًا بصفر أو أكثر من أي رمز أبجدي ، <br>  حرف أو رقم أو اندفاعة. </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">identifier</span></span></span></span>(input: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>), &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> matched = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> chars = input.chars(); <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> chars.next() { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(next) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> next.is_alphabetic() =&gt; matched.push(next), _ =&gt; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(input), } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(next) = chars.next() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> next.is_alphanumeric() || next == <span class="hljs-string"><span class="hljs-string">'-'</span></span> { matched.push(next); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> next_index = matched.len(); <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((&amp;input[next_index..], matched)) }</code> </pre> <br><p style=";text-align:right;direction:rtl">  كما هو الحال دائمًا ، ننظر أولاً إلى النوع.  هذه المرة لا نكتب وظيفة لإنشاء محلل ، نحن فقط نكتب المحلل اللغوي نفسه ، كما في المرة الأولى.  الفرق الملحوظ هنا هو أنه بدلاً من نوع النتيجة <code>()</code> نقوم بإرجاع <code>String</code> في المجموعة مع المدخلات المتبقية.  سوف تحتوي هذه <code>String</code> على المعرف الذي قمنا بتحليله للتو. </p><br><p style=";text-align:right;direction:rtl">  مع وضع ذلك في الاعتبار ، نقوم أولاً بإنشاء <code>String</code> فارغة نسميها <code>matched</code> .  ستكون هذه النتيجة.  نحصل أيضًا على مكرر للأحرف في <code>input</code> ، والتي سنبدأ في تقسيمها. </p><br><p style=";text-align:right;direction:rtl">  الخطوة الأولى هي معرفة ما إذا كان هناك رمز في البداية.  نقوم بسحب الحرف الأول من التكرار والتحقق مما إذا كان حرفًا: <code>next.is_alphabetic()</code> .  بطبيعة الحال ، فإن مكتبة Rust القياسية ، ستساعدنا في Unicode - فهي تتوافق مع الأحرف في أي حروف أبجدية ، وليس فقط في ASCII.  إذا كان خطابًا ، فسنضعه في سلسلتنا في المتغير <code>matched</code> ، وإذا لم يكن الأمر كذلك ، فنحن لا ننظر إلى معرف العنصر ونرجع فورًا مع وجود خطأ. </p><br><p style=";text-align:right;direction:rtl">  في الخطوة الثانية ، نستمر في سحب الأحرف من التكرار ، وإرسالها إلى السطر الذي <code>is_alphanumeric()</code> حتى <code>is_alphanumeric()</code> حرفًا لا يفي <code>is_alphanumeric()</code> يشبه <code>is_alphabetic()</code> باستثناء أنه يتضمن أيضًا أرقامًا في أي أبجدية) أو اندفاعة <code>'-'</code> . </p><br><p style=";text-align:right;direction:rtl">  عندما نرى لأول مرة شيئًا لا يلبي هذه المعايير ، فإننا ننهي التحليل ونكسر الحلقة <code>String</code> ، ونتذكر أن نقطع الجزء الذي استخدمناه من <code>input</code> .  وبالمثل ، إذا انتهت الأحرف في مكرر ، فهذا يعني أننا وصلنا إلى نهاية الإدخال. </p><br><p style=";text-align:right;direction:rtl">  تجدر الإشارة إلى أننا لا نرجع خطأً عندما نرى شيئًا ليس أبجديًا أو شرطيًا.  لدينا بالفعل ما يكفي لإنشاء معرّف صالح بعد أن نطابق هذه الحرف الأول ، ومن الطبيعي تمامًا أنه بعد تحليل معرفنا ، سيكون هناك المزيد من العناصر في سطر الإدخال للتحليل ، لذلك نوقف التحليل ونعيد نتيجتنا.  فقط إذا لم نتمكن من العثور حتى على هذه الرسالة الأولى ، فنحن نرجع خطأ بالفعل ، لأنه في هذه الحالة لا يوجد بالتأكيد معرف. </p><br><p style=";text-align:right;direction:rtl">  تذكر أن بنية <code>Element</code> هي ما سنقوم بتحليل مستند XML الخاص به. </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Element</span></span></span></span> { name: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, attributes: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>)&gt;, children: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;Element&gt;, }</code> </pre> <br><p style=";text-align:right;direction:rtl">  في الواقع ، لقد انتهينا للتو من محلل الجزء الأول ، حقل <code>name</code> .  <code>String</code> التي ترجع المحلل اللغوي لدينا تذهب مباشرة إلى هناك.  وهو أيضًا المحلل اللغوي الصحيح للجزء الأول من كل <code>attribute</code> . </p><br><p style=";text-align:right;direction:rtl">  دعونا التحقق من ذلك. </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">identifier_parser</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>( <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"i-am-an-identifier"</span></span>.to_string())), identifier(<span class="hljs-string"><span class="hljs-string">"i-am-an-identifier"</span></span>) ); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>( <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((<span class="hljs-string"><span class="hljs-string">" entirely an identifier"</span></span>, <span class="hljs-string"><span class="hljs-string">"not"</span></span>.to_string())), identifier(<span class="hljs-string"><span class="hljs-string">"not entirely an identifier"</span></span>) ); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>( <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(<span class="hljs-string"><span class="hljs-string">"!not at all an identifier"</span></span>), identifier(<span class="hljs-string"><span class="hljs-string">"!not at all an identifier"</span></span>) ); }</code> </pre> <br><p style=";text-align:right;direction:rtl">  نرى أنه في الحالة الأولى ، <code>"i-am-an-identifier"</code> تحليل السلسلة <code>"i-am-an-identifier"</code> تمامًا ، ولا تترك سوى سلسلة فارغة.  في الحالة الثانية ، يقوم المحلل بإرجاع <code>"not"</code> كمعرف ، ويتم إرجاع بقية السلسلة كمدخلات متبقية.  في الحالة الثالثة ، يفشل المحلل اللغوي على الفور ، لأن الحرف الأول الذي يعثر عليه ليس حرفًا. </p><br><h3 id="kombinatory" style=";text-align:right;direction:rtl">  combinators </h3><br><p style=";text-align:right;direction:rtl">  الآن يمكننا تحليل الحرف الافتتاحي <code>&lt;</code> ، ويمكننا تحليل المعرف التالي ، لكننا بحاجة إلى تحليل <em>كليهما</em> .  لذلك ، فإن الخطوة التالية هي كتابة دالة محلل اندماجي أخرى ، ولكن واحدة تأخذ <em>محللتين</em> كمدخلات وإرجاع <em>محلل</em> جديد يوزعهما بالترتيب.  بمعنى آخر ، <em>أداة الجمع</em> بين المحلل اللغوي لأنه يجمع بين اللغتين في واحدة جديدة.  دعونا نرى ما اذا كنا نستطيع القيام بذلك. </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pair</span></span></span></span>&lt;P1, P2, R1, R2&gt;(parser1: P1, parser2: P2) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, (R1, R2)), &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P1: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, R1), &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt;, P2: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, R2), &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt;, { <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |input| <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> parser1(input) { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((next_input, result1)) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> parser2(next_input) { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((final_input, result2)) =&gt; <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((final_input, (result1, result2))), <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err) =&gt; <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err), }, <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err) =&gt; <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err), } }</code> </pre> <br><p style=";text-align:right;direction:rtl">  يصبح الأمر أكثر صعوبة بعض الشيء هنا ، لكنك تعرف ما يجب فعله: ابدأ بالنظر في الأنواع. </p><br><p style=";text-align:right;direction:rtl">  بادئ ذي بدء ، لدينا أربعة أنواع من المتغيرات: <code>P1</code> ، <code>P2</code> ، <code>R1</code> و <code>R2</code> .  هذه هي <code>Parser 1</code> ، <code>Parser 2</code> ، <code>Result 1</code> <code>Result 2</code> .  <code>P1</code> و <code>P2</code> هي وظائف ، وستلاحظ أنها تتبع نمطًا ثابتًا من وظائف المحلل اللغوي: تمامًا مثل قيمة الإرجاع ، فإنها تأخذ <code>&amp;str</code> كمدخلات وإرجاع. ينتج <code>Result</code> زوج المدخلات <code>Result</code> المتبقية ، أو خطأ. </p><br><p style=";text-align:right;direction:rtl">  لكن انظر إلى أنواع نتائج كل وظيفة: <code>P1</code> هو المحلل اللغوي الذي يعطي <code>R1</code> إذا نجح ، و <code>P2</code> يعطي <code>R2</code> أيضًا.  وتكون نتيجة المحلل اللغوي الأخير الذي تم إرجاعه من <code>(R1, R2)</code> .  وبالتالي ، فإن مهمة هذا المحلل هي أولاً بدء تشغيل المحلل <code>P1</code> عند الإدخال ، وحفظ نتيجته ، ثم تشغيل <code>P2</code> عند الإدخال الذي أعاد <code>P1</code> ، وإذا <code>P1</code> كلاهما ، فإننا نجمع بين النتيجتين في tuple <code>(R1, R2)</code> . </p><br><p style=";text-align:right;direction:rtl">  يظهر الرمز أن هذا هو بالضبط ما يفعله.  نبدأ ببدء أول محلل عند المدخلات ، ثم بعد ذلك نحلل الثاني ، ثم نجمع بين النتيجتين في tuple ونعيده.  إذا فشل أي من هذه المحللون ، فسوف نعود على الفور مع الخطأ الذي أصدره. </p><br><p style=";text-align:right;direction:rtl">  وبالتالي ، يجب أن نكون قادرين على الجمع بين <code>match_literal</code> ، <code>match_literal</code> ، من أجل <code>match_literal</code> الأول من علامة XML الأولى.  دعنا نكتب اختبار لمعرفة ما إذا كان يعمل. </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pair_combinator</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> tag_opener = pair(match_literal(<span class="hljs-string"><span class="hljs-string">"&lt;"</span></span>), identifier); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>( <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((<span class="hljs-string"><span class="hljs-string">"/&gt;"</span></span>, ((), <span class="hljs-string"><span class="hljs-string">"my-first-element"</span></span>.to_string()))), tag_opener(<span class="hljs-string"><span class="hljs-string">"&lt;my-first-element/&gt;"</span></span>) ); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-literal"><span class="hljs-literal">Err</span></span>(<span class="hljs-string"><span class="hljs-string">"oops"</span></span>), tag_opener(<span class="hljs-string"><span class="hljs-string">"oops"</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-literal"><span class="hljs-literal">Err</span></span>(<span class="hljs-string"><span class="hljs-string">"!oops"</span></span>), tag_opener(<span class="hljs-string"><span class="hljs-string">"&lt;!oops"</span></span>)); }</code> </pre> <br><p style=";text-align:right;direction:rtl">  يبدو أن العمل!  لكن انظر إلى هذا النوع من النتائج: <code>((), String)</code> .  من الواضح أننا مهتمون فقط بالقيمة الصحيحة ، <code>String</code> .  سوف يحدث هذا غالبًا - تتطابق بعض أدوات تحليلنا مع الأنماط في الإدخال دون إنتاج قيم ، وبالتالي يمكن تجاهل إنتاجها بأمان.  للتكيف مع هذا النمط ، سنستخدم أداة دمج <code>pair</code> بنا لكتابة مجمعين آخرين: <code>left</code> ، والذي يتجاهل نتيجة المحلل اللغوي الأول ويعود فقط الثاني ، والعكس <code>right</code> .  استخدمنا المحلل اللغوي في اختبارنا أعلاه ، والذي يتجاهل الجزء الأيسر ويحفظ فقط <code>String</code> لدينا ، بدلاً من <code>pair</code> . </p><br><h3 id="vvedenie-v-funktor" style=";text-align:right;direction:rtl">  مقدمة Functor </h3><br><p style=";text-align:right;direction:rtl">  ولكن قبل أن نذهب إلى هذا الحد ، دعنا نقدم مُزجًا آخر من شأنه تبسيط كتابة هذين الأمرين: <code>map</code> . </p><br><p style=";text-align:right;direction:rtl">  يحتوي هذا الموحد على مهمة واحدة: لتغيير نوع النتيجة.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">على سبيل المثال ، دعنا نقول أن لديك محللًا يُرجع </font></font><code>((), String)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">وترغب في تغييره بحيث يعود على سبيل المثال فقط </font></font><code>String</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></p><br><p style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">للقيام بذلك ، نقوم بتمريرها وظيفة تعرف كيفية تحويل النوع الأصلي إلى نوع جديد. </font><font style="vertical-align: inherit;">في مثالنا، هو بسيط: </font></font><code>|(_left, right)| right</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">بشكل أعم ، سيبدو </font></font><code>Fn(A) -&gt; B</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">المكان </font></font><code>A</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- نتيجة النوع الأصلي للمحلل - والنوع </font></font><code>B</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الجديد.</font></font></p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span></span>&lt;P, F, A, B&gt;(parser: P, map_fn: F) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, B), &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, A), &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt;, F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(A) -&gt; B, { <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |input| <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> parser(input) { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((next_input, result)) =&gt; <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((next_input, map_fn(result))), <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err) =&gt; <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err), } }</code> </pre> <br><p style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ماذا تقول الأنواع؟ </font></font><code>P</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- المحلل اللغوي لدينا. </font><font style="vertical-align: inherit;">عوائد </font></font><code>A</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">النجاح. </font></font><code>F</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">هي وظيفة سوف نستخدمها لعرضها </font></font><code>P</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">كقيمة إرجاع لدينا ، والتي تبدو كما هي </font></font><code>P</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">مع استثناء أن نوع النتيجة الخاص بها </font></font><code>B</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بدلاً من ذلك</font></font><code>A</code> </p><br><p style=";text-align:right;direction:rtl">     <code>parser(input)</code> ,   ,   <code>result</code>       <code>map_fn(result)</code> ,  <code>A</code>  <code>B</code> ,     . </p><br><p style=";text-align:right;direction:rtl">   ,        ,    <code>map</code>   ,    <code>Result</code> : </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span></span>&lt;P, F, A, B&gt;(parser: P, map_fn: F) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, B), &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, A), &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt;, F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(A) -&gt; B, { <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |input| parser(input) .map(|(next_input, result)| (next_input, map_fn(result))) }</code> </pre> <br><p style=";text-align:right;direction:rtl">   — ,   «»  Haskell    ,  .        <code>A</code> ,       <code>map</code> ,      <code>A</code>  <code>B</code>       ,    <code>B</code>  ,  .        Rust,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><code>Option</code></a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><code>Result</code></a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><code>Iterator</code></a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><code>Future</code></a> ,     .     :    -         Rust,         ,    ,    ,   ,       <code>map</code> . </p><br><h3 id="vremya-dlya-tipazha" style=";text-align:right;direction:rtl">    </h3><br><p style=";text-align:right;direction:rtl"> ,   ,         : <code>Fn(&amp;str) -&gt; Result&lt;(&amp;str, Output), &amp;str&gt;</code> . ,    ,    ,  ,   ,   ,     ,              . </p><br><p style=";text-align:right;direction:rtl">         ,    : </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParseResult</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt; = <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(&amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, Output), &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt;;</code> </pre> <br><p style=";text-align:right;direction:rtl">   ,  ,     ,     <code>ParseResult&lt;String&gt;</code>  .     ,      ,      Rust       .      ,   <code>rustc</code> ,     ,   . </p><br><p style=";text-align:right;direction:rtl">   <code>'a</code> ,   ,      <em> </em> . </p><br><p style=";text-align:right;direction:rtl">  .       ,       ,      .    ,     . </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parser</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, input: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; ParseResult&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt;; }</code> </pre> <br><p style=";text-align:right;direction:rtl">         :  <code>parse()</code> ,    :   ,   ,   . </p><br><p style=";text-align:right;direction:rtl">     ,        ,    : </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, F, Output&gt; Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> F <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; ParseResult&lt;Output&gt;, { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, input: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; ParseResult&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt; { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>(input) } }</code> </pre> <br><p style=";text-align:right;direction:rtl">  ,        ,   ,      <code>Parser</code> ,          . </p><br><p style=";text-align:right;direction:rtl"> ,   ,          .    <code>map</code>  ,   . </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, P, F, A, B&gt;(parser: P, map_fn: F) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, B&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, A&gt;, F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(A) -&gt; B, { <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |input| parser.parse(input) .map(|(next_input, result)| (next_input, map_fn(result))) }</code> </pre> <br><p style=";text-align:right;direction:rtl">      :       ,      <code>parser.parse(input)</code> ,     ,    <code>P</code> ,   ,    <code>Parser</code> ,      ,   <code>Parser</code> .         ,     .      <code>'a'</code> ,    ,       . </p><br><p style=";text-align:right;direction:rtl">     <code>pair</code>   ,     : </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pair</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, P1, P2, R1, R2&gt;(parser1: P1, parser2: P2) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, (R1, R2)&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P1: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, R1&gt;, P2: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, R2&gt;, { <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |input| <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> parser1.parse(input) { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((next_input, result1)) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> parser2.parse(next_input) { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((final_input, result2)) =&gt; <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((final_input, (result1, result2))), <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err) =&gt; <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err), }, <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err) =&gt; <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err), } }</code> </pre> <br><p style=";text-align:right;direction:rtl">     :            <code>parser.parse(input)</code>  <code>parser(input)</code> . </p><br><p style=";text-align:right;direction:rtl">   ,       <code>pair</code> ,       <code>map</code> . </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pair</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, P1, P2, R1, R2&gt;(parser1: P1, parser2: P2) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, (R1, R2)&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P1: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, R1&gt;, P2: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, R2&gt;, { <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |input| { parser1.parse(input).and_then(|(next_input, result1)| { parser2.parse(next_input) .map(|(last_input, result2)| (last_input, (result1, result2))) }) } }</code> </pre> <br><p style=";text-align:right;direction:rtl">  <code>and_then</code>  <code>Result</code>   <code>map</code> ,   ,        <code>Result</code> ,    <code>Result</code> .             <code>match</code> .  <code>and_then</code>   ,  ,        <code>map</code> ,    <code>left</code>  <code>right</code> . </p><br><h3 id="left-i-right" style=";text-align:right;direction:rtl"> Left  Right </h3><br><p style=";text-align:right;direction:rtl">  <code>pair</code>  <code>map</code>  ,    <code>left</code>  <code>right</code>  : </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">left</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, P1, P2, R1, R2&gt;(parser1: P1, parser2: P2) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, R1&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P1: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, R1&gt;, P2: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, R2&gt;, { map(pair(parser1, parser2), |(left, _right)| left) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">right</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, P1, P2, R1, R2&gt;(parser1: P1, parser2: P2) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, R2&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P1: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, R1&gt;, P2: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, R2&gt;, { map(pair(parser1, parser2), |(_left, right)| right) }</code> </pre><br><p style=";text-align:right;direction:rtl">    <code>pair</code> ,          ,      <code>map</code>      ,    . </p><br><p style=";text-align:right;direction:rtl">          ,     ,            . </p><br><p style=";text-align:right;direction:rtl">      ,    <code>Parser</code>  <code>ParseResult</code> . <code>match_literal</code>   : </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">match_literal</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(expected: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, ()&gt; { <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |input: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>| <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> input.get(<span class="hljs-number"><span class="hljs-number">0</span></span>..expected.len()) { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(next) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> next == expected =&gt; <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((&amp;input[expected.len()..], ())), _ =&gt; <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(input), } }</code> </pre> <br><p style=";text-align:right;direction:rtl">       ,    ,       — <code>&amp;'a str</code> ,  <code>rustc</code> . </p><br><p style=";text-align:right;direction:rtl">  <code>identifier</code> ,     ,   ,      : </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">identifier</span></span></span></span>(input: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; ParseResult&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; {</code> </pre> <br><p style=";text-align:right;direction:rtl">   . <code>()</code>   .    . </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">right_combinator</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> tag_opener = right(match_literal(<span class="hljs-string"><span class="hljs-string">"&lt;"</span></span>), identifier); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>( <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((<span class="hljs-string"><span class="hljs-string">"/&gt;"</span></span>, <span class="hljs-string"><span class="hljs-string">"my-first-element"</span></span>.to_string())), tag_opener.parse(<span class="hljs-string"><span class="hljs-string">"&lt;my-first-element/&gt;"</span></span>) ); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-literal"><span class="hljs-literal">Err</span></span>(<span class="hljs-string"><span class="hljs-string">"oops"</span></span>), tag_opener.parse(<span class="hljs-string"><span class="hljs-string">"oops"</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-literal"><span class="hljs-literal">Err</span></span>(<span class="hljs-string"><span class="hljs-string">"!oops"</span></span>), tag_opener.parse(<span class="hljs-string"><span class="hljs-string">"&lt;!oops"</span></span>)); }</code> </pre> <br><h3 id="odin-ili-bolshe" style=";text-align:right;direction:rtl">    </h3><br><p style=";text-align:right;direction:rtl">      .      <code>&lt;</code>     .  ?       . </p><br><p style=";text-align:right;direction:rtl"> ,   ,     .       ,    . </p><br><p style=";text-align:right;direction:rtl"> , ,         - , <em> </em>       : . </p><br><p style=";text-align:right;direction:rtl">          (  )  .      . </p><br><p style=";text-align:right;direction:rtl">    —      <em>   </em> ,   <code>&lt;element attribute="value"/&gt;</code>   ,      .       ,     ,   <em>  </em>  . </p><br><p style=";text-align:right;direction:rtl">          <code>identifier</code> ,      .  ,          . </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">one_or_more</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, P, A&gt;(parser: P) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;A&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, A&gt;, { <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> input| { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> result = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((next_input, first_item)) = parser.parse(input) { input = next_input; result.push(first_item); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(input); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((next_input, next_item)) = parser.parse(input) { input = next_input; result.push(next_item); } <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((input, result)) } }</code> </pre> <br><p style=";text-align:right;direction:rtl">  ,    ,    ,  <code>A</code> ,        <code>Vec&lt;A&gt;</code> —   <code>A</code> . </p><br><p style=";text-align:right;direction:rtl">      <code>identifier</code> .     ,     ,    .       ,      ,           . </p><br><p style=";text-align:right;direction:rtl">    ,  :         <em></em>  ?       : </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zero_or_more</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, P, A&gt;(parser: P) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;A&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, A&gt;, { <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> input| { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> result = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((next_input, next_item)) = parser.parse(input) { input = next_input; result.push(next_item); } <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((input, result)) } }</code> </pre> <br><p style=";text-align:right;direction:rtl">    ,  ,     . </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">one_or_more_combinator</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> parser = one_or_more(match_literal(<span class="hljs-string"><span class="hljs-string">"ha"</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[(), (), ()])), parser.parse(<span class="hljs-string"><span class="hljs-string">"hahaha"</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-literal"><span class="hljs-literal">Err</span></span>(<span class="hljs-string"><span class="hljs-string">"ahah"</span></span>), parser.parse(<span class="hljs-string"><span class="hljs-string">"ahah"</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-literal"><span class="hljs-literal">Err</span></span>(<span class="hljs-string"><span class="hljs-string">""</span></span>), parser.parse(<span class="hljs-string"><span class="hljs-string">""</span></span>)); } <span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zero_or_more_combinator</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> parser = zero_or_more(match_literal(<span class="hljs-string"><span class="hljs-string">"ha"</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[(), (), ()])), parser.parse(<span class="hljs-string"><span class="hljs-string">"hahaha"</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((<span class="hljs-string"><span class="hljs-string">"ahah"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[])), parser.parse(<span class="hljs-string"><span class="hljs-string">"ahah"</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[])), parser.parse(<span class="hljs-string"><span class="hljs-string">""</span></span>)); }</code> </pre> <br><p style=";text-align:right;direction:rtl">      :  <code>one_or_more</code>     ,             ,   <code>zero_or_more</code>      ,    . </p><br><p style=";text-align:right;direction:rtl">            ,       ,     .     <code>one_or_more</code>   <code>zero_or_more</code> , -  : </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">one_or_more</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, P, A&gt;(parser: P) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;A&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, A&gt;, { map(pair(parser, zero_or_more(parser)), |(head, <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> tail)| { tail.insert(<span class="hljs-number"><span class="hljs-number">0</span></span>, head); tail }) }</code> </pre> <br><p style=";text-align:right;direction:rtl">      Rust,           <code>cons</code>  <code>Vec</code> ,   ,     Lisp,    ,   . ,   :  . </p><br><p style=";text-align:right;direction:rtl">    ,          :    ,       .  :                (       ).       ,      ,   <code>Clone</code> ,      ,     ,          . </p><br><p style=";text-align:right;direction:rtl">    <em></em> .  ,      <code>one_or_more</code>   ,  ,       ,      ,        ,     -  ,    ,   <code>RangeBound</code>            : <code>range(0..)</code>  <code>zero_or_more</code> , <code>range(1..)</code>  <code>one_or_more</code> , <code>range(5..=6)</code>     ,    . </p><br><p style=";text-align:right;direction:rtl">       .           <code>zero_or_more</code>  <code>one_or_more</code> . </p><br><p style=";text-align:right;direction:rtl">      ,        —  ,    <code>Rc</code>    ? </p><br><h3 id="predikatnyy-kombinator" style=";text-align:right;direction:rtl">   </h3><br><p style=";text-align:right;direction:rtl">      ,         <code>one_or_more</code>      <code>zero_or_more</code> . </p><br><p style=";text-align:right;direction:rtl">   ,  .     ,  <em></em>  .     ,    ,     ,       <code>&gt;</code>  <code>/&gt;</code> .    ,  <em></em>  .    ,   ,       ,        <em>  </em>  <em>  </em> ,    . </p><br><p style=";text-align:right;direction:rtl">       .       . </p><br><p style=";text-align:right;direction:rtl"> -.         <code>match_literal</code>  ,    .   ?   -    ,       Unicode,    .        Rust,  ,  <code>char</code>   <code>is_whitespace</code> ,    <code>is_alphabetic</code>  <code>is_alphanumeric</code> . </p><br><p style=";text-align:right;direction:rtl"> -.     ,      ,   <code>is_whitespace</code> ,     <code>identifier</code> . </p><br><p style=";text-align:right;direction:rtl"> -.    ,     .      <code>any_char</code> ,    <code>char</code>   ,      ,   <code>pred</code> ,       ,    : <code>pred(any_char, |c| c.is_whitespace())</code> .    ,      ,    :      . </p><br><p style=";text-align:right;direction:rtl">  <code>any_char</code> ,   ,       UTF-8. </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any_char</span></span></span></span>(input: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; ParseResult&lt;<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> input.chars().next() { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(next) =&gt; <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((&amp;input[next.len_utf8()..], next)), _ =&gt; <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(input), } }</code> </pre> <br><p style=";text-align:right;direction:rtl">   <code>pred</code>     ,   , .    ,       .     ,      <code>true</code> ,    .       ,    . </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pred</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, P, A, F&gt;(parser: P, predicate: F) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, A&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, A&gt;, F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;A) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>, { <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |input| { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((next_input, value)) = parser.parse(input) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> predicate(&amp;value) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((next_input, value)); } } <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(input) } }</code> </pre> <br><p style=";text-align:right;direction:rtl">   ,  ,    : </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">predicate_combinator</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> parser = pred(any_char, |c| *c == <span class="hljs-string"><span class="hljs-string">'o'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((<span class="hljs-string"><span class="hljs-string">"mg"</span></span>, <span class="hljs-string"><span class="hljs-string">'o'</span></span>)), parser.parse(<span class="hljs-string"><span class="hljs-string">"omg"</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-literal"><span class="hljs-literal">Err</span></span>(<span class="hljs-string"><span class="hljs-string">"lol"</span></span>), parser.parse(<span class="hljs-string"><span class="hljs-string">"lol"</span></span>)); }</code> </pre> <br><p style=";text-align:right;direction:rtl">     ,     <code>whitespace_char</code>    : </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">whitespace_char</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>&gt; { pred(any_char, |c| c.is_whitespace()) }</code> </pre> <br><p style=";text-align:right;direction:rtl">  ,     <code>whitespace_char</code> ,     ,    , <em>   </em> ,    , <em>   </em> .        <code>space1</code>  <code>space0</code> . </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">space1</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>&gt;&gt; { one_or_more(whitespace_char()) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">space0</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>&gt;&gt; { zero_or_more(whitespace_char()) }</code> </pre> <br><h3 id="citiruemye-stroki" style=";text-align:right;direction:rtl">   </h3><br><p style=";text-align:right;direction:rtl">          ? ,    ,          .     <code>identifier</code>    (  ,      <code>any_char</code>  <code>pred</code>   <code>*_or_more</code> ). <code>match_literal("=")</code>   <code>=</code> .         ,     .  ,      ,     . </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">quoted_string</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; { map( right( match_literal(<span class="hljs-string"><span class="hljs-string">"\""</span></span>), left( zero_or_more(pred(any_char, |c| *c != <span class="hljs-string"><span class="hljs-string">'"'</span></span>)), match_literal(<span class="hljs-string"><span class="hljs-string">"\""</span></span>), ), ), |chars| chars.into_iter().collect(), ) }</code> </pre> <br><p style=";text-align:right;direction:rtl">       ,     ,    ,      ,   . </p><br><p style=";text-align:right;direction:rtl">     <code>map</code> -   ,    ,    ,     ,    ,    :   .  <code>map</code>  <code>right</code> ,    <code>right</code> —  ,   : <code>match_literal("\"")</code> .     . </p><br><p style=";text-align:right;direction:rtl">    <code>right</code> —   .      <code>left</code> ,    ,  <em></em>   <code>left</code> , ,   ,   <code>match_literal("\"")</code> —  .  ,   —    . </p><br><p style=";text-align:right;direction:rtl">     <code>pred</code>  <code>any_char</code> ,   ,    <em>   </em> ,      <code>zero_or_more</code> ,   : </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">   </li><li style=";text-align:right;direction:rtl">       ,  <em></em>    </li><li style=";text-align:right;direction:rtl">    </li></ul><br><p style=";text-align:right;direction:rtl">   <code>right</code>  <code>left</code>          . </p><br><p style=";text-align:right;direction:rtl">  ,   . ,   <code>zero_or_more</code> ? <code>Vec&lt;A&gt;</code>      <code>A</code> .  <code>any_char</code>  <code>char</code> .  ,    ,  <code>Vec&lt;char&gt;</code> .     <code>map</code> :   ,   <code>Vec&lt;char&gt;</code>  <code>String</code> ,   ,     <code>String</code>  <code>Iterator&lt;Item = char&gt;</code> ,      <code>vec_of_chars.into_iter().collect()</code>     ,    <code>String</code> . </p><br><p style=";text-align:right;direction:rtl">     ,  ,    ,    ,  ,     ,   ,  ,            . </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">quoted_string_parser</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>( <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"Hello Joe!"</span></span>.to_string())), quoted_string().parse(<span class="hljs-string"><span class="hljs-string">"\"Hello Joe!\""</span></span>) ); }</code> </pre> <br><p style=";text-align:right;direction:rtl"> , , ,  ,    . </p><br><h3 id="nakonec-atributy-razbora" style=";text-align:right;direction:rtl"> ,   </h3><br><p style=";text-align:right;direction:rtl">     , ,  <code>=</code>    .   ,      . </p><br><p style=";text-align:right;direction:rtl">      .   ,      <code>Vec&lt;(String, String)&gt;</code> ,      <code>(String, String)</code> ,       <code>zero_or_more</code> . ,     . </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attribute_pair</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, (<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>)&gt; { pair(identifier, right(match_literal(<span class="hljs-string"><span class="hljs-string">"="</span></span>), quoted_string())) }</code> </pre> <br><p style=";text-align:right;direction:rtl">   !  :           <code>pair</code> ,       <code>identifier</code> ,    <code>String</code> ,  <code>right</code>   <code>=</code> ,      ,    <code>quoted_string</code> ,     <code>String</code> . </p><br><p style=";text-align:right;direction:rtl">      <code>zero_or_more</code> ,   ,        . </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attributes</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>)&gt;&gt; { zero_or_more(right(space1(), attribute_pair())) }</code> </pre> <br><p style=";text-align:right;direction:rtl">    :     , <br>   .   <code>right</code>       . </p><br><p style=";text-align:right;direction:rtl">   . </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attribute_parser</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>( <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(( <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[ (<span class="hljs-string"><span class="hljs-string">"one"</span></span>.to_string(), <span class="hljs-string"><span class="hljs-string">"1"</span></span>.to_string()), (<span class="hljs-string"><span class="hljs-string">"two"</span></span>.to_string(), <span class="hljs-string"><span class="hljs-string">"2"</span></span>.to_string()) ] )), attributes().parse(<span class="hljs-string"><span class="hljs-string">" one=\"1\" two=\"2\""</span></span>) ); }</code> </pre> <br><p style=";text-align:right;direction:rtl">  !  ! </p><br><p style=";text-align:right;direction:rtl">   , ,      rustc ,      ,          .  ,              .  ,    rustc,  ,   ,    <code>#![type_length_limit = "…some big number…"]</code>   ,      .   ,    <code>#![type_length_limit = "16777216"]</code> ,          . ,   ! </p><br><h3 id="tak-teper-zavershenie" style=";text-align:right;direction:rtl">    </h3><br><p style=";text-align:right;direction:rtl">   , ,      ,    ,        NP-.        element:        ,   ,    ,        <code>zero_or_more</code> , ? </p><br><p style=";text-align:right;direction:rtl"> ,     ,     . ,   ,      ,    :   <code>&lt;</code> ,    .  ,       <code>(String, Vec&lt;(String, String)&gt;)</code>   . </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">element_start</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, (<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>)&gt;)&gt; { right(match_literal(<span class="hljs-string"><span class="hljs-string">"&lt;"</span></span>), pair(identifier, attributes())) }</code> </pre> <br><p style=";text-align:right;direction:rtl">    ,        ,       . </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">single_element</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Element&gt; { map( left(element_start(), match_literal(<span class="hljs-string"><span class="hljs-string">"/&gt;"</span></span>)), |(name, attributes)| Element { name, attributes, children: <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[], }, ) }</code> </pre> <br><p style=";text-align:right;direction:rtl"> ,  ,      —     <code>Element</code> ! </p><br><p style=";text-align:right;direction:rtl">      . </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">single_element_parser</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>( <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(( <span class="hljs-string"><span class="hljs-string">""</span></span>, Element { name: <span class="hljs-string"><span class="hljs-string">"div"</span></span>.to_string(), attributes: <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[(<span class="hljs-string"><span class="hljs-string">"class"</span></span>.to_string(), <span class="hljs-string"><span class="hljs-string">"float"</span></span>.to_string())], children: <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[] } )), single_element().parse(<span class="hljs-string"><span class="hljs-string">"&lt;div class=\"float\"/&gt;"</span></span>) ); }</code> </pre> <br><p style=";text-align:right;direction:rtl"> …   ,       . </p><br><p style=";text-align:right;direction:rtl">    <code>single_element</code>  ,          ,    ,    . ,        ,       ,       — ,       —   . </p><br><p style=";text-align:right;direction:rtl">   ,        ,      ... </p><br><h3 id="beskonechnost-ne-predel" style=";text-align:right;direction:rtl">    </h3><br><p style=";text-align:right;direction:rtl">   -      Rust, , ,      . </p><br><p style=";text-align:right;direction:rtl">        .  ,      : </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span></span>&lt;A&gt; { Cons(A, List&lt;A&gt;), Nil, }</code> </pre> <br><p style=";text-align:right;direction:rtl">   rustc    ,     <code>List&lt;A&gt;</code>   ,     <code>List::&lt;A&gt;::Cons</code>    <code>List&lt;A&gt;</code> ,      .   rustc,      ,   ,     <em></em>  . </p><br><p style=";text-align:right;direction:rtl">             ,       Rust.    ,   Rust,   ,     <em></em>     ,     <em></em>  ,    .    ,      . </p><br><p style=";text-align:right;direction:rtl">    ,    .  ,   <code>List::Cons</code>   <code>A</code>   <em></em> <code>A</code> ,     <code>A</code>  <em></em>   <code>A</code> .    ,   ,   ,    ,    <code>List::Cons</code>      ,    .    ,           Rust —  <code>Box</code> . </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span></span>&lt;A&gt; { Cons(A, <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;List&lt;A&gt;&gt;), Nil, }</code> </pre> <br><p style=";text-align:right;direction:rtl">     <code>Box</code>   ,       .  ,          ,            <code>Box&lt;dyn Parser&lt;'a, A&gt;&gt;</code> . </p><br><p style=";text-align:right;direction:rtl">   .  ?  ,        -    ,    ,          .       :   .      .  ,      ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">  SIMD</a> (     ). </p><br><p style=";text-align:right;direction:rtl"> ,     <code>Parser</code>     <em>Box</em>     ,      . </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BoxedParser</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt; { parser: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;dyn Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt; + <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt; BoxedParser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>&lt;P&gt;(parser: P) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt; + <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, { BoxedParser { parser: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(parser), } } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt; Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> BoxedParser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, input: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; ParseResult&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt; { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.parser.parse(input) } }</code> </pre> <br><p style=";text-align:right;direction:rtl"> ,  ,    <code>BoxedParser</code>    <code>box</code> .    <code>BoxedParser</code>       (  <code>BoxedParser</code> ,      ),    <code>BoxedParser::new(parser)</code> ,    ,      <code>Box</code>    . ,   <code>Parser</code>  ,         . </p><br><p style=";text-align:right;direction:rtl">          <code>Box</code> ,  <code>BoxedParser</code>    <code>Parser</code>  ,   . ,   ,  ,           ,    ,     <em>  </em> ,  , ,   <em> </em> .        . </p><br><h3 id="vozmozhnost-predstavlyaet-sebya" style=";text-align:right;direction:rtl">    </h3><br><p style=";text-align:right;direction:rtl"> ,  ,       ,     . </p><br><p style=";text-align:right;direction:rtl">    ,   ?      ,       ,       .    <code>quoted_string</code> : </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">quoted_string</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; { map( right( match_literal(<span class="hljs-string"><span class="hljs-string">"\""</span></span>), left( zero_or_more(pred(any_char, |c| *c != <span class="hljs-string"><span class="hljs-string">'"'</span></span>)), match_literal(<span class="hljs-string"><span class="hljs-string">"\""</span></span>), ), ), |chars| chars.into_iter().collect(), ) }</code> </pre> <br><p style=";text-align:right;direction:rtl">     ,             .             <code>Parser</code> ? </p><br><p style=";text-align:right;direction:rtl">   ,     ,     <code>impl Trait</code>     ,   <code>impl Trait</code>     . </p><br><p style=";text-align:right;direction:rtl"> …      <code>BoxedParser</code> .       ,   <code>impl Parser&lt;'a, A&gt;</code> ,    <em></em>  ,   <code>BoxedParser&lt;'a, A&gt;</code> . </p><br><p style=";text-align:right;direction:rtl">   ,          ,           ,   <code>Parser</code> . </p><br><p style=";text-align:right;direction:rtl">     <code>map</code> ,    <code>Parser</code>  : </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parser</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, input: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; ParseResult&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span></span>&lt;F, NewOutput&gt;(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, map_fn: F) -&gt; BoxedParser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, NewOutput&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Sized</span></span> + <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output: <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, NewOutput: <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(Output) -&gt; NewOutput + <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, { BoxedParser::new(map(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, map_fn)) } }</code> </pre> <br><p style=";text-align:right;direction:rtl">   <code>'a</code> , ,    .  ,            —     ,          ,       <code>impl Trait</code> . </p><br><p style=";text-align:right;direction:rtl">       <code>quoted_string</code> : </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">quoted_string</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; { right( match_literal(<span class="hljs-string"><span class="hljs-string">"\""</span></span>), left( zero_or_more(pred(any_char, |c| *c != <span class="hljs-string"><span class="hljs-string">'"'</span></span>)), match_literal(<span class="hljs-string"><span class="hljs-string">"\""</span></span>), ), ) .map(|chars| chars.into_iter().collect()) }</code> </pre> <br><p style=";text-align:right;direction:rtl">   ,   ,  <code>.map()</code>    <code>right()</code> . </p><br><p style=";text-align:right;direction:rtl">         <code>pair</code> , <code>left</code>  <code>right</code> ,       ,    ,    ,        <code>pair</code> .    ,       ,     <code>map</code> ,         . </p><br><p style=";text-align:right;direction:rtl">    — <code>pred</code> .        <code>Parser</code> : </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pred</span></span></span></span>&lt;F&gt;(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, pred_fn: F) -&gt; BoxedParser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Sized</span></span> + <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output: <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;Output) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> + <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, { BoxedParser::new(pred(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, pred_fn)) }</code> </pre> <br><p style=";text-align:right;direction:rtl">       <code>quoted_string</code>   <code>pred</code> ,   : </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs">zero_or_more(any_char.pred(|c| *c != <span class="hljs-string"><span class="hljs-string">'"'</span></span>)),</code> </pre> <br><p style=";text-align:right;direction:rtl">  ,     ,   ,     <code>zero_or_more</code>   —    «    <code>any_char</code>    »,    .  ,        <code>zero_or_more</code>  <code>one_or_more</code>  . </p><br><p style=";text-align:right;direction:rtl">     <code>quoted_string</code> ,    <code>map</code>  <code>single_element</code> : </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">single_element</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Element&gt; { left(element_start(), match_literal(<span class="hljs-string"><span class="hljs-string">"/&gt;"</span></span>)).map(|(name, attributes)| Element { name, attributes, children: <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[], }) }</code> </pre> <br><p style=";text-align:right;direction:rtl">      <code>element_start</code>  ,    ,  ,   .          ... </p><br><p style=";text-align:right;direction:rtl"> …  ,       .             ,     . </p><br><p style=";text-align:right;direction:rtl">    <code>map</code>  <code>pred</code>  <code>Box</code> — <em></em>     ! </p><br><h3 id="obrabotka-detey-elementa" style=";text-align:right;direction:rtl">    </h3><br><p style=";text-align:right;direction:rtl">         .    <code>single_element</code> ,   ,     <code>&gt;</code> ,    <code>/&gt;</code> .            ,        ,     . </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">open_element</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Element&gt; { left(element_start(), match_literal(<span class="hljs-string"><span class="hljs-string">"&gt;"</span></span>)).map(|(name, attributes)| Element { name, attributes, children: <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[], }) }</code> </pre> <br><p style=";text-align:right;direction:rtl"> ,     ?     ,    ,      ,         <code>zero_or_more</code> ,     ?  ,      , —      : ,   <em></em>  , <em></em>  . </p><br><p style=";text-align:right;direction:rtl">   ,   ,      :     ,  ,      .    ,  ,   ,     <em>   </em> .   , ,   ,    ,   ,        ,    . </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">either</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, P1, P2, A&gt;(parser1: P1, parser2: P2) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, A&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P1: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, A&gt;, P2: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, A&gt;, { <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |input| <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> parser1.parse(input) { ok @ <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(_) =&gt; ok, <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(_) =&gt; parser2.parse(input), } }</code> </pre> <br><p style=";text-align:right;direction:rtl">       <code>element</code> ,     ,    (     <code>open_element</code>   ,       <code>element</code> ). </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">element</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Element&gt; { either(single_element(), open_element()) }</code> </pre> <br><p style=";text-align:right;direction:rtl">       .         ,  ,    ,    .      , ? </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close_element</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(expected_name: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; { right(match_literal(<span class="hljs-string"><span class="hljs-string">"&lt;/"</span></span>), left(identifier, match_literal(<span class="hljs-string"><span class="hljs-string">"&gt;"</span></span>))) .pred(<span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |name| name == &amp;expected_name) }</code> </pre> <br><p style=";text-align:right;direction:rtl">   <code>pred</code>   ,   ? </p><br><p style=";text-align:right;direction:rtl">           ,   : </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parent_element</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Element&gt; { pair( open_element(), left(zero_or_more(element()), close_element(…oops)), ) }</code> </pre> <br><p style=";text-align:right;direction:rtl">        <code>close_element</code> ?  ,      . </p><br><p style=";text-align:right;direction:rtl">   .       ,   <code>parent_element</code> ,     <code>open_element</code>   <code>element</code>   <code>parent_element</code> ,  ,       XML. </p><br><p style=";text-align:right;direction:rtl"> ,  ,     <code>and_then</code> ? ,  .    <code>and_then</code> :   -,   ,  ,       <em></em> ,    .     <code>pair</code> ,   ,   ,       ,     .  , <code>and_then</code>   <code>Result</code>  <code>Option</code> ,   ,      ,   <code>Result</code>  <code>Option</code>      <em></em> ,   ,     ( ,    )). </p><br><p style=";text-align:right;direction:rtl"> ,      . </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">and_then</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, P, F, A, B, NextP&gt;(parser: P, f: F) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, B&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, A&gt;, NextP: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, B&gt;, F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(A) -&gt; NextP, { <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |input| <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> parser.parse(input) { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((next_input, result)) =&gt; f(result).parse(next_input), <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err) =&gt; <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err), } }</code> </pre> <br><p style=";text-align:right;direction:rtl">   ,    ,    <code>P</code> ,   ,     <code>A</code> .    <code>F</code> ,  <code>map</code>    <code>A</code>  <code>B</code> ,     ,  <code>and_then</code>    <code>A</code>  <em>  </em> <code>NextP</code> ,     <code>B</code> .    — <code>B</code> ,    ,  ,     <code>NextP</code>   . </p><br><p style=";text-align:right;direction:rtl">    :        ,     ,  ,     ,      <code>f</code>   ( <code>A</code> ),  ,    <code>f(result)</code> ,       <code>B</code> .   <em></em>          .    ,        ,    ,       <code>B</code> </p><br><p style=";text-align:right;direction:rtl">  :        <code>P</code> ,    ,    <code>f</code>     <code>P</code> ,        <code>NextP</code> ,    ,    . </p><br><p style=";text-align:right;direction:rtl">        <code>Parser</code> ,    <code>map</code> ,    . </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">and_then</span></span></span></span>&lt;F, NextParser, NewOutput&gt;(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, f: F) -&gt; BoxedParser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, NewOutput&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Sized</span></span> + <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output: <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, NewOutput: <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, NextParser: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, NewOutput&gt; + <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(Output) -&gt; NextParser + <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, { BoxedParser::new(and_then(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, f)) }</code> </pre> <br><p style=";text-align:right;direction:rtl"> , ,    ? </p><br><p style=";text-align:right;direction:rtl">  ,   <em></em>  <code>pair</code>  : </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pair</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, P1, P2, R1, R2&gt;(parser1: P1, parser2: P2) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, (R1, R2)&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P1: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, R1&gt; + <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, P2: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, R2&gt; + <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, R1: <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">Clone</span></span>, R2: <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, { parser1.and_then(<span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |result1| parser2.map(<span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |result2| (result1.clone(), result2))) }</code> </pre> <br><p style=";text-align:right;direction:rtl">    ,   : <code>parser2.map()</code>  <code>parser2</code>     ,    <code>Fn</code> ,   <code>FnOnce</code> ,     <code>parser2</code> ,     .  ,  Rust.     ,      ,        <code>pair</code> . </p><br><p style=";text-align:right;direction:rtl"> ,         Rust,            <code>close_element</code> ,   ,         . </p><br><p style=";text-align:right;direction:rtl">    : </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parent_element</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Element&gt; { pair( open_element(), left(zero_or_more(element()), close_element(…oops)), ) }</code> </pre> <br><p style=";text-align:right;direction:rtl"> ,   <code>and_then</code> ,            <code>close_element</code> . </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parent_element</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Element&gt; { open_element().and_then(|el| { left(zero_or_more(element()), close_element(el.name.clone())).map(<span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |children| { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> el = el.clone(); el.children = children; el }) }) }</code> </pre> <br><p style=";text-align:right;direction:rtl">     ,   <code>and_then</code>    <code>open_element()</code> ,    ,    <code>close_element</code> .  ,       <code>open_element</code>      <code>and_then</code> .  ,         <code>Element</code>  <code>open_element</code> , ,   ,      . </p><br><p style=";text-align:right;direction:rtl">  ,  <code>map</code>    ,    <code>Element</code> ( <code>el</code> )   .    <code>clone()</code> ,      <code>Fn</code>       .       ( <code>Vec&lt;Element&gt;</code> )       <code>Element</code> ,        . </p><br><p style=";text-align:right;direction:rtl"> ,     ,      <code>element</code>  ,    <code>open_element</code>  <code>parent_element</code> ,      ,     ,   ,   ! </p><br><h3 id="sobiraetes-li-vy-skazat-slovo-m-ili-dolzhen-ya" style=";text-align:right;direction:rtl">      ""   ? </h3><br><p style=";text-align:right;direction:rtl"> ,    ,   <code>map</code>  «»   Haskell? </p><br><p style=";text-align:right;direction:rtl"> <code>and_then</code> —    ,     Rust,      ,   <code>map</code> .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><code>flat_map</code></a>  <code>Iterator</code> ,     ,   . </p><br><p style=";text-align:right;direction:rtl">     — "".     <code>Thing&lt;A&gt;</code> ,      <code>and_then</code> ,        <code>A</code>  <code>Thing&lt;B&gt;</code> ,        <code>Thing&lt;B&gt;</code> —  . </p><br><p style=";text-align:right;direction:rtl">     , ,     <code>Option&lt;A&gt;</code> ,   ,    <code>Some(A)</code>  <code>None</code> ,     ,   <code>Some(A)</code> ,   <code>Some(B)</code> </p><br><p style=";text-align:right;direction:rtl">     . ,     <code>Future&lt;A&gt;</code>     ,  <code>and_then</code>      <code>Future&lt;B&gt;</code> ,      <code>Future&lt;B&gt;</code>    <code>Future&lt;A&gt;</code>  ,     <code>Future&lt;A&gt;</code> .        <code>Future&lt;A&gt;</code> ,   —   <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">1</a></sup> ,   <code>Future&lt;B&gt;</code> .  ,   <code>Future</code>     ,    <code>and_then</code>   <em>  </em> ,       <code>Future</code> ,  .     ,     <em></em> <code>Future</code> ,       . </p><br><p style=";text-align:right;direction:rtl">      ,   Rust       ,   ,     ,  ,  ,       ,    ,    .  . </p><br><h3 id="probely-redux" style=";text-align:right;direction:rtl"> , Redux </h3><br><p style=";text-align:right;direction:rtl">   . </p><br><p style=";text-align:right;direction:rtl">      ,    XML,      .       ,              (  ,        ,  <code>&lt; div / &gt;</code> ,    ). </p><br><p style=";text-align:right;direction:rtl">               . </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">whitespace_wrap</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, P, A&gt;(parser: P) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, A&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, A&gt;, { right(space0(), left(parser, space0())) }</code> </pre> <br><p style=";text-align:right;direction:rtl">    <code>element</code>  ,          <code>element</code> ,  ,          ,   . </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">element</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Element&gt; { whitespace_wrap(either(single_element(), parent_element())) }</code> </pre> <br><h3 id="my-na-finishnoy-pryamoy" style=";text-align:right;direction:rtl">    ! </h3><br><p style=";text-align:right;direction:rtl">  ,    !    ,  . </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xml_parser</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> doc = <span class="hljs-string"><span class="hljs-string">r#" &lt;top label="Top"&gt; &lt;semi-bottom label="Bottom"/&gt; &lt;middle&gt; &lt;bottom label="Another bottom"/&gt; &lt;/middle&gt; &lt;/top&gt;"#</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> parsed_doc = Element { name: <span class="hljs-string"><span class="hljs-string">"top"</span></span>.to_string(), attributes: <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[(<span class="hljs-string"><span class="hljs-string">"label"</span></span>.to_string(), <span class="hljs-string"><span class="hljs-string">"Top"</span></span>.to_string())], children: <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[ Element { name: <span class="hljs-string"><span class="hljs-string">"semi-bottom"</span></span>.to_string(), attributes: <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[(<span class="hljs-string"><span class="hljs-string">"label"</span></span>.to_string(), <span class="hljs-string"><span class="hljs-string">"Bottom"</span></span>.to_string())], children: <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[], }, Element { name: <span class="hljs-string"><span class="hljs-string">"middle"</span></span>.to_string(), attributes: <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[], children: <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[Element { name: <span class="hljs-string"><span class="hljs-string">"bottom"</span></span>.to_string(), attributes: <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[(<span class="hljs-string"><span class="hljs-string">"label"</span></span>.to_string(), <span class="hljs-string"><span class="hljs-string">"Another bottom"</span></span>.to_string())], children: <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[], }], }, ], }; <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((<span class="hljs-string"><span class="hljs-string">""</span></span>, parsed_doc)), element().parse(doc)); }</code> </pre> <br><p style=";text-align:right;direction:rtl">  ,    -   ,   ,      : </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mismatched_closing_tag</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> doc = <span class="hljs-string"><span class="hljs-string">r#" &lt;top&gt; &lt;bottom/&gt; &lt;/middle&gt;"#</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-literal"><span class="hljs-literal">Err</span></span>(<span class="hljs-string"><span class="hljs-string">"&lt;/middle&gt;"</span></span>), element().parse(doc)); }</code> </pre> <br><p style=";text-align:right;direction:rtl">    ,        .     ,      <em></em>  ,       ,  , <em></em> .  ,  , ,  ,          .     ,       ,    , ,   ,    . </p><br><p style=";text-align:right;direction:rtl">     :     ,   !  ,      ,  ,               <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">2</a></sup> . </p><br><p style=";text-align:right;direction:rtl">  ,   ,       .      ! </p><br><h3 id="dopolnitelnye-resursy" style=";text-align:right;direction:rtl">   </h3><br><p style=";text-align:right;direction:rtl">  ,    ,       Rust ,   ,        - ,        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">  </a> ,       ,       . </p><br><p style=";text-align:right;direction:rtl">        ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><code>pom</code></a> ,           ,    . </p><br><p style=";text-align:right;direction:rtl">       Rust  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><code>nom</code></a>   ,    <code>pom</code>    (    ,  ),          ,     . </p><br><p style=";text-align:right;direction:rtl">        Rust  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><code>combine</code></a> ,    . </p><br><p style=";text-align:right;direction:rtl">       Haskell  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Parsec</a> . </p><br><p style=";text-align:right;direction:rtl"> ,            <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><em>«  Haskell»</em></a> ,          ,      Haskell. </p><br><h2 id="licenziya" style=";text-align:right;direction:rtl">  رخصة </h2><br><p style=";text-align:right;direction:rtl">      Bodil Stokke        Creative Commons Attribution-NonCommercial-ShareAlike 4.0.     ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">http://creativecommons.org/licenses/by-nc-sa/4.0/</a> . </p><br><h2 id="snoski" style=";text-align:right;direction:rtl">  </h2><br><p style=";text-align:right;direction:rtl"> 1:       . </p><br><p style=";text-align:right;direction:rtl"> 2: ,      . </p><br><h2 id="ot-perevodchikov" style=";text-align:right;direction:rtl">   </h2><br><p style=";text-align:right;direction:rtl">      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" class="user_link">andreevlex</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" class="user_link">funkill</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar469213/">https://habr.com/ru/post/ar469213/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar469195/index.html">DevOpsProdigy KubeGraf v1.1.0</a></li>
<li><a href="../ar469203/index.html">"كاف" قوي للإفطار و الاختراقات: لماذا هو مهم لتطوير مجتمع علم البيانات</a></li>
<li><a href="../ar469205/index.html">متحف DataArt. قم بفك "Electronics MS 0511"</a></li>
<li><a href="../ar469209/index.html">كيف رخيصة مصابيح LED فيليبس تختلف عن تلك باهظة الثمن</a></li>
<li><a href="../ar469211/index.html">كيف تقوم ICD بتطوير نظام بيئي لعملاء البنوك</a></li>
<li><a href="../ar469215/index.html">العمل مع التواريخ في لغة R (الميزات الأساسية ، وكذلك حزم lubridate و timeperiodsR)</a></li>
<li><a href="../ar469217/index.html">IMHO Saint TeamLead Conf 2019</a></li>
<li><a href="../ar469219/index.html">أفضل 20 ميزة للتنقل في IntelliJ IDEA. الجزء 2</a></li>
<li><a href="../ar469221/index.html">Cascadeur: توقع ظهور شخصية من ست نقاط</a></li>
<li><a href="../ar469223/index.html">الإضاءة الخلفية LED بمثابة مستتر</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>