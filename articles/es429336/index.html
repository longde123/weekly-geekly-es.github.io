<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéÖüèæ üë®üèª‚Äç‚öñÔ∏è üèê Comunicaci√≥n entre el controlador y el dispositivo mediante el m√©todo _HID ACPI utilizando el GPIO del controlador Lynxpoint como ejemplo üí∫ üèà ‚ÜóÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Declaraci√≥n del problema. 
 Linux tiene una interfaz est√°ndar para trabajar con GPIO a trav√©s de sysfs. La documentaci√≥n para ello se puede encontrar ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comunicaci√≥n entre el controlador y el dispositivo mediante el m√©todo _HID ACPI utilizando el GPIO del controlador Lynxpoint como ejemplo</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429336/"><h3>  Declaraci√≥n del problema. </h3><br>  Linux tiene una interfaz est√°ndar para trabajar con GPIO a trav√©s de sysfs.  La documentaci√≥n para ello se puede encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br>  En resumen, hay archivos "exportar" y "no exportar" en la carpeta "/ sys / class / gpio".  Al escribir el n√∫mero X en el archivo de exportaci√≥n, puede abrir la interfaz en el espacio del usuario para controlar GPIOX <br><br><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#    user space   GPIO12 $ echo 12 &gt; /sys/class/gpio/export</span></span></code> </pre> <br>  Despu√©s de abrir la interfaz, aparecer√° la carpeta / sys / class / gpio / gpioX / en la que habr√° archivos como "value" o "direction", y escribiendo "in" o "out" en el archivo "direction" y escribiendo 1 o 0 en el archivo El "valor" puede controlar la salida GPIO directamente desde la l√≠nea de comando. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  GPIO   $ echo "out" &gt; /sys/class/gpio/gpio12/direction #  1   GPIO $ echo 1 &gt; /sys/class/gpio/gpio12/value</span></span></code> </pre> <br>  Para que el comando "echo X&gt; / sys / class / gpio / export" cree la carpeta "gpioX", el controlador del controlador GPIO debe estar registrado en el kernel, que abre la interfaz a las l√≠neas GPIO. <br><br>  Dio la casualidad de que estoy trabajando en portar coreboot para una placa personalizada basada en el procesador Intel Haswell i7 [Para aquellos que no lo saben, coreboot es un proyecto de c√≥digo abierto de c√≥digo abierto ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://www.coreboot.org/</a> ) ]  El puente sur LynxpointLP en el que hay 94 l√≠neas GPIO est√° integrado en mi procesador.  Y quer√≠a abrirlos en sysfs ... <br><a name="habracut"></a><br><h3>  Resoluci√≥n de problemas (comunicaci√≥n de controlador y dispositivo en Linux) </h3><br>  Despu√©s de una breve b√∫squeda en el c√≥digo del kernel, descubr√≠ que este controlador ya se ha escrito, se encuentra en el archivo "drivers \ gpio \ gpio-lynxpoint.c" y est√° habilitado con Kconfig <br><br><pre> <code class="hljs pgsql">config GPIO_LYNXPOINT tristate "Intel Lynxpoint GPIO support" <span class="hljs-keyword"><span class="hljs-keyword">depends</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ACPI &amp;&amp; X86 <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> GPIOLIB_IRQCHIP help driver <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> GPIO functionality <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> Intel Lynxpoint PCH chipset Requires ACPI device enumeration code <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> up a platform device.</code> </pre> <br>  La opci√≥n GPIO_LYNXPOINT estaba habilitada en el kernel con el que estaba trabajando, sin embargo, no hab√≠a una sola carpeta "gpiochipN" para el controlador GPIO en la carpeta "/ sys / class / gpio /" (que deber√≠a estar), e incluso tal script no condujo a la exportaci√≥n de ninguno l√≠neas <br><br><pre> <code class="bash hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> {0..255}; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$i</span></span> &gt; /sys/class/gpio/<span class="hljs-built_in"><span class="hljs-built_in">export</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre> <br>  Si observa el c√≥digo de arranque b√°sico o la documentaci√≥n de este puente sur, puede ver que el controlador GPIO no es un dispositivo PCI separado.  Forma parte de otro dispositivo PCI: LPC Interface Bridge.  Usando los registros de espacio de configuraci√≥n PCI de este dispositivo, debe habilitar el controlador GPIO y asignarle BASE_ADDRESS en el espacio de E / S.  Esto abrir√° una ventana en el espacio de E / S de 1KV.  Al escribir / leer bytes en esta ventana, puede controlar las l√≠neas GPIO. <br><br>  Lo que podemos ver en el c√≥digo coreboot: <br><br>  southbridge \ intel \ lynxpoint \ pch.h: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEFAULT_GPIOBASE 0x1400 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEFAULT_GPIOSIZE 0x400 ... #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> GPIO_BASE 0x48 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* LPC GPIO Base Address Register */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> GPIO_CNTL 0x4C </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* LPC GPIO Control Register */</span></span></span><span class="hljs-meta"> ... </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* PCI Configuration Space (D31:F0): LPC */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PCH_LPC_DEV PCI_DEV(0, 0x1f, 0)</span></span></code> </pre><br>  southbridge \ intel \ lynxpoint \ early_pch.c: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Setup GPIO Base Address */</span></span> pci_write_config32(PCH_LPC_DEV, GPIO_BASE, DEFAULT_GPIOBASE|<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* Enable GPIO functionality. */</span></span> pci_write_config8(PCH_LPC_DEV, GPIO_CNTL, <span class="hljs-number"><span class="hljs-number">0x10</span></span>);</code> </pre> <br>  Si observamos los registros de dispositivos LPC en Linux a trav√©s de "lspci -xxx", veremos que los datos grabados por nosotros est√°n en estos registros.  Entonces todo parece estar configurado como deber√≠a. <br><br>  Continuando mirando el c√≥digo del controlador, not√© que el controlador de Linux se comunica con el dispositivo a trav√©s del campo .acpi_match_table.  Dado que nuestro dispositivo no se puede enumerar (no est√° ubicado ni en el PCI ni en el bus USB), se requiere un controlador de plataforma para √©l, y la conexi√≥n de este controlador con el dispositivo es a trav√©s de tablas ACPI.  El caso habitual para x86, en el caso de ARM, registrar√≠amos nuestro dispositivo en DeviceTree, o usar√≠amos los viejos c√≥digos en el n√∫cleo. <br><br>  drivers \ gpio \ gpio-lynxpoint.c: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">acpi_device_id</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lynxpoint_gpio_acpi_match</span></span></span><span class="hljs-class">[] = {</span></span> { <span class="hljs-string"><span class="hljs-string">"INT33C7"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"INT3437"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { } }; MODULE_DEVICE_TABLE(acpi, lynxpoint_gpio_acpi_match); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">platform_driver</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lp_gpio_driver</span></span></span><span class="hljs-class"> = {</span></span> .probe = lp_gpio_probe, .remove = lp_gpio_remove, .driver = { .name = <span class="hljs-string"><span class="hljs-string">"lp_gpio"</span></span>, .pm = &amp;lp_gpio_pm_ops, .acpi_match_table = ACPI_PTR(lynxpoint_gpio_acpi_match), }, };</code> </pre><br>  Funciona as√≠: si el n√∫cleo, al analizar la tabla ACPI, ve un dispositivo con el identificador _HID "INT33C7", intentar√° encontrar el controlador de la plataforma con identificadores coincidentes en los campos de la estructura ".driver-&gt; acpi_match_table". <br><br>  Cuando se encuentra una coincidencia, Linux ejecutar√° la funci√≥n del controlador .probe. <br><br>  Result√≥ que el c√≥digo ACPI para este dispositivo se present√≥ en coreboot, solo lo coment√©.  Coment√≥ debido al hecho de que para este dispositivo Windows no pudo encontrar el controlador y mostr√≥ "Dispositivo desconocido" en el administrador de dispositivos.  M√°s sobre esto a continuaci√≥n. <br><br>  Entonces, estamos interesados ‚Äã‚Äãen la informaci√≥n del archivo <br>  src \ southbridge \ intel \ lynxpoint \ acpi \ serialio.asl (el c√≥digo est√° un poco simplificado): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*     * src\southbridge\intel\lynxpoint\pch.h * #define DEFAULT_GPIOBASE 0x1400 * #define DEFAULT_GPIOSIZE 0x400 */</span></span> Scope (\_SB) { Device (PCI0) { ... Device (GPIO) { <span class="hljs-comment"><span class="hljs-comment">// GPIO Controller Name (_HID, "INT33C7") Name (_CID, "INT33C7") Name (_UID, 1) Name (RBUF, ResourceTemplate() { DWordIo (ResourceProducer, MinFixed, // IsMinFixed MaxFixed, // IsMaxFixed PosDecode, // Decode EntireRange, // ISARanges 0x00000000, // AddressGranularity 0x00000000, // AddressMinimum 0x00000000, // AddressMaximum 0x00000000, // AddressTranslation 0x00000001, // RangeLength , // ResourceSourceIndex , // ResourceSource BAR0) Interrupt (ResourceConsumer, Level, ActiveHigh, Shared, , , ) {14} }) Method (_CRS, 0, NotSerialized) { CreateDwordField (^RBUF, ^BAR0._MIN, BMIN) CreateDwordField (^RBUF, ^BAR0._MAX, BMAX) CreateDwordField (^RBUF, ^BAR0._LEN, BLEN) Store (DEFAULT_GPIOSIZE, BLEN) Store (DEFAULT_GPIOBASE, BMIN) Store (Subtract (Add (DEFAULT_GPIOBASE, DEFAULT_GPIOSIZE), 1), BMAX) Return (RBUF) } Method (_STA, 0, NotSerialized) { Return (0xF) } } ... } }</span></span></code> </pre><br>  Para comprender este c√≥digo en detalle, debe familiarizarse con la sintaxis ASL en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la especificaci√≥n ACPI</a> . <br><br>  Pero en resumen, este c√≥digo crea un dispositivo con el identificador "INT33C7" que tiene 2 recursos: <br><br><pre> <code class="hljs mel">I/O <span class="hljs-keyword"><span class="hljs-keyword">memory</span></span>: <span class="hljs-number"><span class="hljs-number">1400</span></span><span class="hljs-number"><span class="hljs-number">-17</span></span>ff; IRQ: <span class="hljs-number"><span class="hljs-number">14</span></span>;</code> </pre> <br>  Dentro de su funci√≥n .probe Linux, el controlador recibe los recursos del dispositivo anteriores de la siguiente manera: <br><br><pre> <code class="cpp hljs">io_rc = platform_get_resource(pdev, IORESOURCE_IO, <span class="hljs-number"><span class="hljs-number">0</span></span>); irq_rc = platform_get_resource(pdev, IORESOURCE_IRQ, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br>  En base a estos datos, el c√≥digo del controlador completar√° la estructura gpio_chip y registrar√° el controlador gpio en el sistema, lo que lo har√° accesible a trav√©s de la interfaz sysfs. <br><br>  Despu√©s de devolver el c√≥digo ASL del dispositivo y volver a compilar la imagen del BIOS, el sistema logr√≥ acceder al GPIO a trav√©s de sysfs. <br><br>  Para comenzar, la carpeta "gpiochip162" apareci√≥ en / sys / class / gpio.  Esta carpeta contiene el archivo "base" y "ngpio".  El archivo base es responsable del n√∫mero del primer GPIO de este controlador, ngpio por su n√∫mero. <br><br><pre> <code class="bash hljs">$ cat /sys/class/gpio/gpiochip162/base 162 $ cat /sys/class/gpio/gpiochip162/ngpio 94</code> </pre> <br>  Por lo tanto, todo se export√≥ como deber√≠a.  Ejecutamos el script: <br><br><pre> <code class="bash hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> {162..255}; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$i</span></span> &gt; /sys/class/gpio/<span class="hljs-built_in"><span class="hljs-built_in">export</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre> <br>  Despu√©s de eso, las subcarpetas gpioN aparecer√°n en la carpeta / sys / class / gpio /, dentro de la cual habr√° archivos para controlar el estado de la l√≠nea. <br><br>  Un par de comentarios: <br><br><ul><li>  La carpeta / sys / class / gpio162 / es responsable de administrar GPIO0, la carpeta / sys / class / gpio163 / es responsable de GPIO1  Este cambio se produjo debido al hecho de que el controlador durante la inicializaci√≥n de la estructura de control "struct gpio_chip" asign√≥ "gc-&gt; base = -1;".  Es decir, dej√© el n√∫cleo para elegir los n√∫meros yo mismo.  Esto generalmente no es cr√≠tico, pero vale la pena recordarlo. </li><li>  El acceso se otorga solo a las l√≠neas GPIO que est√°n configuradas como GPIO, y no como cualquier caracter√≠stica nativa de Southbridge.  Para tales l√≠neas, el controlador muestra informaci√≥n en dmesg: "gpio% d reservado para ACPI".  En el caso de coreboot, el GPIO est√° configurado en el archivo "gpio.h" en la carpeta con la placa base. </li><li>  El dispositivo y el controlador tambi√©n se pueden asignar utilizando el m√©todo _CID (ID compatible), y la documentaci√≥n de nuestro tema en el n√∫cleo se presenta en el documento <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"enumeraci√≥n de dispositivos basada en ACPI"</a> </li></ul><br>  Vale la pena se√±alar que el dispositivo INT33C7 no tiene 2 placas base propietarias en el mismo conjunto de chips en las tablas ACPI (de IBASE y DFI).  Es cierto que lo m√°s probable es que no se generen l√≠neas GPIO (no mir√© la documentaci√≥n en ese momento en detalle). <br><br><h3>  Identificador "INT33C7" </h3><br>  Despu√©s de aumentar la funcionalidad de sysfs, tuve una pregunta, ¬øde d√≥nde vino el n√∫mero de identificaci√≥n "INT33C7"? <br><br>  Despu√©s de mirar la documentaci√≥n para el m√©todo _HID, qued√≥ claro que vale la pena mirar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://www.uefi.org/PNP_ACPI_Registry</a> <br><br><div class="spoiler">  <b class="spoiler_title">_HID (ID de hardware)</b> <div class="spoiler_text">  <b>_HID (ID de hardware)</b> <br>  Este objeto se utiliza para proporcionar a OSPM la ID PNP o ID ACPI del dispositivo * <br>  Al describir una plataforma, el uso de cualquier objeto _HID es opcional.  Sin embargo, un objeto _HID debe ser <br>  se usa para describir cualquier dispositivo que OSPM enumerar√°.  OSPM solo enumera un dispositivo <br>  cuando ning√∫n enumerador de bus puede detectar la ID del dispositivo.  Por ejemplo, los dispositivos en un bus ISA son <br>  enumerado por OSPM.  Use el objeto _ADR para describir dispositivos enumerados por enumeradores de bus <br>  que no sea OSPM. <br><br>  <b>Argumentos:</b> <br>  Ninguno <br><br>  <b>Valor de retorno:</b> <br>  Un entero o cadena que contiene el HID <br>  Un objeto _HID se eval√∫a como un ID de tipo EISA comprimido num√©rico de 32 bits o una cadena.  Si un <br>  cadena, el formato debe ser una identificaci√≥n alfanum√©rica PNP o ACPI sin asterisco u otro <br>  personajes <br><br>  Un ID de PNP v√°lido debe tener la forma "AAA ####" donde A es una letra may√∫scula y # es un hexadecimal <br>  d√≠gito  Un ID de ACPI v√°lido debe tener la forma "NNNN ####" donde N es una letra may√∫scula o un <br>  d√≠gito ('0' - '9') y # es un d√≠gito hexadecimal.  Esta especificaci√≥n reserva la cadena "ACPI" para uso exclusivo <br>  con la lista de dispositivos definidos.  Adem√°s, reserva todas las cadenas que representan 4 d√≠gitos HEX para <br>  uso exclusivo con ID de proveedor asignados por PCI. <br><br>  * -PNP ID y ACPI ID Registry est√°n en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://www.uefi.org/PNP_ACPI_Registry</a> <br></div></div><br>  Hay 3 puntos en este enlace: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> se indican todos los tipos de identificadores de 3 letras (ID de PNP) </li><li>  Las ID de PNP que comienzan con "PNP" reservadas por Microsoft se indican <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠.</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> se indican todos los tipos de identificadores de 4 letras (ID ACPI) </li></ul><br>  No est√° muy claro por qu√©, pero en la lista de ID de PNP puede encontrar que los identificadores "INT" est√°n reservados en INTERPHASE CORPORATION: <br><br><pre> <code class="hljs pgsql">INTERPHASE CORPORATION <span class="hljs-type"><span class="hljs-type">INT</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>/<span class="hljs-number"><span class="hljs-number">29</span></span>/<span class="hljs-number"><span class="hljs-number">1996</span></span></code> </pre> <br>  Aparentemente, no se publica una lista √∫nica de identificadores de dispositivo completos (parte de letra + digital).  Pero con la ayuda de Google fue posible encontrar listas de dispositivos y sus _HID, por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> o <a href="">aqu√≠</a> . <br><br>  Indican: <br><br><pre> <code class="hljs pgsql">INT33C7=Intel <span class="hljs-type"><span class="hljs-type">Serial</span></span> I/O GPIO Host Controller</code> </pre> <br>  Y a juzgar por el resto de las l√≠neas de esta lista, todos los dispositivos INTxxxx son dispositivos Intel (ahora parece bastante obvio, pero la conexi√≥n con INTERPHASE CORPORATION todav√≠a no est√° clara; tampoco est√° muy claro por qu√© la numeraci√≥n comienza con n√∫meros tan grandes, pero es visible en Discreci√≥n de Intel). <br><br><h3>  Controlador de comunicaci√≥n y dispositivo en Windows </h3><br>  Habiendo satisfecho mi curiosidad, decid√≠ descargar Windows en mi tablero.  Como se esperaba, el sistema no pudo encontrar un controlador para el dispositivo.  No hubo ayuda de los controladores para las placas IBASE y DFI, lo cual es comprensible, porque en el BIOS de estas placas este dispositivo no est√° indicado. <br><br>  Logr√© encontrar un controlador <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en el sitio web de Microsoft</a> <br><br>  Sin embargo, all√≠ este controlador se presenta solo para Windows 8.1 y superior.  Todav√≠a estoy trabajando con Windows 7. <br><br>  Sin embargo, intent√© descargar uno de los controladores y especificar su carpeta al buscar un controlador para mi dispositivo desconocido. <br><br>  Sin embargo, el despachador no pudo asignar el controlador al dispositivo.  Aunque el archivo inf conten√≠a claramente informaci√≥n sobre el dispositivo INT33C7. <br><br><pre> <code class="hljs mel">[Manufacturer] %INTEL%=Intel,NTamd64<span class="hljs-number"><span class="hljs-number">.6</span></span><span class="hljs-number"><span class="hljs-number">.3</span></span> [Intel.NTamd64<span class="hljs-number"><span class="hljs-number">.6</span></span><span class="hljs-number"><span class="hljs-number">.3</span></span>] %iaLPSS_GPIO.DeviceDesc_LPT%=iaLPSS_GPIO_Device, ACPI\INT33C7 %iaLPSS_GPIO.DeviceDesc_WPT%=iaLPSS_GPIO_Device, ACPI\INT3437</code> </pre> <br>  En el proceso de analizar el archivo INF, result√≥ que la secci√≥n [Fabricante] indicaba claramente que no estaba destinado a mi sistema: <br><br>  Lo que significa Intel.NTamd64.6.3 se puede entender a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">partir de la descripci√≥n</a> : <br><br><pre> <code class="hljs powershell">nt[<span class="hljs-type"><span class="hljs-type">Architecture</span></span>][<span class="hljs-type"><span class="hljs-type">.</span></span>[<span class="hljs-type"><span class="hljs-type">OSMajorVersion</span></span>][<span class="hljs-type"><span class="hljs-type">.</span></span>[<span class="hljs-type"><span class="hljs-type">OSMinorVersion</span></span>] <span class="hljs-type"><span class="hljs-type">OSMajorVersion</span></span>=<span class="hljs-number"><span class="hljs-number">6</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Windows</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span>/<span class="hljs-type"><span class="hljs-type">Windows</span></span> <span class="hljs-number"><span class="hljs-number">8.1</span></span>/<span class="hljs-type"><span class="hljs-type">Windows</span></span> <span class="hljs-type"><span class="hljs-type">Server</span></span> <span class="hljs-number"><span class="hljs-number">2012</span></span> <span class="hljs-type"><span class="hljs-type">R2</span></span>/<span class="hljs-type"><span class="hljs-type">...</span></span> <span class="hljs-type"><span class="hljs-type">OSMinorVersion</span></span>=<span class="hljs-number"><span class="hljs-number">3</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Windows</span></span> <span class="hljs-number"><span class="hljs-number">8.1</span></span>/<span class="hljs-type"><span class="hljs-type">Windows</span></span> <span class="hljs-type"><span class="hljs-type">Server</span></span> <span class="hljs-number"><span class="hljs-number">2012</span></span> <span class="hljs-type"><span class="hljs-type">R2</span></span></code> </pre> <br>  Tratar de impulsar el controlador de Windows 7 reemplazando Intel.NTamd64.6.3 con Intel.NTamd64.6.1, por decirlo suavemente, fall√≥, ya que me dio una pantalla azul de la muerte y un sistema operativo no arrancable, por lo que tuve que hacer una recuperaci√≥n. <br><br>  El controlador para Win7 se encontr√≥ solo en un sitio web incomprensible en Internet, y luego el dispositivo en el administrador de dispositivos se muestra con un signo de exclamaci√≥n. <br><br>  Al darme cuenta de su impotencia, decid√≠ probar la funcionalidad en Windows 10. Hubo una agradable sorpresa.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Intel Chipset Device Software (INF Update Utility)</a> instal√≥ el controlador para mi controlador sin ning√∫n problema. <br><br><img src="https://habrastorage.org/webt/xb/28/jq/xb28jqet9w3tieq0atau1f2aoum.png"><br><br>  Como puede ver, este dispositivo tiene los recursos indicados por nosotros. <br><br><img src="https://habrastorage.org/webt/2o/fs/p0/2ofsp055fsxm4smnghgxc3eye8u.png"><br><br>  En teor√≠a, despu√©s de instalar el controlador con el controlador GPIO, lo m√°s probable es que sea posible trabajar a trav√©s de las funciones IOCTL ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">como en este documento)</a> . <br><br>  Sin embargo, no hubo una tarea de programaci√≥n GPIO de Windows, por lo que se pospuso la b√∫squeda de un documento similar para mi conjunto de chips. <br><br><hr><br><h3>  Conclusi√≥n </h3><br>  Este art√≠culo examin√≥ la conexi√≥n entre el controlador y el dispositivo utilizando el m√©todo _HID ACPI.  Dicha comunicaci√≥n puede ser necesaria en un sistema x86 para dispositivos que no se pueden enumerar. <br><br><ul><li>  En el caso de Linux, la comunicaci√≥n con el controlador se realiza a trav√©s de .acpi_match_table </li><li>  En el caso de Windows, la comunicaci√≥n con el controlador es a trav√©s de un archivo INF </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es429336/">https://habr.com/ru/post/es429336/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es429324/index.html">Lanzamiento de Unreal Engine 4.21</a></li>
<li><a href="../es429326/index.html">App Store no llamar√°. O c√≥mo hice mi solicitud, pero no llegar√° a los usuarios</a></li>
<li><a href="../es429328/index.html">M√≥dulo de software para digitalizar documentos da√±ados</a></li>
<li><a href="../es429330/index.html">Mitos y leyendas de Agile: desde los faraones hasta nuestros d√≠as</a></li>
<li><a href="../es429332/index.html">Sable de luz l√°ser casero: como estaba, parte 1</a></li>
<li><a href="../es429338/index.html">Almacenamiento de Android: interno, externo, extra√≠ble. Parte 1/3</a></li>
<li><a href="../es429340/index.html">Pi√©nselo dos veces antes de usar Helm.</a></li>
<li><a href="../es429342/index.html">Angular 6+ es una gu√≠a completa de inyecci√≥n de dependencia. provideIn vs proveedores: []</a></li>
<li><a href="../es429344/index.html">Lectura de fin de semana: sintonizaci√≥n de audio y recursos de dise√±o de altavoces</a></li>
<li><a href="../es429346/index.html">Para el programa de maestr√≠a sin ex√°menes: una nueva direcci√≥n "Big Data" en los Juegos Ol√≠mpicos "Soy un profesional"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>