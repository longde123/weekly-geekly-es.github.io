<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚀 👸🏻 👲🏾 我如何不扫描白俄罗斯互联网 🏨 🛰️ 🙋🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="前言 
 本文与之前发布的有关扫描某些国家/地区的Internet的文章不太相似，因为我没有追求对Internet的特定部分进行大规模扫描的开放端口和存在最普遍漏洞的目标，因为这是违法的。 

 我的兴趣稍有不同-尝试使用不同的方法来识别BY域区域中的所有相关站点，并通过Shodan，VirusTo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>我如何不扫描白俄罗斯互联网</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446022/"><h2> 前言 </h2><br> 本文与之前发布的有关扫描某些国家/地区的Internet的文章不太相似，因为我没有追求对Internet的特定部分进行大规模扫描的开放端口和存在最普遍漏洞的目标，因为这是违法的。 <br><br> 我的兴趣稍有不同-尝试使用不同的方法来识别BY域区域中的所有相关站点，并通过Shodan，VirusTotal等服务来确定所使用的技术堆栈，以通过IP和开放端口执行被动侦察，并在附件中收集一些其他有用的信息信息，用于形成有关站点和用户的安全级别的一些常规统计信息。 <br><a name="habracut"></a><br><h2> 介绍和我们的工具包 </h2><br> 一开始的计划很简单-请与您的本地注册商联系以获取当前注册域的列表，然后检查所有内容以获取可用性并开始探索可运行的网站。 实际上，一切都变得更加复杂-这种信息是自然的，没有人愿意提供，除了BY区域中实际注册域名（约13万个域）的官方统计页面之外。 如果没有此类信息，则必须自己收集。 <br><br><img src="https://habrastorage.org/webt/yh/pz/4w/yhpz4wvpvleq-f25o5fp5wwt_2u.png"><br><br> 就工具而言，实际上，一切都非常简单-我们面向开放源码，您可以随时添加一些东西，完成一些基本工作。 在最受欢迎的工具中，使用了以下工具： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Whatweb</a> </li><li> 卷曲 </li><li> 挖 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">wafw00f</a> </li><li> 第三方API（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">VirusTotal</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Google SafeBrwosing</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Shodan</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Vulners</a> ） </li></ul><br><br><h2> 活动开始：起点 </h2><br> 作为引言，正如我之前所说，理想的域名是合适的，但是在哪里可以买到呢？ 我们需要从更简单的方法开始，在这种情况下，IP地址适合我们，但是再次-使用反向查找，并非总是能够捕获所有域，并且在收集主机名时-它并不总是正确的域。 在这个阶段，我再次考虑收集此类信息的可能方案-考虑到我们的预算是VPS租金5美元，其他一切都应该免费。 <br><br><h3> 我们潜在的信息来源： </h3><br><ul><li>  IP地址（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ip2location</a>站点） </li><li> 通过电子邮件地址的第二部分搜索域（但从何处获取它们？ </li><li> 一些注册服务商/托管服务提供商可能会以子域的形式向我们提供此类信息 </li><li> 子域及其后续反向链接（Sublist3r和Aquatone在这里可以提供帮助） </li><li> 蛮力和手动输入（长，沉闷，但可以，尽管我没有使用此选项） </li></ul><br> 我会先行一点，说通过这种方法，我分别设法收集了大约5万个唯一的域和站点（我没有设法处理所有事情）。 如果他继续积极地收集信息，那么可以肯定，在不到一个月的工作中，我的传送带将掌握整个数据库或其中的大部分数据库。 <br><br><h3> 让我们开始做生意 </h3><br> 在前几篇文章中，有关IP地址的信息是从IP2LOCATION网站上获取的，出于明显的原因，我没有看过这些文章（因为所有操作都发生得较早），但也涉及到该资源。 没错，就我而言，方法是不同的-我决定不将数据库本地化，也不从CSV提取信息，而是决定直接在网站上持续不断地监视更改，并将其作为所有后续脚本作为目标的主要基础-制作了一个表格IP地址的格式不同：CIDR，“从”和“至”列表，国家标记（以防万一），AS编号，AS描述。 <br><br><img src="https://habrastorage.org/webt/mx/s4/wj/mxs4wjpxueytkcd15srf7alswf8.png"><br><br> 格式不是最理想的，但是我对演示和一次性升级感到非常满意，并且为了不经常获取ASN之类的辅助信息，我决定在家里另外进行记录。 为了获得此信息，我转向<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">IpToASN</a>服务，它们具有便捷的API（有限制），实际上您只需要集成到自己中即可。 <br><br><div class="spoiler">  <b class="spoiler_title">IP解析代码</b> <div class="spoiler_text"><pre><code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ipList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, <span class="hljs-string"><span class="hljs-string">"https://lite.ip2location.com/belarus-ip-address-ranges"</span></span>); curl_setopt($ch, CURLOPT_HEADER, <span class="hljs-number"><span class="hljs-number">0</span></span>); curl_setopt($ch, CURLOPT_USERAGENT,<span class="hljs-string"><span class="hljs-string">'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.13) Gecko/20080311 Firefox/2.0.0.13'</span></span>); curl_setopt($ch, CURLOPT_RETURNTRANSFER, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); $ipList = curl_exec($ch); curl_close ($ch); preg_match_all(<span class="hljs-string"><span class="hljs-string">"/(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\&lt;\/td\&gt;\s+\&lt;td\&gt;\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})/"</span></span>, $ipList, $matches); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $matches[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iprange2cidr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($ipStart, $ipEnd)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_string($ipStart) || is_string($ipEnd)){ $start = ip2long($ipStart); $end = ip2long($ipEnd); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ $start = $ipStart; $end = $ipEnd; } $result = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>($end &gt;= $start){ $maxSize = <span class="hljs-number"><span class="hljs-number">32</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($maxSize &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>){ $mask = hexdec(iMask($maxSize - <span class="hljs-number"><span class="hljs-number">1</span></span>)); $maskBase = $start &amp; $mask; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($maskBase != $start) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; $maxSize--; } $x = log($end - $start + <span class="hljs-number"><span class="hljs-number">1</span></span>)/log(<span class="hljs-number"><span class="hljs-number">2</span></span>); $maxDiff = floor(<span class="hljs-number"><span class="hljs-number">32</span></span> - floor($x)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($maxSize &lt; $maxDiff){ $maxSize = $maxDiff; } $ip = long2ip($start); array_push($result, <span class="hljs-string"><span class="hljs-string">"$ip/$maxSize"</span></span>); $start += pow(<span class="hljs-number"><span class="hljs-number">2</span></span>, (<span class="hljs-number"><span class="hljs-number">32</span></span>-$maxSize)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $result; } $getIpList = ipList(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>($getIpList <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $item) { $cidr = iprange2cidr($ip[<span class="hljs-number"><span class="hljs-number">0</span></span>], $ip[<span class="hljs-number"><span class="hljs-number">1</span></span>]); }</code> </pre> <br></div></div><br> 弄清楚IP之后，我们需要通过反向查找服务运行整个数据库，可惜没有任何限制-除了钱，这是不可能的。 <br><br> 在最适合此功能且易于使用的服务中，我想提到两个： <br><br><ol><li>  VirusTotal-限制从一个API密钥调用的频率 </li><li>  Hackertarget.com（其API）-限制一个IP的点击次数 </li></ol><br> 超过限制，可获得以下选项： <br><br><ul><li> 在第一种情况下，一种情况是承受15秒的超时，我们总共将每分钟有4个呼叫，这会极大地影响我们的速度，在这种情况下，使用2-3个这样的键将很有用，我建议使用相同的方法代理和更改用户代理。 </li><li> 在第二种情况下，我编写了一个脚本，用于基于公开可用的信息，其验证和后续使用来自动解析代理数据库（但后来我离开了此选项，因为VirusTotal本质上也足够了） </li></ul><br> 我们走得更远并且很顺利地转到电子邮件地址。 它们也可以成为有用信息的来源，但是在哪里收集它们呢？ 我不必长时间寻找解决方案，因为 用户在我们的个人网站细分中占有很少的份额，其中大多数是组织-在线商店目录，论坛和有条件的市场等个人资料网站将非常适合我们。 <br><br> 例如，对这些站点之一的快速检查显示，许多用户将其电子邮件直接添加到其公共资料中，因此，可以仔细分析此业务以备将来使用。 <br><br><div class="spoiler">  <b class="spoiler_title">解析器之一</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env python3 import sys, threading, time, os, urllib, re, requests, pymysql from html.parser import HTMLParser from urllib import request from bs4 import BeautifulSoup # HEADERS CONFIG headers = { 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 11.9; rv:42.0) Gecko/20200202 Firefox/41.0' } file = open('dat.html', 'w') def parseMails(uid): page = 'https://profile.onliner.by/user/'+str(uid)+'' cookie = {'onl_session': 'YOUR_SESSION_COOOKIE_HERE'} r = requests.get(page, headers = headers, cookies = cookie) data = BeautifulSoup(r.text) userinfo = data.find_all('dl', {'class': 'uprofile-info'}) find_email = [] for item in userinfo: find_email += str(item.find('a')) get_mail = ''.join(find_email) detect_email = re.compile(".+?&gt;(.+@.+?)&lt;/a&gt;").search(get_mail) file.write("&lt;li&gt;('"+detect_email.group(1)+"'),&lt;/li&gt;") for uid in range(1, 10000): t = threading.Thread(target=parseMails, args=(uid,)) t.start() time.sleep(0.3)</span></span></code> </pre><br></div></div><br> 我将不讨论解析每个站点的细节，在某个地方更容易通过蛮力猜测用户ID，在某个地方更容易解析站点地图，从中获取有关公司页面的信息，然后从中收集地址。 收集地址后，我们仍然需要执行一些简单的操作，立即按域区域对它们进行排序，保留“尾巴”并用尽它们，以从现有数据库中排除重复项。 <br><br> 在这个阶段，我相信随着范围的形成，我们可以结束并继续发展智能。 我们已经知道，智能可以分为主动和被动两种类型，在我们的案例中，被动方法将是最相关的。 但是再说一次，仅在端口80或443上访问站点而没有恶意负载并利用漏洞是相当合法的行为。 我们的兴趣是服务器对单个请求的响应，在某些情况下，可以有两个请求（从http重定向到https），在少数情况下，可以多达三个（使用www时）。 <br><br><h2> 智商 </h2><br> 使用此类信息作为域，我们可以收集以下数据： <br><br><ul><li>  DNS记录（NS，MX，TXT） </li><li> 答案标题 </li><li> 识别使用的技术栈 </li><li> 了解网站使用哪种协议。 </li><li> 尝试识别开放端口（基于Shodan / Censys数据库）而不进行直接扫描 </li><li> 尝试根据Shodan / Censys与Vulners数据库之间的信息相关性来识别漏洞 </li><li> 它在Google安全浏览恶意软件数据库中吗 </li><li> 此外，还可以按域收集电子邮件地址，以及已经找到的匹配项并通过“我被拥有”进行检查-链接到社交网络 </li><li> 在某些情况下，域不仅是公司的面孔，而且是其活动的产品，用于服务注册的电子邮件地址等，您可以在GitHub，Pastebin，Google Dorks（Google CSE）等资源上搜索与其相关的信息） </li></ul><br> 您可以随时使用masscan或nmap，zmap选项，先通过Tor进行设置，然后随机启动，甚至在多个实例中启动，但我们还有其他目标，而且这个名称意味着我没有进行直接扫描。 <br><br> 我们收集DNS记录，检查请求放大的可能性和诸如AXFR之类的配置错误： <br><br><div class="spoiler">  <b class="spoiler_title">收集NS服务器记录的示例</b> <div class="spoiler_text"><pre> <code class="bash hljs">dig ns +short <span class="hljs-variable"><span class="hljs-variable">$domain</span></span> | sed <span class="hljs-string"><span class="hljs-string">'s/\.$//g'</span></span> | awk <span class="hljs-string"><span class="hljs-string">'{print $1}'</span></span></code> </pre> <br></div></div><br>  MX记录收集示例（请参阅NS，只需将'ns'替换为'mx' <br><br><div class="spoiler">  <b class="spoiler_title">检查AXFR（这里有很多解决方案，这里是另一个拐杖，但是不安全，我曾经查看输出）</b> <div class="spoiler_text"><pre> <code class="php hljs"> $digNs = trim(shell_exec(<span class="hljs-string"><span class="hljs-string">"dig ns +short $domain | sed 's/\.$//g' | awk '{print $1}'"</span></span>)); $ns = explode(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>, $digNs); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>($ns <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $target) { $axfr = trim(shell_exec(<span class="hljs-string"><span class="hljs-string">"dig -t axfr $domain @$target | awk '{print $1}' | sed 's/\.$//g'"</span></span>)); $axfr = preg_replace(<span class="hljs-string"><span class="hljs-string">"/\;/"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, $axfr); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!<span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>(trim($axfr))) { $axfr = preg_replace(<span class="hljs-string"><span class="hljs-string">"/\;/"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, $axfr); $res = json_encode(explode(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>, trim($axfr)));</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">检查DNS放大</b> <div class="spoiler_text"><pre> <code class="bash hljs">dig +short test.openresolver.com TXT @<span class="hljs-variable"><span class="hljs-variable">$dns</span></span></code> </pre> <br> 就我而言，NS服务器是从数据库中获取的，因此在变量的末尾，实际上您可以替换任何服务器。 关于此服务结果的正确性，我不确定那里一切正常，结果始终有效，但我希望大多数结果都是真实的。 <br></div></div><br> 如果出于任何目的，我们需要保留网站的完整最终网址，为此我使用了cURL： <br><br><pre> <code class="bash hljs">curl -I -L <span class="hljs-variable"><span class="hljs-variable">$target</span></span> | awk <span class="hljs-string"><span class="hljs-string">'/Location/{print $2}'</span></span></code> </pre> <br> 他本人将经历整个重定向并显示最后一个重定向，即 当前网站的网址。 就我而言，它对于随后使用诸如WhatWeb之类的工具非常有用。 <br><br> 我们为什么要使用它？ 为了确定操作系统，Web服务器，所使用的CMS站点，一些标头，诸如JS / HTML库/框架之类的其他模块，以及站点名称，您以后可以通过该站点标题尝试按同一活动字段进行过滤。 <br><br> 在这种情况下，一个非常方便的选择是以XML格式导出该工具的操作结果以进行后续分析，如果目标是稍后进行处理，则可以将其导入数据库。 <br><br><pre> <code class="bash hljs">whatweb --no-errors https://www.mywebsite.com --<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>-xml=results.xml</code> </pre> <br> 就我自己而言，我根据输出结果制作了JSON，并将其放入数据库中。 <br><br> 说到标题，通过执行以下形式的查询，您可以使用普通的cURL进行几乎相同的操作： <br><br><pre> <code class="bash hljs">curl -I https://www.mywebsite.com</code> </pre> <br> 在标头中，例如，使用正则表达式捕获有关CMS和Web服务器的信息。 <br><br> 除了有用的方法外，我们还可以强调以下可能性：使用Shodan收集有关开放端口的信息，然后使用已经获得的数据，使用其API对Vulners数据库进行检查（在标题中提供了指向服务的链接）。 当然，在这种情况下，准确性可能会出现问题，但这不是通过手动验证进行的直接扫描，而是对第三方来源的数据进行了平庸的“弄乱”，但至少总比没有好。 <br><br><div class="spoiler">  <b class="spoiler_title">Shodan的PHP函数</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shodanHost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($host)</span></span></span><span class="hljs-function"> </span></span>{ $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, <span class="hljs-string"><span class="hljs-string">"https://api.shodan.io/shodan/host/"</span></span>.$host.<span class="hljs-string"><span class="hljs-string">"?key=&lt;YOUR_API_KEY&gt;"</span></span>); curl_setopt($ch, CURLOPT_HEADER, <span class="hljs-number"><span class="hljs-number">0</span></span>); curl_setopt($ch, CURLOPT_USERAGENT,<span class="hljs-string"><span class="hljs-string">'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.13) Gecko/20080311 Firefox/2.0.0.13'</span></span>); curl_setopt($ch, CURLOPT_RETURNTRANSFER, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); $shodanResponse = curl_exec($ch); curl_close ($ch); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> json_decode($shodanResponse); }</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">这样的比较分析的一个例子＃1</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ha/fv/7q/hafv7qlzupcsueqn_qwe_0qyo7y.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Example＃2</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/9x/0c/jx/9x0cjxkltuscladnh9rd4nshsga.png"><br></div></div><br> 是的，自从他们开始谈论API以来，Vulners就有了局限性，最理想的解决方案是使用Python脚本，一切都可以顺利进行而无需扭转，在PHP的情况下，我遇到了一些小困难（再次添加。超时保存了情况）。 <br><br> 最新测试之一-我们将研究与脚本一起使用的防火墙信息，例如“ wafw00f”。 在测试这个出色的工具时，我注意到了一件有趣的事情：并非总是第一次可以确定所使用的防火墙的类型。 <br><br> 要查看wafw00f可以检测到哪些类型的防火墙，可以输入以下命令： <br><br><pre> <code class="bash hljs">wafw00f -l</code> </pre> <br> 为了确定防火墙的类型，wafw00f在向站点发送标准请求后分析服务器的响应标头，如果这种尝试还不够，它会生成一个附加的简单测试请求，如果再次不够，则第三种方法将在前两次尝试之后对数据进行操作。 <br><br> 因为 对于统计数据，实际上，我们不需要完整的答案，我们使用正则表达式将所有多余的内容都切除，仅保留防火墙名称： <br><br><pre> <code class="php hljs">/is\sbehind\sa\s(.+?)\n/</code> </pre> <br> 好吧，正如我之前写的-除了有关域和站点的信息之外，有关电子邮件地址和社交网络的信息也以被动方式进行了更新： <br><br><div class="spoiler">  <b class="spoiler_title">根据域定义的电子邮件统计信息</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/f-/lq/fj/f-lqfjqylimkrb3l8ham2yxo8f4.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">确定社交网络与电子邮件地址的绑定的示例</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/an/pw/dq/anpwdqniobeopkdhnyq5pd5ejgk.png"><br></div></div><br> 在这方面，最简单的方法是处理Twitter上的地址验证（2种方法），而使用Facebook（1种方法），由于生成实际用户会话的系统稍微复杂一些，事实证明它要复杂一些。 <br><br><h2> 让我们继续进行干统计。 </h2><br><h4>  DNS统计 </h4><br><img src="https://habrastorage.org/webt/uk/md/m1/ukmdm1eoizu6sjvxaf7nld8kdgi.png"><br><br>  <b>提供商-多少个站点</b> <br>  ns1.tutby.com：10899 <br>  ns2.tutby.com：10899 <br>  ns1.neolocation.com：4877 <br>  ns2.neolocation.com：4873 <br>  ns3.neolocation.com：4572 <br>  ns1.activeby.net：4231 <br>  ns2.activeby.net：4229 <br>  u1.hoster.by：3382 <br>  u2.hoster.by：3378 <br><br> 找到唯一的DNS：2462 <br> 独特的MX（邮件）服务器：9175（除了流行的服务之外，还有足够数量的管理员使用自己的邮件服务） <br> 受DNS区域传输影响：1011 <br> 受DNS放大影响：531 <br> 很少有CloudFlare粉丝：375（基于使用过的NS记录） <br><br><h4>  CMS统计 </h4><br><img src="https://habrastorage.org/webt/oz/zp/0k/ozzp0kkl6kof-gomjiesmgoju_y.png"><br><br>  <b>CMS-数量</b> <br>  WordPress：5118 <br>  Joomla：2722 <br>  Bitrix：1757年 <br>  Drupal：898 <br>  OpenCart的：235 <br> 数据生命：133 <br>  Magento的：32 <br><br><ul><li> 潜在脆弱的WordPress安装：2977 </li><li>  Joomla的潜在脆弱安装：212 </li><li> 使用Google SafeBrowsing服务，可以识别潜在的危险或受感染的网站：大约10,000个（在不同时间，有人被修复，有人被破坏，统计数据并不完全是客观的） </li><li> 关于HTTP和HTTPS-发现的卷中不到一半的站点使用后者，但是考虑到我的数据库不完整，但仅占总数的40％，因此，下半部分站点中的大多数很可能可以通过HTTPS进行通信。 </li></ul><br><h4> 防火墙统计信息： </h4><br><img src="https://habrastorage.org/webt/1o/pf/qc/1opfqck9bluf4aa2xvjt2aivaks.png"><br><br>  <b>防火墙-编号</b> <br>  ModSecurity：4354 <br>  IBM Web App安全性：126 <br> 更好的WP安全性：110 <br> 耀斑：104 <br>  Imperva SecureSphere：45 <br>  Juniper WebApp安全：45 <br><br><h4>  Web服务器统计 </h4><br><img src="https://habrastorage.org/webt/k1/ru/ut/k1ruutqumvvmoism9bafmdp8oko.png"><br><br>  <b>Web服务器-编号</b> <br>  Nginx：31752 <br> 阿帕奇：4042 <br>  IIS：959 <br><br>  Nginx的过时和潜在漏洞安装：20966 <br> 不推荐使用的，可能易受攻击的Apache安装：995 <br><br> 例如，尽管hoster.by是域名和托管领域的领导者，但通常也区分了Open Contact，但事实是一个IP上的站点数： <br><br><img src="https://habrastorage.org/webt/mq/gu/wj/mqguwjm8_1ggvfo_o5vam20tjto.png"><br><br>  <b>IP-网站</b> <br>  93.84.119.243：556 <br>  93.125.99.83：399 <br>  193.232.92.25：386 <br><br><img src="https://habrastorage.org/webt/h0/us/nk/h0usnka_tsv0yqqa5jb8vd5wy_k.png"><br><br> 通过电子邮件，详细的统计信息确实决定不被提取，也没有按域区域进行排序，相反，看到特定供应商的用户位置很有趣： <br><br><ul><li> 在TUT.BY服务上：38282 </li><li> 在Yandex服务上（按| ru）：28127 </li><li> 在Gmail服务上：33452 </li><li> 绑在Facebook上：866 </li><li> 绑在Twitter上：652 </li><li> 符合HIBP：7844的泄漏特征 </li><li> 被动情报帮助识别超过13000个电子邮件地址 </li></ul><br> 如您所见，总体情况是乐观的，尤其是托管服务提供商提供的Nginx的积极使用。 也许这主要是由于普通用户中的流行-共享托管类型。 <br><br> 由于我真的不喜欢它，所以有足够多的中间人托管服务提供商注意到了AXFR之类的错误，使用过时的SSH和Apache版本以及其他一些小问题。 在这里，当然可以通过活动阶段来进一步了解情况，但是目前，根据我们的立法，在我看来这是不可能的，而且我真的不想在这类问题上加入有害生物的行列。 <br><br> 如果您可以这样称呼，那么电子邮件的图片通常会非常漂亮。 哦，是的，指示了TUT.BY提供程序的位置-这意味着使用域，因为 此服务基于Yandex。 <br><br><h2> 结论 </h2><br> 总而言之，我可以说一件事-即使获得了可用的结果，您也可以快速了解，涉及清理病毒，设置WAF以及配置/添加不同CMS的专家的工作量很大。 <br><br> 好吧，严肃地说，就像前两篇文章一样，我们看到问题在Internet和国家的绝对所有细分市场中存在着完全不同的层次，其中一些问题甚至在没有使用攻击性方法的情况下就进行了远程研究。 e。 使用公开信息收集不需要的特殊技能。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN446022/">https://habr.com/ru/post/zh-CN446022/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN445992/index.html">最小的Nauchpop：错觉</a></li>
<li><a href="../zh-CN445998/index.html">如何交朋友OpenEdge和Oracle DBMS</a></li>
<li><a href="../zh-CN446000/index.html">Yandex.Music有什么问题？ UX / UI解析</a></li>
<li><a href="../zh-CN446006/index.html">英特尔-声音新</a></li>
<li><a href="../zh-CN446008/index.html">开源工具，用于基于意图的搜索质量验证</a></li>
<li><a href="../zh-CN446024/index.html">安装和配置Ripple节点</a></li>
<li><a href="../zh-CN446026/index.html">为什么SvelteJS可以说是新Web开发人员的最佳框架</a></li>
<li><a href="../zh-CN446028/index.html">分布式应用程序的构建块。 零近似</a></li>
<li><a href="../zh-CN446030/index.html">抗衰老生物技术领域的初创企业，将在2019年相关</a></li>
<li><a href="../zh-CN446032/index.html">将1080P视频缩放到4K，或者使用神经网络将我学会不用担心和喜欢高档</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>