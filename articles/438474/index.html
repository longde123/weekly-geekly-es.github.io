<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôÖüèø ü§¶üèΩ üí™üèΩ Courier: migraci√≥n de Dropbox a gRPC üåõ üôçüèø üíó</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nota del traductor 
 La mayor√≠a de los productos de software modernos no son monol√≠ticos, sino que consisten en muchas partes que interact√∫an entre s√≠...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Courier: migraci√≥n de Dropbox a gRPC</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/438474/"><img src="https://habrastorage.org/webt/eu/p8/y-/eup8y-m8hpxc9w2qhvo1qofrmog.jpeg"><br><br><h1>  Nota del traductor </h1><br>  La mayor√≠a de los productos de software modernos no son monol√≠ticos, sino que consisten en muchas partes que interact√∫an entre s√≠.  En esta situaci√≥n, es necesario que la comunicaci√≥n de las partes interactivas del sistema tenga lugar en un idioma (a pesar de que estas partes pueden escribirse en diferentes lenguajes de programaci√≥n y ejecutarse en diferentes m√°quinas).  Para simplificar la soluci√≥n a este problema, ayuda a gRPC - open-source-framework de Google, lanzado en 2015.  Inmediatamente resuelve una serie de problemas, permitiendo: <br><br><ul><li>  use el lenguaje de Protocol Buffers para describir la interacci√≥n de los servicios; <br></li><li>  generar c√≥digo de programa basado en el protocolo descrito para 11 idiomas diferentes para la parte del cliente y la parte del servidor; <br></li><li>  implementar la autorizaci√≥n entre componentes que interact√∫an; <br></li><li>  use tanto la interacci√≥n sincr√≥nica como la asincr√≥nica. <br></li></ul><br>  gRPC me pareci√≥ un marco bastante interesante, y estaba interesado en conocer la experiencia real de Dropbox en la construcci√≥n de un sistema basado en √©l.  El art√≠culo tiene muchos detalles relacionados con el uso del cifrado, la construcci√≥n de un sistema confiable, observable y productivo, el proceso de migraci√≥n de la antigua soluci√≥n RPC a la nueva. <br><br><div class="spoiler">  <b class="spoiler_title">Descargo de responsabilidad</b> <div class="spoiler_text">  El art√≠culo original no contiene una descripci√≥n de gRPC, y algunos puntos pueden no parecerle claros.  Si no est√° familiarizado con gRPC u otros marcos similares (por ejemplo, Apache Thrift), le recomiendo que primero se familiarice con las ideas principales (ser√° suficiente leer dos peque√±os art√≠culos del sitio web oficial: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">‚Äú¬øQu√© es gRPC?‚Äù</a> Y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">‚ÄúConceptos de gRPC‚Äù</a> ). <br><br>  Gracias a Aleksey Ivanov, alias <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">SaveTheRbtz,</a> por escribir el art√≠culo original y ayudar a traducir lugares dif√≠ciles. <br></div></div><a name="habracut"></a><br>  Dropbox gestiona muchos servicios escritos en diferentes idiomas y atiende millones de solicitudes por segundo.  En el centro de nuestra arquitectura orientada a servicios se encuentra Courier, un marco RPC basado en gPC.  En el proceso de su desarrollo, aprendimos mucho sobre la extensibilidad de gRPC, la optimizaci√≥n del rendimiento y la transici√≥n desde el sistema RPC anterior. <br><br>  <i>Nota: la publicaci√≥n contiene fragmentos de c√≥digo para Python y Go.</i>  <i>Tambi√©n usamos Rust y Java.</i> <br><br><h1>  Camino a gRPC </h1><br>  Courier no es el primer marco de Dropbox RPC.  Incluso antes de comenzar a dividir el sistema monol√≠tico de Python en servicios separados, necesit√°bamos una base confiable para el intercambio de datos entre servicios, especialmente porque elegir un marco tendr√≠a consecuencias a largo plazo. <br><br>  Antes de eso, Dropbox experiment√≥ con diferentes marcos RPC.  Primero, ten√≠amos un protocolo individual para la serializaci√≥n y deserializaci√≥n manual.  Algunos servicios, como el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">registro basado en Scribe</a> , utilizan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Apache Thrift</a> .  Al mismo tiempo, nuestro marco principal de RPC era un protocolo HTTP / 1.1 con mensajes serializados usando Protobuf. <br><br>  Al crear un marco, elegimos entre varias opciones.  Podr√≠amos introducir Swagger (ahora conocido como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">OpenAPI</a> ) en el antiguo marco RPC, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">introducir un nuevo est√°ndar</a> o crear un marco basado en Thrift o gRPC.  El argumento principal a favor de gRPC fue la posibilidad de utilizar prototipos existentes.  Adem√°s, la transferencia de datos multiplex HTTP / 2 y bidireccional fueron √∫tiles para nuestras tareas. <br><br>  <i>Nota: si fbthrift existiera en ese momento, probablemente examinar√≠amos m√°s de cerca las soluciones de Thrift.</i> <br><br><h1>  Lo que Courier trae a gRPC </h1><br>  Courier no es un protocolo RPC;  Es un medio para integrar gRPC en una infraestructura existente.  Se supon√≠a que el marco era compatible con nuestras herramientas de autenticaci√≥n, autorizaci√≥n y descubrimiento de servicios, as√≠ como con la recopilaci√≥n, registro y seguimiento de estad√≠sticas.  Entonces creamos Courier. <br><br>  <i>Aunque en algunos casos usamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bandaid</a> como un proxy gRPC, la mayor√≠a de nuestros servicios se comunican directamente entre s√≠ para minimizar el impacto de RPC en la latencia.</i> <br><br>  Fue importante para nosotros reducir la cantidad de c√≥digo de rutina que debe escribirse.  Dado que Courier sirve como un marco general para el desarrollo de servicios, contiene caracter√≠sticas que todos necesitan.  La mayor√≠a de ellos est√°n habilitados de manera predeterminada y pueden controlarse mediante argumentos de l√≠nea de comando, y algunos est√°n marcados con una casilla de verificaci√≥n. <br><br><h2>  Seguridad: identidad de servicio y autenticaci√≥n mutua TLS </h2><br>  Courier implementa nuestro mecanismo de identificaci√≥n de servicio est√°ndar.  A cada servidor y cliente se le asigna un certificado TLS individual emitido por nuestra propia autoridad de certificaci√≥n.  El identificador personal codificado en el certificado, que se utiliza para la autenticaci√≥n mutua: el servidor verifica al cliente, el cliente verifica al servidor. <br><br>  En TLS, donde controlamos ambos lados de la conexi√≥n, hemos introducido restricciones estrictas.  Todos los RPC internos requieren cifrado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PFS</a> .  La versi√≥n requerida de TLS es 1.2 y superior.  Tambi√©n limitamos el n√∫mero de algoritmos sim√©tricos y asim√©tricos, prefiriendo <i>ECDHE-ECDSA-AES128-GCM-SHA256</i> . <br><br>  Despu√©s de pasar por la identificaci√≥n y descifrado de la solicitud, el servidor verifica si el cliente tiene los permisos necesarios.  Las listas de control de acceso (ACL) y los l√≠mites de velocidad se pueden configurar tanto para servicios en general como para m√©todos individuales.  Sus par√°metros tambi√©n se pueden cambiar a trav√©s de nuestro sistema de archivos distribuido (AFS).  Gracias a esto, los propietarios de servicios pueden soltar la carga en segundos, sin siquiera reiniciar los procesos.  Courier se encargar√° de suscribirse a las notificaciones y actualizar la configuraci√≥n. <br><br>  <i>El servicio de identidad es un identificador global para ACL, l√≠mites de velocidad, estad√≠sticas, etc. Adem√°s, es criptogr√°ficamente seguro.</i> <br><br>  Aqu√≠ hay un ejemplo de configuraci√≥n de ACL y l√≠mite de velocidad utilizado en nuestro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">servicio de reconocimiento de patrones √≥pticos</a> : <br><br><pre><code class="plaintext hljs">limits:  dropbox_engine_ocr:    # All RPC methods.    default:      max_concurrency: 32      queue_timeout_ms: 1000      rate_acls:        # OCR clients are unlimited.        ocr: -1        # Nobody else gets to talk to us.        authenticated: 0        unauthenticated: 0</code> </pre> <br><img src="https://habrastorage.org/webt/ll/as/l_/llasl_0osxrxbboxrbjqaalb8ti.png"><br><br>  <i>Estamos considerando la posibilidad de cambiar al formato SVID (documento <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SPIFFE</a> verificado criptogr√°ficamente), lo que ayudar√° a combinar nuestro marco con muchos proyectos de c√≥digo abierto.</i> <br><br><h2>  Observabilidad: estad√≠sticas y seguimiento </h2><br>  Con solo un identificador, puede encontrar f√°cilmente registros, estad√≠sticas, archivos de rastreo y otros datos sobre Courier. <br><br><img src="https://habrastorage.org/webt/t_/25/3o/t_253ogfq1bizretdswvdrb_7g0.png"><br><br>  Durante la generaci√≥n de c√≥digo, se agrega la recopilaci√≥n de estad√≠sticas para cada servicio y cada m√©todo tanto en el lado del cliente como en el lado del servidor.  Las estad√≠sticas del lado del servidor se dividen por ID de cliente.  En la configuraci√≥n est√°ndar, recibir√° datos detallados sobre la carga, los errores y el tiempo de retraso para cada servicio que utiliza Courier. <br><br><img src="https://habrastorage.org/webt/g1/6g/_1/g16g_1z72oxaxwwvasrjhznfltk.png"><br><br>  Las estad√≠sticas de mensajer√≠a incluyen datos sobre disponibilidad y latencia en el lado del cliente, as√≠ como en el n√∫mero de solicitudes y el tama√±o de la cola en el lado del servidor.  Hay otros gr√°ficos √∫tiles, en particular histogramas de tiempo de respuesta para cada m√©todo y el tiempo de apretones de manos TLS para cada cliente. <br><br>  <i>Una de las ventajas de nuestra generaci√≥n de c√≥digo es la posibilidad de inicializaci√≥n est√°tica de estructuras de datos, como histogramas y gr√°ficos de trazas.</i>  <i>Esto minimiza el impacto en el rendimiento.</i> <br><br><img src="https://habrastorage.org/webt/p7/6-/fv/p76-fvobtszsgtu2g2tlmwfwlyk.png"><br><br>  El antiguo sistema RPC solo distribu√≠a <i>request_id a</i> trav√©s de la API.  Esto permiti√≥ combinar datos de los registros de diferentes servicios.  En Courier, presentamos una API basada en un subconjunto de las especificaciones <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">OpenTracing</a> .  Escribimos nuestras propias bibliotecas en el lado del cliente, y en el lado del servidor implementamos una soluci√≥n basada en Cassandra y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Jaeger</a> . <br><br><img src="https://habrastorage.org/webt/dk/hv/iq/dkhviqgdiem3itipi7x87tri_i8.png"><br><br>  El rastreo nos permite generar diagramas de dependencia de un servicio en tiempo de ejecuci√≥n.  Esto ayuda a los ingenieros a ver todas las dependencias transitivas de un servicio en particular.  Adem√°s, la funci√≥n es √∫til para rastrear dependencias no deseadas despu√©s de la implementaci√≥n. <br><br><h2>  Fiabilidad: plazos y desconexi√≥n </h2><br>  Courier proporciona un lugar central para implementar funciones comunes del cliente (por ejemplo, tiempos de espera) en diferentes idiomas.  Gradualmente agregamos varias caracter√≠sticas, a menudo basadas en los resultados de un an√°lisis "p√≥stumo" de problemas emergentes. <br><br><h3>  Plazos </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cada solicitud de gRPC tiene una fecha l√≠mite que</a> indica el tiempo de espera del cliente.  Dado que los ap√©ndices de Courier distribuyen autom√°ticamente los metadatos conocidos, la fecha l√≠mite de solicitud incluso se transfiere fuera de la API.  Dentro del proceso, los plazos reciben una visualizaci√≥n nativa.  Por ejemplo, en Go, est√°n representados por el resultado de <i>context.Context</i> del m√©todo <i>WithDeadline</i> . <br><br>  De hecho, pudimos solucionar clases enteras de problemas de confiabilidad al obligar a los ingenieros a establecer plazos para definir los servicios apropiados. <br><br>  Este enfoque va m√°s all√° de RPC.  Por ejemplo, nuestro ORM MySQL serializa un contexto RPC junto con una fecha l√≠mite en un comentario de consulta SQL.  Nuestro proxy SQL puede analizar comentarios y "matar" consultas cuando se produce la fecha l√≠mite.  Y como beneficio adicional al depurar llamadas a la base de datos, tenemos un enlace de consulta SQL a una consulta RPC espec√≠fica. <br><br><h3>  Desconectar </h3><br>  Otro problema com√∫n que enfrentaron los clientes del sistema RPC anterior fue la implementaci√≥n del algoritmo de retardo exponencial individual y fluctuaciones a pedido repetido. <br><br>  Intentamos encontrar una soluci√≥n inteligente al problema de desconexi√≥n en Courier, comenzando con la implementaci√≥n del b√∫fer LIFO (√∫ltimo en entrar, primero en salir) entre el servicio y el grupo de tareas. <br><br><img src="https://habrastorage.org/webt/th/sr/t0/thsrt0kbgxgnexrr9figp9ymg_a.png"><br><br>  En caso de sobrecarga, LIFO se desconectar√° autom√°ticamente.  La cola, que es importante, est√° limitada no solo por el tama√±o, sino tambi√©n <b>por el tiempo</b> (la solicitud puede pasar en la cola solo un cierto tiempo). <br><br>  <i>Menos LIFO: cambio del orden de procesamiento de solicitudes.</i>  <i>Si desea conservar el pedido original, use <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CoDel</a> .</i>  <i>Tambi√©n existe la posibilidad de desconectarse, y el orden de procesamiento de las solicitudes seguir√° siendo el mismo.</i> <br><br><img src="https://habrastorage.org/webt/7g/w_/ud/7gw_udkbrsesseak2xrxaucw7fi.png"><br><br><h2>  Introspecci√≥n: puntos finales de depuraci√≥n </h2><br>  Aunque los puntos finales de depuraci√≥n no son directamente parte de Courier, se usan ampliamente en Dropbox y son demasiado √∫tiles para no mencionarlos. <br><br>  <i>Por razones de seguridad, puede abrirlos en un puerto separado o en un socket Unix (para controlar el acceso mediante permisos de archivo).</i>  <i>Tambi√©n debe considerar la autenticaci√≥n mutua de TLS, con la cual los desarrolladores tendr√°n que proporcionar sus certificados para acceder a los puntos finales (principalmente no solo de lectura).</i> <br><br><h3>  Ejecuci√≥n </h3><br>  La capacidad de analizar el estado de un servicio durante su funcionamiento es muy √∫til para la depuraci√≥n.  Por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://golang.org/pkg/net/">se puede acceder a los perfiles de memoria din√°mica y CPU a trav√©s de puntos finales HTTP o gRPC</a> . <br><br>  <i>Planeamos aprovechar esta oportunidad en el procedimiento de verificaci√≥n canaria, para automatizar la b√∫squeda de la diferencia entre las versiones antigua y nueva del c√≥digo.</i> <br><br>  Los puntos finales permiten modificar el estado de un servicio en tiempo de ejecuci√≥n.  En particular, los servicios basados ‚Äã‚Äãen Golang pueden configurar din√°micamente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GCPercent</a> . <br><br><h3>  La biblioteca </h3><br>  La exportaci√≥n autom√°tica de datos espec√≠ficos de la biblioteca como punto final RPC puede ser √∫til para los desarrolladores de la biblioteca.  Por ejemplo, la biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">malloc puede volcar estad√≠sticas internas en un volcado</a> .  Otro ejemplo: un punto final de depuraci√≥n puede cambiar el nivel de registro de servicio sobre la marcha. <br><br><h3>  Rpc </h3><br>  Por supuesto, la soluci√≥n de problemas en protocolos cifrados y codificados no es f√°cil.  Por lo tanto, introducir tantas herramientas como sea posible a nivel RPC es una buena idea.  Un ejemplo de una API tan introspectiva <a href="">es la soluci√≥n Channelz</a> . <br><br><h3>  Nivel de aplicaci√≥n </h3><br>  Ser capaz de aprender las opciones de nivel de aplicaci√≥n tambi√©n puede ser √∫til.  Un buen ejemplo es un punto final con informaci√≥n general sobre la aplicaci√≥n (con un hash de archivos fuente o de ensamblaje, una l√≠nea de comando, etc.).  Puede ser utilizado por un sistema de orquestaci√≥n para verificar la integridad al implementar un servicio. <br><br><h1>  Optimizaci√≥n del rendimiento </h1><br>  Al expandir nuestro marco gRPC a la escala requerida, encontramos varios cuellos de botella espec√≠ficos para Dropbox. <br><br><h3>  Consumo de recursos de TLS Handshakes </h3><br>  En los servicios que sirven a muchas relaciones, como resultado de los apretones de manos TLS, la carga combinada de la CPU puede ser bastante grave (especialmente al reiniciar un servicio popular). <br><br>  Para mejorar el rendimiento al firmar, reemplazamos los pares de claves RSA-2048 con el ECDSA P-256.  Aqu√≠ hay ejemplos de su rendimiento (nota: con RSA, la verificaci√≥n de firma es m√°s r√°pida). <br><br>  <b>RSA:</b> <br><br><pre> <code class="plaintext hljs">~/c0d3/boringssl bazel run -- //:bssl speed -filter 'RSA 2048' Did ... RSA 2048 signing operations in ..............  (1527.9 ops/sec) Did ... RSA 2048 verify (same key) operations in .... (37066.4 ops/sec) Did ... RSA 2048 verify (fresh key) operations in ... (25887.6 ops/sec)</code> </pre> <br>  <b>ECDSA:</b> <br><br><pre> <code class="plaintext hljs">~/c0d3/boringssl bazel run -- //:bssl speed -filter 'ECDSA P-256' Did ... ECDSA P-256 signing operations in ... (40410.9 ops/sec) Did ... ECDSA P-256 verify operations in .... (17037.5 ops/sec)</code> </pre><br>  Dado que la verificaci√≥n con RSA-2048 es aproximadamente tres veces m√°s r√°pida que con ECDSA P-256, puede elegir RSA para certificados ra√≠z y finales para aumentar la velocidad de operaci√≥n.  Pero desde el punto de vista de la seguridad, no todo es tan simple: construir√° cadenas de varias primitivas criptogr√°ficas y, por lo tanto, el nivel de los par√°metros de seguridad resultantes ser√° el m√°s bajo.  Y si desea mejorar el rendimiento, no recomendamos utilizar certificados de la versi√≥n RSA-4096 (y superior) como certificados ra√≠z y finales. <br><br>  Tambi√©n descubrimos que elegir una biblioteca TLS (y marcas de compilaci√≥n) tiene un impacto significativo tanto en el rendimiento como en la seguridad.  Compare, por ejemplo, la compilaci√≥n LibreSSL en macOS X Mojave con el OpenSSL autoescrito en el mismo hardware. <br><br>  <b>LibreSSL 2.6.4:</b> <br><br><pre> <code class="plaintext hljs">~ openssl speed rsa2048 LibreSSL 2.6.4 ...                 sign verify sign/s verify/s rsa 2048 bits 0.032491s 0.001505s     30.8 664.3</code> </pre> <br>  <b>OpenSSL 1.1.1a:</b> <br><br><pre> <code class="plaintext hljs"> ~ openssl speed rsa2048 OpenSSL 1.1.1a  20 Nov 2018 ...                 sign verify sign/s verify/s rsa 2048 bits 0.000992s 0.000029s   1208.0 34454.8</code> </pre> <br>  Sin embargo, la forma m√°s r√°pida de crear un apret√≥n de manos TLS es no crearlo en absoluto.  Hemos incluido soporte para la reanudaci√≥n de la sesi√≥n en gRPC-core y gRPC-python, reduciendo as√≠ la carga en la CPU durante la implementaci√≥n. <br><br><h3>  El cifrado es econ√≥mico </h3><br>  Muchos creen err√≥neamente que el cifrado es costoso.  De hecho, incluso las computadoras modernas m√°s simples realizan un cifrado sim√©trico casi al instante.  Un procesador est√°ndar puede cifrar y autenticar datos a una velocidad de 40 Gb / s por n√∫cleo: <br><br><pre> <code class="plaintext hljs">~/c0d3/boringssl bazel run -- //:bssl speed -filter 'AES' Did ... AES-128-GCM (8192 bytes) seal operations in ... 4534.4 MB/s</code> </pre> <br>  Sin embargo, a√∫n ten√≠amos que configurar gRPC para nuestros bloques de memoria, operando a una velocidad de 50 Gb / s.  Descubrimos que si la velocidad de cifrado es aproximadamente igual a la velocidad de copia, entonces es importante minimizar el n√∫mero de operaciones de <i>memoria.</i>  Adem√°s, realizamos algunos cambios en el propio gRPC. <br><br>  <i>Los protocolos autenticados y encriptados evitaron muchos problemas desagradables (por ejemplo, corrupci√≥n de datos por el procesador, DMA o en la red).</i>  <i>Incluso si no usa gRPC, le recomendamos usar TLS para contactos internos.</i> <br><br><h2>  Canales de datos de alta latencia (BDP) </h2><br>  Nota del traductor: el subt√≠tulo original usaba el t√©rmino <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">producto de retraso de ancho de banda</a> , que no tiene una traducci√≥n establecida al ruso. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La red troncal de Dropbox incluye muchos centros de datos</a> .  A veces, los nodos ubicados en diferentes regiones tienen que comunicarse a trav√©s de RPC, por ejemplo, para la replicaci√≥n.  Cuando se usa TCP, el n√∫cleo del sistema es responsable de limitar la cantidad de datos transmitidos en una conexi√≥n particular (dentro de / <i>proc / sys / net / ipv4 / tcp_ {r, w} mem</i> ), aunque gRPC basado en HTTP / 2 tiene su propia herramienta control de flujo  El l√≠mite superior de BDP <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en grpc-go est√° estrictamente limitado a 16 MB</a> , lo que puede provocar un cuello de botella. <br><br><h2>  net.Server Golang o grpc.Server </h2><br>  Inicialmente, en nuestro c√≥digo Go, admit√≠amos HTTP / 1.1 y gRPC con un √∫nico <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://golang.org/pkg/net/">servidor de red</a> .  La soluci√≥n ten√≠a sentido en t√©rminos de mantenimiento del c√≥digo del programa, pero no funcion√≥ a la perfecci√≥n.  La distribuci√≥n de HTTP / 1.1 y gRPC a trav√©s de servidores y la migraci√≥n de gRPC a grpc. El servidor mejor√≥ significativamente el ancho de banda de Courier y el uso de memoria. <br><br><h2>  golang / protobuf o gogo / protobuf </h2><br>  Cambiar a gRPC puede aumentar el costo de la clasificaci√≥n y la desorganizaci√≥n.  Para el c√≥digo Go, pudimos reducir significativamente la carga de la CPU en los servidores Courier al cambiar a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">gogo / protobuf</a> . <br><br>  <i>Como siempre, la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">transici√≥n a gogo / protobuf estuvo acompa√±ada de algunas preocupaciones</a> , pero si limita razonablemente la funcionalidad, no deber√≠a haber problemas.</i> <br><br><h1>  Detalles de implementaci√≥n </h1><br>  En esta secci√≥n, penetraremos m√°s profundamente en el dispositivo Courier, consideraremos los esquemas de protobuf y ejemplos de trozos de varios idiomas.  Todos los ejemplos se toman del servicio de prueba, que utilizamos durante las pruebas de integraci√≥n de Courier. <br><br><h2>  Descripci√≥n del servicio </h2><br>  Eche un vistazo a un extracto de la definici√≥n del servicio de prueba: <br><br><pre> <code class="plaintext hljs">service Test {   option (rpc_core.service_default_deadline_ms) = 1000;   rpc UnaryUnary(TestRequest) returns (TestResponse) {       option (rpc_core.method_default_deadline_ms) = 5000;   }   rpc UnaryStream(TestRequest) returns (stream TestResponse) {       option (rpc_core.method_no_deadline) = true;   }   ... }</code> </pre> <br>  Como se indic√≥ anteriormente, se requiere una fecha l√≠mite para todos los m√©todos de mensajer√≠a.  Con la siguiente opci√≥n, puede establecer la fecha l√≠mite para todo el servicio: <br><br><pre> <code class="plaintext hljs">option (rpc_core.service_default_deadline_ms) = 1000;</code> </pre> <br>  Al mismo tiempo, cada m√©todo se puede establecer en su propia fecha l√≠mite, cancelando la fecha l√≠mite de todo el servicio (si corresponde): <br><br><pre> <code class="plaintext hljs">option (rpc_core.method_default_deadline_ms) = 5000;</code> </pre> <br>  En casos raros cuando la fecha l√≠mite no tiene sentido (por ejemplo, al rastrear un recurso), el desarrollador puede deshabilitarlo: <br><br><pre> <code class="plaintext hljs">option (rpc_core.method_no_deadline) = true;</code> </pre> <br>  Adem√°s de esto, la descripci√≥n del servicio debe contener documentaci√≥n API detallada, posiblemente con ejemplos de uso. <br><br><h2>  Generaci√≥n de trozos </h2><br>  Para proporcionar una mayor flexibilidad, Courier genera sus propios ap√©ndices sin depender de la funcionalidad del interceptor proporcionada por gRPC (con la excepci√≥n de Java, en el que la API del interceptor tiene suficiente potencia).  Comparemos nuestros talones con los talones est√°ndar de Golang. <br><br>  As√≠ es como se ven los trozos de servidor gRPC predeterminados: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test_UnaryUnary_Handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(srv </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, ctx context.Context, dec </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interceptor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">grpc</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnaryServerInterceptor</span></span></span><span class="hljs-function">) </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> {       in := <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(TestRequest)       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := dec(in); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> {               <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err       }       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> interceptor == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> {               <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> srv.(TestServer).UnaryUnary(ctx, in)       }       info := &amp;grpc.UnaryServerInfo{               Server: srv,               FullMethod: <span class="hljs-string"><span class="hljs-string">"/test.Test/UnaryUnary"</span></span>,       }       handler := <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, req </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> {               <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> srv.(TestServer).UnaryUnary(ctx, req.(*TestRequest))       }       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> interceptor(ctx, in, info, handler) }</code> </pre> <br>  Todo el procesamiento se lleva a cabo en el interior: decodificaci√≥n de protobuf, lanzamiento de interceptores (ver la variable <code>interceptor</code> en el c√≥digo), lanzamiento del controlador UnaryUnary. <br><br>  Ahora eche un vistazo a los trozos de Courier: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test_UnaryUnary_dbxHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(       srv </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{},       ctx context.Context,       dec </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-function">,       </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interceptor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">grpc</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnaryServerInterceptor</span></span></span><span class="hljs-function">) </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(       </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{},       error)</span></span></span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> processor.PanicHandler()       impl := srv.(*dbxTestServerImpl)       metadata := impl.testUnaryUnaryMetadata       ctx = metadata.SetupContext(ctx)       clientId = client_info.ClientId(ctx)       stats := metadata.StatsMap.GetOrCreatePerClientStats(clientId)       stats.TotalCount.Inc()       req := &amp;processor.UnaryUnaryRequest{               Srv: srv,               Ctx: ctx,               Dec: dec,               Interceptor: interceptor,               RpcStats: stats,               Metadata: metadata,               FullMethodPath: <span class="hljs-string"><span class="hljs-string">"/test.Test/UnaryUnary"</span></span>,               Req: &amp;test.TestRequest{},               Handler: impl._UnaryUnary_internalHandler,               ClientId: clientId,               EnqueueTime: time.Now(),       }       metadata.WorkPool.Process(req).Wait()       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> req.Resp, req.Err }</code> </pre> <br>  Aqu√≠ hay bastante c√≥digo, as√≠ que analic√©moslo. <br><br>  Primero, aplazamos la llamada al controlador de p√°nico, que es responsable de recopilar los errores autom√°ticamente.  Esto nos permitir√° recopilar todas las excepciones no detectadas en el repositorio central para su posterior agregaci√≥n e informes: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> processor.PanicHandler()</code> </pre><br>  Otra raz√≥n por la que ejecutamos nuestro propio controlador de p√°nico es para asegurarnos de que la aplicaci√≥n se bloquea si se produce un error.  El controlador HTTP est√°ndar de golang / net en este caso ignorar√° el problema y continuar√° atendiendo nuevas solicitudes (incluso da√±adas e inconsistentes). <br><br>  Luego pasamos el contexto, redefiniendo los valores basados ‚Äã‚Äãen los metadatos de la solicitud entrante: <br><br><pre> <code class="go hljs">ctx = metadata.SetupContext(ctx) clientId = client_info.ClientId(ctx)</code> </pre> <br>  Tambi√©n creamos (y cach√© para mayor eficiencia) estad√≠sticas del cliente del lado del servidor para una agregaci√≥n m√°s detallada: <br><br><pre> <code class="go hljs">stats := metadata.StatsMap.GetOrCreatePerClientStats(clientId)</code> </pre><br>  Esta l√≠nea crea estad√≠sticas para cada cliente (es decir, un identificador TLS) durante la ejecuci√≥n.  Tambi√©n tenemos estad√≠sticas sobre todos los m√©todos para cada servicio.  Dado que el generador de c√≥digo auxiliar tiene acceso a todos los m√©todos durante la generaci√≥n de c√≥digo, podemos crearlos de forma est√°tica de antemano, evitando as√≠ retrasar el programa. <br><br>  Despu√©s de eso, creamos una estructura de solicitud, la transferimos al grupo de tareas y esperamos la ejecuci√≥n: <br><br><pre> <code class="go hljs">req := &amp;processor.UnaryUnaryRequest{       Srv:        srv,       Ctx:        ctx,       Dec:        dec,       Interceptor:    interceptor,       RpcStats:       stats,       Metadata:       metadata,       ... } metadata.WorkPool.Process(req).Wait()</code> </pre> <br>  Tenga en cuenta que en este punto no decodificamos protobuf, ni lanzamos el interceptor.  Antes de esto, el grupo de acceso, la priorizaci√≥n y la limitaci√≥n del n√∫mero de solicitudes ejecutadas deben pasar por el grupo de tareas. <br><br>  <i>Tenga en cuenta que la biblioteca gRPC admite la interfaz TAP, que le permite interceptar solicitudes a una velocidad tremenda.</i>  <i>La interfaz proporciona la infraestructura para construir limitadores de velocidad efectivos con un consumo m√≠nimo de recursos.</i> <br><br><h2>  C√≥digos de error espec√≠ficos para diferentes aplicaciones. </h2><br>  Nuestro generador de c√≥digo auxiliar tambi√©n permite a los desarrolladores asignar c√≥digos de error espec√≠ficos de la aplicaci√≥n utilizando opciones especiales: <br><br><pre> <code class="plaintext hljs">enum ErrorCode { option (rpc_core.rpc_error) = true; UNKNOWN = 0; NOT_FOUND = 1 [(rpc_core.grpc_code)="NOT_FOUND"]; ALREADY_EXISTS = 2 [(rpc_core.grpc_code)="ALREADY_EXISTS"]; ... STALE_READ = 7 [(rpc_core.grpc_code)="UNAVAILABLE"]; SHUTTING_DOWN = 8 [(rpc_core.grpc_code)="CANCELLED"]; }</code> </pre> <br>  Tanto los errores de gRPC como de aplicaci√≥n se propagan dentro del servicio, y en el borde de la API, todos los errores son reemplazados por DESCONOCIDO.  Gracias a esto, podemos evitar transferir el problema a otros servicios, lo que puede provocar un cambio en su sem√°ntica. <br><br><h2>  Cambios de Python </h2><br>  Los stubs de Python agregan un par√°metro de contexto expl√≠cito a todos los manejadores de Courier: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dropbox.context <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Context <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dropbox.proto.test.service_pb2 <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> (       TestRequest,       TestResponse, ) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> typing_extensions <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Protocol <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestCourierClient</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Protocol)</span></span></span><span class="hljs-class">:</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnaryUnary</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(           self,           ctx, # type: Context           request, # type: TestRequest           )</span></span></span><span class="hljs-function">:</span></span>       <span class="hljs-comment"><span class="hljs-comment"># type: (...) -&gt; TestResponse       ...</span></span></code> </pre> <br>  Al principio parec√≠a extra√±o, pero con el tiempo, los desarrolladores se acostumbraron a <i>ctx</i> expl√≠cito como sol√≠an hacerlo. <br><br>  Tenga en cuenta que nuestros talones est√°n completamente escritos para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mypy</a> , que se compensa durante la refactorizaci√≥n principal.  Adem√°s, la integraci√≥n con algunos IDEs (por ejemplo, PyCharm) se simplifica. <br><br>  Continuando con la tendencia de la escritura est√°tica, agregamos anotaciones mypy a los protocolos mismos: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestMessage</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Message)</span></span></span><span class="hljs-class">:</span></span>   field: int   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self,       field : Optional[int] = ...,       )</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> ...   @staticmethod   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FromString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s: bytes)</span></span></span><span class="hljs-function"> -&gt; TestMessage:</span></span> ...</code> </pre> <br>  Estas anotaciones evitar√°n muchos errores comunes, como asignar un valor de <i>Ninguno a un</i> campo de tipo <i>cadena</i> , por ejemplo <i>.</i> <br><br>  Este c√≥digo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">est√° disponible aqu√≠</a> . <br><br><h1>  Proceso de migracion </h1><br>  Crear una nueva pila RPC no es una tarea f√°cil, pero ni siquiera se encuentra al lado del proceso de una transici√≥n completa, si se mira desde el punto de vista de la complejidad operativa.  Por lo tanto, tratamos de hacer que sea lo m√°s f√°cil posible para los desarrolladores cambiar del antiguo RPC a Courier.  Dado que la migraci√≥n suele ir acompa√±ada de errores, decidimos implementarla por etapas. <br><br><h2>  Paso 0: congela el antiguo RPC </h2><br>  En primer lugar, congelamos el antiguo RPC para no disparar a un objetivo en movimiento.  Tambi√©n incit√≥ a las personas a cambiar a Courier, porque todas las nuevas funciones, como el rastreo, solo estaban disponibles en los servicios de Courier. <br><br><h2>  Paso 1: interfaz com√∫n para viejos RPC y Courier </h2><br>  Comenzamos definiendo una interfaz com√∫n para el antiguo RPC y Courier.  Se supon√≠a que nuestra generaci√≥n de c√≥digo asegurar√≠a que ambas versiones de los ap√©ndices correspondieran a esta interfaz: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TestServer <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> {  UnaryUnary(     ctx context.Context,     req *test.TestRequest) (     *test.TestResponse,     error)  ... }</code> </pre><br><h2>  Paso 2: migra a la nueva interfaz </h2><br>  Despu√©s de eso, comenzamos a cambiar cada servicio a una nueva interfaz, mientras continuamos usando el antiguo RPC.  A menudo, los cambios en el c√≥digo fueron una gran diferencia, afectando a todos los m√©todos del servicio y sus clientes.  Como esta etapa es la m√°s problem√°tica, quer√≠amos eliminar completamente el riesgo cambiando solo una cosa a la vez. <br><br>  <i>Los servicios simples con una peque√±a cantidad de m√©todos y el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">derecho a cometer errores</a> se pueden migrar simult√°neamente, sin prestar atenci√≥n a nuestras advertencias.</i> <br><br><h2>  Paso 3: migrar clientes al RPC Courier </h2><br>  Durante el proceso de migraci√≥n, comenzamos a lanzar simult√°neamente servidores antiguos y nuevos en diferentes puertos de la misma m√°quina.  El cambio de la implementaci√≥n RPC del lado del cliente se realiz√≥ cambiando una l√≠nea: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClient</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> -   self.client = LegacyRPCClient(<span class="hljs-string"><span class="hljs-string">'myservice'</span></span>) +   self.client = CourierRPCClient(<span class="hljs-string"><span class="hljs-string">'myservice'</span></span>)</code> </pre> <br>  Tenga en cuenta que con este modelo, puede transferir un cliente a la vez, comenzando con aquellos con un nivel m√°s bajo de SLA. <br><br><h2>  Paso 4: limpieza </h2><br>       ,   ,   RPC    (               ).       ‚Äî   . <br><br><h1>  Conclusiones </h1><br> , Courier ‚Äî  RPC-,   ,      Dropbox. <br><br>     ,    Courier: <br><br><ol><li>  ‚Äî  .           . <br></li><li>      ‚Äî    ,     . <br></li><li>     ,  .     Codegen. <br></li><li>    . ,    ,   .  , :       . <br></li><li>  RPC-       ‚Äî  ,     . .           . <br></li></ol><br><h1>   </h1><br> Courier,   gRPC  ,    ,      ,      . <br><br>         gRPC  Python   ,     C++  Python  Rust          .         ALTS   TLS-    (,     ). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/438474/">https://habr.com/ru/post/438474/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../438464/index.html">SciPy, algoritmos gr√°ficos</a></li>
<li><a href="../438466/index.html">Muleta para un l√°ser chino</a></li>
<li><a href="../438468/index.html">Colonia Cap√≠tulo 23: Prueba de manejo</a></li>
<li><a href="../438470/index.html">Ventas mundiales en diciembre y 2018: 2 millones de veh√≠culos el√©ctricos enchufables vendidos</a></li>
<li><a href="../438472/index.html">Sofisticado entorno arquitect√≥nico modular en UE4</a></li>
<li><a href="../438476/index.html">A la cuesti√≥n de los tampones (anillo)</a></li>
<li><a href="../438478/index.html">GitLab 11.7 lanzado con versiones, √©picas anidadas de varios niveles y el registro de paquetes NPM</a></li>
<li><a href="../438480/index.html">Col√≥quelo bien: 7 lugares ideales para colocar contenido de video</a></li>
<li><a href="../438482/index.html">Reputaci√≥n, trabajo y emigraci√≥n: c√≥mo utilizar las herramientas de promoci√≥n de la empresa para resolver problemas personales.</a></li>
<li><a href="../438486/index.html">Tarjeta de memoria impenetrable: ahogar, congelar y prender fuego a Kingston microSD High Endurance</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>