<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëâüèø ü•ï üè¢ Cr√©ez un shader d'eau de dessin anim√© pour le Web. 2e partie üôÅ üà≥ ‚úâÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans la premi√®re partie, nous avons √©tudi√© la mise en place de l'environnement et de la surface de l'eau. Dans cette partie, nous allons donner de la ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cr√©ez un shader d'eau de dessin anim√© pour le Web. 2e partie</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416983/"> Dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">premi√®re partie,</a> nous avons √©tudi√© la mise en place de l'environnement et de la surface de l'eau.  Dans cette partie, nous allons donner de la flottabilit√© aux objets, ajouter des lignes d'eau √† la surface et cr√©er des lignes de mousse avec un tampon de profondeur autour des limites des objets se croisant avec la surface. <br><br>  Pour rendre la sc√®ne un peu meilleure, j'y ai apport√© des modifications mineures.  Vous pouvez personnaliser votre sc√®ne comme vous le souhaitez, mais j'ai fait ce qui suit: <br><br><ul><li>  Ajout de mod√®les d'un phare et d'une pieuvre. </li><li> Ajout d'un mod√®le au sol avec la couleur <code>#FFA457</code> . </li><li>  Ajout d'une couleur de ciel <code>#6CC8FF</code> . </li><li>  Ajout de la couleur de r√©tro√©clairage <code>#FFC480</code> √† la sc√®ne (ces param√®tres peuvent √™tre trouv√©s dans les param√®tres de la sc√®ne). </li></ul><br>  Ma sc√®ne originale ressemble maintenant √† ceci. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bc2/2fa/0d5/bc22fa0d57b5120e75cced6f105bebd2.png"></div><a name="habracut"></a><br><h2>  Flottabilit√© </h2><br>  La fa√ßon la plus simple de cr√©er une flottabilit√© est d'utiliser un script pour pousser des objets vers le haut et vers le bas.  Cr√©ez un nouveau script <strong>Buoyancy.js</strong> et d√©finissez ce qui suit dans son initialisation: <br><br><pre> <code class="javascript hljs">Buoyancy.prototype.initialize = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.initialPosition = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.entity.getPosition().clone(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.initialRotation = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.entity.getEulerAngles().clone(); <span class="hljs-comment"><span class="hljs-comment">//     ,  //        //     this.time = Math.random() * 2 * Math.PI; };</span></span></code> </pre> <br>  Maintenant, dans la mise √† jour, nous ex√©cutons l'incr√©ment de temps et tournons l'objet: <br><br><pre> <code class="javascript hljs">Buoyancy.prototype.update = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dt</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.time += <span class="hljs-number"><span class="hljs-number">0.1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      var pos = this.entity.getPosition().clone(); pos.y = this.initialPosition.y + Math.cos(this.time) * 0.07; this.entity.setPosition(pos.x,pos.y,pos.z); //    var rot = this.entity.getEulerAngles().clone(); rot.x = this.initialRotation.x + Math.cos(this.time * 0.25) * 1; rot.z = this.initialRotation.z + Math.sin(this.time * 0.5) * 2; this.entity.setLocalEulerAngles(rot.x,rot.y,rot.z); };</span></span></code> </pre> <br>  Appliquez ce script au bateau et voyez comment il saute de haut en bas sur l'eau!  Vous pouvez appliquer ce script √† plusieurs objets (y compris la cam√©ra - essayez-le)! <br><br><h2>  Texture de surface </h2><br>  Alors que nous pouvons voir les vagues, nous regardons les bords de la surface de l'eau.  L'ajout de texture rendra le mouvement de surface plus visible.  De plus, c'est un moyen peu co√ªteux de simuler les r√©flexions et les caustiques. <br><br>  Vous pouvez essayer de trouver des textures caustiques ou en cr√©er une vous-m√™me.  J'ai dessin√© <a href="" rel="external">une texture</a> dans Gimp que vous pouvez utiliser librement.  Toute texture convient, √† condition qu'elle puisse √™tre carrel√©e sans joints perceptibles. <br><br>  Apr√®s avoir choisi la texture que vous aimez, faites-la glisser vers la fen√™tre Actifs de votre projet.  Nous devons r√©f√©rencer cette texture √† partir du script Water.js, alors cr√©ons-en un attribut: <br><br><pre> <code class="javascript hljs">Water.attributes.add(<span class="hljs-string"><span class="hljs-string">'surfaceTexture'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'asset'</span></span>, <span class="hljs-attr"><span class="hljs-attr">assetType</span></span>: <span class="hljs-string"><span class="hljs-string">'texture'</span></span>, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'Surface Texture'</span></span> });</code> </pre> <br>  Et puis affectez-le dans l'√©diteur: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/672/61e/32f/67261e32f145eda9dab99d1866181ced.png"></div><br>  Maintenant, nous devons le passer au shader.  Allez dans <strong>Water.js</strong> et d√©finissez la fonction <code>CreateWaterMaterial</code> nouveau param√®tre: <br><br><pre> <code class="javascript hljs">material.setParameter(<span class="hljs-string"><span class="hljs-string">'uSurfaceTexture'</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.surfaceTexture.resource);</code> </pre> <br>  Revenez maintenant sur <strong>Water.frag</strong> et d√©clarez un nouvel uniforme: <br><br><pre> <code class="javascript hljs">uniform sampler2D uSurfaceTexture;</code> </pre> <br>  Nous avons presque fini.  Pour rendre une texture sur un plan, nous devons savoir o√π se trouve chaque pixel dans le maillage.  Autrement dit, nous devons transf√©rer les donn√©es du vertex shader vers le fragment one. <br><br><h3>  Variables variables </h3><br>  <em>Des</em> variables variables vous permettent de transf√©rer des donn√©es du vertex shader vers le fragment one.  Il s'agit du troisi√®me type de variables sp√©ciales pouvant √™tre utilis√©es dans le shader (les deux premi√®res sont <em>uniformes</em> et <em>attributaires</em> ).  Une variable est d√©finie pour chaque sommet et chaque pixel peut y acc√©der.  Puisqu'il y a beaucoup plus de pixels que de sommets, la valeur est interpol√©e entre les sommets (d'o√π le nom ¬´variant¬ª - il s'√©carte des valeurs qui lui sont transmises). <br><br>  Pour le tester en fonctionnement, d√©clarez une nouvelle variable dans <strong>Water.vert</strong> comme variant: <br><br><pre> <code class="javascript hljs">varying vec2 ScreenPosition;</code> </pre> <br>  Et puis affectez-lui la valeur <code>gl_Position</code> apr√®s le calcul: <br><br><pre> <code class="javascript hljs">ScreenPosition = gl_Position.xyz;</code> </pre> <br>  Revenons maintenant √† <strong>Water.frag</strong> et d√©clarez la m√™me variable.  Nous ne pouvons pas obtenir la sortie des donn√©es de d√©bogage √† partir du shader, mais nous pouvons utiliser la couleur pour le d√©bogage visuel.  Voici comment proc√©der: <br><br><pre> <code class="javascript hljs">uniform sampler2D uSurfaceTexture; varying vec3 ScreenPosition; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    varying- color = vec4(vec3(ScreenPosition.x),1.0); gl_FragColor = color; }</span></span></code> </pre> <br>  L'avion doit maintenant √™tre noir et blanc et la ligne de s√©paration des couleurs ira l√† o√π <code>ScreenPosition.x</code> = 0. Les valeurs de couleur ne changent que de 0 √† 1, mais les valeurs de <code>ScreenPosition</code> peuvent √™tre en dehors de cet intervalle.  Ils sont automatiquement limit√©s, par cons√©quent, lorsque vous voyez du noir, il peut √™tre 0 ou un nombre n√©gatif. <br><br>  Ce que nous venons de faire, c'est de passer la position d'√©cran de chaque sommet √† chaque pixel.  Vous pouvez voir que la ligne s√©parant les c√¥t√©s noir et blanc passera toujours au centre de l'√©cran, quelle que soit la surface r√©elle du monde. <br><br><blockquote>  <em>T√¢che 1: cr√©ez une nouvelle variable variable pour transf√©rer la position dans le monde au lieu de la position de l'√©cran.</em>  <em>Visualisez-le de la m√™me mani√®re.</em>  <em>Si la couleur ne change pas avec le mouvement de la cam√©ra, alors tout est fait correctement.</em> </blockquote><br><h3>  Utilisation des UV </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external">UV</a> est les coordonn√©es 2D de chaque sommet du maillage, normalis√©es de 0 √† 1. Elles sont n√©cessaires pour un √©chantillonnage correct de la texture sur le plan, et nous les avons d√©j√† configur√©es dans la partie pr√©c√©dente. <br><br>  <strong>Nous allons</strong> d√©clarer un nouvel attribut dans <strong>Water.vert</strong> (ce nom est tir√© de la d√©finition d'un shader dans Water.js): <br><br><pre> <code class="javascript hljs">attribute vec2 aUv0;</code> </pre> <br>  Et maintenant, il nous suffit de le passer au fragment shader, il suffit donc de cr√©er des variations et de lui attribuer la valeur d'attribut: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  Water.vert //        varying vec2 vUv0; // .. //        //  varying,        vUv0 = aUv0;</span></span></code> </pre> <br>  Nous allons maintenant d√©clarer la m√™me variable variable dans le fragment shader.  Pour nous assurer que tout fonctionne, nous pouvons visualiser le d√©bogage comme avant, puis Water.frag ressemblera √† ceci: <br><br><pre> <code class="javascript hljs">uniform sampler2D uSurfaceTexture; varying vec2 vUv0; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  UV color = vec4(vec3(vUv0.x),1.0); gl_FragColor = color; }</span></span></code> </pre> <br>  Vous devriez voir un gradient confirmant que nous avons une valeur de 0 √† une extr√©mit√© et de 1 √† l'autre.  Maintenant, pour √©chantillonner la texture pour de vrai, tout ce que nous devons faire est de: <br><br><pre> <code class="javascript hljs">color = texture2D(uSurfaceTexture,vUv0);</code> </pre> <br>  Apr√®s cela, nous verrons la texture √† la surface: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f49/9bf/ae2/f499bfae266b0aa16709bbea0280df6f.png"></div><br><h3>  Style de texture </h3><br>  Au lieu de simplement d√©finir la texture comme nouvelle couleur, combinons-la avec le bleu existant: <br><br><pre> <code class="javascript hljs">uniform sampler2D uSurfaceTexture; varying vec2 vUv0; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); vec4 WaterLines = texture2D(uSurfaceTexture,vUv0); color.rgba += WaterLines.r; gl_FragColor = color; }</code> </pre> <br>  Cela fonctionne car la couleur de la texture est noire (0) partout sauf les lignes de flottaison.  En l'ajoutant, nous ne changeons pas la couleur bleue initiale, √† l'exception des endroits avec des lignes o√π elle devient plus claire. <br><br>  Cependant, ce n'est pas le seul moyen de combiner les couleurs. <br><br><blockquote>  <em>T√¢che 2: pouvez-vous combiner les couleurs pour obtenir l'effet le plus faible illustr√© ci-dessous?</em> </blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a3d/e18/22a/a3de1822a348656f47e5bd6cfa6cbed5.png"></div><br><h3>  Texture en mouvement </h3><br>  Comme dernier effet, nous voulons que les lignes se d√©placent le long de la surface et cela ne semble pas si statique.  Pour ce faire, nous profiterons du fait que toute valeur en dehors de l'intervalle de 0 √† 1 pass√©e √† la fonction <code>texture2D</code> sera transf√©r√©e (par exemple, 1,5 et 2,5 deviennent √©gaux √† 0,5).  Par cons√©quent, nous pouvons augmenter notre position par la variable de temps uniforme que nous avons d√©j√† d√©finie pour augmenter ou diminuer la densit√© des lignes √† la surface, ce qui donnera au fragment final un shader de cette forme: <br><br><pre> <code class="javascript hljs">uniform sampler2D uSurfaceTexture; uniform float uTime; varying vec2 vUv0; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); vec2 pos = vUv0; <span class="hljs-comment"><span class="hljs-comment">//      1 //     pos *= 2.0; //   ,      pos.y += uTime * 0.02; vec4 WaterLines = texture2D(uSurfaceTexture,pos); color.rgba += WaterLines.r; gl_FragColor = color; }</span></span></code> </pre> <br><h2>  Lignes de mousse et tampon de profondeur </h2><br>  Le rendu des lignes de mousse autour des objets dans l'eau permet de voir plus facilement √† quel point les objets sont immerg√©s et o√π ils traversent la surface.  De plus, de cette fa√ßon, notre eau devient beaucoup plus cr√©dible.  Pour r√©aliser les lignes de mousse, nous devons en quelque sorte savoir o√π se trouvent les limites de chaque objet et le faire efficacement. <br><br><h3>  Trick </h3><br>  Nous devons apprendre √† d√©terminer si un pixel √† la surface de l'eau est proche de l'objet.  Si c'est le cas, nous pouvons le peindre dans la couleur de la mousse.  Il n'existe aucun moyen simple de r√©soudre ce probl√®me (pour autant que je sache).  Par cons√©quent, pour le r√©soudre, j'utilise une technique utile pour r√©soudre des probl√®mes: je vais prendre un exemple dont nous connaissons la r√©ponse et voir si nous pouvons la g√©n√©raliser. <br><br>  Jetez un ≈ìil √† l'image ci-dessous. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d0/0e7/eec/4d00e7eec8714a365c110aea67df9fab.png"></div><br>  Quels pixels doivent faire partie de la mousse?  Nous savons que cela devrait ressembler √† ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a8/541/c4f/1a8541c4f8fdd65879966b909805c484.png"></div><br>  Examinons donc deux pixels sp√©cifiques.  Ci-dessous, je les ai marqu√©s avec des ast√©risques.  Le noir sera sur la mousse et le rouge non.  Comment les distinguons-nous dans un shader? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/012/d35/fb2/012d35fb25d42c19a86adaa081048237.png"></div><br>  On sait que m√™me si ces deux pixels de l'espace √©cran sont proches l'un de l'autre (les deux s'affichent au sommet du phare), en fait ils sont tr√®s √©loign√©s dans l'espace du monde.  Nous pouvons le v√©rifier en regardant la m√™me sc√®ne sous un angle diff√©rent. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cd3/5a0/31b/cd35a031bbd18805128ebd44ed1c1279.png"></div><br>  Notez que l'√©toile rouge n'est pas situ√©e sur le phare, comme il nous a sembl√©, mais la noire est en fait l√†.  On peut distinguer l'utilisation de la distance √† la cam√©ra, qui est g√©n√©ralement appel√©e "profondeur".  La profondeur 1 signifie que le point est tr√®s proche de la cam√©ra, la profondeur 0 signifie qu'il est tr√®s loin.  Mais ce n'est pas seulement une question de distances absolues dans le monde, de profondeur ou de cam√©ra.  La profondeur par <em>rapport au pixel derri√®re elle est</em> importante. <br><br>  Regardez √† nouveau la premi√®re vue.  Disons que la coque du phare a une valeur de profondeur de 0,5.  La profondeur de l'√©toile noire sera tr√®s proche de 0,5.  Autrement dit, elle et le pixel en dessous ont des valeurs de profondeur tr√®s proches.  En revanche, l'ast√©risque rouge aura une profondeur beaucoup plus grande, car il est plus proche de la cam√©ra, disons 0,7.  Et bien que le pixel derri√®re lui soit toujours sur le phare, il a une valeur de profondeur de 0,5, c'est-√†-dire qu'il y a plus de diff√©rence. <br><br>  Voil√† l'astuce.  <em>Lorsque la profondeur d'un pixel √† la surface de l'eau est suffisamment proche de la profondeur du pixel sur lequel il est dessin√©, nous sommes assez proches de la bordure d'un objet</em> et pouvons rendre le pixel comme de la mousse. <br><br>  Autrement dit, nous avons besoin de plus d'informations que nous en avons dans n'importe quel pixel.  Nous devons en quelque sorte trouver la profondeur du pixel sur lequel il doit √™tre trac√©.  Et ici, le buffer de profondeur nous est utile. <br><br><h3>  Tampon de profondeur </h3><br>  Vous pouvez consid√©rer un tampon d'image ou un tampon d'image comme un rendu ou une texture cible hors √©cran.  Lorsque nous devons lire des donn√©es, nous devons effectuer un rendu hors √©cran.  Cette technique est utilis√©e dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external">l'effet de fum√©e</a> . <br><br>  Le tampon de profondeur est un rendu cible sp√©cial qui contient des informations sur les valeurs de profondeur de chaque pixel.  N'oubliez pas que la valeur dans <code>gl_Position</code> , calcul√©e dans le vertex shader, √©tait la valeur de l'espace d'√©cran, mais elle a √©galement une troisi√®me coordonn√©e - la valeur Z. Cette valeur Z est utilis√©e pour calculer la profondeur, qui est √©crite dans le tampon de profondeur. <br><br>  Le tampon de profondeur est destin√© au rendu correct de la sc√®ne sans avoir besoin de trier les objets de l'arri√®re vers l'avant.  Chaque pixel √† dessiner v√©rifie d'abord le tampon de profondeur.  Si sa valeur de profondeur est sup√©rieure √† la valeur du tampon, elle est dessin√©e et sa propre valeur √©crase la valeur du tampon.  Sinon, il est jet√© (car cela signifie qu'il y a un autre objet devant lui). <br><br>  En fait, vous pouvez d√©sactiver l'√©criture dans le tampon de profondeur pour voir √† quoi tout ressemblerait sans lui.  Essayons de le faire dans Water.js: <br><br><pre> <code class="javascript hljs">material.depthTest = <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br>  Vous remarquerez que l'eau sera d√©sormais toujours tir√©e par le haut, m√™me si elle se trouve derri√®re des objets opaques. <br><br><h3>  Visualisation du tampon de profondeur </h3><br>  Ajoutons un moyen de rendre le tampon de profondeur √† des fins de d√©bogage.  Cr√©ez un nouveau script <strong>DepthVisualize.js</strong> .  Fixez-le √† la cam√©ra. <br><br>  Pour acc√©der au tampon de profondeur dans PlayCanvas, √©crivez simplement ce qui suit: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.entity.camera.camera.requestDepthMap();</code> </pre> <br>  Nous injectons donc automatiquement la variable uniforme dans tous nos shaders, que nous pouvons utiliser en la d√©clarant comme suit: <br><br><pre> <code class="javascript hljs">uniform sampler2D uDepthMap;</code> </pre> <br>  Vous trouverez ci-dessous un exemple de script demandant une carte de profondeur et la rendant au-dessus d'une sc√®ne.  Il a configur√© un red√©marrage √† chaud. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> DepthVisualize = pc.createScript(<span class="hljs-string"><span class="hljs-string">'depthVisualize'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  initialize,       DepthVisualize.prototype.initialize = function() { this.entity.camera.camera.requestDepthMap(); this.antiCacheCount = 0; //    ,         this.SetupDepthViz(); }; DepthVisualize.prototype.SetupDepthViz = function(){ var device = this.app.graphicsDevice; var chunks = pc.shaderChunks; this.fs = ''; this.fs += 'varying vec2 vUv0;'; this.fs += 'uniform sampler2D uDepthMap;'; this.fs += ''; this.fs += 'float unpackFloat(vec4 rgbaDepth) {'; this.fs += ' const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);'; this.fs += ' float depth = dot(rgbaDepth, bitShift);'; this.fs += ' return depth;'; this.fs += '}'; this.fs += ''; this.fs += 'void main(void) {'; this.fs += ' float depth = unpackFloat(texture2D(uDepthMap, vUv0)) * 30.0; '; this.fs += ' gl_FragColor = vec4(vec3(depth),1.0);'; this.fs += '}'; this.shader = chunks.createShaderFromCode(device, chunks.fullscreenQuadVS, this.fs, "renderDepth" + this.antiCacheCount); this.antiCacheCount ++; //     ,        this.command = new pc.Command(pc.LAYER_FX, pc.BLEND_NONE, function () { pc.drawQuadWithShader(device, null, this.shader); }.bind(this)); this.command.isDepthViz = true; //    ,      this.app.scene.drawCalls.push(this.command); }; //  update,     DepthVisualize.prototype.update = function(dt) { }; //  swap,      //      DepthVisualize.prototype.swap = function(old) { this.antiCacheCount = old.antiCacheCount; //      for(var i=0;i&lt;this.app.scene.drawCalls.length;i++){ if(this.app.scene.drawCalls[i].isDepthViz){ this.app.scene.drawCalls.splice(i,1); break; } } //    this.SetupDepthViz(); }; //      ,  : // http://developer.playcanvas.com/en/user-manual/scripting/</span></span></code> </pre> <br>  Essayez de copier le code et de commenter / d√©commenter la ligne <code>this.app.scene.drawCalls.push(this.command);</code>  pour activer / d√©sactiver le rendu en profondeur.  Cela devrait ressembler √† l'image ci-dessous. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c09/93a/c4f/c0993ac4f8ed7a4c739658bbff69e455.png"></div><br><blockquote>  <em>T√¢che 3: la surface de l'eau n'est pas attir√©e dans le tampon de profondeur.</em>  <em>Le moteur PlayCanvas le fait expr√®s.</em>  <em>Pouvez-vous comprendre pourquoi?</em>  <em>Quelle est la particularit√© du mat√©riau de l'eau?</em>  <em>En d'autres termes, compte tenu de nos r√®gles de v√©rification des profondeurs, que se passerait-il si des pixels d'eau √©taient √©crits dans le tampon de profondeur?</em> </blockquote><br>  <em>Astuce: vous pouvez modifier une ligne dans Water.js, ce qui vous permet d'√©crire de l'eau dans le tampon de profondeur.</em> <br><br>  Il convient √©galement de noter que dans la fonction d'initialisation, je multiplie la valeur de profondeur par 30. Cela est n√©cessaire pour le voir clairement, car sinon la plage de valeurs serait trop petite pour afficher les tons de couleur. <br><br><h3>  Mise en ≈ìuvre astuce </h3><br>  Il existe plusieurs fonctions auxiliaires dans le moteur PlayCanvas pour travailler avec des valeurs de profondeur, mais au moment de la r√©daction, elles n'√©taient pas publi√©es en production, nous devrons donc les configurer nous-m√™mes. <br><br>  Nous <strong>d√©finissons les</strong> variables uniformes suivantes dans <strong>Water.frag</strong> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   uniform-    PlayCanvas uniform sampler2D uDepthMap; uniform vec4 uScreenSize; uniform mat4 matrix_view; //      uniform vec4 camera_params;</span></span></code> </pre> <br>  Nous d√©finissons ces fonctions auxiliaires sur la fonction principale: <br><br><pre> <code class="javascript hljs">#ifdef GL2 float linearizeDepth(float z) { z = z * <span class="hljs-number"><span class="hljs-number">2.0</span></span> - <span class="hljs-number"><span class="hljs-number">1.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1.0</span></span> / (camera_params.z * z + camera_params.w); } #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> #ifndef UNPACKFLOAT #define UNPACKFLOAT float unpackFloat(vec4 rgbaDepth) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> vec4 bitShift = vec4(<span class="hljs-number"><span class="hljs-number">1.0</span></span> / (<span class="hljs-number"><span class="hljs-number">256.0</span></span> * <span class="hljs-number"><span class="hljs-number">256.0</span></span> * <span class="hljs-number"><span class="hljs-number">256.0</span></span>), <span class="hljs-number"><span class="hljs-number">1.0</span></span> / (<span class="hljs-number"><span class="hljs-number">256.0</span></span> * <span class="hljs-number"><span class="hljs-number">256.0</span></span>), <span class="hljs-number"><span class="hljs-number">1.0</span></span> / <span class="hljs-number"><span class="hljs-number">256.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dot(rgbaDepth, bitShift); } #endif #endif float getLinearScreenDepth(vec2 uv) { #ifdef GL2 <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> linearizeDepth(texture2D(uDepthMap, uv).r) * camera_params.y; #<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> unpackFloat(texture2D(uDepthMap, uv)) * camera_params.y; #endif } float getLinearDepth(vec3 pos) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -(matrix_view * vec4(pos, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)).z; } float getLinearScreenDepth() { vec2 uv = gl_FragCoord.xy * uScreenSize.zw; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getLinearScreenDepth(uv); }</code> </pre> <br>  Nous passerons les informations de shader sur la cam√©ra dans <strong>Water.js</strong> .  Collez ceci √† l'endroit o√π vous passez les autres variables uniformes comme uTime: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.camera){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.camera = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.app.root.findByName(<span class="hljs-string"><span class="hljs-string">"Camera"</span></span>).camera; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> camera = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.camera; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n = camera.nearClip; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> f = camera.farClip; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> camera_params = [ <span class="hljs-number"><span class="hljs-number">1</span></span>/f, f, (<span class="hljs-number"><span class="hljs-number">1</span></span>-f / n) / <span class="hljs-number"><span class="hljs-number">2</span></span>, (<span class="hljs-number"><span class="hljs-number">1</span></span> + f / n) / <span class="hljs-number"><span class="hljs-number">2</span></span> ]; material.setParameter(<span class="hljs-string"><span class="hljs-string">'camera_params'</span></span>, camera_params);</code> </pre> <br>  Enfin, nous avons besoin d'une position dans le monde de chaque pixel pour notre fragment shader.  Nous devons l'obtenir du vertex shader.  Par cons√©quent, nous d√©finirons une variable variable dans <strong>Water.frag</strong> : <br><br><pre> <code class="javascript hljs">varying vec3 WorldPosition;</code> </pre> <br>  D√©finissez la m√™me variable variable dans <strong>Water.vert</strong> .  Ensuite, nous lui attribuons une position d√©form√©e par rapport au vertex shader afin que le code complet ressemble √† ceci: <br><br><pre> <code class="javascript hljs">attribute vec3 aPosition; attribute vec2 aUv0; varying vec2 vUv0; varying vec3 WorldPosition; uniform mat4 matrix_model; uniform mat4 matrix_viewProjection; uniform float uTime; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vUv0 = aUv0; vec3 pos = aPosition; pos.y += cos(pos.z*<span class="hljs-number"><span class="hljs-number">5.0</span></span>+uTime) * <span class="hljs-number"><span class="hljs-number">0.1</span></span> * sin(pos.x * <span class="hljs-number"><span class="hljs-number">5.0</span></span> + uTime); gl_Position = matrix_viewProjection * matrix_model * vec4(pos, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); WorldPosition = pos; }</code> </pre> <br><h3>  Nous r√©alisons l'astuce pour de vrai </h3><br>  Nous sommes maintenant enfin pr√™ts √† mettre en ≈ìuvre la technique d√©crite au d√©but de cette section.  Nous voulons comparer la profondeur du pixel dans lequel nous nous trouvons avec la profondeur du pixel en dessous.  Le pixel dans lequel nous nous trouvons provient d'une position dans le monde et le pixel en dessous est obtenu √† partir de la position de l'√©cran.  Par cons√©quent, nous prenons ces deux profondeurs: <br><br><pre> <code class="javascript hljs">float worldDepth = getLinearDepth(WorldPosition); float screenDepth = getLinearScreenDepth();</code> </pre> <br><blockquote>  <em>T√¢che 4: l'une de ces valeurs ne sera jamais plus grande que l'autre (en supposant depthTest = true).</em>  <em>Pouvez-vous d√©terminer lequel?</em> </blockquote><br>  Nous savons que la mousse sera l√† o√π la distance entre les deux valeurs est petite.  Par cons√©quent, rendons cette diff√©rence pour chaque pixel.  Collez-le √† la fin du shader (et d√©sactivez le script de visualisation de la profondeur de la section pr√©c√©dente): <br><br><pre> <code class="javascript hljs">color = vec4(vec3(screenDepth - worldDepth),<span class="hljs-number"><span class="hljs-number">1.0</span></span>); gl_FragColor = color;</code> </pre> <br>  Et cela devrait ressembler √† ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad2/173/883/ad2173883ebe214bbec6c97921810755.png"></div><br>  Autrement dit, nous choisissons correctement les limites de tout objet immerg√© dans l'eau en temps r√©el!  Bien s√ªr, vous pouvez augmenter la diff√©rence pour rendre la mousse plus √©paisse ou moins courante. <br><br>  Nous avons maintenant de nombreuses options pour combiner cette sortie avec la surface de l'eau pour cr√©er de belles lignes de mousse.  Vous pouvez les laisser avec un d√©grad√©, utiliser pour √©chantillonner √† partir d'une texture diff√©rente ou leur attribuer une couleur sp√©cifique si la diff√©rence est inf√©rieure ou √©gale √† une certaine valeur limite. <br><br>  Ce que j'ai le plus aim√©, c'est l'attribution d'une couleur similaire aux lignes d'eau statique, donc ma fonction principale termin√©e ressemble √† ceci: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); vec2 pos = vUv0 * <span class="hljs-number"><span class="hljs-number">2.0</span></span>; pos.y += uTime * <span class="hljs-number"><span class="hljs-number">0.02</span></span>; vec4 WaterLines = texture2D(uSurfaceTexture,pos); color.rgba += WaterLines.r * <span class="hljs-number"><span class="hljs-number">0.1</span></span>; float worldDepth = getLinearDepth(WorldPosition); float screenDepth = getLinearScreenDepth(); float foamLine = clamp((screenDepth - worldDepth),<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>) ; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(foamLine &lt; <span class="hljs-number"><span class="hljs-number">0.7</span></span>){ color.rgba += <span class="hljs-number"><span class="hljs-number">0.2</span></span>; } gl_FragColor = color; }</code> </pre> <br><h2>  Pour r√©sumer </h2><br>  Nous avons cr√©√© la flottabilit√© d'objets immerg√©s dans l'eau, appliqu√© une texture mobile √† la surface pour simuler les caustiques et appris √† utiliser le tampon de profondeur pour cr√©er des bandes de mousse dynamiques. <br><br>  Dans la troisi√®me et derni√®re partie, nous allons ajouter les effets du post-traitement et apprendre √† les utiliser pour cr√©er l'effet de distorsion sous-marine. <br><br><h2>  Code source </h2><br>  Le projet PlayCanvas termin√© peut √™tre trouv√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external">ici</a> .  Notre r√©f√©rentiel poss√®de √©galement un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="external">port de projet sous Three.js</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr416983/">https://habr.com/ru/post/fr416983/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr416963/index.html">Comme nous l'avons fait pour BelAZ. Partie 2 - Tests de laboratoire</a></li>
<li><a href="../fr416967/index.html">Comme nous l'avons fait pour BelAZ. Partie 3 - Mise en service sectionnelle</a></li>
<li><a href="../fr416969/index.html">Justification math√©matique pythagoricienne de l'√©chelle musicale</a></li>
<li><a href="../fr416977/index.html">Logiciel Smart Home # 2</a></li>
<li><a href="../fr416981/index.html">Comment huit personnes font √©voluer un projet √† forte charge. Exp√©rience Unsplash</a></li>
<li><a href="../fr416985/index.html">Au centi√®me pr√®s: Top 10 des rapports SmartData 2017</a></li>
<li><a href="../fr416987/index.html">Gartner: le principal sur le march√© IaaS en 2018</a></li>
<li><a href="../fr416989/index.html">Robots Festo Bionic: araign√©es et poulpes dans les usines du futur?</a></li>
<li><a href="../fr416991/index.html">L'enregistrement vid√©o de votre √©cran n'est pas si secret. Versions de King Burger et Appsee</a></li>
<li><a href="../fr416993/index.html">Rencontrez Sofia: un robot presque impossible √† distinguer des humains</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>