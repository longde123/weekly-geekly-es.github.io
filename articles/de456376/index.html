<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üó®Ô∏è üë©üèæ üß¢ Not One Spring Boot: Ein √úberblick √ºber Alternativen ‚ö™Ô∏è ‚úåüèø üëÇüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Derzeit mangelt es nicht an Frameworks f√ºr die Erstellung von Microservices in Java und Kotlin. Der Artikel beschreibt Folgendes: 
 Titel  Version  Ja...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Not One Spring Boot: Ein √úberblick √ºber Alternativen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/raiffeisenbank/blog/456376/"><img src="https://habrastorage.org/webt/al/mw/1g/almw1ghoqrvuf2nbw_awcwqvqe4.png"><br><br>  Derzeit mangelt es nicht an Frameworks f√ºr die Erstellung von Microservices in Java und Kotlin.  Der Artikel beschreibt Folgendes: <br><div class="scrollable-table"><table><tbody><tr><th>  Titel </th><th>  Version </th><th>  Jahr der ersten Ver√∂ffentlichung </th><th>  Entwickler </th></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Helidon se</a> </td><td>  1.1.1 </td><td>  2019 </td><td>  Oracle </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ktor</a> </td><td>  1.2.1 </td><td>  2018 </td><td>  Jetbrains </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Micronaut</a> </td><td>  1.1.3 </td><td>  2018 </td><td>  Objektberechnung </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fr√ºhlingsstiefel</a> </td><td>  2.1.5 </td><td>  2014 </td><td>  Pivotal </td></tr></tbody></table></div><a name="habracut"></a><br>  Basierend darauf wurden vier Dienste erstellt, die √ºber die HTTP-API mithilfe des mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Consul</a> implementierten Diensterkennungsmusters miteinander interagieren k√∂nnen.  Somit bilden sie eine heterogene (auf Framework-Ebene) Mikroservice-Architektur (im Folgenden als ISA bezeichnet): <br><br><img src="https://habrastorage.org/webt/tv/mv/kp/tvmvkpurtljgpl3yhxhtpmse4_g.png"><br><br>  Definieren Sie eine Reihe von Anforderungen f√ºr jeden Dienst: <br><br><ul><li>  Technologie-Stack: <br><ul><li>  JDK 12; </li><li>  Kotlin </li><li>  Gradle (Kotlin DSL); </li><li>  Einheit 5. </li></ul><br></li><li>  Funktionalit√§t (HTTP API): <br><ul><li><code>GET /application-info{?request-to=some-service-name}</code> <br>  Gibt einige grundlegende Informationen zum Microservice zur√ºck (Name, Framework, Erscheinungsjahr des Frameworks).  Wenn Sie den Namen eines der vier Mikrodienste im Parameter <code>request-to</code> f√ºr die HTTP-API angeben, wird eine √§hnliche Anforderung ausgef√ºhrt, die grundlegende Informationen zur√ºckgibt. </li><li> <code>GET /application-info/logo</code> <br>  Gibt das Bild zur√ºck. </li></ul><br></li><li>  Implementierung: <br><ul><li>  Einrichtung unter Verwendung der Konfigurationsdatei; </li><li>  Verwenden der Abh√§ngigkeitsinjektion </li><li>  Tests, die die Funktionalit√§t der HTTP-API √ºberpr√ºfen. </li></ul><br></li><li>  ISA: <br><ul><li>  Verwenden des Service Discovery-Musters (Registrieren bei Consul, Zugreifen auf die HTTP-API eines anderen Mikrodienstes anhand seines Namens mithilfe des Client-Lastausgleichs); </li><li>  √úberglas-Artefaktbildung. </li></ul><br></li></ul><br>  Als n√§chstes betrachten wir die Implementierung eines Mikrodienstes auf jedem der Frameworks und vergleichen die Parameter der empfangenen Anwendungen. <br><br><h1>  Helidon-Service </h1><br>  Das Entwicklungsframework wurde bei Oracle f√ºr den internen Gebrauch erstellt und anschlie√üend zu Open Source.  Es gibt zwei Entwicklungsmodelle, die auf diesem Framework basieren: Standard Edition (SE) und MicroProfile (MP).  In beiden F√§llen handelt es sich bei dem Dienst um ein regul√§res Java SE-Programm.  Erfahren Sie mehr √ºber die Unterschiede auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieser</a> Seite. <br><br>  Kurz gesagt, Helidon MP ist eine der Eclipse <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MicroProfile-</a> Implementierungen, mit der viele APIs verwendet werden k√∂nnen, die Java EE-Entwicklern (z. B. JAX-RS, CDI) und neueren (Health Check, Metrics, Fault Tolerance) bisher bekannt waren usw.).  In der Helidon SE-Variante orientierten sich die Entwickler am Prinzip ‚ÄûKeine Magie‚Äú, das sich insbesondere in weniger oder gar keinen Anmerkungen zum Erstellen der Anwendung √§u√üert. <br><br>  Helidon SE wurde f√ºr die Entwicklung von Mikroservices ausgew√§hlt.  Unter anderem fehlen Tools zum Implementieren der Abh√§ngigkeitsinjektion, sodass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Koin</a> zum Implementieren von Abh√§ngigkeiten verwendet wird.  Das Folgende ist eine Klasse, die die Hauptmethode enth√§lt.  Um Dependency Injection zu implementieren, erbt die Klasse von <i>KoinComponent</i> .  Koin wird zuerst <code>startServer()</code> , dann werden die erforderlichen Abh√§ngigkeiten initialisiert und die Methode <code>startServer()</code> aufgerufen, wobei ein Objekt vom Typ <i>WebServer</i> erstellt wird, an das zuvor die Anwendungskonfiguration und die Routing-Einstellungen √ºbertragen wurden.  Nach dem Start wird die Anwendung in Consul registriert: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> HelidonServiceApplication : KoinComponent { <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> startTime = System.currentTimeMillis() startKoin { modules(koinModule) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> applicationInfoService: ApplicationInfoService <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> inject() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> consulClient: Consul <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> inject() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> applicationInfoProperties: ApplicationInfoProperties <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> inject() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> serviceName = applicationInfoProperties.name startServer(applicationInfoService, consulClient, serviceName, startTime) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startServer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( applicationInfoService: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ApplicationInfoService</span></span></span></span><span class="hljs-function"><span class="hljs-params">, consulClient: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Consul</span></span></span></span><span class="hljs-function"><span class="hljs-params">, serviceName: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, startTime: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span>: WebServer { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> serverConfig = ServerConfiguration.create(Config.create().<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"webserver"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> server: WebServer = WebServer .builder(createRouting(applicationInfoService)) .config(serverConfig) .build() server.start().thenAccept { ws -&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> durationInMillis = System.currentTimeMillis() - startTime log.info(<span class="hljs-string"><span class="hljs-string">"Startup completed in </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$durationInMillis</span></span></span><span class="hljs-string"> ms. Service running at: http://localhost:"</span></span> + ws.port()) <span class="hljs-comment"><span class="hljs-comment">// register in Consul consulClient.agentClient().register(createConsulRegistration(serviceName, ws.port())) } return server }</span></span></code> </pre> <br>  Das Routing ist wie folgt konfiguriert: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createRouting</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(applicationInfoService: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ApplicationInfoService</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = Routing.builder() .register(JacksonSupport.create()) .<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"/application-info"</span></span>, Handler { req, res -&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> requestTo: String? = req.queryParams() .first(<span class="hljs-string"><span class="hljs-string">"request-to"</span></span>) .orElse(<span class="hljs-literal"><span class="hljs-literal">null</span></span>) res .status(Http.ResponseStatus.create(<span class="hljs-number"><span class="hljs-number">200</span></span>)) .send(applicationInfoService.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(requestTo)) }) .<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"/application-info/logo"</span></span>, Handler { req, res -&gt; res.headers().contentType(MediaType.create(<span class="hljs-string"><span class="hljs-string">"image"</span></span>, <span class="hljs-string"><span class="hljs-string">"png"</span></span>)) res .status(Http.ResponseStatus.create(<span class="hljs-number"><span class="hljs-number">200</span></span>)) .send(applicationInfoService.getLogo()) }) .error(Exception::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) </span></span>{ req, res, ex -&gt; log.error(<span class="hljs-string"><span class="hljs-string">"Exception:"</span></span>, ex) res.status(Http.Status.INTERNAL_SERVER_ERROR_500).send() } .build()</code> </pre> <br>  Die Anwendung verwendet die Konfiguration im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><u>HOCON-</u></a> Format: <br><br><pre> <code class="json hljs">webserver { port: <span class="hljs-number"><span class="hljs-number">8081</span></span> } application-info { name: <span class="hljs-string"><span class="hljs-string">"helidon-service"</span></span> framework { name: <span class="hljs-string"><span class="hljs-string">"Helidon SE"</span></span> release-year: <span class="hljs-number"><span class="hljs-number">2019</span></span> } }</code> </pre> <br>  Es ist auch m√∂glich, Dateien in den Formaten JSON, YAML und Eigenschaften f√ºr die Konfiguration zu verwenden (weitere Details <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ). <br><br><h1>  Ktor Service </h1><br>  Das Framework ist in Kotlin geschrieben.  Ein neues Projekt kann auf verschiedene Arten erstellt werden: mit dem Build-System <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">start.ktor.io</a> oder dem Plug-In f√ºr IntelliJ IDEA (mehr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ). <br><br>  Wie Helidon SE verf√ºgt Ktor nicht √ºber einen sofort einsatzbereiten DI. Daher werden Abh√§ngigkeiten mithilfe von Koin implementiert, bevor der Server gestartet wird: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> koinModule = module { single { ApplicationInfoService(<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(), <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>()) } single { ApplicationInfoProperties() } single { ServiceClient(<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>()) } single { Consul.builder().withUrl(<span class="hljs-string"><span class="hljs-string">"http://localhost:8500"</span></span>).build() } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { startKoin { modules(koinModule) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> server = embeddedServer(Netty, commandLineEnvironment(args)) server.start(wait = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) }</code> </pre> <br>  Von der Anwendung ben√∂tigte Module sind in der Konfigurationsdatei angegeben (es ist m√∂glich, nur das HOCON-Format zu verwenden; mehr zur Konfiguration des Ktor-Servers <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ), deren Inhalt unten dargestellt wird: <br><br><pre> <code class="kotlin hljs">ktor { deployment { host = localhost port = <span class="hljs-number"><span class="hljs-number">8082</span></span> watch = [io.heterogeneousmicroservices.ktorservice] } application { modules = [io.heterogeneousmicroservices.ktorservice.module.KtorServiceApplicationModuleKt.module] } } application-info { name: <span class="hljs-string"><span class="hljs-string">"ktor-service"</span></span> framework { name: <span class="hljs-string"><span class="hljs-string">"Ktor"</span></span> release-year: <span class="hljs-number"><span class="hljs-number">2018</span></span> }</code> </pre> <br>  Ktor und Koin verwenden den Begriff ‚ÄûModul‚Äú, der unterschiedliche Bedeutungen hat.  In Koin ist ein Modul ein Analogon zum Anwendungskontext im Spring Framework.  Das Ktor-Modul ist eine benutzerdefinierte Funktion, die ein Objekt vom Typ <i>Anwendung</i> akzeptiert und eine Pipeline konfigurieren, Funktionen festlegen, Routen registrieren und verarbeiten kann <br>  Anfragen usw.: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Application.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">module</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> applicationInfoService: ApplicationInfoService <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> inject() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isTest()) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> consulClient: Consul <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> inject() registerInConsul(applicationInfoService.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-literal"><span class="hljs-literal">null</span></span>).name, consulClient) } install(DefaultHeaders) install(Compression) install(CallLogging) install(ContentNegotiation) { jackson {} } routing { route(<span class="hljs-string"><span class="hljs-string">"application-info"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> requestTo: String? = call.parameters[<span class="hljs-string"><span class="hljs-string">"request-to"</span></span>] call.respond(applicationInfoService.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(requestTo)) } static { resource(<span class="hljs-string"><span class="hljs-string">"/logo"</span></span>, <span class="hljs-string"><span class="hljs-string">"logo.png"</span></span>) } } } }</code> </pre> <br>  In diesem Codefragment wird das Routing von Anforderungen konfiguriert, insbesondere die statische Ressource <code>logo.png</code> . <br><br>  Der Ktor-Dienst kann Funktionen enthalten.  Eine Funktion ist eine Funktionalit√§t, die in eine Anforderungs-Antwort- <i>Pipeline</i> eingebettet ist ( <i>DefaultHeaders, Compression</i> und andere im obigen Codebeispiel).  Es ist m√∂glich, eigene Funktionen zu implementieren. Der folgende Code implementiert beispielsweise das Service Discovery-Muster in Kombination mit dem Client-Lastausgleich basierend auf dem Round-Robin-Algorithmus: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConsulFeature</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> consulClient: Consul) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> consulClient: Consul } <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> Feature : HttpClientFeature&lt;Config, ConsulFeature&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> serviceInstanceIndex: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> key = AttributeKey&lt;ConsulFeature&gt;(<span class="hljs-string"><span class="hljs-string">"ConsulFeature"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Config</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) = ConsulFeature(Config().apply(block).consulClient) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">install</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(feature: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ConsulFeature</span></span></span></span><span class="hljs-function"><span class="hljs-params">, scope: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">HttpClient</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { scope.requestPipeline.intercept(HttpRequestPipeline.Render) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> serviceName = context.url.host <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> serviceInstances = feature.consulClient.healthClient().getHealthyServiceInstances(serviceName).response <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> selectedInstance = serviceInstances[serviceInstanceIndex] context.url.apply { host = selectedInstance.service.address port = selectedInstance.service.port } serviceInstanceIndex = (serviceInstanceIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>) % serviceInstances.size } } } }</code> </pre> <br>  Die Hauptlogik liegt in der <code>install</code> : W√§hrend der <i>Renderanforderungsphase</i> (die vor der <i>Sendephase ausgef√ºhrt</i> wird) wird zuerst der Name des aufgerufenen Dienstes bestimmt, dann wird eine Liste der Instanzen dieses Dienstes von <code>consulClient</code> angefordert, wonach die Instanz unter Verwendung des Round-Robin-Algorithmus bestimmt wird.  Somit wird der folgende Aufruf m√∂glich: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getApplicationInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(serviceName: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: ApplicationInfo = runBlocking { httpClient.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>&lt;ApplicationInfo&gt;(<span class="hljs-string"><span class="hljs-string">"http://</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$serviceName</span></span></span><span class="hljs-string">/application-info"</span></span>) }</code> </pre> <br><br><h1>  Micronaut-Service </h1><br>  Micronaut wurde von den Entwicklern des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Grails-</a> Frameworks entwickelt und ist von der Erfahrung der Geb√§udetechnik mit Spring, Spring Boot und Grails inspiriert.  Das Framework ist ein Polyglot, das Java, Kotlin und Groovy unterst√ºtzt.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vielleicht gibt</a> es Unterst√ºtzung f√ºr Scala.  Die Abh√§ngigkeitsinjektion wird in der Kompilierungsphase ausgef√ºhrt, was im Vergleich zu Spring Boot zu einem geringeren Speicherverbrauch und einem schnelleren Start der Anwendung f√ºhrt. <br><br>  Die Hauptklasse hat folgende Form: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> MicronautServiceApplication { <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { Micronaut.build() .packages(<span class="hljs-string"><span class="hljs-string">"io.heterogeneousmicroservices.micronautservice"</span></span>) .mainClass(MicronautServiceApplication.javaClass) .start() } }</code> </pre> <br>  Einige Komponenten einer Micronaut-basierten Anwendung √§hneln ihren Gegenst√ºcken in einer Spring Boot-Anwendung. Der Controller-Code lautet beispielsweise wie folgt: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Controller( value = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/application-info"</span></span></span><span class="hljs-meta">, consumes = [MediaType.APPLICATION_JSON], produces = [MediaType.APPLICATION_JSON] )</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationInfoController</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> applicationInfoService: ApplicationInfoService ) { <span class="hljs-meta"><span class="hljs-meta">@Get</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(requestTo: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span>: ApplicationInfo = applicationInfoService.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(requestTo) <span class="hljs-meta"><span class="hljs-meta">@Get(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/logo"</span></span></span><span class="hljs-meta">, produces = [MediaType.IMAGE_PNG])</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLogo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: ByteArray = applicationInfoService.getLogo() }</code> </pre> <br>  Die Kotlin-Unterst√ºtzung in Micronaut basiert auf dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kapt-</a> Compiler- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Plugin</a> (weitere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Informationen</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ).  Das Assembly-Skript ist wie folgt konfiguriert: <br><br><pre> <code class="kotlin hljs">plugins { ... kotlin(<span class="hljs-string"><span class="hljs-string">"kapt"</span></span>) ... } dependencies { kapt(<span class="hljs-string"><span class="hljs-string">"io.micronaut:micronaut-inject-java"</span></span>) ... kaptTest(<span class="hljs-string"><span class="hljs-string">"io.micronaut:micronaut-inject-java"</span></span>) ... }</code> </pre> <br>  Folgendes ist der Inhalt der Konfigurationsdatei: <br><br><pre> <code class="json hljs">micronaut: application: name: micronaut-service server: port: <span class="hljs-number"><span class="hljs-number">8083</span></span> consul: client: registration: enabled: <span class="hljs-literal"><span class="hljs-literal">true</span></span> application-info: name: ${micronaut.application.name} framework: name: Micronaut release-year: <span class="hljs-number"><span class="hljs-number">2018</span></span></code> </pre> <br>  Die Microservice-Konfiguration ist auch mit JSON, Eigenschaften und Groovy-Dateiformaten m√∂glich (weitere Details <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ). <br><br><h1>  Spring Boot Service </h1><br>  Das Framework wurde erstellt, um die Entwicklung von Anwendungen mithilfe des Spring Framework-√ñkosystems zu vereinfachen.  Dies wird durch Autokonfigurationsmechanismen beim Verbinden von Bibliotheken erreicht.  Das Folgende ist der Controller-Code: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@RestController</span></span> <span class="hljs-meta"><span class="hljs-meta">@RequestMapping(path = [</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"application-info"</span></span></span><span class="hljs-meta">], produces = [MediaType.APPLICATION_JSON_UTF8_VALUE])</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationInfoController</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> applicationInfoService: ApplicationInfoService ) { <span class="hljs-meta"><span class="hljs-meta">@GetMapping</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestParam(</span></span></span><span class="hljs-meta-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta"><span class="hljs-meta-string">"request-to"</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">)</span></span></span></span><span class="hljs-function"><span class="hljs-params"> requestTo: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span>: ApplicationInfo = applicationInfoService.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(requestTo) <span class="hljs-meta"><span class="hljs-meta">@GetMapping(path = [</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/logo"</span></span></span><span class="hljs-meta">], produces = [MediaType.IMAGE_PNG_VALUE])</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLogo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: ByteArray = applicationInfoService.getLogo() }</code> </pre> <br>  Der Microservice wird mit einer YAML-Datei konfiguriert: <br><br><pre> <code class="json hljs">spring: application: name: spring-boot-service server: port: <span class="hljs-number"><span class="hljs-number">8084</span></span> application-info: name: ${spring.application.name} framework: name: Spring Boot release-year: <span class="hljs-number"><span class="hljs-number">2014</span></span></code> </pre> <br>  Es ist auch m√∂glich, Dateien im Eigenschaftenformat f√ºr die Konfiguration zu verwenden (weitere Details <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ). <br><br><h1>  Starten </h1><br>  Das Projekt funktioniert unter JDK 12, obwohl es wahrscheinlich auch unter Version 11 funktioniert, m√ºssen Sie nur den Parameter <code>jvmTarget</code> in den Assemblyskripten <code>jvmTarget</code> √§ndern: <br><br><pre> <code class="kotlin hljs">withType&lt;KotlinCompile&gt; { kotlinOptions { jvmTarget = <span class="hljs-string"><span class="hljs-string">"12"</span></span> ... } }</code> </pre> <br>  Bevor Sie Microservices starten, m√ºssen Sie Consul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">installieren</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den</a> Agenten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">starten</a> - zum Beispiel wie <code>consul agent -dev</code> : <code>consul agent -dev</code> . <br><br>  Das Starten von Microservices ist m√∂glich von: <br><br><ul><li>  IDE <br>  IntelliJ IDEA-Benutzer k√∂nnen Folgendes sehen: <br><img src="https://habrastorage.org/webt/n3/u_/hy/n3u_hy7_z5ut65ryaetvsw2znci.png"><br></li><li>  die Konsole <br>  Gehen Sie dazu in den Projektordner und f√ºhren Sie nacheinander Folgendes aus: <br><br><pre> <code class="plaintext hljs">java -jar helidon-service/build/libs/helidon-service-all.jar java -jar ktor-service/build/libs/ktor-service-all.jar java -jar micronaut-service/build/libs/micronaut-service-all.jar java -jar spring-boot-service/build/libs/spring-boot-service.jar</code> </pre> <br></li></ul><br>  Nachdem Sie alle Microservices unter <code>http://localhost:8500/ui/dc1/services</code> Sie: <br><br><img src="https://habrastorage.org/webt/qi/lm/bv/qilmbv1op4a6xgy6b31tnsfjpmm.png"><br><br><h1>  API-Tests </h1><br>  Die Ergebnisse des Testens der Helidon-Service-API sind als Beispiel angegeben: <br><br><ol><li> <code>GET http://localhost:8081/application-info</code> <br> <br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"helidon-service"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"framework"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Helidon SE"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"releaseYear"</span></span>: <span class="hljs-number"><span class="hljs-number">2019</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"requestedService"</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }</code> </pre> </li><li> <code>GET http://localhost:8081/application-info?request-to=ktor-service</code> <br> <br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"helidon-service"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"framework"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Helidon SE"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"releaseYear"</span></span>: <span class="hljs-number"><span class="hljs-number">2019</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"requestedService"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"ktor-service"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"framework"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Ktor"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"releaseYear"</span></span>: <span class="hljs-number"><span class="hljs-number">2018</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"requestedService"</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> } }</code> </pre> </li><li> <code>GET http://localhost:8081/application-info/logo</code> <br> <br>  Gibt das Bild zur√ºck. </li></ol><br>  Sie k√∂nnen eine beliebige Microservice-API mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Postman</a> (eine <a href="">Sammlung von</a> Anforderungen), einem IntelliJ IDEA <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://www.jetbrains.com/help/idea/">HTTP-Client</a> (eine <a href="https://github.com/rkudryashov/heterogeneous-microservices/blob/master/_misc/api_testing/idea_http_client/http-request.">Sammlung von</a> Anforderungen), einem Browser oder einem anderen Tool testen.  Wenn Sie die ersten beiden Clients verwenden, m√ºssen Sie den Port des aufgerufenen Mikrodienstes in der entsprechenden Variablen angeben (in Postman im <i>Sammlungsmen√º -&gt; Bearbeiten -&gt; Variablen</i> und im HTTP-Client in der in <a href="https://github.com/rkudryashov/heterogeneous-microservices/blob/master/_misc/api_testing/idea_http_client/">dieser</a> Datei angegebenen Umgebungsvariablen) und beim Testen von Methode 2). Die API muss auch den Namen des angeforderten "unter der Haube" -Mikroservices angeben.  Die Antworten sind √§hnlich wie oben angegeben. <br><br><h1>  Vergleich der Anwendungseinstellungen </h1><br><br><h3>  Artefaktgr√∂√üe </h3><br>  Um die Einfachheit der Konfiguration und Ausf√ºhrung von Anwendungen in Assemblyskripten zu gew√§hrleisten, wurden keine transitiven Abh√§ngigkeiten ausgeschlossen. Daher √ºbersteigt die Gr√∂√üe des Uber-JAR-Dienstes in Spring Boot die Gr√∂√üe von Analoga in anderen Frameworks erheblich (da bei Verwendung von Startern nicht nur die erforderlichen Abh√§ngigkeiten importiert werden. Falls gew√ºnscht, kann die Gr√∂√üe erheblich reduziert werden. <br><div class="scrollable-table"><table><tbody><tr><th>  Microservice </th><th>  Artefaktgr√∂√üe, MB </th></tr><tr><td>  Helidon-Service </td><td align="right">  16.6 </td></tr><tr><td>  Ktor Service </td><td align="right">  20.9 </td></tr><tr><td>  Micronaut-Service </td><td align="right">  16.5 </td></tr><tr><td>  Spring Boot Service </td><td align="right">  42.7 </td></tr></tbody></table></div><br><br><h3>  Startzeit </h3><br>  Die Startzeit jeder Anwendung ist inkonsistent und f√§llt in ein ‚ÄûFenster‚Äú.  Die folgende Tabelle zeigt die Startzeit des Artefakts ohne Angabe zus√§tzlicher Parameter: <br><div class="scrollable-table"><table><tbody><tr><th>  Microservice </th><th>  Startzeit Sekunden </th></tr><tr><td>  Helidon-Service </td><td align="right">  2.2 </td></tr><tr><td>  Ktor Service </td><td align="right">  1.4 </td></tr><tr><td>  Micronaut-Service </td><td align="right">  4.0 </td></tr><tr><td>  Spring Boot Service </td><td align="right">  10.2 </td></tr></tbody></table></div><br>  Es ist erw√§hnenswert, dass Sie die Startzeit erheblich verk√ºrzen k√∂nnen, wenn Sie die Spring Boot-Anwendung von unn√∂tigen Abh√§ngigkeiten ‚Äûbereinigen‚Äú und darauf achten, die Anwendung zum Starten zu konfigurieren (z. B. nur die erforderlichen Pakete scannen und die Initialisierung des verz√∂gerten Bin verwenden). <br><br><h3>  Lasttest </h3><br>  Zum Testen wurden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gatling</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein</a> Scala- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Skript</a> verwendet.  Der Lastgenerator und der zu testende Dienst wurden auf demselben Computer ausgef√ºhrt (Windows 10, ein Quad-Core-Prozessor mit 3,2 GHz, 24 GB RAM, SSD).  Der Port dieses Dienstes wird im Scala-Skript angegeben. <br><br>  F√ºr jeden Microservice wird bestimmt: <br><br><ul><li>  Die Mindestmenge an Heap-Speicher ( <code>-Xmx</code> ), die erforderlich ist, um einen funktionierenden (auf Anforderungen reagierenden) Mikroservice auszuf√ºhren </li><li>  Mindest-Heap-Speicher erforderlich, um den Auslastungstest zu bestehen 50 Benutzer * 1000 Anforderungen </li><li>  Mindest-Heap-Speicher erforderlich, um den Auslastungstest zu bestehen 500 Benutzer * 1000 Anforderungen </li></ul><br>  Das Bestehen eines Auslastungstests bedeutet, dass der Microservice jederzeit auf alle Anforderungen reagiert hat. <br><div class="scrollable-table"><table><tbody><tr><th rowspan="2">  Microservice </th><th colspan="3">  Die minimale Menge an Heap-Speicher, MB </th></tr><tr><th>  So starten Sie den Dienst </th><th>  F√ºr Last 50 * 1000 </th><th>  F√ºr Last 500 * 1000 </th></tr><tr><td>  Helidon-Service </td><td align="right">  9 </td><td align="right">  9 </td><td align="right">  11 </td></tr><tr><td>  Ktor Service </td><td align="right">  11 </td><td align="right">  11 </td><td align="right">  13 </td></tr><tr><td>  Micronaut-Service </td><td align="right">  13 </td><td align="right">  13 </td><td align="right">  17 </td></tr><tr><td>  Spring Boot Service </td><td align="right">  22 </td><td align="right">  23 </td><td align="right">  25 </td></tr></tbody></table></div><br>  Es ist erw√§hnenswert, dass alle Microservices den Netty HTTP-Server verwenden. <br><br><h1>  Fazit </h1><br>  Die Aufgabe - die Erstellung eines einfachen Dienstes mit HTTP-API und die F√§higkeit, in der ISA zu funktionieren - konnte auf allen fraglichen Frameworks abgeschlossen werden.  Es ist Zeit, Bilanz zu ziehen und ihre Vor- und Nachteile zu ber√ºcksichtigen. <br><br>  <i><b>Helidon</b></i> <br><br>  <font color="#808080">Standard Edition</font> <br><ul><li>  Pluspunkte <br><ul><li>  Anwendungseinstellungen <br>  In jeder Hinsicht zeigten gute Ergebnisse; </li><li>  "Keine Magie" <br>  Das Framework begr√ºndete das von den Entwicklern angegebene Prinzip: Es war nur eine Anmerkung <code>@JvmStatic</code> , um die Anwendung zu erstellen ( <code>@JvmStatic</code> - f√ºr das Java-Kotlin-Interope). </li></ul></li><li>  Nachteile <br><ul><li>  Mikroframework <br>  Einige f√ºr die industrielle Entwicklung erforderliche Komponenten fehlen sofort, z. B. die Abh√§ngigkeitsinjektion und die Implementierung von Service Discovery. </li></ul></li></ul><br>  <font color="#808080">Mikroprofil</font> <br>  Microservice wurde in diesem Framework nicht implementiert, daher m√∂chte ich nur einige Punkte beachten, die ich kenne: <br><br><ul><li>  Pluspunkte <br><ul><li>  Implementierung von Eclipse MicroProfile <br>  Im Wesentlichen ist MicroProfile Java EE, optimiert f√ºr ISA.  Auf diese Weise erhalten Sie zum einen Zugriff auf die gesamte Vielfalt der Java EE-APIs, einschlie√ülich der speziell f√ºr die ISA entwickelten, und zum anderen k√∂nnen Sie die MicroProfile-Implementierung in eine andere √§ndern (Open Liberty, WildFly Swarm usw.). . </li></ul></li><li>  zus√§tzlich <br><ul><li>  In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MicroProfile Starter k√∂nnen</a> Sie ein Projekt mit den erforderlichen Parametern in Analogie zu √§hnlichen Tools f√ºr andere Frameworks (z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spring Initializr</a> ) von Grund auf neu erstellen.  Zum Zeitpunkt der Ver√∂ffentlichung des Artikels implementiert Helidon MicroProfile 1.2, w√§hrend die neueste Version der Spezifikation 3.0 ist. </li></ul></li></ul><br><br>  <i><b>Ktor</b></i> <br><br><ul><li>  Pluspunkte <br><ul><li>  Leichtigkeit <br>  Erm√∂glicht es Ihnen, nur die Funktionen zu verbinden, die direkt zur Ausf√ºhrung der Aufgabe ben√∂tigt werden. </li><li>  Anwendungseinstellungen <br>  In jeder Hinsicht gute Ergebnisse. </li></ul></li><li>  Nachteile <br><ul><li>  Unter Kotlin ‚Äûgesch√§rft‚Äú, das hei√üt, es ist m√∂glich, aber nicht notwendig, in Java zu entwickeln. </li><li>  Mikroframework (siehe √§hnlichen Artikel f√ºr Helidon SE). </li></ul></li><li>  zus√§tzlich <br>  Einerseits ist das Entwicklungskonzept des Frameworks nicht in den beiden beliebtesten Java-Entwicklungsmodellen (Spring-like (Spring Boot / Micronaut) und Java EE / MicroProfile) enthalten, was zu folgenden Ergebnissen f√ºhren kann: <br><br><ul><li>  ein Problem bei der Suche nach Spezialisten; </li><li>  l√§ngere Zeit zum Ausf√ºhren von Aufgaben im Vergleich zu Spring Boot, da die erforderlichen Funktionen explizit konfiguriert werden m√ºssen. </li></ul><br>  Andererseits erm√∂glicht Ihnen die Un√§hnlichkeit zum ‚Äûklassischen‚Äú Spring und Java EE, den Entwicklungsprozess aus einem anderen Blickwinkel zu betrachten, vielleicht bewusster. </li></ul><br><br>  <i><b>Micronaut</b></i> <br><br><ul><li>  Pluspunkte <br><ul><li>  Aot <br>  Wie bereits erw√§hnt, k√∂nnen Sie mit AOT die Startzeit und den von der Anwendung verbrauchten Speicher im Vergleich zu Spring Boot reduzieren. </li><li>  Fr√ºhlingsartiges Entwicklungsmodell <br>  Programmierer mit Erfahrung in der Entwicklung von Spring werden nicht viel Zeit brauchen, um dieses Framework zu beherrschen. </li><li>  Anwendungseinstellungen <br>  Gute Ergebnisse in jeder Hinsicht; </li><li>  mehrsprachig <br>  Erstklassige B√ºrgerunterst√ºtzung f√ºr Java, Kotlin, Groovy;  Vielleicht gibt es Unterst√ºtzung f√ºr Scala.  Meiner Meinung nach kann dies das Wachstum der Community positiv beeinflussen.  √úbrigens, im Juni 2019 belegt Groovy im Ranking der Popularit√§t von Programmiersprachen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TIOBE</a> den 14. Platz, ab dem 60. Jahr zuvor, und belegt damit einen ehrenwerten zweiten Platz unter den JVM-Sprachen; </li><li>  Mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Micronaut for Spring-</a> Projekt k√∂nnen Sie auch die Laufzeit Ihrer vorhandenen Spring Boot-Anwendung in Micronaut √§ndern (mit Einschr√§nkungen). </li></ul></li></ul><br><br>  <i><b>Fr√ºhlingsstiefel</b></i> <br><br><ul><li>  Pluspunkte <br><ul><li>  Plattformreife und √ñkosystem <br>  Der Rahmen "jeden Tag".  F√ºr die meisten allt√§glichen Aufgaben gibt es bereits eine L√∂sung im Spring-Programmierparadigma, die vielen Programmierern vertraut ist.  Die Entwicklung wird durch die Konzepte von Startern und Autokonfigurationen vereinfacht. </li><li>  die Anwesenheit einer gro√üen Anzahl von Spezialisten auf dem Arbeitsmarkt sowie eine bedeutende Wissensbasis (einschlie√ülich Dokumentation und Antworten auf den Stapel√ºberlauf); </li><li>  Perspektive <br>  Ich denke, viele werden zustimmen, dass der Fr√ºhling in naher Zukunft der f√ºhrende Entwicklungsrahmen bleiben wird. </li></ul></li><li>  Nachteile <br><ul><li>  Anwendungseinstellungen <br>  Die Anwendung auf diesem Framework geh√∂rte nicht zu den f√ºhrenden Unternehmen, jedoch k√∂nnen einige Parameter, wie bereits erw√§hnt, unabh√§ngig voneinander optimiert werden.  Es sei auch daran erinnert, dass das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spring Fu-</a> Projekt in der aktiven Entwicklung ist, mit dessen Hilfe diese Parameter reduziert werden k√∂nnen. </li></ul></li></ul><br>  Sie k√∂nnen auch die allgemeinen Probleme hervorheben, die mit den neuen Frameworks verbunden sind, die in Spring Boot fehlen: <br><br><ul><li>  weniger entwickeltes √ñkosystem; </li><li>  eine kleine Anzahl von Spezialisten mit Erfahrung mit diesen Technologien; </li><li>  l√§ngere Zeit, um Aufgaben zu erledigen; </li><li>  dunkle Aussichten. </li></ul><br>  Die betrachteten Frameworks geh√∂ren zu verschiedenen Gewichtsklassen: Helidon SE und Ktor sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mikroframes</a> , Spring Boot ist ein Full-Stack-Framework, Micronaut eher auch Full-Stack;  Eine andere Kategorie ist MicroProfile (z. B. Helidon MP).  In Mikroframes ist die Funktionalit√§t eingeschr√§nkt, was die Ausf√ºhrung von Aufgaben verlangsamen kann.  Um die M√∂glichkeit der Implementierung dieser oder jener Funktionalit√§t auf der Grundlage eines Entwicklungsframeworks zu kl√§ren, empfehle ich, dass Sie sich mit dessen Dokumentation vertraut machen. <br><br>  Ich wage es nicht zu beurteilen, ob dieses oder jenes Framework in naher Zukunft "schie√üen" wird. Daher ist es meiner Meinung nach besser, die Entwicklung von Ereignissen weiterhin unter Verwendung des vorhandenen Entwicklungs-Frameworks zur L√∂sung von Arbeitsaufgaben zu √ºberwachen. <br><br>  Gleichzeitig √ºbertreffen die neuen Frameworks, wie im Artikel gezeigt, Spring Boot um die ber√ºcksichtigten Parameter der empfangenen Anwendungen.  Wenn einer dieser Parameter f√ºr einen Ihrer Microservices kritisch ist, m√ºssen Sie m√∂glicherweise auf die Frameworks achten, die die besten Ergebnisse erzielt haben.  Vergessen Sie jedoch nicht, dass sich Spring Boot zum einen weiter verbessert und zum anderen ein riesiges √ñkosystem hat und eine betr√§chtliche Anzahl von Java-Programmierern damit vertraut ist.  Es gibt andere Frameworks, die in diesem Artikel nicht behandelt werden: Javalin, Quarkus usw. <br><br>  Sie k√∂nnen den Projektcode auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> anzeigen.  Danke f√ºr die Aufmerksamkeit! <br><br>  PS: Vielen Dank an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">artglorin</a> f√ºr die Hilfe bei diesem Artikel. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de456376/">https://habr.com/ru/post/de456376/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de456366/index.html">Wie ich die LED HEART Box entworfen habe</a></li>
<li><a href="../de456368/index.html">Durchf√ºhren √∂ffentlicher und privater Transaktionen in der JPMorgan Quorum-Blockchain mit Web3</a></li>
<li><a href="../de456370/index.html">Implementieren Sie QoS in Qsan Storage</a></li>
<li><a href="../de456372/index.html">SimbirSoft l√§dt IT-Experten zum Intensivsommer 2019 ein</a></li>
<li><a href="../de456374/index.html">Plasma Cash Blockchain State Datenstrukturen</a></li>
<li><a href="../de456380/index.html">Tag der offenen T√ºr der Fakult√§t f√ºr Programmierung in der Netologie</a></li>
<li><a href="../de456382/index.html">Zusammenarbeit und Automatisierung im Frontend. Was wir aus 13 Schulen gelernt haben</a></li>
<li><a href="../de456386/index.html">√ñffnen Sie Bibliotheken zur Visualisierung von Audioinhalten</a></li>
<li><a href="../de456388/index.html">Diagnoseentwicklungsdiagramm in PVS-Studio</a></li>
<li><a href="../de456392/index.html">Parsim 25 TB mit AWK und R.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>