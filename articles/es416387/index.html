<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë¥üèª üêé üßô Camarones: escale y comparta im√°genes HTTP en C ++ moderno con ImageMagic ++, SObjectizer y RESTinio üë£ üê• üëçüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√≥logo 
 Nuestro peque√±o equipo est√° desarrollando dos herramientas OpenSource para desarrolladores de C ++: el marco del actor SObjectizer y el serv...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Camarones: escale y comparta im√°genes HTTP en C ++ moderno con ImageMagic ++, SObjectizer y RESTinio</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416387/"><img src="https://habrastorage.org/webt/c8/es/x7/c8esx7a-blzv0brvoyng2drgdeq.jpeg"><br><br><h1>  Pr√≥logo </h1><br>  Nuestro peque√±o equipo est√° desarrollando dos herramientas OpenSource para desarrolladores de C ++: el marco del actor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SObjectizer</a> y el servidor HTTP incorporado RESTinio.  Sin embargo, regularmente nos encontramos con un par de preguntas no triviales: <br><br><ul><li>  ¬øQu√© funciones agregar a la biblioteca y cu√°les dejar "al agua"? </li><li>  ¬øC√≥mo demostrar claramente las formas "ideol√≥gicamente correctas" de usar la biblioteca? </li></ul><br>  Es bueno cuando las respuestas a tales preguntas aparecen durante el uso de nuestros desarrollos en proyectos reales, cuando los desarrolladores nos llegan con sus quejas o lista de deseos.  Debido a la satisfacci√≥n de los deseos de los usuarios, llenamos nuestras herramientas con una funcionalidad que es dictada por la vida misma, y ‚Äã‚Äãno "extra√≠da del dedo". <br><br>  Pero la informaci√≥n nos llega lejos de todos los problemas y dificultades que enfrentan los usuarios.  Y no siempre podemos usar la informaci√≥n recibida, y especialmente los ejemplos de c√≥digo, en nuestros materiales p√∫blicos. <br><br>  Por lo tanto, a veces pensamos en peque√±os problemas para nosotros mismos, resolviendo lo que nos vemos obligados a convertir de desarrolladores de herramientas a usuarios.  Esto nos permite mirar nuestras propias herramientas con diferentes ojos y comprender por nosotros mismos qu√© es bueno, qu√© no es bueno, qu√© falta y qu√© es demasiado. <br><br>  Hoy queremos contar una de esas tareas "peque√±as", en las que SObjectizer y RESTinio se unieron naturalmente. <br><br><h1>  Escalado y distribuci√≥n de im√°genes.  ¬øPor qu√© exactamente esto? </h1><br>  Como una peque√±a tarea de demostraci√≥n para nosotros, elegimos un servidor HTTP que distribuye im√°genes escaladas a pedido.  Pones las im√°genes en alg√∫n directorio, inicias el servidor HTTP, le solicitas el formulario: <br><a name="habracut"></a><br><pre><code class="bash hljs">curl <span class="hljs-string"><span class="hljs-string">"http://localhost:8080/my_picture.jpg?op=resize&amp;max=1920"</span></span></code> </pre> <br>  y a cambio obtienes una imagen a escala de 1920 p√≠xeles en el lado largo. <br><br>  La elecci√≥n recay√≥ en esta tarea porque demuestra perfectamente los escenarios para los que en un momento comenzamos a desarrollar RESTinio: hay un c√≥digo depurado y de larga ejecuci√≥n en C o C ++ al que debe adjuntar una entrada HTTP y comenzar a responder a las solicitudes entrantes.  Al mismo tiempo, lo cual es importante, el procesamiento de la solicitud de la solicitud puede llevar un tiempo considerable y, por lo tanto, no es rentable extraer el c√≥digo de la aplicaci√≥n directamente en el contexto IO.  El servidor HTTP debe ser as√≠ncrono: acepte y analice la solicitud HTTP, proporcione la solicitud analizada en alg√∫n lugar para su posterior procesamiento de la aplicaci√≥n, proceda a atender la siguiente solicitud HTTP, vuelva a devolver la respuesta a la solicitud HTTP cuando alguien la prepare. <br><br>  Esto es exactamente lo que sucede cuando se procesan solicitudes para escalar im√°genes.  Un servidor HTTP puede hacer su trabajo directo (es decir, leer datos, analizar una solicitud HTTP) en una fracci√≥n de milisegundo.  Pero escalar una imagen puede tomar decenas, cientos o incluso miles de milisegundos. <br><br>  Y dado que puede llevar mucho tiempo escalar una imagen, debe asegurarse de que el servidor HTTP pueda continuar funcionando mientras se escala la imagen.  Para hacer esto, necesitamos difundir el trabajo del servidor HTTP y escalar im√°genes a diferentes contextos de trabajo.  En el caso simple, estos ser√°n diferentes hilos de trabajo.  Bueno, dado que vivimos en procesadores multi-core, tendremos varios hilos de trabajo.  Algunos atender√°n solicitudes HTTP, otros trabajar√°n con im√°genes. <br><br>  Resulta que para distribuir im√°genes escalables a trav√©s de HTTP, tenemos que reutilizar el c√≥digo C / C ++ que funciona desde hace mucho tiempo (en este caso, ImageMagic ++) y atender las solicitudes HTTP de forma as√≠ncrona y realizar el procesamiento de las solicitudes en varios flujos de trabajo.  Una excelente tarea para RESTinio y SObjectizer, como nos pareci√≥. <br><br>  Y decidimos nombrar nuestro proyecto de camarones camarones. <br><br><h1>  Camarones como es </h1><br><h2>  ¬øQu√© hace el camar√≥n? </h2><br>  Shrimp se ejecuta como una aplicaci√≥n de consola, se abre y escucha en el puerto especificado, recibe y procesa las solicitudes HTTP GET del formulario: <br><br><pre> <code class="hljs xml">/<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">image</span></span></span><span class="hljs-tag">&gt;</span></span>.<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ext</span></span></span><span class="hljs-tag">&gt;</span></span> /<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">image</span></span></span><span class="hljs-tag">&gt;</span></span>.<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ext</span></span></span><span class="hljs-tag">&gt;</span></span>?op=resize&amp;<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">side</span></span></span><span class="hljs-tag">&gt;</span></span>=<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">value</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Donde: <br><br><ul><li>  imagen es el nombre del archivo de imagen a escala.  Por ejemplo, my_picture o DSCF0069; </li><li>  ext es una de las extensiones compatibles con camarones (jpg, jpeg, png o gif); </li><li>  lado es una indicaci√≥n del lado para el que se establece el tama√±o.  Puede tener un valor de ancho, en este caso la imagen se escala para que el ancho resultante sea igual al valor especificado, la altura de la imagen se selecciona autom√°ticamente mientras se mantiene la relaci√≥n de aspecto.  O el valor de la altura, en este caso, la escala se produce en altura.  Cualquiera de los valores m√°ximos, en este caso, el lado largo es limitado, y los camarones en s√≠ mismos determinan si el lado largo es alto o ancho; </li><li>  valor es el tama√±o en el que se produce el escalado. </li></ul><br>  Si solo se especifica el nombre del archivo en la URL, sin la operaci√≥n de cambio de tama√±o, entonces los camarones simplemente devuelven la imagen original en la respuesta.  Si se especifica la operaci√≥n de cambio de tama√±o, entonces el camar√≥n cambia el tama√±o de la imagen solicitada y proporciona la versi√≥n escalada. <br><br>  Al mismo tiempo, los camarones mantienen en la memoria un cach√© de im√°genes escaladas.  Si se solicita una imagen repetidamente con los mismos par√°metros de cambio de tama√±o, que ya est√° en la memoria cach√©, se devuelve el valor de la memoria cach√©.  Si no hay imagen en el cach√©, la imagen se lee desde el disco, se escala, se almacena en el cach√© y se devuelve en respuesta. <br><br>  El cach√© se borra peri√≥dicamente.  Las im√°genes que han vivido en el cach√© durante m√°s de una hora desde el √∫ltimo acceso a ellas se eliminan.  Adem√°s, las im√°genes m√°s antiguas se eliminan del cach√© si el cach√© excede su tama√±o m√°ximo (en un proyecto de demostraci√≥n es de 100Mb). <br><br>  Hemos preparado una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">p√°gina</a> para que cualquiera pueda experimentar con camarones: <br><br><img src="https://habrastorage.org/webt/uv/vr/-q/uvvr-qtt1xovbi_k-ieoyrpvq-y.jpeg"><br><br>  En esta p√°gina puede establecer el tama√±o de la imagen y hacer clic en "Cambiar tama√±o".  Se realizar√°n dos solicitudes al servidor de camarones con los mismos par√°metros.  Lo m√°s probable es que la primera solicitud sea √∫nica (es decir, todav√≠a no habr√° una memoria cach√© con tales par√°metros de cambio de tama√±o en la memoria cach√©), por lo que la primera solicitud llevar√° alg√∫n tiempo para escalar la imagen.  Y la segunda solicitud, muy probablemente, encontrar√° la imagen ya escalada en el cach√© y la dar√° de inmediato. <br><br>  Es posible juzgar si una imagen se proporciona desde el cach√© o si realmente fue escalada por el texto debajo de la imagen.  Por ejemplo, el texto "Transformado (114.0ms)" indica que la imagen fue escalada y la operaci√≥n de zoom tom√≥ 114 milisegundos. <br><br><h2>  ¬øC√≥mo lo hace el camar√≥n? </h2><br>  Shrimp es una aplicaci√≥n multiproceso que ejecuta tres grupos de hilos de trabajo: <br><br><ol><li>  El grupo de subprocesos de trabajo que ejecuta el servidor HTTP.  En este grupo, se sirven nuevas conexiones, se reciben y analizan las solicitudes entrantes, se generan y env√≠an respuestas.  El servidor HTTP se implementa a trav√©s de la biblioteca RESTinio. </li><li>  Un subproceso de trabajo independiente en el que se ejecuta el agente transform_manager SObjectizer.  Este agente procesa las solicitudes recibidas del servidor HTTP y mantiene un cach√© de im√°genes escaladas. </li><li>  El grupo de subprocesos en el que los agentes SObjectizer funcionan transformadores.  Realizan el escalado real de im√°genes usando ImageMagic ++. </li></ol><br>  Resulta el siguiente esquema de trabajo: <br><br><img src="https://habrastorage.org/webt/ns/ov/sj/nsovsjushv0zxasu_cq3ur0dy6m.png"><br><br>  El servidor HTTP acepta la solicitud entrante, la analiza y verifica la correcci√≥n.  Si esta solicitud no requiere una operaci√≥n de cambio de tama√±o, el servidor HTTP mismo procesa la solicitud a trav√©s de la operaci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sendfile</a> .  Si la solicitud requiere una operaci√≥n de cambio de tama√±o, la solicitud se env√≠a de forma as√≠ncrona al agente transform_manager. <br><br>  El agente transform_manager recibe solicitudes del servidor HTTP, verifica la presencia de im√°genes ya escaladas en la memoria cach√©.  Si hay una imagen en el cach√©, transform_manager genera inmediatamente una respuesta para el servidor HTTP.  Si no hay imagen, transform_manager env√≠a una solicitud para escalar la imagen a uno de los agentes transformadores.  Cuando el resultado de escala proviene del transformador, el resultado se almacena en la memoria cach√© y se genera una respuesta para el servidor HTTP. <br><br>  El agente transformador recibe solicitudes de transform_manager, las procesa y devuelve el resultado de la transformaci√≥n al agente transform_manager. <br><br><h2>  ¬øQu√© tiene camarones debajo del cap√≥? </h2><br>  El c√≥digo fuente de la versi√≥n m√°s m√≠nima de camarones que se describe en este art√≠culo se puede encontrar en este repositorio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">camarones-demostraci√≥n en BitBucket</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en GitHub</a> . <br><br>  Hay mucho c√≥digo, aunque, en su mayor parte, en esta versi√≥n de camarones, el c√≥digo es bastante trivial.  Sin embargo, tiene sentido centrarse en algunos aspectos de la implementaci√≥n. <br><br><h3>  Usando C ++ 17 y las versiones m√°s recientes del compilador </h3><br>  En la implementaci√≥n de camarones, decidimos usar C ++ 17 y las √∫ltimas versiones de compiladores, en particular GCC 7.3 y 8.1.  El proyecto est√° fuertemente investigado.  Por lo tanto, el conocimiento pr√°ctico de C ++ 17 en el marco de dicho proyecto es natural y aceptable.  Mientras que en desarrollos m√°s mundanos centrados en aplicaciones industriales pr√°cticas aqu√≠ y ahora, nos vemos obligados a mirar hacia atr√°s a compiladores bastante antiguos y usar quiz√°s C ++ 14, o incluso solo un subconjunto de C ++ 11. <br><br>  Debo decir que C ++ 17 hace una buena impresi√≥n.  Parece que no utilizamos tantas innovaciones del decimos√©ptimo est√°ndar en el c√≥digo del camar√≥n, pero tuvieron un efecto positivo: el atributo [[nodiscard]], std :: opcional / std :: variant / std :: filesystem directamente " fuera de la caja ", y no de dependencias externas, enlace estructurado, si se constexpr, la capacidad de reunir visitante para lambdas para std :: visita ... Individualmente, todos estos son peque√±os, pero juntos producen un poderoso efecto acumulativo. <br><br>  Entonces, el primer resultado √∫til que obtuvimos al desarrollar camarones: C ++ 17 vale la pena cambiar a √©l. <br><br><h3>  Servidor HTTP utilizando herramientas RESTinio </h3><br>  Quiz√°s la parte m√°s f√°cil de los camarones result√≥ ser el servidor HTTP y el controlador de solicitudes HTTP GET ( <a href="https://bitbucket.org/sobjectizerteam/shrimp-demo/src/v0.2/dev/shrimp/">http_server.hpp</a> y <a href="https://bitbucket.org/sobjectizerteam/shrimp-demo/src/v0.2/dev/shrimp/">http_server.cpp</a> ). <br><br><h4>  Recibir y enviar solicitudes entrantes </h4><br>  Esencialmente, toda la l√≥gica b√°sica del servidor HTTP de camarones se concentra en esta funci√≥n: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_transform_op_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">app_params_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; app_params, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">http_req_router_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; router, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mbox_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req_handler_mbox )</span></span></span><span class="hljs-function"> </span></span>{ router.http_get( <span class="hljs-string"><span class="hljs-string">R"(/:path(.*)\.:ext(.{3,4}))"</span></span>, restinio::path2regex::<span class="hljs-keyword"><span class="hljs-keyword">options_t</span></span>{}.strict( <span class="hljs-literal"><span class="hljs-literal">true</span></span> ), [req_handler_mbox, &amp;app_params]( <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> req, <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> params ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( has_illegal_path_components( req-&gt;header().path() ) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_400_response( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( req ) ); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> opt_image_format = image_format_from_extension( params[ <span class="hljs-string"><span class="hljs-string">"ext"</span></span> ] ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !opt_image_format ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_400_response( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( req ) ); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( req-&gt;header().query().empty() ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> serve_as_regular_file( app_params.m_storage.m_root_dir, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( req ), *opt_image_format ); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> qp = restinio::parse_query( req-&gt;header().query() ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-string"><span class="hljs-string">"resize"</span></span> != restinio::value_or( qp, <span class="hljs-string"><span class="hljs-string">"op"</span></span>sv, <span class="hljs-string"><span class="hljs-string">""</span></span>sv ) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_400_response( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( req ) ); } handle_resize_op_request( req_handler_mbox, *opt_image_format, qp, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( req ) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::request_accepted(); } ); }</code> </pre> <br>  Esta funci√≥n prepara el controlador de solicitud HTTP GET utilizando el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enrutador</a> RESTinio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ExpressJS</a> .  Cuando el servidor HTTP recibe una solicitud GET, cuya URL se encuentra bajo la expresi√≥n regular dada, se llama a la funci√≥n lambda especificada. <br><br>  Esta funci√≥n lambda realiza algunas comprobaciones simples sobre la exactitud de la solicitud, pero en general, su trabajo se reduce a una elecci√≥n simple: si no se establece el cambio de tama√±o, la imagen solicitada se devolver√° en su forma original utilizando un sistema de env√≠o efectivo del sistema.  Si se establece el modo de cambio de tama√±o, se genera un mensaje y se env√≠a al agente transform_manager: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_resize_op_request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mbox_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; req_handler_mbox, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">image_format_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> image_format, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> restinio::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">query_string_params_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; qp, restinio::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">request_handle_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req )</span></span></span><span class="hljs-function"> </span></span>{ try_to_handle_request( [&amp;]{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> op_params = transform::<span class="hljs-keyword"><span class="hljs-keyword">resize_params_t</span></span>::make( restinio::opt_value&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> &gt;( qp, <span class="hljs-string"><span class="hljs-string">"width"</span></span> ), restinio::opt_value&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> &gt;( qp, <span class="hljs-string"><span class="hljs-string">"height"</span></span> ), restinio::opt_value&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> &gt;( qp, <span class="hljs-string"><span class="hljs-string">"max"</span></span> ) ); transform::<span class="hljs-keyword"><span class="hljs-keyword">resize_params_constraints_t</span></span>{}.check( op_params ); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> image_path{ req-&gt;header().path() }; so_5::send&lt; so_5::mutable_msg&lt;<span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">resize_request_t</span></span>&gt;&gt;( req_handler_mbox, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(req), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(image_path), image_format, op_params ); }, req ); }</code> </pre> <br>  Resulta que el servidor HTTP, despu√©s de haber aceptado la solicitud de cambio de tama√±o, se la entrega al agente transform_manager a trav√©s de un mensaje as√≠ncrono y contin√∫a atendiendo otras solicitudes. <br><br><h4>  Compartir archivos con sendfile </h4><br>  Si el servidor HTTP detecta una solicitud para la imagen original, sin la operaci√≥n de cambio de tama√±o, el servidor env√≠a inmediatamente esta imagen a trav√©s de la operaci√≥n sendfile.  El c√≥digo principal asociado con esto es el siguiente (el c√≥digo completo para esta funci√≥n se puede encontrar <a href="">en el repositorio</a> ): <br><br><pre> <code class="cpp hljs">[[nodiscard]] restinio::<span class="hljs-keyword"><span class="hljs-keyword">request_handling_status_t</span></span> serve_as_regular_file( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp; root_dir, restinio::<span class="hljs-keyword"><span class="hljs-keyword">request_handle_t</span></span> req, <span class="hljs-keyword"><span class="hljs-keyword">image_format_t</span></span> image_format ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> full_path = make_full_path( root_dir, req-&gt;header().path() ); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> sf = restinio::sendfile( full_path ); ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> set_common_header_fields_for_image_resp( file_stat.st_mtim.tv_sec, resp ) .append_header( restinio::http_field::content_type, image_content_type_from_img_format( image_format ) ) .append_header( http_header::shrimp_image_src, image_src_to_str( http_header::<span class="hljs-keyword"><span class="hljs-keyword">image_src_t</span></span>::sendfile ) ) .set_body( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( sf ) ) .done(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(...) {} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_404_response( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( req ) ); }</code> </pre> <br>  El punto clave aqu√≠ es llamar a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">restinio :: sendfile ()</a> y luego pasar el valor devuelto por esta funci√≥n a set_body (). <br><br>  La funci√≥n restinio :: sendfile () crea una operaci√≥n de carga de archivos utilizando la API del sistema.  Cuando esta operaci√≥n se pasa a set_body (), RESTinio comprende que el contenido del archivo especificado en restinio :: sendfile () se utilizar√° para el cuerpo de la respuesta HTTP.  Luego usa la API del sistema para escribir el contenido de este archivo en el socket TCP. <br><br><h3>  Implementando el cach√© de im√°genes </h3><br>  El agente transform_manager almacena el cach√© de las im√°genes convertidas, donde las im√°genes se colocan despu√©s de escalar.  Este cach√© es un contenedor simple hecho a s√≠ mismo que proporciona acceso a su contenido de dos maneras: <br><br><ol><li>  Al buscar un elemento por clave (similar a c√≥mo sucede esto en los contenedores est√°ndar std :: map y std :: unordered_map). </li><li>  Al acceder al elemento de cach√© m√°s antiguo. </li></ol><br>  El primer m√©todo de acceso se usa cuando necesitamos verificar la disponibilidad de la imagen en el cach√©.  El segundo es cuando eliminamos las im√°genes m√°s antiguas del cach√©. <br><br>  No comenzamos a buscar algo listo para estos fines en Internet.  Probablemente Boost.MultiIndex ser√≠a bastante adecuado aqu√≠.  Pero no quer√≠a arrastrar a Boost solo por MultiIndex, as√≠ que hicimos <a href="">nuestra implementaci√≥n trivial</a> literalmente de rodillas.  Parece funcionar;) <br><br><h3>  Cola de solicitudes pendientes en transform_manager </h3><br>  El agente transform_manager, a pesar de su tama√±o bastante decente (un <a href="">archivo hpp de</a> aproximadamente 250 l√≠neas y un <a href="">archivo cpp de</a> aproximadamente 270 l√≠neas), en nuestra implementaci√≥n m√°s simple de camarones, result√≥ ser bastante trivial, en nuestra opini√≥n. <br><br>  Uno de los puntos que hace una contribuci√≥n significativa a la complejidad y el volumen del c√≥digo del agente es la presencia en transform_manager no solo del cach√© de las im√°genes transformadas, sino tambi√©n de la cola de solicitudes pendientes. <br><br>  Tenemos un n√∫mero limitado de agentes transformadores (en principio, su n√∫mero deber√≠a corresponder aproximadamente al n√∫mero de n√∫cleos de procesamiento disponibles).  Si llegan m√°s solicitudes simult√°neamente que hay transformadores libres, entonces podemos responder inmediatamente negativamente a la solicitud o poner en cola la solicitud.  Y luego ret√≠relo de la cola cuando aparezca un transformador libre. <br><br>  En camarones, utilizamos una cola de solicitudes en espera, que se define de la siguiente manera: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pending_request_t</span></span></span><span class="hljs-class"> {</span></span> transform::<span class="hljs-keyword"><span class="hljs-keyword">resize_request_key_t</span></span> m_key; <span class="hljs-keyword"><span class="hljs-keyword">sobj_shptr_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">resize_request_t</span></span>&gt; m_cmd; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::steady_clock::time_point m_stored_at; <span class="hljs-keyword"><span class="hljs-keyword">pending_request_t</span></span>( transform::<span class="hljs-keyword"><span class="hljs-keyword">resize_request_key_t</span></span> key, <span class="hljs-keyword"><span class="hljs-keyword">sobj_shptr_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">resize_request_t</span></span>&gt; cmd, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::steady_clock::time_point stored_at ) : m_key{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(key) } , m_cmd{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cmd) } , m_stored_at{ stored_at } {} }; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pending_request_queue_t</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">pending_request_t</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">pending_request_queue_t</span></span> m_pending_requests; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> max_pending_requests{ <span class="hljs-number"><span class="hljs-number">64u</span></span> };</code> </pre> <br>  Una vez recibida la solicitud, la ponemos en la cola para fijar el momento en que se recibi√≥ la solicitud.  Luego verificamos peri√≥dicamente para ver si el tiempo de espera para esta solicitud ha expirado.  De hecho, en principio, puede suceder que un paquete de solicitudes "pesadas" haya llegado antes, cuyo procesamiento tom√≥ demasiado tiempo.  Es incorrecto esperar sin cesar a que aparezca un transformador libre, es mejor enviar una respuesta negativa al cliente despu√©s de un tiempo, lo que significa que el servicio ahora est√° sobrecargado. <br><br>  Tambi√©n hay un l√≠mite de tama√±o para la cola de solicitudes pendientes.  Si la cola ya ha alcanzado su tama√±o m√°ximo, inmediatamente nos negamos a procesar la solicitud y le decimos al cliente que estamos sobrecargados. <br><br>  Hay un punto importante relacionado con la cola de solicitudes pendientes, en el que nos centraremos en la conclusi√≥n del art√≠culo. <br><br><h4>  Escriba sobj_shptr_t y reutilice instancias de mensajes </h4><br>  Al determinar el tipo de la cola de solicitudes en espera, as√≠ como en las firmas de algunos m√©todos de transform_manager, puede ver el uso del tipo sobj_shptr_t.  Tiene sentido detenerse en m√°s detalles sobre qu√© tipo es y por qu√© se usa. <br><br>  La conclusi√≥n es que transform_manager recibe una solicitud del servidor HTTP como un mensaje resize_request_t: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resize_request_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">message_t</span></span> { restinio::<span class="hljs-keyword"><span class="hljs-keyword">request_handle_t</span></span> m_http_req; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_image; <span class="hljs-keyword"><span class="hljs-keyword">image_format_t</span></span> m_image_format; transform::<span class="hljs-keyword"><span class="hljs-keyword">resize_params_t</span></span> m_params; <span class="hljs-keyword"><span class="hljs-keyword">resize_request_t</span></span>( restinio::<span class="hljs-keyword"><span class="hljs-keyword">request_handle_t</span></span> http_req, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> image, <span class="hljs-keyword"><span class="hljs-keyword">image_format_t</span></span> image_format, transform::<span class="hljs-keyword"><span class="hljs-keyword">resize_params_t</span></span> params ) : m_http_req{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(http_req) } , m_image{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(image) } , m_image_format{ image_format } , m_params{ params } {} };</code> </pre> <br>  y tenemos que hacer algo para almacenar esta informaci√≥n en la cola de solicitudes en espera.  Por ejemplo, puede crear una nueva instancia de resize_request_t y mover los valores del mensaje recibido al mismo. <br><br>  Y puede recordar que el mensaje en s√≠ mismo en SObjectizer es un objeto creado din√°micamente.  Y no es un objeto simple, sino con un contador de enlaces dentro.  Y que en SObjectizer hay un tipo especial de puntero inteligente para tales objetos: intrusive_ptr_t. <br><br>  Es decir  no podemos hacer una copia de resize_request_t para la cola de solicitudes en espera, pero simplemente podemos poner en esta cola un puntero inteligente a una instancia existente de resize_request_t.  Lo que hacemos  Y para no escribir en todas partes el nombre bastante ex√≥tico so_5 :: intrusive_ptr_t, ingresamos nuestro alias: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sobj_shptr_t</span></span> = so_5::<span class="hljs-keyword"><span class="hljs-keyword">intrusive_ptr_t</span></span>&lt;T&gt;;</code> </pre><br><h3>  Respuestas asincr√≥nicas a clientes </h3><br>  Dijimos que las solicitudes HTTP se procesan de forma asincr√≥nica.  Y mostramos anteriormente c√≥mo el servidor HTTP env√≠a una consulta al agente transform_manager con un mensaje asincr√≥nico.  Pero, ¬øqu√© pasa con las respuestas a las solicitudes HTTP? <br><br>  Las respuestas tambi√©n se sirven de forma asincr√≥nica.  Por ejemplo, en el c√≥digo transform_manager puede ver lo siguiente: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_failed_resize( <span class="hljs-keyword"><span class="hljs-keyword">failed_resize_t</span></span> &amp; <span class="hljs-comment"><span class="hljs-comment">/*result*/</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sobj_shptr_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">resize_request_t</span></span>&gt; cmd ) { do_404_response( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cmd-&gt;m_http_req) ); }</code> </pre> <br>  Este c√≥digo genera una respuesta negativa a la solicitud HTTP en el caso de que la imagen no se pueda escalar por alg√∫n motivo.  La respuesta se genera en la funci√≥n auxiliar do_404_response, cuyo c√≥digo se puede representar de la siguiente manera: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_404_response</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( restinio::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">request_handle_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> resp = req-&gt;create_response( <span class="hljs-number"><span class="hljs-number">404</span></span>, <span class="hljs-string"><span class="hljs-string">"Not Found"</span></span> ); resp.append_header( restinio::<span class="hljs-keyword"><span class="hljs-keyword">http_field_t</span></span>::server, <span class="hljs-string"><span class="hljs-string">"Shrimp draft server"</span></span> ); resp.append_header_date_field(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( req-&gt;header().should_keep_alive() ) resp.connection_keep_alive(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> resp.connection_close(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> resp.done(); }</code> </pre> <br>  El primer punto clave con do_404_response () es que esta funci√≥n se llama en el contexto de trabajo del agente transform_manager y no en el contexto de trabajo del servidor HTTP. <br><br>  El segundo punto clave es la llamada al m√©todo done () en el objeto resp totalmente formado.  Toda la magia asincr√≥nica con una respuesta HTTP ocurre aqu√≠.  El m√©todo done () toma toda la informaci√≥n preparada en resp y la env√≠a asincr√≥nicamente al servidor HTTP.  Es decir  Se producir√° un retorno de do_404_response () inmediatamente despu√©s de que el contenido del objeto resp est√© en cola por el servidor HTTP. <br><br>  El servidor HTTP en su contexto de trabajo detectar√° la presencia de una nueva respuesta HTTP y comenzar√° a realizar las acciones necesarias para enviar la respuesta al cliente apropiado. <br><br><h3>  Escriba datasizable_blob_t </h3><br>  Otro peque√±o punto que tiene sentido aclarar, porque probablemente es incomprensible sin comprender las complejidades de RESTinio.  Estamos hablando de la presencia de, a primera vista, un tipo extra√±o de datasizeable_blob_t, definido de la siguiente manera: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">datasizable_blob_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::enable_shared_from_this&lt; <span class="hljs-keyword"><span class="hljs-keyword">datasizable_blob_t</span></span> &gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_blob.data(); } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_blob.length(); } Magick::Blob m_blob; <span class="hljs-comment"><span class="hljs-comment">//! Value for `Last-Modified` http header field. const std::time_t m_last_modified_at{ std::time( nullptr ) }; };</span></span></code> </pre> <br>  Para explicar por qu√© se necesita este tipo, debe mostrar c√≥mo se forma una respuesta HTTP con una imagen transformada: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serve_transformed_image</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( restinio::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">request_handle_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">datasizable_blob_shared_ptr_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> blob, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">image_format_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> img_format, http_header::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">image_src_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> image_src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">header_fields_list_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header_fields )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> resp = req-&gt;create_response(); set_common_header_fields_for_image_resp( blob-&gt;m_last_modified_at, resp ) .append_header( restinio::http_field::content_type, image_content_type_from_img_format( img_format ) ) .append_header( http_header::shrimp_image_src, image_src_to_str( image_src ) ) .set_body( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( blob ) ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; hf : header_fields ) { resp.append_header( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( hf.m_name ), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( hf.m_value ) ); } resp.done(); }</code> </pre> <br>  Prestamos atenci√≥n a la llamada a set_body (): un puntero inteligente a la instancia datasizable_blob_t se env√≠a directamente all√≠.  Por qu√© <br><br>  El hecho es que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RESTinio admite varias opciones para formar el cuerpo de una respuesta HTTP</a> .  Lo m√°s simple es pasar una instancia de tipo std :: string a set_body () y RESTinio guardar√° el valor de esta cadena dentro del objeto resp. <br><br>  Pero hay momentos en que el valor de set_body () debe reutilizarse en varias respuestas a la vez.  Por ejemplo, en el camar√≥n esto sucede cuando el camar√≥n recibe varias solicitudes id√©nticas para la transformaci√≥n de la misma imagen.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este caso, no es rentable copiar el mismo valor en cada respuesta. </font><font style="vertical-align: inherit;">Por lo tanto, en RESTinio hay una variante set_body () de la forma:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_body</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">shared_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;T&gt; body)</span></span></span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero en este caso, se impone una limitaci√≥n importante sobre el tipo T: debe contener los m√©todos de datos p√∫blicos () y tama√±o (), que son necesarios para que RESTinio pueda acceder al contenido de la respuesta. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La imagen escalada en camarones se almacena como un objeto Magick :: Blob. </font><font style="vertical-align: inherit;">Hay un m√©todo de datos en el tipo Magic :: Blob, pero no hay un m√©todo size (), pero s√≠ un m√©todo length (). </font><font style="vertical-align: inherit;">Por lo tanto, necesit√°bamos la clase de contenedor datasizable_blob_t, que proporciona a RESTinio la interfaz necesaria para acceder al valor de Magick :: Blob.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mensajes peri√≥dicos en transform_manager </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El agente transform_manager necesita hacer varias cosas de vez en cuando: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Extraiga las im√°genes que han estado en el cach√© durante demasiado tiempo desde el cach√©. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> controle el tiempo que pasan las solicitudes en la cola de espera de los transformadores libres. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El agente transform_manager realiza estas acciones a trav√©s de mensajes peri√≥dicos. </font><font style="vertical-align: inherit;">Se ve de la siguiente manera. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primero, se determinan los tipos de se√±ales que se utilizar√°n como mensajes peri√≥dicos:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">clear_cache_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">signal_t</span></span> {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">check_pending_requests_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">signal_t</span></span> {};</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Luego, el agente se suscribe, incluidas estas se√±ales: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::so_define_agent() { so_subscribe_self() .event( &amp;<span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_resize_request ) .event( &amp;<span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_resize_result ) .event( &amp;<span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_clear_cache ) .event( &amp;<span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_check_pending_requests ); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_clear_cache( <span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">clear_cache_t</span></span>&gt; ) {...} <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_check_pending_requests( <span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">check_pending_requests_t</span></span>&gt; ) {...}</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gracias a la suscripci√≥n, SObjectizer llamar√° al controlador deseado cuando el agente reciba la se√±al correspondiente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y solo queda ejecutar mensajes peri√≥dicos cuando se inicia el agente:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::so_evt_start() { m_clear_cache_timer = so_5::send_periodic&lt;<span class="hljs-keyword"><span class="hljs-keyword">clear_cache_t</span></span>&gt;( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, clear_cache_period, clear_cache_period ); m_check_pending_timer = so_5::send_periodic&lt;<span class="hljs-keyword"><span class="hljs-keyword">check_pending_requests_t</span></span>&gt;( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, check_pending_period, check_pending_period ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El punto clave aqu√≠ es guardar timer_id, que son devueltos por las funciones send_periodic (). </font><font style="vertical-align: inherit;">Despu√©s de todo, una se√±al peri√≥dica solo llegar√° mientras su timer_id est√© vivo. </font><font style="vertical-align: inherit;">Por lo tanto, si el valor de retorno de send_periodic () no se guarda, el env√≠o de un mensaje peri√≥dico se cancelar√° de inmediato. </font><font style="vertical-align: inherit;">Por lo tanto, la clase a_transform_manager_t tiene los siguientes atributos:</font></font><br><br><pre> <code class="cpp hljs">so_5::<span class="hljs-keyword"><span class="hljs-keyword">timer_id_t</span></span> m_clear_cache_timer; so_5::<span class="hljs-keyword"><span class="hljs-keyword">timer_id_t</span></span> m_check_pending_timer;</code> </pre> <br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fin de la primera parte. </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hoy presentamos al lector la implementaci√≥n m√°s simple y minimalista de camarones. Esta implementaci√≥n es suficiente para mostrar c√≥mo RESTinio y SObjectizer se pueden usar juntos para algo m√°s o menos como una tarea real, en lugar de un simple HelloWorld. Pero tiene una serie de fallas graves. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por ejemplo, en el agente transform_manager hay una cierta comprobaci√≥n de unicidad de la solicitud. Pero solo funciona si la imagen transformada ya est√° en el cach√©. Si todav√≠a no hay una imagen en el cach√© y al mismo tiempo llegan dos solicitudes id√©nticas para la misma imagen, ambas solicitudes se enviar√°n para su procesamiento. Lo que no es bueno Ser√≠a correcto procesar solo uno de ellos y posponer el segundo hasta que se complete el procesamiento del primero.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tal control m√°s avanzado sobre la unicidad de las solicitudes conducir√≠a a un c√≥digo transform_manager mucho m√°s complejo y voluminoso. Por lo tanto, no comenzamos a implementarlo de inmediato, sino que decidimos seguir el camino evolutivo, de simple a complejo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s, la versi√≥n m√°s simple de camarones es una "caja negra" que no muestra signos de su trabajo. Lo cual no es muy conveniente tanto durante la prueba como durante la operaci√≥n. Por lo tanto, en el buen sentido, los camarones tambi√©n deber√≠an agregar la tala. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trataremos de eliminar estas y otras deficiencias de la primera versi√≥n de camarones en futuras versiones y las describiremos en futuros art√≠culos. As√≠ que estad atentos.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si alguien tiene preguntas sobre la l√≥gica del camar√≥n, RESTinio o SObjectizer, estaremos encantados de responder en los comentarios. </font><font style="vertical-align: inherit;">Adem√°s, el camar√≥n en s√≠ es un proyecto de demostraci√≥n, pero si alguien est√° interesado en su funcionalidad y le gustar√≠a ver en el camar√≥n algo m√°s que la operaci√≥n de cambio de tama√±o, h√°ganos saber, estaremos encantados de escuchar cualquier idea constructiva. .</font></font><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Continuar√° ...</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es416387/">https://habr.com/ru/post/es416387/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es416375/index.html">Conceptos b√°sicos de JavaScript para principiantes</a></li>
<li><a href="../es416377/index.html">Nos convertimos en magos en la programaci√≥n. Parte 1</a></li>
<li><a href="../es416379/index.html">Neurobugurt C√≥mo ense√±amos a la red neuronal a inventar memes un a√±o antes que Stanford</a></li>
<li><a href="../es416381/index.html">Informe del Club de Roma 2018, Cap√≠tulo 3.13: Filantrop√≠a, Inversi√≥n, Crowdsourcing y Blockchain</a></li>
<li><a href="../es416385/index.html">Si la correlaci√≥n sale al 100%, en alg√∫n lugar se ha introducido un error: la experiencia de pasant√≠a en Rambler Group</a></li>
<li><a href="../es416391/index.html">Optimizaci√≥n de la colocaci√≥n de m√°quinas virtuales en servidores.</a></li>
<li><a href="../es416393/index.html">Conferencia IIDF: las corporaciones no son vs startups</a></li>
<li><a href="../es416397/index.html">Automatizamos las pruebas de IU de las aplicaciones de Android utilizando el patr√≥n de Objeto de p√°gina</a></li>
<li><a href="../es416399/index.html">C√≥mo analizamos las revisiones de aplicaciones m√≥viles usando el aprendizaje autom√°tico</a></li>
<li><a href="../es416401/index.html">Blender: modelo 3D de un chip para conectarse a la biblioteca KiCad</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>