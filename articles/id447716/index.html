<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¹ ğŸ“¬ ğŸï¸ Unity: menggambar banyak bar kesehatan dalam satu drawcall ğŸ¤ ğŸ¤š ğŸšŒ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Baru-baru ini, saya perlu menyelesaikan masalah yang cukup umum di banyak permainan papan atas: untuk menampilkan di layar sejumlah bar kesehatan musu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unity: menggambar banyak bar kesehatan dalam satu drawcall</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/447716/">  Baru-baru ini, saya perlu menyelesaikan masalah yang cukup umum di banyak permainan papan atas: untuk menampilkan di layar sejumlah bar kesehatan musuh.  Sesuatu seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/14e/081/95e/14e08195e0e331c7f24a8ba50c556d7e.png"></div><br>  Jelas, saya ingin melakukan ini seefisien mungkin, lebih disukai dalam satu panggilan undian.  Seperti biasa, sebelum mulai bekerja, saya melakukan sedikit riset online tentang keputusan orang lain, dan hasilnya sangat berbeda. <br><br>  Saya tidak akan mempermalukan siapa pun atas kode tersebut, tetapi cukup untuk mengatakan bahwa beberapa solusi tidak sepenuhnya brilian, misalnya, seseorang menambahkan objek Kanvas ke setiap musuh (yang sangat tidak efisien). <br><br>  Metode yang saya hasilkan sedikit berbeda dari semua yang saya lihat pada orang lain, dan sama sekali tidak menggunakan kelas UI (termasuk Canvas), jadi saya memutuskan untuk mendokumentasikannya untuk umum.  Dan bagi mereka yang ingin mempelajari kode sumber, saya mempostingnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di Github</a> . <br><a name="habracut"></a><br><h2>  Mengapa tidak menggunakan Canvas? </h2><br>  Satu kanvas untuk setiap musuh jelas merupakan keputusan yang buruk, tetapi saya dapat menggunakan kanvas umum untuk semua musuh;  kanvas tunggal juga akan menyebabkan rendering panggilan batch. <br><br>  Namun, saya tidak suka jumlah pekerjaan yang dilakukan di setiap frame terkait dengan pendekatan ini.  Jika Anda menggunakan Kanvas, maka di setiap bingkai Anda harus melakukan operasi berikut: <br><br><ul><li>  Tentukan musuh mana yang ada di layar, dan pilih masing-masing dari strip UI pool. </li><li>  Proyeksikan posisi musuh di kamera untuk memposisikan strip. </li><li>  Ubah ukuran bagian "isi" strip, mungkin seperti Gambar. </li><li>  Kemungkinan besar mengubah ukuran strip sesuai dengan jenis musuh;  misalnya, musuh besar harus memiliki strip besar sehingga tidak terlihat konyol. </li></ul><br>  Bagaimanapun, semua ini akan mencemari buffer geometri Kanvas dan mengarah ke pembangunan kembali semua data titik dalam prosesor.  Saya tidak ingin semua ini dilakukan untuk elemen sederhana. <br><br><h2>  Secara singkat tentang keputusan saya </h2><br>  Deskripsi singkat tentang proses kerja saya: <br><br><ul><li>  Kami melampirkan objek strip energi ke musuh dalam 3D. <br><ul><li>  Ini memungkinkan Anda untuk mengatur dan memotong strip secara otomatis. </li><li>  Posisi / ukuran strip dapat disesuaikan sesuai dengan jenis musuh. </li><li>  Kami akan mengarahkan strip ke kamera dalam kode menggunakan transform, yang masih ada. </li><li>  Shader memastikan bahwa mereka selalu membuat di atas segalanya. </li></ul></li><li>  Kami menggunakan Instancing untuk merender semua strip dalam satu panggilan undian. </li><li>  Kami menggunakan koordinat UV prosedural sederhana untuk menampilkan tingkat kepenuhan strip. </li></ul><br>  Sekarang mari kita lihat solusinya secara lebih rinci. <br><br><h2>  Apa itu Instancing? </h2><br>  Dalam bekerja dengan grafik, teknik standar telah digunakan untuk waktu yang lama: beberapa objek digabungkan bersama-sama sehingga mereka memiliki data dan materi vertex yang sama dan mereka dapat dirender dalam satu panggilan draw.  Inilah yang kami butuhkan, karena setiap panggilan undian adalah beban tambahan pada CPU dan GPU.  Alih-alih membuat satu panggilan undian untuk setiap objek, kami membuat semuanya sekaligus dan menggunakan shader untuk menambahkan variabilitas pada setiap salinan. <br><br>  Anda dapat melakukan ini secara manual dengan menduplikasi data titik simpul X kali dalam satu buffer, di mana X adalah jumlah maksimum salinan yang dapat dirender, dan kemudian menggunakan array parameter shader untuk mengkonversi / warna / memvariasikan setiap salinan.  Setiap salinan harus menyimpan pengetahuan tentang apa nomor bernomor itu, untuk menggunakan nilai ini sebagai indeks array.  Kemudian kita dapat menggunakan panggilan render yang diindeks, yang memerintahkan "render only to N", di mana N adalah jumlah instance yang <em>sebenarnya</em> dibutuhkan dalam frame saat ini, kurang dari jumlah maksimum X. <br><br>  Sebagian besar API modern sudah memiliki kode untuk ini, jadi Anda tidak perlu melakukan ini secara manual.  Operasi ini disebut "Instancing";  pada kenyataannya, itu mengotomatiskan proses yang dijelaskan di atas dengan batasan yang telah ditentukan. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mesin Unity juga mendukung instancing</a> , ia memiliki API sendiri dan seperangkat makro shader yang membantu dalam implementasinya.  Ini menggunakan asumsi tertentu, misalnya, bahwa setiap instance memerlukan transformasi 3D penuh.  Sebenarnya, untuk strip 2D tidak diperlukan sepenuhnya - kita dapat melakukannya dengan penyederhanaan, tetapi karena itu, kita akan menggunakannya.  Ini akan menyederhanakan shader kami, dan juga menyediakan kemampuan untuk menggunakan indikator 3D, misalnya lingkaran atau busur. <br><br><h2>  Kelas bisa rusak </h2><br>  Musuh kita akan memiliki komponen yang disebut <code>Damageable</code> , memberi mereka kesehatan dan memungkinkan mereka untuk mengambil kerusakan dari tabrakan.  Dalam contoh kita, ini cukup sederhana: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Damageable</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MaxHealth; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DamageForceThreshold = <span class="hljs-number"><span class="hljs-number">1f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DamageForceScale = <span class="hljs-number"><span class="hljs-number">5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CurrentHealth { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CurrentHealth = MaxHealth; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnCollisionEnter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Collision other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Collision would usually be on another component, putting it all here for simplicity float force = other.relativeVelocity.magnitude; if (force &gt; DamageForceThreshold) { CurrentHealth -= (int)((force - DamageForceThreshold) * DamageForceScale); CurrentHealth = Mathf.Max(0, CurrentHealth); } } }</span></span></code> </pre> <br><h2>  Obyek HealthBar: Posisi / Putar </h2><br>  Objek bar kesehatan sangat sederhana: pada kenyataannya, itu hanya Quad yang melekat pada musuh. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/be5/2ef/6e2/be52ef6e247fca661f9136e2835bb5dc.png"><br><br>  Kami menggunakan <strong>skala</strong> objek ini untuk membuat strip panjang dan tipis, dan menempatkannya langsung di atas musuh.  Jangan khawatir tentang rotasi, kami akan memperbaikinya menggunakan kode yang dilampirkan ke objek di <code>HealthBar.cs</code> : <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AlignCamera</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mainCamera != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> camXform = mainCamera.transform; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> forward = transform.position - camXform.position; forward.Normalize(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> up = Vector3.Cross(forward, camXform.right); transform.rotation = Quaternion.LookRotation(forward, up); } }</code> </pre> <br>  Kode ini selalu mengarahkan quad ke arah kamera.  Kita <em>dapat</em> melakukan pengubahan ukuran dan rotasi dalam shader, tetapi saya menerapkannya di sini karena dua alasan. <br><br>  Pertama, pemasangan Unity selalu menggunakan transformasi lengkap dari setiap objek, dan karena kami tetap mentransfer semua data, Anda dapat menggunakannya.  Kedua, mengatur skala / rotasi di sini memastikan bahwa jajar genjang untuk memotong strip akan selalu benar.  Jika kita membuat tugas ukuran dan rotasi sebagai tanggung jawab shader, maka Unity dapat memotong strip yang seharusnya terlihat ketika mereka dekat dengan tepi layar, karena ukuran dan rotasi jajaran genjang pembatasnya tidak akan sesuai dengan apa yang akan kita render.  Tentu saja, kami dapat menerapkan metode pemotongan kami sendiri, tetapi biasanya lebih baik menggunakan apa yang kami miliki jika memungkinkan (Kode Unity adalah asli dan memiliki akses ke lebih banyak data spasial daripada yang kami lakukan). <br><br>  Saya akan menjelaskan bagaimana strip diberikan setelah kita melihat shader. <br><br><h2>  Shader HealthBar </h2><br>  Dalam versi ini, kita akan membuat strip merah-hijau klasik sederhana. <br><br>  Saya menggunakan tekstur 2x1 dengan satu piksel hijau di sebelah kiri dan satu merah di kanan.  Secara alami, saya mematikan pemetaan, pemfilteran, dan kompresi, dan mengatur parameter mode pengalamatan ke Clamp, yang berarti bahwa piksel di strip kami akan selalu berwarna hijau atau merah sempurna, dan tidak akan menyebar di tepinya.  Ini akan memungkinkan kita untuk mengubah koordinat tekstur dalam shader untuk menggeser garis yang membagi piksel merah dan hijau ke bawah dan ke atas strip. <br><br>  <em>(Karena hanya ada dua warna di sini, saya hanya bisa menggunakan fungsi langkah dalam shader untuk kembali ke titik satu atau yang lain. Namun, metode ini nyaman karena Anda dapat menggunakan tekstur yang lebih kompleks jika diinginkan, dan ini akan bekerja sama saat transisi berada di tekstur pertengahan.)</em> <br><br>  Pertama, kami akan mendeklarasikan properti yang kami butuhkan: <br><br><pre> <code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"UI/HealthBar"</span></span> { Properties { _MainTex (<span class="hljs-string"><span class="hljs-string">"Texture"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} _Fill (<span class="hljs-string"><span class="hljs-string">"Fill"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>) = <span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br>  <code>_MainTex</code> adalah tekstur merah-hijau, dan <code>_Fill</code> adalah nilai dari 0 hingga 1, di mana 1 adalah kesehatan penuh. <br><br>  Selanjutnya, kita perlu memesan strip untuk membuat dalam antrian overlay, yang berarti mengabaikan semua kedalaman dalam adegan dan membuat di atas segalanya: <br><br><pre> <code class="cpp hljs"> SubShader { Tags { <span class="hljs-string"><span class="hljs-string">"Queue"</span></span>=<span class="hljs-string"><span class="hljs-string">"Overlay"</span></span> } Pass { ZTest Off</code> </pre> <br>  Bagian selanjutnya adalah kode shader itu sendiri.  Kami sedang menulis shader tanpa penerangan (tidak menyala), jadi kami tidak perlu khawatir tentang integrasi dengan berbagai shader permukaan Persatuan, ini hanya beberapa shader vertex / fragmen.  Pertama, tulis bootstrap: <br><br><pre> <code class="cpp hljs"> CGPROGRAM <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> vertex vert #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> fragment frag #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> multi_compile_instancing #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"UnityCG.cginc"</span></span></span></span></code> </pre> <br>  Untuk sebagian besar, ini adalah bootstrap standar, dengan pengecualian <code>#pragma multi_compile_instancing</code> , yang memberi tahu kompilator Unity apa yang perlu dikompilasi untuk Instancing. <br><br>  Struktur vertex harus menyertakan data instan, jadi kami akan melakukan hal berikut: <br><br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">appdata</span></span></span><span class="hljs-class"> {</span></span> float4 vertex : POSITION; float2 uv : TEXCOORD0; UNITY_VERTEX_INPUT_INSTANCE_ID };</code> </pre> <br>  Kita juga perlu menentukan apa yang sebenarnya akan ada dalam data instance, di samping proses Unity (transform) untuk kita: <br><br><pre> <code class="cpp hljs"> UNITY_INSTANCING_BUFFER_START(Props) UNITY_DEFINE_INSTANCED_PROP(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>, _Fill) UNITY_INSTANCING_BUFFER_END(Props)</code> </pre> <br>  Jadi kami melaporkan bahwa Unity harus membuat buffer yang disebut "Props" untuk menyimpan data untuk setiap instance, dan di dalamnya kami akan menggunakan satu float per instance untuk properti yang disebut <code>_Fill</code> . <br><br>  Anda dapat menggunakan beberapa buffer;  perlu dilakukan jika Anda memiliki beberapa properti yang diperbarui pada frekuensi yang berbeda;  membaginya, Anda dapat, misalnya, tidak mengubah satu buffer ketika mengubah yang lain, yang lebih efisien.  Tetapi kita tidak membutuhkan ini. <br><br>  Vertex shader kami hampir sepenuhnya berfungsi dengan baik, karena ukuran, posisi, dan rotasi sudah ditransfer untuk diubah.  Ini diimplementasikan menggunakan <code>UnityObjectToClipPos</code> , yang secara otomatis menggunakan transformasi dari setiap instance.  Orang bisa membayangkan bahwa tanpa membuat instance ini biasanya akan menjadi penggunaan sederhana dari properti matriks tunggal.  tetapi ketika menggunakan instancing di dalam mesin, itu terlihat seperti array matriks, dan Unity secara mandiri memilih matriks yang cocok untuk instance ini. <br><br>  Selain itu, Anda perlu mengubah UV untuk mengubah lokasi titik transisi dari merah ke hijau sesuai dengan properti <code>_Fill</code> .  Berikut ini cuplikan kode yang relevan: <br><br><pre> <code class="cpp hljs"> UNITY_SETUP_INSTANCE_ID(v); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> fill = UNITY_ACCESS_INSTANCED_PROP(Props, _Fill); <span class="hljs-comment"><span class="hljs-comment">// generate UVs from fill level (assumed texture is clamped) o.uv = v.uv; o.uv.x += 0.5 - fill;</span></span></code> </pre> <br>  <code>UNITY_SETUP_INSTANCE_ID</code> dan <code>UNITY_ACCESS_INSTANCED_PROP</code> melakukan semua keajaiban dengan mengakses versi properti <code>_Fill</code> dari buffer konstan untuk instance ini. <br><br>  Kita tahu bahwa dalam keadaan normal, koordinat UV segi empat mencakup seluruh interval tekstur, dan bahwa garis pemisah strip berada di tengah tekstur secara horizontal.  Oleh karena itu, perhitungan matematis kecil menggeser strip secara horizontal ke kiri atau ke kanan, dan nilai Clamp dari tekstur memastikan pengisian bagian yang tersisa. <br><br>  Shader fragmen tidak bisa lebih sederhana karena semua pekerjaan telah dilakukan: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tex2D(_MainTex, i.uv);</code> </pre> <br>  Kode shader komentar lengkap tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori GitHub</a> . <br><br><h2>  Bahan Healthbar </h2><br>  Maka semuanya sederhana - kita hanya perlu menetapkan materi yang digunakan shader ini pada strip kita.  Hampir tidak ada lagi yang perlu dilakukan, cukup pilih shader yang diinginkan di bagian atas, tetapkan tekstur merah-hijau, dan, yang paling penting, <strong>centang kotak "Enable GPU Instancing"</strong> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/06e/6e0/dcd/06e6e0dcd1965aa73f1dbbcf64e90a22.png" alt="gambar"><br><br><h2>  HealthBar Isi Pembaruan Properti </h2><br>  Jadi, kita memiliki objek bar kesehatan, shader, dan material yang akan dirender, sekarang kita perlu mengatur properti <code>_Fill</code> untuk setiap instance.  Kami melakukan ini di dalam <code>HealthBar.cs</code> sebagai berikut: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateParams</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { meshRenderer.GetPropertyBlock(matBlock); matBlock.SetFloat(<span class="hljs-string"><span class="hljs-string">"_Fill"</span></span>, damageable.CurrentHealth / (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)damageable.MaxHealth); meshRenderer.SetPropertyBlock(matBlock); }</code> </pre> <br>  Kami mengubah <code>CurrentHealth</code> class menjadi nilai dari 0 hingga 1, membaginya dengan <code>MaxHealth</code> .  Lalu kami meneruskannya ke properti <code>_Fill</code> menggunakan <code>MaterialPropertyBlock</code> . <br><br>  Jika Anda belum pernah menggunakan <code>MaterialPropertyBlock</code> untuk mentransfer data ke shader, bahkan tanpa membuat instance, maka Anda perlu mempelajarinya.  Ini tidak dijelaskan dengan baik dalam dokumentasi Unity, tetapi ini adalah cara paling efisien untuk mentransfer data dari setiap objek ke shader. <br><br>  Dalam kasus kami, ketika instancing digunakan, nilai-nilai untuk semua bar kesehatan dikemas dalam buffer konstan sehingga mereka dapat ditransfer bersama-sama dan ditarik pada suatu waktu. <br><br>  Hampir tidak ada apa-apa di sini kecuali boilerplate untuk mengatur variabel, dan kodenya agak membosankan;  lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gudang GitHub untuk</a> detailnya. <br><br><h2>  Demo </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Repositori GitHub</a> memiliki demo uji di mana sekelompok kubus biru jahat dihancurkan oleh bola merah heroik (hore!), Mengambil kerusakan yang ditampilkan oleh garis-garis yang dijelaskan dalam artikel.  Demo ditulis dalam Unity 2018.3.6f1. <br><br>  Efek menggunakan instancing dapat diamati dengan dua cara: <br><br><h3>  Panel Statistik </h3><br>  Setelah mengklik Play, klik tombol Stats di atas panel Game.  Di sini Anda dapat melihat berapa banyak panggilan draw yang disimpan berkat pemasangan: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad0/f25/204/ad0f25204bb3daf73a2c3700fd185938.png" alt="gambar"><br><br>  Setelah meluncurkan game, Anda dapat mengklik materi HealthBar dan <em>menghapus centang pada kotak</em> "Aktifkan GPU Instancing", setelah itu jumlah panggilan yang disimpan akan dikurangi menjadi nol. <br><br><h3>  Bingkai debugger </h3><br>  Setelah meluncurkan game, pergi ke Window&gt; Analysis&gt; Frame Debugger, dan kemudian klik "Enable" di jendela yang muncul. <br><br>  Di kiri bawah Anda akan melihat semua operasi rendering dilakukan.  Perhatikan bahwa meskipun ada banyak tantangan terpisah untuk musuh dan peluru (jika Anda mau, Anda dapat menerapkan instancing untuk mereka juga).  Jika Anda menggulir ke bawah, Anda akan melihat item "Draw Mesh (instanced) Healthbar". <br><br>  Panggilan tunggal ini membuat semua strip.  Jika Anda mengklik operasi ini, dan kemudian pada operasi di atasnya, Anda akan melihat bahwa semua strip menghilang, karena mereka ditarik dalam satu panggilan.  Jika berada di Frame Debugger, Anda hapus centang pada kotak centang Aktifkan GPU Instancing dari materi, Anda akan melihat bahwa satu baris berubah menjadi beberapa, dan setelah mengatur kembali bendera menjadi satu. <br><br><h2>  Cara memperluas sistem ini </h2><br>  Seperti yang saya katakan sebelumnya, karena bilah kesehatan ini adalah benda nyata, tidak ada yang menghentikan Anda dari mengubah bilah 2D sederhana menjadi sesuatu yang lebih kompleks.  Mereka bisa setengah lingkaran di bawah musuh yang berkurang dalam busur, atau memutar belah ketupat di atas kepala mereka.  Dengan menggunakan pendekatan yang sama, Anda masih dapat membuat semuanya dalam satu panggilan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id447716/">https://habr.com/ru/post/id447716/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id447704/index.html">Climbing Elbrus - Pengintaian dalam pertempuran. Bagian Teknis 1. Register, tumpukan dan detail teknis lainnya</a></li>
<li><a href="../id447706/index.html">Bukan ORM tunggal</a></li>
<li><a href="../id447708/index.html">Yandex mempersembahkan Hadiah Ilya Segalovich pertama kepada para ilmuwan muda dan pemimpin ilmiah</a></li>
<li><a href="../id447712/index.html">Hai, SaaS | SaaS Rusia 2018 - hasil</a></li>
<li><a href="../id447714/index.html">Pada penerapan teori proses ARMA dalam praktek teknik</a></li>
<li><a href="../id447718/index.html">Semuanya akan berjalan sesuai rencana</a></li>
<li><a href="../id447720/index.html">Keamanan IOT. Masalah 2. Smart Home</a></li>
<li><a href="../id447724/index.html">Bagaimana kota pintar terjadi</a></li>
<li><a href="../id447728/index.html">Kami menghitung anggaran energi saluran radio untuk satelit format CubeSat</a></li>
<li><a href="../id447730/index.html">Evolusi pemasaran email: dari QWERTYUIOP ke GDPR</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>