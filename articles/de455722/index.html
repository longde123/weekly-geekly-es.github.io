<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé≤ üèïÔ∏è üë∞üèø Python verbraucht viel Speicher oder wie kann die Gr√∂√üe von Objekten reduziert werden? üå≥ ü§≥üèº ‚ô¶Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ein Speicherproblem kann auftreten, wenn Sie w√§hrend der Programmausf√ºhrung eine gro√üe Anzahl von Objekten ben√∂tigen, insbesondere wenn die Gesamtgr√∂√ü...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python verbraucht viel Speicher oder wie kann die Gr√∂√üe von Objekten reduziert werden?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455722/"><p>  Ein Speicherproblem kann auftreten, wenn Sie w√§hrend der Programmausf√ºhrung eine gro√üe Anzahl von Objekten ben√∂tigen, insbesondere wenn die Gesamtgr√∂√üe des verf√ºgbaren Arbeitsspeichers eingeschr√§nkt ist. </p><br><p>  Im Folgenden finden Sie eine √úbersicht √ºber einige Methoden zum Reduzieren der Gr√∂√üe von Objekten, wodurch der f√ºr Programme in reinem Python erforderliche RAM-Speicher erheblich reduziert werden kann. </p><a name="habracut"></a><br><p> Der Einfachheit halber werden wir Strukturen in Python betrachten, um Punkte mit <code>x</code> , <code>y</code> und <code>z</code> Koordinaten mit Zugriff auf Koordinatenwerte nach Namen darzustellen. </p><br><h3 id="dict">  Dikt </h3><br><p>  In kleinen Programmen, insbesondere in Skripten, ist es recht einfach und bequem, das integrierte <code>dict</code> zur Darstellung von Strukturinformationen zu verwenden: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; ob = {'x':1, 'y':2, 'z':3} &gt;&gt;&gt; x = ob['x'] &gt;&gt;&gt; ob['y'] = y</code> </pre> <br><p>  Mit dem Aufkommen einer ‚Äûkompakteren‚Äú Implementierung in Python 3.6 mit einem geordneten Schl√ºsselsatz ist das <code>dict</code> noch attraktiver geworden.  Sehen Sie sich jedoch die Gr√∂√üe der Ablaufverfolgung im RAM an: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; print(sys.getsizeof(ob)) 240</code> </pre> <br><p>  Es nimmt viel Speicherplatz in Anspruch, insbesondere wenn Sie pl√∂tzlich eine gro√üe Anzahl von Instanzen erstellen m√ºssen: </p><br><div class="scrollable-table"><table><thead><tr><th>  Anzahl der Exemplare </th><th>  Trace-Gr√∂√üe </th></tr></thead><tbody><tr><td>  1.000.000 </td><td>  240 Mb </td></tr><tr><td>  10.000.000 </td><td>  2,40 GB </td></tr><tr><td>  100.000.000 </td><td>  24 GB </td></tr></tbody></table></div><br><h3 id="class-instance">  Klasseninstanz </h3><br><p>  F√ºr diejenigen, die alles in Klassen kleiden m√∂chten, ist es vorzuziehen, es als Klasse mit Zugriff √ºber den Attributnamen zu definieren: </p><br><pre> <code class="plaintext hljs">class Point: # def __init__(self, x, y, z): self.x = x self.y = y self.z = z &gt;&gt;&gt; ob = Point(1,2,3) &gt;&gt;&gt; x = ob.x &gt;&gt;&gt; ob.y = y</code> </pre> <br><p>  Die Struktur der Klasseninstanz ist interessant: </p><br><div class="scrollable-table"><table><tbody><tr><th>  Das Feld </th><th>  Gr√∂√üe (Bytes) </th></tr><tr><td>  PyGC_Head </td><td>  24 </td></tr><tr><td>  PyObject_HEAD </td><td>  16 </td></tr><tr><td>  __weakref__ </td><td>  8 </td></tr><tr><td>  __dict__ </td><td>  8 </td></tr><tr><td>  <b>GESAMT:</b> </td><td>  <b>56</b> </td></tr></tbody></table></div><br><p>  Hier ist <code>__weakref__</code> ein Link zu einer Liste sogenannter <em>schwacher Verweise</em> auf dieses Objekt. <code>__dict__</code> Feld <code>__dict__</code> ist ein Link zu einem W√∂rterbuch einer Instanz einer Klasse, die Werte von <code>__dict__</code> enth√§lt (beachten Sie, dass Links auf einer 64-Bit-Plattform 8 Byte belegen).  Ab Python 3.3 wird f√ºr alle Instanzen der Klasse ein gemeinsam genutzter W√∂rterbuchschl√ºssel verwendet.  Dies reduziert die Gr√∂√üe der Instanzablaufverfolgung im Speicher: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; print(sys.getsizeof(ob), sys.getsizeof(ob.__dict__)) 56 112</code> </pre> <br><p>  Infolgedessen hinterl√§sst eine gro√üe Anzahl von Klasseninstanzen einen geringeren Speicherbedarf als ein regul√§res W√∂rterbuch ( <code>dict</code> ): </p><br><div class="scrollable-table"><table><thead><tr><th>  Anzahl der Exemplare </th><th>  Trace-Gr√∂√üe </th></tr></thead><tbody><tr><td>  1.000.000 </td><td>  168 Mb </td></tr><tr><td>  10.000.000 </td><td>  1,68 GB </td></tr><tr><td>  100.000.000 </td><td>  16,8 GB </td></tr></tbody></table></div><br><p>  Es ist leicht zu erkennen, dass die Ablaufverfolgung der Instanz im Speicher aufgrund der Gr√∂√üe des Instanzw√∂rterbuchs immer noch gro√ü ist. </p><br><h3 id="instance-of-class-with--__slots__">  Instanz der Klasse mit __slots__ </h3><br><p>  Eine signifikante Reduzierung der Ablaufverfolgung einer Instanz im Speicher wird durch Eliminieren von <code>__dict__</code> und <code>__weakref__</code> .  Dies ist mit dem "Trick" mit <code>__slots__</code> : </p><br><pre> <code class="plaintext hljs">class Point: __slots__ = 'x', 'y', 'z' def __init__(self, x, y, z): self.x = x self.y = y self.z = z &gt;&gt;&gt; ob = Point(1,2,3) &gt;&gt;&gt; print(sys.getsizeof(ob)) 64</code> </pre> <br><p>  Die Spur im Speicher ist viel kompakter geworden: </p><br><div class="scrollable-table"><table><tbody><tr><th>  Das Feld </th><th>  Gr√∂√üe (Bytes) </th></tr><tr><td>  PyGC_Head </td><td>  24 </td></tr><tr><td>  PyObject_HEAD </td><td>  16 </td></tr><tr><td>  x </td><td>  8 </td></tr><tr><td>  y </td><td>  8 </td></tr><tr><td>  z </td><td>  8 </td></tr><tr><td>  <b>GESAMT:</b> </td><td>  <b>64</b> </td></tr></tbody></table></div><br><p>  Die Verwendung von <code>__slots__</code> in der Klassendefinition f√ºhrt dazu, dass die Ablaufverfolgung einer gro√üen Anzahl von Instanzen im Speicher erheblich reduziert wird: </p><br><div class="scrollable-table"><table><thead><tr><th>  Anzahl der Exemplare </th><th>  Trace-Gr√∂√üe </th></tr></thead><tbody><tr><td>  1.000.000 </td><td>  64 Mb </td></tr><tr><td>  10.000.000 </td><td>  640 Mb </td></tr><tr><td>  100.000.000 </td><td>  6,4 GB </td></tr></tbody></table></div><br><p>  Derzeit ist dies die Hauptmethode, um die Ablaufverfolgung einer Klasseninstanz im Programmspeicher erheblich zu reduzieren. </p><br><p>  Diese Reduzierung wird durch die Tatsache erreicht, dass im Speicher nach dem Speichern des Titels des Objekts Verweise auf Objekte gespeichert werden und der Zugriff auf diese mithilfe spezieller Deskriptoren erfolgt, die sich im Klassenw√∂rterbuch befinden: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; pprint(Point.__dict__) mappingproxy( .................................... 'x': &lt;member 'x' of 'Point' objects&gt;, 'y': &lt;member 'y' of 'Point' objects&gt;, 'z': &lt;member 'z' of 'Point' objects&gt;})</code> </pre> <br><p>  Es gibt eine <code>__slots__</code> Bibliothek, um das Erstellen einer Klasse mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">__slots__</a> zu automatisieren.  Die Funktion <code>namedlist.namedlist</code> erstellt eine Klassenstruktur, die mit der Klasse mit <code>__slots__</code> identisch ist: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; Point = namedlist('Point', ('x', 'y', 'z'))</code> </pre> <br><p>  Mit einem weiteren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">attrs-</a> Paket k√∂nnen Sie das Erstellen von Klassen mit und ohne <code>__slots__</code> . </p><br><h3 id="tuple">  Tupel </h3><br><p>  Python verf√ºgt au√üerdem √ºber einen integrierten <code>tuple</code> zur Darstellung von Datasets.  Tupel ist eine feste Struktur oder ein fester Datensatz, jedoch ohne Feldnamen.  F√ºr den Zugriff auf das Feld wird der Feldindex verwendet.  Die Tupelfelder sind zum Zeitpunkt der Instanziierung des Tupels ein f√ºr alle Mal Wertobjekten zugeordnet: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; ob = (1,2,3) &gt;&gt;&gt; x = ob[0] &gt;&gt;&gt; ob[1] = y # </code> </pre> <br><p>  Tupelinstanzen sind recht kompakt: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; print(sys.getsizeof(ob)) 72</code> </pre> <br><p>  Sie belegen 8 Byte mehr im Speicher als Klasseninstanzen mit <code>__slots__</code> , da der Tupel-Trace im Speicher auch die Anzahl der Felder enth√§lt: </p><br><div class="scrollable-table"><table><tbody><tr><th>  Das Feld </th><th>  Gr√∂√üe (Bytes) </th></tr><tr><td>  PyGC_Head </td><td>  24 </td></tr><tr><td>  PyObject_HEAD </td><td>  16 </td></tr><tr><td>  ob_size </td><td>  8 </td></tr><tr><td>  [0] </td><td>  8 </td></tr><tr><td>  [1] </td><td>  8 </td></tr><tr><td>  [2] </td><td>  8 </td></tr><tr><td>  <b>GESAMT:</b> </td><td>  <b>72</b> </td></tr></tbody></table></div><br><h3 id="namedtuple">  Namedtuple </h3><br><p>  Da Tupel sehr h√§ufig verwendet wird, gab es eines Tages die Anfrage, weiterhin auch namentlich auf die Felder zugreifen zu k√∂nnen.  Die Antwort auf diese Anfrage war das Modul <code>collections.namedtuple</code> . </p><br><p>  Die Funktion <code>namedtuple</code> den Prozess der Generierung dieser Klassen automatisieren: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; Point = namedtuple('Point', ('x', 'y', 'z'))</code> </pre> <br><p>  Es wird eine Unterklasse von Tupeln erstellt, die Handles f√ºr den Zugriff auf Felder nach Namen definiert.  In unserem Beispiel sieht es ungef√§hr so ‚Äã‚Äãaus: </p><br><pre> <code class="plaintext hljs"> class Point(tuple): # @property def _get_x(self): return self[0] @property def _get_y(self): return self[1] @property def _get_y(self): return self[2] # def __new__(cls, x, y, z): return tuple.__new__(cls, (x, y, z))</code> </pre> <br><p>  Alle Instanzen solcher Klassen haben eine Ablaufverfolgung im Speicher, die mit Tupel identisch ist.  Eine gro√üe Anzahl von Instanzen hinterl√§sst einen etwas gr√∂√üeren Speicherbedarf: </p><br><div class="scrollable-table"><table><thead><tr><th>  Anzahl der Exemplare </th><th>  Trace-Gr√∂√üe </th></tr></thead><tbody><tr><td>  1.000.000 </td><td>  72 Mb </td></tr><tr><td>  10.000.000 </td><td>  720 Mb </td></tr></tbody></table></div><br><h3 id="recordclass-mutiruemyy-namedtuple-bez-gc">  Recordclass: mutiertes Namedtupel ohne GC </h3><br><p>  Da <code>namedtuple</code> und entsprechend benannte <code>namedtuple</code> nicht ver√§nderbare Objekte in dem Sinne erzeugen, dass ein <code>ob.x</code> Wertobjekt keinem anderen Wertobjekt mehr zugeordnet werden <code>ob.x</code> , ist eine Anforderung f√ºr eine mutierte benannte Tupelvariante aufgetreten.  Da Python keinen integrierten Typ hat, der mit einem Tupel identisch ist, das Zuweisungen unterst√ºtzt, wurden viele Variationen erstellt.  Wir werden uns auf die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rekordklasse konzentrieren</a> , die eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stackoverflow-</a> Bewertung erhalten hat.  Dar√ºber hinaus kann damit die Gr√∂√üe der Ablaufverfolgung eines Objekts im Speicher im Vergleich zur Gr√∂√üe einer Ablaufverfolgung von Objekten des <code>tuple</code> verringert werden. </p><br><p>  Im Paket <strong>recordclass wird der</strong> Typ <strong>recordclass.mutabletuple</strong> <code>recordclass.mutabletuple</code> , der fast identisch mit <strong>tuple</strong> ist, aber auch Zuweisungen unterst√ºtzt.  Auf dieser Basis werden Unterklassen erstellt, die fast identisch mit Namedtuples sind, aber auch die Zuweisung neuer Werte zu Feldern unterst√ºtzen (ohne neue Instanzen zu erstellen).  Die Funktion <code>namedtuple</code> automatisiert wie die Funktion <code>namedtuple</code> die Erstellung solcher Klassen: </p><br><pre> <code class="plaintext hljs"> &gt;&gt;&gt; Point = recordclass('Point', ('x', 'y', 'z')) &gt;&gt;&gt; ob = Point(1, 2, 3)</code> </pre> <br><p>  Instanzen der Klasse haben dieselbe Struktur wie <code>tuple</code> , jedoch nur ohne <code>PyGC_Head</code> : </p><br><div class="scrollable-table"><table><tbody><tr><th>  Das Feld </th><th>  Gr√∂√üe (Bytes) </th></tr><tr><td>  PyObject_HEAD </td><td>  16 </td></tr><tr><td>  ob_size </td><td>  8 </td></tr><tr><td>  x </td><td>  8 </td></tr><tr><td>  y </td><td>  8 </td></tr><tr><td>  y </td><td>  8 </td></tr><tr><td>  <b>GESAMT:</b> </td><td>  <b>48</b> </td></tr></tbody></table></div><br><p>  Standardm√§√üig <code>recordclass</code> Funktion <code>recordclass</code> eine Klasse, die nicht am Mechanismus der zirkul√§ren <code>recordclass</code> beteiligt ist.  In der Regel werden <code>namedtuple</code> und <code>recordclass</code> verwendet, um Klassen zu <code>recordclass</code> , die Datens√§tze oder einfache (nicht rekursive) Datenstrukturen darstellen.  Ihre korrekte Verwendung in Python generiert keine Zirkelverweise.  Aus diesem Grund schlie√üt die Ablaufverfolgung von Instanzen von Klassen, die von der Standardaufzeichnungsklasse <code>PyGC_Head</code> Fragment aus, das f√ºr Klassen erforderlich ist, die den zyklischen Garbage Collection-Mechanismus unterst√ºtzen (genauer gesagt: <code>PyTypeObject</code> Flag <code>PyTypeObject</code> wird im Feld <code>flags</code> in der <code>PyTypeObject</code> Struktur, die der erstellten Klasse entspricht, nicht gesetzt). </p><br><p>  Die Ablaufverfolgungsgr√∂√üe einer gro√üen Anzahl von Instanzen ist kleiner als die von Instanzen einer Klasse mit <code>__slots__</code> : </p><br><div class="scrollable-table"><table><thead><tr><th>  Anzahl der Exemplare </th><th>  Trace-Gr√∂√üe </th></tr></thead><tbody><tr><td>  1.000.000 </td><td>  48 Mb </td></tr><tr><td>  10.000.000 </td><td>  480 Mb </td></tr><tr><td>  100.000.000 </td><td>  4,8 GB </td></tr></tbody></table></div><br><h3 id="dataobject">  Datenobjekt </h3><br><p>  Eine andere in der <code>recordclass</code> vorgeschlagene L√∂sung basiert auf der Idee: die Speicherstruktur im Speicher wie in Instanzen von Klassen mit <code>__slots__</code> , aber nicht am Mechanismus der zyklischen Speicherbereinigung <code>__slots__</code> .  Die Klasse wird mit der Funktion <code>recordclass.make_dataclass</code> : </p><br><pre> <code class="plaintext hljs"> &gt;&gt;&gt; Point = make_dataclass('Point', ('x', 'y', 'z'))</code> </pre> <br><p>  Die auf diese Weise erstellte Standardklasse erstellt mutierte Instanzen. </p><br><p>  Eine andere M√∂glichkeit besteht darin, die Klassendeklaration zu verwenden, indem Sie von <code>recordclass.dataobject</code> erben: </p><br><pre> <code class="plaintext hljs">class Point(dataobject): x:int y:int z:int</code> </pre> <br><p>  Auf diese Weise erstellte Klassen generieren Instanzen, die nicht am Mechanismus der zirkul√§ren Speicherbereinigung teilnehmen.  Die Struktur der Instanz im Speicher ist dieselbe wie bei <code>__slots__</code> , jedoch ohne den <code>PyGC_Head</code> Header: </p><br><div class="scrollable-table"><table><tbody><tr><th>  Das Feld </th><th>  Gr√∂√üe (Bytes) </th></tr><tr><td>  PyObject_HEAD </td><td>  16 </td></tr><tr><td>  x </td><td>  8 </td></tr><tr><td>  y </td><td>  8 </td></tr><tr><td>  y </td><td>  8 </td></tr><tr><td>  <b>GESAMT:</b> </td><td>  <b>40</b> </td></tr></tbody></table></div><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; ob = Point(1,2,3) &gt;&gt;&gt; print(sys.getsizeof(ob)) 40</code> </pre> <br><p>  Um auf die Felder zuzugreifen, werden spezielle Deskriptoren verwendet, um auf das Feld um seinen Versatz relativ zum Anfang des Objekts zuzugreifen, die im Klassenw√∂rterbuch platziert werden: </p><br><pre> <code class="plaintext hljs">mappingproxy({'__new__': &lt;staticmethod at 0x7f203c4e6be0&gt;, ....................................... 'x': &lt;recordclass.dataobject.dataslotgetset at 0x7f203c55c690&gt;, 'y': &lt;recordclass.dataobject.dataslotgetset at 0x7f203c55c670&gt;, 'z': &lt;recordclass.dataobject.dataslotgetset at 0x7f203c55c410&gt;})</code> </pre> <br><p>  Die Trace-Gr√∂√üe einer gro√üen Anzahl von Instanzen ist f√ºr CPython so klein wie m√∂glich: </p><br><div class="scrollable-table"><table><thead><tr><th>  Anzahl der Exemplare </th><th>  Trace-Gr√∂√üe </th></tr></thead><tbody><tr><td>  1.000.000 </td><td>  40 Mb </td></tr><tr><td>  10.000.000 </td><td>  400 Mb </td></tr><tr><td>  100.000.000 </td><td>  4,0 GB </td></tr></tbody></table></div><br><h3 id="cython">  Cython </h3><br><p>  Es gibt einen Ansatz, der auf der Verwendung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cython</a> basiert.  Der Vorteil ist, dass Felder Werte von C-Sprachtypen annehmen k√∂nnen. Deskriptoren f√ºr den Zugriff auf Felder aus reinem Python werden automatisch erstellt.  Zum Beispiel: </p><br><pre> <code class="plaintext hljs">cdef class Python: cdef public int x, y, z def __init__(self, x, y, z): self.x = x self.y = y self.z = z</code> </pre> <br><p>  In diesem Fall haben die Instanzen eine noch kleinere Speichergr√∂√üe: </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; ob = Point(1,2,3) &gt;&gt;&gt; print(sys.getsizeof(ob)) 32</code> </pre> <br><p>  Ein Instanz-Trace im Speicher hat die folgende Struktur: </p><br><div class="scrollable-table"><table><tbody><tr><th>  Das Feld </th><th>  Gr√∂√üe (Bytes) </th></tr><tr><td>  PyObject_HEAD </td><td>  16 </td></tr><tr><td>  x </td><td>  4 </td></tr><tr><td>  y </td><td>  4 </td></tr><tr><td>  y </td><td>  4 </td></tr><tr><td>  ist leer </td><td>  4 </td></tr><tr><td>  <b>GESAMT:</b> </td><td>  <b>32</b> </td></tr></tbody></table></div><br><p>  Die Trace-Gr√∂√üe einer gro√üen Anzahl von Kopien ist kleiner: </p><br><div class="scrollable-table"><table><thead><tr><th>  Anzahl der Exemplare </th><th>  Trace-Gr√∂√üe </th></tr></thead><tbody><tr><td>  1.000.000 </td><td>  32 Mb </td></tr><tr><td>  10.000.000 </td><td>  320 Mb </td></tr><tr><td>  100.000.000 </td><td>  3,2 GB </td></tr></tbody></table></div><br><p>  Es ist jedoch zu beachten, dass beim Zugriff von Python-Code jedes Mal die Konvertierung von <code>int</code> in Python-Objekt und umgekehrt durchgef√ºhrt wird. </p><br><h3 id="numpy">  Numpy </h3><br><p>  Die Verwendung von mehrdimensionalen oder Datensatz-Arrays f√ºr gro√üe Datenmengen f√ºhrt zu einem Speichergewinn.  F√ºr eine effiziente Verarbeitung in reinem Python sollten Sie jedoch Verarbeitungsmethoden verwenden, die sich auf die Verwendung von Funktionen aus dem <code>numpy</code> Paket konzentrieren. </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; Point = numpy.dtype(('x', numpy.int32), ('y', numpy.int32), ('z', numpy.int32)])</code> </pre> <br><p>  Ein Array und <code>N</code> mit Nullen initialisierte Elemente werden mit der folgenden Funktion erstellt: </p><br><pre> <code class="plaintext hljs"> &gt;&gt;&gt; points = numpy.zeros(N, dtype=Point)</code> </pre> <br><p>  Die Gr√∂√üe des Arrays ist so klein wie m√∂glich: </p><br><div class="scrollable-table"><table><thead><tr><th>  Anzahl der Exemplare </th><th>  Trace-Gr√∂√üe </th></tr></thead><tbody><tr><td>  1.000.000 </td><td>  12 Mb </td></tr><tr><td>  10.000.000 </td><td>  120 Mb </td></tr><tr><td>  100.000.000 </td><td>  1,20 GB </td></tr></tbody></table></div><br><p>  Der regelm√§√üige Zugriff auf Array-Elemente und Zeichenfolgen erfordert eine Python-Objektkonvertierung <br>  in den Wert von C <code>int</code> und umgekehrt.  Das Extrahieren einer einzelnen Zeile f√ºhrt zu einem Array, das ein einzelnes Element enth√§lt.  Sein Track wird nicht so kompakt sein: </p><br><pre> <code class="plaintext hljs"> &gt;&gt;&gt; sys.getsizeof(points[0]) 68</code> </pre> <br><p>  Wie oben erw√§hnt, ist es daher im Python-Code erforderlich, Arrays mithilfe von Funktionen aus dem <code>numpy</code> Paket zu verarbeiten. </p><br><h3 id="zaklyuchenie">  Fazit </h3><br><p>  Anhand eines klaren und einfachen Beispiels konnte √ºberpr√ºft werden, ob die Community von Entwicklern und Benutzern der Python-Programmiersprache (CPython) echte M√∂glichkeiten hat, den von Objekten verwendeten Speicher erheblich zu reduzieren. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de455722/">https://habr.com/ru/post/de455722/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de455702/index.html">Effektive Zahlengenerierung in einem bestimmten Intervall</a></li>
<li><a href="../de455710/index.html">Warum brauchen wir bei Leroy Merlin eine eigene russische Entwicklungsabteilung f√ºr 200 Mitarbeiter?</a></li>
<li><a href="../de455714/index.html">Exportieren Sie Google Forms automatisch mit IFTTT und Django nach Notion</a></li>
<li><a href="../de455716/index.html">15 Best Practices f√ºr die Bereitstellung von Business Intelligence-Software</a></li>
<li><a href="../de455720/index.html">Wie wir eine Benutzeroberfl√§che f√ºr Anzeigensysteme erstellen</a></li>
<li><a href="../de455726/index.html">C ++ Enterprise Edition. Ist es m√∂glich?</a></li>
<li><a href="../de455728/index.html">Erstellen Sie Ihre fast erweiterte schwebende Aktionstaste</a></li>
<li><a href="../de455730/index.html">Installieren Sie MacOS High Sierra, wenn nur WLAN verf√ºgbar ist</a></li>
<li><a href="../de455734/index.html">Gewohnheit, es jetzt zu tun</a></li>
<li><a href="../de455736/index.html">Konsens in Kryptow√§hrungen mit Hybrid- und Multi-PoW-Mining</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>