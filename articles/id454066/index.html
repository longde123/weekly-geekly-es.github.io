<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍦 👨‍🎨 👧 Cara berhenti melupakan indeks dan mulai memeriksa rencana eksekusi dalam pengujian 💛 🤽🏽 🤛🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beberapa waktu yang lalu, sebuah cerita yang tidak menyenangkan terjadi pada saya, yang berfungsi sebagai pemicu untuk proyek kecil di github dan meng...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara berhenti melupakan indeks dan mulai memeriksa rencana eksekusi dalam pengujian</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/454066/"><img src="https://habrastorage.org/webt/cb/kk/ps/cbkkpswi947gczpzqmwkyh2pwmm.jpeg" alt="cdpv"><br><br>  Beberapa waktu yang lalu, sebuah cerita yang tidak menyenangkan terjadi pada saya, yang berfungsi sebagai pemicu untuk proyek kecil di github dan menghasilkan artikel ini. <br><br>  Hari biasa, pelepasan normal: semua tugas diperiksa naik turun oleh insinyur QA kami, jadi dengan ketenangan sapi suci kami "berguling" ke panggung.  Aplikasi berperilaku baik, dalam log - diam.  Kami memutuskan untuk beralih (tahap &lt;-&gt; prod).  Kami beralih, lihat perangkat ... <br><br>  Butuh beberapa menit, penerbangannya stabil.  Insinyur QA melakukan tes asap, memperhatikan bahwa aplikasi tersebut entah bagaimana melambat secara tidak wajar.  Kami menulis untuk menghangatkan cache. <br><br>  Beberapa menit berlalu, keluhan pertama berasal dari baris pertama: data diunduh dari pelanggan untuk waktu yang sangat lama, aplikasi melambat, perlu waktu lama untuk merespons, dll.  Kami mulai khawatir ... kami melihat log, kami mencari kemungkinan alasan. <br><a name="habracut"></a><br>  Beberapa menit kemudian, surat datang dari admin DB.  Mereka menulis bahwa waktu pelaksanaan query ke database (selanjutnya disebut sebagai database) telah menembus semua batas yang mungkin dan cenderung tak terhingga. <br><br>  Saya membuka pemantauan (saya menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JavaMelody</a> ), saya menemukan permintaan ini.  Saya memulai PGAdmin, saya mereproduksi.  Sangat panjang.  Saya menambahkan "jelaskan", saya melihat rencana eksekusi ... itu, kami lupa tentang indeks. <br><br><h2>  Mengapa review kode tidak cukup? </h2><br>  Kejadian itu banyak mengajari saya.  Ya, saya "memadamkan api" selama satu jam, membuat indeks yang tepat langsung pada prod dalam beberapa cara (jangan lupa tentang opsi CONCURRENTLY): <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> CONCURRENTLY <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> ix_pets_name <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> pets_table (name_column);</code> </pre> <br>  Setuju, ini sama dengan penyebaran dengan downtime.  Untuk aplikasi yang sedang saya kerjakan, ini tidak dapat diterima. <br><br>  Saya membuat kesimpulan dan menambahkan titik tebal khusus ke daftar periksa untuk tinjauan kode: jika saya melihat bahwa selama proses pengembangan salah satu kelas Repositori ditambahkan / diubah - Saya memeriksa migrasi sql untuk keberadaan skrip yang membuat dan mengubah indeks di sana.  Jika dia tidak ada di sana, saya menulis pertanyaan kepada penulis: apakah dia yakin bahwa indeks tidak diperlukan di sini? <br><br>  Kemungkinan indeks tidak diperlukan jika ada sedikit data, tetapi jika kita bekerja dengan tabel di mana jumlah baris dihitung dalam jutaan, kesalahan indeks bisa menjadi fatal dan mengarah pada cerita yang ditetapkan di awal artikel. <br><br>  Dalam hal ini, saya meminta penulis permintaan tarik (selanjutnya PR) untuk menjadi 100% yakin bahwa permintaan yang ia tulis dalam HQL setidaknya tercakup sebagian oleh indeks (Indeks Scan digunakan).  Untuk ini, pengembang: <br><br><ol><li>  meluncurkan aplikasi </li><li>  mencari kueri yang dikonversi (HQL -&gt; SQL) di log </li><li>  membuka PGAdmin atau alat administrasi database lainnya </li><li>  menghasilkan dalam database lokal, agar tidak mengganggu siapa pun dengan eksperimen mereka, sejumlah data dapat diterima untuk tes (catatan minimum 10K - 20K) </li><li>  memenuhi permintaan </li><li>  meminta rencana eksekusi </li><li>  hati-hati mempelajarinya dan menarik kesimpulan yang tepat </li><li>  menambah / memodifikasi indeks, memastikan bahwa rencana eksekusi sesuai dengan itu </li><li>  berhenti berlangganan dalam PR yang telah dicentang oleh cakupan permintaan </li><li>  ahli menilai risiko dan tingkat keparahan permintaan, saya dapat memeriksa kembali tindakannya </li></ol><br>  Banyak tindakan rutin dan faktor manusia, tetapi untuk beberapa waktu saya puas, dan saya hidup dengan ini. <br><br><h2>  Di perjalanan pulang </h2><br>  Mereka mengatakan itu sangat berguna setidaknya kadang-kadang untuk pergi dari tempat kerja tanpa mendengarkan musik / podcast di sepanjang jalan.  Pada saat ini, hanya dengan memikirkan kehidupan, Anda bisa sampai pada kesimpulan dan gagasan yang menarik. <br><br>  Suatu hari saya berjalan pulang dan memikirkan apa yang terjadi hari itu.  Ada beberapa ulasan, saya memeriksa masing-masing dengan daftar periksa dan melakukan serangkaian tindakan yang dijelaskan di atas.  Aku sangat lelah waktu itu, pikirku, apa-apaan ini?  Apakah tidak mungkin untuk melakukan ini secara otomatis? .. Saya mengambil langkah cepat, ingin cepat "memotong" ide ini. <br><br><h2>  Pernyataan masalah </h2><br>  Apa yang paling penting bagi pengembang dalam rencana eksekusi? <br>  Tentu saja, pemindaian seq pada sejumlah besar data yang disebabkan oleh kurangnya indeks. <br><br>  Maka, perlu dilakukan tes bahwa: <br><br><ol><li>  Dilakukan pada database dengan konfigurasi yang mirip dengan prod </li><li>  Mencegah kueri basis data yang dibuat oleh repositori JPA (Hibernate) </li><li>  Dapatkan Rencana Eksekusi </li><li>  Rencana Eksekusi Parsit, meletakkannya dalam struktur data yang nyaman untuk pemeriksaan </li><li>  Menggunakan seperangkat metode Assert yang mudah digunakan, periksa harapan.  Misalnya, pemindaian seq itu tidak digunakan. </li></ol><br><br>  Itu perlu untuk dengan cepat menguji hipotesis ini dengan membuat prototipe. <br><br><h2>  Arsitektur Solusi </h2><br><img src="https://habrastorage.org/webt/6e/2i/bz/6e2ibz7cl8roycahqee4yb1lqqq.png" alt="arsitektur checkinx"><br><br>  Masalah pertama yang harus dipecahkan adalah peluncuran tes pada database nyata yang cocok dengan versi dan pengaturan dengan yang digunakan pada prod. <br><br>  Terima kasih kepada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Docker &amp; TestContainers</a> , mereka memecahkan masalah ini. <br><br>  SqlInterceptor, ExecutionPlanQuery, ExecutionPlanParse, dan AssertService adalah antarmuka yang saat ini saya terapkan untuk Postgres.  Rencana tersebut akan diterapkan untuk database lain.  Jika Anda ingin berpartisipasi - selamat datang.  Kode ini ditulis dalam Kotlin. <br><br>  Semua ini bersama-sama saya posting di GitHub dan memanggil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">checkinx-utils</a> .  Anda tidak perlu mengulangi ini, cukup sambungkan ketergantungan ke checkinx dalam maven / gradle dan gunakan konfirmasi yang mudah.  Cara melakukan ini, saya akan jelaskan secara lebih rinci di bawah ini. <br><br><h3>  Deskripsi interaksi komponen CheckInx </h3><br><h4>  ProxyDataSource </h4><br>  Masalah pertama yang harus dipecahkan adalah intersepsi permintaan basis data yang siap dieksekusi.  Sudah dengan parameter yang ditetapkan, tanpa pertanyaan, dll. <br><br>  Untuk melakukan ini, Anda perlu membungkus sumber data nyata dalam Proksi tertentu, yang akan memungkinkan Anda untuk mengintegrasikan ke dalam pipa eksekusi permintaan dan, karenanya, mencegat mereka. <br><br>  ProxyDataSource semacam itu telah diterapkan oleh banyak orang.  Saya menggunakan solusi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ttddyy</a> siap <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pakai</a> , yang memungkinkan saya untuk menginstal Listener saya memotong permintaan yang saya butuhkan. <br><br>  Saya mengganti sumber DataSource menggunakan kelas DataSourceWrapper (BeanPostProcessor). <br><br><h4>  SqlInterceptor </h4><br>  Bahkan, metode start ()-nya menyetel Listener di proxyDataSource dan mulai memotong permintaan, menyimpannya dalam daftar pernyataan internal.  Metode stop (), masing-masing, menghapus Listener yang diinstal. <br><br><h4>  ExecutionPlanQuery </h4><br>  Di sini, permintaan awal diubah menjadi permintaan untuk rencana eksekusi.  Dalam kasus Postgres, ini merupakan tambahan untuk kata kunci kueri "JELAS". <br><br>  Lebih lanjut, kueri ini dieksekusi pada database yang sama dari testcontainders dan rencana eksekusi "mentah" (daftar baris) dikembalikan. <br><br><h4>  ExecutionPlanParser </h4><br>  Tidak nyaman untuk bekerja dengan rencana eksekusi mentah.  Oleh karena itu, saya menguraikannya menjadi pohon yang terdiri dari node (PlanNode). <br><br>  Mari kita menganalisis bidang PlanNode menggunakan contoh ExecutionPlan nyata: <br><br><pre> <code class="sql hljs">Index Scan using ix_pets_age on pets  (cost=0.29..8.77 rows=1 width=36) Index Cond: (age &lt; 10) Filter: ((name)::text = 'Jack'::text)</code> </pre> <br><div class="scrollable-table"><table><tbody><tr><th>  Properti </th><th>  Contoh </th><th>  Deskripsi </th></tr><tr><td>  mentah: String </td><td>  Pemindaian indeks menggunakan ix_pets_age pada hewan peliharaan (biaya = 0,29..8,77 baris = 1 lebar = 36) </td><td>  string sumber </td></tr><tr><td>  tabel: String? </td><td>  hewan peliharaan <br></td><td>  nama tabel </td></tr><tr><td>  target: String? </td><td>  ix_pets_age </td><td>  nama indeks </td></tr><tr><td>  cakupan: String? </td><td>  Pemindaian indeks </td><td>  penutup </td></tr><tr><td>  liputanLevel </td><td>  Setengah </td><td>  abstraksi pelapis (NOL, SETENGAH, PENUH) </td></tr><tr><td>  anak-anak: MutableList &lt;PlanNode&gt; </td><td>  - </td><td>  simpul anak </td></tr><tr><td>  properti: MutableList &lt;Pair &lt;String, String &gt;&gt; </td><td>  <i>kunci</i> : Indeks Cond, <i>nilai</i> : (usia &lt;10); <br>  <i>kunci</i> : Filter, <i>nilai</i> : ((nama) :: text = 'Jack' :: text) <br></td><td>  properti </td></tr><tr><td>  yang lain: MutableList &lt;String&gt; </td><td>  - </td><td>  Semua itu tidak dapat dikenali dalam versi checkinx saat ini </td></tr></tbody></table></div><br><h4>  AssertService </h4><br>  Dimungkinkan untuk bekerja secara normal dengan struktur data yang dikembalikan oleh parser.  CheckInxAssertService adalah serangkaian pemeriksaan pohon PlanNode yang dijelaskan di atas.  Hal ini memungkinkan Anda untuk mengatur lambda Anda sendiri dari cek atau menggunakan yang sudah ditentukan, menurut pendapat saya, yang paling populer.  Misalnya, agar kueri Anda tidak memiliki Pemindaian Seq, atau Anda ingin memastikan bahwa indeks tertentu digunakan / tidak digunakan. <br><br><h4>  Coveragelevel </h4><br>  Sangat penting Enum, saya akan jelaskan secara terpisah: <br><div class="scrollable-table"><table><tbody><tr><th>  Nilai </th><th>  Deskripsi </th></tr><tr><td>  TIDAK ADA <br></td><td>  memeriksa apakah target tertentu (indeks) tidak digunakan <br></td></tr><tr><td>  Nol <br></td><td>  indeks tidak digunakan (Pemindaian Seq) <br></td></tr><tr><td>  Setengah <br></td><td>  cakupan sebagian dari permintaan dengan indeks (Pemindaian Indeks).  Misalnya, pencarian dilakukan berdasarkan indeks, tetapi untuk data yang dihasilkan, ini merujuk pada tabel <br></td></tr><tr><td>  LENGKAP <br></td><td>  cakupan penuh kueri menurut indeks (Pemindaian Hanya Indeks) <br></td></tr><tr><td>  TIDAK DIKENAL <br></td><td>  cakupan tidak diketahui.  Untuk beberapa alasan, itu tidak mungkin untuk menginstalnya. <br></td></tr></tbody></table></div><br>  Selanjutnya, kita akan melihat beberapa contoh penggunaan. <br><br><h2>  Contoh Uji Menggunakan CheckInx </h2><br>  Saya melakukan proyek terpisah pada GitHub <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">checkinx-demo</a> , di mana saya menerapkan repositori JPA untuk tabel hewan peliharaan dan tes untuk cakupan pemeriksaan repositori, indeks, dll.  Akan berguna untuk melihat di sana sebagai titik awal. <br><br>  Anda mungkin memiliki tes seperti ini: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFindByLocation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {  <span class="hljs-comment"><span class="hljs-comment">// ARRANGE  val location = "Moscow"  //   ,      10-20.  //   TestNG      @BeforeClass  IntRange(1, 10000).forEach {      val pet = Pet()      pet.id = UUID.randomUUID()      pet.age = it      pet.location = "Saint Petersburg"      pet.name = "Jack-$it"      repository.save(pet)  }  // ACT  //     sqlInterceptor.startInterception()  //    val pets = repository.findByLocation(location)  //    sqlInterceptor.stopInterception()  // ASSERT  //         assertEquals(1, sqlInterceptor.statements.size.toLong())  // ,    ix_pets_location    (Index Scan)  checkInxAssertService.assertCoverage(CoverageLevel.HALF, "ix_pets_location", sqlInterceptor.statements[0])  //        ,      Seq Scan,        checkInxAssertService.assertCoverage(CoverageLevel.HALF, sqlInterceptor.statements[0])  // ...  ,      checkInxAssertService.assertPlan(plan) {          it.coverageLevel.level &lt; CoverageLevel.FULL.level      } }</span></span></code> </pre> <br>  Rencana implementasi dapat sebagai berikut: <br><br><pre> <code class="sql hljs">Index Scan using ix_pets_location on pets pet0_  (cost=0.29..4.30 rows=1 width=46) Index Cond: ((location)::text = 'Moscow'::text)</code> </pre> <br>  ... atau seperti ini jika kita lupa tentang indeks (tes menjadi merah): <br><br><pre> <code class="sql hljs">Seq Scan on pets pet0_  (cost=0.00..19.00 rows=4 width=84) Filter: ((location)::text = 'Moscow'::text)</code> </pre> <br>  Dalam proyek saya, saya kebanyakan menggunakan pernyataan paling sederhana, yang mengatakan bahwa tidak ada Pemindaian Seq dalam rencana eksekusi: <br><br><pre> <code class="kotlin hljs">checkInxAssertService.assertCoverage(CoverageLevel.HALF, sqlInterceptor.statements[<span class="hljs-number"><span class="hljs-number">0</span></span>])</code> </pre> <br>  Kehadiran tes semacam itu menunjukkan bahwa saya, setidaknya, mempelajari rencana implementasi. <br>  Ini juga membuat manajemen proyek lebih eksplisit, dan kemampuan mendokumentasikan dan dapat diprediksi kode meningkat. <br><br><div class="spoiler">  <b class="spoiler_title">Mode berpengalaman</b> <div class="spoiler_text">  Saya sarankan menggunakan CheckInxAssertService, tetapi jika perlu, Anda dapat mem-bypass pohon yang diurai (ExecutionPlanParser) sendiri atau, secara umum, menguraikan rencana eksekusi mentah (hasil menjalankan ExecutionPlanQuery). <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFindByLocation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {  <span class="hljs-comment"><span class="hljs-comment">// ARRANGE  val location = "Moscow"  // ACT  //     sqlInterceptor.startInterception()  //    val pets = repository.findByLocation(location)  //    sqlInterceptor.stopInterception()  // ASSERT  //  ""    val executionPlan = executionPlanQuery.execute(sqlInterceptor.statements[0])  //    -   val plan = executionPlanParser.parse(executionPlan)  assertNotNull(plan)  // ...     val rootNode = plan.rootPlanNode  assertEquals("Index Scan", rootNode.coverage)  assertEquals("ix_pets_location", rootNode.target)  assertEquals("pets pet0_", rootNode.table) }</span></span></code> </pre> </div></div><br><br><h2>  Koneksi ke proyek </h2><br>  Dalam proyek saya, saya mengalokasikan tes semacam itu ke grup terpisah, menyebutnya Tes Integrasi Intensif. <br><br>  Menghubungkan dan mulai menggunakan checkinx-utils cukup mudah.  Mari kita mulai dengan skrip build. <br><br>  Hubungkan repositori terlebih dahulu.  Suatu hari saya akan mengunggah checkinx ke maven, tetapi sekarang Anda dapat mengunduh artefak hanya dari GitHub melalui jitpack. <br><br><pre> <code class="plaintext hljs">repositories { // ...  maven { url 'https://jitpack.io' } }</code> </pre> <br>  Selanjutnya, tambahkan ketergantungan: <br><br><pre> <code class="plaintext hljs">dependencies { // ...  implementation 'com.github.tinkoffcreditsystems:checkinx-utils:0.2.0' }</code> </pre> <br>  Kami menyelesaikan koneksi dengan menambahkan konfigurasi.  Hanya Postgres yang didukung saat ini. <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Profile(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"test"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-meta"><span class="hljs-meta">@ImportAutoConfiguration(classes = [PostgresConfig::class])</span></span> <span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CheckInxConfig</span></span></span></span></code> </pre> <br>  Perhatikan profil uji.  Kalau tidak, Anda akan menemukan ProxyDataSource di prod Anda. <br><br>  PostgresConfig menghubungkan beberapa kacang: <br><br><ol><li>  DataSourceWrapper </li><li>  PostgresInterceptor </li><li>  PostgresExecutionPlanParser </li><li>  PostgresExecutionPlanQuery </li><li>  PeriksaInxAssertServiceImpl </li></ol><br>  Jika Anda memerlukan semacam penyesuaian yang tidak disediakan oleh API saat ini, Anda selalu dapat mengganti salah satu kacang dengan implementasi Anda. <br><br><h2>  Masalah yang Diketahui </h2><br>  Terkadang DataSourceWrapper gagal mengganti dataSource asli karena proksi Spring CGLIB.  Dalam hal ini, bukan DataSource yang datang ke BeanPostProcessor, tetapi ScopedProxyFactoryBean dan ada masalah dengan pengecekan tipe. <br><br>  Solusi termudah adalah dengan membuat HikariDataSource secara manual untuk pengujian.  Maka konfigurasi Anda adalah sebagai berikut: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Profile(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"test"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-meta"><span class="hljs-meta">@ImportAutoConfiguration(classes = [PostgresConfig::class])</span></span> <span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CheckInxConfig</span></span></span><span class="hljs-class"> </span></span>{  <span class="hljs-meta"><span class="hljs-meta">@Primary</span></span>  <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span>  <span class="hljs-meta"><span class="hljs-meta">@ConfigurationProperties(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"spring.datasource"</span></span></span><span class="hljs-meta">)</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dataSource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: DataSource {      <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DataSourceBuilder.create()          .type(HikariDataSource::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">i</span></span></span><span class="hljs-class">&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">/i</span></span></span><span class="hljs-class">&gt;)          .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">build</span></span></span></span>()  }  <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span>  <span class="hljs-meta"><span class="hljs-meta">@ConfigurationProperties(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"spring.datasource.configuration"</span></span></span><span class="hljs-meta">)</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dataSource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(properties: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">DataSourceProperties</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: HikariDataSource {      <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> properties.initializeDataSourceBuilder()          .type(HikariDataSource::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">i</span></span></span><span class="hljs-class">&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">/i</span></span></span><span class="hljs-class">&gt;)          .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">build</span></span></span></span>()  } }</code> </pre> <br><br><h2>  Rencana pengembangan </h2><br><ol><li>  Saya ingin mengerti jika ada orang lain selain saya yang membutuhkan ini?  Untuk melakukan ini, buat survei.  Saya akan dengan senang hati menjawab dengan jujur. </li><li>  Lihat apa yang benar-benar Anda butuhkan dan perluas daftar standar metode pengesahan. </li><li>  Tulis implementasi untuk database lain. </li><li>  Konstruksi sqlInterceptor.statements [0] tidak terlihat sangat jelas, saya ingin memperbaikinya. </li></ol><br>  Saya akan senang jika seseorang ingin bergabung dan mendapatkan kredit dengan berlatih di Kotlin. <br><br><h2>  Kesimpulan </h2><br>  Saya yakin akan ada komentar: <i>tidak mungkin untuk memprediksi bagaimana perencana kueri akan berperilaku pada prod, itu semua tergantung pada statistik yang dikumpulkan</i> . <br><br>  Memang, seorang perencana.  Menggunakan statistik yang dikumpulkan sebelumnya, itu dapat membangun rencana yang berbeda dari yang sedang diuji.  Artinya sedikit berbeda. <br><br>  Tugas perencana adalah memperbaiki, bukan memperburuk, permintaan.  Karena itu, tanpa alasan yang jelas, dia tidak akan tiba-tiba menggunakan Seq Scan, tetapi Anda bisa tanpa sadar. <br><br>  Anda perlu CheckInx sehingga saat menulis tes, jangan lupa untuk mempelajari rencana eksekusi permintaan dan mempertimbangkan kemungkinan membuat indeks, atau sebaliknya, jelas menunjukkan dengan tes bahwa tidak ada indeks yang diperlukan di sini dan Anda puas dengan Seq Scan.  Ini akan menghemat pertanyaan yang tidak perlu pada ulasan kode. <br><br><h2>  Referensi </h2><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/TinkoffCreditSystems/checkinx-utils</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/dsemyriazhko/checkinx-demo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/ttddyy/datasource-proxy</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://mvnrepository.com/artifact/org.testcontainers/postgresql</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/javamelody/javamelody/wiki</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id454066/">https://habr.com/ru/post/id454066/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id454056/index.html">Bagaimana menghubungkan cluster Kubernetes di pusat data yang berbeda</a></li>
<li><a href="../id454058/index.html">Alat praktis untuk mengukur kode C #</a></li>
<li><a href="../id454060/index.html">Tampilan tak terduga pada sirkuit asinkron yang tidak tergantung kecepatan</a></li>
<li><a href="../id454062/index.html">Telepon perusahaan - seperti pisau Swiss: untuk inventaris, obrolan, panggilan dukungan, dan pertanyaan</a></li>
<li><a href="../id454064/index.html">Kisah AI yang tak terhitung</a></li>
<li><a href="../id454070/index.html">Memilih monowheel untuk bepergian</a></li>
<li><a href="../id454072/index.html">Lima contoh kebohongan terbesar tentang 5G</a></li>
<li><a href="../id454074/index.html">DynamicData: Koleksi Dinamis, Arsitektur MVVM, dan Ekstensi Reaktif</a></li>
<li><a href="../id454076/index.html">DotNext 2019 Piter: laporan kecil</a></li>
<li><a href="../id454078/index.html">"Konten seluler" gratis, tanpa SMS dan pendaftaran. Detail penipuan megafon</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>