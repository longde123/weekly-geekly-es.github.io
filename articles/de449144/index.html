<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍⚕️ 📯 🎳 Grundlagen der JavaScript-Engine: Prototypoptimierung. Teil 2 🕝 👰🏿 🌑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Guten Tag Freunde! Der Kurs "Sicherheit von Informationssystemen" wurde gestartet. In diesem Zusammenhang teilen wir Ihnen den letzten Teil des Artike...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Grundlagen der JavaScript-Engine: Prototypoptimierung. Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/449144/">  Guten Tag Freunde!  Der Kurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Sicherheit von Informationssystemen" wurde</a> gestartet. In diesem Zusammenhang teilen wir Ihnen den letzten Teil des Artikels "Grundlagen von JavaScript-Engines: Optimierung von Prototypen" mit, dessen erster Teil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> gelesen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden kann</a> . <br><br>  Wir erinnern Sie auch daran, dass die aktuelle Veröffentlichung eine Fortsetzung dieser beiden Artikel ist: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Grundlagen von JavaScript-Engines: allgemeine Formulare und Inline-Caching.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1 "</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">" Grundlagen von JavaScript-Engines: Allgemeine Formulare und Inline-Caching.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2 "</a> . <br><br><img src="https://habrastorage.org/webt/2w/nl/r8/2wnlr8o2nlb7dcbfs4hgkbmf-hm.png"><br><br>  <b>Klassen und Prototypenprogrammierung</b> <br><br>  Nachdem wir nun wissen, wie wir schnell auf die Eigenschaften von JavaScript-Objekten zugreifen können, können wir uns die komplexere Struktur von JavaScript-Klassen ansehen.  So sieht die Klassensyntax in JavaScript aus: <br><br><pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; } getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } }</code> </pre> <a name="habracut"></a><br>  Obwohl dies ein relativ neues Konzept für JavaScript zu sein scheint, ist es nur „syntaktischer Zucker“ für die Prototyp-Programmierung, die in JavaScript immer verwendet wurde: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; } Bar.prototype.getX = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getX</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; };</code> </pre> <br>  Hier weisen wir dem Objekt <code>getX</code> Eigenschaft <code>getX</code> .  Dies funktioniert genau wie bei jedem anderen Objekt, da Prototypen in JavaScript dieselben Objekte sind.  In Prototyp-Programmiersprachen wie JavaScript wird über Prototypen auf Methoden zugegriffen, während Felder in bestimmten Instanzen gespeichert werden. <br><br>  Schauen wir uns genauer an, was passiert, wenn wir eine neue Instanz von <code>Bar</code> erstellen, die wir <code>foo</code> nennen werden. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br>  Eine mit diesem Code erstellte Instanz hat ein Formular mit einer einzelnen <code>'x'</code> Eigenschaft.  Der <code>foo</code> Prototyp ist <code>Bar.prototype</code> , der zur <code>Bar</code> Klasse gehört. <br><br><img src="https://habrastorage.org/webt/bo/fa/q_/bofaq_0uieucjmw-dys_fv6rzk8.png"><br><br>  Dieser <code>Bar.prototype</code> hat die Form von sich selbst und enthält die einzige Eigenschaft <code>'getX'</code> , deren Wert durch die Funktion <code>'getX'</code> , die beim Aufruf <code>this.x</code>  Der Prototyp <code>Bar.prototype</code> ist <code>Object.prototype</code> , der Teil der JavaScript-Sprache ist.  <code>Object.prototype</code> ist die Wurzel des Prototypbaums, während sein Prototyp <code>null</code> . <br><br><img src="https://habrastorage.org/webt/do/wd/bu/dowdbubzibagdufziezgg9sp_tq.png"><br><br>  Wenn Sie eine neue Instanz derselben Klasse erstellen, haben beide Instanzen dieselbe Form, wie wir bereits verstanden haben.  Beide Instanzen verweisen auf dasselbe <code>Bar.prototype</code> Objekt. <br><br>  <b>Zugriff auf Prototypeneigenschaften</b> <br><br>  Nun wissen wir, was passiert, wenn wir eine Klasse definieren und eine neue Instanz erstellen.  Aber was passiert, wenn wir die Methode für die Instanz aufrufen, wie im folgenden Beispiel? <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; } getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = foo.getX(); <span class="hljs-comment"><span class="hljs-comment">// ^^^^^^^^^^</span></span></code> </pre> <br>  Sie können jeden Methodenaufruf als zwei separate Schritte betrachten: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = foo.getX(); <span class="hljs-comment"><span class="hljs-comment">// is actually two steps: const $getX = foo.getX; const x = $getX.call(foo);</span></span></code> </pre><br>  Der erste Schritt besteht darin, die Methode zu laden, die eigentlich eine Eigenschaft des Prototyps ist (dessen Wert eine Funktion ist).  Der zweite Schritt besteht darin, eine Funktion mit einer Instanz aufzurufen, beispielsweise den Wert <code>this</code> .  Schauen wir uns den ersten Schritt genauer an, in dem die <code>getX</code> Methode aus der <code>foo</code> Instanz <code>getX</code> . <br><br><img src="https://habrastorage.org/webt/-o/8_/wo/-o8_wolugn73mtcs65v_yomvtzo.png"><br><br>  Die Engine startet eine Instanz von <code>foo</code> und erkennt, dass das Formular <code>foo</code> keine <code>'getX'</code> hat. <code>'getX'</code> muss es die Prototypenkette durchlaufen, um es zu finden.  Wir kommen zu <code>Bar.prototype</code> , schauen uns das Prototypformular an und sehen, dass es die Eigenschaft <code>'getX'</code> bei Nullpunktverschiebung hat.  Wir suchen den Wert an diesem Offset in <code>Bar.prototype</code> und finden die <code>JSFunction getX</code> , nach der wir gesucht haben. <br><br>  Durch die Flexibilität von JavaScript können sich Prototyp-Kettenglieder ändern, zum Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); foo.getX(); <span class="hljs-comment"><span class="hljs-comment">// → true Object.setPrototypeOf(foo, null); foo.getX(); // → Uncaught TypeError: foo.getX is not a function</span></span></code> </pre> <br>  In diesem Beispiel rufen wir an <pre> <code class="javascript hljs">foo.getX()</code> </pre>  zweimal, aber jedes Mal hat es völlig andere Bedeutungen und Ergebnisse.  Trotz der Tatsache, dass Prototypen nur Objekte in JavaScript sind, ist die Beschleunigung des Zugriffs auf Eigenschaften eines Prototyps für JavaScript-Engines eine noch wichtigere Aufgabe als die Beschleunigung des eigenen Zugriffs auf Eigenschaften regulärer Objekte. <br><br>  In der täglichen Praxis ist das Laden von Prototyp-Eigenschaften eine ziemlich häufige Operation: Dies geschieht jedes Mal, wenn Sie eine Methode aufrufen! <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; } getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = foo.getX(); <span class="hljs-comment"><span class="hljs-comment">// ^^^^^^^^^^</span></span></code> </pre> <br>  Zuvor haben wir darüber gesprochen, wie Engines das Laden regulärer Eigenschaften mithilfe von Formularen und Inline-Caches optimieren.  Wie kann ich das Laden von Prototypeneigenschaften für Objekte derselben Form optimieren?  Von oben haben wir gesehen, wie Eigenschaften geladen werden. <br><br><img src="https://habrastorage.org/webt/h1/1q/tw/h11qtwohm_mgsjyp0iphqairudo.png"><br><br>  Um dies in diesem speziellen Fall bei wiederholten Downloads schnell zu tun, müssen Sie die folgenden drei Dinge wissen: <br><br><ul><li>  Das Formular <code>foo</code> enthält kein <code>'getX'</code> und wurde nicht geändert.  Dies bedeutet, dass niemand das foo-Objekt geändert hat, indem er eine Eigenschaft hinzugefügt oder entfernt oder eines der Eigenschaftsattribute geändert hat. </li><li>  Der foo-Prototyp ist immer noch der ursprüngliche <code>Bar.prototype</code> .  Daher hat niemand den Prototyp <code>foo</code> mit <code>Object.setPrototypeOf()</code> geändert oder der speziellen Eigenschaft <code>_proto_</code> . </li><li>  Das <code>Bar.prototype</code> Formular enthält <code>'getX'</code> und wurde nicht geändert.  Dies bedeutet, dass niemand <code>Bar.prototype</code> durch Hinzufügen oder Entfernen einer Eigenschaft oder Ändern eines der Eigenschaftsattribute geändert hat. </li></ul><br>  Im allgemeinen Fall bedeutet dies, dass Sie eine Prüfung der Instanz selbst und zwei weitere Prüfungen für jeden Prototyp bis zu dem Prototyp durchführen müssen, der die gewünschte Eigenschaft enthält.  1 + 2N-Prüfungen, bei denen N die Anzahl der verwendeten Prototypen ist, klingen in diesem Fall nicht so schlecht, da die Prototypenkette relativ flach ist.  Motoren müssen jedoch häufig mit viel längeren Prototypenketten umgehen, wie dies bei regulären DOM-Klassen der Fall ist.  Zum Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> anchor = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'a'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// → HTMLAnchorElement const title = anchor.getAttribute('title');</span></span></code> </pre> <br>  Wir haben ein <code>HTMLAnchorElement</code> und rufen die Methode <code>getAttribute()</code> .  Die Kette für dieses einfache Element enthält bereits 6 Prototypen!  Die meisten DOM-Methoden, die uns interessieren, befinden sich nicht im <code>HTMLAnchorElement</code> Prototyp <code>HTMLAnchorElement</code> , sondern irgendwo in der Kette. <br><br><img src="https://habrastorage.org/webt/wz/kw/fa/wzkwfavxcgkiod8jgz0ybrmgzo8.png"><br><br>  Die Methode <code>getAttribute()</code> befindet sich in <code>Element.prototype</code> .  Dies bedeutet, dass die JavaScript-Engine jedes Mal, wenn wir <code>anchor.getAttribute()</code> aufrufen, <code>anchor.getAttribute()</code> benötigt: <br><br><ol><li>  <code>'getAttribute'</code> dass <code>'getAttribute'</code> per se kein <code>'getAttribute'</code> . </li><li>  <code>HTMLAnchorElement.prototype</code> , dass der endgültige Prototyp <code>HTMLAnchorElement.prototype</code> . </li><li>  Bestätigen Sie dort das Fehlen von <code>'getAttribute'</code> . </li><li>  <code>HTMLElement.prototype</code> , dass der nächste Prototyp <code>HTMLElement.prototype</code> . </li><li>  Bestätigen Sie das Fehlen von <code>'getAttribute'</code> . </li><li>  <code>Element.prototype</code> , dass der nächste Prototyp <code>Element.prototype</code> . </li><li>  Überprüfen Sie, ob <code>'getAttribute'</code> vorhanden ist. </li></ol><br>  Insgesamt 7 Schecks.  Da diese Art von Code im Web weit verbreitet ist, verwenden Engines verschiedene Tricks, um die Anzahl der zum Laden von Prototypeneigenschaften erforderlichen Überprüfungen zu verringern. <br><br>  Zurück zu einem früheren Beispiel, in dem wir nur drei Überprüfungen durchgeführt haben, als wir <code>'getX'</code> für <code>foo</code> <code>'getX'</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; } getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> $getX = foo.getX;</code> </pre> <br>  Für jedes Objekt, das vor dem Prototyp auftritt, der die gewünschte Eigenschaft enthält, müssen die Formulare auf das Fehlen dieser Eigenschaft überprüft werden.  Es wäre schön, wenn wir die Anzahl der Prüfungen reduzieren könnten, indem wir die Prototypprüfung als Prüfung für das Fehlen einer Eigenschaft präsentieren.  Im Wesentlichen ist dies genau das, was Engines mit einem einfachen Trick tun: Anstatt den Prototyp-Link zur Instanz selbst zu speichern, speichern die Engines ihn in Form. <br><br><img src="https://habrastorage.org/webt/_q/j1/8q/_qj18qiex6e31a17r7sgho1r5hc.png"><br><br>  Jedes Formular gibt einen Prototyp an.  Dies bedeutet, dass jedes Mal, wenn sich der Prototyp <code>foo</code> ändert, der Motor in eine neue Form wechselt.  Jetzt müssen wir nur noch die Form des Objekts überprüfen, um das Fehlen bestimmter Eigenschaften zu bestätigen und die Prototypverbindung zu schützen (die Prototypverbindung schützen). <br><br>  Mit diesem Ansatz können wir die Anzahl der erforderlichen Überprüfungen von 2N + 1 auf 1 + N reduzieren, um den Zugriff zu beschleunigen.  Dies ist immer noch eine ziemlich teure Operation, da sie immer noch eine lineare Funktion der Anzahl der Prototypen in der Kette ist.  Motoren verwenden verschiedene Tricks, um die Anzahl der Überprüfungen weiter auf einen bestimmten konstanten Wert zu reduzieren, insbesondere bei sequentiellem Laden derselben Eigenschaften. <br><br>  <b>Gültigkeitszellen</b> <br><br>  Der V8 verarbeitet Prototypformulare speziell für diesen Zweck.  Jeder Prototyp hat eine eindeutige Form, die nicht mit anderen Objekten (insbesondere mit anderen Prototypen) geteilt wird, und jeder dieser Prototypformen ist eine spezielle <code>ValidityCell</code> zugeordnet. <br><br><img src="https://habrastorage.org/webt/pm/gc/m_/pmgcm_cjj6ufzx_dw8npfdbx2wi.png"><br><br>  Diese <code>ValidityCell</code> jedes Mal deaktiviert, wenn jemand den damit verbundenen Prototyp oder einen anderen darüber liegenden Prototyp ändert.  Mal sehen, wie es funktioniert. <br>  Um nachfolgende Prototyp-Downloads zu beschleunigen, platziert V8 den Inline-Cache an einem Ort mit vier Feldern: <br><br><img src="https://habrastorage.org/webt/mr/ab/d2/mrabd2cyki6gglqlxphuqhjzoji.png"><br><br>  Wenn der Inline-Cache beim ersten Ausführen des Codes erwärmt wird, merkt sich V8 den Offset, bei dem die Eigenschaft im Prototyp gefunden wurde, diesen Prototyp (z. B. <code>Bar.prototype</code> ), das <code>Bar.prototype</code> (in unserem Fall das Formular <code>foo</code> ) und bindet auch die aktuelle <code>ValidityCell</code> an den empfangenen Prototyp aus der Instanz des Formulars (in unserem Fall wird <code>Bar.prototype</code> übernommen). <br><br>  Wenn Sie das nächste Mal den Inline-Cache verwenden, muss die Engine das Instanzformular und <code>ValidityCell</code> überprüfen.  Wenn es noch gültig ist, verwendet die Engine direkt den Offset des Prototyps und überspringt die zusätzlichen Suchschritte. <br><br><img src="https://habrastorage.org/webt/hd/qw/4w/hdqw4wkuumyd9dmm0opxan9cbji.png"><br><br>  Wenn Sie den Prototyp ändern, wird ein neues Formular hervorgehoben und die vorherige <code>ValidityCell</code> Zelle deaktiviert.  Aus diesem Grund wird der Inline-Cache beim nächsten Start übersprungen, was zu einer schlechten Leistung führt. <br><br>  Kehren wir zum Beispiel mit dem DOM-Element zurück.  Jede Änderung in <code>Object.prototype</code> nicht nur die Inline-Caches für <code>Object.prototype</code> ungültig, sondern auch für alle Prototypen in der darunter <code>EventTarget.prototype</code> Kette, einschließlich <code>EventTarget.prototype</code> , <code>Node.prototype</code> , <code>Element.prototype</code> usw. bis hin zu <code>HTMLAnchorElement.prototype</code> . <br><br><img src="https://habrastorage.org/webt/oo/ml/ga/oomlgamrgo0peti1y3xsae-vtes.png"><br><br>  Tatsächlich ist das Ändern von <code>Object.prototype</code> während der Ausführung des Codes ein schrecklicher Leistungsverlust.  Tu das nicht! <br><br>  Schauen wir uns ein konkretes Beispiel an, um besser zu verstehen, wie dies funktioniert.  <code>loadX</code> , wir haben eine <code>Bar</code> Klasse und eine <code>loadX</code> Funktion, die eine Methode für Objekte vom Typ <code>Bar</code> aufruft.  Wir rufen die <code>loadX</code> Funktion mehrmals mit Instanzen derselben Klasse auf. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* … */</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadX</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bar</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bar.getX(); <span class="hljs-comment"><span class="hljs-comment">// IC for 'getX' on `Bar` instances. } loadX(new Bar(true)); loadX(new Bar(false)); // IC in `loadX` now links the `ValidityCell` for // `Bar.prototype`. Object.prototype.newMethod = y =&gt; y; // The `ValidityCell` in the `loadX` IC is invalid // now, because `Object.prototype` changed.</span></span></code> </pre> <br>  Der Inline-Cache in <code>loadX</code> jetzt auf <code>ValidityCell</code> für <code>Bar.prototype</code> .  Wenn Sie dann den (mutierten) <code>Object.prototype</code> , der die Wurzel aller Prototypen in JavaScript darstellt, wird <code>ValidityCell</code> ungültig und vorhandene Inline-Caches werden beim nächsten Mal nicht verwendet, was zu einer schlechten Leistung führt. <br><br>  Das Ändern des <code>Object.prototype</code> ist immer eine schlechte Idee, da zum Zeitpunkt der Änderung alle Inline-Caches für geladene Prototypen ungültig werden.  Hier ist ein Beispiel, wie man NICHT macht: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.foo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* … */</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// Run critical code: someObject.foo(); // End of critical code. delete Object.prototype.foo;</span></span></code> </pre> <br>  Wir erweitern <code>Object.prototype</code> , wodurch alle von der Engine zu diesem Zeitpunkt geladenen Inline-Prototyp-Caches ungültig werden.  Dann werden wir einen Code ausführen, der die von uns beschriebene Methode verwendet.  Die Engine muss von Anfang an starten und Inline-Caches für den Zugriff auf die Prototyp-Eigenschaft konfigurieren.  Und schließlich „bereinigen“ und entfernen Sie die zuvor hinzugefügte Prototypmethode. <br><br>  Sie denken, Reinigung ist eine gute Idee, oder?  In diesem Fall wird sich die Situation weiter verschlechtern!  Durch das Entfernen von Eigenschaften wird <code>Object.prototype</code> , sodass alle Inline-Caches wieder deaktiviert werden und die Engine die Arbeit von <code>Object.prototype</code> beginnen muss. <br><br>  <b>Zusammenfassend</b> .  Obwohl Prototypen nur Objekte sind, werden sie speziell von JavaScript-Engines verarbeitet, um die Leistung der Methodensuche nach Prototypen zu optimieren.  <b>Lass die Prototypen in Ruhe!</b>  Oder wenn Sie sich wirklich mit ihnen befassen müssen, tun Sie dies, bevor Sie den Code ausführen, damit Sie zumindest nicht alle Versuche ungültig machen, Ihren Code während seiner Ausführung zu optimieren! <br><br><blockquote>  <b>Fassen Sie zusammen</b> <br><br>  Wir haben gelernt, wie JavaScript Objekte und Klassen speichert und wie Formulare, Inline-Caches und Gültigkeitszellen zur Optimierung von Prototypoperationen beitragen.  Basierend auf diesem Wissen haben wir verstanden, wie die Leistung aus praktischer Sicht verbessert werden kann: Berühren Sie keine Prototypen!  (oder wenn Sie es wirklich brauchen, tun Sie es, bevor Sie den Code ausführen). </blockquote><br>  ← <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der erste Teil</a> <br><br>  War diese Reihe von Veröffentlichungen für Sie hilfreich?  Schreiben Sie in die Kommentare. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de449144/">https://habr.com/ru/post/de449144/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de449132/index.html">Top 17 Plugins für Android Studio</a></li>
<li><a href="../de449134/index.html">Zoo afl</a></li>
<li><a href="../de449138/index.html">5 Gründe für Crypto-Hat Warum IT-Leute Bitcoin nicht mögen</a></li>
<li><a href="../de449140/index.html">Hinterlassen Sie eine Anfrage und wir werden Ihnen innerhalb von 1 Minute online antworten. Oder wie wir uns von OTRS entfernt haben</a></li>
<li><a href="../de449142/index.html">Microbiota. Welche Bakterien leben im Darm der Russen?</a></li>
<li><a href="../de449146/index.html">Aber winken wir nicht der optischen Kommunikation zu? Laser, Weltraum, CubeSat</a></li>
<li><a href="../de449148/index.html">Kunstbücher für Kinder über Social Engineering</a></li>
<li><a href="../de449154/index.html">FAQ zur obligatorischen Kennzeichnung von Schuhen: Alles, was Sie nicht wussten und Angst hatten zu fragen</a></li>
<li><a href="../de449158/index.html">Rough Coster: Gemeinschaftskochbuch</a></li>
<li><a href="../de449162/index.html">C ++ Russland 2019. Ein kleiner Bericht vom Veranstaltungsort und der Ankündigung der nächsten Konferenz in St. Petersburg</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>