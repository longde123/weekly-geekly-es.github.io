<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèΩ‚Äç‚öïÔ∏è üìØ üé≥ Grundlagen der JavaScript-Engine: Prototypoptimierung. Teil 2 üïù üë∞üèø üåë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Guten Tag Freunde! Der Kurs "Sicherheit von Informationssystemen" wurde gestartet. In diesem Zusammenhang teilen wir Ihnen den letzten Teil des Artike...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Grundlagen der JavaScript-Engine: Prototypoptimierung. Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/449144/">  Guten Tag Freunde!  Der Kurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Sicherheit von Informationssystemen" wurde</a> gestartet. In diesem Zusammenhang teilen wir Ihnen den letzten Teil des Artikels "Grundlagen von JavaScript-Engines: Optimierung von Prototypen" mit, dessen erster Teil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> gelesen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden kann</a> . <br><br>  Wir erinnern Sie auch daran, dass die aktuelle Ver√∂ffentlichung eine Fortsetzung dieser beiden Artikel ist: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûGrundlagen von JavaScript-Engines: allgemeine Formulare und Inline-Caching.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1 "</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">" Grundlagen von JavaScript-Engines: Allgemeine Formulare und Inline-Caching.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2 "</a> . <br><br><img src="https://habrastorage.org/webt/2w/nl/r8/2wnlr8o2nlb7dcbfs4hgkbmf-hm.png"><br><br>  <b>Klassen und Prototypenprogrammierung</b> <br><br>  Nachdem wir nun wissen, wie wir schnell auf die Eigenschaften von JavaScript-Objekten zugreifen k√∂nnen, k√∂nnen wir uns die komplexere Struktur von JavaScript-Klassen ansehen.  So sieht die Klassensyntax in JavaScript aus: <br><br><pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; } getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } }</code> </pre> <a name="habracut"></a><br>  Obwohl dies ein relativ neues Konzept f√ºr JavaScript zu sein scheint, ist es nur ‚Äûsyntaktischer Zucker‚Äú f√ºr die Prototyp-Programmierung, die in JavaScript immer verwendet wurde: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; } Bar.prototype.getX = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getX</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; };</code> </pre> <br>  Hier weisen wir dem Objekt <code>getX</code> Eigenschaft <code>getX</code> .  Dies funktioniert genau wie bei jedem anderen Objekt, da Prototypen in JavaScript dieselben Objekte sind.  In Prototyp-Programmiersprachen wie JavaScript wird √ºber Prototypen auf Methoden zugegriffen, w√§hrend Felder in bestimmten Instanzen gespeichert werden. <br><br>  Schauen wir uns genauer an, was passiert, wenn wir eine neue Instanz von <code>Bar</code> erstellen, die wir <code>foo</code> nennen werden. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br>  Eine mit diesem Code erstellte Instanz hat ein Formular mit einer einzelnen <code>'x'</code> Eigenschaft.  Der <code>foo</code> Prototyp ist <code>Bar.prototype</code> , der zur <code>Bar</code> Klasse geh√∂rt. <br><br><img src="https://habrastorage.org/webt/bo/fa/q_/bofaq_0uieucjmw-dys_fv6rzk8.png"><br><br>  Dieser <code>Bar.prototype</code> hat die Form von sich selbst und enth√§lt die einzige Eigenschaft <code>'getX'</code> , deren Wert durch die Funktion <code>'getX'</code> , die beim Aufruf <code>this.x</code>  Der Prototyp <code>Bar.prototype</code> ist <code>Object.prototype</code> , der Teil der JavaScript-Sprache ist.  <code>Object.prototype</code> ist die Wurzel des Prototypbaums, w√§hrend sein Prototyp <code>null</code> . <br><br><img src="https://habrastorage.org/webt/do/wd/bu/dowdbubzibagdufziezgg9sp_tq.png"><br><br>  Wenn Sie eine neue Instanz derselben Klasse erstellen, haben beide Instanzen dieselbe Form, wie wir bereits verstanden haben.  Beide Instanzen verweisen auf dasselbe <code>Bar.prototype</code> Objekt. <br><br>  <b>Zugriff auf Prototypeneigenschaften</b> <br><br>  Nun wissen wir, was passiert, wenn wir eine Klasse definieren und eine neue Instanz erstellen.  Aber was passiert, wenn wir die Methode f√ºr die Instanz aufrufen, wie im folgenden Beispiel? <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; } getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = foo.getX(); <span class="hljs-comment"><span class="hljs-comment">// ^^^^^^^^^^</span></span></code> </pre> <br>  Sie k√∂nnen jeden Methodenaufruf als zwei separate Schritte betrachten: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = foo.getX(); <span class="hljs-comment"><span class="hljs-comment">// is actually two steps: const $getX = foo.getX; const x = $getX.call(foo);</span></span></code> </pre><br>  Der erste Schritt besteht darin, die Methode zu laden, die eigentlich eine Eigenschaft des Prototyps ist (dessen Wert eine Funktion ist).  Der zweite Schritt besteht darin, eine Funktion mit einer Instanz aufzurufen, beispielsweise den Wert <code>this</code> .  Schauen wir uns den ersten Schritt genauer an, in dem die <code>getX</code> Methode aus der <code>foo</code> Instanz <code>getX</code> . <br><br><img src="https://habrastorage.org/webt/-o/8_/wo/-o8_wolugn73mtcs65v_yomvtzo.png"><br><br>  Die Engine startet eine Instanz von <code>foo</code> und erkennt, dass das Formular <code>foo</code> keine <code>'getX'</code> hat. <code>'getX'</code> muss es die Prototypenkette durchlaufen, um es zu finden.  Wir kommen zu <code>Bar.prototype</code> , schauen uns das Prototypformular an und sehen, dass es die Eigenschaft <code>'getX'</code> bei Nullpunktverschiebung hat.  Wir suchen den Wert an diesem Offset in <code>Bar.prototype</code> und finden die <code>JSFunction getX</code> , nach der wir gesucht haben. <br><br>  Durch die Flexibilit√§t von JavaScript k√∂nnen sich Prototyp-Kettenglieder √§ndern, zum Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); foo.getX(); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí true Object.setPrototypeOf(foo, null); foo.getX(); // ‚Üí Uncaught TypeError: foo.getX is not a function</span></span></code> </pre> <br>  In diesem Beispiel rufen wir an <pre> <code class="javascript hljs">foo.getX()</code> </pre>  zweimal, aber jedes Mal hat es v√∂llig andere Bedeutungen und Ergebnisse.  Trotz der Tatsache, dass Prototypen nur Objekte in JavaScript sind, ist die Beschleunigung des Zugriffs auf Eigenschaften eines Prototyps f√ºr JavaScript-Engines eine noch wichtigere Aufgabe als die Beschleunigung des eigenen Zugriffs auf Eigenschaften regul√§rer Objekte. <br><br>  In der t√§glichen Praxis ist das Laden von Prototyp-Eigenschaften eine ziemlich h√§ufige Operation: Dies geschieht jedes Mal, wenn Sie eine Methode aufrufen! <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; } getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = foo.getX(); <span class="hljs-comment"><span class="hljs-comment">// ^^^^^^^^^^</span></span></code> </pre> <br>  Zuvor haben wir dar√ºber gesprochen, wie Engines das Laden regul√§rer Eigenschaften mithilfe von Formularen und Inline-Caches optimieren.  Wie kann ich das Laden von Prototypeneigenschaften f√ºr Objekte derselben Form optimieren?  Von oben haben wir gesehen, wie Eigenschaften geladen werden. <br><br><img src="https://habrastorage.org/webt/h1/1q/tw/h11qtwohm_mgsjyp0iphqairudo.png"><br><br>  Um dies in diesem speziellen Fall bei wiederholten Downloads schnell zu tun, m√ºssen Sie die folgenden drei Dinge wissen: <br><br><ul><li>  Das Formular <code>foo</code> enth√§lt kein <code>'getX'</code> und wurde nicht ge√§ndert.  Dies bedeutet, dass niemand das foo-Objekt ge√§ndert hat, indem er eine Eigenschaft hinzugef√ºgt oder entfernt oder eines der Eigenschaftsattribute ge√§ndert hat. </li><li>  Der foo-Prototyp ist immer noch der urspr√ºngliche <code>Bar.prototype</code> .  Daher hat niemand den Prototyp <code>foo</code> mit <code>Object.setPrototypeOf()</code> ge√§ndert oder der speziellen Eigenschaft <code>_proto_</code> . </li><li>  Das <code>Bar.prototype</code> Formular enth√§lt <code>'getX'</code> und wurde nicht ge√§ndert.  Dies bedeutet, dass niemand <code>Bar.prototype</code> durch Hinzuf√ºgen oder Entfernen einer Eigenschaft oder √Ñndern eines der Eigenschaftsattribute ge√§ndert hat. </li></ul><br>  Im allgemeinen Fall bedeutet dies, dass Sie eine Pr√ºfung der Instanz selbst und zwei weitere Pr√ºfungen f√ºr jeden Prototyp bis zu dem Prototyp durchf√ºhren m√ºssen, der die gew√ºnschte Eigenschaft enth√§lt.  1 + 2N-Pr√ºfungen, bei denen N die Anzahl der verwendeten Prototypen ist, klingen in diesem Fall nicht so schlecht, da die Prototypenkette relativ flach ist.  Motoren m√ºssen jedoch h√§ufig mit viel l√§ngeren Prototypenketten umgehen, wie dies bei regul√§ren DOM-Klassen der Fall ist.  Zum Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> anchor = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'a'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí HTMLAnchorElement const title = anchor.getAttribute('title');</span></span></code> </pre> <br>  Wir haben ein <code>HTMLAnchorElement</code> und rufen die Methode <code>getAttribute()</code> .  Die Kette f√ºr dieses einfache Element enth√§lt bereits 6 Prototypen!  Die meisten DOM-Methoden, die uns interessieren, befinden sich nicht im <code>HTMLAnchorElement</code> Prototyp <code>HTMLAnchorElement</code> , sondern irgendwo in der Kette. <br><br><img src="https://habrastorage.org/webt/wz/kw/fa/wzkwfavxcgkiod8jgz0ybrmgzo8.png"><br><br>  Die Methode <code>getAttribute()</code> befindet sich in <code>Element.prototype</code> .  Dies bedeutet, dass die JavaScript-Engine jedes Mal, wenn wir <code>anchor.getAttribute()</code> aufrufen, <code>anchor.getAttribute()</code> ben√∂tigt: <br><br><ol><li>  <code>'getAttribute'</code> dass <code>'getAttribute'</code> per se kein <code>'getAttribute'</code> . </li><li>  <code>HTMLAnchorElement.prototype</code> , dass der endg√ºltige Prototyp <code>HTMLAnchorElement.prototype</code> . </li><li>  Best√§tigen Sie dort das Fehlen von <code>'getAttribute'</code> . </li><li>  <code>HTMLElement.prototype</code> , dass der n√§chste Prototyp <code>HTMLElement.prototype</code> . </li><li>  Best√§tigen Sie das Fehlen von <code>'getAttribute'</code> . </li><li>  <code>Element.prototype</code> , dass der n√§chste Prototyp <code>Element.prototype</code> . </li><li>  √úberpr√ºfen Sie, ob <code>'getAttribute'</code> vorhanden ist. </li></ol><br>  Insgesamt 7 Schecks.  Da diese Art von Code im Web weit verbreitet ist, verwenden Engines verschiedene Tricks, um die Anzahl der zum Laden von Prototypeneigenschaften erforderlichen √úberpr√ºfungen zu verringern. <br><br>  Zur√ºck zu einem fr√ºheren Beispiel, in dem wir nur drei √úberpr√ºfungen durchgef√ºhrt haben, als wir <code>'getX'</code> f√ºr <code>foo</code> <code>'getX'</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; } getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> $getX = foo.getX;</code> </pre> <br>  F√ºr jedes Objekt, das vor dem Prototyp auftritt, der die gew√ºnschte Eigenschaft enth√§lt, m√ºssen die Formulare auf das Fehlen dieser Eigenschaft √ºberpr√ºft werden.  Es w√§re sch√∂n, wenn wir die Anzahl der Pr√ºfungen reduzieren k√∂nnten, indem wir die Prototyppr√ºfung als Pr√ºfung f√ºr das Fehlen einer Eigenschaft pr√§sentieren.  Im Wesentlichen ist dies genau das, was Engines mit einem einfachen Trick tun: Anstatt den Prototyp-Link zur Instanz selbst zu speichern, speichern die Engines ihn in Form. <br><br><img src="https://habrastorage.org/webt/_q/j1/8q/_qj18qiex6e31a17r7sgho1r5hc.png"><br><br>  Jedes Formular gibt einen Prototyp an.  Dies bedeutet, dass jedes Mal, wenn sich der Prototyp <code>foo</code> √§ndert, der Motor in eine neue Form wechselt.  Jetzt m√ºssen wir nur noch die Form des Objekts √ºberpr√ºfen, um das Fehlen bestimmter Eigenschaften zu best√§tigen und die Prototypverbindung zu sch√ºtzen (die Prototypverbindung sch√ºtzen). <br><br>  Mit diesem Ansatz k√∂nnen wir die Anzahl der erforderlichen √úberpr√ºfungen von 2N + 1 auf 1 + N reduzieren, um den Zugriff zu beschleunigen.  Dies ist immer noch eine ziemlich teure Operation, da sie immer noch eine lineare Funktion der Anzahl der Prototypen in der Kette ist.  Motoren verwenden verschiedene Tricks, um die Anzahl der √úberpr√ºfungen weiter auf einen bestimmten konstanten Wert zu reduzieren, insbesondere bei sequentiellem Laden derselben Eigenschaften. <br><br>  <b>G√ºltigkeitszellen</b> <br><br>  Der V8 verarbeitet Prototypformulare speziell f√ºr diesen Zweck.  Jeder Prototyp hat eine eindeutige Form, die nicht mit anderen Objekten (insbesondere mit anderen Prototypen) geteilt wird, und jeder dieser Prototypformen ist eine spezielle <code>ValidityCell</code> zugeordnet. <br><br><img src="https://habrastorage.org/webt/pm/gc/m_/pmgcm_cjj6ufzx_dw8npfdbx2wi.png"><br><br>  Diese <code>ValidityCell</code> jedes Mal deaktiviert, wenn jemand den damit verbundenen Prototyp oder einen anderen dar√ºber liegenden Prototyp √§ndert.  Mal sehen, wie es funktioniert. <br>  Um nachfolgende Prototyp-Downloads zu beschleunigen, platziert V8 den Inline-Cache an einem Ort mit vier Feldern: <br><br><img src="https://habrastorage.org/webt/mr/ab/d2/mrabd2cyki6gglqlxphuqhjzoji.png"><br><br>  Wenn der Inline-Cache beim ersten Ausf√ºhren des Codes erw√§rmt wird, merkt sich V8 den Offset, bei dem die Eigenschaft im Prototyp gefunden wurde, diesen Prototyp (z. B. <code>Bar.prototype</code> ), das <code>Bar.prototype</code> (in unserem Fall das Formular <code>foo</code> ) und bindet auch die aktuelle <code>ValidityCell</code> an den empfangenen Prototyp aus der Instanz des Formulars (in unserem Fall wird <code>Bar.prototype</code> √ºbernommen). <br><br>  Wenn Sie das n√§chste Mal den Inline-Cache verwenden, muss die Engine das Instanzformular und <code>ValidityCell</code> √ºberpr√ºfen.  Wenn es noch g√ºltig ist, verwendet die Engine direkt den Offset des Prototyps und √ºberspringt die zus√§tzlichen Suchschritte. <br><br><img src="https://habrastorage.org/webt/hd/qw/4w/hdqw4wkuumyd9dmm0opxan9cbji.png"><br><br>  Wenn Sie den Prototyp √§ndern, wird ein neues Formular hervorgehoben und die vorherige <code>ValidityCell</code> Zelle deaktiviert.  Aus diesem Grund wird der Inline-Cache beim n√§chsten Start √ºbersprungen, was zu einer schlechten Leistung f√ºhrt. <br><br>  Kehren wir zum Beispiel mit dem DOM-Element zur√ºck.  Jede √Ñnderung in <code>Object.prototype</code> nicht nur die Inline-Caches f√ºr <code>Object.prototype</code> ung√ºltig, sondern auch f√ºr alle Prototypen in der darunter <code>EventTarget.prototype</code> Kette, einschlie√ülich <code>EventTarget.prototype</code> , <code>Node.prototype</code> , <code>Element.prototype</code> usw. bis hin zu <code>HTMLAnchorElement.prototype</code> . <br><br><img src="https://habrastorage.org/webt/oo/ml/ga/oomlgamrgo0peti1y3xsae-vtes.png"><br><br>  Tats√§chlich ist das √Ñndern von <code>Object.prototype</code> w√§hrend der Ausf√ºhrung des Codes ein schrecklicher Leistungsverlust.  Tu das nicht! <br><br>  Schauen wir uns ein konkretes Beispiel an, um besser zu verstehen, wie dies funktioniert.  <code>loadX</code> , wir haben eine <code>Bar</code> Klasse und eine <code>loadX</code> Funktion, die eine Methode f√ºr Objekte vom Typ <code>Bar</code> aufruft.  Wir rufen die <code>loadX</code> Funktion mehrmals mit Instanzen derselben Klasse auf. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ‚Ä¶ */</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadX</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bar</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bar.getX(); <span class="hljs-comment"><span class="hljs-comment">// IC for 'getX' on `Bar` instances. } loadX(new Bar(true)); loadX(new Bar(false)); // IC in `loadX` now links the `ValidityCell` for // `Bar.prototype`. Object.prototype.newMethod = y =&gt; y; // The `ValidityCell` in the `loadX` IC is invalid // now, because `Object.prototype` changed.</span></span></code> </pre> <br>  Der Inline-Cache in <code>loadX</code> jetzt auf <code>ValidityCell</code> f√ºr <code>Bar.prototype</code> .  Wenn Sie dann den (mutierten) <code>Object.prototype</code> , der die Wurzel aller Prototypen in JavaScript darstellt, wird <code>ValidityCell</code> ung√ºltig und vorhandene Inline-Caches werden beim n√§chsten Mal nicht verwendet, was zu einer schlechten Leistung f√ºhrt. <br><br>  Das √Ñndern des <code>Object.prototype</code> ist immer eine schlechte Idee, da zum Zeitpunkt der √Ñnderung alle Inline-Caches f√ºr geladene Prototypen ung√ºltig werden.  Hier ist ein Beispiel, wie man NICHT macht: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.foo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ‚Ä¶ */</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// Run critical code: someObject.foo(); // End of critical code. delete Object.prototype.foo;</span></span></code> </pre> <br>  Wir erweitern <code>Object.prototype</code> , wodurch alle von der Engine zu diesem Zeitpunkt geladenen Inline-Prototyp-Caches ung√ºltig werden.  Dann werden wir einen Code ausf√ºhren, der die von uns beschriebene Methode verwendet.  Die Engine muss von Anfang an starten und Inline-Caches f√ºr den Zugriff auf die Prototyp-Eigenschaft konfigurieren.  Und schlie√ülich ‚Äûbereinigen‚Äú und entfernen Sie die zuvor hinzugef√ºgte Prototypmethode. <br><br>  Sie denken, Reinigung ist eine gute Idee, oder?  In diesem Fall wird sich die Situation weiter verschlechtern!  Durch das Entfernen von Eigenschaften wird <code>Object.prototype</code> , sodass alle Inline-Caches wieder deaktiviert werden und die Engine die Arbeit von <code>Object.prototype</code> beginnen muss. <br><br>  <b>Zusammenfassend</b> .  Obwohl Prototypen nur Objekte sind, werden sie speziell von JavaScript-Engines verarbeitet, um die Leistung der Methodensuche nach Prototypen zu optimieren.  <b>Lass die Prototypen in Ruhe!</b>  Oder wenn Sie sich wirklich mit ihnen befassen m√ºssen, tun Sie dies, bevor Sie den Code ausf√ºhren, damit Sie zumindest nicht alle Versuche ung√ºltig machen, Ihren Code w√§hrend seiner Ausf√ºhrung zu optimieren! <br><br><blockquote>  <b>Fassen Sie zusammen</b> <br><br>  Wir haben gelernt, wie JavaScript Objekte und Klassen speichert und wie Formulare, Inline-Caches und G√ºltigkeitszellen zur Optimierung von Prototypoperationen beitragen.  Basierend auf diesem Wissen haben wir verstanden, wie die Leistung aus praktischer Sicht verbessert werden kann: Ber√ºhren Sie keine Prototypen!  (oder wenn Sie es wirklich brauchen, tun Sie es, bevor Sie den Code ausf√ºhren). </blockquote><br>  ‚Üê <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der erste Teil</a> <br><br>  War diese Reihe von Ver√∂ffentlichungen f√ºr Sie hilfreich?  Schreiben Sie in die Kommentare. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de449144/">https://habr.com/ru/post/de449144/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de449132/index.html">Top 17 Plugins f√ºr Android Studio</a></li>
<li><a href="../de449134/index.html">Zoo afl</a></li>
<li><a href="../de449138/index.html">5 Gr√ºnde f√ºr Crypto-Hat Warum IT-Leute Bitcoin nicht m√∂gen</a></li>
<li><a href="../de449140/index.html">Hinterlassen Sie eine Anfrage und wir werden Ihnen innerhalb von 1 Minute online antworten. Oder wie wir uns von OTRS entfernt haben</a></li>
<li><a href="../de449142/index.html">Microbiota. Welche Bakterien leben im Darm der Russen?</a></li>
<li><a href="../de449146/index.html">Aber winken wir nicht der optischen Kommunikation zu? Laser, Weltraum, CubeSat</a></li>
<li><a href="../de449148/index.html">Kunstb√ºcher f√ºr Kinder √ºber Social Engineering</a></li>
<li><a href="../de449154/index.html">FAQ zur obligatorischen Kennzeichnung von Schuhen: Alles, was Sie nicht wussten und Angst hatten zu fragen</a></li>
<li><a href="../de449158/index.html">Rough Coster: Gemeinschaftskochbuch</a></li>
<li><a href="../de449162/index.html">C ++ Russland 2019. Ein kleiner Bericht vom Veranstaltungsort und der Ank√ºndigung der n√§chsten Konferenz in St. Petersburg</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>