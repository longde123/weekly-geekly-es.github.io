<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ§“ğŸ¿ ğŸ–±ï¸ ğŸš› Histoire oubliÃ©e de la POO ğŸ§›ğŸ½ ğŸ‘œ ğŸ”»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La plupart des paradigmes de programmation que nous utilisons aujourd'hui ont d'abord Ã©tÃ© Ã©tudiÃ©s mathÃ©matiquement dans les annÃ©es 1930 en utilisant l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Histoire oubliÃ©e de la POO</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/428582/"> La plupart des paradigmes de programmation que nous utilisons aujourd'hui ont d'abord Ã©tÃ© Ã©tudiÃ©s mathÃ©matiquement dans les annÃ©es 1930 en utilisant les idÃ©es du calcul lambda et de la machine de Turing, qui sont des variantes du modÃ¨le informatique universel (ce sont des systÃ¨mes formalisÃ©s qui peuvent effectuer des calculs Ã  usage gÃ©nÃ©ral).  La thÃ¨se de Church-Turing a montrÃ© que le calcul lambda et les machines de Turing sont fonctionnellement Ã©quivalents.  Ã€ savoir, nous parlons du fait que tout ce qui peut Ãªtre calculÃ© Ã  l'aide d'une machine de Turing peut Ã©galement Ãªtre calculÃ© Ã  l'aide du calcul lambda, et vice versa. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/hq/so/jp/hqsojpds8ed1zxx9g7lelnfknbu.jpeg"></a> <br><a name="habracut"></a><br>  Il existe une idÃ©e fausse commune selon laquelle les machines de Turing peuvent calculer tout ce qui peut Ãªtre calculÃ©.  Il existe des classes de problÃ¨mes (par exemple, le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">problÃ¨me de lâ€™arrÃªt</a> ) qui peuvent Ãªtre calculÃ©s Ã  lâ€™aide des machines de Turing dans certains cas seulement.  Lorsque le mot Â«calculableÂ» est utilisÃ© dans ce texte, il signifie Â«calculable par une machine de TuringÂ». <br><br>  Le calcul lambda illustre l'approche consistant Ã  appliquer des fonctions aux calculs de maniÃ¨re descendante.  Une machine Ã  bande Turing est une approche impÃ©rative (Ã©tape par Ã©tape) de l'informatique, mise en Å“uvre de faÃ§on ascendante. <br><br>  Les langages de programmation de bas niveau, tels que le code machine ou l'assembleur, sont apparus dans les annÃ©es 40 et, Ã  la fin des annÃ©es 50, les premiers langages de haut niveau populaires sont apparus et ont mis en Å“uvre des approches fonctionnelles et impÃ©ratives.  Ainsi, les dialectes de la langue Lisp sont encore largement utilisÃ©s, parmi lesquels Clojure, Scheme, AutoLisp et ainsi de suite.  Dans les annÃ©es cinquante, des langues comme le FORTRAN et le COBOL sont apparues.  Ce sont des exemples de langages de haut niveau impÃ©ratifs qui sont toujours vivants.  Bien qu'il convient de noter que les langues de la famille C, dans la plupart des domaines, ont remplacÃ© COBOL et FORTRAN. <br><br>  Les racines de la programmation impÃ©rative et fonctionnelle se trouvent dans les mathÃ©matiques formelles de l'informatique, elles sont apparues avant les ordinateurs numÃ©riques.  La programmation orientÃ©e objet (POO) est venue plus tard; elle trouve son origine dans la rÃ©volution structurelle de la programmation qui a eu lieu dans les annÃ©es 60 et 70 du siÃ¨cle dernier. <br><br>  Le premier objet que je connaissais a Ã©tÃ© utilisÃ© par Ivan Sutherland dans sa fatidique application Sketchpad, crÃ©Ã©e entre 1961 et 1962, qu'il a dÃ©crite dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cet</a> ouvrage en 1963.  Les objets Ã©taient des caractÃ¨res graphiques affichÃ©s sur l'Ã©cran de l'oscilloscope (c'est peut-Ãªtre la premiÃ¨re fois dans l'histoire de l'utilisation d'un Ã©cran d'ordinateur graphique) qui prend en charge l'hÃ©ritage par le biais de dÃ©lÃ©guÃ©s dynamiques, qu'Ivan Sutherland a appelÃ© Â«maÃ®tresÂ» dans son travail.  Tout objet pouvait devenir un objet maÃ®tre, des instances supplÃ©mentaires de l'objet Ã©taient appelÃ©es "occurrences".  Cela a fait du systÃ¨me Sketchpad le propriÃ©taire du premier des fameux langages de programmation qui implÃ©mentait l'hÃ©ritage des prototypes. <br><br>  Le premier langage de programmation, communÃ©ment appelÃ© "orientÃ© objet", Ã©tait le langage Simula, dont les spÃ©cifications ont Ã©tÃ© dÃ©veloppÃ©es en 1965.  Comme Sketchpad, Silmula prÃ©voyait de travailler avec des objets, mais comprenait Ã©galement des classes, un hÃ©ritage basÃ© sur une classe, des sous-classes et des mÃ©thodes virtuelles. <br><br>  <i><font color="#999999">Une mÃ©thode virtuelle est une mÃ©thode dÃ©finie dans une classe conÃ§ue pour Ãªtre redÃ©finie par des sous-classes.</font></i>  <i><font color="#999999">Les mÃ©thodes virtuelles permettent aux programmes d'appeler des mÃ©thodes qui n'existent peut-Ãªtre pas au moment de la compilation du code, en utilisant la rÃ©partition dynamique pour dÃ©terminer quelle mÃ©thode particuliÃ¨re doit Ãªtre appelÃ©e pendant l'exÃ©cution du programme.</font></i>  <i><font color="#999999">JavaScript possÃ¨de des types dynamiques et utilise une chaÃ®ne de dÃ©lÃ©gation pour dÃ©terminer la mÃ©thode Ã  invoquer. Par consÃ©quent, ce langage n'a pas besoin d'introduire le concept de mÃ©thodes virtuelles aux programmeurs.</font></i>  <i><font color="#999999">En d'autres termes, toutes les mÃ©thodes de JavaScript utilisent la rÃ©partition au moment de l'exÃ©cution; par consÃ©quent, les mÃ©thodes de JavaScript n'ont pas besoin d'Ãªtre dÃ©clarÃ©es Â«virtuellesÂ» pour prendre en charge cette fonctionnalitÃ©.</font></i> <br><br><h2>  <font color="#3AC1EF">Opinion du pÃ¨re OOP sur OOP</font> </h2><br>  <i><font color="#999999">"J'ai inventÃ© le terme" orientÃ© objet "et je peux dire que je ne voulais pas dire C ++."</font></i>  <i><font color="#999999">Alan Kay, ConfÃ©rence OOPSLA, 1997.</font></i> <br><br>  Alan Kay a inventÃ© le terme Â«programmation orientÃ©e objetÂ», se rÃ©fÃ©rant au langage de programmation Smalltalk (1972).  Ce langage a Ã©tÃ© dÃ©veloppÃ© par Alan Kay, Dan Ingles et d'autres employÃ©s du Xerox PARC Research Center dans le cadre du projet Dynabook.  Smalltalk Ã©tait plus orientÃ© objet que Simula.  Dans Smalltalk, tout est un objet, y compris les classes, les entiers et les blocs (fermetures).  L'implÃ©mentation initiale du langage, Smalltalk-72, n'avait pas la capacitÃ© de sous-classe.  Cette fonctionnalitÃ© est apparue dans Smalltalk-76. <br><br>  Bien que Smalltalk ait pris en charge les classes et, par consÃ©quent, le sous-classement, Smalltalk n'a pas mis ces idÃ©es au premier plan.  C'Ã©tait un langage fonctionnel que Lisp a influencÃ© autant que Simula.  Selon Alan Kay, traiter les classes comme un mÃ©canisme de rÃ©utilisation de code est une erreur.  L'industrie de la programmation accorde une grande attention Ã  la crÃ©ation de sous-classes, distrayant des avantages rÃ©els de la programmation orientÃ©e objet. <br><br>  JavaScript et Smalltalk ont â€‹â€‹beaucoup en commun.  Je dirais que JavaScript est la vengeance de Smalltalk sur le monde pour avoir mal compris les concepts de la POO.  Ces deux langues prennent en charge les fonctionnalitÃ©s suivantes: <br><br><ul><li>  Objets </li><li>  Fonctions et fermetures de premiÃ¨re classe. </li><li>  Types dynamiques. </li><li>  Liaison tardive (les fonctions et mÃ©thodes peuvent Ãªtre remplacÃ©es lors de l'exÃ©cution du programme). </li><li>  POO sans systÃ¨me d'hÃ©ritage basÃ© sur les classes. </li></ul><br>  <i><font color="#999999">Â«Je regrette d'avoir trouvÃ© le termeÂ« objets Â»pour ce phÃ©nomÃ¨ne il y a longtemps, car son utilisation conduit au fait que beaucoup de gens accordent une importance primordiale Ã  une idÃ©e qui n'est pas aussi importante que la principale.</font></i>  <i><font color="#999999">L'idÃ©e principale est la messagerie. "</font></i>  <i><font color="#999999">Alan Kay</font></i> <br><br>  Dans une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">correspondance par</a> courrier Ã©lectronique de 2003, Alan Kay a prÃ©cisÃ© ce qu'il avait en tÃªte lorsqu'il a appelÃ© Smalltalk "un langage orientÃ© objet". <br><br>  <i><font color="#999999">Â«Pour moi, la POO signifie uniquement la messagerie, le stockage local et la protection, l'Ã©tat de masquage et la liaison trÃ¨s tardive.Â»</font></i>  <i><font color="#999999">Alan Kay</font></i> <br><br>  En d'autres termes, conformÃ©ment aux idÃ©es d'Alan Kay, les ingrÃ©dients les plus importants de la POO sont les suivants: <br><br><ul><li>  Messagerie </li><li>  Encapsulation. </li><li>  Liaison dynamique. </li></ul><br>  Il est important de noter qu'Alan Kay, l'homme qui a inventÃ© le terme Â«OOPÂ» et l'a apportÃ© aux masses, ne considÃ©rait pas l'hÃ©rÃ©ditÃ© et le polymorphisme comme les composants les plus importants de la POO. <br><br><h2>  <font color="#3AC1EF">L'essence de la POO</font> </h2><br>  La combinaison de la messagerie et de l'encapsulation sert plusieurs objectifs importants: <br><br><ul><li>  Ã‰viter l'Ã©tat mutable partagÃ© d'un objet en encapsulant l'Ã©tat et en isolant d'autres objets des changements locaux de son Ã©tat.  La seule faÃ§on d'influencer l'Ã©tat d'un autre objet est de lui demander (plutÃ´t que de lui donner une commande) de changer en lui envoyant un message.  Les changements d'Ã©tat sont surveillÃ©s au niveau cellulaire local, l'Ã©tat n'est pas mis Ã  la disposition d'autres objets. </li><li>  SÃ©paration des objets les uns des autres.  L'expÃ©diteur du message est faiblement couplÃ© au rÃ©cepteur via l'API de messagerie. </li><li>  AdaptabilitÃ© et rÃ©sistance aux changements pendant l'exÃ©cution du programme grÃ¢ce Ã  une liaison tardive.  L'adaptation aux changements pendant l'exÃ©cution du programme offre de nombreux avantages importants, qu'Alan Kay considÃ©rait trÃ¨s importants pour la POO. </li></ul><br>  Alan Kay, qui a exprimÃ© ces idÃ©es, s'est inspirÃ© de ses connaissances en biologie et de ses connaissances sur ARPANET (il s'agit d'une premiÃ¨re version d'Internet).  Ã€ savoir, nous parlons de cellules biologiques et d'ordinateurs individuels connectÃ©s au rÃ©seau.  MÃªme alors, Alan Kay a imaginÃ© comment les programmes s'exÃ©cutent sur d'Ã©normes ordinateurs distribuÃ©s (Internet), tandis que les ordinateurs individuels agissent comme des cellules biologiques, travaillant indÃ©pendamment avec leur propre Ã©tat isolÃ© et Ã©changeant des donnÃ©es avec d'autres ordinateurs en envoyant des messages. <br><br>  <i><font color="#999999">"J'ai rÃ©alisÃ© qu'une mÃ©taphore pour une cellule ou un ordinateur aiderait Ã  se dÃ©barrasser des donnÃ©es [...]."</font></i>  <i><font color="#999999">Alan Kay</font></i> <br><br>  Dire Â«aider Ã  se dÃ©barrasser des donnÃ©esÂ», Alan Kay, bien sÃ»r, Ã©tait conscient des problÃ¨mes causÃ©s par l'Ã©tat mutable partagÃ© et de la forte connectivitÃ© causÃ©e par le partage des donnÃ©es.  Aujourd'hui, ces sujets sont largement entendus.  Mais Ã  la fin des annÃ©es 1960, les programmeurs ARPANET n'Ã©taient pas satisfaits de la nÃ©cessitÃ© de choisir une reprÃ©sentation de modÃ¨le de donnÃ©es pour leurs programmes avant de dÃ©velopper des programmes.  Les dÃ©veloppeurs ont voulu s'Ã©loigner de cette pratique, car, avant de se plonger dans le cadre dÃ©terminÃ© par la prÃ©sentation des donnÃ©es, il est plus difficile de changer quelque chose Ã  l'avenir. <br><br>  Le problÃ¨me Ã©tait que diffÃ©rentes faÃ§ons de prÃ©senter les donnÃ©es nÃ©cessitaient, pour y accÃ©der, un code diffÃ©rent et une syntaxe diffÃ©rente dans les langages de programmation utilisÃ©s Ã  un moment donnÃ©.  Le Saint Graal serait ici un moyen universel d'accÃ©der et de gÃ©rer les donnÃ©es.  Si toutes les donnÃ©es se ressemblaient pour le programme, cela rÃ©soudrait de nombreux problÃ¨mes des dÃ©veloppeurs concernant le dÃ©veloppement et la maintenance des programmes. <br>  Alan Kay a tentÃ© de "se dÃ©barrasser" de l'idÃ©e, selon laquelle les donnÃ©es et les programmes Ã©taient, en un sens, des entitÃ©s indÃ©pendantes.  Ils ne sont pas considÃ©rÃ©s comme tels dans List ou Smalltalk.  Il n'y a pas de sÃ©paration entre ce qui peut Ãªtre fait avec des donnÃ©es (avec des valeurs, des variables, des structures de donnÃ©es, etc.) et des constructions logicielles comme des fonctions.  Les fonctions sont des Â«citoyens de premiÃ¨re classeÂ» et les programmes peuvent changer pendant leur exÃ©cution.  En d'autres termes, Smalltalk n'a pas de relation privilÃ©giÃ©e spÃ©ciale avec les donnÃ©es. <br><br>  Alan Kay, en outre, considÃ©rait les objets comme des structures algÃ©briques, qui donnaient des garanties prÃ©cises et mathÃ©matiquement prouvables de leur comportement. <br><br>  <i><font color="#999999">"Mes connaissances mathÃ©matiques m'ont permis de comprendre que chaque objet peut avoir plusieurs modÃ¨les algÃ©briques associÃ©s, qu'il peut y avoir des groupes entiers de modÃ¨les similaires et qu'ils peuvent Ãªtre trÃ¨s, trÃ¨s utiles."</font></i>  <i><font color="#999999">Alan Kay</font></i> <br><br>  Il a Ã©tÃ© prouvÃ© qu'il en Ã©tait ainsi, et cela a constituÃ© la base pour des objets, tels que les promesses et les lentilles, de plus, la thÃ©orie des catÃ©gories a Ã©tÃ© influencÃ©e par les deux. <br>  La nature algÃ©brique de la faÃ§on dont Alan Kay a vu les objets permettrait aux objets de fournir une vÃ©rification formelle, un comportement dÃ©terministe et d'amÃ©liorer la testabilitÃ©, car les modÃ¨les algÃ©briques sont, par essence, des opÃ©rations qui obÃ©issent Ã  plusieurs rÃ¨gles sous la forme d'Ã©quations. <br><br>  Dans le jargon des programmeurs, les Â«modÃ¨les algÃ©briquesÂ» sont des abstractions crÃ©Ã©es Ã  partir de fonctions (opÃ©rations) qui sont accompagnÃ©es de certaines rÃ¨gles, imposÃ©es par des tests unitaires que ces fonctions doivent rÃ©ussir (axiomes, Ã©quations). <br><br>  Ces idÃ©es sont oubliÃ©es depuis des dÃ©cennies dans la plupart des langages orientÃ©s objet de la famille C, notamment C ++, Java, C #, etc.  Mais ces idÃ©es commencent la recherche du voyage de retour, dans les versions rÃ©centes des langages orientÃ©s objet les plus utilisÃ©s. <br><br>  A cette occasion, quelqu'un peut dire que le monde de la programmation redÃ©couvre les avantages de la programmation fonctionnelle et fournit des arguments rationnels dans le contexte des langages orientÃ©s objet. <br><br>  Comme JavaScript et Smalltalk plus tÃ´t, la plupart des langages orientÃ©s objet modernes deviennent de plus en plus "multi-paradigmes".  Il n'y a aucune raison de choisir entre la programmation fonctionnelle et la POO.  Lorsque nous examinons l'essence historique de chacune de ces approches, elles semblent non seulement compatibles, mais aussi complÃ©mentaires. <br><br>  D'aprÃ¨s les pensÃ©es d'Alan Kay, quel est le plus important au sein de l'OLP? <br><br><ul><li>  Encapsulation. </li><li>  Messagerie </li><li>  Liaison dynamique (capacitÃ© des programmes Ã  se dÃ©velopper et Ã  s'adapter aux changements pendant leur exÃ©cution). </li></ul><br>  Qu'est-ce qui est nÃ©gligeable dans la POO? <br><br><ul><li>  Cours. </li><li>  HÃ©ritage basÃ© sur les classes. </li><li>  Relation particuliÃ¨re aux objets, fonctions ou donnÃ©es. </li><li> <code>new</code> mot-clÃ©. </li><li>  Polymorphisme. </li><li>  Typage statique. </li><li>  Attitude envers les classes en tant que Â«typesÂ». </li></ul><br>  Si vous connaissez Java ou C #, vous pourriez penser que le typage statique ou le polymorphisme sont les ingrÃ©dients les plus importants de la POO, mais Alan Kay prÃ©fÃ¨re traiter les modÃ¨les de comportement universels sous forme algÃ©brique.  Voici un exemple Ã©crit en Haskell: <br><br><pre> <code class="hljs erlang-repl">fmap :: (a -&gt; b) -&gt; fa -&gt; fb</code> </pre> <br>  Il s'agit de la signature du foncteur de <code>map</code> universel, qui fonctionne avec les types non dÃ©finis <code>a</code> et <code>b</code> , en appliquant la fonction de <code>a</code> Ã  <code>b</code> dans le contexte du foncteur <code>a</code> afin de crÃ©er le foncteur <code>b</code> .  Â«FunctorÂ» est un mot du jargon mathÃ©matique dont la signification est rÃ©duite Ã  Â«support de l'opÃ©ration d'affichageÂ».  Si vous connaissez la mÃ©thode <code>[].map()</code> en JavaScript, vous savez dÃ©jÃ  ce que cela signifie. <br><br>  Voici quelques exemples JavaScript: <br><br><pre> <code class="hljs powershell">// isEven = Number =&gt; Boolean const isEven = n =&gt; n % <span class="hljs-number"><span class="hljs-number">2</span></span> === <span class="hljs-number"><span class="hljs-number">0</span></span>; const nums = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>]; //  map   `a =&gt; b`    `a` ( `this`) //     `b` //    `a`   `Number`,   `b`  `Boolean` const results = nums.map(isEven); console.log(results); // [<span class="hljs-type"><span class="hljs-type">false</span></span>, <span class="hljs-type"><span class="hljs-type">true</span></span>, <span class="hljs-type"><span class="hljs-type">false</span></span>, <span class="hljs-type"><span class="hljs-type">true</span></span>, <span class="hljs-type"><span class="hljs-type">false</span></span>, <span class="hljs-type"><span class="hljs-type">true</span></span>]</code> </pre> <br>  La mÃ©thode <code>.map()</code> est universelle, dans le sens oÃ¹ <code>a</code> et <code>b</code> peuvent Ãªtre de tout type, et cette mÃ©thode rÃ©sout sans problÃ¨me une situation similaire, car les tableaux sont des structures de donnÃ©es qui mettent en Å“uvre les lois algÃ©briques des foncteurs.  Les types de <code>.map()</code> n'ont pas d'importance, car cette mÃ©thode n'essaie pas de travailler directement avec les valeurs correspondantes.  Au lieu de cela, il utilise une fonction qui attend et renvoie des valeurs des types correspondants qui sont correctes du point de vue de l'application. <br><br><pre> <code class="hljs pgsql">// matches = a =&gt; <span class="hljs-type"><span class="hljs-type">Boolean</span></span> //  `a`    ,   const matches = control =&gt; input =&gt; input === control; const strings = [<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-string"><span class="hljs-string">'bar'</span></span>, <span class="hljs-string"><span class="hljs-string">'baz'</span></span>]; const results = strings.map(matches(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>)); console.log(results); // [<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>]</code> </pre> <br>  La relation des types universels peut Ãªtre difficile Ã  exprimer correctement et complÃ¨tement dans des langages comme TypeScript, mais elle est trÃ¨s simple Ã  faire dans le systÃ¨me de type Hindley-Milner utilisÃ© dans Haskell, qui prend en charge les types supÃ©rieurs (types de type). <br><br>  La plupart des systÃ¨mes de types imposent des restrictions trop fortes pour permettre la libre expression d'idÃ©es dynamiques et fonctionnelles, telles que la composition des fonctions, la libre composition des objets, l'expansion des objets pendant l'exÃ©cution du programme, l'utilisation de combinateurs, de lentilles, etc.  En d'autres termes?  les types statiques rendent souvent difficile l'Ã©criture de logiciels Ã  l'aide de mÃ©thodes de construction. <br><br>  Si votre systÃ¨me de types a trop de restrictions (comme dans TypeScript ou Java), pour atteindre les mÃªmes objectifs, vous devez Ã©crire du code plus complexe que lorsque vous utilisez des langages avec une approche plus libre de la frappe.  Cela ne signifie pas que l'utilisation de types statiques est une idÃ©e malheureuse, ou que toutes les implÃ©mentations de types statiques ont les mÃªmes limitations.  Par exemple, j'ai rencontrÃ© beaucoup moins de problÃ¨mes avec le systÃ¨me de type Haskell. <br><br>  Si vous Ãªtes un fan des types statiques et que vous n'Ãªtes pas contre les restrictions, je vous souhaite sept pieds sous la quille.  Mais si vous trouvez que certaines des idÃ©es exprimÃ©es ici sont difficiles Ã  mettre en Å“uvre en raison du fait qu'il n'est pas facile de taper des fonctions obtenues en composant d'autres fonctions et des structures algÃ©briques composites, blÃ¢mez le systÃ¨me de types et non l'idÃ©e.  Les conducteurs aiment les commoditÃ©s que les VUS Ã  chÃ¢ssis leur offrent, mais personne ne se plaint de ne pas voler.  Pour voler, vous avez besoin d'un vÃ©hicule qui a plus de degrÃ©s de libertÃ©. <br><br>  Si les restrictions rendent votre code plus simple, tant mieux!  Mais si les contraintes vous obligent Ã  Ã©crire du code plus complexe, alors peut-Ãªtre que quelque chose ne va pas avec ces contraintes. <br><br><h2>  <font color="#3AC1EF">Qu'est-ce qu'un Â«objetÂ»?</font> </h2><br>  Le mot Â«objetÂ», au fil du temps, a acquis de nombreuses connotations secondaires de sens.  Ce que nous appelons des Â«objetsÂ» en JavaScript sont simplement des types de donnÃ©es composites, sans aucune allusion Ã  la programmation basÃ©e sur les classes, ni aux idÃ©es de passage de messages d'Alan Kay. <br><br>  En JavaScript, ces objets peuvent prendre en charge, et prennent souvent en charge, l'encapsulation, le passage de messages, la sÃ©paration des comportements par le biais de mÃ©thodes, voire le polymorphisme Ã  l'aide de sous-classes (bien qu'en utilisant une chaÃ®ne de dÃ©lÃ©gation plutÃ´t qu'une rÃ©partition basÃ©e sur le type). <br><br>  Alan Kay voulait se dÃ©barrasser de la diffÃ©rence entre le programme et ses donnÃ©es.  JavaScript, dans une certaine mesure, atteint cet objectif en plaÃ§ant les mÃ©thodes d'objet au mÃªme endroit que les propriÃ©tÃ©s qui stockent les donnÃ©es.  Par exemple, n'importe quelle propriÃ©tÃ© peut Ãªtre affectÃ©e Ã  n'importe quelle fonction.  Vous pouvez construire le comportement d'un objet de maniÃ¨re dynamique et modifier le contenu sÃ©mantique de l'objet pendant l'exÃ©cution du programme. <br><br>  Un objet est juste une structure de donnÃ©es composite, et il n'a besoin de rien de spÃ©cial pour Ãªtre considÃ©rÃ© comme un objet.  Cependant, la programmation Ã  l'aide d'objets ne conduit pas au fait qu'un tel code se rÃ©vÃ¨le Â«orientÃ© objetÂ», tout comme l'utilisation de fonctions ne rend pas le code Â«fonctionnelÂ». <br><br><h2>  <font color="#3AC1EF">La POO n'est plus une vraie POO</font> </h2><br>  Ã‰tant donnÃ© que le concept d 'Â«objetÂ» dans les langages de programmation modernes signifie beaucoup moins que ce qu'Alan Kay voulait dire, j'utilise le mot Â«composantÂ» au lieu du mot Â«objetÂ» pour dÃ©crire les rÃ¨gles de ce POO.  De nombreux objets sont directement dÃ©tenus et contrÃ´lÃ©s par du code JavaScript tiers, mais les composants doivent encapsuler leur propre Ã©tat et le contrÃ´ler. <br><br>  Voici ce qu'est la vraie POO: <br><br><ul><li>  Programmation Ã  l'aide de composants (Alan Kay les appelle des Â«objetsÂ»). </li><li>  L'Ã©tat du composant doit Ãªtre encapsulÃ©. </li><li>  Pour la communication entre les entitÃ©s, la messagerie est utilisÃ©e. </li><li>  Les composants peuvent Ãªtre ajoutÃ©s, modifiÃ©s et remplacÃ©s lors de l'exÃ©cution. </li></ul><br>  La plupart des comportements d'objet peuvent Ãªtre dÃ©finis de maniÃ¨re universelle Ã  l'aide de structures de donnÃ©es algÃ©briques.  Il n'y a pas besoin d'hÃ©ritage.  Les composants peuvent rÃ©utiliser les comportements des fonctions publiques et importer des modules, sans avoir Ã  rendre leurs donnÃ©es publiques. <br><br>  La manipulation d'objets en JavaScript ou l'utilisation de l'hÃ©ritage basÃ© sur une classe ne signifie pas que quelqu'un est impliquÃ© dans la programmation POO.  Mais l'utilisation de composants de cette maniÃ¨re - signifie.  Mais il est trÃ¨s difficile de se dÃ©barrasser des idÃ©es Ã©tablies sur les termes, alors peut-Ãªtre devrions-nous laisser le terme Â«POOÂ» et appeler ce que les Â«composantsÂ» ci-dessus sont utilisÃ©s comme Â«programmation orientÃ©e message (MOP)Â»?  Nous utiliserons le terme Â«MOPÂ» ci-dessous pour parler de programmation orientÃ©e message. <br><br>  Par hasard, le mot anglais Â«mopÂ» est traduit par Â«mopÂ» et, comme vous le savez, ils sont utilisÃ©s pour rÃ©tablir l'ordre. <br><br><h2>  <font color="#3AC1EF">Ã€ quoi ressemble une bonne MOP?</font> </h2><br>  La plupart des programmes modernes ont une interface utilisateur (User Interface, UI) qui est chargÃ©e d'interagir avec l'utilisateur, un code qui gÃ¨re l'Ã©tat de l'application (donnÃ©es utilisateur) et un code qui fonctionne avec le systÃ¨me ou qui est responsable de l'Ã©change de donnÃ©es avec le rÃ©seau. <br><br>  Pour prendre en charge le fonctionnement de chacun de ces systÃ¨mes, des processus Ã  longue durÃ©e de vie, tels que des Ã©couteurs d'Ã©vÃ©nements, peuvent Ãªtre nÃ©cessaires.  Ici, vous aurez besoin de l'Ã©tat de l'application - pour stocker quelque chose comme des informations sur les connexions rÃ©seau, sur l'Ã©tat des choses avec les contrÃ´les d'interface et sur l'application elle-mÃªme. <br><br>  Un bon MOP signifie qu'au lieu que tous ces systÃ¨mes aient accÃ¨s Ã  l'Ã©tat de l'autre et puissent les contrÃ´ler directement, ils interagissent les uns avec les autres par le biais de messages.  Lorsque l'utilisateur clique sur le bouton "Enregistrer", le message <code>"SAVE"</code> peut Ãªtre envoyÃ©.  Le composant d'application de gestion d'Ã©tat peut interprÃ©ter ce message et le rediriger vers le gestionnaire responsable de la mise Ã  jour Ã  partir de l'Ã©tat (tel qu'une fonction de rÃ©ducteur pur).  Peut-Ãªtre qu'aprÃ¨s la mise Ã  jour de l'Ã©tat, le composant responsable de la gestion de l'Ã©tat envoie le message <code>"STATE_UPDATED"</code> composant d'interface utilisateur qui, Ã  son tour, interprÃ¨te l'Ã©tat, dÃ©cide quelles parties de l'interface doivent Ãªtre mises Ã  jour et transfÃ¨re l'Ã©tat mis Ã  jour aux sous-composants chargÃ©s de travailler avec Ã©lÃ©ments d'interface spÃ©cifiques. <br><br>  Pendant ce temps, le composant responsable des connexions rÃ©seau peut surveiller la connexion de l'utilisateur Ã  un autre ordinateur du rÃ©seau, Ã©couter les messages et envoyer une vue mise Ã  jour de l'Ã©tat pour l'enregistrer sur la machine distante.  Un tel composant est chargÃ© de travailler avec des mÃ©canismes de rÃ©seau, sait si la connexion fonctionne ou non, etc. <br><br>  Les systÃ¨mes d'application similaires ne devraient pas connaÃ®tre les dÃ©tails de ses autres parties.  Ils ne devraient se soucier que de rÃ©soudre leurs propres problÃ¨mes.  Les composants du systÃ¨me peuvent Ãªtre dÃ©montÃ©s et assemblÃ©s en tant que constructeur.  Ils implÃ©mentent des interfaces standardisÃ©es, ce qui signifie qu'ils peuvent interagir les uns avec les autres.  Tant que les exigences bien connues pour l'interface des composants sont remplies, ces composants peuvent Ãªtre remplacÃ©s par d'autres, avec les mÃªmes interfaces, mais faisant la mÃªme chose diffÃ©remment, ou effectuant, recevant les mÃªmes messages, quelque chose de complÃ¨tement diffÃ©rent.  Vous pouvez changer un composant en un autre mÃªme pendant l'exÃ©cution du programme - cela ne cassera pas son travail. <br><br>  Les composants d'un systÃ¨me logiciel n'ont mÃªme pas besoin d'Ãªtre sur le mÃªme ordinateur.  Le systÃ¨me peut Ãªtre dÃ©centralisÃ©.  Le stockage en rÃ©seau peut placer des donnÃ©es dans un systÃ¨me de stockage dÃ©centralisÃ© comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IPFS</a> , par consÃ©quent, l'utilisateur est indÃ©pendant de la santÃ© d'une machine particuliÃ¨re, ce qui garantit la sÃ©curitÃ© de ses donnÃ©es.  Avec cette approche, les donnÃ©es sont stockÃ©es de maniÃ¨re fiable et protÃ©gÃ©es contre les intrus. <br><br>  L'OLP, en partie, est tombÃ©e sous l'influence des idÃ©es d'ARPANET, et l'un des objectifs de ce projet Ã©tait de crÃ©er un rÃ©seau dÃ©centralisÃ© qui serait rÃ©sistant aux attaques comme une frappe nuclÃ©aire. <br><br>  Un bon systÃ¨me MOP peut Ãªtre caractÃ©risÃ© par un niveau de stabilitÃ© similaire en utilisant des composants qui prennent en charge l'Ã©change Ã  chaud pendant que l'application est en cours d'exÃ©cution.  Il pourra continuer Ã  fonctionner si l'utilisateur travaille avec lui Ã  partir d'un tÃ©lÃ©phone portable et est hors de la couverture rÃ©seau du fait qu'il est entrÃ© dans le tunnel.  Si un ouragan interrompait l'alimentation Ã©lectrique de l'un des centres de donnÃ©es dans lesquels ses serveurs sont situÃ©s, il continuera Ã©galement de fonctionner. <br><br>  Il est temps que le monde du logiciel se libÃ¨re d'une expÃ©rience d'hÃ©ritage basÃ©e sur une classe infructueuse et adopte les principes mathÃ©matiques et scientifiques qui Ã©taient Ã  la pointe de la POO. <br><br>  Il est temps pour nous, dÃ©veloppeurs, de crÃ©er des programmes plus flexibles, stables et beaux en utilisant une combinaison harmonieuse de MOP et de programmation fonctionnelle. <br>  Soit dit en passant, l'acronyme "MOP" est dÃ©jÃ  utilisÃ©, dÃ©crivant "Monitoring Oriented Programming", mais ce concept, contrairement Ã  la POO, disparaÃ®tra tout simplement. <br><br>  Par consÃ©quent, ne vous dÃ©couragez pas si le terme Â«MOPÂ» ne ressemble pas Ã  un mot du jargon des programmeurs.  Ranger juste votre POO avec les principes MOP ci-dessus. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr428582/">https://habr.com/ru/post/fr428582/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr428572/index.html">Composants d'ordre supÃ©rieur dans React</a></li>
<li><a href="../fr428574/index.html">Faites passer la communication d'entreprise au niveau supÃ©rieur avec Zextras Chat</a></li>
<li><a href="../fr428576/index.html">[signet] Version PDF du tutoriel Node.js et nouveau guide JavaScript</a></li>
<li><a href="../fr428578/index.html">Comment dÃ©marrer avec Hibernate Search</a></li>
<li><a href="../fr428580/index.html">Bon guide de communication</a></li>
<li><a href="../fr428588/index.html">RÃ©sumÃ© des Ã©vÃ©nements informatiques en novembre (deuxiÃ¨me partie)</a></li>
<li><a href="../fr428590/index.html">Microinteractions et micro invites dans l'interface</a></li>
<li><a href="../fr428592/index.html">ArrÃªtez d'embaucher des Â«gestionnaires efficacesÂ». Ils sont non seulement inutiles, mais nocifs</a></li>
<li><a href="../fr428596/index.html">Elon Musk a licenciÃ© des chefs de projet Internet par satellite Starlink en raison du non-respect des dÃ©lais</a></li>
<li><a href="../fr428598/index.html">RÃ©seaux de neurones profonds pour l'Ã©valuation automatique des appels</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>