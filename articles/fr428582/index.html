<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧓🏿 🖱️ 🚛 Histoire oubliée de la POO 🧛🏽 👜 🔻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La plupart des paradigmes de programmation que nous utilisons aujourd'hui ont d'abord été étudiés mathématiquement dans les années 1930 en utilisant l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Histoire oubliée de la POO</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/428582/"> La plupart des paradigmes de programmation que nous utilisons aujourd'hui ont d'abord été étudiés mathématiquement dans les années 1930 en utilisant les idées du calcul lambda et de la machine de Turing, qui sont des variantes du modèle informatique universel (ce sont des systèmes formalisés qui peuvent effectuer des calculs à usage général).  La thèse de Church-Turing a montré que le calcul lambda et les machines de Turing sont fonctionnellement équivalents.  À savoir, nous parlons du fait que tout ce qui peut être calculé à l'aide d'une machine de Turing peut également être calculé à l'aide du calcul lambda, et vice versa. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/hq/so/jp/hqsojpds8ed1zxx9g7lelnfknbu.jpeg"></a> <br><a name="habracut"></a><br>  Il existe une idée fausse commune selon laquelle les machines de Turing peuvent calculer tout ce qui peut être calculé.  Il existe des classes de problèmes (par exemple, le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">problème de l’arrêt</a> ) qui peuvent être calculés à l’aide des machines de Turing dans certains cas seulement.  Lorsque le mot «calculable» est utilisé dans ce texte, il signifie «calculable par une machine de Turing». <br><br>  Le calcul lambda illustre l'approche consistant à appliquer des fonctions aux calculs de manière descendante.  Une machine à bande Turing est une approche impérative (étape par étape) de l'informatique, mise en œuvre de façon ascendante. <br><br>  Les langages de programmation de bas niveau, tels que le code machine ou l'assembleur, sont apparus dans les années 40 et, à la fin des années 50, les premiers langages de haut niveau populaires sont apparus et ont mis en œuvre des approches fonctionnelles et impératives.  Ainsi, les dialectes de la langue Lisp sont encore largement utilisés, parmi lesquels Clojure, Scheme, AutoLisp et ainsi de suite.  Dans les années cinquante, des langues comme le FORTRAN et le COBOL sont apparues.  Ce sont des exemples de langages de haut niveau impératifs qui sont toujours vivants.  Bien qu'il convient de noter que les langues de la famille C, dans la plupart des domaines, ont remplacé COBOL et FORTRAN. <br><br>  Les racines de la programmation impérative et fonctionnelle se trouvent dans les mathématiques formelles de l'informatique, elles sont apparues avant les ordinateurs numériques.  La programmation orientée objet (POO) est venue plus tard; elle trouve son origine dans la révolution structurelle de la programmation qui a eu lieu dans les années 60 et 70 du siècle dernier. <br><br>  Le premier objet que je connaissais a été utilisé par Ivan Sutherland dans sa fatidique application Sketchpad, créée entre 1961 et 1962, qu'il a décrite dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cet</a> ouvrage en 1963.  Les objets étaient des caractères graphiques affichés sur l'écran de l'oscilloscope (c'est peut-être la première fois dans l'histoire de l'utilisation d'un écran d'ordinateur graphique) qui prend en charge l'héritage par le biais de délégués dynamiques, qu'Ivan Sutherland a appelé «maîtres» dans son travail.  Tout objet pouvait devenir un objet maître, des instances supplémentaires de l'objet étaient appelées "occurrences".  Cela a fait du système Sketchpad le propriétaire du premier des fameux langages de programmation qui implémentait l'héritage des prototypes. <br><br>  Le premier langage de programmation, communément appelé "orienté objet", était le langage Simula, dont les spécifications ont été développées en 1965.  Comme Sketchpad, Silmula prévoyait de travailler avec des objets, mais comprenait également des classes, un héritage basé sur une classe, des sous-classes et des méthodes virtuelles. <br><br>  <i><font color="#999999">Une méthode virtuelle est une méthode définie dans une classe conçue pour être redéfinie par des sous-classes.</font></i>  <i><font color="#999999">Les méthodes virtuelles permettent aux programmes d'appeler des méthodes qui n'existent peut-être pas au moment de la compilation du code, en utilisant la répartition dynamique pour déterminer quelle méthode particulière doit être appelée pendant l'exécution du programme.</font></i>  <i><font color="#999999">JavaScript possède des types dynamiques et utilise une chaîne de délégation pour déterminer la méthode à invoquer. Par conséquent, ce langage n'a pas besoin d'introduire le concept de méthodes virtuelles aux programmeurs.</font></i>  <i><font color="#999999">En d'autres termes, toutes les méthodes de JavaScript utilisent la répartition au moment de l'exécution; par conséquent, les méthodes de JavaScript n'ont pas besoin d'être déclarées «virtuelles» pour prendre en charge cette fonctionnalité.</font></i> <br><br><h2>  <font color="#3AC1EF">Opinion du père OOP sur OOP</font> </h2><br>  <i><font color="#999999">"J'ai inventé le terme" orienté objet "et je peux dire que je ne voulais pas dire C ++."</font></i>  <i><font color="#999999">Alan Kay, Conférence OOPSLA, 1997.</font></i> <br><br>  Alan Kay a inventé le terme «programmation orientée objet», se référant au langage de programmation Smalltalk (1972).  Ce langage a été développé par Alan Kay, Dan Ingles et d'autres employés du Xerox PARC Research Center dans le cadre du projet Dynabook.  Smalltalk était plus orienté objet que Simula.  Dans Smalltalk, tout est un objet, y compris les classes, les entiers et les blocs (fermetures).  L'implémentation initiale du langage, Smalltalk-72, n'avait pas la capacité de sous-classe.  Cette fonctionnalité est apparue dans Smalltalk-76. <br><br>  Bien que Smalltalk ait pris en charge les classes et, par conséquent, le sous-classement, Smalltalk n'a pas mis ces idées au premier plan.  C'était un langage fonctionnel que Lisp a influencé autant que Simula.  Selon Alan Kay, traiter les classes comme un mécanisme de réutilisation de code est une erreur.  L'industrie de la programmation accorde une grande attention à la création de sous-classes, distrayant des avantages réels de la programmation orientée objet. <br><br>  JavaScript et Smalltalk ont ​​beaucoup en commun.  Je dirais que JavaScript est la vengeance de Smalltalk sur le monde pour avoir mal compris les concepts de la POO.  Ces deux langues prennent en charge les fonctionnalités suivantes: <br><br><ul><li>  Objets </li><li>  Fonctions et fermetures de première classe. </li><li>  Types dynamiques. </li><li>  Liaison tardive (les fonctions et méthodes peuvent être remplacées lors de l'exécution du programme). </li><li>  POO sans système d'héritage basé sur les classes. </li></ul><br>  <i><font color="#999999">«Je regrette d'avoir trouvé le terme« objets »pour ce phénomène il y a longtemps, car son utilisation conduit au fait que beaucoup de gens accordent une importance primordiale à une idée qui n'est pas aussi importante que la principale.</font></i>  <i><font color="#999999">L'idée principale est la messagerie. "</font></i>  <i><font color="#999999">Alan Kay</font></i> <br><br>  Dans une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">correspondance par</a> courrier électronique de 2003, Alan Kay a précisé ce qu'il avait en tête lorsqu'il a appelé Smalltalk "un langage orienté objet". <br><br>  <i><font color="#999999">«Pour moi, la POO signifie uniquement la messagerie, le stockage local et la protection, l'état de masquage et la liaison très tardive.»</font></i>  <i><font color="#999999">Alan Kay</font></i> <br><br>  En d'autres termes, conformément aux idées d'Alan Kay, les ingrédients les plus importants de la POO sont les suivants: <br><br><ul><li>  Messagerie </li><li>  Encapsulation. </li><li>  Liaison dynamique. </li></ul><br>  Il est important de noter qu'Alan Kay, l'homme qui a inventé le terme «OOP» et l'a apporté aux masses, ne considérait pas l'hérédité et le polymorphisme comme les composants les plus importants de la POO. <br><br><h2>  <font color="#3AC1EF">L'essence de la POO</font> </h2><br>  La combinaison de la messagerie et de l'encapsulation sert plusieurs objectifs importants: <br><br><ul><li>  Éviter l'état mutable partagé d'un objet en encapsulant l'état et en isolant d'autres objets des changements locaux de son état.  La seule façon d'influencer l'état d'un autre objet est de lui demander (plutôt que de lui donner une commande) de changer en lui envoyant un message.  Les changements d'état sont surveillés au niveau cellulaire local, l'état n'est pas mis à la disposition d'autres objets. </li><li>  Séparation des objets les uns des autres.  L'expéditeur du message est faiblement couplé au récepteur via l'API de messagerie. </li><li>  Adaptabilité et résistance aux changements pendant l'exécution du programme grâce à une liaison tardive.  L'adaptation aux changements pendant l'exécution du programme offre de nombreux avantages importants, qu'Alan Kay considérait très importants pour la POO. </li></ul><br>  Alan Kay, qui a exprimé ces idées, s'est inspiré de ses connaissances en biologie et de ses connaissances sur ARPANET (il s'agit d'une première version d'Internet).  À savoir, nous parlons de cellules biologiques et d'ordinateurs individuels connectés au réseau.  Même alors, Alan Kay a imaginé comment les programmes s'exécutent sur d'énormes ordinateurs distribués (Internet), tandis que les ordinateurs individuels agissent comme des cellules biologiques, travaillant indépendamment avec leur propre état isolé et échangeant des données avec d'autres ordinateurs en envoyant des messages. <br><br>  <i><font color="#999999">"J'ai réalisé qu'une métaphore pour une cellule ou un ordinateur aiderait à se débarrasser des données [...]."</font></i>  <i><font color="#999999">Alan Kay</font></i> <br><br>  Dire «aider à se débarrasser des données», Alan Kay, bien sûr, était conscient des problèmes causés par l'état mutable partagé et de la forte connectivité causée par le partage des données.  Aujourd'hui, ces sujets sont largement entendus.  Mais à la fin des années 1960, les programmeurs ARPANET n'étaient pas satisfaits de la nécessité de choisir une représentation de modèle de données pour leurs programmes avant de développer des programmes.  Les développeurs ont voulu s'éloigner de cette pratique, car, avant de se plonger dans le cadre déterminé par la présentation des données, il est plus difficile de changer quelque chose à l'avenir. <br><br>  Le problème était que différentes façons de présenter les données nécessitaient, pour y accéder, un code différent et une syntaxe différente dans les langages de programmation utilisés à un moment donné.  Le Saint Graal serait ici un moyen universel d'accéder et de gérer les données.  Si toutes les données se ressemblaient pour le programme, cela résoudrait de nombreux problèmes des développeurs concernant le développement et la maintenance des programmes. <br>  Alan Kay a tenté de "se débarrasser" de l'idée, selon laquelle les données et les programmes étaient, en un sens, des entités indépendantes.  Ils ne sont pas considérés comme tels dans List ou Smalltalk.  Il n'y a pas de séparation entre ce qui peut être fait avec des données (avec des valeurs, des variables, des structures de données, etc.) et des constructions logicielles comme des fonctions.  Les fonctions sont des «citoyens de première classe» et les programmes peuvent changer pendant leur exécution.  En d'autres termes, Smalltalk n'a pas de relation privilégiée spéciale avec les données. <br><br>  Alan Kay, en outre, considérait les objets comme des structures algébriques, qui donnaient des garanties précises et mathématiquement prouvables de leur comportement. <br><br>  <i><font color="#999999">"Mes connaissances mathématiques m'ont permis de comprendre que chaque objet peut avoir plusieurs modèles algébriques associés, qu'il peut y avoir des groupes entiers de modèles similaires et qu'ils peuvent être très, très utiles."</font></i>  <i><font color="#999999">Alan Kay</font></i> <br><br>  Il a été prouvé qu'il en était ainsi, et cela a constitué la base pour des objets, tels que les promesses et les lentilles, de plus, la théorie des catégories a été influencée par les deux. <br>  La nature algébrique de la façon dont Alan Kay a vu les objets permettrait aux objets de fournir une vérification formelle, un comportement déterministe et d'améliorer la testabilité, car les modèles algébriques sont, par essence, des opérations qui obéissent à plusieurs règles sous la forme d'équations. <br><br>  Dans le jargon des programmeurs, les «modèles algébriques» sont des abstractions créées à partir de fonctions (opérations) qui sont accompagnées de certaines règles, imposées par des tests unitaires que ces fonctions doivent réussir (axiomes, équations). <br><br>  Ces idées sont oubliées depuis des décennies dans la plupart des langages orientés objet de la famille C, notamment C ++, Java, C #, etc.  Mais ces idées commencent la recherche du voyage de retour, dans les versions récentes des langages orientés objet les plus utilisés. <br><br>  A cette occasion, quelqu'un peut dire que le monde de la programmation redécouvre les avantages de la programmation fonctionnelle et fournit des arguments rationnels dans le contexte des langages orientés objet. <br><br>  Comme JavaScript et Smalltalk plus tôt, la plupart des langages orientés objet modernes deviennent de plus en plus "multi-paradigmes".  Il n'y a aucune raison de choisir entre la programmation fonctionnelle et la POO.  Lorsque nous examinons l'essence historique de chacune de ces approches, elles semblent non seulement compatibles, mais aussi complémentaires. <br><br>  D'après les pensées d'Alan Kay, quel est le plus important au sein de l'OLP? <br><br><ul><li>  Encapsulation. </li><li>  Messagerie </li><li>  Liaison dynamique (capacité des programmes à se développer et à s'adapter aux changements pendant leur exécution). </li></ul><br>  Qu'est-ce qui est négligeable dans la POO? <br><br><ul><li>  Cours. </li><li>  Héritage basé sur les classes. </li><li>  Relation particulière aux objets, fonctions ou données. </li><li> <code>new</code> mot-clé. </li><li>  Polymorphisme. </li><li>  Typage statique. </li><li>  Attitude envers les classes en tant que «types». </li></ul><br>  Si vous connaissez Java ou C #, vous pourriez penser que le typage statique ou le polymorphisme sont les ingrédients les plus importants de la POO, mais Alan Kay préfère traiter les modèles de comportement universels sous forme algébrique.  Voici un exemple écrit en Haskell: <br><br><pre> <code class="hljs erlang-repl">fmap :: (a -&gt; b) -&gt; fa -&gt; fb</code> </pre> <br>  Il s'agit de la signature du foncteur de <code>map</code> universel, qui fonctionne avec les types non définis <code>a</code> et <code>b</code> , en appliquant la fonction de <code>a</code> à <code>b</code> dans le contexte du foncteur <code>a</code> afin de créer le foncteur <code>b</code> .  «Functor» est un mot du jargon mathématique dont la signification est réduite à «support de l'opération d'affichage».  Si vous connaissez la méthode <code>[].map()</code> en JavaScript, vous savez déjà ce que cela signifie. <br><br>  Voici quelques exemples JavaScript: <br><br><pre> <code class="hljs powershell">// isEven = Number =&gt; Boolean const isEven = n =&gt; n % <span class="hljs-number"><span class="hljs-number">2</span></span> === <span class="hljs-number"><span class="hljs-number">0</span></span>; const nums = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>]; //  map   `a =&gt; b`    `a` ( `this`) //     `b` //    `a`   `Number`,   `b`  `Boolean` const results = nums.map(isEven); console.log(results); // [<span class="hljs-type"><span class="hljs-type">false</span></span>, <span class="hljs-type"><span class="hljs-type">true</span></span>, <span class="hljs-type"><span class="hljs-type">false</span></span>, <span class="hljs-type"><span class="hljs-type">true</span></span>, <span class="hljs-type"><span class="hljs-type">false</span></span>, <span class="hljs-type"><span class="hljs-type">true</span></span>]</code> </pre> <br>  La méthode <code>.map()</code> est universelle, dans le sens où <code>a</code> et <code>b</code> peuvent être de tout type, et cette méthode résout sans problème une situation similaire, car les tableaux sont des structures de données qui mettent en œuvre les lois algébriques des foncteurs.  Les types de <code>.map()</code> n'ont pas d'importance, car cette méthode n'essaie pas de travailler directement avec les valeurs correspondantes.  Au lieu de cela, il utilise une fonction qui attend et renvoie des valeurs des types correspondants qui sont correctes du point de vue de l'application. <br><br><pre> <code class="hljs pgsql">// matches = a =&gt; <span class="hljs-type"><span class="hljs-type">Boolean</span></span> //  `a`    ,   const matches = control =&gt; input =&gt; input === control; const strings = [<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-string"><span class="hljs-string">'bar'</span></span>, <span class="hljs-string"><span class="hljs-string">'baz'</span></span>]; const results = strings.map(matches(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>)); console.log(results); // [<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>]</code> </pre> <br>  La relation des types universels peut être difficile à exprimer correctement et complètement dans des langages comme TypeScript, mais elle est très simple à faire dans le système de type Hindley-Milner utilisé dans Haskell, qui prend en charge les types supérieurs (types de type). <br><br>  La plupart des systèmes de types imposent des restrictions trop fortes pour permettre la libre expression d'idées dynamiques et fonctionnelles, telles que la composition des fonctions, la libre composition des objets, l'expansion des objets pendant l'exécution du programme, l'utilisation de combinateurs, de lentilles, etc.  En d'autres termes?  les types statiques rendent souvent difficile l'écriture de logiciels à l'aide de méthodes de construction. <br><br>  Si votre système de types a trop de restrictions (comme dans TypeScript ou Java), pour atteindre les mêmes objectifs, vous devez écrire du code plus complexe que lorsque vous utilisez des langages avec une approche plus libre de la frappe.  Cela ne signifie pas que l'utilisation de types statiques est une idée malheureuse, ou que toutes les implémentations de types statiques ont les mêmes limitations.  Par exemple, j'ai rencontré beaucoup moins de problèmes avec le système de type Haskell. <br><br>  Si vous êtes un fan des types statiques et que vous n'êtes pas contre les restrictions, je vous souhaite sept pieds sous la quille.  Mais si vous trouvez que certaines des idées exprimées ici sont difficiles à mettre en œuvre en raison du fait qu'il n'est pas facile de taper des fonctions obtenues en composant d'autres fonctions et des structures algébriques composites, blâmez le système de types et non l'idée.  Les conducteurs aiment les commodités que les VUS à châssis leur offrent, mais personne ne se plaint de ne pas voler.  Pour voler, vous avez besoin d'un véhicule qui a plus de degrés de liberté. <br><br>  Si les restrictions rendent votre code plus simple, tant mieux!  Mais si les contraintes vous obligent à écrire du code plus complexe, alors peut-être que quelque chose ne va pas avec ces contraintes. <br><br><h2>  <font color="#3AC1EF">Qu'est-ce qu'un «objet»?</font> </h2><br>  Le mot «objet», au fil du temps, a acquis de nombreuses connotations secondaires de sens.  Ce que nous appelons des «objets» en JavaScript sont simplement des types de données composites, sans aucune allusion à la programmation basée sur les classes, ni aux idées de passage de messages d'Alan Kay. <br><br>  En JavaScript, ces objets peuvent prendre en charge, et prennent souvent en charge, l'encapsulation, le passage de messages, la séparation des comportements par le biais de méthodes, voire le polymorphisme à l'aide de sous-classes (bien qu'en utilisant une chaîne de délégation plutôt qu'une répartition basée sur le type). <br><br>  Alan Kay voulait se débarrasser de la différence entre le programme et ses données.  JavaScript, dans une certaine mesure, atteint cet objectif en plaçant les méthodes d'objet au même endroit que les propriétés qui stockent les données.  Par exemple, n'importe quelle propriété peut être affectée à n'importe quelle fonction.  Vous pouvez construire le comportement d'un objet de manière dynamique et modifier le contenu sémantique de l'objet pendant l'exécution du programme. <br><br>  Un objet est juste une structure de données composite, et il n'a besoin de rien de spécial pour être considéré comme un objet.  Cependant, la programmation à l'aide d'objets ne conduit pas au fait qu'un tel code se révèle «orienté objet», tout comme l'utilisation de fonctions ne rend pas le code «fonctionnel». <br><br><h2>  <font color="#3AC1EF">La POO n'est plus une vraie POO</font> </h2><br>  Étant donné que le concept d '«objet» dans les langages de programmation modernes signifie beaucoup moins que ce qu'Alan Kay voulait dire, j'utilise le mot «composant» au lieu du mot «objet» pour décrire les règles de ce POO.  De nombreux objets sont directement détenus et contrôlés par du code JavaScript tiers, mais les composants doivent encapsuler leur propre état et le contrôler. <br><br>  Voici ce qu'est la vraie POO: <br><br><ul><li>  Programmation à l'aide de composants (Alan Kay les appelle des «objets»). </li><li>  L'état du composant doit être encapsulé. </li><li>  Pour la communication entre les entités, la messagerie est utilisée. </li><li>  Les composants peuvent être ajoutés, modifiés et remplacés lors de l'exécution. </li></ul><br>  La plupart des comportements d'objet peuvent être définis de manière universelle à l'aide de structures de données algébriques.  Il n'y a pas besoin d'héritage.  Les composants peuvent réutiliser les comportements des fonctions publiques et importer des modules, sans avoir à rendre leurs données publiques. <br><br>  La manipulation d'objets en JavaScript ou l'utilisation de l'héritage basé sur une classe ne signifie pas que quelqu'un est impliqué dans la programmation POO.  Mais l'utilisation de composants de cette manière - signifie.  Mais il est très difficile de se débarrasser des idées établies sur les termes, alors peut-être devrions-nous laisser le terme «POO» et appeler ce que les «composants» ci-dessus sont utilisés comme «programmation orientée message (MOP)»?  Nous utiliserons le terme «MOP» ci-dessous pour parler de programmation orientée message. <br><br>  Par hasard, le mot anglais «mop» est traduit par «mop» et, comme vous le savez, ils sont utilisés pour rétablir l'ordre. <br><br><h2>  <font color="#3AC1EF">À quoi ressemble une bonne MOP?</font> </h2><br>  La plupart des programmes modernes ont une interface utilisateur (User Interface, UI) qui est chargée d'interagir avec l'utilisateur, un code qui gère l'état de l'application (données utilisateur) et un code qui fonctionne avec le système ou qui est responsable de l'échange de données avec le réseau. <br><br>  Pour prendre en charge le fonctionnement de chacun de ces systèmes, des processus à longue durée de vie, tels que des écouteurs d'événements, peuvent être nécessaires.  Ici, vous aurez besoin de l'état de l'application - pour stocker quelque chose comme des informations sur les connexions réseau, sur l'état des choses avec les contrôles d'interface et sur l'application elle-même. <br><br>  Un bon MOP signifie qu'au lieu que tous ces systèmes aient accès à l'état de l'autre et puissent les contrôler directement, ils interagissent les uns avec les autres par le biais de messages.  Lorsque l'utilisateur clique sur le bouton "Enregistrer", le message <code>"SAVE"</code> peut être envoyé.  Le composant d'application de gestion d'état peut interpréter ce message et le rediriger vers le gestionnaire responsable de la mise à jour à partir de l'état (tel qu'une fonction de réducteur pur).  Peut-être qu'après la mise à jour de l'état, le composant responsable de la gestion de l'état envoie le message <code>"STATE_UPDATED"</code> composant d'interface utilisateur qui, à son tour, interprète l'état, décide quelles parties de l'interface doivent être mises à jour et transfère l'état mis à jour aux sous-composants chargés de travailler avec éléments d'interface spécifiques. <br><br>  Pendant ce temps, le composant responsable des connexions réseau peut surveiller la connexion de l'utilisateur à un autre ordinateur du réseau, écouter les messages et envoyer une vue mise à jour de l'état pour l'enregistrer sur la machine distante.  Un tel composant est chargé de travailler avec des mécanismes de réseau, sait si la connexion fonctionne ou non, etc. <br><br>  Les systèmes d'application similaires ne devraient pas connaître les détails de ses autres parties.  Ils ne devraient se soucier que de résoudre leurs propres problèmes.  Les composants du système peuvent être démontés et assemblés en tant que constructeur.  Ils implémentent des interfaces standardisées, ce qui signifie qu'ils peuvent interagir les uns avec les autres.  Tant que les exigences bien connues pour l'interface des composants sont remplies, ces composants peuvent être remplacés par d'autres, avec les mêmes interfaces, mais faisant la même chose différemment, ou effectuant, recevant les mêmes messages, quelque chose de complètement différent.  Vous pouvez changer un composant en un autre même pendant l'exécution du programme - cela ne cassera pas son travail. <br><br>  Les composants d'un système logiciel n'ont même pas besoin d'être sur le même ordinateur.  Le système peut être décentralisé.  Le stockage en réseau peut placer des données dans un système de stockage décentralisé comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IPFS</a> , par conséquent, l'utilisateur est indépendant de la santé d'une machine particulière, ce qui garantit la sécurité de ses données.  Avec cette approche, les données sont stockées de manière fiable et protégées contre les intrus. <br><br>  L'OLP, en partie, est tombée sous l'influence des idées d'ARPANET, et l'un des objectifs de ce projet était de créer un réseau décentralisé qui serait résistant aux attaques comme une frappe nucléaire. <br><br>  Un bon système MOP peut être caractérisé par un niveau de stabilité similaire en utilisant des composants qui prennent en charge l'échange à chaud pendant que l'application est en cours d'exécution.  Il pourra continuer à fonctionner si l'utilisateur travaille avec lui à partir d'un téléphone portable et est hors de la couverture réseau du fait qu'il est entré dans le tunnel.  Si un ouragan interrompait l'alimentation électrique de l'un des centres de données dans lesquels ses serveurs sont situés, il continuera également de fonctionner. <br><br>  Il est temps que le monde du logiciel se libère d'une expérience d'héritage basée sur une classe infructueuse et adopte les principes mathématiques et scientifiques qui étaient à la pointe de la POO. <br><br>  Il est temps pour nous, développeurs, de créer des programmes plus flexibles, stables et beaux en utilisant une combinaison harmonieuse de MOP et de programmation fonctionnelle. <br>  Soit dit en passant, l'acronyme "MOP" est déjà utilisé, décrivant "Monitoring Oriented Programming", mais ce concept, contrairement à la POO, disparaîtra tout simplement. <br><br>  Par conséquent, ne vous découragez pas si le terme «MOP» ne ressemble pas à un mot du jargon des programmeurs.  Ranger juste votre POO avec les principes MOP ci-dessus. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr428582/">https://habr.com/ru/post/fr428582/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr428572/index.html">Composants d'ordre supérieur dans React</a></li>
<li><a href="../fr428574/index.html">Faites passer la communication d'entreprise au niveau supérieur avec Zextras Chat</a></li>
<li><a href="../fr428576/index.html">[signet] Version PDF du tutoriel Node.js et nouveau guide JavaScript</a></li>
<li><a href="../fr428578/index.html">Comment démarrer avec Hibernate Search</a></li>
<li><a href="../fr428580/index.html">Bon guide de communication</a></li>
<li><a href="../fr428588/index.html">Résumé des événements informatiques en novembre (deuxième partie)</a></li>
<li><a href="../fr428590/index.html">Microinteractions et micro invites dans l'interface</a></li>
<li><a href="../fr428592/index.html">Arrêtez d'embaucher des «gestionnaires efficaces». Ils sont non seulement inutiles, mais nocifs</a></li>
<li><a href="../fr428596/index.html">Elon Musk a licencié des chefs de projet Internet par satellite Starlink en raison du non-respect des délais</a></li>
<li><a href="../fr428598/index.html">Réseaux de neurones profonds pour l'évaluation automatique des appels</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>