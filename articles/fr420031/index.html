<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü¶á üï∑Ô∏è üìã Dessin avec des cibles de rendu dans Unreal Engine ‚¨ÜÔ∏è üë©üèæ‚Äçüé® üèÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La cible de rendu est essentiellement une texture sur laquelle vous pouvez √©crire lors de l'ex√©cution. Du point de vue du moteur, ils stockent des inf...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dessin avec des cibles de rendu dans Unreal Engine</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420031/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/276/6ee/ee4/2766eeee4fcc87c31919d427c829ee98.gif"></div><br>  La cible de rendu est essentiellement une texture sur laquelle vous pouvez √©crire lors de l'ex√©cution.  Du point de vue du moteur, ils stockent des informations telles que la couleur de base, les normales et l'occlusion ambiante. <br><br>  Du point de vue de l'utilisateur, les cibles de rendu sont principalement utilis√©es comme une sorte de cam√©ra suppl√©mentaire.  Vous pouvez d√©finir la capture de la sc√®ne √† un moment donn√© et enregistrer l'image dans la cible de rendu.  Vous pouvez ensuite afficher la cible de rendu sur le maillage, par exemple, pour simuler une cam√©ra de surveillance. <br><br>  Apr√®s la sortie de la version du moteur 4.13, Epic a ajout√© la possibilit√© de dessiner des mat√©riaux directement sur la cible de rendu en utilisant des contours.  Cette fonction vous permet de cr√©er des effets complexes, tels que la simulation de fluide et la d√©formation de la neige.  Cela semble incroyable, non?  Mais avant de passer √† des effets aussi complexes, il est pr√©f√©rable de se familiariser avec quelque chose de simple.  Quoi de plus simple que de dessiner sur une cible de rendu? <br><br>  Dans ce didacticiel, vous apprendrez ce qui suit: <br><br><ul><li>  Cr√©ez des cibles de rendu dynamiquement avec des contours </li><li>  Afficher la cible de rendu sur le maillage </li><li>  Dessiner une texture sur la cible de rendu </li><li>  Changer la taille et la texture du pinceau pendant le jeu </li></ul><a name="habracut"></a><br><blockquote>  <em>Remarque:</em> ce didacticiel suppose que vous connaissez d√©j√† les bases de l'utilisation d'Unreal Engine.  Si vous d√©butez avec Unreal Engine, consultez notre s√©rie en dix parties de didacticiels <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Unreal Engine pour les d√©butants</a> . </blockquote><br><h2>  Se rendre au travail </h2><br>  Commen√ßons par t√©l√©charger du mat√©riel pour ce tutoriel (vous pouvez les obtenir <a href="">ici</a> ).  D√©compressez-les, acc√©dez √† <em>CanvasPainterStarter</em> et ouvrez <em>CanvasPainter.uproject</em> .  Si vous cliquez sur <em>Lecture</em> , vous verrez ce qui suit: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9b9/e6d/01f/9b9e6d01f6955d5a93f737588f4bb730.jpg"></div><br>  Le carr√© au milieu (toile) est ce sur quoi nous allons dessiner.  Les √©l√©ments de l'interface utilisateur sur la gauche seront la texture que nous allons dessiner et sa taille. <br><br>  Voyons d'abord la m√©thode utilis√©e pour dessiner. <br><br><h2>  M√©thode de dessin </h2><br>  La premi√®re chose dont nous avons besoin est une cible de rendu, utilis√©e comme toile.  Pour d√©terminer o√π dessiner sur la cible de rendu, nous allons tracer la ligne droite sortant de la cam√©ra vers l'avant.  Si la ligne coupe la toile, nous pouvons obtenir l'intersection dans l'espace UV. <br><br>  Par exemple, si le canevas a une liaison parfaite des coordonn√©es UV, l'intersection au centre renverra la valeur <em>(0,5, 0,5)</em> .  Si la ligne traverse la toile dans le coin inf√©rieur droit, nous obtiendrons la valeur <em>(1, 1)</em> .  Ensuite, vous pouvez utiliser des calculs simples pour calculer l'emplacement du dessin. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5f2/369/fe2/5f2369fe21d9655fa5e7fc0914c6c023.gif"></div><br>  Mais pourquoi obtenir les coordonn√©es dans l'espace UV?  Pourquoi ne pas utiliser les coordonn√©es de l'espace r√©el du monde?  Lors de l'utilisation de l'espace du monde, nous devons d'abord calculer l'intersection par rapport au plan.  Vous devrez √©galement prendre en compte la rotation et l'√©chelle de l'avion. <br><br>  Lorsque vous utilisez l'espace UV, tous ces calculs ne sont pas n√©cessaires.  Sur un plan avec une liaison parfaite des coordonn√©es UV, l'intersection avec le milieu revient toujours <em>(0,5, 0,5)</em> , quels que soient l'emplacement et la rotation du plan. <br><br><blockquote>  <em>Remarque: la</em> m√©thode consid√©r√©e dans ce didacticiel ne fonctionne g√©n√©ralement qu'avec des plans ou des surfaces similaires aux plans.  D'autres types de g√©om√©trie n√©cessitent une m√©thode plus complexe, que je couvrirai dans un autre tutoriel. </blockquote><br>  Tout d'abord, nous allons cr√©er du mat√©riel qui rendra la cible de rendu. <br><br><h2>  Cr√©er du mat√©riel de toile </h2><br>  Acc√©dez au dossier <em>Mat√©riaux</em> et ouvrez <em>M_Canvas</em> . <br><br>  Dans ce didacticiel, nous allons cr√©er des cibles de rendu de mani√®re dynamique √† l'aide de contours.  Cela signifie que nous devons configurer la texture en tant que param√®tre afin de pouvoir la passer pour rendre la cible.  Pour ce faire, cr√©ez un <em>TextureSampleParameter2D</em> et appelez-le <em>RenderTarget</em> .  Connectez-le ensuite √† <em>BaseColor</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/439/741/68a/43974168a064c39f35acc53ab09f1c65.jpg"></div><br>  Pour l'instant, ne vous inqui√©tez pas de choisir une texture - nous le ferons plus tard dans les plans.  Cliquez sur <em>Appliquer</em> , puis fermez <em>M_Canvas</em> . <br><br>  L'√©tape suivante consiste √† cr√©er une cible de rendu, apr√®s quoi nous l'utilisons comme mat√©riau de canevas. <br><br><h2>  Cr√©ation d'une cible de rendu </h2><br>  Il existe deux fa√ßons de cr√©er une cible de rendu.  Tout d'abord: cr√©er dans l'√©diteur en cliquant sur <em>Add New \ Materials &amp; Textures \ Render Target</em> .  Cette m√©thode vous permet de r√©f√©rencer facilement la m√™me cible de rendu √† plusieurs acteurs.  Cependant, si nous avons besoin de plusieurs toiles, nous devrons cr√©er une cible de rendu manuellement pour chaque toile. <br><br>  Par cons√©quent, il est pr√©f√©rable de cr√©er des cibles de rendu √† l'aide de contours.  L'avantage de cette approche est que nous cr√©ons des cibles de rendu uniquement lorsque cela est n√©cessaire et qu'elles ne gonflent pas la taille des fichiers de projet. <br><br>  Nous devons d'abord cr√©er une cible de rendu et l'enregistrer en tant que variable pour une utilisation future.  Acc√©dez au dossier <em>Blueprints</em> et ouvrez <em>BP_Canvas</em> .  Localisez l' <em>√©v√©nement BeginPlay</em> et ajoutez les n≈ìuds s√©lectionn√©s. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ed/91a/e85/7ed91ae8543ccf5875dad7828c308ed1.jpg"></div><br>  D√©finissez la <em>largeur</em> et la <em>hauteur</em> sur <em>1024</em> .  Nous modifions donc la r√©solution de la cible de rendu √† <em>1024 √ó 1024</em> .  Plus la valeur est √©lev√©e, plus la qualit√© d'image est √©lev√©e, mais aussi plus le co√ªt de la m√©moire vid√©o est √©lev√©. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aeb/56f/96c/aeb56f96c38d3ae2606d4f3b2d3abeaf.jpg"></div><br>  Vient ensuite le n≈ìud <em>Clear Render Target 2D</em> .  Nous pouvons utiliser ce n≈ìud pour d√©finir la couleur de la cible de rendu.  R√©glez <em>Clear Color</em> sur <em>(0,07, 0,13, 0,06)</em> .  Dans ce cas, la totalit√© de la cible de rendu se remplira de couleur verd√¢tre. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/94b/d30/eed/94bd30eedc1f590ffd157c8091d7898e.jpg"></div><br>  Nous devons maintenant afficher la cible de rendu sur le maillage du canevas. <br><br><h3>  Affichage de la cible de rendu </h3><br>  √Ä ce stade, le maillage du canevas utilise le mat√©riau par d√©faut.  Pour afficher la cible de rendu, vous devez cr√©er une instance dynamique de <em>M_Canvas</em> et lui passer la cible de rendu.  Vous devez ensuite appliquer une instance dynamique du mat√©riau au maillage du canevas.  Pour ce faire, nous allons ajouter les n≈ìuds s√©lectionn√©s: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c9a/7d8/1aa/c9a7d81aa770c63cc6cf75f52746c4c3.jpg"></div><br>  Tout d'abord, passons au n≈ìud <em>Cr√©er une instance de mat√©riau dynamique</em> et d√©finissons la valeur <em>parent</em> sur <em>M_Canvas</em> .  Nous allons donc cr√©er une instance dynamique de <em>M_Canvas</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da7/f26/2bf/da7f262bfda0215098287d3a2286085b.jpg"></div><br>  Ensuite, acc√©dez au n≈ìud <em>D√©finir la valeur du param√®tre de texture</em> et d√©finissez le <em>nom</em> du <em>param√®tre</em> sur <em>RenderTarget</em> .  Nous passerons donc la cible de rendu au param√®tre de texture cr√©√© pr√©c√©demment. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c7/8d0/377/7c78d0377ef6a592c05f5cd54d08a89e.jpg"></div><br>  Maintenant, la cible de rendu sera affich√©e sur le maillage du canevas.  Cliquez sur <em>Compiler</em> et revenez √† l'√©diteur principal.  Cliquez sur <em>Lecture</em> pour voir comment la toile change de couleur. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53f/949/fd6/53f949fd6ad350b4a016545af0eca47c.jpg"></div><br>  Maintenant que nous avons la toile, nous devons cr√©er un mat√©riau pouvant √™tre utilis√© comme pinceau. <br><br><h2>  Cr√©er un mat√©riau de pinceau </h2><br>  Acc√©dez au dossier <em>Mat√©riaux</em> .  Cr√©ez le mat√©riau <em>M_Brush</em> et ouvrez-le.  <em>R√©glez d'</em> abord le <em>mode</em> de <em>fusion</em> sur <em>Translucide</em> .  Cela nous permettra d'utiliser des textures avec transparence. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf2/18a/4b7/cf218a4b7b0e2c57f307cd06d8a92860.jpg"></div><br>  Comme pour la toile, nous d√©finissons la texture du pinceau en √©moussant.  Cr√©ez un <em>TextureSampleParameter2D</em> et nommez-le <em>BrushTexture</em> .  Connectez-le comme suit: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/097/c49/7d1/097c497d1e50af95c004f9bdfe849897.jpg"></div><br>  Cliquez sur <em>Appliquer</em> , puis fermez <em>M_Brush</em> . <br><br>  La prochaine chose √† faire est de cr√©er une instance dynamique du mat√©riau du pinceau afin de pouvoir changer la texture du pinceau.  Ouvrez <em>BP_Canvas</em> et ajoutez les n≈ìuds s√©lectionn√©s. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/49d/628/860/49d62886060349fc146ce04c150d539c.jpg"></div><br>  Ensuite, acc√©dez au n≈ìud <em>Cr√©er une instance de mat√©riau dynamique</em> et d√©finissez le <em>parent</em> sur <em>M_Canvas</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e0/009/4aa/8e00094aa61fbd27c527f207b360856b.jpg"></div><br>  Nous avons cr√©√© le mat√©riau du pinceau et nous avons maintenant besoin d'une fonction pour peindre avec le pinceau sur la cible de rendu. <br><br><h2>  Peinture au pinceau sur la cible de rendu </h2><br>  Cr√©ez une nouvelle fonction et nommez-la <em>DrawBrush</em> .  Nous avons d'abord besoin des param√®tres: texture utilis√©e, taille du pinceau et endroit pour dessiner.  Cr√©ez l'entr√©e suivante: <br><br><ul><li>  <em>BrushTexture:</em> s√©lectionnez le type <em>Texture 2D</em> <br></li><li>  <em>BrushSize:</em> s√©lectionnez le type de <em>flotteur</em> <br></li><li>  <em>DrawLocation:</em> s√©lectionnez le type <em>Vector 2D</em> </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6e/2cb/d2f/e6e2cbd2f9e69222d7bcbe616d30f8b2.jpg"></div><br>  Avant de dessiner un pinceau, nous devons d√©finir sa texture.  Pour ce faire, cr√©ez le circuit illustr√© ci-dessous.  Assurez-vous que <em>BrushTexture est</em> s√©lectionn√© comme <em>nom de param√®tre</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ff/645/efc/0ff645efc2374126884a93b9b3a8c25b.jpg"></div><br>  Maintenant, nous devons faire le rendu dans la cible de rendu.  Pour ce faire, cr√©ez les n≈ìuds s√©lectionn√©s: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c69/b73/c02/c69b73c027dc7280673644d512498492.jpg"></div><br>  <em>Commencer √† dessiner le canevas sur la cible de rendu indique</em> au moteur que nous voulons commencer le rendu sur une cible de rendu sp√©cifique.  <em>Dessiner un mat√©riau</em> vous permet de dessiner du mat√©riau √† un emplacement sp√©cifi√© avec la taille et la rotation s√©lectionn√©es. <br><br>  Le calcul de la position de rendu est un processus en deux √©tapes.  Nous devons d' <em>abord</em> mettre √† l' <em>√©chelle DrawLocation</em> pour tenir dans la r√©solution de la cible de rendu.  Pour ce faire, multipliez <em>DrawLocation</em> par <em>Size</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cbb/513/4d2/cbb5134d2311305c42095e53939cc130.jpg"></div><br>  Par d√©faut, le moteur rendra les mat√©riaux en utilisant le coin sup√©rieur gauche comme point de d√©part.  Par cons√©quent, la texture du pinceau ne sera pas centr√©e sur nous l√† o√π nous voulons effectuer le rendu.  Pour r√©soudre ce probl√®me, nous devons diviser <em>BrushSize</em> par <em>2</em> , puis soustraire le r√©sultat de l'√©tape pr√©c√©dente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/501/58f/e82/50158fe822073487d12a3099f86c7737.jpg"></div><br>  Ensuite, nous connectons tout comme suit: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d58/20a/111/d5820a1117491a78e4e020c4fd13e6ca.jpg"></div><br>  Enfin, nous devons dire au moteur que nous voulons arr√™ter le rendu dans la cible de rendu.  Ajoutez le n≈ìud <em>End Draw Canvas au rendu cible</em> et connectez-le comme suit: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/86f/8ff/a3e/86f8ffa3ecad0a4b3b47fe21f4044eb0.jpg"></div><br>  Maintenant, chaque fois que <em>DrawBrush est</em> ex√©cut√© <em>,</em> il d√©finira d'abord la texture transmise comme texture pour <em>BrushMaterial</em> .  Elle rendra ensuite le <em>BrushMaterial</em> dans le <em>RenderTarget</em> , en utilisant la position et la taille transmises. <br><br>  Et l√†-dessus, la fonction de rendu est pr√™te.  Cliquez sur <em>Compiler</em> et fermez <em>BP_Canvas</em> .  L'√©tape suivante consiste √† tracer la ligne depuis la cam√©ra et √† dessiner √† l'endroit de la toile o√π l'intersection s'est produite. <br><br><h2>  Trace directe de la cam√©ra </h2><br>  Avant de dessiner sur la toile, nous devons sp√©cifier la texture et la taille du pinceau.  Acc√©dez au dossier <em>Blueprints</em> et ouvrez <em>BP_Player</em> .  D√©finissez ensuite la variable BrushTexture sur <em>T_Brush_01</em> et la variable <em>BrushSize</em> sur <em>500</em> .  Nous attribuons donc une image au pinceau d'un singe d'une taille de <em>500 √ó 500</em> pixels. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a76/ab2/b26/a76ab2b267bd2f0ea514b319528eeb26.jpg"></div><br>  Ensuite, vous devez tracer la ligne.  Localisez <em>InputAxis Paint</em> et cr√©ez le diagramme suivant: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/775/cf0/68e/775cf068e5c0820fa2d4539ca6ae3960.jpg"></div><br>  Nous allons donc tracer la ligne dirig√©e directement depuis la cam√©ra pendant que le joueur tient la touche assign√©e √† <em>Paint</em> (dans notre cas, c'est le <em>bouton gauche de la souris</em> ). <br><br>  Maintenant, nous devons v√©rifier si la toile droite s'est crois√©e.  Ajouter des n≈ìuds s√©lectionn√©s: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da5/f53/97b/da5f5397b6a59eebdb9fce09541a35d8.jpg"></div><br>  Maintenant, lorsque la ligne et le canevas se <em>croisent</em> , la fonction <em>DrawBrush</em> sera ex√©cut√©e, en utilisant les variables de pinceau et les coordonn√©es UV qui lui sont transmises. <br><br>  Pour que le n≈ìud <em>Find Collision UV</em> fonctionne, nous devons modifier deux param√®tres.  Tout d'abord, acc√©dez au n≈ìud <em>LineTraceByChannel</em> et <em>activez</em> <em>Trace Complex</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/759/207/f4a/759207f4a22689a21f91f6c244648f75.jpg"></div><br>  Ensuite, acc√©dez √† <em>Edit \ Project Settings</em> , puis √† <em>Engine \ Physics</em> .  Activez <em>Support UV From Hit Results</em> et red√©marrez le projet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c8f/42d/56b/c8f42d56bac2b1ec4ad15884efa7f51d.jpg"></div><br>  Apr√®s le red√©marrage, pour dessiner sur le canevas, cliquez sur <em>Lecture</em> et <em>cliquez avec le bouton gauche</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2b3/5ff/ad6/2b35ffad6680fa6349018143397310f3.gif"></div><br>  Vous pouvez m√™me cr√©er plusieurs toiles et dessiner sur chacune d'elles s√©par√©ment.  Cela est possible car chaque canevas cr√©e dynamiquement sa propre cible de rendu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/151/9c6/89e/1519c689ef59642b5fbb6a8dfbd304dc.gif"></div><br>  Dans la section suivante, nous impl√©mentons la fonction de modification de la taille du pinceau d'un joueur. <br><br><h2>  Redimensionner la brosse </h2><br>  Ouvrez <em>BP_Player</em> et recherchez le n≈ìud <em>InputAxis ChangeBrushSize</em> .  Cette liaison d'axe est configur√©e pour utiliser <em>la molette de la souris</em> .  Pour modifier la taille du pinceau, il nous suffit de modifier la valeur <em>BrushSize en</em> fonction de la valeur de l' <em>axe</em> .  Pour ce faire, cr√©ez le sch√©ma suivant: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/554/da6/2c8/554da62c836912958e8588e582862a69.jpg"></div><br>  Il effectuera l'addition ou la soustraction de <em>BrushSize</em> lorsque le joueur utilise la molette de la souris.  La premi√®re multiplication d√©termine le taux d'addition ou de soustraction.  <em>Une pince (flotteur) a √©t√©</em> ajout√©e par mesure de s√©curit√©.  Il garantit que la taille de la brosse ne devient pas inf√©rieure √† <em>0</em> ou sup√©rieure √† <em>1000</em> . <br><br>  Cliquez sur <em>Compiler</em> et revenez √† l'√©diteur principal.  Faites tourner <em>la molette</em> de <em>la souris</em> pour redimensionner le pinceau pendant le dessin. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/276/6ee/ee4/2766eeee4fcc87c31919d427c829ee98.gif"></div><br>  Dans la derni√®re section, nous allons cr√©er une fonctionnalit√© qui permet au joueur de changer la texture du pinceau. <br><br><h2>  Changer la texture du pinceau </h2><br>  Tout d'abord, nous avons besoin d'un tableau pour stocker les textures que le joueur peut utiliser.  Ouvrez <em>BP_Player</em> et cr√©ez une variable de <em>tableau</em> .  S√©lectionnez le type de <em>texture 2D</em> et nommez-le <em>Textures</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/425/45f/db9/42545fdb9060f05e84a1e251be28bc3e.jpg"></div><br>  Cr√©ez ensuite <em>trois</em> √©l√©ments dans <em>Textures</em> .  Attribuez-leur les valeurs suivantes: <br><br><ul><li>  <em>T_Brush_01</em> </li><li>  <em>T_Brush_02</em> </li><li>  <em>T_Brush_03</em> </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93e/a5a/9fb/93ea5a9fb103654bac3448131c9b6d11.jpg"></div><br>  Ce seront les textures que le joueur pourra dessiner.  Pour ajouter de nouvelles textures, ajoutez-les simplement √† ce tableau. <br><br>  Ensuite, nous avons besoin d'une variable pour stocker l'index actuel du tableau.  Cr√©ez une variable <em>enti√®re</em> et nommez-la <em>CurrentTextureIndex</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0f/b87/b82/c0fb87b8243042c1ce3a6d441490b63e.jpg"></div><br>  Ensuite, nous avons besoin d'un moyen de parcourir toutes les textures dans une boucle.  Pour ce didacticiel, j'ai configur√© un mappage d'action appel√© <em>NextTexture</em> et <em>je l'ai</em> li√© au <em>bouton droit de la souris</em> .  Lorsque le joueur appuie sur cette touche, la transition vers la texture suivante doit √™tre effectu√©e.  Pour ce faire, recherchez le n≈ìud <em>InputAction NextTexture</em> et cr√©ez le diagramme suivant: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3f2/3d1/9ad/3f23d19ad803a74af5a11892dc7e3579.jpg"></div><br>  Ce sch√©ma incr√©mente <em>CurrentTextureIndex</em> chaque fois que vous <em>cliquez avec le bouton droit</em> .  Si l'index atteint la fin du tableau, il est √† nouveau r√©initialis√© √† <em>0</em> .  Enfin, <em>BrushTexture</em> d√©finit la texture appropri√©e. <br><br>  Cliquez sur <em>Compiler</em> et fermez <em>BP_Player</em> .  Cliquez sur <em>Lecture</em> et <em>cliquez</em> avec le bouton <em>droit</em> pour basculer entre les textures. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f4/ed0/d25/8f4ed0d25ed9f1944327137905ecba2b.gif"></div><br><h2>  O√π aller ensuite? </h2><br>  Le projet termin√© peut √™tre t√©l√©charg√© <a href="">ici</a> . <br><br>  La cible de rendu est un outil extr√™mement puissant et dans ce tutoriel, nous n'avons couvert que les bases.  Si vous souhaitez savoir de quelles capacit√©s de rendu les cibles sont capables, consultez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rendu Multipass bas√©</a> sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">contenu dans UE4</a> .  Cette vid√©o contient des exemples de dessin de cartes de flux, de dessin volum√©trique, de simulations de fluides, etc. <br><br>  Consultez √©galement notre vid√©o de didacticiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Blueprint Drawing to Render Targets</a> pour apprendre √† cr√©er une carte de hauteur avec une cible de rendu. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr420031/">https://habr.com/ru/post/fr420031/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr420019/index.html">Interaction client-serveur dans un nouveau jeu de tir PvP mobile et un serveur de jeu: probl√®mes et solutions</a></li>
<li><a href="../fr420021/index.html">Pourquoi avez-vous besoin de Splunk? Internet des objets et donn√©es industrielles</a></li>
<li><a href="../fr420023/index.html">Enregistrement des √©tats dans les applications Android</a></li>
<li><a href="../fr420025/index.html">Ferme intelligente. √Ä quoi ressemblera-t-elle?</a></li>
<li><a href="../fr420029/index.html">Comment nous, chez 1C: Enterprise, r√©solvons des syst√®mes d'√©quations alg√©briques</a></li>
<li><a href="../fr420033/index.html">Comment nous avons commenc√© √† enregistrer les caisses enregistreuses pour nos clients</a></li>
<li><a href="../fr420035/index.html">Interface graphique de Golang: GTK + 3</a></li>
<li><a href="../fr420037/index.html">Stream avec plusieurs cam√©ras √† partir de mat√©riaux improvis√©s</a></li>
<li><a href="../fr420039/index.html">Pens√©e fonctionnelle. 2e partie</a></li>
<li><a href="../fr420041/index.html">TypeScript War ou Enum Conquest</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>