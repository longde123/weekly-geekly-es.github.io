<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ôüèæ ü§° ü•å Desenvolvimento de aplicativos h√≠bridos PHP / Go usando RoadRunner üè¢ üëàüèª üÖæÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O aplicativo PHP cl√°ssico √© um carregamento pesado de thread √∫nico (a menos que voc√™ escreva em microframes) e a morte inevit√°vel do processo ap√≥s cad...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desenvolvimento de aplicativos h√≠bridos PHP / Go usando RoadRunner</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/461827/"> O aplicativo PHP cl√°ssico √© um carregamento pesado de thread √∫nico (a menos que voc√™ escreva em microframes) e a morte inevit√°vel do processo ap√≥s cada solicita√ß√£o ... Esse aplicativo √© pesado e lento, mas podemos dar uma segunda vida por hibridiza√ß√£o.  Para acelerar - demonizamos e otimizamos o vazamento de mem√≥ria para obter melhor desempenho - apresentaremos nosso pr√≥prio servidor de aplicativos PHP Golang RoadRunner para adicionar flexibilidade - simplificar o c√≥digo PHP, expandir a pilha e compartilhar responsabilidades entre o servidor e o aplicativo.  Em ess√™ncia, faremos nosso aplicativo funcionar como se o estiv√©ssemos escrevendo em Java ou em outra linguagem. <br><br>  Gra√ßas √† hibridiza√ß√£o, um aplicativo anteriormente lento parou de sofrer 502 erros sob carga, o tempo m√©dio de resposta √†s solicita√ß√µes diminuiu, a produtividade aumentou e a implanta√ß√£o e montagem ficaram mais f√°ceis devido √† unifica√ß√£o do aplicativo e √† elimina√ß√£o de liga√ß√µes desnecess√°rias na forma de nginx + php-fpm. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/RUm94xCaXMo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Anton Titov</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Lachezis</a> ) √© CTO e co-fundador da SpiralScout LLC, com 12 anos de experi√™ncia ativa em desenvolvimento comercial em PHP.  Nos √∫ltimos anos, ele implementou ativamente a Golang na pilha de desenvolvimento da empresa.  Anton falou sobre um exemplo no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PHP Russia 2019</a> . <br><a name="habracut"></a><br><h2>  Ciclo de vida de aplicativos PHP </h2><br>  Esquematicamente, um dispositivo de aplicativo abstrato com uma certa estrutura se parece com isso. <br><br><img src="https://habrastorage.org/webt/mm/va/0d/mmva0djqxjc5l733ikzi738ydry.jpeg"><br><br>  Quando enviamos uma solicita√ß√£o para um processo, acontece: <br><br><ul><li>  inicializa√ß√£o do projeto; </li><li>  carregando bibliotecas compartilhadas, estruturas e ORMs; </li><li>  carregando bibliotecas necess√°rias para um projeto espec√≠fico; </li><li>  roteamento; </li><li>  solicita√ß√£o de roteamento para um controlador espec√≠fico; </li><li>  gera√ß√£o de resposta. </li></ul><br>  Esse √© o princ√≠pio de opera√ß√£o de um <strong>aplicativo</strong> cl√°ssico <strong>de encadeamento √∫nico</strong> com um √∫nico ponto de entrada, que ap√≥s cada execu√ß√£o √© completamente destru√≠do ou limpa seu estado.  Todo o c√≥digo √© descarregado da mem√≥ria, o trabalhador √© limpo ou simplesmente redefine seu estado. <br><br><h3>  Carregamento lento </h3><br>  A maneira padr√£o e f√°cil de acelerar √© a implementa√ß√£o do <strong>sistema de carregamento lento</strong> ou das bibliotecas de carregamento sob demanda. <br><br><img src="https://habrastorage.org/webt/vj/eb/gp/vjebgpv7_a4fuvu64x4g8eqmbke.jpeg"><br><br><blockquote>  Com o carregamento lento, solicitamos apenas o c√≥digo necess√°rio. </blockquote><br>  Ao acessar um controlador espec√≠fico, apenas as bibliotecas necess√°rias ser√£o carregadas na mem√≥ria, processadas e depois descarregadas.  Isso permite <strong>reduzir o tempo m√©dio de resposta do projeto</strong> e facilitar muito o processo de trabalho no servidor.  Em todas as estruturas que estamos usando atualmente, o princ√≠pio do carregamento lento √© implementado. <br><br><h3>  C√°lculos frequentes de cache </h3><br>  O m√©todo √© mais complicado e usado ativamente, por exemplo, na estrutura Symfony, mecanismos de modelo, esquemas ORM e roteamento.  Isso n√£o est√° armazenando em cache como memcached ou Redis para dados do usu√°rio.  Este sistema <strong>aquece partes do c√≥digo antecipadamente</strong> .  Na primeira solicita√ß√£o, o sistema gera um c√≥digo ou arquivo de cache e, nas solicita√ß√µes subsequentes, esses c√°lculos, necess√°rios, por exemplo, para compilar um modelo, n√£o ser√£o mais executados. <br><br><img src="https://habrastorage.org/webt/nb/44/f6/nb44f6isfvs6vouultxridabeps.jpeg"><br><br>  O armazenamento em cache <strong>acelera</strong> significativamente <strong>o aplicativo</strong> , mas ao mesmo tempo o <strong>complica</strong> .  Por exemplo, h√° problemas com a invalida√ß√£o do cache e a atualiza√ß√£o do aplicativo.  N√£o confunda o cache do usu√°rio com o cache do aplicativo - em um, os dados mudam com o tempo, no outro somente quando o c√≥digo √© atualizado. <br><br><h3>  Processamento de solicita√ß√£o </h3><br>  Quando uma solicita√ß√£o √© recebida de um servidor PHP-FPM externo, o ponto de entrada e a inicializa√ß√£o da solicita√ß√£o coincidem. <br><br><blockquote>  Acontece que a solicita√ß√£o do cliente √© o estado do nosso processo. </blockquote><br>  A √∫nica maneira de alterar esse estado √© destruir completamente o trabalhador e come√ßar de novo com uma nova solicita√ß√£o. <br><br><img src="https://habrastorage.org/webt/jc/cr/rb/jccrrb-szkhb6_nfn2zthotuctk.jpeg"><br><br>  Este √© um modelo cl√°ssico de thread √∫nico com suas vantagens. <br><br><ul><li>  Todos os trabalhadores no final da solicita√ß√£o morrem. </li><li>  Vazamentos de mem√≥ria, condi√ß√£o de corrida, conflitos n√£o s√£o inerentes ao PHP.  Voc√™ n√£o pode se preocupar com isso. </li><li>  O c√≥digo √© simples: escrevemos, processamos a solicita√ß√£o, morremos e seguimos em frente. </li></ul><br>  Por outro lado, para cada solicita√ß√£o, carregamos completamente a estrutura, todas as bibliotecas, realizamos alguns c√°lculos, recompilamos os modelos.  Com cada solicita√ß√£o em um c√≠rculo, produzimos muitas manipula√ß√µes e trabalho desnecess√°rio. <br><br><h3>  Como funciona no servidor </h3><br>  Muito provavelmente, um monte de nginx e PHP funcionar√°.  O Nginx funcionar√° como um proxy reverso: d√™ aos usu√°rios parte das estat√≠sticas e delegue parte das solicita√ß√µes ao gerenciador de processos PHP PHP-FPM abaixo.  O gerente j√° cria um trabalhador separado para a solicita√ß√£o e a processa.  Depois disso, o trabalhador √© destru√≠do ou liberado.  Em seguida, um novo trabalhador √© criado para a pr√≥xima solicita√ß√£o. <br><br><img src="https://habrastorage.org/webt/8f/lc/fp/8flcfpz6zxemgxlas6avx5aguqa.jpeg"><br><br>  Esse modelo funciona de forma est√°vel - o aplicativo √© quase imposs√≠vel de matar.  Mas, sob cargas pesadas, a quantidade de trabalho para inicializar e destruir trabalhadores afeta o desempenho do sistema, porque mesmo para uma simples solicita√ß√£o GET, muitas vezes precisamos puxar v√°rias depend√™ncias e aumentar novamente a conex√£o com o banco de dados. <br><br><h2>  Acelerando o aplicativo </h2><br>  Como acelerar o aplicativo cl√°ssico ap√≥s a introdu√ß√£o do cache e do carregamento lento?  Que outras op√ß√µes existem? <br><br>  <strong>Vire para o pr√≥prio idioma</strong> . <br><br><ul><li>  <strong>Use o OPCache.</strong>  Eu acho que ningu√©m est√° executando o PHP na produ√ß√£o sem o OPCache ativado? </li><li>  Aguarde <strong>RFC: pr√©-carregando</strong> .  Ele permite pr√©-carregar um conjunto de arquivos em uma m√°quina virtual. </li><li>  <strong>JIT</strong> - acelera seriamente o aplicativo em tarefas associadas √† CPU.  Infelizmente, com tarefas relacionadas a bancos de dados, isso n√£o ajudar√° muito. </li></ul><br>  <strong>Use alternativas</strong> .  Por exemplo, a m√°quina virtual HHVM do Facebook.  Ele executa o c√≥digo em um ambiente mais otimizado.  Infelizmente, o HHVM n√£o √© totalmente compat√≠vel com a sintaxe do PHP.  Como alternativa, os compiladores kPHP do VK ou PeachPie, que convertem completamente o c√≥digo em .NET C #, s√£o uma alternativa. <br><br>  <strong>Reescreva totalmente para outro idioma.</strong>  Esta √© uma op√ß√£o radical - elimine completamente o carregamento de c√≥digo entre solicita√ß√µes. <br><br>  Voc√™ pode <b>armazenar</b> completamente <b>o estado do aplicativo na mem√≥ria</b> , us√°-lo ativamente para trabalhar e esquecer o conceito de trabalhador que est√° morrendo e limpar completamente o aplicativo entre solicita√ß√µes. <br><br>  Para conseguir isso, movemos o ponto de entrada, que costumava estar junto com o ponto de inicializa√ß√£o, para dentro do aplicativo. <br><br><h3>  Transferindo ponto de entrada - demoniza√ß√£o </h3><br>  Isso est√° criando um loop infinito no aplicativo: solicita√ß√£o de entrada - execute-a na estrutura - gere uma resposta para o usu√°rio.  Esta √© uma economia s√©ria - toda a inicializa√ß√£o, toda a inicializa√ß√£o da estrutura √© realizada apenas uma vez e, em seguida, v√°rias solicita√ß√µes s√£o processadas pelo aplicativo. <br><br><img src="https://habrastorage.org/webt/ce/7k/3l/ce7k3lov0kzcyxc3zyjq008taiy.jpeg"><br><br><h3>  N√≥s adaptamos a aplica√ß√£o </h3><br>  Curiosamente, podemos nos concentrar em otimizar apenas a parte do aplicativo que ser√° executada <strong>em tempo de execu√ß√£o</strong> : controladores, l√≥gica de neg√≥cios.  Nesse caso, voc√™ pode abandonar o modelo de carregamento lento.  Iremos participar do projeto de bootstrap desde o in√≠cio - no momento da inicializa√ß√£o.  C√°lculos preliminares: roteamento, modelos, configura√ß√µes, esquemas ORM inflar√£o a inicializa√ß√£o, mas no futuro eles economizar√£o tempo de processamento para uma solicita√ß√£o espec√≠fica. <br><br><img src="https://habrastorage.org/webt/fz/kj/ft/fzkjftdkc41niwqyrmml-ijjkwy.jpeg"><br><br>  N√£o recomendo compilar modelos ao baixar um trabalhador, mas o download, por exemplo, de todas as configura√ß√µes √© √∫til. <br><br><h3>  Comparar modelos </h3><br>  Compare os modelos demonizados (esquerda) e cl√°ssicos. <br><br><img src="https://habrastorage.org/webt/zo/en/6r/zoen6rl8zyj6tpn7bghp_ozv61m.jpeg"><br><br>  O modelo demonizado leva mais tempo desde o momento em que o processo foi criado at√© o momento em que a resposta √© retornada ao usu√°rio.  O aplicativo cl√°ssico √© otimizado para cria√ß√£o, processamento e destrui√ß√£o r√°pidos. <br><br>  No entanto, todas as solicita√ß√µes subsequentes ap√≥s o aquecimento do c√≥digo s√£o muito mais r√°pidas.  A estrutura, o aplicativo e o cont√™iner j√° est√£o na mem√≥ria e prontos para aceitar solicita√ß√µes e responder rapidamente. <br><br><h3>  Problemas do modelo de longa dura√ß√£o </h3><br>  Apesar das vantagens, o modelo possui um conjunto de limita√ß√µes. <br><br>  <strong>Vazamentos de mem√≥ria.</strong>  O aplicativo fica na mem√≥ria por muito tempo e, se voc√™ usar as "curvas" da biblioteca, as depend√™ncias incorretas ou os estados globais - a mem√≥ria come√ßar√° a vazar.  Em algum momento, ser√° exibido um erro fatal que interromper√° a solicita√ß√£o do usu√°rio. <br><br>  O problema √© resolvido de duas maneiras. <br><br><ul><li>  Escreva um c√≥digo preciso, use bibliotecas comprovadas. </li><li>  Monitore ativamente os trabalhadores.  Se voc√™ suspeitar que a mem√≥ria est√° vazando dentro do processo, altere-a proativamente para um anal√≥gico com um limite inferior, ou seja, simplesmente para uma nova c√≥pia que ainda n√£o conseguiu acumular mem√≥ria n√£o limpa. </li></ul><br>  <strong>Vazamentos de dados</strong> .  Por exemplo, se durante uma solicita√ß√£o recebida salvarmos o usu√°rio atual do sistema em alguma vari√°vel global e esquecermos de redefinir essa vari√°vel ap√≥s a solicita√ß√£o, √© poss√≠vel que o pr√≥ximo usu√°rio do sistema obtenha acesso acidental a dados que ele n√£o deve ver. <br><br>  O problema foi resolvido no n√≠vel da arquitetura do aplicativo. <br><br><ul><li>  N√£o armazene um usu√°rio ativo em um contexto global.  Todos os dados espec√≠ficos do contexto da solicita√ß√£o s√£o descartados e limpos antes da pr√≥xima solicita√ß√£o. </li><li>  Manuseie os dados da sess√£o com cuidado.  Sess√µes em PHP - com a abordagem cl√°ssica, este √© um objeto global.  Enrole-o corretamente para que, mediante solicita√ß√£o subsequente, seja redefinido. </li></ul><br>  <strong>Gerenciamento de recursos</strong> . <br><br><ul><li>  Monitore as conex√µes com o banco de dados.  Se o aplicativo ficar na mem√≥ria por um m√™s ou dois, a conex√£o aberta provavelmente ser√° fechada dentro desse per√≠odo: o banco de dados ser√° reinstalado, reiniciado ou o firewall redefinir√° a conex√£o.  No n√≠vel do c√≥digo, considere reconectar ou, ap√≥s cada solicita√ß√£o, redefinir a conex√£o e aument√°-la novamente na pr√≥xima solicita√ß√£o. </li><li>  Evite bloqueio de arquivo de longa dura√ß√£o.  Se o seu trabalhador gravar algumas informa√ß√µes em um arquivo, n√£o h√° problema.  Mas se esse arquivo estiver aberto e tiver um bloqueio, nenhum outro processo no seu sistema ter√° acesso a ele at√© que o bloqueio seja liberado. </li></ul><br><br><h2>  Explore o modelo de longa dura√ß√£o </h2><br>  Considere um modelo de trabalhador de longa dura√ß√£o - demonizando um aplicativo - e explore maneiras de implement√°-lo. <br><br><h3>  Abordagem sem bloqueio </h3><br>  Usamos PHP ass√≠ncrono - carregamos o aplicativo uma vez na mem√≥ria e processamos solicita√ß√µes HTTP recebidas dentro do aplicativo.  Agora, o <strong>aplicativo e o servidor s√£o um processo</strong> .  Quando a solicita√ß√£o chega, criamos uma rotina separada ou, no loop de eventos, prometemos, processamos e entregamos ao usu√°rio. <br><br><img src="https://habrastorage.org/webt/v6/js/od/v6jsodvtlxjfy1udzwvl0wa2njk.jpeg"><br><br>  A vantagem ineg√°vel da abordagem √© o desempenho m√°ximo.  Tamb√©m √© poss√≠vel usar ferramentas interessantes, por exemplo, <strong>configurar o WebSocket diretamente no seu aplicativo</strong> . <br><br>  No entanto, a abordagem <strong>aumenta</strong> significativamente <strong>a complexidade do desenvolvimento</strong> .  √â necess√°rio instalar o ELDO, lembre-se de que nem todos os drivers de banco de dados ser√£o suportados e a biblioteca PDO est√° exclu√≠da. <br><br>  Para resolver problemas no caso de demoniza√ß√£o com uma abordagem sem bloqueio, voc√™ pode usar ferramentas conhecidas: <strong>ReactPHP</strong> , <strong>amphp</strong> e <strong>Swoole</strong> - um desenvolvimento interessante na forma de uma extens√£o C.  Essas ferramentas funcionam rapidamente, possuem uma boa comunidade e boa documenta√ß√£o. <br><br><h3>  Abordagem de bloqueio </h3><br>  N√≥s n√£o elevamos corotinas dentro do aplicativo, mas fazemos de fora. <br><br><img src="https://habrastorage.org/webt/ad/ul/eq/adulequ1msa3sb6ae6saah3bu-c.jpeg"><br><br>  N√≥s apenas <strong>escolhemos alguns processos de aplica√ß√£o</strong> , como o PHP-FPM faria.  Em vez de transmitir essas solicita√ß√µes na forma de um estado do processo, as entregamos de fora na forma de um protocolo ou mensagem. <br><br>  Escrevemos o mesmo <strong>c√≥digo de thread √∫nico</strong> que conhecemos, usamos as mesmas bibliotecas e o mesmo PDO.  Todo o trabalho duro de trabalhar com soquetes, HTTP e outras ferramentas √© feito <strong>fora do aplicativo PHP</strong> . <br><br>  Dos pontos negativos: devemos <strong>monitorar a mem√≥ria</strong> e lembrar que a <strong>comunica√ß√£o entre dois processos diferentes n√£o √© livre</strong> , mas precisamos transferir dados.  Isso criar√° uma ligeira sobrecarga. <br><br>  Para resolver o problema, j√° existe uma <strong>ferramenta PHP-RM</strong> escrita em PHP.  Na biblioteca ReactPHP, possui <strong>integra√ß√£o com v√°rias estruturas</strong> .  No entanto, o PHP-PM √© muito <strong>lento, vaza mem√≥ria no n√≠vel do servidor</strong> e, sob carga, n√£o mostra tanto crescimento quanto o PHP-FRM. <br><br><h2>  Escrevemos nosso servidor de aplicativos </h2><br>  N√≥s escrevemos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nosso servidor de aplicativos</a> , que √© semelhante ao PHP-RM, mas h√° mais funcionalidades.  O que quer√≠amos do servidor? <br><br>  <strong>Combine com estruturas existentes.</strong>  Gostar√≠amos de ter uma integra√ß√£o flex√≠vel com quase todas as estruturas do mercado.  N√£o tenho vontade de escrever uma ferramenta que funcione apenas em um caso espec√≠fico. <br><br>  <strong>Diferentes processos para servidor e aplicativo</strong> .  Possibilidade de uma reinicializa√ß√£o a quente, para que, ao desenvolver localmente, pressione F5 e veja o novo c√≥digo atualizado, al√©m de poder expandi-los individualmente. <br><br>  <strong>Alta velocidade e estabilidade</strong> .  Ainda assim, estamos escrevendo um servidor HTTP. <br><br>  <strong>F√°cil extensibilidade</strong> .  Queremos usar o servidor n√£o apenas como um servidor HTTP, mas tamb√©m para cen√°rios individuais como um servidor de filas ou um servidor gRPC. <br><br>  <strong>Trabalhe imediatamente,</strong> sempre que poss√≠vel: Windows, Linux, CPU ARM. <br><br>  Capacidade de escrever <strong>extens√µes multithread</strong> muito <strong>r√°pidas,</strong> espec√≠ficas para a nossa aplica√ß√£o. <br><br>  Como voc√™ j√° entendeu, vamos escrever em Golang. <br><br><h2>  Servidor RoadRunner </h2><br>  Para criar um servidor PHP, voc√™ precisa resolver 4 problemas principais: <br><br><ul><li>  Estabelecer comunica√ß√£o entre os processos Golang e PHP. </li><li>  Gerenciamento de processos: cria√ß√£o, destrui√ß√£o, monitoramento de trabalhadores. </li><li>  Balanceamento de tarefas - distribui√ß√£o eficiente de tarefas aos trabalhadores.  Como estamos implementando um sistema que bloqueia um trabalhador individual para uma tarefa de entrada espec√≠fica espec√≠fica, √© importante criar um sistema que diga rapidamente que o processo terminou o trabalho e est√° pronto para aceitar a pr√≥xima tarefa. </li><li>  Pilha HTTP - enviando dados da solicita√ß√£o HTTP para o trabalhador.  √â uma tarefa simples escrever um ponto de entrada para o qual o usu√°rio envia uma solicita√ß√£o, que √© passada ao PHP e retornada. </li></ul><br><h3>  Variantes de intera√ß√£o entre processos </h3><br>  Primeiro, vamos resolver o problema de comunica√ß√£o entre os processos Golang e PHP.  Temos v√°rias maneiras. <br><br>  <strong>Incorpora√ß√£o: incorpora√ß√£o de um int√©rprete PHP diretamente no Golang.</strong>  Isso √© poss√≠vel, mas requer um assembly PHP personalizado, configura√ß√£o complexa e um processo comum para o servidor e o PHP.  Como no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">go-php</a> , por exemplo, onde o interpretador PHP √© integrado ao Golang. <br><br>  <strong>Mem√≥ria compartilhada - O uso do espa√ßo de mem√≥ria compartilhada,</strong> <strong>onde os processos compartilham esse espa√ßo</strong> .  √â preciso um trabalho meticuloso.  Ao trocar dados, voc√™ precisar√° sincronizar o estado manualmente e a quantidade de erros que podem ocorrer √© bastante grande.  A mem√≥ria compartilhada tamb√©m depende do sistema operacional. <br><br><h3>  Escrevendo seu protocolo de transporte - Goridge </h3><br>  Seguimos um caminho simples que √© usado em quase todas as solu√ß√µes em sistemas Linux - usamos o protocolo de transporte.  Est√° <strong>escrito em cima dos PIPES e UNIX / TCP padr√£o</strong> . <br><br>  Ele tem a capacidade de transferir dados em ambas as dire√ß√µes, detectar erros e tamb√©m marcar solicita√ß√µes e colocar cabe√ßalhos nelas.  Uma nuance importante para n√≥s √© a capacidade de implementar o protocolo sem depend√™ncias do lado do PHP e Golang - sem extens√µes C em linguagem pura. <br><br>  Como em qualquer protocolo, a base √© um pacote de dados.  No nosso caso, o pacote possui um cabe√ßalho fixo de 17 bytes. <br><br><img src="https://habrastorage.org/webt/wb/_h/g_/wb_hg_qtkmoxe74sthy12rhtzms.jpeg"><br><br>  O primeiro byte √© alocado para determinar o tipo de pacote.  Pode ser um fluxo ou um sinalizador que indica o tipo de serializa√ß√£o de dados.  Em seguida, duas vezes empacotamos o tamanho dos dados em Little Endian e Big Endian.  Usamos esse legado para detectar erros de transmiss√£o.  Se percebermos que o tamanho dos dados compactados em dois pedidos diferentes n√£o corresponde, provavelmente ocorreu um erro de transfer√™ncia de dados.  Ent√£o os dados s√£o transmitidos. <br><br><img src="https://habrastorage.org/webt/bt/rb/dr/btrbdre8cwionih8m6e7yze2crw.jpeg"><br><br>  Na terceira vers√£o do pacote, nos livraremos desse legado, apresentaremos uma abordagem mais cl√°ssica com uma soma de verifica√ß√£o e tamb√©m adicionaremos a capacidade de usar esse protocolo com processos PHP ass√≠ncronos. <br><br>  Para implementar o protocolo em Golang e PHP, usamos ferramentas padr√£o. <br><br>  <strong>No Golang:</strong> bibliotecas de codifica√ß√£o / bin√°rias e io e net para trabalhar com pipes padr√£o e soquetes UNIX / TCP. <br><br>  <strong>No PHP:</strong> a fun√ß√£o familiar para trabalhar com pacote / descompacta√ß√£o de dados bin√°rios e os fluxos de extens√µes e soquetes para tubos e soquetes. <br><br>  Um <strong>efeito colateral</strong> interessante surgiu durante a implementa√ß√£o.  N√≥s o integramos √† biblioteca l√≠quida / rpc Golang padr√£o, que nos permite chamar o c√≥digo de servi√ßo da Golang diretamente no aplicativo. <br><br>  Escrevemos um servi√ßo: <br><br><pre><code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//  sample type  struct{} // Hi returns greeting message. func (a *App) Hi(name string, r *string) error { *r = fmt.Sprintf("ll, %s!", name) return nil }</span></span></code> </pre> <br>  Com uma pequena quantidade de c√≥digo, chamamos de aplicativo: <br><br><pre> <code class="go hljs">&lt;?php use Spiral\Goridge; require <span class="hljs-string"><span class="hljs-string">"vendor/autoload.php"</span></span>; $rpc = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Goridge\RPC( <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Goridge\SocketRelay(<span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span>, <span class="hljs-number"><span class="hljs-number">6001</span></span>) ); echo $rpc-&gt;call(<span class="hljs-string"><span class="hljs-string">"App.Hi"</span></span>, <span class="hljs-string"><span class="hljs-string">"Antony"</span></span>);</code> </pre> <br><h3>  Gerenciador de processos PHP </h3><br>  A pr√≥xima parte do servidor √© o gerenciamento de trabalhadores PHP. <br><img src="https://habrastorage.org/webt/vt/jy/tk/vtjytk9effas7jkgjgadvbek_zw.jpeg"><br><br>  Worker √© um processo PHP que constantemente observamos na Golang.  Coletamos o log de seus erros no arquivo STDERR, nos comunicamos com o trabalhador atrav√©s do protocolo de transporte Goridge e coletamos estat√≠sticas sobre consumo de mem√≥ria, execu√ß√£o de tarefas e bloqueio. <br><br>  A implementa√ß√£o √© simples - essa √© a funcionalidade padr√£o de os / exec, runtime, sync, atomic.  Para criar trabalhadores, usamos <strong>Worker Factory</strong> . <br><img src="https://habrastorage.org/webt/wq/kr/tt/wqkrtt0n0xxvhdnxuvx_4f2deiy.jpeg"><br><br>  Por que f√°brica de trabalhadores?  Porque queremos nos comunicar tanto em tubos padr√£o quanto em soquetes.  Nesse caso, o processo de inicializa√ß√£o √© um pouco diferente.  Ao criar um trabalhador que se comunica por canal, podemos cri√°-lo imediatamente e enviar dados diretamente.  No caso de soquetes, voc√™ precisa criar um trabalhador, aguardar at√© que ele atinja o sistema, fazer um aperto de m√£o PID e s√≥ ent√£o continuar trabalhando. <br><br><h3>  Balanceador de tarefas </h3><br>  A terceira parte do servidor √© a mais importante para o desempenho. <br><br>  Para implementa√ß√£o, usamos a funcionalidade padr√£o Golang - um <strong>canal em buffer</strong> .  Em particular, criamos v√°rios trabalhadores e os colocamos neste canal como uma pilha LIFO. <br><img src="https://habrastorage.org/webt/bm/po/f4/bmpof4s5-owl810px69ectqiw_i.jpeg"><br>  Ao receber tarefas do usu√°rio, enviamos uma solicita√ß√£o para a pilha LIFO e solicitamos que o primeiro trabalhador livre seja emitido.  Se o trabalhador n√£o puder ser alocado por um determinado per√≠odo de tempo, o usu√°rio receber√° um erro do tipo "Erro de tempo limite".  Se o trabalhador estiver alocado - ele sai da pilha, √© bloqueado, ap√≥s o que recebe a tarefa do usu√°rio. <br><img src="https://habrastorage.org/webt/cm/2o/cq/cm2ocqak94ubao7tk8vxnglfyyo.jpeg"><br>  Depois que a tarefa √© processada, a resposta √© retornada ao usu√°rio e o trabalhador fica no final da pilha.  Ele est√° pronto para executar a pr√≥xima tarefa novamente. <br><img src="https://habrastorage.org/webt/oj/f_/l4/ojf_l4ipil8fcslpyherhsg02la.jpeg"><br>  Se ocorrer um erro, o usu√°rio receber√° um erro, pois o trabalhador ser√° destru√≠do.  Solicitamos ao Worker Pool e Worker Factory para criar um processo id√™ntico e substitu√≠-lo na pilha.  Isso permite que o sistema funcione mesmo em caso de erros fatais, simplesmente recriando trabalhadores por analogia com o PHP-FPM. <br><img src="https://habrastorage.org/webt/qs/li/dq/qslidqche8glb-q5pucwfwnpogw.jpeg"><br><br>  Como resultado, acabou implementando um pequeno sistema que funciona muito rapidamente - <strong>200 ns para aloca√ß√£o de trabalhadores</strong> .  √â capaz de funcionar mesmo em caso de erros fatais.  Cada trabalhador, em determinado momento, processa apenas uma tarefa, o que nos permite usar a <strong>abordagem cl√°ssica de bloqueio</strong> . <br><br><h3>  Monitoramento proativo </h3><br>  Uma parte separada do gerenciador de processos e do balanceador de tarefas √© o sistema de monitoramento proativo. <br><img src="https://habrastorage.org/webt/83/zq/ep/83zqepdmerd6ozakntcmv33hnus.jpeg"><br><br>  Este √© um sistema que, uma vez por segundo, pesquisa trabalhadores e monitora indicadores: analisa quanta mem√≥ria eles consomem, quanto est√£o, se est√£o inativos.  Al√©m do rastreamento, o sistema monitora vazamentos de mem√≥ria.  Se o trabalhador exceder um determinado limite, n√≥s o veremos e o removeremos cuidadosamente do sistema antes que ocorra um vazamento fatal. <br><br><h3>  Pilha HTTP </h3><br>  A √∫ltima e simples parte. <br><img src="https://habrastorage.org/webt/hl/cc/7e/hlcc7ehfob5vhc_zjse_em8e0eg.jpeg"><br>  <strong>Como √© implementado:</strong> <br><br><ul><li>  gera um ponto HTTP no lado Golang; </li><li>  n√≥s recebemos uma solicita√ß√£o; </li><li>  converter para o formato PSR-7; </li><li>  envie a solicita√ß√£o ao primeiro trabalhador livre; </li><li>  Descompacte a solicita√ß√£o em um objeto PSR-7; </li><li>  n√≥s processamos; </li><li>  n√≥s geramos a resposta. </li></ul><br>  Para implementa√ß√£o, usamos a <strong>biblioteca</strong> padr√£o <strong>Golang NET / HTTP</strong> .  Esta √© uma biblioteca famosa com muitas extens√µes.  Capaz de trabalhar tanto em HTTPS quanto em protocolo HTTP / 2. <br><br>  No lado do PHP, usamos o padr√£o PSR-7 <strong>.</strong>  √â uma <strong>estrutura independente</strong> com muitas extens√µes e Middlewares.  O PSR-7 √© <strong>imut√°vel em design</strong> , que se adapta bem ao conceito de aplicativos de longa dura√ß√£o e evita erros globais de consulta. <br><br>  Ambas as estruturas no Golang e no PSR-7 s√£o semelhantes, o que economizou significativamente tempo para mapear uma solicita√ß√£o de um idioma para outro. <br><br>  Para iniciar o servidor, √© necess√°ria uma <strong>liga√ß√£o m√≠nima</strong> : <br><br><pre> <code class="go hljs">http: address: <span class="hljs-number"><span class="hljs-number">0.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>:<span class="hljs-number"><span class="hljs-number">8080</span></span> workers: command: <span class="hljs-string"><span class="hljs-string">"php psr-worker.php"</span></span> pool: numWorkers: <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre> <br>  Al√©m disso, a partir da vers√£o 1.3.0, a √∫ltima parte da configura√ß√£o pode ser omitida. <br><br>  Fa√ßa o download do arquivo bin√°rio do servidor, coloque-o no cont√™iner do Docker ou na pasta do projeto.  Como alternativa, globalmente, escrevemos um pequeno arquivo de configura√ß√£o que descreve qual pod vamos ouvir, qual trabalhador √© o ponto de entrada e quantos s√£o necess√°rios. <br><br>  No lado do PHP, escrevemos um loop prim√°rio que recebe uma solicita√ß√£o PSR-7, a processa e retorna uma resposta ou um erro ao servidor. <br><br><pre> <code class="go hljs">while ($req = $psr7-&gt;acceptRequest()) { try { $resp = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> \Zend\Diactoros\Response(); $resp-&gt;getBody()-&gt;write(<span class="hljs-string"><span class="hljs-string">"hello world"</span></span>); $psr7-&gt;respond($resp); } catch (\Throwable $e) { $psr7-&gt;getWorker()-&gt;error((<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>)$e); } }</code> </pre> <br>  <strong>Assembl√©ia</strong>  Para implementar o servidor, escolhemos uma arquitetura com uma abordagem de componente.  Isso possibilita montar o servidor para as necessidades do projeto, adicionando ou removendo pe√ßas individuais, dependendo dos requisitos do aplicativo. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { rr.Container.Register(env.ID, &amp;env.Service{}) rr.Container.Register(rpc.ID, &amp;rpc.Service{}) rr.Container.Register(http.ID, &amp;http.Service{}) rr.Container.Register(static.ID, &amp;static.Service{}) rr.Container.Register(limit.ID, &amp;limit.Service{} <span class="hljs-comment"><span class="hljs-comment">// you can register additional commands using cmd.CLI rr.Execute() }</span></span></code> </pre> <br><h2>  Casos de uso </h2><br>  Considere as op√ß√µes para usar o servidor e modificar a estrutura.  Para come√ßar, considere o pipeline cl√°ssico - o trabalho do servidor com solicita√ß√µes. <br><br><h3>  Modularidade </h3><br>  O servidor recebe a solicita√ß√£o para um ponto HTTP e a passa por um conjunto de Middleware, escrito em Golang.  Uma solicita√ß√£o de entrada √© convertida em uma tarefa que o trabalhador entende.  O servidor entrega a tarefa ao trabalhador e a devolve. <br><br><img src="https://habrastorage.org/webt/zz/v5/ak/zzv5akvapzklanxdlzunxdq-xpu.jpeg"><br><br>  Ao mesmo tempo, o trabalhador, usando o protocolo Goridge, se comunica com o servidor, monitora seu status e transfere dados para ele. <br><br><h3>  Middleware em Golang: autoriza√ß√£o </h3><br>  Esta √© a primeira coisa a fazer.  Em nosso aplicativo, criamos o Middleware para <strong>autorizar o usu√°rio pelo token JWT</strong> .  O middleware √© escrito da mesma maneira para qualquer outro tipo de autoriza√ß√£o.  Uma implementa√ß√£o muito banal e simples √© escrever limitador de taxa ou disjuntor. <br><br><img src="https://habrastorage.org/webt/on/zg/ro/onzgroqwxc7umuy-y2xfv9s7dqe.jpeg"><br><br>  <strong>A autoriza√ß√£o √© r√°pida</strong> .  Se a solicita√ß√£o n√£o for v√°lida - simplesmente n√£o a envie para o aplicativo PHP e n√£o desperdice recursos no processamento de tarefas in√∫teis. <br><br><h3>  Monitoramento </h3><br>  O segundo caso de uso.  Podemos integrar o sistema de monitoramento diretamente no Golang Middleware.  Por exemplo, Prometheus, para coletar estat√≠sticas sobre a velocidade dos pontos de resposta, o n√∫mero de erros. <br><br><img src="https://habrastorage.org/webt/rz/_o/hz/rz_ohzkiz6bwjoebzqu2qt4e6dc.jpeg"><br><br>  Voc√™ tamb√©m pode <strong>combinar o monitoramento com m√©tricas espec√≠ficas do aplicativo</strong> (dispon√≠vel como padr√£o na 1.4.5).  Por exemplo, podemos enviar o n√∫mero de solicita√ß√µes para o banco de dados ou o n√∫mero de solicita√ß√µes espec√≠ficas processadas para o servidor Golang e, em seguida, para o Prometheus. <br><br><h3>  Rastreamento e registro distribu√≠dos </h3><br>  Escrevemos Middleware com um gerenciador de processos.  Em particular, podemos nos conectar ao sistema em tempo real para monitorar logs e <strong>coletar todos os logs em um banco de dados central</strong> , o que √© √∫til ao escrever aplicativos distribu√≠dos. <br><br><img src="https://habrastorage.org/webt/lf/ir/cd/lfircdprhx6nqetmadblqftvbu4.jpeg"><br><br>  Tamb√©m podemos <strong>marcar solicita√ß√µes</strong> , fornecer um ID espec√≠fico e transmitir esse ID a todos os servi√ßos ou sistemas de comunica√ß√£o downstream entre eles.  Como resultado, podemos criar um <strong>rastreamento distribu√≠do</strong> e ver como os logs do aplicativo v√£o. <br><br><h3>  Registre seu hist√≥rico de consultas </h3><br>  Este √© um pequeno m√≥dulo que registra todas as solicita√ß√µes recebidas e as armazena em um banco de dados externo.  O m√≥dulo permite fazer solicita√ß√µes de reprodu√ß√£o no projeto e implementar um sistema de teste autom√°tico, um sistema de teste de carga ou apenas verificar a opera√ß√£o da API. <br><br><img src="https://habrastorage.org/webt/ex/q3/kg/exq3kgpym1uf6tjcfwysjk1so00.jpeg"><br><br>  Como implementamos o m√≥dulo? <br><br>  <strong>Processamos parte dos pedidos de Golang</strong> .  Escrevemos Middleware em Golang e podemos enviar parte das solicita√ß√µes para Handler, que tamb√©m est√° escrito em Golang.  Se algum ponto do aplicativo √© preocupante em termos de desempenho, reescrevemos para Golang e arrastamos a pilha de um idioma para outro. <br><br><img src="https://habrastorage.org/webt/q0/zf/qn/q0zfqnzddo_mn7h-d779cg9ganm.jpeg"><br><br>  <strong>Estamos escrevendo um servidor WebSocket</strong> .  A implementa√ß√£o de um servidor WebSocket ou servidor de notifica√ß√£o por push est√° se tornando uma tarefa trivial. <br><br><ul><li>  Servi√ßo Golang no n√≠vel do servidor. </li><li>  Para comunica√ß√£o, usamos Goridge. </li><li>  Camada de servi√ßo fina em PHP. </li><li>  Implementamos o servidor de notifica√ß√£o. </li></ul><br>  Recebemos uma solicita√ß√£o e aumentamos uma conex√£o WebSocket.  Se o aplicativo precisar enviar algum tipo de notifica√ß√£o ao usu√°rio, ele lan√ßar√° essa mensagem atrav√©s do protocolo RPC para o servidor WebSocket. <br><br><img src="https://habrastorage.org/webt/go/ta/fv/gotafvsepr8u8_r_lvfdjpff2rg.jpeg"><br><br>  <strong>Gerencie seu ambiente PHP.</strong>  Ao criar um pool de trabalhadores, o RoadRunner tem controle total sobre o estado das vari√°veis ‚Äã‚Äãde ambiente e permite que voc√™ as altere conforme desejar.  Se estivermos escrevendo um aplicativo distribu√≠do grande, podemos usar uma √∫nica fonte de dados de configura√ß√£o e conect√°-los como um sistema para configurar o ambiente.  Se criarmos um conjunto de servi√ßos, todos esses servi√ßos bater√£o em um √∫nico sistema, configurar√£o e funcionar√£o.  Isso pode simplificar bastante a implanta√ß√£o e livrar-se dos arquivos .env. <br><br><img src="https://habrastorage.org/webt/iv/m5/03/ivm503pht02yug6do6-od3pyt6i.jpeg"><br><br>  Curiosamente, as vari√°veis ‚Äã‚Äãenv que est√£o dispon√≠veis dentro do trabalhador n√£o s√£o globais no sistema.  Isso melhora um pouco a seguran√ßa do cont√™iner. <br><br><h3>  Integra√ß√£o da biblioteca Golang em PHP </h3><br>  Usamos essa op√ß√£o no site oficial do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RoadRunner</a> .  Esta √© uma integra√ß√£o de um banco de dados quase completo <strong>com a pesquisa de texto completo BleveSearch</strong> dentro do servidor. <br><br><img src="https://habrastorage.org/webt/5a/ba/uc/5abaucml3dmvxqpns_h7bug_ldi.jpeg"><br><br>  N√≥s indexamos as p√°ginas da documenta√ß√£o: as colocamos no Bolt DB, ap√≥s o qual realizamos uma pesquisa de texto completo sem um banco de dados real como o MySQL e sem um cluster de pesquisa como o Elasticsearch.  O resultado foi um pequeno projeto em que parte da funcionalidade est√° em PHP, mas a pesquisa est√° em Golang. <br><br><h3>  Implementando fun√ß√µes Lambda </h3><br>  Voc√™ pode ir al√©m e <strong>se livrar completamente da camada HTTP.</strong>  Nesse caso, implementar, por exemplo, fun√ß√µes Lambda √© uma tarefa simples. <br><br><img src="https://habrastorage.org/webt/ty/ie/dy/tyiedyrsetx2l5wljnllkbju0xg.jpeg"><br><br>  Para implementa√ß√£o, usamos o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tempo</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">execu√ß√£o</a> padr√£o da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">AWS</a> para a fun√ß√£o Lambda.  Escrevemos uma pequena liga√ß√£o, cortamos completamente os servidores HTTP e enviamos os dados em formato bin√°rio para os trabalhadores.  Tamb√©m temos acesso √†s configura√ß√µes do ambiente, o que nos permite escrever fun√ß√µes configuradas diretamente no painel de administra√ß√£o da Amazon. <br><br>  Os trabalhadores ficam na mem√≥ria durante toda a vida √∫til do processo e a fun√ß√£o Lambda ap√≥s a solicita√ß√£o inicial permanece na mem√≥ria por 15 minutos.  No momento, o c√≥digo n√£o carrega e responde rapidamente.  Em testes sint√©ticos, recebemos at√© <strong>0,5 ms por uma solicita√ß√£o recebida</strong> . <br><br><h3>  gRPC para PHP </h3><br>  A op√ß√£o mais dif√≠cil √© substituir a camada HTTP pela camada gRPC.  Este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pacote est√° dispon√≠vel no GitHub</a> . <br><img src="https://habrastorage.org/webt/jh/u5/cg/jhu5cgv7-cdj6wf4ifukhqxnd0u.jpeg"><br><br>  Podemos proxy completamente todas as solicita√ß√µes Protobuf recebidas para um aplicativo PHP subordinado, onde elas podem ser descompactadas, processadas e respondidas novamente.  Podemos escrever c√≥digo no PHP e no Golang, combinando e transferindo funcionalidades de uma pilha para outra.  O servi√ßo suporta Middleware.  O aplicativo independente e em conjunto com o HTTP podem funcionar. <br><br><h3>  Servidor de fila </h3><br>  A √∫ltima e mais interessante op√ß√£o √© a implementa√ß√£o do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">servidor de filas</a> . <br><img src="https://habrastorage.org/webt/rn/ch/1i/rnch1i0ieekunszmsv_ppegtwbu.jpeg"><br><br>  No lado do PHP, tudo o que fazemos √© obter uma carga bin√°ria, descompact√°-la, fazer o trabalho e informar o servidor sobre o sucesso.  No lado Golang, estamos totalmente engajados no gerenciamento de conex√µes com corretores.  Pode ser RabbitMQ, Amazon SQS ou Beanstalk. <br><br>  No lado de Golang, implementamos o " <strong>desligamento gracioso" dos</strong> trabalhadores.  Podemos esperar pela implementa√ß√£o da ‚Äúconex√£o dur√°vel‚Äù - se a conex√£o com o broker for perdida, o servidor esperar√° um pouco usando a ‚Äúestrat√©gia de retirada‚Äù, ela eleva a conex√£o e o aplicativo nem percebe. <br><br>  Podemos processar essas solicita√ß√µes no PHP e Golang e coloc√°-las na fila dos dois lados: <br><br><ul><li>  do PHP atrav√©s do protocolo Goridge Goridge RPC; </li><li>  de Golang - comunicando-se com a biblioteca SDK. </li></ul><br>  Se a carga √∫til cair, nem todo o consumidor cair√°, mas apenas um processo separado.  O sistema gera imediatamente, a tarefa √© enviada para o pr√≥ximo trabalhador.  Isso permite que voc√™ execute tarefas sem parar. <br><br>  Implementamos um dos corretores diretamente na mem√≥ria do servidor e usamos a funcionalidade Golang.  Isso nos permite escrever um aplicativo usando filas antes de escolher a pilha final.  Levantamos o aplicativo localmente, iniciamos e temos filas que funcionam na mem√≥ria e se comportam da mesma maneira que se comportariam no RabbitMQ, Amazon SQS ou Beanstalk. <br><br>  Ao usar dois idiomas em um pacote h√≠brido, vale lembrar como separ√°-los. <br><br><h3>  Dom√≠nios separados </h3><br><blockquote>  Golang √© uma linguagem r√°pida e multiencadeada, adequada para escrever l√≥gica de infraestrutura e l√≥gica de monitoramento e autoriza√ß√£o de usu√°rio. </blockquote><br>  Tamb√©m √© √∫til para <strong>implementar drivers personalizados</strong> para acessar fontes de dados - s√£o filas, por exemplo, Kafka, Cassandra. <br><br><blockquote>  PHP √© uma √≥tima linguagem para escrever l√≥gica de neg√≥cios. </blockquote><br>  Este √© um bom sistema para renderiza√ß√£o HTML, ORM e trabalho com o banco de dados. <br><br><h2>  Compara√ß√£o de ferramentas </h2><br>  H√° alguns meses, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Habr√© comparou</a> PHP-FPM, PHP-PM, React-PHP, Roadrunner e outras ferramentas.  O benchmark foi realizado em um projeto com o Symfony real 4. <br><br>  O RoadRunner sob carga mostra bons resultados e est√° √† frente de todos os servidores.  Comparado ao PHP-FPM, o desempenho √© de 6 a 8 vezes mais. <br><img src="https://habrastorage.org/webt/ny/tx/yl/nytxylmddyrmglxjoe8hos7tnka.jpeg"><br><br>  Na mesma refer√™ncia, o RoadRunner n√£o perdeu um √∫nico pedido, tudo estava 100% resolvido.  Infelizmente, o React-PHP perdeu 8 a 9 solicita√ß√µes sob cargas - isso √© inaceit√°vel.  Gostar√≠amos que o servidor n√£o travasse e trabalhasse de forma est√°vel. <br><img src="https://habrastorage.org/webt/7b/fl/gq/7bflgqhrq1f-y0jixnud_k1ckdg.jpeg"><br><br>  Desde a publica√ß√£o do RoadRunner no acesso p√∫blico ao GitHub, recebemos mais de 30.000 instala√ß√µes.  A comunidade nos ajudou a escrever um conjunto espec√≠fico de extens√µes, melhorias e acredita que a solu√ß√£o tem direito √† vida. <br><br>  O RoadRunner √© bom se voc√™ deseja <strong>acelerar significativamente o aplicativo, mas ainda n√£o est√° pronto para entrar no PHP ass√≠ncrono</strong> .  Esse √© um compromisso que exigir√° uma certa quantidade de esfor√ßo, mas n√£o t√£o significativo quanto uma reescrita completa da base de c√≥digo. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tome o RoadRunner</a> se voc√™ deseja ter <strong>mais controle sobre o ciclo de vida do PHP</strong> , <strong>se n√£o houver recursos PHP suficientes,</strong> por exemplo, para o sistema de filas ou o Kafka, e quando sua popular biblioteca Golang resolver seu problema, que n√£o est√° em PHP, e a escrita leva tempo, o que voc√™ tamb√©m n√£o tem. <br><br><h2>  Sum√°rio </h2><br>  O que conseguimos ao escrever este servidor e us√°-lo em nossa infraestrutura de produ√ß√£o. <br><br><ul><li>  <strong>Eles aumentaram a velocidade de rea√ß√£o dos pontos de aplica√ß√£o em 4 vezes em</strong> compara√ß√£o com o PHP-FPM. </li><li>  <strong>Livre-se completamente de 502 erros sob cargas</strong> .  Em picos de carga, o servidor espera um pouco mais e responde como se n√£o houvesse cargas. </li><li>  Ap√≥s otimizar o vazamento de mem√≥ria, os funcion√°rios <strong>ficam na mem√≥ria por at√© 2 meses</strong> .  Isso ajuda ao escrever aplicativos distribu√≠dos, pois todas as solicita√ß√µes entre servi√ßos j√° est√£o armazenadas em cache no n√≠vel do soquete. </li><li>  <strong>Usamos o Keep-Alive.</strong>  Isso acelera significativamente a comunica√ß√£o entre um sistema distribu√≠do. </li><li>  Dentro da infraestrutura real, <strong>colocamos tudo no Alpine Docker em Kubernetes</strong> .  O sistema de implanta√ß√£o e constru√ß√£o do projeto agora √© mais f√°cil.  Tudo o que √© necess√°rio √© criar uma vers√£o personalizada do RoadRunner para o projeto, coloc√°-la no projeto Docker, preencher a imagem do Docker e fazer o upload calmo de nosso pod para o Kubernetes. </li><li>  De acordo com o tempo real de um dos projetos para pontos individuais que n√£o t√™m acesso ao banco de dados, o <strong>tempo m√©dio de resposta √© de 0,33 ms</strong> . </li></ul><br><blockquote>  A pr√≥xima confer√™ncia profissional para desenvolvedores de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PHP PHP R√∫ssia</a> apenas no pr√≥ximo ano.  Por enquanto, oferecemos o seguinte: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Preste</a> aten√ß√£o no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GolangConf</a> se voc√™ estiver interessado na parte Go e quiser saber mais detalhes ou ouvir argumentos a favor de mudar para esse idioma.  Se voc√™ estiver pronto para compartilhar sua experi√™ncia, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">envie resumos</a> . </li><li>  Participe do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HighLoad ++</a> em Moscou, se tudo que for importante para voc√™ associado ao alto desempenho, envie um relat√≥rio antes de 7 de setembro ou reserve um ingresso. </li><li>  Assine o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">boletim informativo</a> e o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">canal de telegrama</a> para receber um convite para o PHP Russia 2020 mais cedo do que outros. </li></ul></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt461827/">https://habr.com/ru/post/pt461827/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt461815/index.html">Uma revolu√ß√£o no design de fontes de alimenta√ß√£o para computadores meio s√©culo atr√°s</a></li>
<li><a href="../pt461817/index.html">CMake e C ++ - irm√£os para sempre</a></li>
<li><a href="../pt461819/index.html">Por que o design simples de sites √© melhor cientificamente</a></li>
<li><a href="../pt461821/index.html">Nova imunoterapia removeu todos os tumores de uma mulher com c√¢ncer de mama metast√°tico</a></li>
<li><a href="../pt461823/index.html">Quatro regras aprimoradas para design de software</a></li>
<li><a href="../pt461829/index.html">TCP vs UDP ou o futuro dos protocolos de rede</a></li>
<li><a href="../pt461831/index.html">StealthWatch: Implanta√ß√£o e Personaliza√ß√£o. Parte 2</a></li>
<li><a href="../pt461833/index.html">N√£o se perca em tr√™s pinheiros: uma representa√ß√£o egoc√™ntrica do meio ambiente</a></li>
<li><a href="../pt461835/index.html">Como os gr√°ficos de Gantt simplificam e capacitam o gerenciamento de projetos</a></li>
<li><a href="../pt461841/index.html">PVS-Studio olhou para o Bullet Engine do Red Dead Redemption</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>