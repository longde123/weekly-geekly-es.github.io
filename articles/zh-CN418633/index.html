<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📞 🏝️ 🌻 JavaScript反应性：一个简单直观的示例 🅾️ 🧕🏽 👎🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="许多JavaScript前端框架（例如Angular，React和Vue）都有自己的反应系统。 了解这些系统的功能对于任何开发人员都将是有用的，将帮助他更有效地使用现代JS框架。 

  

 我们今天发布的翻译材料显示了使用纯JavaScript开发反应系统的分步示例。 该系统实现了Vue中使用的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript反应性：一个简单直观的示例</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/418633/"> 许多JavaScript前端框架（例如Angular，React和Vue）都有自己的反应系统。 了解这些系统的功能对于任何开发人员都将是有用的，将帮助他更有效地使用现代JS框架。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/c_/k4/dp/c_k4dpwjifcbq6pvrg-gn7wydsu.jpeg"></a> <br><br> 我们今天发布的翻译材料显示了使用纯JavaScript开发反应系统的分步示例。 该系统实现了Vue中使用的相同机制。 <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">反应系统</font> </h2><br> 对于第一次接触Vue反应系统的人来说，它似乎就像是一个神秘的黑匣子。 考虑一个简单的Vue应用程序。 这是标记： <br><br><pre><code class="hljs django"><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"app"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">    </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Price: $</span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ price }}</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">    </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Total: $</span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ price*quantity }}</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">    </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Taxes: $</span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ totalPriceWithTax }}</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br> 这是框架连接命令和应用程序代码。 <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="actionscript"><span class="actionscript">   </span><span class="hljs-keyword"><span class="actionscript"><span class="hljs-keyword">var</span></span></span><span class="actionscript"> vm = </span><span class="hljs-keyword"><span class="actionscript"><span class="hljs-keyword">new</span></span></span><span class="actionscript"> Vue({       el: </span><span class="hljs-string"><span class="actionscript"><span class="hljs-string">'#app'</span></span></span><span class="actionscript">,       data: {           price: </span><span class="hljs-number"><span class="actionscript"><span class="hljs-number">5.00</span></span></span><span class="actionscript">,           quantity: </span><span class="hljs-number"><span class="actionscript"><span class="hljs-number">2</span></span></span><span class="actionscript">       },       computed: {           totalPriceWithTax() {               </span><span class="hljs-keyword"><span class="actionscript"><span class="hljs-keyword">return</span></span></span><span class="actionscript"> </span><span class="hljs-keyword"><span class="actionscript"><span class="hljs-keyword">this</span></span></span><span class="actionscript">.price * </span><span class="hljs-keyword"><span class="actionscript"><span class="hljs-keyword">this</span></span></span><span class="actionscript">.quantity * </span><span class="hljs-number"><span class="actionscript"><span class="hljs-number">1.03</span></span></span><span class="actionscript">           }       }   }) </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Vue以某种方式发现，当<code>price</code>变化时，引擎需要做三件事： <br><br><ol><li> 刷新网页上的<code>price</code>值。 </li><li> 重新计算<code>price</code>乘以<code>quantity</code>的表达式，然后在页面上显示结果值。 </li><li> 调用函数<code>totalPriceWithTax</code> ，然后再次将其返回的内容放在页面上。 </li></ol><br> 下图显示了此处发生的情况。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/373/af5/15e/373af515eac946ce5c656df9fe2da573.jpg"></div><br>  <i><font color="#999999">价格属性发生变化时，Vue如何知道该怎么办？</font></i> <br><br> 现在，我们对Vue如何知道<code>price</code>变化时确切需要更新的内容以及引擎如何跟踪页面上发生的情况等问题有所疑问。 您在此处观察到的内容看起来并不像常规的JS应用程序。 <br><br> 也许这还不是很明显，但是我们需要在这里解决的主要问题是JS程序通常不能那样工作。 例如，让我们运行以下代码： <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> price = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> quantity = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> total = price * quantity <span class="hljs-comment"><span class="hljs-comment">//  10 price = 20; console.log(`total is ${total}`)</span></span></code> </pre> <br> 您认为控制台中会显示什么？ 因为这里除了常规的JS之外什么都没有使用，所以<code>10</code>将进入控制台。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/030/992/c52/030992c52de473284847fa7f8f2f6785.png"></div><br>  <i><font color="#999999">程序的结果</font></i> <br><br> 当使用Vue的功能时，在类似情况下，我们可以实现一种方案，其中在<code>price</code>或<code>quantity</code>变量发生变化时重新计算<code>total</code>价值。 也就是说，如果在以上代码的执行中使用了反应性系统，那么控制台上将不会显示10，而是显示40： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/22c/c4e/6c7/22cc4e6c79914b1c9f2c4df6bf83c9e1.png"></div><br>  <i><font color="#999999">使用反应系统由假设代码生成的控制台输出</font></i> <br><br>  JavaScript是一种既可以作用于程序又可以面向对象的语言，但是它没有内置的反应系统，因此我们在更改<code>price</code>时考虑的代码不会将数字40输出到控制台。 为了在<code>price</code>或<code>quantity</code>发生变化时重新计算<code>total</code>指标，我们将需要自己创建一个反应系统，从而实现所需的行为。 我们将把实现这一目标的道路分为几个小步骤。 <br><br><h2>  <font color="#3AC1EF">任务：存储指标计算规则</font> </h2><br> 我们需要在某个地方保存有关<code>total</code>指标如何计算的信息，以便在更改<code>price</code>或<code>quantity</code>变量的值时可以重新计算它。 <br><br><h3>  <font color="#3AC1EF">▍解决方案</font> </h3><br> 首先，我们需要告诉应用程序以下内容：“这是我要运行的代码，保存下来，我可能需要再次执行它。” 然后，我们将需要运行代码。 稍后，如果<code>price</code>或<code>quantity</code>指标发生变化，则需要调用保存的代码来重新计算<code>total</code> 。 看起来像这样： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e8/de0/6ce/7e8de06ce6262d1989c13153884cd225.png"></div><br>  <i><font color="#999999">总的计算代码需要保存在某处，以便以后可以访问</font></i> <br><br> 您可以在JavaScript中调用以执行某些操作的代码，其格式设置为函数。 因此，我们将编写一个用于处理<code>total</code>的函数，并创建一种机制来存储以后可能需要的函数。 <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> price = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> quantity = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> total = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> target = <span class="hljs-literal"><span class="hljs-literal">null</span></span> target = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   total = price * quantity } record() <span class="hljs-comment"><span class="hljs-comment">//       ,       target() //  </span></span></code> </pre> <br> 请注意，我们将匿名函数存储在<code>target</code>变量中，然后调用<code>record</code>函数。 我们将在下面讨论。 我还想指出，使用ES6箭头函数的语法可以将<code>target</code>函数重写如下： <br><br><pre> <code class="hljs coffeescript"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">target</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { total = price * quantity }</code> </pre> <br> 这是<code>record</code>函数的声明和用于存储函数的数据结构： <br><br><pre> <code class="hljs powershell">let storage = [] //     target <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">record</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { // target = () =&gt; { total = price * quantity }   storage.push(target) }</code> </pre> <br> 使用<code>record</code>函数，我们将<code>target</code>函数（在本例中为<code>{ total = price * quantity }</code> ）保存在<code>storage</code>数组中，这使我们以后可以调用此函数，可能使用<code>replay</code>函数，其代码如下所示。 这将使我们能够调用存储在<code>storage</code>所有函数。 <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">replay</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   storage.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">run</span></span></span><span class="hljs-function"> =&gt;</span></span> run()) }</code> </pre> <br> 在这里，我们遍历存储在<code>storage</code>阵列中的所有匿名函数并执行它们中的每一个。 <br><br> 然后，在我们的代码中，我们可以执行以下操作： <br><br><pre> <code class="hljs pgsql">price = <span class="hljs-number"><span class="hljs-number">20</span></span> console.log(total) // <span class="hljs-number"><span class="hljs-number">10</span></span> replay() console.log(total) // <span class="hljs-number"><span class="hljs-number">40</span></span></code> </pre> <br> 看起来并不那么难，不是吗？ 这是完整的代码，上面我们讨论了代码的片段，以防您最终更方便地处理它。 顺便说一句，此代码不是偶然编写的。 <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> price = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> quantity = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> total = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> target = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> storage = [] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">record</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   storage.push(target) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">replay</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   storage.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">run</span></span></span><span class="hljs-function"> =&gt;</span></span> run()) } target = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { total = price * quantity } record() target() price = <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(total) <span class="hljs-comment"><span class="hljs-comment">// 10 replay() console.log(total) // 40</span></span></code> </pre> <br> 这是启动后将在浏览器控制台中显示的内容。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/67c/18e/94b/67c18e94b8afde9e116e95bb4cf8f41b.png"></div><br>  <i><font color="#999999">代码结果</font></i> <br><br><h2>  <font color="#3AC1EF">挑战：可靠的功能存储解决方案</font> </h2><br> 我们可以在必要时继续写下所需的功能，但是如果我们有一个可以随应用程序扩展的更可靠的解决方案，那就太好了。 也许它将是一个类，该类维护最初写入<code>target</code>变量的函数列表，并且在我们需要重新执行这些函数时会接收通知。 <br><br><h3>  <font color="#3AC1EF">▍解决方案：依赖类</font> </h3><br> 解决上述问题的一种方法是将我们需要的行为封装在一个类中，这可以称为依赖。 此类将实现标准的观察者编程模式。 <br><br> 结果，如果我们创建一个用于管理依赖项的JS类（这将类似于Vue中实现类似机制的方式），则它看起来可能像这样： <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dep</span></span></span><span class="hljs-class"> { // </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dep</span></span></span><span class="hljs-class"> -    </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dependency</span></span></span><span class="hljs-class">   constructor () {       this.subscribers = [] //  ,                               //    notify()   }   depend () { //   record       if (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">target</span></span></span><span class="hljs-class"> &amp;&amp; !</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">this</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">subscribers</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">includes</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">target</span></span></span><span class="hljs-class">)){           //    target                //                this.subscribers.push(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">target</span></span></span><span class="hljs-class">)       }   }   notify () { //   replay       this.subscribers.forEach(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sub</span></span></span><span class="hljs-class"> =&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sub</span></span></span><span class="hljs-class">())       //  -     } }</span></span></code> </pre> <br> 请注意，我们现在将匿名函数存储在<code>subscribers</code>数组中，而不是<code>storage</code>数组中。 现在将调用<code>depend</code>方法，而不是<code>record</code>函数。 同样在这里， <code>notify</code>功能代替<code>replay</code>功能。 这是使用<code>Dep</code>类运行代码的方法： <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dep = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dep() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> price = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> quantity = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> total = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> target = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { total = price * quantity } dep.depend() <span class="hljs-comment"><span class="hljs-comment">//   target    target() //     total console.log(total) // 10 -   price = 20 console.log(total) // 10 -    ,    dep.notify() //   -  console.log(total) // 40 -   </span></span></code> </pre> <br> 我们的新代码与以前一样，但是现在设计得更好了，感觉可以更好地重用。 <br><br> 到目前为止，唯一看起来很奇怪的事情是使用存储在<code>target</code>变量中的函数。 <br><br><h2>  <font color="#3AC1EF">任务：创建匿名函数的机制</font> </h2><br> 将来，我们将需要为每个变量创建一个<code>Dep</code>类的对象。 此外，最好将在某些地方创建匿名函数的行为封装起来，在更新相关数据时应调用该函数。 也许这将有助于我们使用附加功能，我们将其称为<code>watcher</code> 。 这将导致这样一个事实，我们可以用新功能替换之前示例中的此构造： <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> target = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { total = price * quantity } dep.depend() target()</code> </pre> <br> 实际上，替换该代码的对<code>watcher</code>函数的调用将如下所示： <br><br><pre> <code class="hljs coffeescript">watcher(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   total = price * quantity })</code> </pre> <br><h3>  <font color="#3AC1EF">▍解决方案：观察者功能</font> </h3><br> 在<code>watcher</code>函数内部（下面提供其代码），我们可以执行一些简单的操作： <br><br><pre> <code class="hljs cmake"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> watcher(myFunc) {   <span class="hljs-keyword"><span class="hljs-keyword">target</span></span> = myFunc //   <span class="hljs-keyword"><span class="hljs-keyword">target</span></span>   myFunc   dep.depend() //  <span class="hljs-keyword"><span class="hljs-keyword">target</span></span>      <span class="hljs-keyword"><span class="hljs-keyword">target</span></span>() //     <span class="hljs-keyword"><span class="hljs-keyword">target</span></span> = null //   <span class="hljs-keyword"><span class="hljs-keyword">target</span></span> }</code> </pre> <br> 如您所见， <code>watcher</code>函数将<code>myFunc</code>函数作为参数，将其写入全局<code>target</code>变量，调用<code>dep.depend()</code>将该函数添加到订阅者列表，调用此函数并重置<code>target</code>变量。 <br> 现在，如果执行以下代码，我们将得到所有相同的值10和40： <br><br><pre> <code class="hljs pgsql">price = <span class="hljs-number"><span class="hljs-number">20</span></span> console.log(total) dep.<span class="hljs-keyword"><span class="hljs-keyword">notify</span></span>() console.log(total)</code> </pre> <br> 也许您想知道为什么我们将<code>target</code>实现为全局变量，而不是在必要时将此变量传递给我们的函数。 我们有充分的理由这样做，以后您将了解。 <br><br><h2>  <font color="#3AC1EF">任务：为每个变量拥有Dep对象</font> </h2><br> 我们只有一个类<code>Dep</code>对象。 如果我们需要每个变量都有自己的<code>Dep</code>类对象，该怎么办？ 在继续之前，让我们将使用的数据移动到对象的属性中： <br><br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">let</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> = { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">price</span></span></span><span class="hljs-class">: 5, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">quantity</span></span></span><span class="hljs-class">: 2 }</span></span></code> </pre> <br> 想象一下，我们的每个属性（ <code>price</code>和<code>quantity</code> ）都有自己的内部<code>Dep</code>类对象。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d6/7a0/686/0d67a0686a5c87e6080994309197e6b4.png"></div><br>  <i><font color="#999999">价格和数量属性</font></i> <br><br> 现在我们可以像这样调用<code>watcher</code>函数： <br><br><pre> <code class="hljs coffeescript">watcher(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   total = data.price * data.quantity })</code> </pre> <br> 由于我们在这里使用<code>data.price</code>属性的值，因此我们需要<code>price</code>属性的<code>Dep</code>类对象将匿名函数（存储在<code>target</code> ）放置在其订户数组中（通过调用<code>dep.depend()</code> ）。 另外，由于我们在<code>data.quantity</code>使用<code>data.quantity</code> ，因此需要<code>quantity</code>属性的<code>Dep</code>对象在其订户数组中放置一个匿名函数（同样，存储在<code>target</code> ）。 <br><br> 如果以图表形式进行描述，则会得到以下结果。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90a/2c9/16d/90a2c916de1e45a044fb1074d64ba196.png"></div><br>  <i><font color="#999999">函数属于对应于不同属性的Dep类对象的订户数组</font></i> <br><br> 如果我们还有一个匿名函数，其中仅使用<code>data.price</code>属性，则相应的匿名函数应仅存储到此属性的<code>Dep</code>类对象中。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e9/ed1/040/8e9ed104054baab4bb24eeed338cc6a0.png"></div><br>  <i><font color="#999999">只能将附加的观察者添加到可用属性之一。</font></i> <br><br> 对于预订了<code>price</code>属性更改的函数，何时可能需要调用<code>dep.notify()</code> ？ 更改<code>price</code>时将需要这样做。 这意味着当我们的示例完全准备就绪时，以下代码将为我们工作。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2df/2d9/7a0/2df2d97a0a995fbbdb63703ea76f8349.png"></div><br>  <i><font color="#999999">在这里，更改价格时，您需要为预订了更改价格的所有函数调用dep.notify（）</font></i> <br><br> 为了使所有内容都能以这种方式工作，我们需要某种方式来拦截属性访问事件（在我们的例子中，它是<code>price</code>或<code>quantity</code> ）。 发生这种情况时，这将允许将<code>target</code>函数保存到订阅者数组中，并且当相应的变量更改时，可以执行存储在该数组中的函数。 <br><br><h3>  <font color="#3AC1EF">▍解决方案：Object.defineProperty（）</font> </h3><br> 现在，我们需要熟悉标准的ES5方法<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Object.defineProperty（）。</a> 它允许您将getter和setter分配给对象的属性。 在继续实际使用之前，请允许我以一个简单的示例演示这些机制的操作。 <br><br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">let</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> = { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">price</span></span></span><span class="hljs-class">: 5, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">quantity</span></span></span><span class="hljs-class">: 2 } </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Object</span></span></span><span class="hljs-class">.defineProperty(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">, '</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">price'</span></span></span><span class="hljs-class">, { //       </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">price</span></span></span><span class="hljs-class">   </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">get</span></span></span><span class="hljs-class">() { //        </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">console</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">log</span></span></span><span class="hljs-class">(`</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">I</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">was</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">accessed</span></span></span><span class="hljs-class">`)   },   set(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">newVal</span></span></span><span class="hljs-class">) { //        </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">console</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">log</span></span></span><span class="hljs-class">(`</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">I</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">was</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">changed</span></span></span><span class="hljs-class">`)   } }) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.price //       </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.price = 20 //     </span></span></code> </pre> <br> 如果在浏览器控制台中运行此代码，它将显示以下文本。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed0/7a5/ec1/ed07a5ec1a3a8183516f908695d42c47.png"></div><br>  <i><font color="#999999">Getter和Setter结果</font></i> <br><br> 如您所见，我们的示例仅将两行文本打印到控制台。 但是，它不读取或设置值，因为我们重新定义了getter和setter的标准功能。 我们将恢复这些方法的功能。 即，期望getter返回相应方法的值，并由setter设置它们。 因此，我们将在代码中添加一个新变量<code>internalValue</code> ，该变量将用于存储当前<code>price</code>值。 <br><br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">let</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> = { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">price</span></span></span><span class="hljs-class">: 5, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">quantity</span></span></span><span class="hljs-class">: 2 } let internalValue = </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.price //   </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Object</span></span></span><span class="hljs-class">.defineProperty(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">, '</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">price'</span></span></span><span class="hljs-class">, { //       </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">price</span></span></span><span class="hljs-class">   </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">get</span></span></span><span class="hljs-class">() { //        </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">console</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">log</span></span></span><span class="hljs-class">(`</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Getting</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">price</span></span></span><span class="hljs-class">: ${</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">internalValue</span></span></span><span class="hljs-class">}`)       return internalValue   },   set(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">newVal</span></span></span><span class="hljs-class">) {       </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">console</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">log</span></span></span><span class="hljs-class">(`</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Setting</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">price</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">to</span></span></span><span class="hljs-class">: ${</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">newVal</span></span></span><span class="hljs-class">}`)       internalValue = newVal   } }) total = </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.price * </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.quantity //       </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.price = 20 //     </span></span></code> </pre> <br> 既然getter和setter的工作方式应该正确，那么执行此代码后，您认为将如何进入控制台？ 看下图。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/050/0c1/6b1/0500c16b12301a46ee7a0db01ea3b823.png"></div><br>  <i><font color="#999999">数据输出到控制台</font></i> <br><br> 因此，现在我们有了一种机制，使您可以在读取属性值以及将新值写入属性值时接收通知。 现在，在稍微修改代码之后，我们可以为getter和setter装备<code>data</code>对象的所有属性。 在这里，我们将使用<code>Object.keys()</code>方法，该方法返回传递给它的对象的键的数组。 <br><br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">let</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> = { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">price</span></span></span><span class="hljs-class">: 5, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">quantity</span></span></span><span class="hljs-class">: 2 } </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Object</span></span></span><span class="hljs-class">.keys(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">).forEach(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">key</span></span></span><span class="hljs-class"> =&gt; { //        </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">   </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">let</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">internalValue</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">key</span></span></span><span class="hljs-class">]   </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Object</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">defineProperty</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">key</span></span></span><span class="hljs-class">, {       </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">get</span></span></span><span class="hljs-class">() {           </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">console</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">log</span></span></span><span class="hljs-class">(`</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Getting</span></span></span><span class="hljs-class"> ${</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">key</span></span></span><span class="hljs-class">}: ${</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">internalValue</span></span></span><span class="hljs-class">}`)           return internalValue       },       set(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">newVal</span></span></span><span class="hljs-class">) {           </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">console</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">log</span></span></span><span class="hljs-class">(`</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Setting</span></span></span><span class="hljs-class"> ${</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">key</span></span></span><span class="hljs-class">} to: ${</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">newVal</span></span></span><span class="hljs-class">}`)           internalValue = newVal       }   }) }) let total = </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.price * </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.quantity </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.price = 20</span></span></code> </pre> <br> 现在， <code>data</code>对象的所有属性都有getter和setter。 这是运行此代码后出现在控制台中的内容。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bc6/af0/6b1/bc6af06b16c72f0772634160add682ab.png"></div><br>  <i><font color="#999999">获取器和设置器将数据输出到控制台</font></i> <br><br><h2>  <font color="#3AC1EF">反应系统组装</font> </h2><br> 当<code>total = data.price * data.quantity</code>诸如<code>total = data.price * data.quantity</code>类的代码片段并在其中获得<code>price</code>属性的值时，我们需要<code>price</code>属性来“记住”相应的匿名函数（在本例中为<code>target</code> ）。 结果，如果更改了<code>price</code>属性，即将其设置为新值，这将导致对该函数的调用以重复执行它执行的操作，因为它知道某些代码行依赖于此。 结果，可以想象在getter和setter中执行的操作如下： <br><br><ul><li>  Getter-您需要记住匿名函数，当值更改时，我们将再次调用该函数。 </li><li> 设置器-必须执行存储的匿名函数，这将导致相应结果值的更改。 </li></ul><br> 如果使用此描述中已知的<code>Dep</code>类，则会得到以下信息： <br><br><ul><li> 读取属性值时，将调用<code>dep.depend()</code>来保存当前的<code>target</code>函数。 </li><li> 将值写入属性时，将调用<code>dep.notify()</code>重新启动所有存储的函数。 </li></ul><br> 现在，我们将结合这两个想法，最后，我们将介绍允许我们实现目标的代码。 <br><br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">let</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> = { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">price</span></span></span><span class="hljs-class">: 5, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">quantity</span></span></span><span class="hljs-class">: 2 } let target = null //  -    ,     class </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dep</span></span></span><span class="hljs-class"> {   </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constructor</span></span></span><span class="hljs-class"> () {       </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">this</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">subscribers</span></span></span><span class="hljs-class"> = []   }   depend () {       </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">if</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">target</span></span></span><span class="hljs-class"> &amp;&amp; !</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">this</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">subscribers</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">includes</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">target</span></span></span><span class="hljs-class">)){           </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">this</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">subscribers</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">push</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">target</span></span></span><span class="hljs-class">)       }   }   notify () {       </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">this</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">subscribers</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">forEach</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sub</span></span></span><span class="hljs-class"> =&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sub</span></span></span><span class="hljs-class">())   } } //      ,  //      </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Object</span></span></span><span class="hljs-class">.keys(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">).forEach(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">key</span></span></span><span class="hljs-class"> =&gt; {   </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">let</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">internalValue</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">key</span></span></span><span class="hljs-class">]   //         //   </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dep</span></span></span><span class="hljs-class">   </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dep</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dep</span></span></span><span class="hljs-class">()   </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Object</span></span></span><span class="hljs-class">.defineProperty(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">key</span></span></span><span class="hljs-class">, {       </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">get</span></span></span><span class="hljs-class">() {           </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dep</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">depend</span></span></span><span class="hljs-class">() //    </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">target</span></span></span><span class="hljs-class">           </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">internalValue</span></span></span><span class="hljs-class">       },       set(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">newVal</span></span></span><span class="hljs-class">) {           </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">internalValue</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">newVal</span></span></span><span class="hljs-class">           </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dep</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">notify</span></span></span><span class="hljs-class">() //           }   }) }) //   watcher   dep.depend(), //        function watcher(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">myFunc</span></span></span><span class="hljs-class">){   </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">target</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">myFunc</span></span></span><span class="hljs-class">   </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">target</span></span></span><span class="hljs-class">()   </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">target</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">null</span></span></span><span class="hljs-class"> } watcher(() =&gt; {   </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">total</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">price</span></span></span><span class="hljs-class"> * </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">quantity</span></span></span><span class="hljs-class"> })</span></span></code> </pre> <br> 让我们在浏览器控制台中试用此代码。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2bc/47f/c10/2bc47fc1035298c26eb1dfd84d72e738.png"></div><br>  <i><font color="#999999">准备好的代码实验</font></i> <br><br> 如您所见，它完全可以满足我们的需求！  <code>price</code>和<code>quantity</code>属性已变得反应灵敏！ 重复执行负责<code>price</code>或<code>quantity</code>变化时产生<code>total</code>所有代码。 <br><br> 现在，在我们编写了自己的反应性系统之后，Vue文档中的插图对于您而言似乎是熟悉且可以理解的。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f1e/a0d/193/f1ea0d19322cee657e9b130cbd491e65.png"></div><br>  <i><font color="#999999">Vue反应系统</font></i> <br><br> 看到这个美丽的紫色圆圈，上面写着“ <code></code>包含getter和setter”吗？ 现在他应该对您很熟悉。 组件的每个实例都有一个观察者方法的实例（蓝色圆圈），该方法收集对吸气剂的依赖关系（红线）。 稍后，当调用setter时，它将通知观察者方法，这将导致组件的重新呈现。 这是相同的方案，并提供与我们的开发相关的说明。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/276/fb4/6db/276fb46db5618c8a08428c5c1914e988.png"></div><br>  <i><font color="#999999">Vue反应性图及说明</font></i> <br><br> 我们相信，现在，我们已经编写了自己的反应性系统，该方案不需要其他说明。 <br><br> 当然，在Vue中，所有这些都比较复杂，但是现在您应该了解反应系统的基本机制。 <br><br><h2>  <font color="#3AC1EF">总结</font> </h2><br> 阅读此材料后，您了解了以下内容： <br><br><ul><li> 如何创建一个<code>Dep</code>类，该类使用<code>depend</code>方法来收集函数，并在必要时使用<code>notify</code>方法再次调用它们。 </li><li> 如何创建一个<code>watcher</code>函数，使您可以控制我们运行的代码（这是<code>target</code>函数），您可能需要将其保存在<code>Dep</code>类的对象中。 </li><li> 如何使用<code>Object.defineProperty()</code>方法创建getter和setter。 </li></ul><br> 所有这些，都聚集在一个示例中，通过了解可以理解现代Web框架中使用的此类系统的功能，可以使用纯JavaScript创建响应系统。 <br><br>  <b>亲爱的读者们！</b> 如果在阅读本文之前，您对反应系统机制的功能没有很好的想象，请告诉我，您现在是否能够应对它们？ <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN418633/">https://habr.com/ru/post/zh-CN418633/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN418621/index.html">为什么要设计软技能</a></li>
<li><a href="../zh-CN418625/index.html">秘密致电安迪·格鲁夫（Andy Grove），后者帮助苹果购买了NeXT</a></li>
<li><a href="../zh-CN418627/index.html">有关解线性代数方程组的方法的更多信息</a></li>
<li><a href="../zh-CN418629/index.html">如何独立验证您是否可以对您的产品申请专利并进行专利检索</a></li>
<li><a href="../zh-CN418631/index.html">7个JavaScript代码准则</a></li>
<li><a href="../zh-CN418635/index.html">创建一个模拟器街机。 第一部分</a></li>
<li><a href="../zh-CN418637/index.html">Kubernetes面向大众：Slurm将于8月3日开始</a></li>
<li><a href="../zh-CN418639/index.html">仅有凡人的Akka流</a></li>
<li><a href="../zh-CN418641/index.html">一个使设计师无法成长的错误</a></li>
<li><a href="../zh-CN418643/index.html">坐vs站：如何更好地工作？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>