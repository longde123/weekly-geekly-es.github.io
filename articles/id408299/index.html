<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸš¹ ğŸ¾ ğŸ–•ğŸ» Memecahkan masalah ubin menggunakan pemecah SAT menggunakan contoh pentamino ğŸ“¿ ğŸ¤ğŸ¼ ğŸ‘©ğŸ¾â€âš•ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Setelah saya menemukan permainan pentomino di mana perlu untuk menempatkan angka 13 ke dalam persegi 8 dengan 8. Setelah periode waktu tertentu ketika...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memecahkan masalah ubin menggunakan pemecah SAT menggunakan contoh pentamino</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/408299/"> Setelah saya menemukan permainan pentomino di mana perlu untuk menempatkan angka 13 ke dalam persegi 8 dengan 8. Setelah periode waktu tertentu ketika saya mencoba gagal untuk menyelesaikan masalah ini, saya memutuskan bahwa perlu untuk menulis sebuah program yang akan melakukan ini untuk saya.  Untuk melakukan ini, perlu memilih algoritma solusi.  Hal pertama yang terlintas dalam pikiran adalah algoritma cabang dan perbatasan yang biasa, ketika angka-angka ditumpuk satu sama lain berdekatan satu sama lain (algoritma dengan link menari tidak cocok di sini, karena angka-angka berbeda).  Berbagai heuristik biasanya digunakan untuk mempercepat algoritme ini, misalnya bercabang dengan jumlah opsi paling sedikit.  Anda dapat menemukan dan menerapkan heuristik lain dalam algoritma ini, tetapi di sini saya berpikir bahwa banyak trik berbeda untuk mempercepat solusi dari masalah tersebut telah diterapkan pada SAT solver.  Oleh karena itu, perlu untuk menerjemahkan tugas ke dalam bahasa matematika yang sesuai dan menggunakan semacam solver SAT.  Tentang bagaimana ini diterapkan dan apa hasil yang dihasilkan dapat dibaca di bawah potongan. <br><a name="habracut"></a><br>  Pada awalnya saya ingin mengingatkan Anda apa permainan pentamino.  Ini adalah bidang 8x8 persegi, yang harus diberi ubin dengan 13 angka - 12 coretan, yang terdiri dari 5 kotak dan satu angka 2x2: <br><br><img src="https://ic.pics.livejournal.com/andyplekhanov/66030250/59907/59907_900.jp" alt="gambar"><br><br>  Di sini perlu dikatakan apa masalah kepuasan Boolean atau masalah SAT.  Secara umum, ini dapat dirumuskan sebagai temuan nilai-nilai variabel Boolean di mana ekspresi yang diberikan menjadi benar.  Secara umum, ini adalah tugas lengkap NP, tetapi ada banyak trik yang membantu untuk menyelesaikannya secara efektif.  Untuk melakukan ini, banyak aplikasi khusus yang disebut pemecah SAT telah dikembangkan.  Saya akan menggunakan pemecah SAT bernama minisat.  Untuk mengatasi masalah ini, perlu menulis ulang ekspresi input dalam bentuk normal konjungtif, yaitu, dalam bentuk produk dari jumlah variabel yang logis.  Setiap braket dalam bentuk konjungtif normal di sini disebut klausa, yang merupakan "atau" logis beberapa literal, yaitu, variabel Boolean atau penolakannya.  Sebagai contoh: <br><br>  (x1 V bukan x3) (x2 V x4) (x2 V x3 V tidak X4) <br><br>  Saya perlu menerjemahkan tugas pemasangan ke tugas SAT.  Ambil beberapa figur pentamino dan letakkan di lapangan bermain dengan semua cara yang mungkin, termasuk shift, belokan dan refleksi.  Untuk setiap posisi dari figur tersebut, kita mengaitkan variabel Boolean dan kita akan mengasumsikan bahwa jika dalam solusi akhir kita angka ini hadir dalam posisi khusus ini, maka variabel tersebut akan benar, dan jika tidak, maka false.  Kami melakukan ini untuk semua angka. <br><br>  Sekarang mari kita buat formula yang menggambarkan masalah kita, yaitu, kita akan benar-benar memberlakukan batasan pada variabel kita.  Hal pertama yang harus dilakukan adalah memastikan bahwa semua sel di lapangan bermain kita akan ditutupi dengan setidaknya satu angka.  Untuk melakukan ini, untuk setiap sel dari 64, kami menemukan semua angka dan posisi dari angka-angka ini yang menutupi sel ini dan menyusun klausa dari variabel yang ditugaskan ke posisi ini dari angka-angka.  Hal kedua yang harus dilakukan adalah menghilangkan persimpangan bentuk.  Ini dapat dilakukan dalam siklus ganda, cukup memilah semua posisi yang mungkin dari semua angka dan menentukan apakah pasangan memiliki sel yang sama.  Jika ada, maka mereka berpotongan dan Anda perlu menambahkan klausa formulir (bukan x_i V bukan x_j), di mana x_i adalah variabel yang ditetapkan ke posisi pertama, dan x_j adalah posisi kedua.  Klausa ini benar ketika x_i dan x_j tidak sama dengan satu pada saat yang sama, yaitu mengecualikan persimpangan.  Dan akhirnya, hal ketiga yang perlu dipertimbangkan adalah bahwa setiap figur hanya dapat hadir di lapangan bermain satu kali.  Untuk melakukan ini, kita juga melalui semua posisi masing-masing gambar dalam siklus ganda dan untuk setiap pasangan posisi dari angka yang sama kita membuat klausa yang mirip dengan yang sebelumnya dan terdiri dari dua negatif.  Yaitu, ketika dua angka identik muncul (tetapi dalam posisi yang berbeda), salah satu klausa ini akan memberikan salah dan, karenanya, akan mengecualikan solusi semacam itu. <br><br>  Itu semua teori, dan sekarang mari kita beralih ke praktik.  Setiap gambar memiliki angka dari 1 hingga d untuk membedakannya dari yang lain dan mudah dicetak.  Kemudian buat matriks dari lapangan bermain dan encode sel yang sesuai dari lapangan bermain sebagai ditempati / tidak ditempati oleh gambar: <br><br> <code>. . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . 1 1 . . . . . <br> 1 1 . . . . . . <br> . 1 . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> 2 . . . . . . . <br> 2 . . . . . . . <br> 2 . . . . . . . <br> 2 . . . . . . . <br> 2 . . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> 3 . . . . . . . <br> 3 . . . . . . . <br> 3 . . . . . . . <br> 3 3 . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> 4 . . . . . . . <br> 4 . . . . . . . <br> 4 4 . . . . . . <br> . 4 . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> 5 5 . . . . . . <br> 5 5 . . . . . . <br> 5 . . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> 6 6 6 . . . . . <br> . 6 . . . . . . <br> . 6 . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> 7 . 7 . . . . . <br> 7 7 7 . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> 8 . . . . . . . <br> 8 . . . . . . . <br> 8 8 8 . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . 9 . . . . . <br> . 9 9 . . . . . <br> 9 9 . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . a . . . . . . <br> aaa . . . . . <br> . a . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> b . . . . . . . <br> bb . . . . . . <br> b . . . . . . . <br> b . . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . cc . . . . . <br> . c . . . . . . <br> cc . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> dd . . . . . . <br> dd . . . . . . <br></code> <br>  Sekarang, untuk masing-masing bagian, perlu untuk menemukan semua posisi yang mungkin di lapangan bermain melalui pergeseran, belokan dan refleksi.  Mari kita mulai dengan belokan dan refleksi.  Secara total, ada 8 kemungkinan transformasi belokan dan refleksi, termasuk satu transformasi sepele yang membuat gambarnya utuh.  Untuk transformasi ini, saya membuat 8 matriks yang sesuai, seperti yang ditunjukkan di bawah ini.  Setelah rotasi atau refleksi, angka tersebut dapat melampaui bidang bermain, sehingga perlu mengembalikannya ke bidang bermain.  Juga harus diperhitungkan bahwa beberapa tokoh dapat berubah menjadi diri mereka sendiri setelah transformasi, dan kasus-kasus seperti itu harus dikecualikan.  Saya menambahkan opsi unik ke kelas Orientation.  Hasilnya adalah kode berikut: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dimension_ = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MATRIX_SIZE = dimension_ * dimension_; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> * matrix = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[ MATRIX_SIZE ]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; MATRIX_SIZE; i++ ) { matrix[ i ] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; dimension_; i++ ) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> * matrix1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[ MATRIX_SIZE ]; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::copy( matrix, matrix + MATRIX_SIZE, matrix1 ); matrix1[ i ] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = dimension_; j &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> * dimension_; j++ ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !matrix1[ j - dimension_ ] ) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> * matrix2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[ MATRIX_SIZE ]; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::copy( matrix1, matrix1 + MATRIX_SIZE, matrix2 ); matrix2[ j ] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> NUMBER = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; dimension_; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> l = <span class="hljs-number"><span class="hljs-number">0</span></span>; l &lt; NUMBER; l++ ) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> * matrix3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[ MATRIX_SIZE ]; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::copy( matrix2, matrix2 + MATRIX_SIZE, matrix3 ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( l &amp; <span class="hljs-number"><span class="hljs-number">1</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> l1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; l1 &lt; dimension_; l1++ ) { matrix3[ l1 ] = -matrix3[ l1 ]; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( l &amp; <span class="hljs-number"><span class="hljs-number">2</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> l1 = dimension_; l1 &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> * dimension_; l1++ ) { matrix3[ l1 ] = -matrix3[ l1 ]; } } Orientation * orientation = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Orientation( figure ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Point *&gt;::const_iterator h = figure-&gt;points().begin(); h != figure-&gt;points().end(); ++h ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Point * p = *h; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; i1 &lt; dimension_; i1++ ) { x = x + p-&gt;coord( i1 ) * matrix3[ i1 ]; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; i1 &lt; dimension_; i1++ ) { y = y + p-&gt;coord( i1 ) * matrix3[ dimension_ + i1 ]; } <span class="hljs-function"><span class="hljs-function">Point </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">p1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( x, y )</span></span></span></span>; orientation-&gt;createPoint( p1.coord( <span class="hljs-number"><span class="hljs-number">0</span></span> ), p1.coord( <span class="hljs-number"><span class="hljs-number">1</span></span> ) ); } orientation-&gt;moveToOrigin(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( isUnique( orientations, orientation ) ) { orientations.push_back( orientation ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> orientation; } <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> [] matrix3; } <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> [] matrix2; } } <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> [] matrix1; }</code> </pre><br>  Kode ini diterapkan untuk masing-masing gambar, dan kemudian, Orientasi unik yang diterima digeser sepanjang sumbu x dan y menciptakan semua posisi yang mungkin dari setiap gambar.  Akibatnya, kami memiliki jumlah posisi berbeda berikut untuk masing-masing angka: <br><br> <code>---------- Figure 1 <br> Count = 288 <br> ---------- Figure 2 <br> Count = 64 <br> ---------- Figure 3 <br> Count = 280 <br> ---------- Figure 4 <br> Count = 280 <br> ---------- Figure 5 <br> Count = 336 <br> ---------- Figure 6 <br> Count = 144 <br> ---------- Figure 7 <br> Count = 168 <br> ---------- Figure 8 <br> Count = 144 <br> ---------- Figure 9 <br> Count = 144 <br> ---------- Figure a <br> Count = 36 <br> ---------- Figure b <br> Count = 280 <br> ---------- Figure c <br> Count = 144 <br> ---------- Figure d <br> Count = 49 <br></code> <br>  Kemudian kami menetapkan variabel Boolean untuk setiap posisi yang memungkinkan dan membuat formula, seperti dijelaskan di atas.  Setelah itu, kami memanggil minisat langsung dari aplikasi, yang mengembalikan solusi - satu set variabel kami dengan nilai yang diberikan benar atau salah.  Mengetahui posisi mana variabel-variabel ini ditugaskan, kami mencetak solusinya: <br><br> <code>bbbb 3 3 3 3 <br> ddbc 8 8 8 3 <br> dd 1 ccc 8 2 <br> 5 5 1 1 1 c 8 2 <br> 5 5 5 1 4 4 4 2 <br> 7 7 a 4 4 9 6 2 <br> 7 aaa 9 9 6 2 <br> 7 7 a 9 9 6 6 6 <br></code> <br><img src="https://ic.pics.livejournal.com/andyplekhanov/66030250/60414/60414_900.jpg" alt="gambar"><br><br><h2>  Apa selanjutnya </h2><br>  Tentu, untuk memikirkan ini tidak akan begitu menarik.  Oleh karena itu, pertanyaan pertama yang muncul bagi saya adalah "berapa banyak solusi berbeda yang ada yang tidak berbeda dalam belokan sepele dan refleksi dari lapangan bermain?".  Untuk melakukan ini, ada mode dalam pemecah SAT yang memungkinkan Anda untuk menambahkan klausa tanpa kehilangan informasi yang ada, yang secara signifikan mempercepat proses dibandingkan seolah-olah solusi dicari dari awal.  Solusi berikut dapat ditemukan dengan menambahkan klausa yang berisi negasi dari semua variabel yang ada dalam solusi sebelumnya.  Setelah menambahkan prosedur ini dan membandingkan solusi baru dengan yang sebelumnya, dengan mempertimbangkan belokan dan refleksi dari lapangan bermain, saya mendapat 1364 opsi berbeda. <br><br>  Perpanjangan lain yang menarik yang saya terapkan adalah studi tentang berbagai bentuk lapangan dan tokoh lainnya.  Dan akhirnya, studi bidang bermain tiga dimensi sangat menarik.  Tapi ini topik untuk artikel lain. <br><br><h2>  Perbarui </h2><br><br>  Setelah menambahkan kondisi tambahan: untuk setiap angka dari satu klausa - harus ada setidaknya satu posisi angka ini di lapangan bermain, perhitungannya menjadi jauh lebih cepat.  Selain itu, satu kesalahan telah diperbaiki, sebagai akibatnya jumlah semua opsi unik yang mungkin adalah 16146. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id408299/">https://habr.com/ru/post/id408299/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id408285/index.html">Survei Pengguna Geektimes</a></li>
<li><a href="../id408287/index.html">Siapa yang bisa disalahkan atas kecelakaan yang melibatkan mobil otonom? Kapan kita akan melihat KAMAZ otonom di jalan?</a></li>
<li><a href="../id408289/index.html">Antarmuka pengguna futuristik dari Tesla Model 3 baru</a></li>
<li><a href="../id408291/index.html">Di planet kerdil Ceres, samudera bisa ada di masa lalu</a></li>
<li><a href="../id408297/index.html">Cara kerja sulih suara aktor: bagian 2</a></li>
<li><a href="../id408301/index.html">DJI mengancam pengadilan dengan spesialis cybersecurity yang menemukan kunci untuk mengakses akun perusahaan di GitHub</a></li>
<li><a href="../id408303/index.html">Sejarah Singkat Makalah Elektronik: Evolusi dan Prospek</a></li>
<li><a href="../id408305/index.html">Jaringan saraf Stanford mendiagnosis pneumonia pada x-ray lebih baik daripada dokter</a></li>
<li><a href="../id408307/index.html">Raise3D: Pencetakan 3D menggantikan pembuatan sepatu tradisional</a></li>
<li><a href="../id408311/index.html">Proton dan neutron: mengerumuni materi dalam</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>