<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔘 🍞 📪 Mockito以及如何烹饪 ⛔️ 👶🏾 🌘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="关于文章 


 这是Mockito的另一本指南。 在其中，一方面，我试图描述该库的功能，以便使不熟悉该库的读者立即有机会充分利用它，而不仅仅是对其的一般了解。 另一方面，我想使它足够紧凑和结构化，这样我就可以快速完整地阅读它，并在阅读后很快找到但忘记了的东西。 总的来说，这篇文章对我本人很有用，当...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mockito以及如何烹饪</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444982/"><h2 id="o-state"> 关于文章 </h2><br><p> 这是Mockito的另一本指南。 在其中，一方面，我试图描述该库的功能，以便使不熟悉该库的读者立即有机会充分利用它，而不仅仅是对其的一般了解。 另一方面，我想使它足够紧凑和结构化，这样我就可以快速完整地阅读它，并在阅读后很快找到但忘记了的东西。 总的来说，这篇文章对我本人很有用，当我刚接触该库而并不真正了解它的工作原理时。 </p><br><p> 我想它现在对我有用-有时我会忘记其中的一些，并且最方便的是根据我自己的需求（例如摘要）而不是根据官方文档或其他人的文章来回顾这些资料。 同时，我尝试构建文本，以便首先从零开始了解Mockito时非常方便，并且在某些地方，我详细分析了看似明显的事情-并非所有这些东西从一开始就对我来说是显而易见的。 </p><a name="habracut"></a><br><h2 id="soderzhanie"> 内容： </h2><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Mockito：这是什么，为什么有必要</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">环境，版本和实验动物</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">模拟和间谍</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">行为管理</a> <br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">设定通话条件</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">设定通话结果</a> </li></ol></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">跟踪方法调用</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">将对象模拟为字段值和Mockito批注</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">回滚行为到默认会话和Mockito会话</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">还有什么</a> </li></ol><br><h2 id="mockito-chto-eto-takoe-i-zachem-nuzhno">  Mockito：这是什么，为什么有必要 </h2><br><p> 简而言之，Mockito是一个存根框架。 </p><br><p> 如您所知，在测试代码（主要是单元测试，但不仅是单元测试）时，被测元素通常需要提供工作时应使用的类的实例。 但是，它们通常不必完全发挥功能-相反，要求它们以严格定义的方式进行操作，以便其操作简单且完全可预测。 它们称为存根。 要获得它们，您可以创建接口的替代测试实现，使用功能的重新定义继承必要的类，依此类推，但这都是非常不便，多余且充满错误的。 在所有意义上，更方便的解决方案是用于创建存根的专用框架。 其中之一（也许是Java中最著名的）是Mockito。 </p><br><p> Mockito允许您用一行代码创建任何类的所谓的模拟（类似于所需存根的基础）。 对于这样的模拟，创建后立即具有某种默认行为（所有方法都返回先前已知的值-通常为<code>null</code>或<code>0</code> ）。 您可以按照自己的方式重新定义此行为，以适当的详细程度对其进行控制，等等。 结果，模拟成为具有所需属性的存根。 下面，我将详细讨论如何执行此操作。 </p><br><p> 我注意到，还可以为这些类创建模拟，实际上，您不能仅仅创建它们的新实例，尤其是具有专有私有构造函数的类，例如单例和实用程序类，并且框架和枚举的最小配置。 </p><br><h2 id="okruzhenie-versii-i-podopytnoe-zhivotnoe"> 环境，版本和实验动物 </h2><br><p> 在撰写本文时，我使用了： </p><br><ul><li>  Mockito：“ org.mockito：mockito-core：2.24.0”（撰写本文时为最新稳定版本） </li><li>  TestNG：“ org.testng：testng：6.14.3”作为测试框架 </li><li>  AssertJ：“ org.assertj：assertj-core：3.11.1”作为验证工具 </li><li> 龙目岛：'org.projectlombok：龙目岛：1.18.6'（为方便起见） </li><li>  Java 8 </li></ul><br><p> 对于我的非人为实验，我编写了该服务的接口，该接口提供对某些数据的访问。 </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;String&gt; dataToSave)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDataById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String id)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDataById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String id, Supplier&lt;String&gt; calculateIfAbsent)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">List&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">List&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDataListByIds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;String&gt; idList)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">List&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDataByRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DataSearchRequest request)</span></span></span></span>; }</code> </pre> <br><p> 并将请求类的此代码（为了方便起见）传递给最后一个接口方法。 </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@AllArgsConstructor</span></span> <span class="hljs-meta"><span class="hljs-meta">@Getter</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataSearchRequest</span></span></span><span class="hljs-class"> </span></span>{ String id; Date updatedBefore; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length; }</code> </pre> <br><p> 数据单元由ID标识，并具有更多特征，但是直接由服务返回的形式是字符串，而不是更复杂的对象。 我不会错过任何重要的事情，这些示例更加简单明了。 </p><br><p> 我马上会注意到：在下面的示例中，为了清楚起见，我直接调用了模拟对象的重写方法，但是经过实际测试，这个想法根本没有！ 在此测试中，我将始终执行以下操作： </p><br><ul><li> 根据需要配置我的服务的模拟； </li><li> 将它（很可能通过构造函数）传递给使用它的另一个类的实例（假设它使用<code>DataService</code>提供的数据包含某种业务逻辑），我将对其进行实际测试； </li><li> 启用测试类的功能并控制结果； </li><li> 如有必要，我将控制对我的模拟方法的调用的次数和顺序，由于先前的操作，被测试的类应该已经调用了该方法。 </li></ul><br><h2 id="mock-i-spy"> 模拟和间谍 </h2><br><p> 实际上，应该通过它访问大多数功能的Mockito的中心类是一个称为<code>Mockito</code>的类（还有<code>BDDMockito</code>类，它以更适合<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">BDD</a>的形式提供了相同的可能性，但在此我不再赘述） 。 对功能的访问是通过其静态方法实现的。 </p><br><p> 要创建<code>DataService</code>类的模拟，我只需执行以下操作： </p><br><pre> <code class="java hljs">DataService dataServiceMock = Mockito.mock(DataService.class);</code> </pre> <br><p> 完成-我得到了所需班级的一个实例。 任何需要此类型参数的方法或构造函数（例如，我要测试的类的构造函数）都将接受它。 即使上瘾检查稍后等待它也将通过它：不仅<code>instanceof DataService</code>将返回<code>true</code> ，而且<code>dataServiceMock.getClass()</code> －即<code>DataService.class</code> 。 从某种形式上讲，以编程方式将模拟对象与普通对象区分开来是一项相当困难的任务，这是合乎逻辑的：毕竟，第一个对象的目的只是与第二个对象没有区别。 但是，Mockito具有用于此目的的工具<code>Mockito.mockingDetails</code>方法。 通过将其传递给任意对象，我得到了<code>MockingDetails</code>类的对象。 从Mockito的角度来看，它包含有关此对象表示什么的信息：它是模拟的，间谍的（请参见下文），如何使用，如何创建等等。 </p><br><p> 特别需要注意的是，当我尝试为final类或enum的模拟实例创建模拟或覆盖final方法的行为时。 在这种情况下，使用Mockito的默认行为，上面的代码正是由于这种情况而拒绝工作。 但是，这可以更改-只需在项目（使用项目目录树的标准设备）中创建文件<code>test/resources/mockito-extensions/org.mockito.plugins.MockMaker</code>然后在其中输入以下行： </p><br><pre> <code class="plaintext hljs">mock-maker-inline</code> </pre> <br><p> 之后，您可以按照通常的方式模仿final类和枚举，以及覆盖final方法。 </p><br><p> 我使用的模拟程序尽可能没有特征：没有一个方法会对任何事物产生任何影响，并且对象类型的返回值将为<code>null</code> ，原始类型的返回值将为<code>0</code> 。 请注意：如果该方法返回一个集合，则默认的模拟将不会返回<code>null</code> ，而将返回空的集合实例。 例如，对于<code>List</code>无论实际方法应该返回什么<code>List</code>这都将是一个空的<code>LinkedList</code> 。 但是，作为数组，基元或对象的值，我得到<code>null</code> 。 可以使用<code>MockSettings</code>类的功能来更改默认行为（不仅是默认行为），但这很少需要。 </p><br><p> 一种或另一种方式，在大多数情况下，我不需要默认行为，在下一节中，我将详细分析如何设置所需的内容。 </p><br><p> 但是，如果我想将具有可用功能的真实类对象用作存根，仅重新定义其部分方法的操作，该怎么办？ 如果我们谈论的是单元测试，那么这种需求通常（但并非总是如此）表明该项目在设计上并不可行，并且原则上不建议这样做。 但是，在某些情况下由于某些原因无法避免这种情况。 对于这种情况，Mockito具有所谓的间谍“间谍”。 与模拟不同，它们可以基于类和完成的对象来创建： </p><br><pre> <code class="java hljs">DataService dataServiceSpy = Mockito.spy(DataService.class); <span class="hljs-comment"><span class="hljs-comment">// or DataService dataService = new DataService(); dataServiceSpy = Mockito.spy(dataService);</span></span></code> </pre> <br><p> 在基于类创建间谍时，如果其类型是接口，则将创建常规的模拟对象，如果类型是类，则Mockito将尝试使用默认构造函数（不带参数）创建实例。 并且只有在没有这样的构造函数的情况下，才会发生错误并且测试将无法进行。 </p><br><p> 默认情况下，间谍对象的行为与常规类实例的行为相同，但是它们为我提供了与模拟对象相同的可能性：它们允许我重新定义其行为并监视其使用（请参阅以下部分）。 重要的一点是：间谍不是创建它的实例的包装器！ 因此，调用spy方法不会影响原始实例的状态。 </p><br><h2 id="upravlenie-povedeniem"> 行为管理 </h2><br><p> 因此，关于如何嘲笑或间谍来做我需要的事情。 此外，除非另有明确说明，否则我到处总是简单地写“ mock”，这意味着“ mock or spy”。 </p><br><p> 通常，控制模拟对象的行为归结为一个显而易见的概念：当模拟以这种方式（即以这样的参数调用这样的方法）受到影响时，它应该以这样的方式响应。 这个概念在Mockito类中有两种实现-开发人员建议在可能的情况下使用的主要实现，而在主要不合适的情况下使用另一种实现。 </p><br><p> 主要实现基于<code>Mockito.when</code>方法。 该方法将对模拟对象的重新定义方法的调用作为“参数”（通过这种方式固定检测到的动作），并返回<code>OngoingStubbing</code>类型的对象，该对象允许调用<code>Mockito.then...</code> family的方法之一（这是对此效果的反应方式）。 总之，在最简单的情况下，它看起来像这样： </p><br><pre> <code class="java hljs">List&lt;String&gt; data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); data.add(<span class="hljs-string"><span class="hljs-string">"dataItem"</span></span>); Mockito.when(dataService.getAllData()).thenReturn(data);</code> </pre> <br><p> 完成此操作后，通过在<code>getAllData()</code>对象上调用<code>getAllData()</code>方法，可以得到清单第一行中指定的对象。 </p><br><p> 在这里，熟悉的“面向对象”直觉可能会带来某种故障，因此值得详细介绍。 从Java语法的角度来看，作为参数传递给<code>when</code>方法的值当然是重写方法返回的值。 对于模拟，这是一个空值；对于间谍，这是实际对象的方法返回的值。 但是，由于Mockito在幕后发挥了神奇的作用，仅<code>when</code>之后的模拟对象方法调用位于方括号内<code>when</code> ， <code>when</code>方法才能正常工作（并且在启动时出错时不会崩溃）。 </p><br><p> 在定义Mockito中的模拟行为时，通常会使用类似的意识形态：通过调用（模拟对象或<code>Mockito</code>类的）方法，我试图不获取其返回的值，但以某种方式影响所使用的模拟对象方法的调用：它的边界，设定结果，观察其挑战等。 我承认，这听起来有些模糊，在第一次碰撞时看起来很奇怪，但是一旦弄清楚了，很快就开始觉得这种方法在使用存根的情况下是完全自然的。 </p><br><p> 将条件和调用结果链接在一起的另一种实现方法是<code>Mockito.do...</code>系列的方法。 这些方法允许您从调用结果开始设置行为，并返回<code>Stubber</code>类的对象，您可以使用该对象设置条件。 与上述相同的绑定方式如下所示： </p><br><pre> <code class="java hljs">List&lt;String&gt; data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); data.add(<span class="hljs-string"><span class="hljs-string">"dataItem"</span></span>); Mockito.doReturn(data).when(dataService).getData()</code> </pre> <br><p> 有什么区别，为什么最好通过<code>Mockito.when</code>绑定，以及何时仍必须使用<code>Mockito.do...</code>的方法？ 请注意：在第一个实现中，设置方法的行为时（在本例中为<code>getAllData()</code> ），将首先执行对尚未重新定义的版本的调用，然后才在Mockito的肠道中进行覆盖。 在第二种方法中，不会发生这样的调用- <code>Stubber.when</code>方法直接传递到<code>Stubber.when</code>方法，并使用可重写方法调用此方法返回的相同类型但性质不同的对象。 这种差异决定了一切。 通过<code>Mockito.do...</code>绑定在编译阶段根本无法控制我将调用的可重定义方法，以及它在类型上是否与给定的返回值兼容。 因此，通常<code>Mockito.when</code>更可取的-这样做没有错误。 但是在某些情况下，我想避免调用重写的方法-对于新创建的模拟，这样的调用是完全可以接受的，但是如果我已经重新定义了此方法或处理间谍，则可能是不可取的，并且抛出异常将根本不允许进行必要的重新定义。 。 在这里，通过<code>Mockito.do...</code>进行绑定即可<code>Mockito.do...</code> </p><br><p> 没有<code>Mockito.do...</code>方法不能做的另一种情况是覆盖返回<code>void</code>的方法：挂起的<code>Mockito.when</code>参数不能与这种方法一起使用。  <code>Mockito.doReturn</code>在这里<code>Mockito.doReturn</code> ，但是有<code>Mockito.doThrow</code> ， <code>Mockito.doAnswer</code>和很少<code>Mockito.doNothing</code> 。 </p><br><p> 接下来，我将更详细地考虑如何设置呼叫的条件和结果。 我只会考虑通过<code>Mockito.when</code>绑定-另一种方法在处理方面几乎完全相似。 </p><br><h3 id="zadanie-usloviy-vyzova"> 设定通话条件 </h3><br><p> 上面的示例涉及一种没有参数的方法，并且关联的调用条件可能是一件事-调用的事实。 一旦出现参数，情况就变得更加复杂。 至少，要调用要设置其行为的方法，我需要向其传递一些信息。 但是另一件事更重要：事实证明，我并不总是希望得到给定的反应，而仅当我使用满足某些要求的参数来调用它时。  <code>DataService</code>具有以下方法： </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDataItemById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String id)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// some code... }</span></span></code> </pre> <br><p> 如果无论参数如何，都需要对此方法的任何调用设置响应，则必须使用<code>Mockito.any</code>方法： </p><br><pre> <code class="java hljs">Mockito.when(dataService.getDataItemById(any())) .thenReturn(<span class="hljs-string"><span class="hljs-string">"dataItem"</span></span>);</code> </pre> <br><p> 如果我需要模拟仅对参数的某个值作出反应，则可以直接使用此值，也可以使用<code>Mockito.eq</code> （如果等效）或<code>Mockito.same</code> （如果需要链接比较）的方法： </p><br><pre> <code class="java hljs">Mockito.when(dataService.getDataItemById(<span class="hljs-string"><span class="hljs-string">"idValue"</span></span>)) .thenReturn(<span class="hljs-string"><span class="hljs-string">"dataItem"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// or Mockito.when(dataService.getDataItemById(Mockito.eq("idValue"))) .thenReturn("dataItem");</span></span></code> </pre> <br><p> 如果我希望参数满足某些要求，则可以使用多个方便的，相同<code>Mockito</code>类的专用静态方法（例如，可以在某些字符序列的开头或结尾处检查字符串的内容，模式匹配等）。 还有一个通用方法Mockito.argThat（及其原始类型的类似物）接受ArgumentMatcher功能接口的实现： </p><br><pre> <code class="java hljs">Mockito.when(dataService.getDataById( Mockito.argThat(arg -&gt; arg == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || arg.length() &gt; <span class="hljs-number"><span class="hljs-number">5</span></span>))) .thenReturn(<span class="hljs-string"><span class="hljs-string">"dataItem"</span></span>);</code> </pre> <br><p>  <code>ArgumentMatchers</code>和<code>AdditionalMatchers</code>类使您可以使用此接口的一些有用的现成实现。 例如， <code>AdditionalMatchers.or</code>和<code>AdditionalMatchers.and</code>允许您组合其他匹配器（注意：这些类的静态方法不会返回匹配器的实例，而只能访问它们！） </p><br><p> 对于相同的方法，您可以针对参数的不同要求多次设置行为，并且以此方式定义的所有行为模型将同时起作用。 当然，在某些情况下，它们可能相交-例如，我将要求在参数的<code>int</code>值小于5时返回一个结果，而在接收到偶数时返回另一个结果。 在这种情况下，以后指定的行为优先。 因此，在定义复杂的行为模式时，您应该从最弱的要求开始（在极限内<code>any()</code> ），然后再转向更具体的要求。 </p><br><p> 当使用具有多个自变量的方法时，将根据逻辑与将指定的要求组合在一起，也就是说，要获得指定的结果，每个自变量都必须满足指定的要求。 尽管可能存在，但我没有找到设置任意组合方式的方法。 </p><br><p> 另外，在指定这种方法的行为时，不能<code>Mockito</code>和值的直接传递来组合静态<code>Mockito</code>方法。 使用<code>Mockito.eq</code>或<code>Mockito.same</code> 。 </p><br><h3 id="zadanie-rezultatov-vyzova"> 设定通话结果 </h3><br><p> 调用模拟对象方法后，对象必须响应该调用。 主要的可能结果是返回结果并引发异常，而Mockito工具箱正是在这些选项上设计的。 </p><br><p> 在上面已经显示的最简单的情况下，对调用的响应是返回一个值。 我将再次给出他的代码： </p><br><pre> <code class="java hljs">List&lt;String&gt; data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); data.add(<span class="hljs-string"><span class="hljs-string">"dataItem"</span></span>); Mockito.when(dataService.getAllData()).thenReturn(data);</code> </pre> <br><p> 请注意：您只能返回一个对象；没有用于原语的单独方法。 因此，如果该方法返回原始值，则在这种情况下将取消装箱。 在大多数情况下，这不会造成干扰，但是如果编译器认为不是，则您将不得不以某种方式同意他……或忍受他的警告。 </p><br><p> 抛出异常不再困难： </p><br><pre> <code class="java hljs">Mockito.when(dataService.getDataById(<span class="hljs-string"><span class="hljs-string">"invalidId"</span></span>)) .thenThrow(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException());</code> </pre> <br><p> 还有另一种方法：您可以创建一个异常对象并将其直接抛出，或者可以为Mockito仅提供一个异常类，以便自动创建它： </p><br><pre> <code class="java hljs">Mockito.when(dataService.getDataById(<span class="hljs-string"><span class="hljs-string">"invalidId"</span></span>)) .thenThrow(IllegalArgumentException.class);</code> </pre> <br><p> 在这两种情况下，语法都允许您使用和检查异常，但是，如果异常类型与我要强制抛出此异常的方法不匹配，则Mockito将不允许您运行此类测试。 </p><br><p> 当使用类作为参数时，构造函数（甚至没有参数）以及直接字段初始化都将被忽略-绕过它们创建的对象（毕竟，这是Mockito！），因此抛出异常的所有字段都将为<code>null</code> 。 因此，如果异常的内容对您很重要（例如，某个具有默认值的<code>type</code>字段），则您将不得不放弃此方法并手动创建异常。 </p><br><p> 如果响应给定条件的调用时，您始终需要返回某个特定的，始终相同的结果值或始终引发相同的异常，并且在大多数情况下这些功能已足够，则这些响应选项非常适合。 但是，如果需要更大的灵活性怎么办？ 假设我的方法接受值的集合，并返回与第一个值相关的另一个值的集合（例如，通过其ID集合获得数据对象的集合），并且我想在测试中对不同的输入集重复使用此模拟对象数据，每次获取对应的结果。 当然，您可以分别描述对每个特定参数集的反应，但是有一个更方便的解决方案<code>Mockito.thenAnswer</code>方法，又名<code>Mockito.then</code> 。 它接受<code>Answer</code>功能接口的实现，该接口的唯一方法是接收<code>InvocationOnMock</code>类的对象。 从后者中，我可以请求方法调用的参数（以数字的形式或以数组的形式一次或全部），并根据需要使用它们。 例如，您可以为我的集合中的每个元素获取一个与之对应的值，从它们中形成一个新的集合并返回它（注意：只是返回了期望的结果，而不是您期望的那样将其写入参数对象的某个字段）： </p><br><pre> <code class="java hljs">Mockito.when(dataService.getDataByIds(Mockito.any())) .thenAnswer(invocation -&gt; invocation .&lt;List&lt;String&gt;&gt;getArgument(<span class="hljs-number"><span class="hljs-number">0</span></span>).stream() .map(id -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (id) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"a"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"dataItemA"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"b"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"dataItemB"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } }) .collect(Collectors.toList()));</code> </pre> <br><p> 从意识形态上讲，这类似于编写一个真实方法的模型：获取参数，处理，返回结果。          -  ,    - ,      ,     ,    mock-    . </p><br><p>     <code>Answer</code> ,     , — , <code>AnswersWithDelay</code> , <code>ReturnsElementsOf</code>  . . </p><br><p>  :  <code>InvocationOnMock</code>   —       <code>Object[]</code> ,  generic-. </p><br><p>        — <code>thenCallRealMethod</code> .    .     mock-,    spy-.   mock   ,      ,  -   <code>null</code> .  spy   <code>thenCallRealMethod</code>     spy  ;    ,     -      . </p><br><p>        <code>thenAnswer</code> :  <code>InvocationOnMock</code>   <code>callRealMethod()</code> —   ,   ""    -  . </p><br><p>    <code>OngoingStubbing</code>    <code>OngoingStubbing</code> ,  ,   ,     .            ,   .  <code>thenReturn</code>  <code>thenThrow</code>   ,  varargs.       . </p><br><pre> <code class="java hljs">Mockito.when(dataService.getDataById(<span class="hljs-string"><span class="hljs-string">"a"</span></span>)) .thenReturn(<span class="hljs-string"><span class="hljs-string">"valueA1"</span></span>, <span class="hljs-string"><span class="hljs-string">"valueA2"</span></span>) .thenThrow(IllegalArgumentException.class);</code> </pre> <br><p>         <code>"valueA1</code> ,  — <code>"valueA2</code> ( ),   (  )    <code>IllegalArgumentException</code> . </p><br><h2 id="slezhenie-za-vyzovami-metodov">     </h2><br><p>        :          (mock'    ),     .   ,     :   ,          ,       .      <code>verify</code> . </p><br><p>  ,           ,  : </p><br><pre> <code class="java hljs">Mockito.verify(dataService).getDataById(Mockito.any());</code> </pre> <br><p>      ,            <code>getDataById</code> ,  ,           . ,             Mockito,      <code>when</code> ,   ,  ,         mock-. , ,  ,      <code>when</code>  , —      mock',       (. ). </p><br><p>           : </p><br><pre> <code class="plaintext hljs">Mockito.verify(dataService, Mockito.times(1)) .getDataById(Mockito.any());</code> </pre> <br><p>           <code>Mockito.times</code> ;       <code>Mockito.never</code> .    <code>Mockito.atLeast</code> (  <code>Mockito.atLeastOnce</code>   1)  <code>Mockito.atMost</code> ,       ,    <code>Mockito.only</code> , ,         mock-  (. .     ). </p><br><p>  ,         <code>Mockito</code> ,     <code>VerificationAfterDelay</code>  <code>VerificationWithTimeout</code> ,    <code>Mockito.after</code>  <code>Mockito.timeout</code> . 例如： </p><br><pre> <code class="plaintext hljs">Mockito.verify(dataService, Mockito.after(1000).times(1)) .getDataById(Mockito.any());</code> </pre> <br><p>    ,    mock   ,      ,              ,       .        .   <code>after</code>  <code>timeout</code>  ,          ,    ,    —   ,     .  ,   <code>timeout</code>         —       .   <code>VerificationWithTimeout</code>   <code>never</code>  <code>atMost</code> :         . </p><br><p>  ,             <code>Mockito.any()</code> .          ,   ,     —    Mockito       ,    ,     . Mock-     ,        ,   , , : </p><br><pre> <code class="java hljs">dataService.getDataById(<span class="hljs-string"><span class="hljs-string">"a"</span></span>); dataService.getDataById(<span class="hljs-string"><span class="hljs-string">"b"</span></span>); Mockito.verify(dataService, Mockito.times(<span class="hljs-number"><span class="hljs-number">2</span></span>)).getDataById(Mockito.any()); Mockito.verify(dataService, Mockito.times(<span class="hljs-number"><span class="hljs-number">1</span></span>)).getDataById(<span class="hljs-string"><span class="hljs-string">"a"</span></span>); Mockito.verify(dataService, Mockito.never()).getDataById(<span class="hljs-string"><span class="hljs-string">"c"</span></span>); dataService.getDataById(<span class="hljs-string"><span class="hljs-string">"c"</span></span>); Mockito.verify(dataService, Mockito.times(<span class="hljs-number"><span class="hljs-number">1</span></span>)).getDataById(<span class="hljs-string"><span class="hljs-string">"c"</span></span>); Mockito.verifyNoMoreInteractions(dataService);</code> </pre> <br><p>      <code>verifyNoMoreInteractions</code> (  <code>verifyZeroInteractions</code> ) —    -  (            <code>verify</code> )    mock- —    .  :   varargs,     ,     ,         <strong> </strong> ! </p><br><p>       ,   ,      ,     .   ,    <code>InOrder</code> : </p><br><pre> <code class="java hljs">InOrder inOrder = Mockito.inOrder(dataService);</code> </pre> <br><p>     varargs;     —    mock-   ,    <code>InOrder</code>                .     <code>verify</code>    ,   <code>Mockito.verify</code> : </p><br><pre> <code class="java hljs">inOrder.verify(dataService, times(<span class="hljs-number"><span class="hljs-number">2</span></span>)).saveData(any()); inOrder.verify(dataService).getData();</code> </pre> <br><p>       ,         <code>saveData</code> , <strong> </strong>  — <code>getData</code> .  ,   <code>InOrder</code>    ,      —     . </p><br><p>       ,   ,       — , .      -      ,    ,      —  ,     ,    .     <code>ArgumentCaptor</code>    <code>capture()</code> . 例如： </p><br><pre> <code class="java hljs">DataSearchRequest request = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DataSearchRequest(<span class="hljs-string"><span class="hljs-string">"idValue"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date(System.currentTimeMillis()), <span class="hljs-number"><span class="hljs-number">50</span></span>); dataService.getDataByRequest(request); ArgumentCaptor&lt;DataSearchRequest&gt; requestCaptor = ArgumentCaptor.forClass(DataSearchRequest.class); Mockito.verify(dataService, times(<span class="hljs-number"><span class="hljs-number">1</span></span>)).getDataByRequest(requestCaptor.capture()); assertThat(requestCaptor.getAllValues()).hasSize(<span class="hljs-number"><span class="hljs-number">1</span></span>); DataSearchRequest capturedArgument = requestCaptor.getValue(); assertThat(capturedArgument.getId()).isNotNull(); assertThat(capturedArgument.getId()).isEqualTo(<span class="hljs-string"><span class="hljs-string">"idValue"</span></span>); assertThat(capturedArgument.getUpdatedBefore()).isAfterYear(<span class="hljs-number"><span class="hljs-number">1970</span></span>); assertThat(capturedArgument.getLength()).isBetween(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>);</code> </pre> <br><p> <code>ArgumentCaptor</code>       ,      <strong> </strong> ,   <code>ArgumentCaptor</code>  . <code>getValue()</code>    , <code>getAllValues()</code> —     .   ,         ,   . </p><br><h2 id="mock-obekty-kak-znacheniya-poley-i-annotacii-mockito"> Mock-      Mockito </h2><br><p>      ,     mock-   ,      —     <code>@Mock</code>   -       : </p><br><pre> <code class="java hljs">MockitoAnnotations.initMocks(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);</code> </pre> <br><p> (  ,       mock',       ) </p><br><p>  spy   <code>@Spy</code> —     <code>@Mock</code> …   spy   ,      , ?          ,      —  spy     . </p><br><p>   <code>@Captor</code>    <code>ArgumentCaptor</code> —   , ,    . </p><br><p>   <code>@InjectMocks</code> .       -  Mockito,          .       mock-   ,   .        ,    .  -     ,     <code>null</code> ,   -     .         (      )  dependency injection. </p><br><h2 id="otkat-povedeniya-k-defoltnomu-i-sessii-mockito">       Mockito </h2><br><p>         ,  :   mock (spy, argument captor...),   ,    , .    ,  mock' —    ,    . JUnit           ,      ,    TestNG   —       . , ,   mock'    ,     ,   ,         . .  ,  ,  —  ,          . </p><br><p>   ,             mock-    .  TestNG     <code>@BeforeMethod</code> ( <code>@AfterMethod</code>  ).           mock'   ,        ,           (    JUnit —      <code>@Before</code> ). </p><br><p>   ,     , —   <code>Mockito.reset</code>  <code>Mockito.clearInvocations</code> .   varargs,      mock'.      ,    .     :     (,              )  ,   /   mock'    , —       .     ,    mock'       . .      , ,             . </p><br><p>       (,  ) —     <code>MockitoAnnotations.initMocks(this);</code>  。    ""  ,   Mockito. </p><br><p>    —     Mockito.    .     mock- ,          ( mock'      ).          ,      <code>MockitoSession</code> ,           .     TestNG: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Mock</span></span> DataService dataService; MockitoSession session; <span class="hljs-meta"><span class="hljs-meta">@BeforeMethod</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">beforeMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ session = Mockito.mockitoSession() .initMocks(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) .startMocking(); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// some code using the dataService field } @AfterMethod public void afterMethod() { session.finishMocking(); }</span></span></code> </pre> <br><p>  ,        —  ,  "" (,     )  ,   . </p><br><h2 id="chto-eschyo">  ? </h2><br><p>      Mockito:  mock  spy-,        .      ,       .  ,  , : </p><br><ul><li>  Mockito   mock-   <code>MockSettings</code> (      — ,   mock'    -  ); </li><li>     mock-,   <code>MockingDetails</code> ; </li><li>   <code>BDDMockito</code>   <code>Mockito</code> ; </li><li>     (    JUnit       Mockito,     ). </li></ul><br><p>         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">  Mockito</a> .           javadoc'  <code>Mockito</code> . </p><br><p> , ,  . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN444982/">https://habr.com/ru/post/zh-CN444982/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN444972/index.html">Intel Gen11 GPU架构和Intel独立显卡</a></li>
<li><a href="../zh-CN444974/index.html">Java中的密码学。 类MessageDigest</a></li>
<li><a href="../zh-CN444976/index.html">Quester-创建和完成任务的平台（测试版）</a></li>
<li><a href="../zh-CN444978/index.html">欧盟当局因阻止竞争对手的广告而对谷歌处以17亿美元的罚款</a></li>
<li><a href="../zh-CN444980/index.html">解析KIB SEARCHINFORM加密算法中的严重错误</a></li>
<li><a href="../zh-CN444984/index.html">照片来自哪里，用于测试人脸识别系统？</a></li>
<li><a href="../zh-CN444986/index.html">IETF批准ACME-这是使用SSL证书的标准</a></li>
<li><a href="../zh-CN444992/index.html">系统中内置的错误：它们在统计中的作用</a></li>
<li><a href="../zh-CN444994/index.html">关于驱动器及其在现代计算机上的使用</a></li>
<li><a href="../zh-CN444996/index.html">Redis流作为干净的数据结构</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>