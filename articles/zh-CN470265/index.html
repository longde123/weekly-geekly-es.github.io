<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍶 🏀 🈴 C ++缩写备忘单等。 第1部分：C ++ 🥣 👨🏼‍✈️ 🏇🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="有一次，我在一个体面甚至知名的办公室接受了C ++开发人员的职位面试。 那时我已经有一些经验，当时我甚至被雇主称为领先开发人员。 但是当被问到我是否知道诸如DRY，KISS，YAGNI，NIH之类的东西时，我不得不反复回答“不”。 

 我当然惨败了。 但是随后，上面的缩写被谷歌搜索并被记住。 当我...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C ++缩写备忘单等。 第1部分：C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470265/"> 有一次，我在一个体面甚至知名的办公室接受了C ++开发人员的职位面试。 那时我已经有一些经验，当时我甚至被雇主称为领先开发人员。 但是当被问到我是否知道诸如DRY，KISS，YAGNI，NIH之类的东西时，我不得不反复回答“不”。 <br><br> 我当然惨败了。 但是随后，上面的缩写被谷歌搜索并被记住。 当我阅读主题文章和书籍，准备接受采访以及与同事交谈时，我学到了更多新事物，忘记了它们，再次谷歌搜索并理解了。 几个月前，我的一位同事在IIFE关于C ++的工作聊天中随意提及。 就像那个祖父在开玩笑一样，我差点从火炉上摔下来，再次进入Google。 <br><br><img src="https://habrastorage.org/webt/i7/7u/fc/i77ufc8-ui3-rtrvpu-421lmpfq.png"><br><a name="habracut"></a><br> 那时，我决定（主要是为我自己）撰写一份备忘单，以供C ++开发人员了解有用的缩写。 这并不意味着它们仅适用于C ++，也不意味着它们是C ++的所有概念（您可以编写有关语言习语的书籍）。 不，这些只是我在工作和面试中实际遇到的概念，通常以缩写形式表示。 好吧，我错过了LIFO，FIFO，CRUD，OOP，GCC和MSVC等绝对琐碎的事情。 <br><br> 尽管如此，缩写还是相当不错的，所以我将备忘单分为两部分：C ++的强特性和更常见的特性。 在适当的时候，我将这些概念归为一组，否则我只是按字母顺序列出它们。 通常，它们的顺序没有多大意义。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">基本的东西：</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ODR</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">POD</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">POF</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PIMPL</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RAII</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RTTI</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">STL</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">UB</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">语言的细微之处：</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ADL</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CRTP</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CTAD</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">EBO</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">IIFE</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NVI</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RVO和NRVO</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SFINAE</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SBO，SOO，SSO</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b>更新：</b></a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">简历</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">LTO</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PCH</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PGO</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SEH / VEH</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">TMP</a> <br>  • <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">VLA</a> <br><br><h2> 基本的东西 <a name="Basics"></a></h2><br><h3>  ODR <a name="ODR"></a></h3><br>  <i>一个定义规则。</i>  <i>一个定义的规则。</i> 简化意味着： <br><br><ul><li> 在一个翻译单元中，每个变量，函数，类等的定义不得超过一个。 有尽可能多的广告（没有给定基本类型的传输除外，除非定义，否则就不能声明），但不得超过一个定义。 如果不使用实体，则可能性较小。 </li><li> 在整个程序中，使用的每个非内联函数和变量都必须具有唯一的定义。 使用的每个内联函数和变量在每个转换单元中必须有一个定义。 </li><li> 某些实体（例如类，内联函数和变量，模板，枚举等）可以在程序中具有多个定义（但在翻译单元中不能超过一个）。 实际上，例如，当包含完全实现的类的同一标头连接到多个.cpp文件时，就会发生这种情况。 但是这些定义应该是一致的（我大大简化了，但本质是这样）。 否则将是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">UB</a> 。 </li></ul><br> 编译器将很容易在翻译单元中发现违反<i>ODR的</i>情况。 但是如果在程序规模上违反了规则，他将无能为力-仅因为编译器一次处理一个翻译单元。 <br><br> 链接器可以发现更多的违规行为，但是严格来说，他没有义务这样做（因为根据标准， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">UB在</a>此处）并且可以丢失某些内容。 另外，在链接阶段搜索<i>ODR</i>违规的过程具有二次复杂性，并且C ++代码的汇编不是那么快。 <br><br> 因此，遵守此规则（尤其是在程序级别）的主要责任是开发人员本人。 是的-只有具有外部链接的实体才能在程序规模上违反<i>ODR</i> ； 内部的内容（即在匿名名称空间中定义的内容）不参与此狂欢。 <br><br> 阅读更多： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一（英语）</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">两（英语）</a> <br><br><h3> 豆荚 <a name="POD"></a></h3><br>  <i>普通的旧数据。</i>  <i>简单的数据结构。</i> 最简单的定义：您可以直接以二进制形式向C库发送/从C库接收这种结构。 或者，同一件事，请使用简单的<code>memcpy</code>正确复制。 <br><br> 从标准到标准，完整定义已详细更改。 最新的C ++ 17 <i>POD</i>当前定义了 <br><br><ul><li> 标量类型 </li><li> 或一个类/结构/联合： <br>  -有一个琐碎的课 <br>  -有配备标准装置的课程 <br>  -不包含非<i>POD</i>非静态字段 <br></li><li> 或这些类型的数组 </li></ul><br> 普通班： <br><br><ul><li> 至少有一个未删除： <br>  -默认构造函数 <br>  -复制构造函数 <br>  -移动构造函数 <br>  -复制分配运算符 <br>  -移动分配运算符 <br></li><li> 复制和移动构造函数和赋值运算符的所有默认构造函数都是微不足道的（简化的-由编译器生成）或远程的 </li><li> 有一个琐碎的非远程析构函数 </li><li> 所有基本类型和类类型的所有字段都具有琐碎的析构函数 </li><li> 没有虚拟方法（包括析构函数） </li><li> 没有虚拟基础类型 </li></ul><br> 具有标准设备的类（标准布局类）： <br><br><ul><li> 没有虚拟方法 </li><li> 没有虚拟基础类型 </li><li> 没有非静态链接字段 </li><li> 所有非静态字段都具有相同的访问修饰符（公共/受保护/私有） </li><li> 所有非静态字段和基类也是带有标准设备的类型 </li><li> 该类本身及其所有祖先的所有非静态字段都在一个单独的类中声明（即，在类本身或一个祖先中） </li><li> 它不会两次继承相同的类型，即无法做到这一点： <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> :</span></span> A {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> :</span></span> A{}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D</span></span></span><span class="hljs-class"> :</span></span> B, C {};</code> </pre> </li><li> 第一个非静态字段的类型，或者，如果它是一个数组，则其元素的类型必须与任何基本类型都不相同（在这种情况下是由于强制性<i>EBO</i> ） </li></ul><br> 但是，在C ++ 20中，将不再存在<i>POD</i>类型的概念，仅保留普通类型和带有标准设备的类型。 <br><br> 阅读更多： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一名（俄语）</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">两名（英语）</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">三名（英语）</a> <br><br><h3>  POF <a name="POF"></a></h3><br>  <i>普通的旧函数。</i>  <i>一个简单的C样式函数</i> ，仅在信号处理程序的上下文中在C ++ 14之前的标准中提及。 要求是： <br><br><ul><li> 仅使用C和C ++通用的东西（例如，没有例外和<code>try-catch</code> ） </li><li> 不会直接或间接导致非<i>POF</i>函数，除了无原子块操作（ <code>std::atomic_init</code> ， <code>std::atomic_fetch_add</code>等） </li></ul><br> 本标准仅将这些功能（也具有C链接）（ <code>extern "C"</code> ）用作信号处理程序。 对其他功能的支持取决于编译器。 <br><br> 在C ++ 17中， <i>POF</i>的概念消失了，而不是出现信号安全评估。 在这种计算中被禁止： <br><br><ul><li> 调用标准库的所有函数，除了原子，无锁 </li><li>  <code>new</code>和<code>delete</code>呼叫 </li><li> 使用<code>dynamic_cast</code> </li><li> 调用<code>thread_local</code>实体 </li><li> 任何例外的工作 </li><li> 局部静态变量的初始化 </li><li> 等待静态变量初始化完成 </li></ul><br> 如果信号处理程序执行上述任一操作，则标准承诺<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">UB</a> 。 <br><br> 阅读更多： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">时间（英语）</a> <br><br><h3>  PIMPL <a name="PIMPL"></a></h3><br>  <i>实施的指针。</i>  <i>指向实现的指针。</i>  C ++中的经典习语，也称为d指针，不透明指针，编译防火墙。 它包含以下事实：某个类的所有私有方法，字段和其他实现细节都分配到一个单独的类中，而只有公共方法（即一个接口）和指向该新的单独类的实例的指针保留在原始类中。 例如： <br><br><div class="spoiler">  <b class="spoiler_title">foo.hpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Foo(); ~Foo(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doThis</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doThat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Impl</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Impl&gt; pImpl_; };</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">foo.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"foo.hpp"</span></span></span><span class="hljs-meta"> class Foo::Impl { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// implementation }; Foo::Foo() : pImpl_(std::make_unique&lt;Impl&gt;()) {} Foo::~Foo() = default; void Foo::doThis() { pImpl_-&gt;doThis(); } int Foo::doThat() { return pImpl_-&gt;doThat(); }</span></span></span></span></code> </pre> <br></div></div><br> 为什么这是必要的，即优点： <br><br><ul><li> 封装：通过头连接的类的用户只能获得他们需要的东西-公共接口。 如果实现细节发生变化，则不必重新编译客户端代码（请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ABI</a> ）。 </li><li> 编译时间：由于公共头文件对实现一无所知，因此它不包含所需的许多头文件。 因此，减少了客户端代码中隐式连接的标头的数量。 还可以简化对重载的名称和解析的搜索，因为公共标题不包含私有成员（尽管它们是私有成员，但它们参与这些过程）。 </li></ul><br> 价格，即劣势： <br><br><ul><li> 访问公共方法时，至少要有一个指针取消引用，再加上一个函数调用。 </li><li> 所需的内存类的大小会因指针的大小而增加。 </li><li> 此内存的一部分（很可能更大）分配在堆上，这也对性能产生负面影响。 </li><li> 逻辑恒定性很容易被破坏。 例如，这样的代码编译： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Foo::doThis() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { pImpl_-&gt;doThis(); <span class="hljs-comment"><span class="hljs-comment">// cosnt method pImpl_-&gt;doSmthElse(); // non-const method }</span></span></code> </pre> </li></ul><br> 这些缺点中的一些缺点是可以消除的，但是价格进一步使代码复杂化，并引入了更多的抽象级别（请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FTSE</a> ）。 <br><br> 阅读更多： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一名（俄语）</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">两名（俄语）</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">三名（英语）</a> <br><br><h3> 区域情报研究所 <a name="RAII"></a></h3><br>  <i>资源获取正在初始化。</i>  <i>捕获资源就是初始化。</i> 这个成语的意思是，某种资源的保留在相应对象的整个生命周期中持续存在。 资源的捕获发生在对象的创建/初始化时，释放发生在相同对象的销毁/完成时。 <br><br> 奇怪的是（主要用于C ++程序员），这个习惯用法还用于其他语言，甚至那些带有垃圾收集器的语言。 在Java中，它是<code>try--</code> ，在Python中是<code>with</code>语句，在C＃中是<code>using</code>指令，在Go <code>defer</code> 。 但是， <i>RAII</i>尤其适合有机地使用具有绝对可预测对象寿命的C ++。 <br><br> 在C ++中，通常在构造函数中捕获资源，然后在析构函数中释放资源。 例如，智能指针以这种方式控制内存，文件流管理文件，互斥锁锁定互斥锁。 这样做的好处是，无论块如何退出（范围）-通过任何出口点正常运行还是抛出异常-在此块中创建的资源控制对象都将被销毁，并且资源将被释放。 即 除了将<i>RAII</i>封装在C ++中之外，它还有助于确保异常意义上的安全性。 <br><br> 局限，没有局限。  C ++中的析构函数不返回值，并且绝对不应引发异常。 因此，如果资源的释放伴随一个或另一个，则有必要在控制对象的析构函数中实现其他逻辑。 <br><br> 阅读更多： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一次（俄语）</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">两次（英语）</a> <br><br><h3>  RTTI <a name="RTTI"></a></h3><br>  <i>运行时类型信息。</i>  <i>在运行时进行类型识别。</i> 这是一种用于在运行时获取有关对象或表达式类型的信息的机制。 它以其他语言存在，但在C ++中，它用于： <br><br><ul><li> <code>dynamic_cast</code> </li> <li>  <code>typeid</code>和<code>type_info</code> </li><li> 捕获异常 </li></ul><br> 一个重要的限制： <i>RTTI</i>使用虚拟函数表，因此仅适用于多态类型（虚拟析构函数就足够了）。 一个重要的解释： <code>dynamic_cast</code>和<code>typeid</code>并不总是使用<i>RTTI</i> ，因此适用于非多态类型。 例如，要动态地将到后代的链接转换为到祖先的链接， <i>则</i>不需要<i>RTTI</i> ；所有信息在编译时都可用。 <br><br>  <i>RTTI</i>尽管不是免费的，但不是免费的，但它会对所消耗的内存的性能和大小产生负面影响（因此，经常建议不要使用<code>dynamic_cast</code>因为它的速度较慢）。 因此，通常，编译器允许您禁用<i>RTTI</i> 。  GCC和MSVC承诺这不会影响捕获异常的正确性。 <br><br> 阅读更多： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一次（俄语）</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">两次（英语）</a> <br><br><h3>  STL <a name="STL"></a></h3><br>  <i>标准模板库。</i>  <i>标准模板库。</i>  C ++标准库的一部分，提供通用容器，迭代器，算法和帮助函数。 <br><br> 尽管它的名称众所周知，但<i>STL</i>从未在标准中如此称呼。 从标准的各个部分，可以明确将<i>STL</i>归因于Containers库，Iterators库，Algorithm库以及部分General Utility库。 <br><br> 在职位描述中，您经常可以找到2个独立的需求-C ++知识和对<i>STL的</i>熟悉。 我从不理解这一点，因为自1998年第一版标准以来， <i>STL就已</i>成为语言不可分割的一部分。 <br><br> 阅读更多： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一次（俄语）</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">两次（英语）</a> <br><br><h3>  UB <a name="UB"></a></h3><br>  <i>未定义的行为。</i>  <i>未定义的行为。</i> 在没有标准要求的错误情况下，这种行为。 这些标准中有许多在<i>UB中</i>被明确列出。 这些包括，例如： <br><br><ul><li> 违反数组或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">STL</a>容器的边界 </li><li> 使用未初始化的变量 </li><li> 解引用空指针 </li><li> 有符号整数溢出 </li></ul><br>  <i>UB</i>的结果取决于连续的所有内容-既取决于编译器版本，又取决于火星的天气。 而且，此结果可能是任何事情：编译错误，正确执行和崩溃。 不确定的行为是邪恶的，有必要摆脱它。 <br><br> 另一方面，不应将未定义的行为与<i>未指定的行为</i>混淆。 未指定的行为是正确程序的正确行为，但在标准允许的情况下，取决于编译器。 并且不需要编译器对其进行记录。 例如，这是评估函数参数的顺序或<code>std::map</code>的实现细节。 <br><br> 好了，在这里您可以回顾实现定义的行为。 与未指定的文档可用性不同。 示例：编译器可以自由地将<code>std::size_t</code>类型设置<code>std::size_t</code>任意大小，但必须指出哪种类型。 <br><br> 阅读更多： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一名（俄语）</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">两名（俄语）</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">三名（英语）</a> <br><br><h2> 舌头的微妙之处 <a name="Cobwebs"></a></h2><br><h3>  ADL <a name="ADL"></a></h3><br>  <i>基于参数的查找。</i>  <i>依赖参数的搜索。</i> 他是对Koenig的搜寻-以此纪念Andrew Koenig。 除了通常的名称解析之外，这是一组用于解析不合格函数名称（即，不带<code>::</code>运算符的名称）的规则。 简而言之：在与函数自变量相关的名称空间中查找函数的名称（这是一个空间，其中包含参数的类型，类型本身（如果是类，则包括其祖先等）。） <br><br><div class="spoiler">  <b class="spoiler_title">最简单的例子</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; namespace N { struct S {}; void f(S) { std::cout &lt;&lt; "f(S)" &lt;&lt; std::endl; }; } int main() { N::S s; f(s); }</span></span></span></span></code> </pre> <br> 仅在名称空间<code>N</code>找到函数<code>f</code> ，因为函数的参数属于该空间。 <br></div></div><br> 甚至普通的<code>std::cout &lt;&lt; "Hello World!\n"</code>使用<i>ADL</i> ， <code>std::basic_stream::operator&lt;&lt;</code> <code>const char*</code>不会重载<code>std::basic_stream::operator&lt;&lt;</code> 。 但是此语句的第一个参数是<code>std::basic_stream</code> ，编译器在<code>std</code>搜索并找到合适的重载。 <br><br> 一些细节：如果常规搜索在不使用的情况下在当前块中找到了类成员的声明或函数声明，或者不使用函数或函数模板的声明，则<i>ADL</i>不适用。 或者，如果函数名称在括号中指示（上面的示例未使用<code>(f)(s)</code>编译；您将必须编写<code>(N::f)(s);</code> ）。 <br><br> 有时， <i>ADL会</i>强迫您在似乎不必要的地方使用完全限定的函数名。 <br><br><div class="spoiler">  <b class="spoiler_title">例如，此代码无法编译</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> N1 { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(S)</span></span></span><span class="hljs-function"> </span></span>{}; } <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> N2 { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(N1::S)</span></span></span><span class="hljs-function"> </span></span>{}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(N1::S s)</span></span></span><span class="hljs-function"> </span></span>{ foo(s); } }</code> </pre> <br></div></div><br> 阅读更多： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一种（英语）</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">两种（英语）</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">三种（英语）</a> <br><br><h3>  CRTP <a name="CRTP"></a></h3><br>  <i>奇怪地重复的模板模式。</i>  <i>奇怪的递归模式。</i> 模板的实质如下： <br><br><ul><li> 一些类从模板类继承 </li><li> 后代类用作其基类的模板参数 </li></ul><br> 举个例子比较容易： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived</span></span></span><span class="hljs-class"> :</span></span> Base&lt;Derived&gt; {};</code> </pre> <br>  <i>CRTP</i>是静态多态性的主要示例。 基类提供接口；派生类提供实现。 但是与普通的多态性不同，创建和使用虚拟函数表没有任何开销。 <br><br><div class="spoiler">  <b class="spoiler_title">例子</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">action</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T*&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)-&gt;actionImpl(); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived</span></span></span><span class="hljs-class"> :</span></span> Base&lt;Derived&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">actionImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ ... } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arg</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">staticPolymorphicHandler</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arg</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">arg</span></span></span><span class="hljs-class">) {</span></span> arg.action(); }</code> </pre> <br> 正确使用<code>T</code>始终是<code>Base</code>的后代，因此<code>static_cast</code>足以<code>static_cast</code>转换。 是的，在这种情况下，基类知道后代接口。 <br></div></div><br>  <i>CRTP的</i>另一个常见使用领域是继承类（某些语言中称为mixin的类）的功能的扩展（或缩小）。 也许最著名的例子： <br><br><ul><li> <code>struct Derived : singleton&lt;Derived&gt; { … }</code> </li> <li> <code>struct Derived : private boost::noncopyable&lt;Derived&gt; { … }</code> </li> <li> <code>struct Derived : std::enable_shared_from_this&lt;Derived&gt; { … }</code> </li> <li>  <code>struct Derived : counter&lt;Derived&gt; { … }</code> -计算已创建和/或现有对象的数量 </li></ul><br> 缺点，或者是需要引起注意的时刻： <br><br><ul><li> 没有通用的基类，您无法创建不同后代的集合，也无法通过指向基类型的指针访问它们。 但是，如果需要，您可以从通常的多态类型继承Base。 </li><li> 还有一个机会可以使您的脚摆脱粗心大意： <br><br><div class="spoiler">  <b class="spoiler_title">例子</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived1</span></span></span><span class="hljs-class"> :</span></span> Base&lt;Derived1&gt; {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived2</span></span></span><span class="hljs-class"> :</span></span> Base&lt;Derived1&gt; {};</code> </pre> <br> 但是您可以添加保护： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: Base() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> T;</code> </pre> </div></div></li><li> 因为 由于所有方法都是非虚拟的，因此后代的方法将隐藏具有相同名称的基类的方法。 因此，最好以不同的方式命名它们。 </li><li> 通常，后代具有公共方法，除了基类外，不应在其他任何地方使用。 这不是很好，但是可以通过附加的抽象级别进行纠正（请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FTSE</a> ）。 </li></ul><br><br> 阅读更多： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一次（俄语）</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">两次（英语）</a> <br><br><h3>  CTAD <a name="CTAD"></a></h3><br>  <i>类模板参数推导。</i>  <i>自动推断类模板参数的类型。</i> 这是C ++ 17的一项新功能。 以前，仅自动显示变量类型（ <code>auto</code> ）和函数模板参数，这就是为什么出现诸如<code>std::make_pair</code> ， <code>std::make_tuple</code>等辅助函数的<code>std::make_tuple</code> ，现在大多不需要它们，因为编译器能够自动显示类模板的参数： <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair p{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2.0</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// -&gt; std::pair&lt;int, double&gt; auto lck = std::lock_guard{mtx}; // -&gt; std::lock_guard&lt;std::mutex&gt;</span></span></code> </pre> <br>  <i>CTAD</i>是一个新的机会，它仍然<i>需要</i>发展和发展（C ++ 20已经有望得到改进）。 同时，限制如下： <br><br><ul><li><div class="spoiler">  <b class="spoiler_title">不支持参数类型的部分推断</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; p{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//  std::tuple&lt;&gt; t{1, 2, 3}; // </span></span></code> </pre></div></div></li><li><div class="spoiler">  <b class="spoiler_title">不支持模板别名</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">U</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyPair</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:pair&lt;T, U&gt;; MyPair p{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> </div></div></li><li><div class="spoiler">  <b class="spoiler_title">不支持仅在模板专业化中可用的构造函数。</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Wrapper</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Wrapper</span></span></span><span class="hljs-class">&lt;int&gt; {</span></span> Wrapper(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) {}; }; Wrapper w{<span class="hljs-number"><span class="hljs-number">5</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> </div></div></li><li><div class="spoiler">  <b class="spoiler_title">不支持嵌套模板</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">U</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> {</span></span> Bar(T, U) {}; }; }; Foo::Bar x{ <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2.0</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//  Foo&lt;int&gt;::Bar x{1, 2.0}; // OK</span></span></code> </pre> </div></div></li><li><div class="spoiler">  <b class="spoiler_title">显然，如果模板参数的类型与构造函数参数不相关，则CTAD将不起作用。</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Collection</span></span></span><span class="hljs-class"> {</span></span> Collection(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size) {}; }; Collection c{<span class="hljs-number"><span class="hljs-number">5</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> </div></div></li></ul><br> 在某些情况下，应该在与类模板相同的块中声明的显式推理规则会有所帮助。 <br><br><div class="spoiler">  <b class="spoiler_title">例子</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Collection</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">It</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Collection</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">It</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">from</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">It</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">to</span></span></span><span class="hljs-class">) {</span></span>}; }; Collection c{v.begin(), v.end()}; <span class="hljs-comment"><span class="hljs-comment">//  template &lt;class It&gt; Collection(It, It)-&gt;Collection&lt;typename std::iterator_traits&lt;It&gt;::value_type&gt;; Collection c{v.begin(), v.end()}; //  OK</span></span></code> </pre> </div></div><br><br> 阅读更多： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一次（俄语）</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">两次（英语）</a> <br><br><h3> 埃博 <a name="EBO"></a></h3><br>  <i>空基础优化。</i>  <i>空基类的优化。</i> 也称为空基类优化（EBCO）。 <br><br> 如您所知，在C ++中，任何类的对象的大小不能为零。 否则，所有指针的运算都将中断，因为可以在一个地址上标记任意数量的不同对象。 因此，即使是空类的对象（即没有单个非静态字段的类）也具有一些非零的大小，这取决于编译器和OS，通常等于1。 <br><br> 因此，在空类的所有对象上的内存被白白浪费了。 但不是其后代的对象，因为在这种情况下，标准明确地规定了例外。 允许编译器不为空的基类分配内存，因此，由于还可以对齐，因此不但可以节省空类的1个字节，还可以节省所有4个字节（取决于平台）。 <br><br><div class="spoiler">  <b class="spoiler_title">例子</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Empty</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> :</span></span> Empty { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(Empty) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 1 std::cout &lt;&lt; sizeof(Foo) &lt;&lt; std::endl; // 4 std::cout &lt;&lt; sizeof(int) &lt;&lt; std::endl; // 4</span></span></code> </pre> </div></div><br> 但是， <i>由于</i>不能将相同类型的不同对象放在同一地址，因此在以下情况下， <i>EBO</i>将不起作用： <br><br><ul><li><div class="spoiler">  <b class="spoiler_title">在祖先中两次发现一个空类</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Empty</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Empty2</span></span></span><span class="hljs-class"> :</span></span> Empty {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> :</span></span> Empty, Empty2 { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(Empty) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 1 std::cout &lt;&lt; sizeof(Empty2) &lt;&lt; std::endl; // 1 std::cout &lt;&lt; sizeof(Foo) &lt;&lt; std::endl; // 8</span></span></code> </pre> </div></div></li><li><div class="spoiler">  <b class="spoiler_title">第一个非静态字段是相同空类或其后代的对象</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Empty</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> :</span></span> Empty { Empty e; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(Empty) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 1 std::cout &lt;&lt; sizeof(Foo) &lt;&lt; std::endl; // 8</span></span></code> </pre> </div></div></li></ul><br> 如果空类的对象是非静态字段，则不会提供任何优化（目前，属性<code>[[no_unique_address]]</code>将出现在C ++ 20中）。 但是为每个这样的字段花费4个字节（或编译器需要多少字节）是一个耻辱，因此您可以自己将第一个非空非静态字段与空类的对象“折叠”在一起。 <br><br><div class="spoiler">  <b class="spoiler_title">例子</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Empty1</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Empty2</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Member</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Empty</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EmptyOptimization</span></span></span><span class="hljs-class"> :</span></span> Empty ... { Member member; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> {</span></span> EmptyOptimization&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, Empty1, Empty2&gt; data; };</code> </pre> <br> 奇怪，但是在这种情况下，不同编译器的Foo大小是不同的，对于MSVC 2019，它的大小是8，对于GCC 8.3.0，它的大小是4。但是无论如何，增加空类的数量不会影响<code>Foo</code>的大小。 </div></div><br> 阅读更多： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一次（英语）</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">两次（英语）</a> <br><br><h3> 国际教育展 <a name="IIFE"></a></h3><br>  <i>立即调用的函数表达式。</i>  <i>功能表达式立即调用。</i> 通常，这是JavaScript中的一个惯用法，Jason Turner从中借用了它和名称。 实际上，它只是在创建并立即调用一个lambda： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> myVar = [&amp;] { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (condition1()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> computeSomeComplexStuff(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> condition2() ? computeSonethingElse() : DEFAULT_VALUE; } ();</code> </pre> <br> 为什么这是必要的？ 好吧，例如，如上面的代码中所示，是为了通过非平凡的计算结果初始化常量，而不用不必要的变量和函数阻塞作用域。 <br><br> 阅读更多： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一次（英语）</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">两次（英语）</a> <br><br><h3>  NVI <a name="NVI"></a></h3><br>  <i>非虚拟接口。</i>  <i>非虚拟接口。</i> 根据这个习惯用法，开放类接口不应包含虚函数。 所有虚拟函数都设为私有（最大保护）并在非虚拟内部调用。 <br><br><div class="spoiler">  <b class="spoiler_title">例子</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Base() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// check precondition fooImpl(); // check postconditions } private: virtual void fooImpl() = 0; }; class Derived : public Base { private: void fooImpl() override { } };</span></span></code> </pre> </div></div><br> 为什么这是必要的： <br><br><ul><li> 每个打开的虚函数都做两件事：它定义类的公共接口，并参与子孙类中的重写行为。  <i>NVI</i>的使用消除了此类功能，带来了双重负担：接口由某些功能定义，行为由其他功能定义。 您可以彼此独立地更改它们。 </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果对实现虚拟功能的所有选项（检查前和检查后，互斥量捕获等）有一些一般性要求，那么将它们收集在一个位置（请参见</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DRY</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）-在基类中-并防止继承者覆盖</font><font style="vertical-align: inherit;">是非常方便的</font><font style="vertical-align: inherit;">这种行为。</font></font>即<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 原来是模式Template方法的一种特殊情况。 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NVI的代价</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是代码膨胀，性能可能下降（由于调用了一个额外的方法）以及对脆弱的基类问题的敏感性增加（请参阅</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FBC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阅读更多：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一次（英语）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">两次（英语）</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> RVO和NRVO </font></font><a name="RVO"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（命名）返回值优化。</font><font style="vertical-align: inherit;">优化（命名）返回值。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是标准允许的复制省略的一种特殊情况-编译器可以忽略不必要的临时对象副本，即使它们的构造函数和析构函数具有明显的副作用。</font><font style="vertical-align: inherit;">当函数按值返回对象时，这样的优化是允许的（其他两种允许的复制省略情况是引发和捕获异常）。</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例子</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Foo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Foo(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> f = bar(); }</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果没有</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，将在此处创建</font></font><code>Foo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数中的</font><font style="vertical-align: inherit;">一个临时对象</font></font><code>bar</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，然后通过复制构造函数从中创建函数中的另一个临时对象</font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（以获取结果</font></font><code>bar</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），然后才创建</font></font><code>f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该对象并将第二个临时对象的值分配给它。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">摆脱了所有这些复制和分配，并且该函数</font></font><code>bar</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">直接创建</font></font><code>f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发生这种情况：函数</font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在其堆栈框架中为对象分配空间</font></font><code>f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。函数</font></font><code>bar</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（已在其框架中工作）可以访问在前一框架中分配的该内存，并在那里创建所需的对象。</font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NRVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVO进行</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了相同的优化，但是不是在expression中</font></font><code>return</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建对象时，而是在返回先前在函数中创建的对象</font><font style="vertical-align: inherit;">时进行的优化</font><font style="vertical-align: inherit;">。</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例子</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Foo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Foo result; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管差异看似很小，但</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NRVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实施起来却困难得多，因此在许多情况下它不起作用。</font><font style="vertical-align: inherit;">例如，如果一个函数返回一个全局对象或其参数之一，或者一个函数有多个退出点并且通过它们返回了不同的对象，则</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NRVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将不适用。</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NRVO在这里不起作用</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Foo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> condition)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (condition) { Foo f1; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f1; } Foo f2; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f2; }</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">几乎所有编译器都长期支持</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NRVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的支持程度</font><font style="vertical-align: inherit;">可能因编译器和版本而异。</font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NRVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只是优化。并且虽然没有调用复制构造函数和赋值运算符，但是它们应该在对象的类中。在C ++ 17中，规则有所变化：现在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不被视为复制省略，它已成为强制性的，并且不需要相应的构造函数和赋值运算符。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（N）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">恒定</font><i><font style="vertical-align: inherit;">RVO</font></i><font style="vertical-align: inherit;">是一个比较滑的话题。直到C ++ 14包括在内，对此一无所知，C ++ 17 </font><font style="vertical-align: inherit;">在此类表达式中</font><font style="vertical-align: inherit;">要求使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，而即将发布的C ++ 20禁止使用。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关于位移的语义的几句话。</font><font style="vertical-align: inherit;">首先，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（N）RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仍然更有效，因为 </font><font style="vertical-align: inherit;">无需调用move构造函数和析构函数。</font><font style="vertical-align: inherit;">其次，如果不是</font></font><code>result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从同一个函数返回</font></font><code>std::move(result)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而是</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保证</font><i><font style="vertical-align: inherit;">NRVO</font></i><font style="vertical-align: inherit;">不起作用。</font><font style="vertical-align: inherit;">释义标准：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">适用于prvalue，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NRVO适用</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">于lvalue，a </font></font><code>std::move(result)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为xvalue。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阅读更多：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一种（英语）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">两种（英语）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">三种（英语）</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> FINAE </font></font><a name="SFINAE"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">替换失败不是错误。</font><font style="vertical-align: inherit;">替换失败不是错误。</font></font></i> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SFINAE</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是C ++中模板（函数和类）的实例化过程的功能。</font><font style="vertical-align: inherit;">底线是，如果无法实例化某个模板，则在存在其他选项的情况下，这不会被视为错误。</font><font style="vertical-align: inherit;">例如，用于选择最合适的函数重载的简化算法如下所示：</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数的名称已解析-编译器在所有考虑的名称空间中搜索具有给定名称的所有函数（请参见</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ADL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 不适当的函数将被丢弃-而不是参数的数量，没有必要对参数类型进行转换，无法为函数模板派生类型，等等。 </font></font></li><li>          (viable functions),          .           —     . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SFINAE</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发生在第二步中：如果通过实例化函数模板获得重载，但是编译器无法推断函数签名的类型，则该重载不被视为错误，而是被静默丢弃（即使没有警告）。</font><font style="vertical-align: inherit;">对于班级也是如此。</font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SFINAE</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可用于许多用途，例如，用于计数初始化列表的长度或用于计数数字中的位。</font><font style="vertical-align: inherit;">但是最常见的是，在它的帮助下，至少会模拟反射，即确定类是否具有带有特定签名的方法。</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例子</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;type_traits&gt; #include &lt;utility&gt; template &lt;class, class = void&gt; struct HasToString : std::false_type {}; //    ,      //   -    ,  //     —  ,    ,   template &lt;class T&gt; struct HasToString&lt;T, std::void_t&lt;decltype(&amp;T::toString)&gt;&gt; : std::is_same&lt;std::string, decltype(std::declval&lt;T&gt;().toString())&gt; {}; struct Foo { std::string toString() { return {}; } }; int main() { std::cout &lt;&lt; HasToString&lt;Foo&gt;::value &lt;&lt; std::endl; // 1 std::cout &lt;&lt; HasToString&lt;int&gt;::value &lt;&lt; std::endl; // 0 }</span></span></span></span></code> </pre> </div></div><br><font style="vertical-align: inherit;"></font><code>static if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在某些情况下</font><font style="vertical-align: inherit;">，C ++ 17中出现的内容</font><font style="vertical-align: inherit;">可能会取代</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SFINAE</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，而C ++ 20中预期的概念几乎将使它变得不必要。</font><font style="vertical-align: inherit;">让我们看看。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阅读更多：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一名（俄语）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">两名（英语）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">三名（英语）</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SBO，SOO，SSO </font></font><a name="SBO"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小缓冲区/对象/字符串优化。</font><font style="vertical-align: inherit;">优化小缓冲区/对象/行。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有时，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在“小型优化”的含义中</font><i><font style="vertical-align: inherit;">使用</font></i><font style="vertical-align: inherit;">，但很少使用，因此我们假定</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与字符串有关。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SBO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SOO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只是同义词，而</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是最著名的特例。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当然，所有使用动态内存的数据结构在堆栈上也一定占有一席之地。</font><font style="vertical-align: inherit;">至少是为了存储指向一堆的指针。</font><font style="vertical-align: inherit;">这些优化的本质不是要从堆中请求相对较小的对象（相对昂贵）的内存，而是将它们放置在已分配的堆栈空间中。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例如，std :: string可以这样实现：</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例子</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* begin_; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size_; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> capacity_; };</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 此类的大小，我得到24个字节（取决于编译器和平台）。 </font></font>即<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">长度不超过24个字符的字符串可以放在堆栈中。</font><font style="vertical-align: inherit;">实际上，实际上，直到24天，因为必须以某种方式区分堆栈上和堆上的放置。</font><font style="vertical-align: inherit;">但是，以下是最短的方法，用于短行最多8个字符（相同大小-24字节）：</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例子</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> Buffer { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* begin_; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> local_[<span class="hljs-number"><span class="hljs-number">8</span></span>]; }; Buffer buffer_; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> _size; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> _capacity; };</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">除了在堆上缺乏分配之外，还有另一个优点-高度的数据局部性。</font><font style="vertical-align: inherit;">这样的优化对象的数组或向量实际上只会占用连续的内存。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">几乎所有的实现都</font></font><code>std::string</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并且至少有一些实现</font></font><code>std::function</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">但是它</font></font><code>std::vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从来没有以这种方式进行优化，因为该标准要求</font></font><code>std::swap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于两个向量，它不会导致其元素的复制或分配，并且所有有效的迭代器均保持有效。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SBO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不允许满足这些要求（因为</font></font><code>std::string</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它们不是）。</font><font style="vertical-align: inherit;">但是</font></font><code>boost::container::small_vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，您可能会猜到使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SBO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阅读更多：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">时间（英语）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">两个</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> UDPATE </font></font><a name="Update"></a></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">感谢</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PyerK</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提供此附加的缩写列表。</font></font><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 简历 </font></font><a name="CV"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">限定符，例如const和volatile。</font></font></i> <code>const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">意味着该对象/变量不能被修改，尝试这样做将导致在编译时或</font><font style="vertical-align: inherit;">运行时</font><font style="vertical-align: inherit;">在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UB</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中</font><font style="vertical-align: inherit;">导致错误</font><font style="vertical-align: inherit;">。</font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">意味着对象/变量可以更改，而与程序的操作无关（例如，某些微控制器将某些内容填充到内存中），并且编译器不应优化对其的访问。</font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不通过</font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">链接或指针</font><font style="vertical-align: inherit;">访问</font><font style="vertical-align: inherit;">对象</font><font style="vertical-align: inherit;">也会导致</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UB</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阅读更多：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一（俄语）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">两（英语）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">三（俄语）</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LTO </font></font><a name="LTO"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">链接时间优化。</font><font style="vertical-align: inherit;">链接优化。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">顾名思义，这种优化发生在链接期间，即在编译之后。</font><font style="vertical-align: inherit;">链接器可以执行编译器不敢执行的操作：内联一些函数，丢弃未使用的代码和数据。</font><font style="vertical-align: inherit;">当然，增加链接时间。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阅读更多：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">时间（英语）</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PCH </font></font><a name="PCH"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">预编译的标题。</font><font style="vertical-align: inherit;">预编译的头文件。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">经常使用但很少修改的头文件会被编译一次并以内部编译器格式保存。</font><font style="vertical-align: inherit;">因此，重新组装项目将花费更少的时间，有时甚至更少。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了解更多：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">时间（前）</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pgo </font></font><a name="PGO"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配置文件引导的优化。</font><font style="vertical-align: inherit;">根据分析结果进行优化。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是一种程序优化方法，但不是通过静态代码分析，而是通过测试程序启动和收集实际统计信息。</font><font style="vertical-align: inherit;">例如，可以优化以这种方式分支和调用虚拟函数。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了解更多：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">时间（前）</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seh / veh </font></font><a name="SEH"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结构化/矢量化异常处理。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是用于异常和错误处理的MSVC扩展。</font><font style="vertical-align: inherit;">不同于标准的</font></font><code>try-catch</code> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SEH</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用其自己的关键字：</font></font><code>__try</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>__except</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>__finally</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，抓住和处理不明确抛出的异常，这样的事情作为访问一个无效的内存堆栈溢出由于无限递归调用纯虚函数，等等</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VEH</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它不会显式捕获每个错误，但是会创建一个全局的错误处理程序链。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阅读更多：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">时间（英语）</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tmp </font></font><a name="TMP"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模板元编程。</font><font style="vertical-align: inherit;">模板元编程。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">元编程是指一个程序由于其工作而创建另一个程序。</font><font style="vertical-align: inherit;">C ++中的模板实现了这种元编程。</font><font style="vertical-align: inherit;">模板编译器生成所需数量的类或函数。</font><font style="vertical-align: inherit;">众所周知，</font><font style="vertical-align: inherit;">C ++ </font><font style="vertical-align: inherit;">中的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TMP</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是图灵完备的，即可以在其上实现任何功能。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了解更多：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">时间（前）</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 弗拉 </font></font><a name="VLA"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可变长度数组。</font><font style="vertical-align: inherit;">可变长度的数组。</font></font></i> 即<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在编译时长度未知的数组： </font></font><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[n]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++标准不允许这样做。</font><font style="vertical-align: inherit;">这有点奇怪，因为它们自C99标准以来就存在于纯C语言中。</font><font style="vertical-align: inherit;">并且被某些C ++编译器支持作为扩展。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了解更多：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">时间（前）</font></font></a> <br><br><h2> 聚苯乙烯 </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果我错过了某件事或在某个地方弄错了-在评论中写。</font><font style="vertical-align: inherit;">请记住，这里只列出了与C ++直接相关的缩写。</font><font style="vertical-align: inherit;">对于其他人（但同样有用），将有一个单独的帖子。</font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第二部分</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN470265/">https://habr.com/ru/post/zh-CN470265/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN470247/index.html">RESHI.RU-机器人解决并解释数学中的学校课文问题</a></li>
<li><a href="../zh-CN470251/index.html">我如何在Flutter上做桌面应用程序（+奖金）</a></li>
<li><a href="../zh-CN470255/index.html">使用ALGLIB优化债券投资组合</a></li>
<li><a href="../zh-CN470257/index.html">Java中的ImmutableList周围的伪装</a></li>
<li><a href="../zh-CN470259/index.html">搜索中的Aimybox：用于创建语音助手的框架需要iOS向导</a></li>
<li><a href="../zh-CN470267/index.html">认证温度监控</a></li>
<li><a href="../zh-CN470271/index.html">F＃6：元组</a></li>
<li><a href="../zh-CN470273/index.html">F＃7：记录</a></li>
<li><a href="../zh-CN470275/index.html">F＃8：歧视工会</a></li>
<li><a href="../zh-CN470277/index.html">俄罗斯联邦的全球网络是如何组织和组织的？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>