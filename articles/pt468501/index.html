<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§òüèª üçú ‚ûñ Como eu criei um filtro que n√£o corrompe a imagem mesmo depois de um milh√£o de execu√ß√µes üçü üö¥üèø üë≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Depois de concluir a cria√ß√£o da arquitetura da web para o nosso novo quadrinho na web Meow the Infinite , decidi que era hora de escrever alguns artig...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como eu criei um filtro que n√£o corrompe a imagem mesmo depois de um milh√£o de execu√ß√µes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468501/">  Depois de concluir a cria√ß√£o da arquitetura da web para o nosso novo quadrinho na web <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Meow the Infinite</a> , decidi que era hora de escrever alguns artigos t√©cnicos h√° muito esperados.  Este artigo se concentrar√° em um filtro que desenvolvi h√° v√°rios anos.  Nunca foi discutido no campo da compress√£o de v√≠deo, embora me pare√ßa que vale a pena fazer. <br><br>  Em 2011, desenvolvi o ‚Äúfiltro half-pel‚Äù.  Esse √© um tipo especial de filtro que obt√©m uma imagem recebida e mostra de maneira mais convincente a apar√™ncia da imagem quando deslocada <i>exatamente meio pixel</i> . <br><br>  Voc√™ provavelmente est√° se perguntando por que esse filtro pode ser necess√°rio.  De fato, eles s√£o bastante comuns em codecs de v√≠deo modernos.  Os codecs de v√≠deo usam filtros semelhantes para pegar fragmentos de quadros anteriores e us√°-los em quadros subsequentes.  Os codecs mais antigos moviam os dados do quadro apenas um pixel inteiro de cada vez, mas os novos codecs foram al√©m e permitiram um deslocamento de meio ou at√© um quarto de pixel para transmitir melhor pequenos movimentos. <br><br>  Ao analisar o comportamento dos algoritmos de compensa√ß√£o de movimento nos filtros tradicionais de meio-p√©l, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Jeff Roberts</a> descobriu que, quando aplicados repetidamente em quadros seq√ºenciais, eles se degradam rapidamente, for√ßando outras partes do compressor de v√≠deo a usar mais dados do que o necess√°rio para corrigir artefatos.  Se voc√™ desabilitar essas corre√ß√µes e observar os resultados "brutos" do filtro halfpel, esta √© a imagem original: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br>  vira isso: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a3/3f7/605/2a33f7605ba0b5456d11881f24be8226.png" width="1000" height="284"></div><br>  apenas um segundo depois o v√≠deo.  Como deveria, √© deslocado para o lado, porque cada quadro mudou a imagem em meio pixel.  Mas o resultado n√£o parece uma vers√£o deslocada da imagem original, est√° seriamente distorcido. <br><a name="habracut"></a><br>  Durante o filtro "um segundo v√≠deo", na verdade, √© aplicado v√°rias vezes - 60 se o v√≠deo for reproduzido com uma frequ√™ncia de 60 quadros por segundo.  Mas, idealmente, precisamos de filtros resistentes a essas distor√ß√µes.  Se os tiv√©ssemos, os v√≠deos com rolagem suave n√£o teriam sido codificados com tantas corre√ß√µes de artefatos, o que os tornaria menos, ou melhores, ou ambos. <br><br>  Se voc√™ conhece o campo da compacta√ß√£o de v√≠deo, pode se perguntar por que precisamos usar o filtro halfpel mais de uma vez.  No final, se aplicarmos o filtro halfpel duas vezes, j√° moveremos um pixel inteiro. Ent√£o, por que n√£o usar os dados de <i>dois</i> quadros atr√°s e lev√°- <i>los</i> ? <br><br>  A resposta n√£o √© t√£o simples.  Primeiro, quanto mais dados precisarmos codificar, menor ser√° a compacta√ß√£o.  Portanto, se come√ßarmos a codificar sem a necessidade de muitos dados, como "a partir de qual quadro coletar dados", o v√≠deo n√£o ser√° compactado muito bem. <br><br>  Mas isso n√£o √© o mais importante.  O principal problema √© que, se precisarmos obter informa√ß√µes de quadros anteriores, teremos <i>que armazen√°-los</i> .  Para preservar os dois quadros anteriores, em vez de um, voc√™ precisa adivinhar que possui duas vezes mais mem√≥ria.  Para CPUs modernas, esse n√£o √© um problema especial, eles t√™m muita mem√≥ria e essa ninharia n√£o os incomoda.  Mas isso √© um <i>problema</i> para voc√™, se voc√™ deseja criar um formato de v√≠deo r√°pido, port√°til e amplamente usado, que funcione em dispositivos com pouca mem√≥ria (telefones celulares, eletr√¥nicos embutidos etc.). <br><br>  Realmente n√£o queremos armazenar v√°rios quadros para compensar o movimento, apenas para n√£o usar um filtro de meio fotorreceptor.  Portanto, fui instru√≠do a descobrir o que exatamente est√° acontecendo aqui e a descobrir se posso criar um filtro que n√£o tenha esses problemas. <br><br>  Antes disso, eu nunca havia trabalhado com filtros e n√£o tinha ideia de como eles geralmente s√£o desenvolvidos.  Curiosamente, acabou sendo a meu favor, porque eu tive que olhar para esse problema sem preconceitos. <br><br><h2>  O b√°sico </h2><br>  Eu rapidamente percebi que os filtros halfpel mais populares t√™m uma estrutura semelhante: para cada pixel na imagem de sa√≠da, s√£o capturados 2 a 8 pixels da imagem de entrada, que s√£o amostrados e misturados com certos coeficientes.  Os filtros diferentes diferem apenas no n√∫mero de pixels de origem amostrados (geralmente no jarg√£o dos desenvolvedores de filtros, chamados de torneira) e nos fatores de mistura de pixels.  Esses coeficientes s√£o frequentemente chamados de "n√∫cleo do filtro" e √© tudo o que √© necess√°rio para descrever completamente o filtro. <br><br>  Se voc√™ estiver familiarizado com qualquer tipo de amostragem ou reamostragem de imagens (por exemplo, dimensionamento de imagens), isso deve ficar claro para voc√™.  Essencialmente, os filtros fazem a mesma coisa.  Como a compacta√ß√£o de v√≠deo √© uma vasta √°rea na qual v√°rios estudos s√£o realizados, √© √≥bvio que existem muitas <i>outras</i> maneiras de compensar o movimento, al√©m da simples filtragem.  Por√©m, codecs comuns geralmente usam procedimentos de compensa√ß√£o de movimento com filtros de meio-p√©l, que s√£o essencialmente id√™nticos aos filtros de escala de imagem: eles apenas pegam os pixels originais, multiplicam-nos por alguns pesos, adicionam-nos e obt√™m os pixels de sa√≠da. <br><br><h2>  A necessidade de "nitidez" </h2><br>  Ent√£o, precisamos mudar a imagem em meio pixel.  Se voc√™ √© um programador gr√°fico, mas n√£o est√° familiarizado com a filtragem, pode pensar: "Eu tamb√©m tenho um problema, basta usar um filtro bilinear".  Este √© um processo padr√£o no trabalho com gr√°ficos, quando precisamos calcular valores intermedi√°rios entre dois elementos de dados recebidos, como acontece aqui. <br><br>  Um filtro bilinear para mover exatamente meio pixel pode ser facilmente descrito pelo seguinte n√∫cleo de filtro: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// NOTE(casey): Simple bilinear filter BilinearKernel[] = {1.0/2.0, 1.0/2.0};</span></span></code> </pre> <br>  Isso vai funcionar, mas n√£o sem problemas.  Se o seu objetivo √© imagens de alta qualidade e, no caso de compacta√ß√£o de v√≠deo, o objetivo √© exatamente isso, ent√£o um filtro bilinear n√£o √© a melhor solu√ß√£o, porque adiciona mais desfoque ao resultado do que o necess√°rio.  N√£o √© <i>tanto</i> , mas <i>mais do</i> que outros filtros criam. <br><br>  Para mostrar isso claramente, eis uma imagem aproximada do olho da morsa a partir da imagem original ap√≥s uma √∫nica aplica√ß√£o dos filtros mais comuns: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b0/97d/17e/1b097d17ed0bf71252e43527442a852b.png" width="670" height="140"></div><br>  √Ä esquerda est√° o original, √† direita h√° filtragem bilinear.  Entre eles est√£o os filtros halfpel mais usados ‚Äã‚Äãde codecs de v√≠deo.  Se voc√™ observar atentamente, poder√° ver que quase todas as imagens s√£o semelhantes, <i>exceto uma</i> bilinear, que √© um pouco mais desfocada.  Embora n√£o haja muito desfoque, se o seu objetivo principal √© a qualidade da imagem, isso √© suficiente para preferir um filtro diferente a um filtro bilinear. <br><br>  Ent√£o, como outros filtros ‚Äúmant√™m‚Äù a nitidez e evitam a desfocagem?  Vamos lembrar como √© o n√∫cleo do desfoque bilinear: <br><br><pre> <code class="cpp hljs">BilinearKernel[] = {<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">2.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">2.0</span></span>};</code> </pre> <br>  √â muito simples  Para mudar a imagem em meio pixel, pegamos um pixel e o misturamos 50% com o vizinho.  Isso √© tudo.  Pode-se imaginar como isso ‚Äúdesfoca‚Äù a imagem, porque nos locais em que o pixel branco brilhante √© adjacente ao preto escuro, esses dois pixels s√£o calculados em m√©dia durante a filtragem bilinear, criando um pixel cinza que ‚Äúsuaviza‚Äù a borda.  Isso acontece com todos os pixels, portanto, literalmente, todas as √°reas em que h√° uma clara diferen√ßa de cor ou brilho.  suavizado. <br><br>  √â por isso que, nos codecs de alta qualidade, a filtragem bilinear n√£o √© usada para compensa√ß√£o de movimento (embora possa ser usada em outros casos).  Em vez disso, s√£o usados ‚Äã‚Äãfiltros que preservam a nitidez, por exemplo, como: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// NOTE(casey): Half-pel filters for the industry-standard h.264 and HEVC video codecs h264Kernel[] = {1.0/32.0, -5.0/32.0, 20.0/32.0, 20.0/32.0, -5.0/32.0, 1.0/32.0}; HEVCKernel[] = {-1.0/64.0, 4.0/64.0, -11.0/64.0, 40.0/64.0, 40/64.0, -11.0/64.0, 4.0/64.0, -1.0/64.0};</span></span></code> </pre> <br>  Como voc√™ pode ver, onde a filtragem bilinear levou em considera√ß√£o apenas dois pixels, esses filtros levaram em considera√ß√£o seis (h.264) ou at√© oito (HEVC).  Al√©m disso, eles n√£o apenas calculam os valores m√©dios ponderados usuais desses pixels, mas usam pesos <i>negativos</i> para alguns pixels para <i>subtrair</i> esses pixels de outros valores. <br><br>  Por que eles est√£o fazendo isso? <br><br>  Na verdade, n√£o √© dif√≠cil entender isso: usando valores positivos e negativos e tamb√©m considerando uma "janela" mais ampla, o filtro pode levar em considera√ß√£o a <i>diferen√ßa</i> entre os pixels adjacentes e simular a nitidez dos dois pixels mais pr√≥ximos em rela√ß√£o aos vizinhos mais distantes.  Isso permite manter a nitidez do resultado da imagem nos locais em que os pixels diferem significativamente de seus vizinhos, enquanto a m√©dia ainda √© usada para criar valores confi√°veis ‚Äã‚Äãde trocas de "meio pixel", que necessariamente refletem a combina√ß√£o de pixels da imagem recebida. <br><br><h2>  Filtragem inst√°vel </h2><br>  Ent√£o, o problema foi resolvido?  Sim, √© poss√≠vel, mas se voc√™ precisar fazer apenas um deslocamento de meio pixel.  No entanto, esses filtros de "nitidez" (e eu uso esse termo aqui intencionalmente) realmente fazem algo perigoso, <i>essencialmente semelhante</i> ao que a filtragem bilinear faz.  Eles apenas sabem como esconder isso. <br><br>  Onde a filtragem bilinear <i>reduz a</i> nitidez da imagem, esses filtros padr√£o <i>aumentam</i> , como a opera√ß√£o de nitidez em alguns programas gr√°ficos.  A quantidade de nitidez √© muito pequena; portanto, se executarmos o filtro apenas uma vez, n√£o perceberemos isso.  Mas se a filtragem for realizada v√°rias vezes, isso poder√° se tornar muito percept√≠vel. <br><br>  E, infelizmente, como essa nitidez √© processual e depende da diferen√ßa entre os pixels, <i>cria um loop de feedback</i> que continuar√° a afiar a mesma borda repetidamente at√© destruir a imagem.  Voc√™ pode mostrar isso com exemplos espec√≠ficos. <br><br>  Acima - a imagem original, abaixo - com filtragem bilinear, executou mais de 60 quadros: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/346/0d9/d18/3460d9d18c2e74e79980d1ead799d7c4.png" width="1000" height="284"></div><br>  Como seria de esperar, o desfoque simplesmente continua a reduzir a nitidez da imagem at√© que ela fique bastante emba√ßada.  Agora, o original estar√° na parte superior e o filtro de halfpel do codec h.264 que ser√° executado por 60 quadros na parte inferior: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a3/3f7/605/2a33f7605ba0b5456d11881f24be8226.png" width="1000" height="284"></div><br>  Est√° vendo todo esse lixo?  O filtro fez o mesmo que o efeito de "desfoque" da filtragem bilinear, mas <i>vice-versa</i> - "aumentou a nitidez da imagem", de modo que todas as partes em que os detalhes foram transformados em padr√µes claros / escuros fortemente distorcidos. <br><br>  O codec HEVC usando 8 pixels se comporta melhor?  Bem, definitivamente faz melhor que h.264: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/337/309/98e/33730998e411bb57ad5e38bb835cf7e1.png" width="1000" height="284"></div><br>  mas se aumentarmos o tempo de 60 quadros (1 segundo) para 120 quadros (2 segundos), ainda veremos que h√° feedback e a imagem √© destru√≠da: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95c/672/b35/95c672b35482ac260a4ed0bbf10d7833.png" width="1000" height="284"></div><br>  Para quem gosta de processamento de sinal, adicionarei um filtro com janela sinc (chamado filtro Lanczos) para refer√™ncia: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// NOTE(casey): Traditional 6-tap Lanczos filter LanczosKernel[] = {0.02446, -0.13587, 0.61141, 0.61141, -0.13587, 0.02446};</span></span></code> </pre> <br>  N√£o explicarei neste artigo por que algu√©m pode estar interessado em "janela sinc", mas basta dizer que esse filtro √© popular por raz√µes te√≥ricas; portanto, veja como fica ao processar 60 quadros (1 segundo): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a46/5ce/35c/a465ce35c2009cc7cfd8ebfc2959748c.png" width="1000" height="284"></div><br>  e ao processar 120 quadros (2 segundos): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b8/f55/da5/3b8f55da553059f6639982098c75f148.png" width="1000" height="284"></div><br>  Melhor que o h.264 e quase o mesmo que o HEVC. <br><br><h2>  Filtragem est√°vel </h2><br>  Como podemos obter melhores resultados do que h.264, HEVC e window window sinc?  E quanto melhor eles podem ser? <br><br>  Eu <i>esperava</i> ver perguntas semelhantes na literatura sobre compacta√ß√£o de v√≠deo e elas deveriam ser bem conhecidas dos especialistas em compacta√ß√£o, mas, de fato (pelo menos para 2011), n√£o encontrei ningu√©m que ao menos afirmasse que isso era um problema.  Ent√£o eu tive que encontrar uma solu√ß√£o sozinha. <br><br>  Felizmente, a declara√ß√£o do problema √© muito simples: crie um filtro que possa ser aplicado tantas vezes quanto poss√≠vel, para que a imagem pare√ßa a mesma do in√≠cio. <br><br>  Eu chamo essa defini√ß√£o de "filtragem est√°vel" porque, na minha opini√£o, ela pode ser considerada uma propriedade de filtro.  Um filtro √© "est√°vel" se n√£o cair em seu loop de feedback, ou seja, pode ser aplicado repetidamente sem criar artefatos.  Um filtro √© "inst√°vel" se ele cria artefatos que s√£o amplificados pelo uso repetido e eventualmente destr√≥i a imagem. <br><br>  Repito, n√£o entendo por que esse t√≥pico n√£o √© considerado na literatura sobre codecs de v√≠deo ou processamento de imagens.  Talvez ele use uma terminologia diferente, mas eu n√£o a conheci.  O conceito de "feedback" est√° bem estabelecido no campo do trabalho com som.  mas n√£o √© uma quest√£o importante no processamento de imagens.  Talvez porque geralmente os filtros devam ser aplicados apenas uma vez? <br><br>  Se eu fosse um especialista nesse campo, provavelmente teria uma opini√£o sobre esse assunto, e talvez eu conhecesse aqueles recantos de literatura especializada onde j√° existem solu√ß√µes para esse problema, conhecidas por poucos.  Mas, como eu disse no come√ßo do artigo, nunca tinha conseguido criar filtros antes, ent√£o procurei apenas em artigos conhecidos (embora valha a pena notar que h√° pelo menos uma pessoa conhecida na literatura que tamb√©m n√£o ouviu nada parecido com isso ) <br><br>  Ent√£o, pela manh√£, eles me disseram que precis√°vamos desse filtro e durante todo o dia tentei cri√°-lo.  Minha abordagem foi simples: criei um programa que executou o filtro centenas de vezes e, no final, produzi uma imagem para que eu pudesse ver o resultado de execu√ß√µes longas.  Depois experimentei diferentes coeficientes de filtro e observei os resultados.  Era literalmente um processo direcional de tentativa e erro. <br><br>  Cerca de uma hora depois, peguei os melhores coeficientes de filtro adequados para esta tarefa (mas eles tinham uma falha, que discutirei na segunda parte do artigo): <br><br><pre> <code class="cpp hljs">MyKernel[] = {<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">-4.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">19.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">19.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">-4.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>};</code> </pre> <br>  Este n√∫cleo est√° √† beira de afiar e desfocar.  Como a nitidez sempre leva a um feedback que cria artefatos v√≠vidos e √≥bvios, esse n√∫cleo do filtro prefere um pouco de desfoque, de modo que a imagem pare√ßa um pouco mais "opaca". <br><br>  √â assim que ele cuida de 60 quadros.  Para refer√™ncia, mostrei todos os filtros nesta ordem: a imagem original (sem filtragem), meu filtro, bilinear, Lanczos, h.264, HEVC: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc8/c7e/cd1/fc8c7ecd131c285b080ca8c6375c66b5.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/346/0d9/d18/3460d9d18c2e74e79980d1ead799d7c4.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a46/5ce/35c/a465ce35c2009cc7cfd8ebfc2959748c.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a3/3f7/605/2a33f7605ba0b5456d11881f24be8226.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/337/309/98e/33730998e411bb57ad5e38bb835cf7e1.png" width="1000" height="284"></div><br>  Como voc√™ pode ver, meu filtro fornece resultados um pouco mais emba√ßados do que os filtros de nitidez, mas n√£o possui artefatos de nitidez inaceit√°veis ‚Äã‚Äãap√≥s 60 quadros.  No entanto, voc√™ pode preferir artefatos de desfoque a objetos de nitidez, para escolher entre o melhor filtro de nitidez (Lanczos) e o meu.  No entanto, se aumentarmos o n√∫mero para 120 quadros, meu filtro estar√° fora de competi√ß√£o: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44a/a48/c5e/44aa48c5ef416f191097379547061625.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a13/3a5/f66/a133a5f66fa5ddd6d5a9073a23f02b2e.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b8/f55/da5/3b8f55da553059f6639982098c75f148.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/410/92a/849/41092a8499f2ea7beab529cdeca274bc.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95c/672/b35/95c672b35482ac260a4ed0bbf10d7833.png" width="1000" height="284"></div><br>  Ap√≥s 300 quadros, todos os filtros, exceto o meu, tornam-se uma piada de mau gosto: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d2/1ca/007/2d21ca007ccba46c3a9427dd767d6fb7.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/816/ca3/619/816ca36196d48266af8218a585744068.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de4/45d/377/de445d3777d9d35e988585af3f83581f.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c5/0e4/31f/5c50e431ff7a624e078fe95479cafbe2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d9/ac8/5b7/8d9ac85b768064dfaacd5bdb8019b8c5.png" width="1000" height="284"></div><br>  Depois de 600 quadros, a piada se torna ainda mais cruel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f23/69e/d51/f2369ed51c63439be8c3281c706e10d7.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/344/544/b61/344544b6152756bcdce564d58ee61cc0.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/536/25d/943/53625d9435b36876edf087a753a63c61.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/55d/32c/66a/55d32c66a716e40c2826bd5150e3e34f.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f5/b92/c95/4f5b92c95825178ca0ce82320c37a2bc.png" width="1000" height="284"></div><br>  Voc√™ nem precisa dizer o que acontece depois de 900 quadros: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09c/46f/617/09c46f617c7dfe04b5cb7e7c1010ba62.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1c/f58/7a4/b1cf587a4ceea34f13f97bece1f70a07.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/271/860/34d/27186034d68d111643b325559a3d5b13.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f9d/ac6/d55/f9dac6d551ef448f6b8a042a43af17b6.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/32e/742/9dd/32e7429dd6fa7f0d704f40d28e92e0dc.png" width="1000" height="284"></div><br><h2>  Qu√£o est√°vel √© isso? </h2><br>  Nesse est√°gio, ele naturalmente se perguntar√°: meu filtro √© <i>realmente</i> est√°vel ou √© apenas um borr√£o muito lento, muito mais lento que a filtragem bilinear?  Talvez depois de milhares de repeti√ß√µes, meu filtro desfoque <i>gradualmente</i> a imagem? <br><br>  Surpreendentemente, a resposta parece ser negativa.  Embora um pouco de desfoque seja adicionado ao longo de cerca de cem das primeiras sobreposi√ß√µes, parece que o filtro <i>converge</i> para uma representa√ß√£o est√°vel da imagem, que <i>nunca √©</i> degradada.  Aqui est√° outra imagem ampliada de um olho de morsa: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e4a/26d/19f/e4a26d19f9ba6142ab7c45aeaea765ec.png" width="768" height="128"></div><br>  Da esquerda para a direita: a imagem original, meu filtro foi aplicado 60 vezes, 120 vezes, 300 vezes, 600 e 900 vezes.  Como voc√™ pode ver, o desfoque converge para um estado est√°vel, que n√£o √© mais degradado, mesmo depois de centenas de sobreposi√ß√µes de filtro.  Por outro lado, compare isso com a sincroniza√ß√£o em janelas para o mesmo n√∫mero de amostras (toque) e veja o qu√£o ruim (e r√°pido!) Os artefatos formam o feedback e criam um resultado in√∫til: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/122/2ff/2f2/1222ff2f2fe380cfab03df453f06ce2f.png" width="768" height="128"></div><br>  Meu filtro parece muito est√°vel e, comparado a todos os filtros que vi, cria os melhores resultados ap√≥s o uso repetido.  Parece que possui uma certa propriedade "assint√≥tica", na qual os dados convergem rapidamente para uma imagem suavizada (limitada) e, em seguida, essa imagem suavizada √© salva e n√£o executa degrada√ß√£o ilimitada para concluir o lixo. <br><br>  Eu at√© tentei aplicar o filtro um <i>milh√£o de</i> vezes, e parece que, ap√≥s as primeiras centenas de sobreposi√ß√µes, ele n√£o se deteriora mais.  Sem uma an√°lise matem√°tica melhor (e ainda n√£o encontrei uma solu√ß√£o matem√°tica que possa prov√°-la exatamente, mas sei com certeza que est√° em algum lugar), n√£o posso dizer com certeza que em algum lugar ap√≥s bilh√µes ou trilh√µes de sobreposi√ß√µes que -n√£o vai quebrar.  Em testes razo√°veis, n√£o consegui detectar mais degrada√ß√£o. <br><br><h2>  √â o melhor filtro Halfpel est√°vel para seis torneiras? </h2><br>  Nesse est√°gio, seria l√≥gico fazer a pergunta: isso √© realmente o melhor que pode ser encontrado?  A intui√ß√£o nos diz que n√£o, porque eu n√£o tinha absolutamente nenhum conhecimento sobre o desenvolvimento de filtros e quase n√£o olhei na literatura, peguei esse filtro em apenas uma hora.  Pelo menos, pode-se <i>supor</i> que, depois de um estudo t√£o breve, eu n√£o encontraria um filtro definitivo com a melhor conquista de todos. <br><br>  Essa suposi√ß√£o √© verdadeira?  E se for verdade, <i>qual</i> ser√° o melhor filtro final?  Vou discutir isso em mais detalhes na segunda parte do artigo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt468501/">https://habr.com/ru/post/pt468501/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt468487/index.html">O que pode acontecer (vetores de ataque t√≠picos)</a></li>
<li><a href="../pt468489/index.html">Contrabando de solicita√ß√£o HTTP - novas abordagens</a></li>
<li><a href="../pt468491/index.html">A maldi√ß√£o c√°rmica de Habra</a></li>
<li><a href="../pt468493/index.html">A estrutura da vista a√©rea do projeto Data Science</a></li>
<li><a href="../pt468497/index.html">Temporizador de escovagem com dura√ß√£o de 3 minutos</a></li>
<li><a href="../pt468503/index.html">O correio n√£o percorre mais de 500 milhas - Perguntas frequentes</a></li>
<li><a href="../pt468509/index.html">Desenvolvimento de sistema operacional Unix-like - Drivers de dispositivos de caracteres (8)</a></li>
<li><a href="../pt468511/index.html">Publicando um servidor atrav√©s de um gateway DFL da D-Link</a></li>
<li><a href="../pt468515/index.html">Dicas √∫teis para integra√ß√£o em novos projetos</a></li>
<li><a href="../pt468519/index.html">Crie uma base de c√≥digo comum</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>