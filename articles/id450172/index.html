<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙌🏼 🤾🏿 🍅 Pengatur waktu IOS 👨‍👨‍👧 🤪 🏯</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bayangkan Anda sedang mengerjakan suatu aplikasi di mana Anda perlu melakukan beberapa tindakan secara berkala. Inilah yang digunakan Swift untuk kela...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengatur waktu IOS</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450172/"> Bayangkan Anda sedang mengerjakan suatu aplikasi di mana Anda perlu melakukan beberapa tindakan secara berkala.  Inilah yang digunakan Swift untuk kelas <b>Timer</b> . <br><br>  Timer digunakan untuk merencanakan tindakan dalam aplikasi.  Ini bisa berupa tindakan satu kali atau prosedur berulang. <br><br>  Dalam panduan ini, Anda akan mempelajari cara timer bekerja di iOS, bagaimana timer dapat memengaruhi responsif UI, cara mengoptimalkan konsumsi baterai saat menggunakan timer, dan cara menggunakan <b>CADisplayLink</b> untuk animasi. <br><br>  Sebagai situs uji, kami akan menggunakan aplikasi - penjadwal tugas primitif. <br><a name="habracut"></a><br><h2>  Memulai </h2><br>  Unduh <a href="">proyek sumber.</a>  Buka di Xcode, lihat strukturnya, kompilasi dan eksekusi.  Anda akan melihat penjadwal tugas yang paling sederhana: <br><br><img src="https://habrastorage.org/webt/9v/iw/xg/9viwxg_qjy7oyvwfsss09ec813c.png"><br><br>  Tambahkan tugas baru ke sana.  Ketuk ikon +, masukkan nama tugas, ketuk Ok. <br><br>  Tugas yang ditambahkan memiliki stempel waktu.  Tugas baru yang baru saja Anda buat ditandai dengan nol detik.  Seperti yang Anda lihat, nilai ini tidak meningkat. <br><br>  Setiap tugas dapat ditandai sebagai selesai.  Ketuk tugas tersebut.  Nama tugas akan dicoret dan akan ditandai sebagai selesai. <br><br><h2>  Buat timer pertama kami </h2><br>  Mari kita buat timer utama dari aplikasi kita.  Kelas <b>Timer</b> , juga dikenal sebagai <b>NSTimer,</b> adalah cara yang nyaman untuk menjadwalkan tindakan untuk momen tertentu, baik tunggal maupun berkala. <br><br>  Buka <b>TaskListViewController.swift</b> dan tambahkan variabel ini ke <b>TaskListViewController</b> : <br><br><pre><code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> timer: <span class="hljs-type"><span class="hljs-type">Timer?</span></span></code> </pre> <br>  Kemudian tambahkan ekstensi di sana: <br><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">// MARK: - Timer extension TaskListViewController { }</span></span></code> </pre> <br>  Dan rekatkan kode ini ke dalam ekstensi: <br><br><pre> <code class="swift hljs"><span class="hljs-meta"><span class="hljs-meta">@objc</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateTimer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1 guard let visibleRowsIndexPaths = tableView.indexPathsForVisibleRows else { return } for indexPath in visibleRowsIndexPaths { // 2 if let cell = tableView.cellForRow(at: indexPath) as? TaskTableViewCell { cell.updateTime() } } }</span></span></code> </pre> <br>  Dalam metode ini, kami: <br><br><ol><li>  Periksa apakah ada baris yang terlihat di tabel tugas. </li><li>  Panggil <b>updateTime</b> untuk setiap sel yang terlihat.  Metode ini memperbarui timestamp di sel (lihat <b>TaskTableViewCell.swift</b> ). </li></ol><br>  Kemudian tambahkan kode ini ke ekstensi: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTimer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1 if timer == nil { // 2 timer = Timer.scheduledTimer(timeInterval: 1.0, target: self, selector: #selector(updateTimer), userInfo: nil, repeats: true) } }</span></span></code> </pre> <br>  Di sini kita: <br><br><ol><li>  Periksa apakah timer berisi instance kelas <b>Timer</b> . </li><li>  Jika tidak, buat pengatur waktu yang memanggil <b>updateTimer ()</b> setiap detik. </li></ol><br>  Maka kita perlu membuat timer segera setelah pengguna menambahkan tugas pertama.  Tambahkan <b>createTimer ()</b> di bagian paling awal metode <b>presentAlertController (_ :)</b> . <br><br>  Luncurkan aplikasi dan buat beberapa tugas baru.  Anda akan melihat bahwa cap waktu untuk setiap tugas berubah setiap detik. <br><br><img src="https://habrastorage.org/webt/nw/ze/nn/nwzenn61635ppptgcdsule6ywsk.gif" width="281" height="500"><br><br><h2>  Tambahkan toleransi waktu </h2><br>  Peningkatan jumlah pengatur waktu menghasilkan respons UI yang lebih buruk dan konsumsi baterai yang lebih banyak.  Setiap timer mencoba mengeksekusi tepat pada waktu yang ditentukan, karena secara default toleransinya adalah nol. <br><br>  Menambahkan toleransi waktu adalah cara mudah untuk mengurangi konsumsi energi.  Ini memungkinkan sistem untuk melakukan tindakan pengatur waktu antara waktu yang ditetapkan dan waktu yang ditetapkan <b>ditambah waktu toleransi</b> - tetapi tidak pernah sebelum interval yang ditetapkan. <br><br>  Untuk penghitung waktu yang berjalan hanya sekali, nilai toleransi diabaikan. <br><br>  Dalam metode <b>createTimer ()</b> , segera setelah penetapan waktu, tambahkan baris ini: <br><br><pre> <code class="swift hljs">timer?.tolerance = <span class="hljs-number"><span class="hljs-number">0.1</span></span></code> </pre> <br>  Luncurkan aplikasi.  Dalam kasus khusus ini, efeknya tidak akan terlihat jelas (kami hanya memiliki satu pengatur waktu), namun, dalam situasi nyata dari beberapa pengatur waktu, pengguna Anda akan mendapatkan antarmuka yang lebih responsif dan aplikasi akan lebih hemat energi. <br><br><img src="https://habrastorage.org/webt/nw/ze/nn/nwzenn61635ppptgcdsule6ywsk.gif" width="281" height="500"><br><br><h2>  Pengatur waktu di latar belakang </h2><br>  Menariknya, apa yang terjadi pada penghitung waktu saat aplikasi masuk ke latar belakang?  Untuk mengatasinya, tambahkan kode ini di bagian paling awal metode <b>updateTimer ()</b> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fireDateDescription = timer?.fireDate.description { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(fireDateDescription) }</code> </pre> <br>  Ini akan memungkinkan kita untuk melacak peristiwa penghitung waktu di konsol. <br><br>  Jalankan aplikasi, tambahkan tugas.  Sekarang tekan tombol Rumah di perangkat Anda, dan kemudian kembali ke aplikasi kami. <br><br>  Di konsol, Anda akan melihat sesuatu seperti ini: <br><br><img src="https://habrastorage.org/webt/qb/ry/dd/qbryddhdojzhiq5jp0eol00axf4.png"><br><br>  Seperti yang Anda lihat, ketika aplikasi masuk ke latar belakang, iOS menjeda semua penghitung waktu aplikasi yang berjalan.  Ketika aplikasi menjadi aktif, iOS melanjutkan penghitung waktu. <br><br><h2>  Memahami <b>Run Loops</b> </h2><br>  Run loop adalah loop acara yang menjadwalkan pekerjaan dan menangani acara yang masuk.  Siklus membuat utas sibuk saat sedang berjalan dan menempatkannya dalam kondisi "tidur" ketika tidak ada pekerjaan untuk itu. <br><br>  Setiap kali Anda meluncurkan aplikasi, sistem membuat utas utama aplikasi, setiap utas memiliki loop eksekusi yang dibuat secara otomatis untuknya. <br><br>  Tetapi mengapa semua informasi ini penting bagi Anda sekarang?  Sekarang setiap timer dimulai di utas utama dan bergabung dengan loop eksekusi.  Anda mungkin menyadari bahwa utas utama terlibat dalam rendering antarmuka pengguna, pemrosesan sentuhan, dan sebagainya.  Jika utas utama sibuk dengan sesuatu, antarmuka aplikasi Anda mungkin menjadi "tidak responsif" (hang). <br><br>  Apakah Anda memperhatikan bahwa cap waktu di sel tidak diperbarui saat Anda menyeret tampilan tabel? <br><br><img src="https://habrastorage.org/webt/og/jg/l6/ogjgl6z6livbu-shmvtszh3movq.gif" width="281" height="500"><br><br>  Anda dapat mengatasi masalah ini dengan memberi tahu siklus lari untuk memulai penghitung waktu dalam mode yang berbeda. <br><br><h2>  Memahami Mode Jalankan Siklus </h2><br>  Mode siklus eksekusi adalah serangkaian sumber input, seperti menyentuh layar atau mengklik mouse, yang dapat diatur untuk memantau dan satu set "pengamat" yang menerima pemberitahuan. <br><br>  Ada tiga mode runtime di iOS: <br><br>  <b>default</b> : sumber input yang bukan NSConnectionObjects diproses. <br>  <b>umum</b> : satu set siklus input sedang diproses, di mana Anda dapat menentukan satu set sumber input, timer, "pengamat". <br>  <b>pelacakan</b> : UI aplikasi sedang diproses. <br><br>  Untuk aplikasi kita, mode yang paling cocok adalah <b>umum</b> .  Untuk menggunakannya, ganti konten metode <b>createTimer () dengan yang</b> berikut: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> timer == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timer = <span class="hljs-type"><span class="hljs-type">Timer</span></span>(timeInterval: <span class="hljs-number"><span class="hljs-number">1.0</span></span>, target: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, selector: #selector(updateTimer), userInfo: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, repeats: <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-type"><span class="hljs-type">RunLoop</span></span>.current.add(timer, forMode: .common) timer.tolerance = <span class="hljs-number"><span class="hljs-number">0.1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.timer = timer }</code> </pre> <br>  Perbedaan utama dari kode sebelumnya adalah bahwa sebelum menetapkan timer ke TaskListViewController, kami menambahkan timer ini ke run loop dalam mode <b>umum</b> . <br><br>  Kompilasi dan jalankan aplikasi. <br><br><img src="https://habrastorage.org/webt/ya/up/xy/yaupxyslxeqpej-7kwxadnlrtzk.gif" width="281" height="500"><br><br>  Sekarang cap waktu sel diperbarui bahkan jika tabel digulir. <br><br><h2>  Tambahkan animasi untuk menyelesaikan semua tugas </h2><br>  Sekarang kami menambahkan animasi selamat untuk pengguna untuk menyelesaikan semua tugas - bola akan naik dari bagian bawah layar ke bagian paling atas. <br><br>  Tambahkan variabel-variabel ini di awal TaskListViewController: <br><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 var animationTimer: Timer? // 2 var startTime: TimeInterval?, endTime: TimeInterval? // 3 let animationDuration = 3.0 // 4 var height: CGFloat = 0</span></span></code> </pre> <br>  Tujuan dari variabel-variabel ini adalah: <br><br><ol><li>  penyimpanan pewaktu animasi. </li><li>  penyimpanan waktu awal dan akhir animasi. </li><li>  durasi animasi. </li><li>  tinggi animasi. </li></ol><br>  Sekarang tambahkan <b>ekstensi</b> TaskListViewController berikut di akhir file <b>TaskListViewController.swift</b> : <br><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">// MARK: - Animation extension TaskListViewController { func showCongratulationAnimation() { // 1 height = UIScreen.main.bounds.height + balloon.frame.size.height // 2 balloon.center = CGPoint(x: UIScreen.main.bounds.width / 2, y: height + balloon.frame.size.height / 2) balloon.isHidden = false // 3 startTime = Date().timeIntervalSince1970 endTime = animationDuration + startTime! // 4 animationTimer = Timer.scheduledTimer(withTimeInterval: 1 / 60, repeats: true) { timer in // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Animation here } } }</span></span></code> </pre> <br>  Di sini kita lakukan hal berikut: <br><br><ul><li>  menghitung ketinggian animasi, mendapatkan ketinggian layar perangkat </li><li>  pusatkan bola di luar layar dan atur visibilitasnya </li><li>  menetapkan waktu mulai dan akhir animasi </li><li>  kami memulai timer animasi dan memperbarui animasi 60 kali per detik </li></ul><br>  Sekarang kita perlu membuat logika aktual untuk memperbarui animasi ucapan selamat.  Tambahkan kode ini setelah <b>showCongratulationAnimation ()</b> : <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateAnimation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1 guard let endTime = endTime, let startTime = startTime else { return } // 2 let now = Date().timeIntervalSince1970 // 3 if now &gt;= endTime { animationTimer?.invalidate() balloon.isHidden = true } // 4 let percentage = (now - startTime) * 100 / animationDuration let y = height - ((height + balloon.frame.height / 2) / 100 * CGFloat(percentage)) // 5 balloon.center = CGPoint(x: balloon.center.x + CGFloat.random(in: -0.5...0.5), y: y) }</span></span></code> </pre> <br>  Apa yang kita lakukan: <br><br><ol><li>  periksa endTime dan startTime ditugaskan </li><li>  menghemat waktu saat ini dalam konstan </li><li>  kami memastikan bahwa waktu terakhir belum tiba.  Jika sudah tiba, perbarui timer dan sembunyikan bola kami </li><li>  hitung koordinat-y bola yang baru </li><li>  posisi horizontal bola dihitung relatif terhadap posisi sebelumnya </li></ol><br>  Sekarang ganti <b>// TODO: Animasi</b> di <b>sini</b> di <b>showCongratulationAnimation () dengan</b> kode ini: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.updateAnimation()</code> </pre> <br>  Sekarang <b>updateAnimation ()</b> dipanggil setiap kali peristiwa timer terjadi. <br><br>  Hore, kami baru saja membuat animasi.  Namun, ketika aplikasi dimulai, tidak ada yang baru terjadi ... <br><br><h2>  Menampilkan animasi </h2><br>  Seperti yang Anda duga, tidak ada yang bisa "meluncurkan" animasi baru kami.  Untuk melakukan ini, kita perlu metode lain.  Tambahkan kode ini ke <b>ekstensi</b> animasi TaskListViewController: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showCongratulationsIfNeeded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> taskList.<span class="hljs-built_in"><span class="hljs-built_in">filter</span></span>({ !$<span class="hljs-number"><span class="hljs-number">0</span></span>.completed }).<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> { showCongratulationAnimation() } }</code> </pre> <br>  Kami akan memanggil metode ini setiap kali pengguna menandai tugas selesai, ia memeriksa apakah semua tugas selesai.  Jika demikian, ia akan memanggil <b>showCongratulationAnimation ()</b> . <br><br>  Sebagai kesimpulan, tambahkan panggilan ke metode ini di akhir <b>tableView (_: didSelectRowAt :)</b> : <br><br><pre> <code class="swift hljs">showCongratulationsIfNeeded()</code> </pre> <br>  Luncurkan aplikasi, buat beberapa tugas, tandai sebagai selesai - dan Anda akan melihat animasi kami! <br><br><img src="https://habrastorage.org/webt/zz/xs/2m/zzxs2mcciespvyjwaudma_rytyi.gif" width="281" height="500"><br><br><h2>  Kami menghentikan timer </h2><br>  Jika Anda melihat konsol, Anda akan melihat bahwa, meskipun pengguna menandai semua tugas selesai, timer tetap berfungsi.  Ini sama sekali tidak berguna, jadi masuk akal untuk menghentikan timer ketika tidak diperlukan. <br><br>  Pertama, buat metode baru untuk menghentikan timer: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancelTimer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { timer?.invalidate() timer = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br>  Ini akan memperbarui timer dan meresetnya ke nol sehingga kita dapat membuatnya dengan benar lagi nanti.  <b>invalidate ()</b> adalah satu-satunya cara untuk menghapus Timer dari run loop.  Run loop akan menghapus referensi timer kuat baik segera setelah panggilan <b>tidak valid ()</b> atau sedikit kemudian. <br><br>  Sekarang ganti metode showCongratulationsIfNeeded () sebagai berikut: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showCongratulationsIfNeeded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> taskList.<span class="hljs-built_in"><span class="hljs-built_in">filter</span></span>({ !$<span class="hljs-number"><span class="hljs-number">0</span></span>.completed }).<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> { cancelTimer() showCongratulationAnimation() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { createTimer() } }</code> </pre> <br>  Sekarang, jika pengguna menyelesaikan semua tugas, aplikasi pertama-tama akan mengatur ulang timer dan kemudian menunjukkan animasi, jika tidak maka akan mencoba untuk membuat timer baru jika belum ada di sana. <br><br>  Luncurkan aplikasi. <br><br><img src="https://habrastorage.org/webt/62/l9/4-/62l94-n0gtjlg2sfpjoffjqvaom.gif" width="281" height="500"><br><br>  Sekarang penghitung waktu berhenti dan memulai kembali sebagaimana mestinya. <br><br><h2>  CADisplayLink untuk animasi yang halus </h2><br>  <b>Timer</b> bukanlah pilihan ideal untuk mengendalikan animasi.  Anda mungkin memperhatikan beberapa frame melewatkan animasi, terutama jika Anda menjalankan aplikasi dalam simulator. <br><br>  Kami mengatur timer ke 60Hz.  Dengan demikian, pengatur waktu memperbarui animasi setiap 16 ms.  Pertimbangkan situasinya lebih dekat: <br><br><img src="https://habrastorage.org/webt/ar/df/ec/ardfecmgf7bizt8ggcqa01jdbju.png"><br><br>  Saat menggunakan <b>Timer,</b> kami tidak tahu kapan tepatnya tindakan dimulai.  Ini bisa terjadi baik di awal atau di akhir bingkai.  Katakanlah timer berjalan di tengah setiap frame (titik-titik biru pada gambar).  Satu-satunya hal yang kita tahu dengan pasti adalah bahwa panggilan akan setiap 16 ms. <br><br>  Sekarang kita hanya memiliki 8 ms untuk menjalankan animasi, dan ini mungkin tidak cukup untuk animasi kita.  Mari kita lihat frame kedua pada gambar.  Bingkai kedua tidak dapat diselesaikan dalam waktu yang ditentukan, sehingga aplikasi akan mengatur ulang bingkai animasi kedua. <br><br><h2>  CADisplayLink akan membantu kami </h2><br>  <b>CADisplayLink</b> dipanggil sekali per bingkai dan mencoba menyinkronkan frame animasi nyata sebanyak mungkin.  Sekarang Anda akan memiliki semua 16 ms yang Anda inginkan dan iOS tidak akan menjatuhkan satu frame pun. <br><br>  Untuk menggunakan <b>CADisplayLink</b> , Anda perlu mengganti <b>animationTimer</b> dengan tipe baru. <br><br>  Ganti kode ini <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> animationTimer: <span class="hljs-type"><span class="hljs-type">Timer?</span></span></code> </pre> <br>  yang ini: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> displayLink: <span class="hljs-type"><span class="hljs-type">CADisplayLink?</span></span></code> </pre> <br>  Anda telah mengganti <b>Timer</b> dengan <b>CADisplayLink</b> .  <b>CADisplayLink</b> adalah tampilan penghitung waktu yang terkait dengan pemindaian vertikal tampilan.  Ini berarti bahwa GPU perangkat akan berhenti sampai layar dapat melanjutkan untuk memproses perintah GPU.  Dengan cara ini kita mendapatkan animasi yang halus. <br><br>  Ganti kode ini <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> startTime: <span class="hljs-type"><span class="hljs-type">TimeInterval?</span></span>, endTime: <span class="hljs-type"><span class="hljs-type">TimeInterval?</span></span></code> </pre> <br>  yang ini: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> startTime: <span class="hljs-type"><span class="hljs-type">CFTimeInterval?</span></span>, endTime: <span class="hljs-type"><span class="hljs-type">CFTimeInterval?</span></span></code> </pre> <br><br>  Anda mengganti <b>TimeInterval</b> dengan <b>CFTimeInterval</b> , yang diperlukan untuk bekerja dengan CADisplayLink. <br><br>  Ganti teks metode <b>showCongratulationAnimation ()</b> dengan ini: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showCongratulationAnimation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1 height = UIScreen.main.bounds.height + balloon.frame.size.height balloon.center = CGPoint(x: UIScreen.main.bounds.width / 2, y: height + balloon.frame.size.height / 2) balloon.isHidden = false // 2 startTime = CACurrentMediaTime() endTime = animationDuration + startTime! // 3 displayLink = CADisplayLink(target: self, selector: #selector(updateAnimation)) displayLink?.add(to: RunLoop.main, forMode: .common) }</span></span></code> </pre> <br>  Apa yang kita lakukan di sini: <br><br><ol><li>  Atur ketinggian animasi, koordinat bola dan visibilitas - hampir sama dengan yang mereka lakukan sebelumnya. </li><li>  Inisialisasi <b>startTime</b> dengan <b>CACurrentMediaTime ()</b> (bukan Date ()). </li><li>  Kami membuat instance dari kelas <b>CADisplayLink</b> dan menambahkannya ke run loop dalam mode <b>umum</b> . </li></ol><br>  Sekarang ganti <b>updateAnimation () dengan</b> kode berikut: <br><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 @objc func updateAnimation() { guard let endTime = endTime, let startTime = startTime else { return } // 2 let now = CACurrentMediaTime() if now &gt;= endTime { // 3 displayLink?.isPaused = true displayLink?.invalidate() balloon.isHidden = true } let percentage = (now - startTime) * 100 / animationDuration let y = height - ((height + balloon.frame.height / 2) / 100 * CGFloat(percentage)) balloon.center = CGPoint(x: balloon.center.x + CGFloat.random(in: -0.5...0.5), y: y) }</span></span></code> </pre> <br><ol><li>  Tambahkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">objc</a> ke tanda tangan metode (untuk CADisplayLink, parameter pemilih memerlukan tanda tangan seperti itu). </li><li>  Ganti inisialisasi dengan <b>Date ()</b> untuk menginisialisasi tanggal <b>CoreAnimation</b> . </li><li>  Ganti panggilan <b>animationTimer.invalidate ()</b> dengan jeda dari CADisplayLink dan batal.  Ini juga akan menghapus CADisplayLink dari run loop. </li></ol><br>  Luncurkan aplikasi! <br><br><img src="https://habrastorage.org/webt/01/ct/jf/01ctjfswyhfhc6dogl8wavqv8-a.gif" width="281" height="500"><br>  Hebat!  Kami berhasil mengganti animasi berbasis <b>Timer</b> dengan <b>CADisplayLink yang</b> lebih sesuai - dan mendapatkan animasi lebih lancar, tanpa menyentak. <br><br><h2>  Kesimpulan </h2><br>  Dalam panduan ini, Anda mengetahui bagaimana kelas <b>Timer</b> bekerja di iOS, apa siklus eksekusi itu dan bagaimana hal itu dapat membuat aplikasi Anda lebih responsif dalam hal antarmuka, dan bagaimana menggunakan <b>CADisplayLink</b> daripada Timer untuk animasi yang lancar. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id450172/">https://habr.com/ru/post/id450172/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id450160/index.html">Windows 10 versi 1903 - ruang disk minimum 32 GB</a></li>
<li><a href="../id450164/index.html">Bagaimana cara membantu tim yang terbakar di tempat kerja jika Anda sendiri kelelahan?</a></li>
<li><a href="../id450166/index.html">Kami mengundang pengembang ke Think Developers Workshop</a></li>
<li><a href="../id450168/index.html">Sejarah Internet: Backbone</a></li>
<li><a href="../id450170/index.html">AR, robotika, dan katarak: bagaimana kami pergi ke sekolah pemrograman Rusia-Jerman</a></li>
<li><a href="../id450176/index.html">Untuk pertanyaan set</a></li>
<li><a href="../id450178/index.html">Kualitas sebagai tanggung jawab tim. Pengalaman QA kami</a></li>
<li><a href="../id450180/index.html">6 alat yang berguna untuk memulai startup di AS</a></li>
<li><a href="../id450182/index.html">Pemodelan penagihan berbasis cloud</a></li>
<li><a href="../id450186/index.html">Sedikit kriptografi: Enigma yang misterius dan legendaris</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>