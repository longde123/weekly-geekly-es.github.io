<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí™üèæ üßû ‚û∞ Verificando o c√≥digo fonte de Roslyn üë§ üññüèª üßïüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De vez em quando, voltamos aos projetos que verificamos anteriormente usando o PVS-Studio, o que resulta em suas descri√ß√µes em v√°rios artigos. Duas ra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verificando o c√≥digo fonte de Roslyn</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/446588/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/833/abb/d94/833abbd94d6e48526a175b89fffc9dd5.png" alt="Roslyn vs PVS-Studio"></div><br>  De vez em quando, voltamos aos projetos que verificamos anteriormente usando o PVS-Studio, o que resulta em suas descri√ß√µes em v√°rios artigos.  Duas raz√µes tornam essas respostas emocionantes para n√≥s.  Em primeiro lugar, a oportunidade de avaliar o progresso do nosso analisador.  Em segundo lugar, monitorando o feedback dos autores do projeto em rela√ß√£o ao nosso artigo e o relat√≥rio de erros, que geralmente fornecemos a eles.  Obviamente, os erros podem ser corrigidos sem a nossa participa√ß√£o.  No entanto, √© sempre bom quando nossos esfor√ßos ajudam a melhorar um projeto.  Roslyn n√£o foi exce√ß√£o.  O artigo anterior sobre essa verifica√ß√£o do projeto data de 23 de dezembro de 2015. Ainda h√° muito tempo, considerando o progresso que nosso analisador fez desde ent√£o.  Como o n√∫cleo C # do analisador PVS-Studio √© baseado em Roslyn, isso nos d√° interesse adicional nesse projeto.  Como resultado, estamos muito interessados ‚Äã‚Äãna qualidade do c√≥digo deste projeto.  Agora vamos test√°-lo mais uma vez e descobrir alguns problemas novos e interessantes (mas espero que nada significativo) que o PVS-Studio possa encontrar. <br><a name="habracut"></a><br>  Muitos de nossos leitores provavelmente conhecem bem o Roslyn (ou .NET Compiler Platform).  Em resumo, √© um conjunto de compiladores de c√≥digo aberto e uma API para an√°lise de c√≥digo das linguagens C # e Visual Basic .NET da Microsoft.  O c√≥digo fonte do projeto est√° dispon√≠vel no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> . <br><br>  N√£o darei uma descri√ß√£o detalhada dessa plataforma e vou recomendar o artigo de meu colega Sergey Vasiliev " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Introdu√ß√£o ao Roslyn e seu uso no desenvolvimento de programas</a> " a todos os leitores interessados.  Neste artigo, voc√™ pode descobrir n√£o apenas sobre os recursos da arquitetura do Roslyn, mas como exatamente usamos essa plataforma. <br><br>  Como mencionei anteriormente, faz mais de tr√™s anos que meu colega Andrey Karpov escreveu o √∫ltimo artigo sobre a verifica√ß√£o de Roslyn " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ano Novo PVS-Studio 6.00 Release: Scanning Roslyn</a> ".  Desde ent√£o, o analisador C # PVS-Studio recebeu muitos novos recursos.  Na verdade, o artigo de Andrey era um caso de teste, pois naquele momento o analisador C # era adicionado ao PVS-Studio.  Apesar disso, conseguimos detectar erros no projeto Roslyn, que certamente era de alta qualidade.  Ent√£o, o que mudou no analisador para c√≥digo C # neste momento que nos permitir√° realizar uma an√°lise mais aprofundada? <br><br>  Desde ent√£o, o n√∫cleo e a infraestrutura v√™m se desenvolvendo.  Adicionamos suporte ao Visual Studio 2017 e Roslyn 2.0 e uma profunda integra√ß√£o com o MSBuild.  O artigo do meu colega Paul Eremeev " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Suporte do Visual Studio 2017 e Roslyn 2.0 no PVS-Studio: √†s vezes n√£o √© t√£o f√°cil usar solu√ß√µes prontas quanto parece</a> " descreve nossa abordagem para a integra√ß√£o com o MSBuild e os motivos dessa decis√£o. <br><br>  No momento, estamos trabalhando ativamente para mudar para o Roslyn 3.0 da mesma maneira que inicialmente apoiamos o Visual Studio 2017. Ele requer o uso de nosso pr√≥prio conjunto de ferramentas, inclu√≠do no distribuidor PVS-Studio como um "stub", que √© um MSBuild vazio arquivo .exe.  Apesar de parecer uma "muleta" (a API do MSBuild n√£o √© muito amig√°vel para reutilizar em projetos de terceiros devido √† baixa portabilidade das bibliotecas), essa abordagem j√° nos ajudou a superar de maneira relativamente uniforme v√°rias atualiza√ß√µes do Roslyn em termos de Visual Studio 2017. At√© agora, estava ajudando (mesmo com alguns desafios) a passar pela atualiza√ß√£o do Visual Studio 2019 e manter a compatibilidade e desempenho com vers√µes anteriores para sistemas com vers√µes mais antigas do MSBuild. <br><br>  O n√∫cleo do analisador tamb√©m passou por v√°rias melhorias.  Uma das principais caracter√≠sticas √© uma an√°lise interprocedural completa, considerando os valores dos m√©todos de entrada e sa√≠da, avaliando (dependendo desses par√¢metros) a acessibilidade dos ramos de execu√ß√£o e pontos de retorno. <br><br>  Estamos no caminho de concluir a tarefa de monitorar par√¢metros dentro dos m√©todos (por exemplo, desrefer√™ncias potencialmente perigosas), al√©m de salvar suas anota√ß√µes autom√°ticas.  Para um diagn√≥stico que utiliza o mecanismo de fluxo de dados, isso permitir√° levar em considera√ß√£o situa√ß√µes perigosas que ocorrem ao passar um par√¢metro em um m√©todo.  Antes disso, ao analisar lugares t√£o perigosos, um aviso n√£o era gerado, pois n√£o pod√≠amos saber sobre todos os poss√≠veis valores de entrada nesse m√©todo.  Agora podemos detectar o perigo, pois em todos os locais de chamada desse m√©todo, esses par√¢metros de entrada ser√£o levados em considera√ß√£o. <br><br>  Nota: voc√™ pode ler sobre mecanismos b√°sicos do analisador, como fluxo de dados e outros no artigo " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tecnologias usadas no analisador de c√≥digo PVS-Studio para encontrar erros e poss√≠veis vulnerabilidades</a> ". <br><br>  A an√°lise interprocedural no PVS-Studio C # n√£o √© limitada nem pelos par√¢metros de entrada nem pela profundidade.  A √∫nica limita√ß√£o s√£o os m√©todos virtuais nas classes, abertos √† heran√ßa e tamb√©m √† recurs√£o (a an√°lise para quando se depara com uma chamada repetida do m√©todo j√° avaliado).  Ao fazer isso, o pr√≥prio m√©todo recursivo ser√° avaliado eventualmente, assumindo que o valor de retorno de sua recurs√£o seja desconhecido. <br><br>  Outro grande recurso novo no analisador C # tornou-se levar em conta a poss√≠vel desrefer√™ncia de um ponteiro potencialmente nulo.  Antes disso, o analisador reclamou de uma poss√≠vel exce√ß√£o de refer√™ncia nula, garantindo que em todas as ramifica√ß√µes de execu√ß√£o o valor da vari√°vel seja nulo.  Obviamente, estava errado em alguns casos, por isso o diagn√≥stico do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3080</a> havia anteriormente chamado refer√™ncia nula em potencial. <br><br>  Agora, o analisador est√° ciente do fato de que a vari√°vel pode ser nula em uma das ramifica√ß√µes de execu√ß√£o (por exemplo, sob uma condi√ß√£o <i>if</i> ).  Se perceber o acesso a essa vari√°vel sem uma verifica√ß√£o, emitir√° o aviso do V3080, mas com um n√≠vel mais baixo de certeza, do que se v√™ nulo em todas as ramifica√ß√µes.  Juntamente com a an√°lise interprocedural aprimorada, esse mecanismo permite encontrar erros que s√£o muito dif√≠ceis de detectar.  Aqui est√° um exemplo - imagine uma longa cadeia de chamadas de m√©todo, a √∫ltima das quais n√£o lhe √© familiar.  Sob certas circunst√¢ncias, ele retorna nulo no bloco <i>catch</i> , mas voc√™ n√£o se protegeu disso, pois simplesmente n√£o sabia.  Nesse caso, o analisador apenas reclama quando v√™ exatamente a atribui√ß√£o nula.  Em nossa vis√£o, ele distingue qualitativamente nossa abordagem de tal recurso do C # 8.0 como refer√™ncia de tipo anul√°vel, que, de fato, se limita a definir verifica√ß√µes para nulo para cada m√©todo.  No entanto, sugerimos a alternativa - executar verifica√ß√µes apenas em locais onde o nulo pode realmente ocorrer, e nosso analisador agora pode procurar esses casos. <br><br>  Portanto, n√£o vamos atrasar o ponto principal por muito tempo e passar √† culpa - analisando os resultados da verifica√ß√£o de Roslyn.  Primeiro, vamos considerar os erros encontrados devido aos recursos descritos acima.  Em suma, havia muitos avisos para o c√≥digo de Roslyn dessa vez.  Acho que est√° relacionado ao fato de a plataforma estar evoluindo muito ativamente (neste momento, a base de c√≥digo √© de cerca de 2.770.000 linhas, exceto as vazias), e n√£o analisamos esse projeto por muito tempo.  No entanto, n√£o existem muitos erros cr√≠ticos, embora sejam de maior interesse para o artigo.  Como de costume, exclu√≠ testes da verifica√ß√£o, existem muitos deles em Roslyn. <br><br>  Iniciarei com os erros V3080 do n√≠vel M√©dio de certeza, nos quais o analisador detectou um poss√≠vel acesso por refer√™ncia nula, mas n√£o em todos os casos poss√≠veis (ramifica√ß√µes de c√≥digo). <br><br>  <b>Poss√≠vel desrefer√™ncia nula - M√©dia</b> <br><br>  V3080 Poss√≠vel desrefer√™ncia nula.  Considere inspecionar 'atual'.  CSharpSyntaxTreeFactoryService.PositionalSyntaxReference.cs 70 <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> SyntaxNode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SyntaxNode root)</span></span></span><span class="hljs-function"> </span></span>{ var current = root; .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current.FullSpan.Contains(....)) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { .... var nodeOrToken = current.ChildThatContainsPosition(....); .... current = nodeOrToken.AsNode(); // &lt;= } .... } public SyntaxNode AsNode() { if (_token != null) { return null; } return _nodeOrParent; }</span></span></code> </pre> <br>  Vamos considerar o m√©todo <i>GetNode</i> .  O analisador sugere que o acesso por refer√™ncia nula seja poss√≠vel na condi√ß√£o do bloco <i>while</i> <i>.</i>  A vari√°vel recebe um valor no corpo do bloco <i>while</i> , que √© o resultado do m√©todo <i>AsNode</i> .  Em alguns casos, esse valor ser√° <i>nulo</i> .  Um bom exemplo de an√°lise interprocedural em a√ß√£o. <br><br>  Agora vamos considerar um caso semelhante, no qual a an√°lise interprocedural foi realizada por meio de duas chamadas de m√©todo. <br><br>  V3080 Poss√≠vel desrefer√™ncia nula.  Considere inspecionar 'diret√≥rio'.  CommonCommandLineParser.cs 911 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> IEnumerable&lt;CommandLineSourceFile&gt; ExpandFileNamePattern(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> path, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> baseDirectory, ....) { <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> directory = PathUtilities.GetDirectoryName(path); .... var resolvedDirectoryPath = (directory.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) ? <span class="hljs-comment"><span class="hljs-comment">// &lt;= baseDirectory : FileUtilities.ResolveRelativePath(directory, baseDirectory); .... } public static string GetDirectoryName(string path) { return GetDirectoryName(path, IsUnixLikePlatform); } internal static string GetDirectoryName(string path, bool isUnixLike) { if (path != null) { .... } return null; }</span></span></code> </pre> <br>  A vari√°vel de <i>diret√≥rio</i> no corpo do m√©todo <i>ExpandFileNamePattern</i> obt√©m o valor do m√©todo <i>GetDirectoryName (string)</i> .  Isso, por sua vez, retorna o resultado do m√©todo sobrecarregado <i>GetDirectoryName (string, bool)</i> cujo valor pode ser <i>nulo</i> .  Como o <i>diret√≥rio de</i> vari√°veis ‚Äã‚Äã√© usado sem uma verifica√ß√£o preliminar de null no corpo do m√©todo <i>ExpandFileNamePattern</i> - podemos proclamar o analisador correto sobre a emiss√£o do aviso.  Esta √© uma constru√ß√£o potencialmente insegura. <br><br>  Outro fragmento de c√≥digo com o erro V3080, mais precisamente, com dois erros, emitido para uma √∫nica linha de c√≥digo.  A an√°lise interprocedural n√£o foi necess√°ria aqui. <br><br>  V3080 Poss√≠vel desrefer√™ncia nula.  Considere inspecionar 'spanStartLocation'.  TestWorkspace.cs 574 <br><br>  V3080 Poss√≠vel desrefer√™ncia nula.  Considere inspecionar 'spanEndLocationExclusive'.  TestWorkspace.cs 574 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MapMarkupSpans</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (....) { .... foreach (....) { .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>? spanStartLocation = null; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>? spanEndLocationExclusive = null; foreach (....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spanStartLocation == null &amp;&amp; positionInMarkup &lt;= markupSpanStart &amp;&amp; ....) { .... spanStartLocation = ....; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spanEndLocationExclusive == null &amp;&amp; positionInMarkup &lt;= markupSpanEndExclusive &amp;&amp; ....) { .... spanEndLocationExclusive = ....; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } .... } .... } tempMappedMarkupSpans[key]. Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TextSpan( spanStartLocation.Value, <span class="hljs-comment"><span class="hljs-comment">// &lt;= spanEndLocationExclusive.Value - // &lt;= spanStartLocation.Value)); } } .... }</span></span></code> </pre> <br>  As vari√°veis <i>spanStartLocation</i> e <i>spanEndLocationExclusive</i> s√£o do tipo <i>int anul√°vel</i> e s√£o inicializadas por <i>null</i> .  Mais adiante, no c√≥digo, eles podem receber valores, mas somente sob certas condi√ß√µes.  Em alguns casos, seu valor permanece <i>nulo</i> .  Depois disso, essas vari√°veis ‚Äã‚Äãs√£o acessadas por refer√™ncia sem verifica√ß√£o preliminar de nulo, o que o analisador indica. <br><br>  O c√≥digo Roslyn cont√©m muitos desses erros, mais de 100. Geralmente, o padr√£o desses erros √© o mesmo.  Existe algum tipo de m√©todo geral, que potencialmente retorna <i>nulo</i> .  O resultado desse m√©todo √© usado em muitos lugares, √†s vezes atrav√©s de dezenas de chamadas de m√©todo intermedi√°rias ou verifica√ß√µes adicionais.  √â importante entender que esses erros n√£o s√£o fatais, mas podem levar ao acesso por refer√™ncia nula.  Embora a detec√ß√£o de tais erros seja bastante desafiadora.  Por isso, em alguns casos, deve-se considerar a refatora√ß√£o de c√≥digo; nesse caso, se retornar <i>nulo</i> , o m√©todo lan√ßar√° uma exce√ß√£o.  Caso contr√°rio, voc√™ poder√° proteger seu c√≥digo apenas com verifica√ß√µes gerais, o que √© bastante cansativo e, √†s vezes, pouco confi√°vel.  De qualquer forma, √© claro que cada caso espec√≠fico requer uma solu√ß√£o com base nas especifica√ß√µes do projeto. <br><br>  Nota  Acontece que, em um determinado momento, n√£o existem casos (dados de entrada), quando o m√©todo retorna <i>nulo</i> e n√£o h√° erro real.  No entanto, esse c√≥digo ainda n√£o √© confi√°vel, porque tudo pode mudar ao introduzir algumas altera√ß√µes no c√≥digo. <br><br>  Para descartar o assunto do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3080</a> , vejamos erros √≥bvios do n√≠vel de alta seguran√ßa, quando o acesso por refer√™ncia nula √© o mais prov√°vel ou at√© inevit√°vel. <br><br>  <b>Poss√≠vel desrefer√™ncia nula - Alta</b> <br><br>  V3080 Poss√≠vel desrefer√™ncia nula.  Considere inspecionar 'collectionType.Type'.  AbstractConvertForToForEachCodeRefactoringProvider.cs 137 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override async Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ComputeRefactoringsAsync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CodeRefactoringContext context)</span></span></span><span class="hljs-function"> </span></span>{ .... var collectionType = semanticModel.GetTypeInfo(....); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collectionType.Type == null &amp;&amp; collectionType.Type.TypeKind == TypeKind.Error) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } .... }</code> </pre> <br>  Devido ao erro de digita√ß√£o na condi√ß√£o ( <i>&amp;&amp;</i> √© usado em vez do operador <i>||</i> ), o c√≥digo funciona de maneira diferente da pretendida e o acesso √† vari√°vel <i>collectionType.Type</i> ser√° executado quando for <i>nulo</i> .  A condi√ß√£o deve ser corrigida da seguinte maneira: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collectionType.Type == null || collectionType.Type.TypeKind == TypeKind.Error) ....</code> </pre> <br>  A prop√≥sito, as coisas podem se desdobrar de outra maneira: na primeira parte da condi√ß√£o, os operadores <i>==</i> e <i>! =</i> Est√£o desarrumados <i>.</i>  Ent√£o o c√≥digo correto ficaria assim: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collectionType.Type != null &amp;&amp; collectionType.Type.TypeKind == TypeKind.Error) ....</code> </pre> <br>  Esta vers√£o do c√≥digo √© menos l√≥gica, mas tamb√©m corrige o erro.  A solu√ß√£o final cabe aos autores do projeto decidirem. <br><br>  Outro erro semelhante. <br><br>  V3080 Poss√≠vel desrefer√™ncia nula.  Considere inspecionar 'a√ß√£o'.  TextViewWindow_InProc.cs 372 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Func&lt;IWpfTextView, Task&gt; GetLightBulbApplicationAction(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (action == null) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException( $<span class="hljs-string"><span class="hljs-string">"Unable to find FixAll in {fixAllScope.ToString()} code fix for suggested action '{action.DisplayText}'."</span></span>); } .... }</code> </pre> <br>  O erro √© cometido ao gerar a mensagem para a exce√ß√£o.  √â seguida pela tentativa de acessar a propriedade <i>action.DisplayText</i> por meio da vari√°vel de <i>a√ß√£o</i> , que √© conhecida por ser <i>nula</i> . <br><br>  A√≠ vem o √∫ltimo erro V3080 do n√≠vel Alto. <br><br>  V3080 Poss√≠vel desrefer√™ncia nula.  Considere inspecionar 'tipo'.  ObjectFormatterHelpers.cs 91 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsApplicableAttribute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TypeInfo type, TypeInfo targetType, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> targetTypeName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type != null &amp;&amp; AreEquivalent(targetType, type) || targetTypeName != null &amp;&amp; type.FullName == targetTypeName; }</code> </pre> <br>  O m√©todo √© bastante pequeno, por isso cito-o inteiramente.  A condi√ß√£o no bloco de <i>devolu√ß√£o</i> est√° incorreta.  Em alguns casos, ao acessar <i>type.FullName</i> , uma exce√ß√£o pode ocorrer.  Vou usar par√™nteses para deixar claro (eles n√£o v√£o mudar o comportamento): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (type != null &amp;&amp; AreEquivalent(targetType, type)) || (targetTypeName != null &amp;&amp; type.FullName == targetTypeName);</code> </pre> <br>  De acordo com a preced√™ncia das opera√ß√µes, o c√≥digo funcionar√° exatamente assim.  Caso a vari√°vel <i>type</i> seja <i>nula</i> , cairemos na outra op√ß√£o, onde usaremos a refer√™ncia null do <i>tipo</i> , verificando a vari√°vel <i>targetTypeName</i> como <i>null</i> .  O c√≥digo pode ser corrigido, por exemplo, da seguinte maneira: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type != null &amp;&amp; (AreEquivalent(targetType, type) || targetTypeName != null &amp;&amp; type.FullName == targetTypeName);</code> </pre> <br>  Eu acho que √© o suficiente para revisar os erros do V3080.  Agora √© hora de ver outras coisas interessantes que o analisador PVS-Studio conseguiu encontrar. <br><br>  <b>Typo</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3005</a> A vari√°vel 'SourceCodeKind' √© atribu√≠da a si mesma.  DynamicFileInfo.cs 17 <br><br><pre> <code class="cpp hljs">internal sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DynamicFileInfo</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DynamicFileInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> filePath, SourceCodeKind sourceCodeKind, TextLoader textLoader, IDocumentServiceProvider documentServiceProvider)</span></span></span><span class="hljs-function"> </span></span>{ FilePath = filePath; SourceCodeKind = SourceCodeKind; <span class="hljs-comment"><span class="hljs-comment">// &lt;= TextLoader = textLoader; DocumentServiceProvider = documentServiceProvider; } .... }</span></span></code> </pre> <br>  Devido √† falha na nomea√ß√£o de vari√°veis, um erro de digita√ß√£o foi feito no construtor da classe <i>DynamicFileInfo</i> .  O campo <i>SourceCodeKind</i> recebe seu pr√≥prio valor em vez de usar o par√¢metro <i>sourceCodeKind</i> .  Para minimizar a probabilidade de tais erros, recomendamos que voc√™ use o prefixo de sublinhado nos nomes dos par√¢metros nesses casos.  Aqui est√° um exemplo de uma vers√£o corrigida do c√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DynamicFileInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _filePath, SourceCodeKind _sourceCodeKind, TextLoader _textLoader, IDocumentServiceProvider _documentServiceProvider)</span></span></span><span class="hljs-function"> </span></span>{ FilePath = _filePath; SourceCodeKind = _sourceCodeKind; TextLoader = _textLoader; DocumentServiceProvider = _documentServiceProvider; }</code> </pre> <br>  <b>Inadvert√™ncia</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3006</a> O objeto foi criado, mas n√£o est√° sendo usado.  A palavra-chave 'throw' pode estar ausente: throw new InvalidOperationException (FOO).  ProjectBuildManager.cs 61 <br><br><pre> <code class="cpp hljs">~ProjectBuildManager() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_batchBuildStarted) { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">"ProjectBuilderManager.Stop() not called."</span></span>); } }</code> </pre> <br>  Sob uma determinada condi√ß√£o, o destruidor deve lan√ßar uma exce√ß√£o, mas isso n√£o est√° acontecendo enquanto o objeto de exce√ß√£o √© simplesmente criado.  A palavra-chave <i>throw</i> foi perdida.  Aqui est√° a vers√£o corrigida do c√≥digo: <br><br><pre> <code class="cpp hljs">~ProjectBuildManager() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_batchBuildStarted) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">"ProjectBuilderManager.Stop() not called."</span></span>); } }</code> </pre> <br>  O problema com destruidores em C # e lan√ßando exce√ß√µes a eles √© um t√≥pico para outra discuss√£o, que est√° al√©m do escopo deste artigo. <br><br>  <b>Quando o resultado n√£o √© importante</b> <br><br>  Os m√©todos, que receberam o mesmo valor em todos os casos, acionaram um certo n√∫mero de avisos do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3009</a> .  Em alguns casos, isso pode n√£o ser cr√≠tico ou o valor de retorno simplesmente n√£o √© verificado no c√≥digo de chamada.  Eu pulei esses avisos.  Mas alguns trechos de c√≥digo pareciam suspeitos.  Aqui est√° um deles: <br><br>  V3009 √â estranho que esse m√©todo sempre retorne um e o mesmo valor de 'true'.  GoToDefinitionCommandHandler.cs 62 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (context.OperationContext.AddScope(....)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  O m√©todo <i>TryExecuteCommand</i> retorna apenas <i>true</i> .  Ao fazer isso, no c√≥digo de chamada, o valor retornado est√° envolvido em algumas verifica√ß√µes. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (caretPos.HasValue &amp;&amp; TryExecuteCommand(....)) { .... } .... }</code> </pre> <br>  √â dif√≠cil dizer exatamente at√© que ponto esse comportamento √© perigoso.  Mas se o resultado n√£o for necess√°rio, talvez o tipo do valor de retorno deva ser alterado para nulo e a pessoa fa√ßa pequenas edi√ß√µes no m√©todo de chamada.  Isso tornar√° o c√≥digo mais leg√≠vel e seguro. <br><br>  Avisos semelhantes do analisador: <br><br><ul><li>  V3009 √â estranho que esse m√©todo sempre retorne um e o mesmo valor de 'true'.  CommentUncommentSelectionCommandHandler.cs 86 </li><li>  V3009 √â estranho que esse m√©todo sempre retorne um e o mesmo valor de 'true'.  RenomearTrackingTaggerProvider.RenameTrackingCommitter.cs 99 </li><li>  V3009 √â estranho que esse m√©todo sempre retorne um e o mesmo valor de 'true'.  JsonRpcClient.cs 138 </li><li>  V3009 √â estranho que esse m√©todo sempre retorne um e o mesmo valor de 'true'.  AbstractFormatEngine.OperationApplier.cs 164 </li><li>  V3009 √â estranho que esse m√©todo sempre retorne um e o mesmo valor de 'false'.  TriviaDataFactory.CodeShapeAnalyzer.cs 254 </li><li>  V3009 √â estranho que esse m√©todo sempre retorne um e o mesmo valor de 'true'.  ObjectList.cs 173 </li><li>  V3009 √â estranho que esse m√©todo sempre retorne um e o mesmo valor de 'true'.  ObjectList.cs 249 </li></ul><br>  <b>Verificou a coisa errada</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3019</a> Possivelmente, uma vari√°vel incorreta √© comparada com nulo ap√≥s a convers√£o do tipo usando a palavra-chave 'as'.  Verifique as vari√°veis ‚Äã‚Äã'valor', 'valueToSerialize'.  RoamingVisualStudioProfileOptionPersister.cs 277 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryPersist</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OptionKey optionKey, object value)</span></span></span><span class="hljs-function"> </span></span>{ .... var valueToSerialize = value as NamingStylePreferences; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value != null) { value = valueToSerialize.CreateXElement().ToString(); } .... }</code> </pre> <br>  A vari√°vel <i>value</i> √© convertida para o tipo <i>NamingStylePreferences</i> .  O problema est√° na verifica√ß√£o que se segue.  Mesmo que a vari√°vel <i>value</i> n√£o seja nula, n√£o garante que a convers√£o do tipo tenha sido bem-sucedida e <i>valueToSerialize</i> n√£o contenha <i>nulo</i> .  Poss√≠vel lan√ßamento da exce√ß√£o <i>NullReferenceException</i> .  O c√≥digo precisa ser corrigido da seguinte maneira: <br><br><pre> <code class="cpp hljs">var valueToSerialize = value as NamingStylePreferences; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (valueToSerialize != null) { value = valueToSerialize.CreateXElement().ToString(); }</code> </pre> <br>  Outro bug semelhante: <br><br>  V3019 Possivelmente, uma vari√°vel incorreta √© comparada com nulo ap√≥s a convers√£o do tipo usando a palavra-chave 'as'.  Verifique as vari√°veis ‚Äã‚Äã'columnState', 'columnState2'.  StreamingFindUsagesPresenter.cs 181 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetDefinitionGroupingPriority</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (var columnState in ....) { var columnState2 = columnState as ColumnState2; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (columnState?.Name == <span class="hljs-comment"><span class="hljs-comment">// &lt;= StandardTableColumnDefinitions2.Definition) { newColumns.Add(new ColumnState2( columnState2.Name, // &lt;= ....)); } .... } .... }</span></span></code> </pre> <br>  A vari√°vel <i>columnState</i> √© convertida no tipo <i>ColumnState2</i> .  No entanto, o resultado da opera√ß√£o, que √© a vari√°vel <i>columnState2,</i> n√£o recebe mais <i>nulos</i> .  Em vez disso, a vari√°vel <i>columnState</i> √© verificada usando o operador <i>nulo</i> condicional.  Por que esse c√≥digo √© perigoso?  Assim como no exemplo anterior, a convers√£o com o operador as pode falhar e a vari√°vel ser√° <i>nula</i> , resultando em uma exce√ß√£o.  A prop√≥sito, um erro de digita√ß√£o pode ser o culpado aqui.  D√™ uma olhada na condi√ß√£o no bloco <i>if</i> . <br><br>  Talvez, em vez de <i>columnState? .Name,</i> o autor queira escrever <i>columnState2? .Name</i> .  √â muito prov√°vel, considerando nomes de vari√°veis ‚Äã‚Äãbastante defeituosos <i>columnState</i> e <i>columnState2.</i> <br><br>  <b>Verifica√ß√µes redundantes</b> <br><br>  Um grande n√∫mero de avisos (mais de 100) foi emitido em constru√ß√µes n√£o cr√≠ticas, mas potencialmente inseguras relacionadas a verifica√ß√µes redundantes.  Por exemplo, este √© um deles. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A</a> express√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3022</a> 'navInfo == null' sempre √© falsa.  AbstractSyncClassViewCommandHandler.cs 101 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... IVsNavInfo navInfo = null; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (symbol != null) { navInfo = libraryService.NavInfoFactory.CreateForSymbol(....); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (navInfo == null) { navInfo = libraryService.NavInfoFactory.CreateForProject(....); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (navInfo == null) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { return true; } .... } public IVsNavInfo CreateForSymbol(....) { .... return null; } public IVsNavInfo CreateForProject(....) { return new NavInfo(....); }</span></span></code> </pre> <br>  Pode ser que n√£o haja nenhum bug real aqui.  √â apenas uma boa raz√£o para demonstrar "an√°lise interprocedural + an√°lise de fluxo de dados" trabalhando em um reboque.  O analisador sugere que a segunda verifica√ß√£o <i>navInfo == null</i> seja redundante.  De fato, antes dele, o valor atribu√≠do a <i>navInfo</i> ser√° obtido no m√©todo <i>libraryService.NavInfoFactory.CreateForProject</i> , que construir√° e retornar√° um novo objeto da classe <i>NavInfo</i> .  De maneira alguma ele retornar√° <i>nulo</i> .  Aqui surge a pergunta: por que o analisador n√£o emitiu um aviso para a primeira verifica√ß√£o <i>navInfo == null</i> ?  Existem algumas raz√µes.  Primeiramente, se a vari√°vel do <i>s√≠mbolo</i> for <i>nula</i> , o valor <i>navInfo</i> tamb√©m permanecer√° uma refer√™ncia nula.  Em segundo lugar, mesmo se <i>navInfo</i> obtiver o valor do m√©todo <i>ibraryService.NavInfoFactory.CreateForSymbol</i> , esse valor tamb√©m poder√° ser <i>nulo</i> .  Portanto, a primeira verifica√ß√£o <i>navInfo == null</i> √© realmente necess√°ria. <br><br>  <b>Verifica√ß√µes insuficientes</b> <br><br>  Agora, a situa√ß√£o inversa do discutido acima.  V√°rios avisos da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3042</a> foram acionados para o c√≥digo, no qual o acesso por refer√™ncia nula √© poss√≠vel.  Mesmo uma ou duas pequenas verifica√ß√µes poderiam ter consertado tudo. <br><br>  Vamos considerar outro fragmento de c√≥digo interessante, que possui dois desses erros. <br><br>  V3042 Poss√≠vel NullReferenceException.  O '?'  e '.'  operadores s√£o usados ‚Äã‚Äãpara acessar membros do objeto 'receptor' Binder_Expressions.cs 7770 <br><br>  V3042 Poss√≠vel NullReferenceException.  O '?'  e '.'  operadores s√£o usados ‚Äã‚Äãpara acessar membros do objeto 'receptor' Binder_Expressions.cs 7776 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> BoundExpression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetReceiverForConditionalBinding</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ExpressionSyntax binding, DiagnosticBag diagnostics)</span></span></span><span class="hljs-function"> </span></span>{ .... BoundExpression receiver = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ConditionalReceiverExpression; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (receiver?.Syntax != <span class="hljs-comment"><span class="hljs-comment">// &lt;= GetConditionalReceiverSyntax(conditionalAccessNode)) { receiver = BindConditionalAccessReceiver(conditionalAccessNode, diagnostics); } var receiverType = receiver.Type; // &lt;= if (receiverType?.IsNullableType() == true) { .... } receiver = new BoundConditionalReceiver(receiver.Syntax, 0, // &lt;= receiverType ?? CreateErrorType(), hasErrors: receiver.HasErrors) // &lt;= { WasCompilerGenerated = true }; return receiver; }</span></span></code> </pre> <br>  A vari√°vel do <i>receptor</i> pode ser nula.  O autor do c√≥digo sabe disso, pois ele usa o operador <i>nulo</i> condicional na condi√ß√£o do bloco <i>if</i> para acessar o <i>receptor ?</i> . <i>Sintaxe</i> .  Al√©m disso, a vari√°vel do <i>receptor</i> √© usada sem nenhuma verifica√ß√£o para acessar o <i>receiver.Type</i> , <i>receiver.Syntax</i> e <i>receiver.HasErrors</i> .  Esses erros devem ser corrigidos: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> BoundExpression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetReceiverForConditionalBinding</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ExpressionSyntax binding, DiagnosticBag diagnostics)</span></span></span><span class="hljs-function"> </span></span>{ .... BoundExpression receiver = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ConditionalReceiverExpression; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (receiver?.Syntax != GetConditionalReceiverSyntax(conditionalAccessNode)) { receiver = BindConditionalAccessReceiver(conditionalAccessNode, diagnostics); } var receiverType = receiver?.Type; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (receiverType?.IsNullableType() == <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { .... } receiver = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BoundConditionalReceiver(receiver?.Syntax, <span class="hljs-number"><span class="hljs-number">0</span></span>, receiverType ?? CreateErrorType(), hasErrors: receiver?.HasErrors) { WasCompilerGenerated = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> receiver; }</code> </pre> <br>  Tamb√©m precisamos ter certeza de que o construtor suporta a obten√ß√£o de valores <i>nulos</i> para seus par√¢metros ou precisamos executar refatora√ß√£o adicional. <br><br>  Outros erros semelhantes: <br><br><ul><li>  V3042 Poss√≠vel NullReferenceException.  O '?'  e '.'  operadores s√£o usados ‚Äã‚Äãpara acessar membros do objeto 'containsType' SyntaxGeneratorExtensions_Negate.cs 240 </li><li>  V3042 Poss√≠vel NullReferenceException.  O '?'  e '.'  operadores s√£o usados ‚Äã‚Äãpara acessar membros do objeto 'express√£o' ExpressionSyntaxExtensions.cs 349 </li><li>  V3042 Poss√≠vel NullReferenceException.  O '?'  e '.'  operadores s√£o usados ‚Äã‚Äãpara acessar membros do objeto 'express√£o' ExpressionSyntaxExtensions.cs 349 </li></ul><br>  <b>Erro na condi√ß√£o</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3057</a> A fun√ß√£o ' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Substring</a> ' pode receber o valor '-1' enquanto se espera um valor n√£o negativo.  Inspecione o segundo argumento.  CommonCommandLineParser.cs 109 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryParseOption</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colon &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { name = arg.Substring(<span class="hljs-number"><span class="hljs-number">1</span></span>, colon - <span class="hljs-number"><span class="hljs-number">1</span></span>); value = arg.Substring(colon + <span class="hljs-number"><span class="hljs-number">1</span></span>); } .... }</code> </pre> <br>  Caso a vari√°vel de <i>dois pontos</i> seja 0, o que √© bom de acordo com a condi√ß√£o no c√≥digo, o m√©todo <i>Substring</i> emitir√° uma exce√ß√£o.  Isso precisa ser corrigido: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colon &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  <b>Poss√≠vel erro de digita√ß√£o</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3065 O</a> par√¢metro 't2' n√£o √© utilizado dentro do corpo do m√©todo.  CSharpCodeGenerationHelpers.cs 84 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> TypeDeclarationSyntax </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReplaceUnterminatedConstructs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... var updatedToken = lastToken.ReplaceTrivia(lastToken.TrailingTrivia, (t1, t2) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t1.Kind() == SyntaxKind.MultiLineCommentTrivia) { var text = t1.ToString(); .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t1.Kind() == SyntaxKind.SkippedTokensTrivia) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ReplaceUnterminatedConstructs(t1); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t1; }); .... }</code> </pre> <br>  A express√£o lambda aceita dois par√¢metros: t1 e t2.  No entanto, apenas t1 √© usado.  Parece suspeito, levando em considera√ß√£o o qu√£o f√°cil √© cometer um erro ao usar vari√°veis ‚Äã‚Äãcom esses nomes. <br><br>  <b>Inadvert√™ncia</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3083 Chamada n√£o segura</a> do evento 'TagsChanged', NullReferenceException √© poss√≠vel.  Considere atribuir um evento a uma vari√°vel local antes de invoc√°-lo.  PreviewUpdater.Tagger.cs 37 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnTextBufferChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PreviewUpdater.SpanToShow != <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TagsChanged != null) { var span = _textBuffer.CurrentSnapshot.GetFullSpan(); TagsChanged(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SnapshotSpanEventArgs(span)); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } } }</span></span></code> </pre> <br>  O evento <i>TagsChanged</i> √© invocado de maneira insegura.  Entre a verifica√ß√£o de <i>nulo</i> e a invoca√ß√£o do evento, algu√©m pode cancelar a inscri√ß√£o, e uma exce√ß√£o ser√° lan√ßada.  Al√©m disso, outras opera√ß√µes s√£o executadas no corpo do bloco <i>if</i> antes de chamar o evento.  Chamei esse erro de "inadvert√™ncia", porque esse evento √© tratado com mais cuidado em outros lugares, da seguinte maneira: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnTrackingSpansChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> leafChanged)</span></span></span><span class="hljs-function"> </span></span>{ var handler = TagsChanged; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handler != null) { var snapshot = _buffer.CurrentSnapshot; handler(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SnapshotSpanEventArgs(snapshot.GetFullSpan())); } }</code> </pre> <br>  O uso de uma vari√°vel de <i>manipulador</i> adicional evita o problema.  No m√©todo <i>OnTextBufferChanged,</i> √© necess√°rio fazer edi√ß√µes para lidar com seguran√ßa com o evento. <br><br>  <b>Interse√ß√£o de intervalos</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3092 As</a> interse√ß√µes de faixa s√£o poss√≠veis dentro de express√µes condicionais.  Exemplo: if (A&gt; 0 &amp;&amp; A &lt;5) {...} else if (A&gt; 3 &amp;&amp; A &lt;9) {...}.  ILBuilderEmit.cs 677 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EmitLongConstant</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MinValue &amp;&amp; value &lt;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= uint.MinValue &amp;&amp; value &lt;= uint.MaxValue) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } }</code> </pre> <br>  Para uma melhor compreens√£o, deixe-me reescrever esse c√≥digo, alterando os nomes das constantes com seus valores reais: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EmitLongConstant</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= <span class="hljs-number"><span class="hljs-number">-2147483648</span></span> &amp;&amp; value &lt;= <span class="hljs-number"><span class="hljs-number">2147483648</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; value &lt;= <span class="hljs-number"><span class="hljs-number">4294967295</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } }</code> </pre> <br>  Provavelmente, n√£o h√° erro real, mas a condi√ß√£o parece estranha.  Sua segunda parte ( <i>sen√£o se</i> ) ser√° executada apenas para o intervalo de 2147483648 + 1 a 4294967295. <br><br>  Outro par de avisos semelhantes: <br><br><ul><li>  V3092 As interse√ß√µes de faixa s√£o poss√≠veis dentro de express√µes condicionais.  Exemplo: if (A&gt; 0 &amp;&amp; A &lt;5) {...} else if (A&gt; 3 &amp;&amp; A &lt;9) {...}.  LocalRewriter_Literal.cs 109 </li><li>  V3092 As interse√ß√µes de faixa s√£o poss√≠veis dentro de express√µes condicionais.  Exemplo: if (A&gt; 0 &amp;&amp; A &lt;5) {...} else if (A&gt; 3 &amp;&amp; A &lt;9) {...}.  LocalRewriter_Literal.cs 66 </li></ul><br>  <b>Mais sobre verifica√ß√µes de nulo (ou falta delas)</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Alguns</a> erros do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3095</a> na verifica√ß√£o de uma vari√°vel para nulo logo ap√≥s seu uso.  O primeiro √© amb√≠guo, vamos considerar o c√≥digo. <br><br>  V3095 O objeto 'displayName' foi usado antes de ser verificado contra nulo.  Verifique as linhas: 498, 503. FusionAssemblyIdentity.cs 498 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IAssemblyName </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToAssemblyNameObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> displayName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (displayName.IndexOf(<span class="hljs-string"><span class="hljs-string">'\0'</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } Debug.Assert(displayName != null); .... }</code> </pre> <br>  Sup√µe-se que a refer√™ncia <i>displayName</i> possa ser nula.  Para isso, a verifica√ß√£o <i>Debug.Assert</i> foi realizada.  N√£o est√° claro por que isso ocorre ap√≥s o uso de uma string.  Tamb√©m deve ser levado em considera√ß√£o que, para configura√ß√µes diferentes de Debug, o compilador remover√° o <i>Debug.Assert</i> <i>.</i>  Isso significa que obter uma refer√™ncia nula √© poss√≠vel apenas para Depura√ß√£o?  Caso contr√°rio, por que o autor fez a verifica√ß√£o de <i>string.IsNullOrEmpty (string)</i> , por exemplo.  √â a pergunta para os autores do c√≥digo. <br><br>  O seguinte erro √© mais evidente. <br><br>  V3095 O objeto 'scriptArgsOpt' foi usado antes de ser verificado em rela√ß√£o a nulo.  Verifique as linhas: 321, 325. CommonCommandLineParser.cs 321 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FlattenArgs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., List&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; scriptArgsOpt, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (args.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parsingScriptArgs) { scriptArgsOpt.Add(arg); <span class="hljs-comment"><span class="hljs-comment">// &lt;= continue; } if (scriptArgsOpt != null) { .... } .... } }</span></span></code> </pre> <br>  Eu acho que esse c√≥digo n√£o precisa de explica√ß√µes.  Deixe-me dar a vers√£o fixa: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FlattenArgs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., List&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; scriptArgsOpt, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (args.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parsingScriptArgs) { scriptArgsOpt?.Add(arg); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (scriptArgsOpt != null) { .... } .... } }</code> </pre> <br>  No c√≥digo Roslyn, havia mais 15 erros semelhantes: <br><br><ul><li>  V3095 O objeto 'LocalFunctions' foi usado antes de ser verificado contra nulo.  Verifique as linhas: 289, 317. ControlFlowGraphBuilder.RegionBuilder.cs 289 </li><li>  V3095 O objeto 'resolution.OverloadResolutionResult' foi usado antes de ser verificado como nulo.  Verifique as linhas: 579, 588. Binder_Invocation.cs 579 </li><li>  V3095 O objeto 'resolution.MethodGroup' foi usado antes de ser verificado contra nulo.  Verifique as linhas: 592, 621. Binder_Invocation.cs 592 </li><li>  V3095 O objeto 'touchedFilesLogger' foi usado antes de ser verificado como nulo.  Verifique as linhas: 111, 126. CSharpCompiler.cs 111 </li><li>  V3095 O objeto 'newExceptionRegionsOpt' foi usado antes de ser verificado como nulo.  Verifique as linhas: 736, 743. AbstractEditAndContinueAnalyzer.cs 736 </li><li>  V3095 O objeto 'symbol' foi usado antes de ser verificado com rela√ß√£o a nulo.  Verifique as linhas: 422, 427. AbstractGenerateConstructorService.Editor.cs 422 </li><li>  V3095 O objeto '_state.BaseTypeOrInterfaceOpt' foi usado antes de ser verificado como nulo.  Verifique as linhas: 132, 140. AbstractGenerateTypeService.GenerateNamedType.cs 132 </li><li>  V3095 O objeto 'elemento' foi usado antes de ser verificado com rela√ß√£o a nulo.  Verifique as linhas: 232, 233. ProjectUtil.cs 232 </li><li>  V3095 O objeto 'languages' foi usado antes de ser verificado com valor nulo.  Verifique as linhas: 22, 28. ExportCodeCleanupProvider.cs 22 </li><li>  V3095 O objeto 'memberType' foi usado antes de ser verificado com rela√ß√£o a nulo.  Verifique as linhas: 183, 184. SyntaxGeneratorExtensions_CreateGetHashCodeMethod.cs 183 </li><li>  V3095 O objeto 'validTypeDeclarations' foi usado antes de ser verificado em rela√ß√£o a nulo.  Verifique as linhas: 223, 228. SyntaxTreeExtensions.cs 223 </li><li>  V3095 O objeto 'texto' foi usado antes de ser verificado com rela√ß√£o a nulo.  Verifique as linhas: 376, 385. MSBuildWorkspace.cs 376 </li><li>  V3095 O objeto 'nameOrMemberAccessExpression' foi usado antes de ser verificado com rela√ß√£o a nulo.  Verifique as linhas: 206, 223. CSharpGenerateTypeService.cs 206 </li><li>  V3095 O objeto 'simpleName' foi usado antes de ser verificado com rela√ß√£o a nulo.  Verifique as linhas: 83, 85. CSharpGenerateMethodService.cs 83 </li><li>  V3095 O objeto 'op√ß√£o' foi usado antes de ser verificado em rela√ß√£o a nulo.  Verifique as linhas: 23, 28. OptionKey.cs 23 </li></ul><br>  Vamos considerar os erros da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3105</a> .  Aqui, o operador <i>nulo</i> condicional √© usado ao inicializar a vari√°vel, mas ainda mais a vari√°vel √© usada sem verifica√ß√µes de <i>nulo</i> . <br><br>  Dois avisos indicam o seguinte erro: <br><br>  V3105 A vari√°vel 'documentId' foi usada ap√≥s ser atribu√≠da por meio do operador condicional nulo.  NullReferenceException √© poss√≠vel.  CodeLensReferencesService.cs 138 <br><br>  V3105 A vari√°vel 'documentId' foi usada ap√≥s ser atribu√≠da por meio do operador condicional nulo.  NullReferenceException √© poss√≠vel.  CodeLensReferencesService.cs 139 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> async Task&lt;ReferenceLocationDescriptor&gt; GetDescriptorOfEnclosingSymbolAsync(....) { .... var documentId = solution.GetDocument(location.SourceTree)?.Id; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReferenceLocationDescriptor( .... documentId.ProjectId.Id, documentId.Id, ....); }</code> </pre> <br>  A vari√°vel <i>documentId</i> pode ser inicializada por <i>nulo</i> .  Como resultado, a cria√ß√£o de um objeto <i>ReferenceLocationDescriptor</i> resultar√° no lan√ßamento de uma exce√ß√£o.  O c√≥digo deve ser corrigido: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReferenceLocationDescriptor( .... documentId?.ProjectId.Id, documentId?.Id, ....);</code> </pre> <br>  Os desenvolvedores tamb√©m devem cobrir a possibilidade de vari√°veis, passadas para um construtor, serem <i>nulas.</i> <br><br>  Outros erros semelhantes no c√≥digo: <br><br><ul><li>  V3105 A vari√°vel 'symbol' foi usada ap√≥s ser atribu√≠da atrav√©s do operador condicional nulo.  NullReferenceException √© poss√≠vel.  SymbolFinder_Hierarchy.cs 44 </li><li>  V3105 A vari√°vel 'symbol' foi usada ap√≥s ser atribu√≠da atrav√©s do operador condicional nulo.  NullReferenceException √© poss√≠vel.  SymbolFinder_Hierarchy.cs 51 </li></ul><br>  <b>Prioridades e par√™nteses</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3123</a> Talvez o operador '?:' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Funcione de</a> maneira diferente do esperado.  Sua prioridade √© menor que a prioridade de outros operadores em sua condi√ß√£o.  Edit.cs 70 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Edit&lt;TNode&gt; other)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _kind == other._kind &amp;&amp; (_oldNode == null) ? other._oldNode == null : _oldNode.Equals(other._oldNode) &amp;&amp; (_newNode == null) ? other._newNode == null : _newNode.Equals(other._newNode); }</code> </pre> <br>  A condi√ß√£o no bloco de retorno n√£o √© avaliada como o desenvolvedor pretendia.  Assumiu-se que a primeira condi√ß√£o ser√° <i>_tipo == outro._kin</i> d, (√© por isso que, ap√≥s essa condi√ß√£o, h√° uma quebra de linha) e, depois disso, os blocos de condi√ß√µes com o operador " <i>?</i> " Ser√£o avaliados em sequ√™ncia.  De fato, a primeira condi√ß√£o √© <i>_kind == other._kind &amp;&amp; (_oldNode == null)</i> .  Isso se deve ao fato de o operador <i>&amp;&amp;</i> ter uma prioridade mais alta que o operador " <i>?</i> ".  Para corrigir isso, um desenvolvedor deve usar todas as express√µes do operador " <i>?</i> " Entre par√™nteses: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _kind == other._kind &amp;&amp; ((_oldNode == null) ? other._oldNode == null : _oldNode.Equals(other._oldNode)) &amp;&amp; ((_newNode == null) ? other._newNode == null : _newNode.Equals(other._newNode));</code> </pre> <br>  Isso conclui minha descri√ß√£o dos erros encontrados. <br><br>  <b>Conclus√£o</b> <br><br>  Apesar do grande n√∫mero de erros que eu consegui encontrar, em termos do tamanho do c√≥digo do projeto Roslyn (2.770.000 linhas), n√£o √© demais.  Como Andrey escreveu em um artigo anterior, tamb√©m estou pronto para reconhecer a alta qualidade deste projeto. <br><br>  Gostaria de observar que essas verifica√ß√µes ocasionais de c√≥digo n√£o t√™m nada a ver com a metodologia da an√°lise est√°tica e s√£o quase in√∫teis.  A an√°lise est√°tica deve ser aplicada regularmente, e n√£o caso a caso.  Dessa forma, muitos erros ser√£o corrigidos nos est√°gios iniciais e, portanto, o custo para corrigi-los ser√° dez vezes menor.  Essa id√©ia √© apresentada com mais detalhes nesta pequena <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nota</a> , por favor, confira. <br><br>  Voc√™ pode verificar alguns erros neste projeto e em outro.  Para fazer isso, basta fazer o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">download</a> e experimentar o nosso analisador. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt446588/">https://habr.com/ru/post/pt446588/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt446572/index.html">O Editor.js √© um excelente editor que salva o c√≥digo-fonte no formato JSON</a></li>
<li><a href="../pt446576/index.html">Substitui√ß√£o de importa√ß√£o ou como os helic√≥pteros russos fizeram algo errado</a></li>
<li><a href="../pt446578/index.html">Linguagem de programa√ß√£o baseada em cart√£o postal</a></li>
<li><a href="../pt446582/index.html">Reflex√µes sobre hospedagem solar para abelhas</a></li>
<li><a href="../pt446586/index.html">Configura√ß√µes de rede do FreeRadius via DHCP</a></li>
<li><a href="../pt446590/index.html">39 novos recursos dispon√≠veis no Java 12</a></li>
<li><a href="../pt446592/index.html">Verificando o c√≥digo fonte de Roslyn</a></li>
<li><a href="../pt446598/index.html">Recriando fontes CRT</a></li>
<li><a href="../pt446602/index.html">Corrente m√°xima DC atrav√©s do transistor de efeito de campo</a></li>
<li><a href="../pt446604/index.html">ESET: Novos esquemas de entrega de backdoor de grupos cibern√©ticos da OceanLotus</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>