<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõåüèº üòø üñïüèΩ RabbitMQ contre Kafka: basculement et haute disponibilit√© dans les clusters üë®‚Äçüë©‚Äçüëß ü•å üéè</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La tol√©rance aux pannes et la haute disponibilit√© sont des sujets importants, donc RabbitMQ et Kafka consacreront des articles distincts. Cet article ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RabbitMQ contre Kafka: basculement et haute disponibilit√© dans les clusters</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/itsumma/blog/471858/"><img src="https://habrastorage.org/webt/hr/j2/oy/hrj2oyxwqv8-wo-vpmagx_dwmia.jpeg"><br><br>  La tol√©rance aux pannes et la haute disponibilit√© sont des sujets importants, donc RabbitMQ et Kafka consacreront des articles distincts.  Cet article concerne RabbitMQ, et le suivant concerne Kafka, par rapport √† RabbitMQ.  L'article est long, alors installez-vous confortablement. <br><br>  Tenez compte des strat√©gies de tol√©rance aux pannes, de coh√©rence et de haute disponibilit√© (HA), ainsi que des compromis que chaque strat√©gie doit faire.  RabbitMQ peut fonctionner sur un cluster de n≈ìuds - puis il est class√© comme un syst√®me distribu√©.  Lorsqu'il s'agit de syst√®mes distribu√©s, nous parlons souvent de coh√©rence et d'accessibilit√©. <br><br>  Ces concepts d√©crivent le comportement du syst√®me en cas de panne.  √âchec de la connexion r√©seau, d√©faillance du serveur, d√©faillance du disque dur, indisponibilit√© temporaire du serveur en raison de la r√©cup√©ration de place, de la perte de paquets ou du ralentissement de la connexion r√©seau.  Tout cela peut entra√Æner des pertes de donn√©es ou des conflits.  Il s'av√®re qu'il est presque impossible de d√©velopper un syst√®me √† la fois compl√®tement coh√©rent (sans perte de donn√©es, sans anomalies de donn√©es) et accessible (il acceptera les op√©rations de lecture et d'√©criture) pour tous les types de d√©faillance. <br><a name="habracut"></a><br>  Nous verrons que la coh√©rence et l'accessibilit√© se situent √† diff√©rentes extr√©mit√©s du spectre, et vous devez choisir la voie √† optimiser.  La bonne nouvelle est qu'avec RabbitMQ un tel choix est possible.  Vous avez une sorte de levier "Nerd" pour d√©placer l'√©quilibre vers une plus grande coh√©rence ou une plus grande accessibilit√©. <br><br>  Nous porterons une attention particuli√®re aux configurations entra√Ænant une perte de donn√©es en raison des enregistrements confirm√©s.  Il existe une cha√Æne de responsabilit√© entre les √©diteurs, les courtiers et les consommateurs.  Une fois le message transmis au courtier, il lui appartient de ne pas perdre le message.  Lorsque le courtier confirme √† l'√©diteur la r√©ception du message, nous ne nous attendons pas √† ce qu'il soit perdu.  Mais nous verrons que cela peut vraiment se produire en fonction de la configuration de votre courtier et √©diteur. <br><br><h1>  Les primitives de stabilit√© d'un n≈ìud </h1><br><h3>  Files d'attente / routage soutenus </h3><br>  Il existe deux types de files d'attente dans RabbitMQ: durable / non durable.  Toutes les files d'attente sont stock√©es dans la base de donn√©es Mnesia.  Les files d'attente persistantes sont re-d√©clar√©es au d√©marrage du n≈ìud et survivent ainsi √† un red√©marrage, √† un plantage du syst√®me ou √† un plantage du serveur (tant que les donn√©es sont enregistr√©es).  Cela signifie que pendant que vous d√©clarez le routage (√©change) et la file d'attente r√©siliente, l'infrastructure des files d'attente / routage reviendra au mode en ligne. <br><br>  Les files d'attente volatiles et le routage sont supprim√©s au red√©marrage de l'h√¥te. <br><br><h3>  Messages persistants </h3><br>  Ce n'est pas parce que la file d'attente est longue que tous ses messages survivront au red√©marrage d'un n≈ìud.  Seuls les messages d√©finis par l'√©diteur comme persistants seront restaur√©s.  Les messages persistants cr√©ent une charge suppl√©mentaire pour le courtier, mais si la perte de messages est inacceptable, il n'y a pas d'autre moyen. <br><br><img src="https://habrastorage.org/webt/hl/nv/gv/hlnvgvt20t-fbikkajwnkirflyo.png"><br>  <i>Fig.</i>  <i>1. Matrice de stabilit√©</i> <br><br><h1>  Mise en miroir de la file d'attente </h1><br>  Pour survivre √† la perte d'un courtier, nous avons besoin de redondance.  Nous pouvons combiner plusieurs n≈ìuds RabbitMQ dans un cluster, puis ajouter une redondance suppl√©mentaire en r√©pliquant les files d'attente entre plusieurs n≈ìuds.  Ainsi, si un n≈ìud tombe, nous ne perdons pas de donn√©es et restons disponibles. <br><br>  Mise en miroir de la file d'attente: <br><br><ul><li>  une file d'attente principale (ma√Ætre), qui re√ßoit toutes les commandes d'√©criture et de lecture <br></li><li>  un ou plusieurs miroirs qui re√ßoivent tous les messages et m√©tadonn√©es de la file d'attente principale.  Ces miroirs n'existent pas pour la mise √† l'√©chelle, mais uniquement pour la redondance. </li></ul><br><img src="https://habrastorage.org/webt/am/-b/ol/am-boljly334-fiqfajsoowe3iu.png"><br>  <i>Fig.</i>  <i>2. Mise en miroir de la file d'attente</i> <br><br>  La mise en miroir est d√©finie par la strat√©gie appropri√©e.  Dans celui-ci, vous pouvez choisir le taux de r√©plication et m√™me les n≈ìuds sur lesquels la file d'attente doit √™tre plac√©e.  Exemples: <br><br><ul><li><code>ha-mode: all</code> <br> </li><li>  <code>ha-mode: exactly, ha-params: 2</code> (un ma√Ætre et un miroir) <br></li><li> <code>ha-mode: nodes, ha-params: rabbit@node1, rabbit@node2</code> </li> </ul><br><h1>  Confirmation √† l'√©diteur </h1><br>  Pour obtenir un enregistrement s√©quentiel, les confirmations de l'√©diteur doivent √™tre confirm√©es.  Sans eux, il y a une chance de perdre des messages.  Une confirmation est envoy√©e √† l'√©diteur apr√®s avoir √©crit le message sur le disque.  RabbitMQ √©crit des messages sur le disque non pas √† la r√©ception, mais sur une base p√©riodique, dans la r√©gion de plusieurs centaines de millisecondes.  Lorsque la file d'attente est mise en miroir, la confirmation n'est envoy√©e qu'apr√®s que tous les miroirs ont √©galement √©crit leur copie du message sur le disque.  Cela signifie que l'utilisation d'accus√©s de r√©ception augmente le d√©lai, mais si la s√©curit√© des donn√©es est importante, elles sont n√©cessaires. <br><br><h1>  File d'attente de basculement </h1><br>  Lorsque le courtier s'arr√™te ou se bloque, toutes les files d'attente principales (ma√Ætres) sur ce n≈ìud tombent avec lui.  Le cluster s√©lectionne ensuite le miroir le plus ancien de chaque ma√Ætre et le promeut en tant que nouveau ma√Ætre. <br><br><img src="https://habrastorage.org/webt/pq/v_/_a/pqv__ahffpye5i6h_2pdzozyrgi.png"><br>  <i>Fig.</i>  <i>3. Plusieurs files d'attente en miroir et leurs politiques</i> <br><br>  Courtier 3 gouttes.  Notez que le miroir de la file d'attente C sur Broker 2 est mis √† niveau vers un ma√Ætre.  Notez √©galement qu'un nouveau miroir a √©t√© cr√©√© pour la file d'attente C sur le courtier 1. RabbitMQ essaie toujours de maintenir le taux de r√©plication sp√©cifi√© dans vos strat√©gies. <br><br><img src="https://habrastorage.org/webt/df/e7/la/dfe7laf8pyg0pobmrkgteky-wsw.png"><br>  <i>Fig.</i>  <i>4. Le courtier 3 tombe, entra√Ænant l'√©chec de la file d'attente C</i> <br><br>  Le prochain courtier 1 tombe!  Il ne nous reste qu'un courtier.  Le miroir de la file d'attente B monte vers le ma√Ætre. <br><br><img src="https://habrastorage.org/webt/b2/bd/qi/b2bdqi_lz21qoe8hcdmsjy8g5kc.png"><br>  <i>Fig.</i>  <i>5</i> <br><br>  Nous avons renvoy√© le courtier 1. Quel que soit le succ√®s avec lequel les donn√©es ont surv√©cu √† la perte et √† la r√©cup√©ration du courtier, tous les messages de file d'attente en miroir sont ignor√©s au red√©marrage.  Ceci est important √† noter, car il y aura des cons√©quences.  Nous examinerons bient√¥t ces cons√©quences.  Ainsi, Broker 1 est √† nouveau membre du cluster, et le cluster tente de se conformer aux strat√©gies et cr√©e donc des miroirs sur Broker 1. <br><br>  Dans ce cas, la perte du courtier 1 √©tait termin√©e, ainsi que les donn√©es, de sorte que la file d'attente D sans miroir √©tait compl√®tement perdue. <br><br><img src="https://habrastorage.org/webt/wi/ql/68/wiql68dzsoerzuibhspllun85ec.png"><br>  <i>Fig.</i>  <i>6. Le courtier 1 est de retour en service</i> <br><br>  Le courtier 3 est de retour en ligne, donc les lignes A et B obtiennent des miroirs cr√©√©s en fonction de leurs politiques HA.  Mais maintenant, toutes les lignes principales sont sur un seul n≈ìud!  Ce n'est pas id√©al; une distribution uniforme entre les n≈ìuds est meilleure.  Malheureusement, il n'y a pas d'options sp√©ciales pour r√©√©quilibrer les ma√Ætres.  Nous reviendrons sur ce probl√®me plus tard, car nous devons d'abord consid√©rer la synchronisation des files d'attente. <br><br><img src="https://habrastorage.org/webt/bg/hj/4n/bghj4n6pdd5ki4oideq7zbwmasi.png"><br>  <i>Fig.</i>  <i>7. Le courtier 3 est de retour en service.</i>  <i>Toutes les files d'attente principales sur un n≈ìud!</i> <br><br>  Ainsi, vous devriez maintenant avoir une id√©e de la fa√ßon dont les miroirs offrent une redondance et une tol√©rance aux pannes.  Cela garantit la disponibilit√© en cas de d√©faillance d'un n≈ìud unique et prot√®ge contre la perte de donn√©es.  Mais nous n'avons pas encore fini, car en r√©alit√© tout est beaucoup plus compliqu√©. <br><br><h1>  Sync </h1><br>  Lors de la cr√©ation d'un nouveau miroir, tous les nouveaux messages seront toujours r√©pliqu√©s sur ce miroir et tous les autres.  Quant aux donn√©es existantes dans la file d'attente principale, nous pouvons les r√©pliquer dans un nouveau miroir, qui devient une copie compl√®te du ma√Ætre.  Nous ne pouvons pas non plus r√©pliquer les messages existants et permettre √† la file d'attente principale et au nouveau miroir de converger √† temps lorsque de nouveaux messages arrivent en queue et que les messages existants quittent la t√™te de la file d'attente principale. <br><br>  Cette synchronisation est effectu√©e automatiquement ou manuellement et est contr√¥l√©e √† l'aide d'une politique de file d'attente.  Prenons un exemple. <br><br>  Nous avons deux lignes en miroir.  La file d'attente A se synchronise automatiquement et la file d'attente B manuellement.  Les deux lignes ont chacune dix messages. <br><br><img src="https://habrastorage.org/webt/vz/zm/5x/vzzm5x_2w3tphqi09kn6h_9_e1c.png"><br>  <i>Fig.</i>  <i>8. Deux files d'attente avec diff√©rents modes de synchronisation</i> <br><br>  Maintenant, nous perdons Broker 3. <br><br><img src="https://habrastorage.org/webt/5x/wp/ki/5xwpki1aoj_-e1hdt0i-gswn-nu.png"><br>  <i>Fig.</i>  <i>9. Le courtier 3 est tomb√©</i> <br><br>  Le courtier 3 est de retour en service.  Le cluster cr√©e un miroir pour chaque file d'attente sur le nouveau n≈ìud et synchronise automatiquement la nouvelle file d'attente A avec le ma√Ætre.  Cependant, le miroir du nouveau Turn B reste vide.  Ainsi, nous avons une redondance compl√®te de la file d'attente A et un seul miroir pour les messages existants de la file d'attente B. <br><br><img src="https://habrastorage.org/webt/zo/hb/ha/zohbhaicbgsjdynexgjhuh70ujg.png"><br>  <i>Fig.</i>  <i>10. Le nouveau miroir de la file d'attente A re√ßoit tous les messages existants, mais le nouveau miroir de la file d'attente B ne</i> <br><br>  Les deux lignes re√ßoivent dix messages suppl√©mentaires.  Ensuite, le courtier 2 tombe et la file d'attente A revient au miroir le plus ancien, qui se trouve sur le courtier 1. En cas de d√©faillance, il n'y a pas de perte de donn√©es.  Il y a vingt messages dans la file d'attente B dans l'assistant et seulement dix dans le miroir, car cette file d'attente n'a jamais r√©pliqu√© les dix messages d'origine. <br><br><img src="https://habrastorage.org/webt/yy/hc/sz/yyhcszfowfi6eiidhubgqfy1zry.png"><br>  <i>Fig.</i>  <i>11. La ligne A est restaur√©e vers le courtier 1 sans perdre de messages</i> <br><br>  Les deux lignes re√ßoivent dix messages suppl√©mentaires.  Le courtier 1 se bloque maintenant. La file d'attente A passe au miroir sans aucun probl√®me sans perdre de messages.  Cependant, la file d'attente B a des probl√®mes.  √Ä ce stade, nous pouvons optimiser l'accessibilit√© ou la coh√©rence. <br><br>  Si nous voulons optimiser l'accessibilit√©, la politique <b><i>ha-promotion-on-fail</i></b> doit √™tre d√©finie sur <b><i>toujours</i></b> .  Il s'agit de la valeur par d√©faut, vous pouvez donc tout simplement omettre la strat√©gie.  Dans ce cas, en fait, nous autorisons les √©checs dans les miroirs non synchronis√©s.  Cela entra√Ænera une perte de message, mais la file d'attente reste lisible et inscriptible. <br><br><img src="https://habrastorage.org/webt/4h/hv/_n/4hhv_n4seyvz33pq_sk3my2bnmk.png"><br>  <i>Fig.</i>  <i>12. La ligne A est restaur√©e vers le courtier 3 sans perdre de messages.</i>  <i>La ligne B revient au courtier 3 avec la perte de dix messages</i> <br><br>  Nous pouvons √©galement d√©finir <code>ha-promote-on-failure</code> sur une <code>when-synced</code> .  Dans ce cas, au lieu de revenir au miroir, la file d'attente attendra que le courtier 1 avec ses donn√©es revienne en mode en ligne.  Apr√®s son retour, la file d'attente principale appara√Æt √† nouveau sur le courtier 1 sans perte de donn√©es.  L'accessibilit√© est sacrifi√©e pour la s√©curit√© des donn√©es.  Mais c'est un mode risqu√©, qui peut m√™me conduire √† une perte compl√®te de donn√©es, que nous envisagerons dans un avenir proche. <br><br><img src="https://habrastorage.org/webt/fk/mx/gx/fkmxgxilgyi8bp_n_-osz6q8be0.png"><br>  <i>Fig.</i>  <i>13. La ligne B reste indisponible apr√®s avoir perdu le courtier 1</i> <br><br>  Vous pouvez poser une question: ¬´Peut-√™tre est-il pr√©f√©rable de ne jamais utiliser la synchronisation automatique?¬ª.  La r√©ponse est que la synchronisation est une op√©ration de blocage.  Pendant la synchronisation, la file d'attente principale ne peut effectuer aucune op√©ration de lecture ou d'√©criture! <br><br>  Prenons un exemple.  Nous avons maintenant de tr√®s longues files d'attente.  Comment peuvent-ils atteindre cette taille?  Pour plusieurs raisons: <br><br><ul><li>  Les files d'attente ne sont pas activement utilis√©es. <br></li><li>  Ce sont des lignes √† grande vitesse, et en ce moment, les consommateurs sont lents <br></li><li>  Ce sont des files d'attente √† grande vitesse, une d√©faillance s'est produite et les consommateurs rattrapent leur retard </li></ul><br><img src="https://habrastorage.org/webt/es/6q/gy/es6qgy7p-1cu0avxb1xivijyjii.png"><br>  <i>Fig.</i>  <i>14. Deux grandes files d'attente avec diff√©rents modes de synchronisation</i> <br><br>  Maintenant, Broker 3 plante. <br><br><img src="https://habrastorage.org/webt/vg/ta/ue/vgtauedea7kaitatv7oshzottps.png"><br>  <i>Fig.</i>  <i>15. Le courtier 3 tombe, laissant un ma√Ætre et un miroir dans chaque file d'attente</i> <br><br>  Broker 3 revient et de nouveaux miroirs sont cr√©√©s.  La file d'attente principale A commence √† r√©pliquer les messages existants vers un nouveau miroir et pendant ce temps, la file d'attente A n'est pas disponible.  La r√©plication des donn√©es n√©cessite deux heures, ce qui entra√Æne deux heures d'indisponibilit√© pour cette file d'attente! <br><br>  Cependant, la ligne B reste disponible pendant toute la p√©riode.  Elle a sacrifi√© une certaine redondance pour des raisons d'accessibilit√©. <br><br><img src="https://habrastorage.org/webt/qn/rd/ep/qnrdep5m7sszgxjesb_kfwuw-zw.png"><br>  <i>Fig.</i>  <i>16. La file d'attente reste indisponible pendant la synchronisation</i> <br><br>  Apr√®s deux heures, la file d'attente A devient √©galement disponible et peut recommencer √† accepter les op√©rations de lecture et d'√©criture. <br><br><h3>  Mises √† jour </h3><br>  Ce comportement de blocage lors de la synchronisation rend difficile la mise √† niveau des clusters avec de tr√®s grandes files d'attente.  √Ä un moment donn√©, le n≈ìud avec l'assistant doit √™tre red√©marr√©, ce qui signifie soit basculer vers le miroir soit d√©sactiver la file d'attente lors de la mise √† jour du serveur.  Si nous choisissons une transition, nous perdrons des messages si les miroirs ne sont pas synchronis√©s.  Par d√©faut, lors de la d√©connexion du courtier, la transition vers un miroir non synchronis√© n'est pas effectu√©e.  Cela signifie que d√®s que le courtier revient, nous ne perdons aucun message, le seul dommage √©tait seulement une simple file d'attente.  La d√©sactivation des courtiers est r√©gie par la politique <code>ha-promote-on-shutdown</code> .  Vous pouvez d√©finir l'une des deux valeurs: <br><br><ul><li>  <code>always</code> = basculement activ√© vers des miroirs non synchronis√©s <br></li><li>  <code>when-synced</code> = basculer uniquement vers le miroir synchronis√©, sinon la file d'attente devient inaccessible pour la lecture et l'√©criture.  La file d'attente revient d√®s que le courtier revient </li></ul><br>  D'une mani√®re ou d'une autre, avec de grandes files d'attente, vous devez choisir entre la perte de donn√©es et l'inaccessibilit√©. <br><br><h3>  Quand la disponibilit√© am√©liore la s√©curit√© des donn√©es </h3><br>  Avant de prendre une d√©cision, une complication suppl√©mentaire doit √™tre prise en compte.  Bien que la synchronisation automatique soit meilleure pour la redondance, comment affecte-t-elle la s√©curit√© des donn√©es?  Bien s√ªr, gr√¢ce √† une meilleure redondance, RabbitMQ est moins susceptible de perdre des messages existants, mais qu'en est-il des nouveaux messages des √©diteurs? <br><br>  Ici, vous devez prendre en compte les √©l√©ments suivants: <br><ul><li>  Un √©diteur peut-il simplement renvoyer une erreur et un service ou un utilisateur sup√©rieur r√©essaiera plus tard? <br></li><li>  Un √©diteur peut-il enregistrer un message localement ou dans une base de donn√©es pour r√©essayer plus tard? </li></ul><br>  Si l'√©diteur ne peut que supprimer le message, alors, en fait, l'am√©lioration de l'accessibilit√© augmente √©galement la s√©curit√© des donn√©es. <br><br>  Ainsi, vous devez rechercher un √©quilibre et la d√©cision d√©pend de la situation sp√©cifique. <br><br><h1>  Probl√®mes avec ha-promo-on-failure = lors de la synchronisation </h1><br>  L'id√©e de <i><b>ha-promo-on-failure</b></i> = <i><b>lors de la synchronisation</b></i> est que nous emp√™chons de basculer vers un miroir non synchronis√© et √©vitons ainsi la perte de donn√©es.  La file d'attente reste inaccessible pour la lecture ou l'√©criture.  Au lieu de cela, nous essayons de renvoyer un courtier tomb√© en panne avec des donn√©es intactes afin qu'il reprenne le travail en tant que ma√Ætre sans perte de donn√©es. <br><br>  Mais (et c'est gros mais) si le courtier a perdu ses donn√©es, alors nous avons un gros probl√®me: la file d'attente est perdue!  Toutes les donn√©es ont disparu!  M√™me si vous disposez de miroirs qui rattrapent essentiellement la file d'attente principale, ces miroirs sont √©galement supprim√©s. <br><br>  Pour rajouter un n≈ìud avec le m√™me nom, nous demandons au cluster d'oublier le n≈ìud perdu (avec la <i>commande rabbitmqctl oublie_cluster_node</i> ) et d√©marre un nouveau courtier avec le m√™me nom d'h√¥te.  Tant que le cluster se souvient du n≈ìud perdu, il se souvient de l'ancienne file d'attente et des miroirs non synchronis√©s.  Lorsqu'un cluster est invit√© √† oublier un n≈ìud perdu, cette file d'attente est √©galement oubli√©e.  Vous devez maintenant le d√©clarer √† nouveau.  Nous avons perdu toutes les donn√©es, bien que nous disposions de miroirs avec un ensemble de donn√©es partiel.  Il serait pr√©f√©rable de passer √† un miroir non synchronis√©! <br><br>  Par cons√©quent, √† mon avis, la synchronisation manuelle (et l'√©chec de la synchronisation) en combinaison avec <code>ha-promote-on-failure=when-synced</code> est assez risqu√©e.  Les documents disent que cette option existe pour la s√©curit√© des donn√©es, mais c'est un couteau √† double tranchant. <br><br><h1>  R√©√©quilibrer les Masters </h1><br>  Comme promis, nous revenons au probl√®me de l'accumulation de tous les ma√Ætres sur un ou plusieurs n≈ìuds.  Cela peut se produire m√™me √† la suite de mises √† jour continues de cluster.  Dans un cluster √† trois n≈ìuds, toutes les files d'attente principales s'accumuleront sur un ou deux n≈ìuds. <br><br>  Le r√©√©quilibrage des ma√Ætres peut √™tre probl√©matique pour deux raisons: <br><br><ul><li>  Pas de bons outils de r√©√©quilibrage </li><li>  Synchronisation de file d'attente </li></ul><br>  Pour le r√©√©quilibrage, il existe un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plugin</a> tiers qui n'est pas officiellement pris en charge.  Concernant les plug-ins tiers, le manuel RabbitMQ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dit</a> : ¬´Le plug-in fournit des outils de configuration et de reporting suppl√©mentaires, mais il n'est pas pris en charge et non test√© par l'√©quipe RabbitMQ.  Utilisez √† vos risques et p√©rils. " <br><br>  Il existe une autre astuce pour d√©placer la file d'attente principale via des strat√©gies HA.  Le manuel mentionne un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">script</a> pour cela.  Cela fonctionne comme suit: <br><br><ul><li>  Supprime tous les miroirs utilisant une strat√©gie temporaire avec une priorit√© plus √©lev√©e que la strat√©gie HA existante. <br></li><li>  Modifie la strat√©gie temporaire HA pour utiliser le mode n≈ìuds avec le n≈ìud vers lequel la file d'attente principale doit √™tre d√©plac√©e. <br></li><li>  Synchronise la file d'attente pour la migration forc√©e. <br></li><li>  Une fois la migration termin√©e, supprime la strat√©gie temporaire.  La strat√©gie initiale HA entre en vigueur et le nombre de miroirs requis est cr√©√©. </li></ul><br>  L'inconv√©nient est que cette approche peut ne pas fonctionner si vous avez de grandes files d'attente ou des exigences de redondance strictes. <br><br>  Voyons maintenant comment les clusters RabbitMQ fonctionnent avec les partitions r√©seau. <br><br><h1>  Perturbation de la connectivit√© </h1><br>  Les n≈ìuds d'un syst√®me distribu√© sont connect√©s par des liaisons r√©seau, et les liaisons r√©seau peuvent et seront d√©connect√©es.  La fr√©quence des pannes d√©pend de l'infrastructure locale ou de la fiabilit√© du cloud s√©lectionn√©.  Dans tous les cas, les syst√®mes distribu√©s devraient pouvoir les g√©rer.  Encore une fois, nous avons le choix entre l'accessibilit√© et la coh√©rence, et encore une fois, la bonne nouvelle est que RabbitMQ fournit les deux (mais pas en m√™me temps). <br><br>  Avec RabbitMQ, nous avons deux options principales: <br><br><ul><li>  Autoriser la s√©paration logique (split-brain).  Cela fournit l'accessibilit√©, mais peut entra√Æner une perte de donn√©es. <br></li><li>  Interdisez la s√©paration logique.  Peut entra√Æner une perte de disponibilit√© √† court terme selon la fa√ßon dont les clients se connectent au cluster.  Cela peut √©galement conduire √† une inaccessibilit√© compl√®te dans un cluster de deux n≈ìuds. </li></ul><br>  Mais qu'est-ce que la s√©paration logique?  C'est lorsqu'un cluster est divis√© en deux en raison de la perte de connexions r√©seau.  De chaque c√¥t√©, les r√©troviseurs montent vers le ma√Ætre, donc au final, il y a plusieurs ma√Ætres √† chaque tour. <br><br><img src="https://habrastorage.org/webt/mi/4f/bb/mi4fbbuk9maj487alkqsbbykkns.png"><br>  <i>Fig.</i>  <i>17. La ligne principale et deux miroirs, chacun sur un n≈ìud distinct.</i>  <i>Ensuite, une panne de r√©seau se produit et un miroir se s√©pare.</i>  <i>Le n≈ìud d√©tach√© voit que les deux autres sont tomb√©s et avance ses miroirs au ma√Ætre.</i>  <i>Nous avons maintenant deux lignes principales, et les deux permettent l'√©criture et la lecture.</i> <br><br>  Si les √©diteurs envoient des donn√©es aux deux ma√Ætres, nous obtenons deux copies divergentes de la file d'attente. <br><br>  Les diff√©rents modes RabbitMQ offrent soit l'accessibilit√© soit la coh√©rence. <br><br><h3>  Ignorer le mode (par d√©faut) </h3><br>  Ce mode fournit l'accessibilit√©.  Apr√®s la perte de connectivit√©, une s√©paration logique se produit.  Apr√®s la reconnexion, l'administrateur doit d√©cider quelle partition pr√©f√©rer.  Le c√¥t√© perdant sera red√©marr√© et toutes les donn√©es accumul√©es de ce c√¥t√© seront perdues. <br><br><img src="https://habrastorage.org/webt/ih/rj/ow/ihrjow-ceolx0wy8y2o-cn2yiuk.png"><br>  <i>Fig.</i>  <i>18. Trois √©diteurs sont associ√©s √† trois courtiers.</i>  <i>En interne, le cluster transf√®re toutes les demandes √† la file d'attente principale sur Broker 2.</i> <br><br>  Maintenant, nous perdons le courtier 3. Il voit que d'autres courtiers sont tomb√©s et d√©place son miroir vers le ma√Ætre.  C'est la s√©paration logique. <br><br><img src="https://habrastorage.org/webt/u_/l8/af/u_l8af-qqcyv4ldqdgwrn4t22ei.png"><br>  <i>Fig.</i>  <i>19. S√©paration logique (split-brain).</i>  <i>Les enregistrements vont sur deux lignes principales et deux copies divergent.</i> <br><br>  La connectivit√© est restaur√©e, mais la s√©paration logique demeure.  L'administrateur doit s√©lectionner manuellement le c√¥t√© perdant.  Dans le cas suivant, l'administrateur red√©marre Broker 3. Tous les messages qu'il n'a pas r√©ussi √† transmettre sont perdus. <br><br><img src="https://habrastorage.org/webt/_o/a9/ft/_oa9ftbuvl6dwnewtgfkrhkyva4.png"><br>  <i>Fig.</i>  <i>20. L'administrateur d√©sactive Broker 3.</i> <br><br><img src="https://habrastorage.org/webt/ni/y_/xq/niy_xqsgzuvf5ktcta35z98zzxs.png"><br>  <i>Fig.</i>  <i>21. L'administrateur d√©marre Broker 3 et il rejoint le cluster, perdant tous les messages qui y sont rest√©s.</i> <br><br>  Pendant la perte de connectivit√© et apr√®s sa restauration, le cluster et cette file d'attente √©taient disponibles pour la lecture et l'√©criture. <br><br><h3>  Mode Autoheal </h3><br>  Il fonctionne de mani√®re similaire au mode Ignorer, sauf que le cluster lui-m√™me s√©lectionne automatiquement le c√¥t√© perdant apr√®s la division et la restauration de la connectivit√©.  Le c√¥t√© perdant revient au cluster vide et la file d'attente perd tous les messages qui ont √©t√© envoy√©s uniquement √† ce c√¥t√©. <br><br><h3>  Pause du mode minoritaire </h3><br>  Si nous ne voulons pas autoriser la s√©paration logique, alors notre seule option est de refuser de lire et d'√©crire sur le petit c√¥t√© apr√®s la partition du cluster.  Quand un courtier voit qu'il est du c√¥t√© inf√©rieur, il fait une pause, c'est-√†-dire, ferme toutes les connexions existantes et refuse toutes les nouvelles.  Une fois par seconde, il v√©rifie la reconnexion.  Une fois la connectivit√© restaur√©e, elle reprend son travail et rejoint le cluster. <br><br><img src="https://habrastorage.org/webt/xl/cc/af/xlccafaylyx2nrsz5scaafo1h6u.png"><br>  <i>Fig.</i>  <i>22. Trois √©diteurs sont associ√©s √† trois courtiers.</i>  <i>En interne, le cluster transf√®re toutes les demandes √† la file d'attente principale sur Broker 2.</i> <br><br>  Les courtiers 1 et 2 sont ensuite s√©par√©s du courtier 3. Au lieu de mettre √† niveau leur miroir en ma√Ætre, le courtier 3 s'arr√™te et devient inaccessible. <br><br><img src="https://habrastorage.org/webt/8h/0_/hc/8h0_hc8vj99u6zaht7cgymlckve.png"><br>  <i>Fig.</i>  <i>23. Le courtier 3 interrompt, d√©connecte tous les clients et rejette les demandes de connexion.</i> <br><br>  Une fois la connectivit√© restaur√©e, elle revient au cluster. <br><br>  Regardons un autre exemple, o√π la ligne principale se trouve sur Broker 3. <br><br><img src="https://habrastorage.org/webt/rs/0s/if/rs0siffyxwpdc8imasvfvkapykw.png"><br>  <i>Fig.</i>  <i>24. La ligne principale au courtier 3.</i> <br><br>  Ensuite, la m√™me perte de connectivit√© se produit.  Le courtier 3 fait une pause car il est plus petit.  De l'autre c√¥t√©, les n≈ìuds voient que le courtier 3 est tomb√©, de sorte que l'ancien miroir des courtiers 1 et 2 monte vers le ma√Ætre. <br><br><img src="https://habrastorage.org/webt/ba/o3/gr/bao3gr7y31x5ljbbpkqkretaaty.png"><br>  <i>Fig.</i>  <i>25. Transition vers le courtier 2 si le courtier 3 n'est pas disponible.</i> <br><br>  Une fois la connectivit√© restaur√©e, Broker 3 se joindra au cluster. <br><br><img src="https://habrastorage.org/webt/3z/rp/3k/3zrp3knvfoew7m25bg6bg4dlhju.png"><br>  <i>Fig.</i>  <i>26. Le cluster est revenu √† un fonctionnement normal.</i> <br><br>  Il est important de comprendre que nous obtenons de la coh√©rence, mais nous pouvons √©galement obtenir l'accessibilit√© <i><b>si nous</b></i> r√©ussissons √† transf√©rer des clients vers la majeure partie de la section.  Pour la plupart des situations, je choisirais personnellement le mode Pause minoritaire, mais cela d√©pend vraiment du cas particulier. <br><br>  Pour garantir la disponibilit√©, il est important de s'assurer que les clients se connectent avec succ√®s au site.  Consid√©rez nos options. <br><br><h1>  Connectivit√© client </h1><br>  Nous avons plusieurs options pour savoir comment, apr√®s avoir perdu la connectivit√©, envoyer des clients vers la partie principale du cluster ou vers des n≈ìuds de travail (apr√®s une d√©faillance d'un n≈ìud).  Tout d'abord, rappelons qu'une file d'attente particuli√®re est h√©berg√©e sur un h√¥te particulier, mais le routage et les politiques sont r√©pliqu√©s sur tous les h√¥tes.  Les clients peuvent se connecter √† n'importe quel n≈ìud et le routage interne les dirigera si n√©cessaire.  Mais lorsqu'un n≈ìud est suspendu, il rejette la connexion, les clients doivent donc se connecter √† un autre n≈ìud.  Si un n≈ìud tombe, il ne peut rien faire du tout. <br><br>  Nos options: <br><br><ul><li>  Le cluster est accessible √† l'aide d'un √©quilibreur de charge, qui parcourt simplement les n≈ìuds et les clients tentent √† plusieurs reprises de se connecter jusqu'√† ce qu'ils soient termin√©s avec succ√®s.      ,        ,        (  ).         ,    . <br></li><li>         /   ,    .    ,        ,     . <br></li><li>      ,          .       ,       ,   . <br></li><li>    /    DNS.      TTL. </li></ul><br><h1>  Conclusions </h1><br>   RabbitMQ    .      , : <br><br><ul><li>        ; <br></li><li>      . </li></ul><br>         .   RabbitMQ      ,     .        ,     .         RabbitMQ        .      RabbitMQ     : <br><br><ul><li>  . <br></li><li>  . <br></li><li>   . </li></ul><br>      ,   : <br><br><ul><li> <code>ha-promote-on-failure=always</code> <br> </li><li> <code>ha-sync-mode=manual</code> <br> </li><li> <code>cluster_partition_handling=ignore</code> ( <code>autoheal</code> ) <br></li><li>   <br></li><li> ,      ,  -     </li></ul><br>   ( )   : <br><br><ul><li> Publisher Confirms  Manual Acknowledgements    <br></li><li> <code>ha-promote-on-failure=when-synced</code> ,              !   <code>=always</code> . <br></li><li> <code>ha-sync-mode=automatic</code> (        ;  , ,       ) <br></li><li>  Pause Minority <br></li><li>   </li></ul><br>          ; ,      (,   ).        Shovel. <br><br>    - , ,  . <br><br> .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> ,       RabbitMQ   Docker  Blockade,      ,    . <br><br>   : <br> ‚Ññ1 ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">habr.com/ru/company/itsumma/blog/416629</a> <br> ‚Ññ2 ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">habr.com/ru/company/itsumma/blog/418389</a> <br> ‚Ññ3 ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">habr.com/ru/company/itsumma/blog/437446</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr471858/">https://habr.com/ru/post/fr471858/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr471840/index.html">Pourquoi aller aux interviews</a></li>
<li><a href="../fr471844/index.html">5 raisons de visiter EPAM INSIDER au Kazakhstan</a></li>
<li><a href="../fr471852/index.html">Nouvelles du monde d'OpenStreetMap n ¬∞ 481 (10/01/2019 - 07/10/2019)</a></li>
<li><a href="../fr471854/index.html">Heat Death 5G</a></li>
<li><a href="../fr471856/index.html">Nous r√©solvons les 42 versions du puzzle de potion Harry Potter</a></li>
<li><a href="../fr471860/index.html">Analyseurs de cheville</a></li>
<li><a href="../fr471862/index.html">Impl√©mentation de l'analyseur PEG</a></li>
<li><a href="../fr471864/index.html">G√©n√©ration de l'analyseur PEG</a></li>
<li><a href="../fr471866/index.html">Visualisation de l'analyseur PEG</a></li>
<li><a href="../fr471868/index.html">G√©n√©tique de l'amour: le conflit entre les sexes comme base de coop√©ration dans des couples d'oiseaux monogames</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>