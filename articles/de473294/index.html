<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì£ üé£ üë®üèø‚Äçüéì Speicherverwaltung oder seltener schie√üen Sie sich in den Fu√ü ‚õΩÔ∏è üîÄ üè£</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo habr In diesem Artikel werde ich versuchen zu erkl√§ren, was Speicherverwaltung in Programmen / Anwendungen aus der Sicht eines Anwendungsprogram...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Speicherverwaltung oder seltener schie√üen Sie sich in den Fu√ü</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473294/"><p>  Hallo habr  In diesem Artikel werde ich versuchen zu erkl√§ren, was Speicherverwaltung in Programmen / Anwendungen aus der Sicht eines Anwendungsprogrammierers ist.  Dies ist keine vollst√§ndige Anleitung oder Anleitung, sondern lediglich eine √úbersicht √ºber vorhandene Probleme und einige L√∂sungsans√§tze. </p><br><p>  Warum ist das notwendig?  Ein Programm ist eine Folge von Datenverarbeitungsanweisungen (im allgemeinsten Fall).  Diese Daten m√ºssen auf irgendeine Weise <strong>gespeichert</strong> , <strong>geladen</strong> , <strong>√ºbertragen</strong> usw. werden.  Alle diese Vorg√§nge werden nicht sofort ausgef√ºhrt, daher wirken sie sich direkt auf die Geschwindigkeit Ihrer endg√ºltigen Anwendung aus.  Die F√§higkeit, Daten w√§hrend des Arbeitsprozesses optimal zu verwalten, erm√∂glicht es Ihnen, sehr nicht triviale und sehr ressourcenintensive Programme zu erstellen. </p><br><p>  Hinweis: Der Gro√üteil des Materials wird mit Beispielen aus Spielen / Spiele-Engines pr√§sentiert (da dieses Thema f√ºr mich pers√∂nlich interessanter ist). Der gr√∂√üte Teil des Materials kann jedoch zum Schreiben von Servern, Benutzeranwendungen, Grafikpaketen usw. verwendet werden. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f13/ef3/482/f13ef3482dfe066b41b53e44179a0242.jpg"></p><br><p>  <em>Es ist unm√∂glich, alles im Auge zu behalten.</em>  <em>Wenn Sie es jedoch nicht geschafft haben, es zu laden, erhalten Sie Seife</em> </p><a name="habracut"></a><br><h1 id="s-mesta-v-karer">  Auf Anhieb </h1><br><p>  In der Branche kam es vor, dass gro√üe AAA-Spielprojekte haupts√§chlich auf Engines entwickelt wurden, die mit C ++ geschrieben wurden.  Eines der Merkmale dieser Sprache ist die Notwendigkeit einer manuellen Speicherverwaltung.  Java / C # usw.  Sie verf√ºgen √ºber Garbage Collection (GarbageCollection / GC) - die F√§higkeit, Objekte zu erstellen und dennoch nicht den verwendeten Speicher von Hand freizugeben.  Dieser Prozess vereinfacht und beschleunigt die Entwicklung, kann aber auch einige Probleme verursachen: Ein periodisch ausgel√∂ster Garbage Collector kann alle Soft-Echtzeit-Aktionen beenden und dem Spiel unangenehme Einfrierungen hinzuf√ºgen. </p><br><p>  Ja, in Projekten wie "Minecraft" ist der GC m√∂glicherweise nicht erkennbar  Sie stellen im Allgemeinen keine hohen Anforderungen an die Ressourcen des Computers, aber Spiele wie "Red Dead Redemption 2", "God of War" und "Last of Us" arbeiten "fast" auf dem H√∂hepunkt der Systemleistung und m√ºssen daher nicht nur gro√ü sein die Menge der Ressourcen, aber auch in ihrer kompetenten Verteilung. </p><br><p>  Wenn Sie in einer Umgebung mit automatischer Speicherzuweisung und Speicherbereinigung arbeiten, kann es au√üerdem zu mangelnder Flexibilit√§t bei der Verwaltung von Ressourcen kommen.  Es ist kein Geheimnis, dass Java alle Implementierungsdetails und Aspekte seiner Arbeit unter der Haube verbirgt. Am Ausgang haben Sie also nur die installierte Schnittstelle f√ºr die Interaktion mit Systemressourcen, aber es reicht m√∂glicherweise nicht aus, um einige Probleme zu l√∂sen.  Das Starten eines Algorithmus mit einer nicht konstanten Anzahl von Speicherzuweisungen in jedem Frame (dies kann eine Suche nach Pfaden f√ºr KI, √úberpr√ºfen der Sichtbarkeit, Animation usw. sein) f√ºhrt unweigerlich zu einem katastrophalen Leistungsabfall. </p><br><h1 id="kak-vyglyadyat-allokacii-v-kode">  Wie Zuordnungen im Code aussehen </h1><br><p>  Bevor ich die Diskussion fortsetze, m√∂chte ich anhand einiger Beispiele zeigen, wie die Arbeit mit dem Speicher in C / C ++ direkt abl√§uft.  Im Allgemeinen wird die standardm√§√üige und einfachste Schnittstelle zum Zuweisen von Prozessspeicher durch die folgenden Operationen dargestellt: </p><br><pre><code class="plaintext hljs">//        size  void* malloc(size_t size); //      p void free(void* p);</code> </pre> <br><p>  Hier k√∂nnen Sie weitere Funktionen hinzuf√ºgen, mit denen Sie einen ausgerichteten Speicherplatz zuweisen k√∂nnen: </p><br><pre> <code class="plaintext hljs">// C11  -     , * alignment void* aligned_alloc(size_t size, size_t alignment); // Posix  -       //        address (*address = allocated_mem_p) int posix_memalign(void** address, size_t alignment, size_t size);</code> </pre> <br><p>  Bitte beachten Sie, dass verschiedene Plattformen m√∂glicherweise unterschiedliche Funktionsstandards unterst√ºtzen, die beispielsweise unter macOS und unter win nicht verf√ºgbar sind. </p><br><p>  Mit Blick auf die Zukunft sind m√∂glicherweise <strong>speziell</strong> ausgerichtete Speicherbereiche erforderlich, damit Sie sowohl die Prozessor-Cache-Zeile erreichen als auch Berechnungen mit einem erweiterten Registersatz ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SSE</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MMX</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AVX</a> usw.) durchf√ºhren k√∂nnen. </p><br><p>  Ein Beispiel f√ºr ein Spielzeugprogramm, das Speicher zuweist, Pufferwerte druckt und diese als vorzeichenbehaftete Ganzzahlen interpretiert: </p><br><pre> <code class="plaintext hljs">/* main.cpp */ #include &lt;cstdio&gt; #include &lt;cstdlib&gt; int main(int argc, char** argv) { const int N = 10; int* buffer = (int*) malloc(sizeof(int) * N); for(int i = 0; i &lt; N; i++) { printf("%i ", buffer[i]); } free(buffer); return 0; }</code> </pre> <br><p>  Unter macOS 10.14 kann dieses Programm mit den folgenden Befehlen erstellt und ausgef√ºhrt werden: </p><br><pre> <code class="plaintext hljs">$ clang++ main.cpp -o main $ ./main</code> </pre> <br><p>  Hinweis: Im Folgenden m√∂chte ich C ++ - Operationen wie new / delete nicht wirklich behandeln, da sie eher zum direkten Erstellen / Zerst√∂ren von Objekten verwendet werden, aber sie verwenden die √ºblichen Operationen mit Speicher wie malloc / free. </p><br><h1 id="problemy-s-pamyatyu">  Speicherprobleme </h1><br><p>  Bei der Arbeit mit dem RAM des Computers treten verschiedene Probleme auf.  Alle auf die eine oder andere Weise werden nicht nur durch die Funktionen des Betriebssystems und der Software verursacht, sondern auch durch die Architektur des B√ºgeleisens, auf dem all diese Dinge funktionieren. </p><br><h3 id="1-kolichestvo-pamyati">  1. Speicherplatz </h3><br><p>  Leider ist der Speicher physisch begrenzt.  Auf der PlayStation 4 sind dies 8 GiB GDDR5, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von denen 3,5 GiB das Betriebssystem f√ºr seine Bed√ºrfnisse reserviert</a> .  Der Austausch von virtuellem Speicher und Seiten hilft nicht viel, da das Austauschen von Seiten auf die Festplatte ein sehr langsamer Vorgang ist (innerhalb von festen N Bildern pro Sekunde, wenn es um Spiele geht). </p><br><p>  Erw√§hnenswert ist auch das begrenzte " <em>Budget</em> " - eine k√ºnstliche Begrenzung der verwendeten Speichermenge, die erstellt wird, um die Anwendung auf mehreren Plattformen auszuf√ºhren.  Wenn Sie ein Spiel f√ºr eine mobile Plattform erstellen und nicht nur eines, sondern eine ganze Reihe von Ger√§ten unterst√ºtzen m√∂chten, m√ºssen Sie Ihren Appetit einschr√§nken, um einen breiteren Absatzmarkt zu schaffen.  Dies kann sowohl durch einfaches Begrenzen des RAM-Verbrauchs als auch durch die M√∂glichkeit erreicht werden, diese Einschr√§nkung abh√§ngig vom Gadget zu konfigurieren, auf dem das Spiel tats√§chlich startet. </p><br><h3 id="2-fragmentaciya">  2. Fragmentierung </h3><br><p>  Ein unangenehmer Effekt, der w√§hrend des Prozesses der mehrfachen Zuordnung von Speicherst√ºcken unterschiedlicher Gr√∂√üe auftritt.  Als Ergebnis erhalten Sie einen Adressraum, der in viele separate Teile fragmentiert ist.  Das Kombinieren dieser Teile zu einzelnen Bl√∂cken gr√∂√üerer Gr√∂√üe funktioniert nicht, da ein Teil des Speichers belegt ist und wir ihn nicht frei bewegen k√∂nnen. </p><br><p><img src="https://habrastorage.org/webt/8f/un/ie/8funiekbmroqz6xqhdpsyrpovcs.png"><br>  Fragmentierung am Beispiel sequentieller Zuordnungen und Freigaben von Speicherbl√∂cken </p><br><p>  Als Ergebnis: Wir k√∂nnen quantitativ, aber nicht qualitativ genug freien Speicher haben.  Und bei der n√§chsten Anforderung, beispielsweise "Speicherplatz f√ºr die Audiospur zuweisen", kann der Zuweiser diese nicht erf√ºllen, da es einfach kein einzelnes Speicherelement dieser Gr√∂√üe gibt. </p><br><h3 id="3-kesh-processora">  3. CPU-Cache </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e9d/592/5e5/e9d5925e5a0fc9629656ead20ce91b36.png"><br>  Computerspeicherhierarchie </p><br><p>  Der Cache eines modernen Prozessors ist eine Zwischenverbindung, die den Hauptspeicher (RAM) und die Prozessorregister direkt verbindet.  Es kam vor, dass der Lese- / Schreibzugriff auf den Speicher eine sehr langsame Operation ist (wenn wir √ºber die Anzahl der zur Ausf√ºhrung erforderlichen CPU-Taktzyklen sprechen).  Daher gibt es eine Cache-Hierarchie (L1, L2, L3 usw.), die es sozusagen "gem√§√ü einer Vorhersage" erm√∂glicht, Daten aus dem RAM zu laden oder sie langsam in einen langsameren Speicher zu verschieben. </p><br><p>  Durch das Platzieren von Objekten desselben Typs in einer Zeile im Speicher k√∂nnen Sie den Verarbeitungsprozess "erheblich" beschleunigen (wenn die Verarbeitung nacheinander erfolgt), da in diesem Fall leichter vorhergesagt werden kann, welche Daten als N√§chstes ben√∂tigt werden.  Und mit "signifikant" sind manchmal Produktivit√§tssteigerungen gemeint.  Die Entwickler der Unity-Engine haben in ihren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Berichten bei der GDC</a> wiederholt dar√ºber gesprochen. </p><br><h3 id="4-multi-threading">  4. Multithreading </h3><br><p>  <strong>Das Sicherstellen eines sicheren Zugriffs auf gemeinsam genutzten Speicher in einer Umgebung mit mehreren Threads</strong> ist eines der Hauptprobleme, die Sie l√∂sen m√ºssen, wenn Sie Ihre eigene Spiel-Engine / Spiel / jede andere Anwendung erstellen, die mehrere Threads verwendet, um eine h√∂here Leistung zu erzielen.  Moderne Computer sind sehr trivial angeordnet.  Wir haben sowohl eine komplexe Cache-Struktur als auch mehrere Taschenrechner-Kerne.  All dies kann bei unsachgem√§√üer Verwendung zu Situationen f√ºhren, in denen die gemeinsam genutzten Daten Ihres Prozesses durch mehrere Threads besch√§digt werden (wenn sie gleichzeitig versuchen, mit diesen Daten ohne Zugriffskontrolle zu arbeiten).  Im einfachsten Fall sieht es so aus: <br><img src="https://habrastorage.org/webt/sl/dm/2y/sldm2ybotnk9ncozwf5rkgozifw.png"><br>  Ich m√∂chte mich nicht mit dem Thema Multithread-Programmierung befassen, da viele seiner Aspekte sehr weit √ºber den Rahmen des Artikels oder sogar des gesamten Buches hinausgehen. </p><br><h3 id="5-mallocfree">  5. Malloc / frei </h3><br><p>  Zuordnungs- / Freigabevorg√§nge werden nicht sofort ausgef√ºhrt.  Unter modernen Betriebssystemen sind Windows / Linux / MacOS gut implementiert und funktionieren <em>in den meisten Situationen schnell</em> .  Dies ist jedoch m√∂glicherweise ein sehr zeitaufw√§ndiger Vorgang.  Dies ist nicht nur ein Systemaufruf, sondern es kann je nach Implementierung eine Weile dauern, bis ein geeigneter Speicherplatz (First Fit, Best Fit usw.) gefunden oder ein Platz zum Einf√ºgen und / oder Zusammenf√ºhren des freigegebenen Bereichs gefunden wurde. </p><br><p>  Dar√ºber hinaus wird der frisch zugewiesene Speicher m√∂glicherweise nicht auf reale physische Seiten abgebildet, was auch beim ersten Zugriff einige Zeit in Anspruch nehmen kann. </p><br><p>  Dies sind Implementierungsdetails, aber was ist mit der Anwendbarkeit?  Malloc / new haben keine Ahnung, wo, wie oder warum Sie sie angerufen haben.  Sie weisen (im schlimmsten Fall) Speicher von 1 KiB und 100 MiB gleicherma√üen zu ... gleich schlecht.  Die Verwendungsstrategie bleibt direkt entweder dem Programmierer oder demjenigen √ºberlassen, der die Laufzeit Ihres Programms implementiert hat. </p><br><h3 id="6-memory-corruption">  6. Speicherbesch√§digung </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie das Wiki sagt</a> , ist dies einer der unvorhersehbarsten Fehler, der nur im Verlauf des Programms auftritt und meistens direkt durch Fehler beim Schreiben dieses Programms verursacht wird.  Aber was ist das f√ºr ein Problem?  Gl√ºcklicherweise (oder leider) h√§ngt es nicht mit der Besch√§digung Ihres Computers zusammen.  Es wird vielmehr eine Situation angezeigt, in der Sie versuchen, mit Speicher zu arbeiten <em>, der Ihnen nicht geh√∂rt</em> .  Ich werde jetzt erkl√§ren: </p><br><ol><li>  Dies kann ein Versuch sein, in einen Teil des nicht zugewiesenen Speichers zu lesen / schreiben. </li><li>  √úber die Grenzen des f√ºr Sie bereitgestellten Speicherblocks hinausgehen.  Dieses Problem ist eine Art Sonderfall des Problems (1), aber es ist schlimmer, weil das System Ihnen mitteilt, dass Sie die Grenzen nur √ºberschritten haben, wenn Sie die f√ºr Sie angezeigte Seite verlassen.  Das hei√üt, dieses Problem ist m√∂glicherweise sehr schwer zu erkennen, da das Betriebssystem nur dann reagieren kann, wenn Sie die Grenzen der angezeigten virtuellen Seiten belassen.  Sie k√∂nnen den Prozessspeicher verderben und einen sehr seltsamen Fehler an der Stelle erhalten, von der er √ºberhaupt nicht erwartet wurde. </li><li>  Freigeben eines bereits freigegebenen (klingt seltsam) oder noch nicht zugewiesenen Speichers </li><li>  usw. </li></ol><br><p>  In C / C ++, wo es Zeigerarithmetik gibt, werden Sie ein- oder zweimal darauf sto√üen.  In Java Runtime muss man jedoch ziemlich stark schwitzen, um diese Art von Fehler zu bekommen (ich habe es nicht selbst versucht, aber ich denke, dass dies m√∂glich ist, sonst w√§re das Leben zu einfach). </p><br><h3 id="7-utechki-pamyati">  7. Speicherlecks </h3><br><p>  Es ist ein Sonderfall eines allgemeineren Problems, das in vielen Programmiersprachen auftritt.  Die Standard-C / C ++ - Bibliothek bietet Zugriff auf Betriebssystemressourcen.  Dies k√∂nnen Dateien, Sockets, Speicher usw. sein.  Nach der Verwendung muss die Ressource korrekt geschlossen sein und <br>  Die von ihm besetzte Erinnerung sollte befreit werden.  Und wenn wir speziell √ºber die Freigabe von Speicher sprechen - akkumulierte Lecks infolge des Programms k√∂nnen zu einem Fehler "Nicht gen√ºgend Speicher" f√ºhren, wenn das Betriebssystem die n√§chste Zuweisungsanforderung nicht erf√ºllen kann.  Oft vergisst der Entwickler einfach, den verwendeten Speicher aus dem einen oder anderen Grund freizugeben. </p><br><p>  Hier lohnt es sich, etwas √ºber das korrekte Schlie√üen und Freigeben von Ressourcen auf der GPU hinzuzuf√ºgen, da die fr√ºhen Treiber die Arbeit mit der Grafikkarte nicht wieder aufnehmen konnten, wenn die vorherige Sitzung nicht korrekt abgeschlossen wurde.  Nur ein Neustart des Systems k√∂nnte dieses Problem l√∂sen, was sehr zweifelhaft ist - den Benutzer zu zwingen, das System nach dem Ausf√ºhren Ihrer Anwendung neu zu starten. </p><br><h3 id="8-dangling-pointer">  8. Baumelnder Zeiger </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>Ein baumelnder Zeiger</strong></a> ist eine Fachsprache, die eine Situation beschreibt, in der ein Zeiger auf einen ung√ºltigen Wert verweist.  Eine √§hnliche Situation kann leicht auftreten, wenn klassische C-Zeiger in einem C / C ++ - Programm verwendet werden.  Angenommen, Sie haben Speicher zugewiesen, die Adresse im p-Zeiger gespeichert und dann den Speicher freigegeben (siehe Codebeispiel): </p><br><pre> <code class="plaintext hljs">//   void* p = malloc(size); // ...  -    //   free(p); //    p? // *p == ?</code> </pre> <br><p>  Der Zeiger speichert einen Wert, den wir als Adresse des Speicherblocks interpretieren k√∂nnen.  Es ist also passiert, dass wir nicht sagen k√∂nnen, ob dieser Speicherblock g√ºltig ist oder nicht.  Nur ein Programmierer, der auf bestimmten Vereinbarungen basiert, kann mit einem Zeiger arbeiten.  Beginnend mit C ++ 11 wurden eine Reihe zus√§tzlicher ‚Äûintelligenter Zeiger‚Äú in die Standardbibliothek aufgenommen, die es dem Programmierer auf irgendeine Weise erm√∂glichen, die Ressourcensteuerung zu schw√§chen, indem zus√§tzliche Metainformationen in sich selbst verwendet werden (dazu sp√§ter mehr). </p><br><p>  Als Teill√∂sung k√∂nnen Sie den <em>speziellen Wert des</em> Zeigers verwenden, der uns signalisiert, dass sich an dieser Adresse nichts befindet.  In C wird das NULL-Makro als Wert f√ºr diesen Wert verwendet, und in C ++ wird das Schl√ºsselwort nullptr verwendet.  Die L√∂sung ist teilweise, weil: </p><br><ol><li>  Der Zeigerwert muss manuell eingestellt werden, damit der Programmierer dies einfach vergessen kann. </li><li>  nullptr oder nur 0x0 ist in der vom Zeiger akzeptierten Wertemenge enthalten, was nicht gut ist, wenn der spezielle Zustand eines Objekts durch seinen normalen Zustand ausgedr√ºckt wird.  Dies ist eine Art Verm√§chtnis, und nach Vereinbarung weist Ihnen das Betriebssystem keinen Speicher zu, dessen Adresse mit 0x0 beginnt. </li></ol><br><p>  Beispielcode mit null: </p><br><pre> <code class="plaintext hljs">//  -  p free(p); p = nullptr; //   p == nullptr   ,       </code> </pre> <br><p>  Sie k√∂nnen diesen Prozess bis zu einem gewissen Grad automatisieren: </p><br><pre> <code class="plaintext hljs">void _free(void* &amp;p) { free(p); p = nullptr; } //  -  p _free(p); //   p == nullptr,     //   </code> </pre> <br><h3 id="9-tip-pamyati">  9. Art des Speichers </h3><br><p>  <strong>RAM</strong> ist ein gew√∂hnlicher Allzweck-Direktzugriffsspeicher, auf den √ºber den zentralen Bus alle Kerne Ihres Prozessors und Ihrer Peripherieger√§te zugreifen k√∂nnen.  Das Volumen variiert, aber meistens handelt es sich um N Gigabyte, wobei N 1,2,4,8,16 usw. ist.  Ruft malloc / free auf, um den gew√ºnschten Speicherblock direkt im RAM des Computers zu platzieren. </p><br><p>  <strong>VRAM</strong> (Videospeicher) - Videospeicher, der mit der Grafikkarte / dem Videobeschleuniger Ihres PCs geliefert wird.  Es ist in der Regel kleiner als RAM (ca. 1,2,4 GiB), hat aber eine hohe Geschwindigkeit.  Die Verteilung dieses Speichertyps wird vom Grafikkartentreiber √ºbernommen, und meistens haben Sie keinen direkten Zugriff darauf. </p><br><p>  Auf der PlayStation 4 gibt es keine solche Trennung, und der gesamte Arbeitsspeicher wird auf GDDR5 durch einzelne 8 Gigabyte dargestellt.  Daher sind alle Daten sowohl f√ºr den Prozessor als auch f√ºr den Videobeschleuniger in der N√§he. </p><br><p>  Ein gutes Ressourcenmanagement in der Spiel-Engine umfasst eine kompetente Speicherzuweisung sowohl im Haupt-RAM als auch auf der VRAM-Seite.  Hier kann es zu <strong>Duplikaten kommen,</strong> wenn dieselben Daten vorhanden sind oder wenn Daten <strong>√ºberm√§√üig</strong> vom RAM zum VRAM √ºbertragen werden und umgekehrt. </p><br><p>  <strong>Zur Veranschaulichung aller angesprochenen Probleme</strong> : Sie k√∂nnen die Aspekte der Ger√§tecomputer am Beispiel der PlayStation 4-Architektur betrachten (Abb.).  Hier ist der Zentralprozessor, 8 Kerne, Caches auf L1- und L2-Ebene, Datenbusse, RAM, Grafikbeschleuniger usw.  Eine vollst√§ndige und detaillierte Beschreibung finden Sie in Jason Gregorys <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Game Engine Architecture"</a> . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c50/7ba/756/c507ba75624a3c9be702f85ddfa50e11.png"><br>  PlayStation 4-Architektur </p><br><h1 id="obschie-podhody-k-resheniyu">  Allgemeine Ans√§tze </h1><br><p>  Es gibt keine universelle L√∂sung.  Es gibt jedoch einige Punkte, auf die Sie sich konzentrieren sollten, wenn Sie die manuelle Zuordnung und Speicherverwaltung in Ihrer Anwendung implementieren m√∂chten.  Dies umfasst Container und spezialisierte Zuweiser, Speicherzuweisungsstrategien, System- / Spieldesign, Ressourcenmanager und mehr. </p><br><h2 id="tipy-allokatorov">  Arten von Allokatoren </h2><br><p>  Die Verwendung spezieller Speicherzuordnungen basiert auf der folgenden Idee: Sie wissen, welche Gr√∂√üe, zu welchen Arbeitszeiten und an welcher Stelle Sie Speicher ben√∂tigen.  Daher k√∂nnen Sie den erforderlichen Speicher zuweisen, ihn irgendwie strukturieren und verwenden / wiederverwenden.  Dies ist die allgemeine Idee / das Konzept der Verwendung spezieller Allokatoren.  Was sie sind (nat√ºrlich nicht alle), kann weiter gesehen werden: </p><br><ol><li><p>  <strong>Linearer Allokator</strong> <br>  Stellt einen zusammenh√§ngenden Adressraumpuffer dar.  Im Laufe der Arbeit k√∂nnen Sie Speicherabschnitte beliebiger Gr√∂√üe zuordnen (so dass sie in einen Puffer passen).  Sie k√∂nnen den gesamten zugewiesenen Speicher jedoch nur einmal freigeben.  Das hei√üt, ein beliebiger Speicherplatz kann nicht freigegeben werden - er bleibt so, als w√§re er <em>belegt,</em> bis der gesamte Puffer als sauber markiert ist.  Diese Konstruktion erm√∂glicht die Zuweisung und Freigabe von O (1), was unter allen Bedingungen eine Geschwindigkeitsgarantie bietet. <br><img src="https://habrastorage.org/webt/eb/tp/vm/ebtpvmrs616uwpgdfpd1nujw69s.png"><br>  Typischer Anwendungsfall: W√§hrend der Aktualisierung des Prozessstatus (jedes Frames im Spiel) k√∂nnen Sie mit LinearAllocator tmp-Puffer f√ºr alle technischen Anforderungen zuweisen: Eingabeverarbeitung, Arbeiten mit Zeichenfolgen, Analysieren von ConsoleManager-Befehlen im Debug-Modus usw. </p><br></li><li><p>  <strong>Stapelverteiler</strong> <br>  Modifikation eines linearen Allokators.  Erm√∂glicht das Freigeben von Speicher in umgekehrter Reihenfolge der Zuordnung, dh verh√§lt sich wie ein regul√§rer Stapel nach dem LIFO-Prinzip.  Es kann sehr n√ºtzlich sein, um geladene mathematische Berechnungen (Hierarchie von Transformationen) durchzuf√ºhren, um die Arbeit des Skriptsubsystems zu implementieren, f√ºr alle Berechnungen, bei denen die angegebene Reihenfolge der Speicherfreigabe im Voraus bekannt ist. <br><img src="https://habrastorage.org/webt/hu/7j/fm/hu7jfm6iqhxz0uk5xwo_ayzwyfo.png"><br>  Die Einfachheit des Designs bietet eine O (1) -Speicherzuordnung und Freigabegeschwindigkeit. </p><br></li><li><p>  <strong>Pool Allokator</strong> <br>  Erm√∂glicht das Zuweisen von Speicherbl√∂cken derselben Gr√∂√üe.  Es kann als Puffer eines kontinuierlichen Adressraums implementiert werden, der in Bl√∂cke einer vorbestimmten Gr√∂√üe unterteilt ist.  Diese Bl√∂cke k√∂nnen eine verkn√ºpfte Liste bilden.  Und wir wissen immer, welchen Block wir bei der n√§chsten Zuordnung geben sollen.  Diese Metainformationen k√∂nnen in den Bl√∂cken selbst gespeichert werden, wodurch die minimale Blockgr√∂√üe (sizeof (void *)) eingeschr√§nkt wird.  In Wirklichkeit ist dies nicht kritisch. <br><img src="https://habrastorage.org/webt/cv/sl/qz/cvslqzmqj1nsp-gtqccoyx6hwy4.png"><br>  Da alle Bl√∂cke gleich gro√ü sind, spielt es f√ºr uns keine Rolle, welcher Block zur√ºckgegeben werden soll. Daher k√∂nnen alle Zuordnungs- / Freigabevorg√§nge in O (1) ausgef√ºhrt werden. </p><br></li><li><p>  <strong>Rahmenverteiler</strong> <br>  Linearer Allokator, jedoch nur mit Bezug auf den aktuellen Frame - Erm√∂glicht die Zuweisung von MPP-Speicher und die automatische Freigabe aller Elemente beim √Ñndern des Frames.  Es sollte separat herausgegriffen werden, da dies eine globale und einzigartige Einheit im Rahmen des Laufzeitspiels ist und daher eine sehr beeindruckende Gr√∂√üe haben kann, beispielsweise ein paar Dutzend MiB, die beim Laden und Verarbeiten von Ressourcen sehr n√ºtzlich sein wird. </p><br></li><li><p>  <strong>Doppelrahmen-Allokator</strong> <br>  Es ist ein Doppelrahmen-Allokator, aber mit einigen Funktionen.  Sie k√∂nnen Speicher im aktuellen Frame zuweisen und sowohl im aktuellen als auch im n√§chsten Frame verwenden.  Das hei√üt, der Speicher, den Sie in Frame N zugewiesen haben, wird erst nach N + 1 Frame freigegeben.  Dies wird durch Umschalten des aktiven Rahmens auf Hervorheben am Ende jedes Rahmens realisiert. <br><img src="https://habrastorage.org/webt/ug/cc/zh/ugcczhvv6ibzbarvb0plwhvgbuu.png"><br>  Diese Art von Allokator unterwirft jedoch wie die vorherige eine Reihe von Einschr√§nkungen f√ºr die Lebensdauer von Objekten, die in dem ihm zugewiesenen Speicher erstellt wurden.  Daher sollten Sie sich bewusst sein, dass die Daten am Ende des Frames einfach ung√ºltig werden und ein wiederholter Zugriff auf sie schwerwiegende Probleme verursachen kann. </p><br></li><li><p>  <strong>Statischer Allokator</strong> <br>  Diese Art von Allokator reserviert Speicher aus einem Puffer, der beispielsweise beim Programmstart erhalten oder in einem Funktionsrahmen auf dem Stapel erfasst wurde.  Nach Typ kann es sich um einen beliebigen beliebigen Allokator handeln: linear, Pool, Stack.  Warum hei√üt es <em>statisch</em> ?  Die Gr√∂√üe des erfassten Speicherpuffers sollte <strong>in der Phase der Kompilierung des</strong> Programms bekannt sein.  Dies stellt eine erhebliche Einschr√§nkung dar: Die f√ºr diesen Allokator verf√ºgbare Speichermenge kann w√§hrend des Betriebs nicht ge√§ndert werden.  Aber was sind die Vorteile?  Der verwendete Puffer wird automatisch erfasst und dann freigegeben (entweder nach Abschluss der Arbeiten oder nach Verlassen der Funktion).  Dadurch wird der Heap nicht geladen, Sie werden vor Fragmentierung bewahrt und k√∂nnen schnell Speicherplatz zuweisen. <br>  Sie k√∂nnen sich das Codebeispiel mit diesem Allokator ansehen, wenn Sie die Zeichenfolge in Teilzeichenfolgen aufteilen und etwas damit tun m√ºssen: <br><img src="https://habrastorage.org/webt/3s/xk/t5/3sxkt5_00ztji1gesnh0cd1edno.png"><br>  Es kann auch angemerkt werden, dass die Verwendung von Speicher aus dem Stapel theoretisch viel effizienter ist, weil  Stapeln Sie den Frame der aktuellen Funktion mit hoher Wahrscheinlichkeit bereits im Prozessor-Cache. </p><br></li></ol><br><p>  Alle diese Allokatoren l√∂sen irgendwie die Probleme mit der Fragmentierung, mit einem Mangel an Speicher, mit der Geschwindigkeit des Empfangens und Freigebens von Bl√∂cken der erforderlichen Gr√∂√üe, mit der Lebensdauer von Objekten und dem Speicher, den sie belegen. </p><br><p>  Es sollte auch beachtet werden, dass Sie mit dem richtigen Ansatz f√ºr das Schnittstellendesign eine Art <em>Hierarchie von</em> Zuweisern erstellen k√∂nnen, wenn beispielsweise: Pool Speicher aus Frame-Zuweisung zuweist und Frame-Zuweisung wiederum Speicher aus linearer Zuweisung zuweist.  Eine √§hnliche Struktur kann weitergef√ºhrt werden und sich an Ihre Aufgaben und Bed√ºrfnisse anpassen. </p><br><p><img src="https://habrastorage.org/webt/rf/l8/4a/rfl84aakccaw2qfdw6hxlqiygos.png"></p><br><p>  Ich sehe eine √§hnliche Schnittstelle zum Erstellen von Hierarchien wie folgt: </p><br><pre> <code class="plaintext hljs">class IAllocator { public: virtual void* alloc(size_t size) = 0; virtual void* alloc(size_t size, size_t alignment) = 0; virtual void free (void* &amp;p) = 0; }</code> </pre> <br><p>          malloc/free ,     .  ,        ,            .           /    ,       . </p><br><h2 id="umnye-ukazateli">   </h2><br><p> Smart pointer ‚Äî        C++   ++11 (   boost,    ).   -,     ,        -  ,        .                . </p><br><p>       ?     : </p><br><ol><li>       </li><li>   (/) </li><li>    </li></ol><br><p>         : </p><br><ol><li><p> <strong>Unique pointer</strong> <br>      1    ( ). <br>   unique pointer ,          .        , ..    1   / . <br>        uniquePtr1  uniquePtr2,    uniquePtr1 , .   1  . <br><img src="https://habrastorage.org/webt/xl/qd/x2/xlqdx2thnzcg7rvvv0va70zpzl4.png"></p><br></li><li><p> <strong>Shared pointer</strong> <br>        (reference counting).       ,    ,      .    , ,      ,    . <br><img src="https://habrastorage.org/webt/jb/y6/wi/jby6wipfn5sv2ghabpuzzresgsk.png"><br>       . -,       ,      .        . -,  -                . </p><br></li><li><p> <strong>Weak pointer</strong> <br>    .       ,    .   ?           shared pointer.   ,   shared pointer  ,     . ,     shared pointer weak pointer.  ,   (shared)    ,   weak pointer    shared pointer.    ‚Äî  weak pointer ,     ,  ,       . <br><img src="https://habrastorage.org/webt/nr/bt/bq/nrbtbqg6rukrcdgmij-v08bpim4.png"><br>   shared,   weak pointer     meta-data   .    -   ,     ..   ,  O(N) overhead  ,  N ‚Äî -  .      , .               ,        .         . </p><br></li></ol><br><p>     :         . ,  shared pointer,     ,    (      )  <em>- - -</em> .           .            meta-info   ,  ,           .  Ein Beispiel: </p><br><pre> <code class="plaintext hljs">/*     */ /*   ,  shared pointer */ Array&lt;TSharedPtr&lt;Object&gt;&gt; objects; objects.add(newShared&lt;Object&gt;(...)); ... objects.add(newShared&lt;Object&gt;(...));</code> </pre> <br><pre> <code class="plaintext hljs">/*      (   meta-info    ) */ Array&lt;Object&gt; objects; objects.emplace(...); ... objects.emplace(...);</code> </pre> <br><p>   .            .  Dar√ºber weiter. </p><br><h2 id="unique-id"> Unique id </h2><br><p>      ,    .     (id/identificator),   , ,   -.    : </p><br><ol><li> <strong> </strong> <br>     ,   id.    ,   <strong>  </strong> ,  ,          id. </li><li> <strong>  </strong> <br>      ,          (  ,     ) </li><li> <strong>    </strong> <br>    id  ,      ,        id. </li><li> <strong>    </strong> <br>                 . ,   id,     . </li></ol><br><p>     :    id,   ,      id,         . </p><br><p>  id     ,  (Vulkan, OpenGL),   (Godot, CryEngine).  EntityID   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">     CryEngine</a> . </p><br><p>   ,  id   :   .     ,     (   ),     ,      . </p><br><pre> <code class="plaintext hljs">/*    */ class ID { uint32 index; uint32 generation; }</code> </pre> <br><pre> <code class="plaintext hljs">/*  - /  */ class ObjectManager { public: ID create(...); void destroy(ID); void update(ID id, ...); private: Array&lt;uint32&gt; generations; Array&lt;Objects&gt; objects; }</code> </pre> <br><p>   ID        ,     ID .     : </p><br><pre> <code class="plaintext hljs">generation = generations[id.index]; if (generation == id.generation) then /*    */ else /*  ,     */</code> </pre> <br><p>      id      generation  1   id   ids. </p><br><h2 id="konteynery">  Container </h2><br><p>     C++   ,         .      std,     <strong></strong>   ,   <strong></strong>    .        : </p><br><ul><li> Linked list ‚Äî   </li><li> Array ‚Äî /  </li><li> Queue ‚Äî  </li><li> Stack ‚Äî  </li><li> Map ‚Äî   </li><li> Set ‚Äî  </li></ul><br><p>         ?             memory corruption.        / ,    ,   ,    ,     . </p><br><h1 id="obschie-idei">   </h1><br><p>           ,     ,       .  , ,    /         . </p><br><h2 id="pod-konkretnye-zadachi">    </h2><br><p>   ,      ,       .              ,   (  )   .    ,   malloc/free  ,       ,            . </p><br><p>     ?   ,     (/ ),     ,     ,   .    ,     ,    ,           . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/554/778/95b/55477895bb7e2fcf71d44ad06ceb8ce3.jpg"><br> ryEngine Sandbox:       </p><br><p>   ,   Unreal, Unity, CryEngine  .,     ,    . ,       , ,     ‚Äî       ,                 . </p><br><h2 id="pre-allocating"> Pre-allocating </h2><br><p>        ,      /          . </p><br><p>    :   malloc/free      .     ,      "run out of memory", .        .         ,       (,   ,     .). </p><br><p>       .          .  ,         -  .           ,           malloc/free,    : ,  ,  . </p><br><h2 id="ne-nado-boyatsya-dinamicheskoy-pamyati">      </h2><br><p>            .   :     ,       , ,   ..             . </p><br><p>    :   ,      ,       ,    .  open-source ,      ,     .   ,  ,   ‚Äî     malloc/free. </p><br><h2 id="dizayn-iz-ogranicheniy">    </h2><br><p>  GDC  CD Project Red <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  </a> ,     ,       "The Witcher: Blood and Wine"    ()        .     ,     ,    ,         ,         . <br><img src="https://habrastorage.org/getpro/habr/post_images/80b/c6c/fb0/80bc6cfb08009ba02caee322cb092110.png"></p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   </a>    Naughty Dog  ,      "Uncharted 4: A Thief's End"     ,         (,    )       . <br><img src="https://habrastorage.org/getpro/habr/post_images/7c4/2c8/469/7c42c84690c9374423bba12dea6126ff.jpg"></p><br><h1 id="zaklyuchenie">  Fazit </h1><br><p>     ,    ,     ,          .       ,         .     / ,     ,   -   ..       ,        (,    ). </p><br><h1 id="literatura-i-poleznye-ssylki">     </h1><br><ul><li>         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Game Engine Architecture"</a> .           ,  , , ,   ..  ,    ,      . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Custom memory allocators</a> ‚Äî        ,     C++  .     ,         . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Smart pointers</a> ‚Äî     ,      . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Start Pre-allocating And Stop Worrying</a> ‚Äî        </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de473294/">https://habr.com/ru/post/de473294/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de473284/index.html">Senior, TechLead, Architekt - wie geht es weiter? Wie gehe ich mit einer Arbeitsroutine um und wohin gehe ich?</a></li>
<li><a href="../de473286/index.html">Wir schreiben Schutz gegen DDoS-Angriffe auf XDP. Kernteil</a></li>
<li><a href="../de473288/index.html">Erstellen Sie Ihren Code von Grund auf neu, er wird Ihr Level verbessern</a></li>
<li><a href="../de473290/index.html">Julia. Wo soll ich das Projekt starten? ...</a></li>
<li><a href="../de473292/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 319 (am 21. und 27. Oktober)</a></li>
<li><a href="../de473296/index.html">Start ohne Geld. Pers√∂nliche Erfahrung</a></li>
<li><a href="../de473298/index.html">Wie man Prozesse aufbaut und aufh√∂rt, sich √ºber ein Team lustig zu machen</a></li>
<li><a href="../de473300/index.html">PR im digitalen Zeitalter, moderne Treueprogramme und Festivalmarketing</a></li>
<li><a href="../de473302/index.html">Auf Wiedersehen HTML, Hallo QML</a></li>
<li><a href="../de473306/index.html">Augmented Reality Brillenkonzept. Mein perfektes AR-Headset, das m√∂glich ist</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>