<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙎🏿 🍳 🥡 Tests oder Typen? - Rostversion 🧝🏿 👩🏼‍🔬 👲🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor ein paar Tagen hat 0xd34df00d hier eine Übersetzung eines Artikels veröffentlicht, der beschreibt, was Sie über eine Funktion in verschiedenen Spr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tests oder Typen? - Rostversion</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468145/"><p> Vor ein paar Tagen hat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">0xd34df00d hier</a> eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Übersetzung eines</a> Artikels veröffentlicht, der beschreibt, was Sie über eine Funktion in verschiedenen Sprachen lernen können, wenn Sie sie als "Black Box" betrachten, ohne Informationen über ihre Implementierung zu verwenden (aber natürlich ohne die Verwendung des Compilers zu verhindern).  Natürlich sind die erhaltenen Informationen sehr abhängig von der Sprache - vier Beispiele wurden im Originalartikel berücksichtigt: </p><br><ul><li>  Python - dynamisch typisierte, minimale Informationen, nur Tests geben einige Hinweise; </li><li>  C - schwach statisch typisiert, nicht viel mehr Informationen; </li><li>  Haskell - stark statisch typisiert, mit reinen Funktionen, viel mehr Informationen; </li><li>  Idris ist eine Sprache mit abhängigen Typen. Es gibt genügend Informationen, um die Richtigkeit der Funktion während der Kompilierung zu beweisen. </li></ul><br><p>  "Da ist C, da ist Haskell, aber wo ist Rust ?!"  - Sofort wurde die Frage aufgeworfen.  Die Antwort ist unter dem Schnitt. </p><a name="habracut"></a><br><p>  Erinnern Sie sich an den Zustand des Problems: </p><br><blockquote>  Lassen Sie eine Liste und eine Bedeutung gegeben werden.  Es ist erforderlich, den Index dieses Werts in der Liste zurückzugeben oder anzugeben, dass dieser Wert nicht in der Liste enthalten ist. </blockquote><p>  Für Ungeduldige - alle unten diskutierten Optionen sind auf dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rust-Spielplatz zu sehen</a> . <br>  Lass uns gehen! </p><br><h4 id="prostoy-poisk">  Einfache Suche </h4><br><p>  Wir beginnen mit einer fast naiven Signatur, die sich tatsächlich nur in einigen idiomatischen Elementen vom C-Code unterscheidet: </p><br><pre><code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(x: &amp;[<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>], y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; { <span class="hljs-comment"><span class="hljs-comment">// 10000    }</span></span></code> </pre> <br><p>  Was wissen wir über diese Funktion?  Naja ... eigentlich nicht so sehr.  Natürlich ist es viel besser, <code>Option&lt;usize&gt;</code> in den Rückgabewerten zu haben, als C uns zur Verfügung gestellt hat, aber wir haben immer noch keine Informationen über die Semantik der Funktion.  Insbesondere gibt es keine Garantie dafür, dass keine Nebenwirkungen auftreten, und es gibt auch keine Möglichkeit, das erwartete Verhalten zu überprüfen. </p><br><p>  Kann ein korrekt geschriebener Test die Situation beheben?  Wir schauen: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(foo(&amp;[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(foo(&amp;[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-literal"><span class="hljs-literal">None</span></span>); }</code> </pre> <br><p>  Im Allgemeinen haben wir nichts Neues bekommen - all die gleichen Überprüfungen, die wir mit Python problemlos durchführen konnten (und die Tests werden in Zukunft praktisch nichts mehr bringen). </p><br><h4 id="use-the-generics-luke">  Benutze die Generika, Luke! </h4><br><p>  Aber ist es wirklich gut, dass wir nur signierte 32-Bit-Zahlen verwenden müssen?  Das Durcheinander.  Wir beheben: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;El&gt;(x: &amp;[El], y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">PartialEq</span></span>, { <span class="hljs-comment"><span class="hljs-comment">// 10000    }</span></span></code> </pre> <br><p>  Ja!  Das ist schon was.  Jetzt können wir Scheiben nehmen, die aus beliebigen Elementen bestehen, die wir auf Gleichheit vergleichen können.  Expliziter Polymorphismus ist fast immer besser als implizit und fast immer besser als keiner, oder? </p><br><p>  Eine solche Funktion kann jedoch unerwartet den folgenden Test für uns bestehen: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refl</span></span></span></span>&lt;El: <span class="hljs-built_in"><span class="hljs-built_in">PartialEq</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">Copy</span></span>&gt;(el: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; { foo(&amp;[el], el) <span class="hljs-comment"><span class="hljs-comment">// should always return Some(0), right? } #[test] fn dont_find_nan() { assert_eq!(refl(std::f64::NAN), None); }</span></span></code> </pre> <br><p>  Dies weist sofort auf einen Fehler unsererseits hin, da ein solcher Aufruf gemäß der ursprünglichen Spezifikation <code>Some(0)</code> müsste.  Natürlich liegt das Problem hier an der Spezifität von Typen mit einem teilweise definierten Vergleich im Allgemeinen und Floats im Besonderen. <br>  Nehmen wir jetzt an, wir wollen ein solches Problem beseitigen - dafür verschärfen wir nur die Anforderungen für den Typ El: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;El&gt;(x: &amp;[El], y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>, { <span class="hljs-comment"><span class="hljs-comment">// 10000    }</span></span></code> </pre> <br><p>  Jetzt fordern wir nicht nur die Möglichkeit eines Vergleichs für Gleichheit - wir fordern, dass dieser Vergleich eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Äquivalenzbeziehung ist</a> .  Dies schränkt den Bereich möglicher Parameter etwas ein, aber jetzt legen sowohl Typen als auch Tests nahe (wenn auch nicht explizit), dass das erwartete Verhalten wirklich in die Spezifikation fallen sollte. </p><br><div class="spoiler">  <b class="spoiler_title">Exkurs: Wir wollen generischer werden!</b> <div class="spoiler_text"><p>  Diese Option bezieht sich nicht auf die ursprüngliche Aufgabe, ist aber meiner Meinung nach ein gutes Beispiel für das Prinzip: "Sei liberal in dem, was du akzeptierst, sei konservativ in dem, was du tust".  Mit anderen Worten: Wenn es die Möglichkeit gibt, unbeschadet der Ergonomie und Leistung die Art der akzeptierten Werte allgemeiner zu gestalten, ist es sinnvoll, genau das zu tun. </p><br><p>  Betrachten Sie diese Option: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, El: <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(x: <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">IntoIterator</span></span>&lt;Item = &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> El&gt;, y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>, { <span class="hljs-comment"><span class="hljs-comment">// 10000    }</span></span></code> </pre> <br><p>  Was wissen wir jetzt über diese Funktion?  Alles ist das gleiche, nur dass jetzt keine Liste oder ein Slice als Eingabe akzeptiert wird, sondern ein beliebiges Objekt, mit dem abwechselnd Links zu Objekten vom Typ El ausgegeben und mit dem gesuchten verglichen werden können: Das Analogon in Java war, wenn ich mich richtig erinnere wäre eine Funktion, die eine <code>Iterable&lt;Comparable&gt;</code> . </p></div></div><br><h4 id="kak-ranshe-tolko-strozhe">  Nach wie vor nur strenger </h4><br><p>  Zum Beispiel reichen uns jedoch die vom Compiler in bereits bekannten Phasen angebotenen Garantien nicht aus.  Oder sagen wir, wir möchten nicht (aus dem einen oder anderen Grund) in einen Heap gelangen, sondern am Stapel arbeiten - was bedeutet, dass wir ein Array anstelle eines Vektors benötigen -, aber gleichzeitig möchten wir, dass unser Code auf verschiedene Größen des Arrays verallgemeinert wird .  Oder wir möchten, dass die Funktion für jede bestimmte Größe der Eingabeliste so weit wie möglich optimiert wird. <br><br>  Kurz gesagt, wir brauchen ein generisches Array - und Rust hat bereits ein Paket, das es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wörtlich</a> bereitstellt. </p><br><p>  Jetzt steht uns folgender Code zur Verfügung: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> generic_array::{GenericArray, ArrayLength}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;El, Size&gt;(x: GenericArray&lt;El, Size&gt;, y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>, Size: ArrayLength&lt;El&gt;, { <span class="hljs-comment"><span class="hljs-comment">// 10000    }</span></span></code> </pre> <br><p>  Was wissen wir aus diesem Code?  Dass die Funktion ein Array mit einer festen Größe verwendet, das sich in seinem Typ widerspiegelt (und für jede dieser Größen unabhängig kompiliert wird).  Bisher ändert sich daran nicht viel - am Ende haben genau die gleichen Garantien, nicht nur in der Monomorphisierungsphase, sondern auch zur Laufzeit, die vorherige Version mit einem Schnitt versehen. </p><br><p>  Aber wir können noch weiter gehen. </p><br><h4 id="arifmetika-urovnya-tipov">  Typ Level Arithmetik </h4><br><p>  Der ursprüngliche Artikel erwähnte mehrere Garantien, die wir von Idris erhalten hatten und von niemand anderem bekommen konnten.  Einer von ihnen - und vielleicht der einfachste, weil Sie dafür nicht einmal einen vollständigen Beweis oder einen vollständigen Test schreiben müssen, sondern nur den Typ ein wenig angeben müssen -, dass der Rückgabewert, falls vorhanden (d. H. Wenn er <code>Nothing</code> ) wird die Länge der Eingabeliste garantiert nicht überschreiten. <br><br>  Es scheint, dass die notwendige Bedingung für eine solche Garantie das Vorhandensein abhängiger Typen oder zumindest eine Art Ähnlichkeit ist, und es wäre seltsam, so etwas von Rust zu erwarten, oder? </p><br><p>  Meet - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Typenum</a> .  Damit kann unsere Funktion folgendermaßen dargestellt werden: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> generic_array::{ArrayLength, GenericArray}; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> typenum::{IsLess, Unsigned, B1}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnsignedLessThan</span></span></span></span>&lt;T&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_usize</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;Less, More&gt; UnsignedLessThan&lt;More&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Less <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> Less: IsLess&lt;More, Output = B1&gt;, Less: Unsigned, { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_usize</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> { &lt;<span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Unsigned&gt;::USIZE } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;El, Size&gt;(x: GenericArray&lt;El, Size&gt;, y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;dyn UnsignedLessThan&lt;Size&gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>, Size: ArrayLength&lt;El&gt;, { <span class="hljs-comment"><span class="hljs-comment">// 10000    }</span></span></code> </pre> <br><p>  "Was zum Teufel ist diese schwarze Magie ?!"  - Du fragst.  Und Sie werden sicherlich Recht haben: Typenum ist diese schwarze Magie, und Versuche, sie zumindest irgendwie vernünftig einzusetzen, sind doppelt. <br><br>  Trotzdem ist die Signatur dieser Funktion ziemlich eindeutig. </p><br><ul><li>  Die Funktion akzeptiert ein Array von El-Elementen der Länge Size und ein Element vom Typ El. </li><li>  Die Funktion gibt einen Optionswert zurück, der, wenn es sich um Some handelt, <br><ul><li>  Es ist ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Merkmalobjekt,</a> das auf dem <code>UnsignedLessThan&lt;T&gt;</code> basiert und den <code>UnsignedLessThan&lt;T&gt;</code> Size als Parameter akzeptiert. </li><li>  Das <code>IsLess&lt;T&gt;</code> <code>UnsignedLessThan&lt;T&gt;</code> <code>IsLess&lt;T&gt;</code> für alle Typen implementiert, die <code>Unsigned</code> und <code>IsLess&lt;T&gt;</code> implementieren, für die <code>IsLess&lt;T&gt;</code> B1 zurückgibt, d. <code>IsLess&lt;T&gt;</code>  wahr </li></ul></li></ul><br><p>  Mit anderen Worten, auf diese Weise haben wir eine Funktion geschrieben, die <em>garantiert</em> eine nicht negative (vorzeichenlose) Zahl zurückgibt, die <em>kleiner</em> als die ursprüngliche Größe des Arrays ist (oder vielmehr natürlich dasselbe Merkmalsobjekt zurückgibt, von dem wir später die <code>as_usize</code> Methode aufrufen <code>as_usize</code> , die garantiert eine solche Zahl <code>as_usize</code> ). . </p><br><p>  Bei diesem Ansatz gibt es genau zwei Tricks: </p><br><ol><li>  Wir können spürbar an Leistung verlieren.  Wenn sich unsere Funktion aus irgendeinem Grund plötzlich im "heißen" Teil des Programms befindet, kann der ständige Bedarf an dynamischen Aufrufen eine der langsamsten Operationen sein.  Dieser Nachteil mag zwar nicht so bedeutend sein, wie es scheint, aber es gibt einen zweiten: </li><li>  Damit diese Funktion korrekt kompiliert werden kann, müssen wir entweder den Beweis für die Richtigkeit ihrer Arbeit in sie schreiben oder das Typensystem durch <code>unsafe</code> „austricksen“.  Der erste ist zu kompliziert für den Artikel vom Freitag, aber der zweite ist einfach ein Betrug. </li></ol><br><h4 id="zaklyuchenie">  Fazit </h4><br><p>  In der Praxis wird in solchen Fällen natürlich entweder die zweite Implementierung (Empfang eines Slice eines beliebigen Typs) oder die Implementierung unter einem Spoiler (Empfang eines iterierbaren Objekts) verwendet.  Alle nachfolgenden Argumente sind mit ziemlicher Sicherheit nicht von praktischem Interesse und dienen lediglich als Übung bei der Arbeit mit einem Typensystem. </p><br><p>  Dennoch ist die Tatsache, dass das Rust-Typ-System eines der Merkmale des offensichtlich stärkeren Idris-Typ-Systems emulieren kann, meiner Meinung nach ziemlich bezeichnend. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468145/">https://habr.com/ru/post/de468145/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468127/index.html">Evolution CMS 2.0 auf Laravel 6.0-Komponenten - die natürliche Entwicklung von MODX Evolution</a></li>
<li><a href="../de468135/index.html">Top 10 JPoint 2019-Berichte</a></li>
<li><a href="../de468139/index.html">Aftershokz Xtrainerz Schwimmkopfhörer mit knochenleitendem Sound - Cool</a></li>
<li><a href="../de468141/index.html">Aufgabe: Schlüsselausdrücke aus dem Text in russischer Sprache extrahieren. Python NLP</a></li>
<li><a href="../de468143/index.html">466 Terabit: Der weltweite Internetverkehr wächst weiter. Können Satelliten mit U-Boot-Kabeln konkurrieren?</a></li>
<li><a href="../de468147/index.html">Einladung zur Lichtshow „Circle of Light“ 2019 in Moskau und ein kleiner Insider von einem der Standorte</a></li>
<li><a href="../de468151/index.html">Schwachstellen in GeekBrains: Warum Geld für Kurse bezahlen, wenn Sie diese nur herunterladen können?</a></li>
<li><a href="../de468155/index.html">Neue Produkttrends</a></li>
<li><a href="../de468157/index.html">Die Perspektive von EcmaScript auf die allgemeine Theorie der OOP</a></li>
<li><a href="../de468161/index.html">Die gierige Leuchte: Warum Sonnenenergie die Welt nicht eroberte und wie das „russische Mineral“ sie retten kann</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>