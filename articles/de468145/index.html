<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôéüèø üç≥ ü•° Tests oder Typen? - Rostversion üßùüèø üë©üèº‚Äçüî¨ üë≤üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor ein paar Tagen hat 0xd34df00d hier eine √úbersetzung eines Artikels ver√∂ffentlicht, der beschreibt, was Sie √ºber eine Funktion in verschiedenen Spr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tests oder Typen? - Rostversion</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468145/"><p> Vor ein paar Tagen hat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">0xd34df00d hier</a> eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úbersetzung eines</a> Artikels ver√∂ffentlicht, der beschreibt, was Sie √ºber eine Funktion in verschiedenen Sprachen lernen k√∂nnen, wenn Sie sie als "Black Box" betrachten, ohne Informationen √ºber ihre Implementierung zu verwenden (aber nat√ºrlich ohne die Verwendung des Compilers zu verhindern).  Nat√ºrlich sind die erhaltenen Informationen sehr abh√§ngig von der Sprache - vier Beispiele wurden im Originalartikel ber√ºcksichtigt: </p><br><ul><li>  Python - dynamisch typisierte, minimale Informationen, nur Tests geben einige Hinweise; </li><li>  C - schwach statisch typisiert, nicht viel mehr Informationen; </li><li>  Haskell - stark statisch typisiert, mit reinen Funktionen, viel mehr Informationen; </li><li>  Idris ist eine Sprache mit abh√§ngigen Typen. Es gibt gen√ºgend Informationen, um die Richtigkeit der Funktion w√§hrend der Kompilierung zu beweisen. </li></ul><br><p>  "Da ist C, da ist Haskell, aber wo ist Rust ?!"  - Sofort wurde die Frage aufgeworfen.  Die Antwort ist unter dem Schnitt. </p><a name="habracut"></a><br><p>  Erinnern Sie sich an den Zustand des Problems: </p><br><blockquote>  Lassen Sie eine Liste und eine Bedeutung gegeben werden.  Es ist erforderlich, den Index dieses Werts in der Liste zur√ºckzugeben oder anzugeben, dass dieser Wert nicht in der Liste enthalten ist. </blockquote><p>  F√ºr Ungeduldige - alle unten diskutierten Optionen sind auf dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rust-Spielplatz zu sehen</a> . <br>  Lass uns gehen! </p><br><h4 id="prostoy-poisk">  Einfache Suche </h4><br><p>  Wir beginnen mit einer fast naiven Signatur, die sich tats√§chlich nur in einigen idiomatischen Elementen vom C-Code unterscheidet: </p><br><pre><code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(x: &amp;[<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>], y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; { <span class="hljs-comment"><span class="hljs-comment">// 10000    }</span></span></code> </pre> <br><p>  Was wissen wir √ºber diese Funktion?  Naja ... eigentlich nicht so sehr.  Nat√ºrlich ist es viel besser, <code>Option&lt;usize&gt;</code> in den R√ºckgabewerten zu haben, als C uns zur Verf√ºgung gestellt hat, aber wir haben immer noch keine Informationen √ºber die Semantik der Funktion.  Insbesondere gibt es keine Garantie daf√ºr, dass keine Nebenwirkungen auftreten, und es gibt auch keine M√∂glichkeit, das erwartete Verhalten zu √ºberpr√ºfen. </p><br><p>  Kann ein korrekt geschriebener Test die Situation beheben?  Wir schauen: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(foo(&amp;[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(foo(&amp;[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-literal"><span class="hljs-literal">None</span></span>); }</code> </pre> <br><p>  Im Allgemeinen haben wir nichts Neues bekommen - all die gleichen √úberpr√ºfungen, die wir mit Python problemlos durchf√ºhren konnten (und die Tests werden in Zukunft praktisch nichts mehr bringen). </p><br><h4 id="use-the-generics-luke">  Benutze die Generika, Luke! </h4><br><p>  Aber ist es wirklich gut, dass wir nur signierte 32-Bit-Zahlen verwenden m√ºssen?  Das Durcheinander.  Wir beheben: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;El&gt;(x: &amp;[El], y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">PartialEq</span></span>, { <span class="hljs-comment"><span class="hljs-comment">// 10000    }</span></span></code> </pre> <br><p>  Ja!  Das ist schon was.  Jetzt k√∂nnen wir Scheiben nehmen, die aus beliebigen Elementen bestehen, die wir auf Gleichheit vergleichen k√∂nnen.  Expliziter Polymorphismus ist fast immer besser als implizit und fast immer besser als keiner, oder? </p><br><p>  Eine solche Funktion kann jedoch unerwartet den folgenden Test f√ºr uns bestehen: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refl</span></span></span></span>&lt;El: <span class="hljs-built_in"><span class="hljs-built_in">PartialEq</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">Copy</span></span>&gt;(el: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; { foo(&amp;[el], el) <span class="hljs-comment"><span class="hljs-comment">// should always return Some(0), right? } #[test] fn dont_find_nan() { assert_eq!(refl(std::f64::NAN), None); }</span></span></code> </pre> <br><p>  Dies weist sofort auf einen Fehler unsererseits hin, da ein solcher Aufruf gem√§√ü der urspr√ºnglichen Spezifikation <code>Some(0)</code> m√ºsste.  Nat√ºrlich liegt das Problem hier an der Spezifit√§t von Typen mit einem teilweise definierten Vergleich im Allgemeinen und Floats im Besonderen. <br>  Nehmen wir jetzt an, wir wollen ein solches Problem beseitigen - daf√ºr versch√§rfen wir nur die Anforderungen f√ºr den Typ El: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;El&gt;(x: &amp;[El], y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>, { <span class="hljs-comment"><span class="hljs-comment">// 10000    }</span></span></code> </pre> <br><p>  Jetzt fordern wir nicht nur die M√∂glichkeit eines Vergleichs f√ºr Gleichheit - wir fordern, dass dieser Vergleich eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√Ñquivalenzbeziehung ist</a> .  Dies schr√§nkt den Bereich m√∂glicher Parameter etwas ein, aber jetzt legen sowohl Typen als auch Tests nahe (wenn auch nicht explizit), dass das erwartete Verhalten wirklich in die Spezifikation fallen sollte. </p><br><div class="spoiler">  <b class="spoiler_title">Exkurs: Wir wollen generischer werden!</b> <div class="spoiler_text"><p>  Diese Option bezieht sich nicht auf die urspr√ºngliche Aufgabe, ist aber meiner Meinung nach ein gutes Beispiel f√ºr das Prinzip: "Sei liberal in dem, was du akzeptierst, sei konservativ in dem, was du tust".  Mit anderen Worten: Wenn es die M√∂glichkeit gibt, unbeschadet der Ergonomie und Leistung die Art der akzeptierten Werte allgemeiner zu gestalten, ist es sinnvoll, genau das zu tun. </p><br><p>  Betrachten Sie diese Option: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, El: <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(x: <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">IntoIterator</span></span>&lt;Item = &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> El&gt;, y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>, { <span class="hljs-comment"><span class="hljs-comment">// 10000    }</span></span></code> </pre> <br><p>  Was wissen wir jetzt √ºber diese Funktion?  Alles ist das gleiche, nur dass jetzt keine Liste oder ein Slice als Eingabe akzeptiert wird, sondern ein beliebiges Objekt, mit dem abwechselnd Links zu Objekten vom Typ El ausgegeben und mit dem gesuchten verglichen werden k√∂nnen: Das Analogon in Java war, wenn ich mich richtig erinnere w√§re eine Funktion, die eine <code>Iterable&lt;Comparable&gt;</code> . </p></div></div><br><h4 id="kak-ranshe-tolko-strozhe">  Nach wie vor nur strenger </h4><br><p>  Zum Beispiel reichen uns jedoch die vom Compiler in bereits bekannten Phasen angebotenen Garantien nicht aus.  Oder sagen wir, wir m√∂chten nicht (aus dem einen oder anderen Grund) in einen Heap gelangen, sondern am Stapel arbeiten - was bedeutet, dass wir ein Array anstelle eines Vektors ben√∂tigen -, aber gleichzeitig m√∂chten wir, dass unser Code auf verschiedene Gr√∂√üen des Arrays verallgemeinert wird .  Oder wir m√∂chten, dass die Funktion f√ºr jede bestimmte Gr√∂√üe der Eingabeliste so weit wie m√∂glich optimiert wird. <br><br>  Kurz gesagt, wir brauchen ein generisches Array - und Rust hat bereits ein Paket, das es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">w√∂rtlich</a> bereitstellt. </p><br><p>  Jetzt steht uns folgender Code zur Verf√ºgung: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> generic_array::{GenericArray, ArrayLength}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;El, Size&gt;(x: GenericArray&lt;El, Size&gt;, y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>, Size: ArrayLength&lt;El&gt;, { <span class="hljs-comment"><span class="hljs-comment">// 10000    }</span></span></code> </pre> <br><p>  Was wissen wir aus diesem Code?  Dass die Funktion ein Array mit einer festen Gr√∂√üe verwendet, das sich in seinem Typ widerspiegelt (und f√ºr jede dieser Gr√∂√üen unabh√§ngig kompiliert wird).  Bisher √§ndert sich daran nicht viel - am Ende haben genau die gleichen Garantien, nicht nur in der Monomorphisierungsphase, sondern auch zur Laufzeit, die vorherige Version mit einem Schnitt versehen. </p><br><p>  Aber wir k√∂nnen noch weiter gehen. </p><br><h4 id="arifmetika-urovnya-tipov">  Typ Level Arithmetik </h4><br><p>  Der urspr√ºngliche Artikel erw√§hnte mehrere Garantien, die wir von Idris erhalten hatten und von niemand anderem bekommen konnten.  Einer von ihnen - und vielleicht der einfachste, weil Sie daf√ºr nicht einmal einen vollst√§ndigen Beweis oder einen vollst√§ndigen Test schreiben m√ºssen, sondern nur den Typ ein wenig angeben m√ºssen -, dass der R√ºckgabewert, falls vorhanden (d. H. Wenn er <code>Nothing</code> ) wird die L√§nge der Eingabeliste garantiert nicht √ºberschreiten. <br><br>  Es scheint, dass die notwendige Bedingung f√ºr eine solche Garantie das Vorhandensein abh√§ngiger Typen oder zumindest eine Art √Ñhnlichkeit ist, und es w√§re seltsam, so etwas von Rust zu erwarten, oder? </p><br><p>  Meet - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Typenum</a> .  Damit kann unsere Funktion folgenderma√üen dargestellt werden: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> generic_array::{ArrayLength, GenericArray}; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> typenum::{IsLess, Unsigned, B1}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnsignedLessThan</span></span></span></span>&lt;T&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_usize</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;Less, More&gt; UnsignedLessThan&lt;More&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Less <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> Less: IsLess&lt;More, Output = B1&gt;, Less: Unsigned, { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_usize</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> { &lt;<span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Unsigned&gt;::USIZE } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;El, Size&gt;(x: GenericArray&lt;El, Size&gt;, y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;dyn UnsignedLessThan&lt;Size&gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>, Size: ArrayLength&lt;El&gt;, { <span class="hljs-comment"><span class="hljs-comment">// 10000    }</span></span></code> </pre> <br><p>  "Was zum Teufel ist diese schwarze Magie ?!"  - Du fragst.  Und Sie werden sicherlich Recht haben: Typenum ist diese schwarze Magie, und Versuche, sie zumindest irgendwie vern√ºnftig einzusetzen, sind doppelt. <br><br>  Trotzdem ist die Signatur dieser Funktion ziemlich eindeutig. </p><br><ul><li>  Die Funktion akzeptiert ein Array von El-Elementen der L√§nge Size und ein Element vom Typ El. </li><li>  Die Funktion gibt einen Optionswert zur√ºck, der, wenn es sich um Some handelt, <br><ul><li>  Es ist ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Merkmalobjekt,</a> das auf dem <code>UnsignedLessThan&lt;T&gt;</code> basiert und den <code>UnsignedLessThan&lt;T&gt;</code> Size als Parameter akzeptiert. </li><li>  Das <code>IsLess&lt;T&gt;</code> <code>UnsignedLessThan&lt;T&gt;</code> <code>IsLess&lt;T&gt;</code> f√ºr alle Typen implementiert, die <code>Unsigned</code> und <code>IsLess&lt;T&gt;</code> implementieren, f√ºr die <code>IsLess&lt;T&gt;</code> B1 zur√ºckgibt, d. <code>IsLess&lt;T&gt;</code>  wahr </li></ul></li></ul><br><p>  Mit anderen Worten, auf diese Weise haben wir eine Funktion geschrieben, die <em>garantiert</em> eine nicht negative (vorzeichenlose) Zahl zur√ºckgibt, die <em>kleiner</em> als die urspr√ºngliche Gr√∂√üe des Arrays ist (oder vielmehr nat√ºrlich dasselbe Merkmalsobjekt zur√ºckgibt, von dem wir sp√§ter die <code>as_usize</code> Methode aufrufen <code>as_usize</code> , die garantiert eine solche Zahl <code>as_usize</code> ). . </p><br><p>  Bei diesem Ansatz gibt es genau zwei Tricks: </p><br><ol><li>  Wir k√∂nnen sp√ºrbar an Leistung verlieren.  Wenn sich unsere Funktion aus irgendeinem Grund pl√∂tzlich im "hei√üen" Teil des Programms befindet, kann der st√§ndige Bedarf an dynamischen Aufrufen eine der langsamsten Operationen sein.  Dieser Nachteil mag zwar nicht so bedeutend sein, wie es scheint, aber es gibt einen zweiten: </li><li>  Damit diese Funktion korrekt kompiliert werden kann, m√ºssen wir entweder den Beweis f√ºr die Richtigkeit ihrer Arbeit in sie schreiben oder das Typensystem durch <code>unsafe</code> ‚Äûaustricksen‚Äú.  Der erste ist zu kompliziert f√ºr den Artikel vom Freitag, aber der zweite ist einfach ein Betrug. </li></ol><br><h4 id="zaklyuchenie">  Fazit </h4><br><p>  In der Praxis wird in solchen F√§llen nat√ºrlich entweder die zweite Implementierung (Empfang eines Slice eines beliebigen Typs) oder die Implementierung unter einem Spoiler (Empfang eines iterierbaren Objekts) verwendet.  Alle nachfolgenden Argumente sind mit ziemlicher Sicherheit nicht von praktischem Interesse und dienen lediglich als √úbung bei der Arbeit mit einem Typensystem. </p><br><p>  Dennoch ist die Tatsache, dass das Rust-Typ-System eines der Merkmale des offensichtlich st√§rkeren Idris-Typ-Systems emulieren kann, meiner Meinung nach ziemlich bezeichnend. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468145/">https://habr.com/ru/post/de468145/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468127/index.html">Evolution CMS 2.0 auf Laravel 6.0-Komponenten - die nat√ºrliche Entwicklung von MODX Evolution</a></li>
<li><a href="../de468135/index.html">Top 10 JPoint 2019-Berichte</a></li>
<li><a href="../de468139/index.html">Aftershokz Xtrainerz Schwimmkopfh√∂rer mit knochenleitendem Sound - Cool</a></li>
<li><a href="../de468141/index.html">Aufgabe: Schl√ºsselausdr√ºcke aus dem Text in russischer Sprache extrahieren. Python NLP</a></li>
<li><a href="../de468143/index.html">466 Terabit: Der weltweite Internetverkehr w√§chst weiter. K√∂nnen Satelliten mit U-Boot-Kabeln konkurrieren?</a></li>
<li><a href="../de468147/index.html">Einladung zur Lichtshow ‚ÄûCircle of Light‚Äú 2019 in Moskau und ein kleiner Insider von einem der Standorte</a></li>
<li><a href="../de468151/index.html">Schwachstellen in GeekBrains: Warum Geld f√ºr Kurse bezahlen, wenn Sie diese nur herunterladen k√∂nnen?</a></li>
<li><a href="../de468155/index.html">Neue Produkttrends</a></li>
<li><a href="../de468157/index.html">Die Perspektive von EcmaScript auf die allgemeine Theorie der OOP</a></li>
<li><a href="../de468161/index.html">Die gierige Leuchte: Warum Sonnenenergie die Welt nicht eroberte und wie das ‚Äûrussische Mineral‚Äú sie retten kann</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>