<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§¥üèø ü•É üèáüèª Syst√®mes bas√©s sur la file d'attente üöá ü§ñ üö∂üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut, habrozhiteli! 

 Nous avons d√©cid√© de partager la traduction du chapitre ¬´Syst√®mes bas√©s sur des files d'attente de t√¢ches¬ª de la nouveaut√© √† v...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Syst√®mes bas√©s sur la file d'attente</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/440444/">  Salut, habrozhiteli! <br><br>  Nous avons d√©cid√© de partager la traduction du chapitre ¬´Syst√®mes bas√©s sur des files d'attente de t√¢ches¬ª de la nouveaut√© √† venir ¬´Syst√®mes distribu√©s.  Design patterns ¬ª(d√©j√† dans l'imprimerie). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/c0/c7/6k/c0c76kbloj9pjb2olgoma345bes.png" alt="image"></div><br>  La forme la plus simple de traitement par lots est la file d'attente des t√¢ches.  Dans un syst√®me avec une file d'attente de t√¢ches, il existe un ensemble de t√¢ches qui doivent √™tre termin√©es.  Chaque t√¢che est compl√®tement ind√©pendante des autres et peut √™tre trait√©e sans aucune interaction avec elles.  Dans le cas g√©n√©ral, l'objectif d'un syst√®me avec une file d'attente de t√¢ches est de s'assurer que chaque √©tape du travail est termin√©e dans un laps de temps donn√©.  Le nombre de workflows augmente ou diminue en fonction de l'√©volution de la charge.  Le sch√©ma de la file d'attente de t√¢ches g√©n√©ralis√©e est pr√©sent√© √† la Fig.  10.1. <br><a name="habracut"></a><br><h3>  Un syst√®me bas√© sur une file d'attente de t√¢ches g√©n√©ralis√©e </h3><br>  La ligne de t√¢ches est un exemple id√©al qui montre toute la puissance des mod√®les de conception de syst√®mes distribu√©s.  La plupart de la logique de la file d'attente des t√¢ches ne d√©pend pas du type de travail effectu√©.  Dans de nombreux cas, il en va de m√™me pour l'ex√©cution des t√¢ches elles-m√™mes. <br><br>  Illustrons cette d√©claration √† l'aide de la file d'attente des t√¢ches illustr√©e √† la Fig.  10.1.  Apr√®s l'avoir r√©examin√©, d√©terminez quelles fonctions peuvent √™tre fournies par un ensemble partag√© de conteneurs.  Il devient √©vident que la plupart de l'impl√©mentation d'une file d'attente de t√¢ches conteneuris√©e peut √™tre utilis√©e par un large √©ventail d'utilisateurs. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8h/b2/qf/8hb2qfylszx_qmk8dicocvnvxtg.png" alt="image"></div><br>  La mise en file d'attente des t√¢ches bas√©e sur des conteneurs n√©cessite des interfaces correspondantes entre les conteneurs de biblioth√®que et les conteneurs avec une logique utilisateur.  Dans la file d'attente des t√¢ches conteneuris√©es, deux interfaces sont distingu√©es: l'interface du conteneur source, qui fournit un flux de t√¢ches n√©cessitant un traitement, et l'interface du conteneur d'ex√©cution, qui sait comment les g√©rer. <br><br><h3>  Interface du conteneur source </h3><br>  Toute file d'attente de t√¢ches fonctionne sur la base d'un ensemble de t√¢ches qui n√©cessitent un traitement.  Selon l'application sp√©cifique impl√©ment√©e sur la base de la file d'attente des t√¢ches, il existe de nombreuses sources de t√¢ches qui y entrent.  Mais apr√®s avoir re√ßu un ensemble de t√¢ches, le sch√©ma d'op√©ration de file d'attente est assez simple.  Par cons√©quent, nous pouvons s√©parer la logique sp√©cifique √† l'application de la source de t√¢che du sch√©ma g√©n√©ralis√© de traitement de la file d'attente de t√¢ches.  En rappelant les mod√®les de groupes de conteneurs discut√©s pr√©c√©demment, vous pouvez voir ici la mise en ≈ìuvre du mod√®le Ambassador.  Le conteneur de file d'attente de t√¢ches g√©n√©ralis√© est le conteneur d'application principal et le conteneur source sp√©cifique √† l'application est un ambassadeur diffusant les demandes du conteneur du gestionnaire de files d'attente aux ex√©cuteurs de t√¢ches sp√©cifiques.  Ce groupe de conteneurs est illustr√© √† la Fig.  10.2. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bx/7u/pc/bx7upcqfw7gxqus2zqrhbrhqpes.png" alt="image"></div><br>  Soit dit en passant, bien que l'ambassadeur de conteneur soit sp√©cifique √† l'application (ce qui est √©vident), il existe √©galement un certain nombre d'impl√©mentations g√©n√©ralis√©es de l'API de source de t√¢ches.  Par exemple, la source peut √™tre une liste de photos situ√©es dans un stockage cloud, un ensemble de fichiers sur un lecteur r√©seau, ou m√™me une file d'attente dans des syst√®mes fonctionnant sur le principe de "publication / abonnement", tels que Kafka ou Redis.  Bien que les utilisateurs puissent choisir les ambassadeurs de conteneurs les mieux adapt√©s √† leur t√¢che, ils doivent utiliser une impl√©mentation de ¬´biblioth√®que¬ª g√©n√©ralis√©e du conteneur lui-m√™me.  Cela minimisera la quantit√© de travail et maximisera la r√©utilisation du code. <br><br>  <b>API de file d'attente des t√¢ches</b>  √âtant donn√© le m√©canisme d'interaction entre la file d'attente des t√¢ches et le conteneur d√©pendant de l'application, nous devons formuler une d√©finition formelle de l'interface entre les deux conteneurs.  Il existe de nombreux protocoles diff√©rents, mais les API HTTP RESTful sont faciles √† impl√©menter et constituent la norme de facto pour de telles interfaces.  La file d'attente des t√¢ches s'attend √† ce que les URL suivantes soient impl√©ment√©es dans le conteneur apr√®s: <br><br><ul><li>  GET <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">localhost / api / v1 / items;</a> </li><li>  GET <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">localhost / api / v1 / items</a> &lt;item-name&gt;. </li></ul><blockquote>  Pourquoi ajouter la v1 √† votre d√©finition d'API, demandez-vous?  Y aura-t-il jamais une deuxi√®me version de l'interface?  Cela semble illogique, mais le co√ªt de versioning de l'API lorsqu'il est initialement d√©fini est minime.  La r√©alisation du refactoring appropri√© plus tard sera extr√™mement co√ªteuse.  Faites-en une r√®gle pour ajouter des versions √† toutes les API, m√™me si vous n'√™tes pas s√ªr qu'elles changeront jamais.  Dieu sauve le coffre-fort. <br></blockquote>  URL / √©l√©ments / renvoie une liste de toutes les t√¢ches: <br><br><pre><code class="plaintext hljs">{ kind: ItemList, apiVersion: v1, items: [ "item-1", "item-2", ‚Ä¶. ] }</code> </pre> <br>  L'URL / items / &lt;item-name&gt; fournit des informations d√©taill√©es sur une t√¢che sp√©cifique: <br><br><pre> <code class="plaintext hljs">{ kind: Item, apiVersion: v1, data: { "some": "json", "object": "here", } }</code> </pre> <br>  Veuillez noter que l'API ne fournit aucun m√©canisme pour corriger le fait de la t√¢che.  On pourrait d√©velopper une API plus complexe et transf√©rer la plupart de l'impl√©mentation √† un ambassadeur de conteneurs.  N'oubliez pas, cependant, que notre objectif est de concentrer le plus possible l'impl√©mentation globale dans le gestionnaire de files d'attente de t√¢ches.  √Ä cet √©gard, le gestionnaire de files d'attente de t√¢ches doit lui-m√™me surveiller les t√¢ches qui ont d√©j√† √©t√© trait√©es et celles qui doivent encore l'√™tre. <br><br>  De cette API, nous obtenons des informations sur une t√¢che sp√©cifique, puis passons la valeur du champ item.data de l'interface conteneur de l'ex√©cuteur. <br><br><h3>  Ex√©cution de l'interface de conteneur </h3><br>  D√®s que le gestionnaire de files d'attente a re√ßu la t√¢che suivante, il doit la confier √† un ex√©cuteur.  Il s'agit de la deuxi√®me interface de la file d'attente de t√¢ches g√©n√©ralis√©e.  Le conteneur lui-m√™me et son interface sont l√©g√®rement diff√©rents de l'interface du conteneur source pour plusieurs raisons.  Tout d'abord, il s'agit d'une API unique.  Le travail de l'ex√©cuteur testamentaire commence par un seul appel, et pendant le cycle de vie du conteneur, plus aucun appel n'est effectu√©.  Deuxi√®mement, le conteneur en cours d'ex√©cution et le gestionnaire de files d'attente de t√¢ches se trouvent dans des groupes de conteneurs diff√©rents.  L'ex√©cuteur de conteneur est lanc√© via l'API d'orchestrateur de conteneur dans son propre groupe.  Cela signifie que le gestionnaire de files d'attente de t√¢ches doit effectuer un appel distant pour lancer le conteneur d'ex√©cution.  Cela signifie √©galement que vous devez faire plus attention aux probl√®mes de s√©curit√©, car un utilisateur malveillant du cluster peut le charger avec un travail inutile. <br><br>  Dans le conteneur source, nous avons utilis√© un simple appel HTTP pour envoyer la liste des t√¢ches au gestionnaire de t√¢ches.  Cela a √©t√© fait en supposant que cet appel d'API devait √™tre effectu√© plusieurs fois, et les probl√®mes de s√©curit√© n'√©taient pas pris en compte, car tout fonctionnait dans le cadre de l'h√¥te local.  L'API de conteneur ne doit √™tre appel√©e qu'une seule fois et il est important de s'assurer que les autres utilisateurs du syst√®me ne peuvent pas ajouter de travail aux ex√©cuteurs, m√™me par accident ou par intention malveillante.  Par cons√©quent, pour le conteneur en cours d'ex√©cution, nous utiliserons l'API de fichier.  Lors de la cr√©ation, nous transmettrons au conteneur une variable d'environnement appel√©e WORK_ITEM_FILE, dont la valeur fait r√©f√©rence √† un fichier dans le syst√®me de fichiers interne du conteneur.  Ce fichier contient des donn√©es sur la t√¢che √† effectuer.  Ce type d'API, comme illustr√© ci-dessous, peut √™tre impl√©ment√© par l'objet ConfigMap Kubernetes.  Il peut √™tre mont√© dans un groupe de conteneurs sous forme de fichier (Fig. 10.3). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jn/p0/zb/jnp0zbiduvl1qsstlwa1mphwrxq.png" alt="image"></div><br>  Un tel m√©canisme d'API de fichier est plus facile √† impl√©menter √† l'aide d'un conteneur.  Un ex√©cuteur dans une file d'attente de t√¢ches est souvent un simple script shell qui acc√®de √† plusieurs outils.  Il n'est pas pratique d'√©lever un serveur Web entier pour la gestion des t√¢ches - cela entra√Æne une complication de l'architecture.  Comme dans le cas des sources de t√¢ches, la plupart des ex√©cuteurs de conteneurs seront des conteneurs sp√©cialis√©s pour certaines t√¢ches, mais il existe √©galement des ex√©cuteurs g√©n√©ralis√©s applicables pour r√©soudre plusieurs t√¢ches diff√©rentes. <br><br>  Prenons l'exemple d'un conteneur en cours d'ex√©cution qui t√©l√©charge un fichier √† partir du stockage cloud, ex√©cute un script shell dessus, puis copie le r√©sultat vers le stockage cloud.  Un tel conteneur peut √™tre pour la plupart g√©n√©ral, mais un sc√©nario sp√©cifique peut lui √™tre transmis en tant que param√®tre.  Ainsi, la plupart du code de gestion de fichiers peut √™tre r√©utilis√© par de nombreux utilisateurs / files d'attente de t√¢ches.  L'utilisateur final n'a qu'√† fournir un script contenant les sp√©cificit√©s du traitement des fichiers. <br><br><h3>  Infrastructure de file d'attente de t√¢ches commune </h3><br>  Que reste-t-il √† impl√©menter dans une impl√©mentation de file d'attente r√©utilisable si vous avez d√©j√† des impl√©mentations des deux interfaces de conteneur d√©crites pr√©c√©demment?  L'algorithme de base de la file d'attente des t√¢ches est assez simple. <br><br><ol><li>  T√©l√©chargez les t√¢ches actuellement disponibles √† partir du conteneur source. </li><li>  Clarifiez le statut de la file d'attente des t√¢ches pour quelles t√¢ches ont d√©j√† √©t√© termin√©es ou sont encore en cours d'ex√©cution. </li><li>  Pour chacune des t√¢ches non r√©solues, cr√©ez des conteneurs de conteneurs avec une interface appropri√©e. </li><li>  Une fois le conteneur ex√©cut√© avec succ√®s, notez que la t√¢che est termin√©e. </li></ol><br>  Cet algorithme est simple en mots, mais en r√©alit√© il n'est pas si facile √† mettre en ≈ìuvre.  Heureusement, l'orchestre Kubernetes poss√®de plusieurs fonctionnalit√©s qui simplifient consid√©rablement sa mise en ≈ìuvre.  √Ä savoir: Kubernetes poss√®de un objet Job qui garantit un fonctionnement fiable de la file d'attente des t√¢ches.  Vous pouvez configurer l'objet Job pour qu'il d√©marre le conteneur d'ex√©cution correspondant soit une fois, soit jusqu'√† ce que la t√¢che soit termin√©e avec succ√®s.  Si vous configurez le conteneur en cours d'ex√©cution de sorte qu'il s'ex√©cute avant la fin de la t√¢che, m√™me lorsque la machine du cluster √©choue, la t√¢che sera finalement termin√©e avec succ√®s. <br><br>  Ainsi, la mise en file d'attente des t√¢ches est grandement simplifi√©e, car l'orchestre assume la responsabilit√© de l'ex√©cution fiable des t√¢ches. <br><br>  De plus, Kubernetes vous permet d'annoter des t√¢ches, ce qui nous permet de marquer chaque objet de t√¢che avec le nom de l'√©l√©ment de file d'attente de t√¢ches trait√©.  Il devient de plus en plus facile de distinguer les t√¢ches qui sont trait√©es et termin√©es avec succ√®s et avec une erreur. <br><br>  Cela signifie que nous pouvons impl√©menter la file d'attente des t√¢ches au-dessus de l'orchestrateur Kubernetes sans utiliser notre propre r√©f√©rentiel.  Tout cela simplifie consid√©rablement la t√¢che de construction de l'infrastructure de la file d'attente des t√¢ches. <br><br>  Par cons√©quent, un algorithme d√©taill√© pour le fonctionnement du conteneur, le gestionnaire de files d'attente de t√¢ches, est le suivant. <br><br>  R√©p√©tez sans cesse. <br><br><ol><li>  Obtenez la liste des t√¢ches via l'interface du conteneur - la source des t√¢ches. </li><li>  Obtenez une liste des t√¢ches desservant cette file d'attente de t√¢ches. </li><li>  Sur la base de ces listes, s√©lectionnez une liste de t√¢ches non trait√©es. </li><li>  Pour chaque t√¢che non trait√©e, cr√©ez un objet Job qui g√©n√®re le conteneur d'ex√©cution correspondant. </li></ol><br>  Voici un script Python qui impl√©mente cette file d'attente: <br><br><pre> <code class="plaintext hljs">import requests import json from kubernetes import client, config import time namespace = "default" def make_container(item, obj): container = client.V1Container() container.image = "my/worker-image" container.name = "worker" return container def make_job(item): response = requests.get("http://localhost:8000/items/{}".format(item)) obj = json.loads(response.text) job = client.V1Job() job.metadata = client.V1ObjectMeta() job.metadata.name = item job.spec = client.V1JobSpec() job.spec.template = client.V1PodTemplate() job.spec.template.spec = client.V1PodTemplateSpec() job.spec.template.spec.restart_policy = "Never" job.spec.template.spec.containers = [ make_container(item, obj) ] return job def update_queue(batch): response = requests.get("http://localhost:8000/items") obj = json.loads(response.text) items = obj['items'] ret = batch.list_namespaced_job(namespace, watch=False) for item in items: found = False for i in ret.items: if i.metadata.name == item: found = True if not found: #    Job,  #   job = make_job(item) batch.create_namespaced_job(namespace, job) config.load_kube_config() batch = client.BatchV1Api() while True: update_queue(batch) time.sleep(10)</code> </pre> <br><h3>  Atelier  Impl√©mentation d'un g√©n√©rateur de vignettes pour les fichiers vid√©o </h3><br>  Comme exemple d'utilisation de la file d'attente des t√¢ches, consid√©rez la t√¢che de g√©n√©ration de vignettes de fichiers vid√©o.  Sur la base de ces miniatures, les utilisateurs d√©cident quelles vid√©os ils souhaitent regarder. <br><br>  Pour impl√©menter les vignettes, vous avez besoin de deux conteneurs.  Le premier concerne la source des t√¢ches.  Il sera plus facile de placer des t√¢ches sur un lecteur r√©seau partag√© connect√©, par exemple via NFS (Network File System, syst√®me de fichiers r√©seau).  La source de la t√¢che re√ßoit une liste de fichiers dans ce r√©pertoire et les transmet √† l'appelant. <br><br>  Je vais donner un programme simple sur NodeJS: <br><br><pre> <code class="plaintext hljs">const http = require('http'); const fs = require('fs'); const port = 8080; const path = process.env.MEDIA_PATH; const requestHandler = (request, response) =&gt; { console.log(request.url); fs.readdir(path + '/*.mp4', (err, items) =&gt; { var msg = { 'kind': 'ItemList', 'apiVersion': 'v1', 'items': [] }; if (!items) { return msg; } for (var i = 0; i &lt; items.length; i++) { msg.items.push(items[i]); } response.end(JSON.stringify(msg)); }); } const server = http.createServer(requestHandler); server.listen(port, (err) =&gt; { if (err) { return console.log('  ', err); } console.log(`    ${port}`) });</code> </pre> <br>  Cette source d√©finit la liste des films √† traiter.  L'utilitaire ffmpeg est utilis√© pour extraire les vignettes. <br><br>  Vous pouvez cr√©er un conteneur qui ex√©cute la commande suivante: <br><br><pre> <code class="plaintext hljs">ffmpeg -i ${INPUT_FILE} -frames:v 100 thumb.png</code> </pre> <br>  La commande extrait une trame sur 100 (param√®tre -frames: v 100) et l'enregistre au format PNG (par exemple, thumb1.png, thumb2.png, etc.). <br><br>  Ce type de traitement peut √™tre impl√©ment√© sur la base de l'image Docker ffmpeg existante.  L' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">image de jrottenberg / ffmpeg</a> est populaire. <br><br>  En d√©finissant un conteneur source simple et un conteneur d'ex√©cution encore plus simple, il est facile de voir les avantages d'un syst√®me de gestion de file d'attente g√©n√©rique et orient√© conteneur.  Il r√©duit consid√©rablement le temps entre la conception et la mise en ≈ìuvre de la file d'attente des t√¢ches. <br><br><h3>  Mise √† l'√©chelle dynamique des artistes </h3><br>  La file d'attente des t√¢ches consid√©r√©e pr√©c√©demment est bien adapt√©e au traitement des t√¢ches au fur et √† mesure qu'elles deviennent disponibles, mais peut entra√Æner une charge brutale sur les ressources de l'orchestrateur de cluster de conteneurs.  Cela est utile lorsque vous avez de nombreux types de t√¢ches diff√©rents qui cr√©ent des pics de charge √† des moments diff√©rents et r√©partissent ainsi la charge sur le cluster de mani√®re uniforme dans le temps. <br><br>  Mais si vous n'avez pas assez de types de charge, l'approche ¬´puis √©paisse, puis vide¬ª pour faire √©voluer la file d'attente des t√¢ches peut n√©cessiter la r√©servation de ressources suppl√©mentaires pour prendre en charge les rafales de charge.  Le reste du temps, les ressources seront inactives, vidant inutilement votre portefeuille. <br><br>  Pour r√©soudre ce probl√®me, vous pouvez limiter le nombre total d'objets Job g√©n√©r√©s par la file d'attente des t√¢ches.  Cela limitera naturellement le nombre de travaux trait√©s en parall√®le et, par cons√©quent, r√©duira l'utilisation des ressources lors des pics de charge.  En revanche, la dur√©e de chaque t√¢che individuelle augmentera avec une charge √©lev√©e sur le cluster. <br><br>  Si la charge est spasmodique, ce n'est pas effrayant, car les intervalles de temps d'arr√™t peuvent √™tre utilis√©s pour terminer les t√¢ches accumul√©es.  Cependant, si la charge constante est trop √©lev√©e, la file d'attente des t√¢ches n'aura pas le temps de traiter les t√¢ches entrantes et de plus en plus de temps sera consacr√© √† leur mise en ≈ìuvre. <br><br>  Dans une telle situation, vous devrez ajuster dynamiquement le nombre maximal de t√¢ches parall√®les et, par cons√©quent, les ressources informatiques disponibles pour maintenir le niveau de performances requis.  Heureusement, il existe des formules math√©matiques qui vous permettent de d√©terminer quand il est n√©cessaire de mettre √† l'√©chelle la file d'attente des t√¢ches pour traiter plus de demandes. <br><br>  Imaginez une file d'attente de t√¢ches dans laquelle une nouvelle t√¢che appara√Æt en moyenne une fois par minute et son ach√®vement prend en moyenne 30 secondes.  Une telle file d'attente est capable de faire face au flux de t√¢ches qui y p√©n√®trent.  M√™me si un grand ensemble de t√¢ches arrive √† la fois, cr√©ant un embouteillage, alors l'embouteillage sera √©limin√© au fil du temps, car la file d'attente parvient √† traiter deux t√¢ches en moyenne avant l'arriv√©e de la t√¢che suivante. <br><br>  Si une nouvelle t√¢che arrive toutes les minutes et qu'il faut en moyenne 1 minute pour traiter une t√¢che, alors un tel syst√®me est parfaitement √©quilibr√©, mais en m√™me temps r√©agit mal aux changements de la charge.  Elle est capable de faire face √† des √©clats de charge, mais cela lui prendra beaucoup de temps.  Le syst√®me ne sera pas inactif, mais il n'y aura pas de r√©serve de temps informatique pour compenser l'augmentation √† long terme de la vitesse de r√©ception des nouvelles t√¢ches.  Pour maintenir la stabilit√© du syst√®me, il est n√©cessaire d'avoir une r√©serve en cas de croissance de charge √† long terme ou de retards impr√©vus dans les t√¢ches de traitement. <br><br>  Enfin, consid√©rons un syst√®me dans lequel une t√¢che par minute arrive et le traitement des t√¢ches prend deux minutes.  Un tel syst√®me perdra constamment ses performances.  La longueur de la file d'attente des t√¢ches augmentera avec le d√©lai entre la r√©ception et le traitement des t√¢ches (et le degr√© de g√™ne des utilisateurs). <br><br>  Les valeurs de ces deux indicateurs doivent √™tre surveill√©es en permanence.  En faisant la moyenne du temps entre la r√©ception des t√¢ches pendant une longue p√©riode de temps, par exemple, sur la base du nombre de t√¢ches par jour, nous obtenons une estimation de l'intervalle entre les t√¢ches.  Il est √©galement n√©cessaire de surveiller le temps de traitement moyen de la t√¢che (hors temps pass√© dans la file d'attente).  Dans une file d'attente de t√¢ches stable, le temps de traitement moyen des t√¢ches doit √™tre inf√©rieur √† l'intervalle entre les t√¢ches.  Pour garantir que cette condition est remplie, il est n√©cessaire d'ajuster dynamiquement le nombre de files d'attente disponibles de ressources informatiques.  Si les travaux sont trait√©s en parall√®le, le temps de traitement doit √™tre divis√© par le nombre de travaux trait√©s en parall√®le.  Par exemple, si une t√¢che est trait√©e par minute, mais que quatre t√¢ches sont trait√©es en parall√®le, le temps de traitement effectif d'une t√¢che est de 15 secondes, ce qui signifie que l'intervalle entre les t√¢ches doit √™tre d'au moins 16 secondes. <br><br>  Cette approche vous permet de cr√©er facilement un module pour faire √©voluer la file d'attente des t√¢ches vers le haut.  La r√©duction d'√©chelle est un peu plus probl√©matique.  N√©anmoins, il est possible d'utiliser les m√™mes calculs que pr√©c√©demment, en posant en plus la r√©serve de ressources informatiques d√©termin√©e par la voie heuristique.  Par exemple, vous pouvez r√©duire le nombre de t√¢ches parall√®les jusqu'√† ce que le temps de traitement pour une t√¢che soit de 90% de l'intervalle entre les t√¢ches. <br><br><h3>  Mod√®le multi-travailleurs </h3><br>  L'un des principaux sujets de ce livre est l'utilisation de conteneurs pour encapsuler et r√©utiliser le code.  Il est √©galement pertinent pour les mod√®les de mise en file d'attente des t√¢ches d√©crits dans ce chapitre.  En plus des conteneurs qui g√®rent la file d'attente elle-m√™me, vous pouvez r√©utiliser des groupes de conteneurs qui composent l'impl√©mentation des acteurs.  Supposons que vous ayez besoin de traiter chaque t√¢che d'une file d'attente de trois mani√®res diff√©rentes.  Par exemple, pour d√©tecter des visages sur une photo, associez-les √† des personnes sp√©cifiques, puis brouillez les parties correspondantes de l'image.  Vous pouvez placer tous les traitements dans un seul conteneur d'ex√©cution, mais il s'agit d'une solution unique qui ne peut pas √™tre r√©utilis√©e.  Pour couvrir autre chose, comme des voitures, sur la photo, vous devrez cr√©er un artiste conteneur √† partir de z√©ro. <br><br>  La possibilit√© de ce type de r√©utilisation peut √™tre obtenue en appliquant le mod√®le Multi-Worker, qui est en fait un cas sp√©cial du mod√®le Adapter d√©crit au d√©but du livre.  Le mod√®le Multi-Worker convertit un ensemble de conteneurs en un conteneur commun avec l'interface logicielle du conteneur en cours d'ex√©cution.  Ce conteneur partag√© d√©l√®gue le traitement √† plusieurs conteneurs r√©utilisables distincts.  Ce processus est sch√©matis√© sur la Fig.  10.4. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ei/wx/zv/eiwxzvdwvre9k_ftflo2xfz_bz4.png" alt="image"></div><br>  En r√©utilisant le code en combinant des conteneurs d'ex√©cution, le travail des personnes qui con√ßoivent des syst√®mes de traitement par lots distribu√©s est r√©duit. <br><br>  ¬ªPlus d'informations sur le livre sont disponibles sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le site Web de l'√©diteur</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Contenu</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Extrait</a> <br><br>  Pour habrozhitelami 20% de r√©duction sur le coupon - <b>Syst√®mes distribu√©s</b> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr440444/">https://habr.com/ru/post/fr440444/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr440432/index.html">Vendredi SciFi sur les m√©tiers du futur: ¬´Real Girls¬ª</a></li>
<li><a href="../fr440434/index.html">L'industrie automobile russe: la voie des technologies additives</a></li>
<li><a href="../fr440436/index.html">T√¢ches pratiques Java - pour les cours et autres activit√©s</a></li>
<li><a href="../fr440438/index.html">Pr√©-roll MQTT / UDP: configuration √† distance et signature num√©rique</a></li>
<li><a href="../fr440440/index.html">Comment j'ai obtenu un emploi avec un salaire de 300 000 $ dans la Silicon Valley</a></li>
<li><a href="../fr440446/index.html">S√©rie de webinaires TDMS Fair Workflow</a></li>
<li><a href="../fr440448/index.html">Qu'est-ce qui a mis fin √† l'histoire avec le programmeur sans-abri</a></li>
<li><a href="../fr440450/index.html">Il y a un rouble pour l'entr√©e, mais il n'y a pas d'issue: comment les fichiers tiers entrent dans la blockchain et que faire √† ce sujet</a></li>
<li><a href="../fr440454/index.html">Paul Graham: ce que j'ai appris de Hacker News</a></li>
<li><a href="../fr440458/index.html">Pr√©diction de l'√©tat du r√©seau VoIP sur la base des fichiers journaux de texte du serveur d'applications SIP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>