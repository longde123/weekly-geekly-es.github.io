<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçÆ üñåÔ∏è ü§ô Migraci√≥n de Nginx a Envoy Proxy üëçüèæ ‚ÜôÔ∏è üßòüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! Les traigo a su atenci√≥n la traducci√≥n de la publicaci√≥n: Migraci√≥n de Nginx a Envoy Proxy . 


 Envoy es un servidor proxy distribuido de ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Migraci√≥n de Nginx a Envoy Proxy</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469455/"><p>  Hola Habr!  Les traigo a su atenci√≥n la traducci√≥n de la publicaci√≥n: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Migraci√≥n de Nginx a Envoy Proxy</a> . </p><br><p>  Envoy es un servidor proxy distribuido de alto rendimiento (escrito en C ++) dise√±ado para servicios y aplicaciones individuales, tambi√©n es un bus de comunicaci√≥n y un "plano de datos universal" dise√±ado para grandes arquitecturas de "servicio de malla" de microservicios.  Cuando se cre√≥, se tuvieron en cuenta las soluciones a los problemas que surgieron durante el desarrollo de servidores como NGINX, HAProxy, equilibradores de carga de hardware y equilibradores de carga en la nube.  Envoy funciona con todas las aplicaciones y abstrae la red, proporcionando funciones comunes independientemente de la plataforma.  Cuando todo el tr√°fico de la oficina en la infraestructura pasa a trav√©s de la cuadr√≠cula Envoy, se vuelve f√°cil visualizar las √°reas problem√°ticas con una observaci√≥n constante, sintonizando el rendimiento general y agregando funciones b√°sicas en un lugar espec√≠fico. </p><br><h2 id="vozmozhnosti">  Las posibilidades </h2><br><ul><li> Arquitectura fuera de proceso: enviado es un servidor independiente de alto rendimiento que consume una peque√±a cantidad de RAM.  Funciona en conjunci√≥n con cualquier lenguaje o marco de aplicaci√≥n. </li><li>  Soporte para http / 2 y grpc: envoy tiene soporte de primera clase para http / 2 y grpc para conexiones entrantes y salientes.  Este es un proxy transparente de http / 1.1 a http / 2. </li><li>  Equilibrio de carga mejorado: enviado admite funciones avanzadas de equilibrio de carga, incluidos los reintentos autom√°ticos, circuito abierto, l√≠mite de velocidad global, solicitudes de sombreado, equilibrio de carga de zona local, etc. </li><li>  API de gesti√≥n de configuraci√≥n: enviado proporciona una API robusta para gestionar din√°micamente su configuraci√≥n. </li><li>  Observabilidad: observabilidad profunda del tr√°fico L7, soporte integrado para rastreo distribuido y observabilidad de mongodb, dynamodb y muchas otras aplicaciones. </li></ul><a name="habracut"></a><br><h2 id="shag-1---primer-konfiga-nginx">  Paso 1 - Ejemplo de configuraci√≥n NGINX </h2><br><p>  Este script utiliza un archivo <em>nginx.conf</em> especialmente creado, basado en un ejemplo completo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NGINX Wiki</a> .  Puede ver la configuraci√≥n en el editor abriendo <em>nginx.conf</em> </p><br><p>  Fuente nginx config </p><br><pre><code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">user</span></span> www www; <span class="hljs-attribute"><span class="hljs-attribute">pid</span></span> /var/run/nginx.pid; <span class="hljs-attribute"><span class="hljs-attribute">worker_processes</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-section"><span class="hljs-section">events</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">worker_connections</span></span> <span class="hljs-number"><span class="hljs-number">2000</span></span>; } <span class="hljs-section"><span class="hljs-section">http</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">gzip</span></span> <span class="hljs-literal"><span class="hljs-literal">on</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">gzip_min_length</span></span> <span class="hljs-number"><span class="hljs-number">1100</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">gzip_buffers</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">8k</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">gzip_types</span></span> text/plain; <span class="hljs-attribute"><span class="hljs-attribute">log_format</span></span> main <span class="hljs-string"><span class="hljs-string">'</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$remote_addr</span></span></span><span class="hljs-string"> - </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$remote_user</span></span></span><span class="hljs-string"> [</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$time_local</span></span></span><span class="hljs-string">] '</span></span> <span class="hljs-string"><span class="hljs-string">'"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$request</span></span></span><span class="hljs-string">" </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$status</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$bytes_sent</span></span></span><span class="hljs-string"> '</span></span> <span class="hljs-string"><span class="hljs-string">'"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$http_referer</span></span></span><span class="hljs-string">" "</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$http_user_agent</span></span></span><span class="hljs-string">" '</span></span> <span class="hljs-string"><span class="hljs-string">'"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$gzip_ratio</span></span></span><span class="hljs-string">"'</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">log_format</span></span> download <span class="hljs-string"><span class="hljs-string">'</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$remote_addr</span></span></span><span class="hljs-string"> - </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$remote_user</span></span></span><span class="hljs-string"> [</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$time_local</span></span></span><span class="hljs-string">] '</span></span> <span class="hljs-string"><span class="hljs-string">'"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$request</span></span></span><span class="hljs-string">" </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$status</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$bytes_sent</span></span></span><span class="hljs-string"> '</span></span> <span class="hljs-string"><span class="hljs-string">'"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$http_referer</span></span></span><span class="hljs-string">" "</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$http_user_agent</span></span></span><span class="hljs-string">" '</span></span> <span class="hljs-string"><span class="hljs-string">'"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$http_range</span></span></span><span class="hljs-string">" "</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$sent_http_content_range</span></span></span><span class="hljs-string">"'</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">upstream</span></span> targetCluster { 172.18.0.3:80; 172.18.0.4:80; } <span class="hljs-section"><span class="hljs-section">server</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">listen</span></span> <span class="hljs-number"><span class="hljs-number">8080</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">server_name</span></span> one.example.com www.one.example.com; <span class="hljs-attribute"><span class="hljs-attribute">access_log</span></span> /var/log/nginx.access_log main; <span class="hljs-attribute"><span class="hljs-attribute">error_log</span></span> /var/log/nginx.error_log <span class="hljs-literal"><span class="hljs-literal">info</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> / { <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> http://targetCluster/; <span class="hljs-attribute"><span class="hljs-attribute">proxy_redirect</span></span> <span class="hljs-literal"><span class="hljs-literal">off</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> Host <span class="hljs-variable"><span class="hljs-variable">$host</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Real-IP <span class="hljs-variable"><span class="hljs-variable">$remote_addr</span></span>; } } }</code> </pre> <br><p>  Las configuraciones de NGINX generalmente tienen tres elementos clave: </p><br><ol><li>  Configuraci√≥n del servidor NGINX, la estructura de registro y la funcionalidad de Gzip.  Esto se determina globalmente en todos los casos. </li><li>  Configurar NGINX para aceptar solicitudes de host <em>one.example.com</em> en el puerto 8080. </li><li>  Establecer su ubicaci√≥n de destino, c√≥mo manejar el tr√°fico para diferentes partes de la URL. </li></ol><br><p>  No toda la configuraci√≥n se aplicar√° a Envoy Proxy, y no necesita configurar algunos ajustes.  Envoy Proxy tiene <strong>cuatro tipos clave</strong> que admiten la infraestructura subyacente que ofrece NGINX.  El n√∫cleo es: </p><br><ul><li>  <strong>Oyentes:</strong> determinan c√≥mo Envoy Proxy acepta las solicitudes entrantes.  Envoy Proxy actualmente solo es compatible con escuchas basadas en TCP.  Una vez que se establece la conexi√≥n, se transfiere a un conjunto de filtros para su procesamiento. </li><li>  <strong>Filtros:</strong> forman parte de una arquitectura canalizada que puede procesar datos entrantes y salientes.  Esta funcionalidad incluye filtros, como Gzip, que comprime los datos antes de enviarlos al cliente. </li><li>  <strong>Enrutadores:</strong> Redirigen el tr√°fico al destino deseado, definido como un cl√∫ster. </li><li>  <strong>Cl√∫steres:</strong> definen el punto final para el tr√°fico y la configuraci√≥n. </li></ul><br><p>  Utilizaremos estos cuatro componentes para crear la configuraci√≥n de Envoy Proxy para que coincida con la configuraci√≥n espec√≠fica de NGINX.  El objetivo de Envoy es trabajar con la API y la configuraci√≥n din√°mica.  En este caso, la configuraci√≥n b√°sica utilizar√° par√°metros est√°ticos codificados de NGINX. </p><br><h2 id="shag-2---konfiguraciya-nginx">  Paso 2 - Configurar NGINX </h2><br><p>  La primera parte de <em>nginx.conf</em> define algunos de los componentes internos de NGINX que deben configurarse. </p><br><h4 id="worker-connections-rabochie-soedineniya">  Conexiones de trabajadores </h4><br><p>  La siguiente configuraci√≥n determina la cantidad de procesos de trabajo y conexiones.  Esto indica c√≥mo NGINX escalar√° para satisfacer la demanda. </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">worker_processes</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-section"><span class="hljs-section">events</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">worker_connections</span></span> <span class="hljs-number"><span class="hljs-number">2000</span></span>; }</code> </pre> <br><p>  Envoy Proxy gestiona los flujos de trabajo y las conexiones de manera diferente. </p><br><p>  Envoy crea un flujo de trabajo para cada hilo de hardware en el sistema.  Cada subproceso de trabajo ejecuta un bucle de evento sin bloqueo que es responsable de </p><br><ol><li>  Escuchando a cada oyente </li><li>  Aceptar nuevas conexiones </li><li>  Crear un conjunto de filtros para una conexi√≥n </li><li>  Manejo de todas las operaciones de E / S durante la vida √∫til de una conexi√≥n. </li></ol><br><p>  Todo el procesamiento de conexi√≥n adicional se procesa completamente en el flujo de trabajo, incluido cualquier comportamiento de reenv√≠o. </p><br><p>  Para cada flujo de trabajo en Envoy, hay una conexi√≥n en el grupo.  Por lo tanto, los grupos de conexiones HTTP / 2 establecen solo una conexi√≥n para cada host externo a la vez; si hay cuatro subprocesos de trabajo, habr√° cuatro conexiones HTTP / 2 para cada host externo en un estado estable.  Al almacenar todo en un flujo de trabajo, casi todo el c√≥digo se puede escribir sin bloqueo, como si fuera un subproceso √∫nico.  Si se asignan flujos de trabajo m√°s de lo necesario, esto puede conducir a un uso no racional de la memoria, la creaci√≥n de una gran cantidad de conexiones inactivas y una disminuci√≥n en la cantidad de conexiones devueltas al grupo. </p><br><p>  Para obtener m√°s informaci√≥n, visite el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">blog Envoy Proxy</a> . </p><br><h4 id="konfiguraciya-http">  Configuraci√≥n HTTP </h4><br><p>  El siguiente bloque de configuraci√≥n de NGINX define la configuraci√≥n de HTTP, como: </p><br><ul><li>  Qu√© tipos de mime son compatibles </li><li>  Tiempos de espera predeterminados </li><li>  Configuraci√≥n de Gzip </li></ul><br><p>  Puede configurar estos aspectos utilizando filtros en Envoy Proxy, que discutiremos m√°s adelante. </p><br><h2 id="shag-3---konfiguraciya-server">  Paso 3 - Configuraci√≥n del servidor </h2><br><p>  En el bloque de configuraci√≥n HTTP, la configuraci√≥n NGINX le indica que escuche en el puerto 8080 y responda a las solicitudes entrantes para los dominios <em>one.example.com</em> y <em>www.one.example.com</em> . </p><br><pre> <code class="nginx hljs"> <span class="hljs-section"><span class="hljs-section">server</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">listen</span></span> <span class="hljs-number"><span class="hljs-number">8080</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">server_name</span></span> one.example.com www.one.example.com;</code> </pre> <br><p>  Dentro del Enviado, los oyentes lo controlan. </p><br><h4 id="slushateli-envoy">  Enviados oyentes </h4><br><p>  El aspecto m√°s importante para comenzar con Envoy Proxy es identificar a los oyentes.  Debe crear un archivo de configuraci√≥n que describa c√≥mo desea ejecutar una instancia de Envoy. </p><br><p>  El fragmento a continuaci√≥n crear√° un nuevo oyente y lo asociar√° con el puerto 8080. La configuraci√≥n le dice a Envoy Proxy a qu√© puertos debe estar vinculado para las solicitudes entrantes. </p><br><p>  Envoy Proxy utiliza la notaci√≥n YAML para su configuraci√≥n.  Para familiarizarse con esta notaci√≥n, vea el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enlace</a> aqu√≠. </p><br><pre> <code class="plaintext hljs">Copy to Editorstatic_resources: listeners: - name: listener_0 address: socket_address: { address: 0.0.0.0, port_value: 8080 }</code> </pre> <br><p>  No hay necesidad de definir <em>nombre_servidor</em> , ya que los filtros de Envoy Proxy pueden manejar esto. </p><br><h2 id="shag-4---konfiguraciya-mestopolozheniya">  Paso 4 - Configuraci√≥n de ubicaci√≥n </h2><br><p>  Cuando llega una solicitud a NGINX, el bloque de ubicaci√≥n determina c√≥mo procesar y d√≥nde dirigir el tr√°fico.  En el siguiente fragmento, todo el tr√°fico hacia el sitio se transmite a un cl√∫ster en sentido ascendente (nota del traductor: en sentido ascendente suele ser un servidor de aplicaciones) denominado <em>targetCluster</em> .  El cl√∫ster ascendente define los nodos que deben procesar la solicitud.  Discutiremos esto en el siguiente paso. </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">location</span></span> / { <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> http://targetCluster/; <span class="hljs-attribute"><span class="hljs-attribute">proxy_redirect</span></span> <span class="hljs-literal"><span class="hljs-literal">off</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> Host <span class="hljs-variable"><span class="hljs-variable">$host</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Real-IP <span class="hljs-variable"><span class="hljs-variable">$remote_addr</span></span>; }</code> </pre> <br><p>  En Envoy, Filters hace esto. </p><br><h4 id="envoy-filters">  Filtros de enviado </h4><br><p>  Para una configuraci√≥n est√°tica, los filtros determinan c√≥mo manejar las solicitudes entrantes.  En este caso, establecemos filtros que coinciden con <em>server_names</em> en el paso anterior.  Cuando llegan solicitudes entrantes que corresponden a dominios y rutas espec√≠ficos, el tr√°fico se enruta al cl√∫ster.  Este es el equivalente de la configuraci√≥n ascendente NGINX. </p><br><pre> <code class="plaintext hljs">Copy to Editor filter_chains: - filters: - name: envoy.http_connection_manager config: codec_type: auto stat_prefix: ingress_http route_config: name: local_route virtual_hosts: - name: backend domains: - "one.example.com" - "www.one.example.com" routes: - match: prefix: "/" route: cluster: targetCluster http_filters: - name: envoy.router</code> </pre> <br><p>  El nombre <em>envoy.http_connection_manager</em> es un filtro incorporado en Envoy Proxy.  Otros filtros incluyen <em>Redis</em> , <em>Mongo</em> , <em>TCP</em> .  Puede encontrar la lista completa en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n</a> . </p><br><p>  Para obtener m√°s informaci√≥n sobre otras pol√≠ticas de equilibrio de carga, visite la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Documentaci√≥n de Envoy</a> . </p><br><h2 id="step-5---proxy-and-upstream-configuration">  Paso 5 - Proxy y configuraci√≥n aguas arriba </h2><br><p>  En NGINX, la configuraci√≥n ascendente define el conjunto de servidores de destino que manejar√°n el tr√°fico.  En este caso, se asignaron dos grupos. </p><br><pre> <code class="nginx hljs"> <span class="hljs-attribute"><span class="hljs-attribute">upstream</span></span> targetCluster { 172.18.0.3:80; 172.18.0.4:80; }</code> </pre> <br><p>  En Envoy, se gestiona en cl√∫ster. </p><br><h4 id="envoy-clusters">  Grupos de enviados </h4><br><p>  El equivalente de aguas arriba se define como grupos.  En este caso, se identificaron los hosts que servir√°n al tr√°fico.  Un m√©todo para acceder a los hosts, como un tiempo de espera, se define como una configuraci√≥n de cl√∫ster.  Esto le permite controlar con mayor precisi√≥n la granularidad de aspectos como la latencia y el equilibrio de carga. </p><br><pre> <code class="plaintext hljs">Copy to Editor clusters: - name: targetCluster connect_timeout: 0.25s type: STRICT_DNS dns_lookup_family: V4_ONLY lb_policy: ROUND_ROBIN hosts: [ { socket_address: { address: 172.18.0.3, port_value: 80 }}, { socket_address: { address: 172.18.0.4, port_value: 80 }} ]</code> </pre> <br><p>  Cuando se utiliza el <em>descubrimiento de</em> servicio <em>STRICT_DNS,</em> Envoy resolver√° de forma continua y as√≠ncrona los objetivos DNS especificados.  Cada direcci√≥n IP devuelta como resultado de DNS se considerar√° un host expl√≠cito en el cl√∫ster ascendente.  Esto significa que si la solicitud devuelve dos direcciones IP, Envoy asumir√° que hay dos hosts en el cl√∫ster, y ambos deben tener una carga equilibrada.  Si el host se elimina del resultado, Envoy supone que ya no existe y seleccionar√° el tr√°fico de cualquier grupo de conexiones existente. </p><br><p>  Para obtener m√°s informaci√≥n, consulte la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n de proxy de Envoy</a> . </p><br><h2 id="shag-6---dostup-k-zhurnalu-i-oshibki">  Paso 6 - Acceso al registro y errores </h2><br><p>  La configuraci√≥n final es el registro.  En lugar de transferir registros de errores al disco, Envoy Proxy utiliza un enfoque basado en la nube.  Todos los registros de aplicaciones se muestran en <em>stdout</em> y <em>stderr</em> . </p><br><p>  Cuando los usuarios realizan una solicitud, los registros de acceso son opcionales y est√°n deshabilitados de manera predeterminada.  Para habilitar los registros de acceso para las solicitudes HTTP, habilite la configuraci√≥n de <em>access_log</em> para el Administrador de conexi√≥n HTTP.  La ruta puede ser un dispositivo, como <em>stdout</em> , o un archivo en el disco, seg√∫n sus requisitos. </p><br><p>  La siguiente configuraci√≥n redirigir√° todos los registros de acceso a <em>stdout</em> (nota del traductor: stdout es necesario para usar enviado dentro de Docker. Si lo usa sin docker, reemplace / dev / stdout con la ruta al archivo de registro normal).  Copie el fragmento a la secci√≥n de configuraci√≥n para el administrador de conexi√≥n: </p><br><pre> <code class="plaintext hljs">Copy to Clipboardaccess_log: - name: envoy.file_access_log config: path: "/dev/stdout"</code> </pre> <br><p>  Los resultados deber√≠an verse as√≠: </p><br><pre> <code class="plaintext hljs"> - name: envoy.http_connection_manager config: codec_type: auto stat_prefix: ingress_http access_log: - name: envoy.file_access_log config: path: "/dev/stdout" route_config:</code> </pre> <br><p>  Por defecto, Envoy tiene una cadena de formato que incluye los detalles de la solicitud HTTP: </p><br><pre> <code class="plaintext hljs">[%START_TIME%] "%REQ(:METHOD)% %REQ(X-ENVOY-ORIGINAL-PATH?:PATH)% %PROTOCOL%" %RESPONSE_CODE% %RESPONSE_FLAGS% %BYTES_RECEIVED% %BYTES_SENT% %DURATION% %RESP(X-ENVOY-UPSTREAM-SERVICE-TIME)% "%REQ(X-FORWARDED-FOR)%" "%REQ(USER-AGENT)%" "%REQ(X-REQUEST-ID)%" "%REQ(:AUTHORITY)%" "%UPSTREAM_HOST%"\n</code> </pre> <br><p>  El resultado de esta cadena de formato: </p><br><pre> <code class="bash hljs">[2018-11-23T04:51:00.281Z] <span class="hljs-string"><span class="hljs-string">"GET / HTTP/1.1"</span></span> 200 - 0 58 4 1 <span class="hljs-string"><span class="hljs-string">"-"</span></span> <span class="hljs-string"><span class="hljs-string">"curl/7.47.0"</span></span> <span class="hljs-string"><span class="hljs-string">"f21ebd42-6770-4aa5-88d4-e56118165a7d"</span></span> <span class="hljs-string"><span class="hljs-string">"one.example.com"</span></span> <span class="hljs-string"><span class="hljs-string">"172.18.0.4:80"</span></span></code> </pre> <br><p>  El contenido de la salida se puede personalizar configurando el campo de formato.  Por ejemplo: </p><br><pre> <code class="plaintext hljs">access_log: - name: envoy.file_access_log config: path: "/dev/stdout" format: "[%START_TIME%] "%REQ(:METHOD)% %REQ(X-ENVOY-ORIGINAL-PATH?:PATH)% %PROTOCOL%" %RESPONSE_CODE% %RESP(X-ENVOY-UPSTREAM-SERVICE-TIME)% "%REQ(X-REQUEST-ID)%" "%REQ(:AUTHORITY)%" "%UPSTREAM_HOST%"\n"</code> </pre> <br><p>  La cadena de registro tambi√©n se puede generar en formato JSON configurando el campo <em>json_format</em> .  Por ejemplo: </p><br><pre> <code class="plaintext hljs">access_log: - name: envoy.file_access_log config: path: "/dev/stdout" json_format: {"protocol": "%PROTOCOL%", "duration": "%DURATION%", "request_method": "%REQ(:METHOD)%"}</code> </pre> <br><p>  Para obtener m√°s informaci√≥n sobre las t√©cnicas de registro de enviados, visite </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://www.envoyproxy.io/docs/envoy/latest/configuration/access_log#config-access-log-format-dictionaries</a> </p><br><p>  El registro no es la √∫nica forma de hacerse una idea de trabajar con Envoy Proxy.  Tiene funciones avanzadas incorporadas para rastreo y m√©tricas.  Puede obtener m√°s informaci√≥n en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n de seguimiento</a> o mediante el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Script de seguimiento interactivo</a> . </p><br><h2 id="shag-7---zapusk">  Paso 7 - Lanzamiento </h2><br><p>  Ahora ha transferido la configuraci√≥n de NGINX a Envoy Proxy.  El √∫ltimo paso es ejecutar una instancia de Envoy Proxy para probarlo. </p><br><h4 id="zapusk-ot-polzovatelya">  Ejecutar desde usuario </h4><br><p>  En la parte superior de la configuraci√≥n de NGINX, el <em>usuario de</em> l√≠nea <em>www www;</em>  indica que NGINX se ha lanzado como un usuario con pocos privilegios para mejorar la seguridad. </p><br><p>  Envoy Proxy adopta un enfoque basado en la nube para administrar qui√©n es el propietario del proceso.  Cuando ejecutamos Envoy Proxy a trav√©s del contenedor, podemos especificar un usuario con un nivel de privilegio bajo. </p><br><h4 id="zapusk-envoy-proxy">  Lanzar Envoy Proxy </h4><br><p>  El siguiente comando iniciar√° Envoy Proxy a trav√©s del contenedor Docker en el host.  Este comando proporciona a Envoy la capacidad de escuchar las solicitudes entrantes a trav√©s del puerto 80. Sin embargo, como se indica en la configuraci√≥n de escucha, Envoy Proxy escucha el tr√°fico entrante a trav√©s del puerto 8080. Esto permite que el proceso se ejecute como un usuario con pocos privilegios. </p><br><pre> <code class="bash hljs">docker run --name proxy1 -p 80:8080 --user 1000:1000 -v /root/envoy.yaml:/etc/envoy/envoy.yaml envoyproxy/envoy</code> </pre> <br><h4 id="testirovanie">  Prueba </h4><br><p>  Con los servidores proxy en ejecuci√≥n, las pruebas ahora se pueden hacer y procesar.  El siguiente comando cURL emite una solicitud con el encabezado del host definido en la configuraci√≥n del proxy. </p><br><pre> <code class="bash hljs">curl -H <span class="hljs-string"><span class="hljs-string">"Host: one.example.com"</span></span> localhost -i</code> </pre> <br><p>  Una solicitud HTTP generar√° el error <em>503</em> .  Esto se debe al hecho de que las conexiones ascendentes no funcionan y no est√°n disponibles.  Por lo tanto, Envoy Proxy no tiene destinos de destino disponibles para la solicitud.  El siguiente comando lanzar√° una serie de servicios HTTP que coinciden con la configuraci√≥n definida para Envoy. </p><br><pre> <code class="bash hljs">docker run -d katacoda/docker-http-server; docker run -d katacoda/docker-http-server;</code> </pre> <br><p>  Con los servicios disponibles, Envoy puede enviar con √©xito el tr√°fico a su destino. </p><br><pre> <code class="bash hljs">curl -H <span class="hljs-string"><span class="hljs-string">"Host: one.example.com"</span></span> localhost -i</code> </pre> <br><p>  Deber√≠a ver una respuesta que indica qu√© contenedor de Docker ha procesado la solicitud.  En los registros de Envoy Proxy, tambi√©n deber√≠a ver la cadena de acceso que se muestra. </p><br><h4 id="dopolnitelnye-zagolovki-otveta-http-http-response">  Encabezados de respuesta HTTP adicionales </h4><br><p>  Ver√° encabezados HTTP adicionales en los encabezados de respuesta de la solicitud real.  El encabezado muestra el tiempo que el host ascendente pas√≥ procesando la solicitud.  Se expresa en milisegundos.  Esto es √∫til si el cliente desea determinar el tiempo de servicio en comparaci√≥n con la latencia de la red. </p><br><pre> <code class="plaintext hljs">x-envoy-upstream-service-time: 0 server: envoy</code> </pre> <br><h2 id="itogovyy-konfig">  Configuraci√≥n final </h2><br><pre> <code class="plaintext hljs">static_resources: listeners: - name: listener_0 address: socket_address: { address: 0.0.0.0, port_value: 8080 } filter_chains: - filters: - name: envoy.http_connection_manager config: codec_type: auto stat_prefix: ingress_http route_config: name: local_route virtual_hosts: - name: backend domains: - "one.example.com" - "www.one.example.com" routes: - match: prefix: "/" route: cluster: targetCluster http_filters: - name: envoy.router clusters: - name: targetCluster connect_timeout: 0.25s type: STRICT_DNS dns_lookup_family: V4_ONLY lb_policy: ROUND_ROBIN hosts: [ { socket_address: { address: 172.18.0.3, port_value: 80 }}, { socket_address: { address: 172.18.0.4, port_value: 80 }} ] admin: access_log_path: /tmp/admin_access.log address: socket_address: { address: 0.0.0.0, port_value: 9090 }</code> </pre> <br><h2 id="dopolnitelnaya-informaciya-ot-perevodchika">  Informaci√≥n adicional del traductor </h2><br><p>  Las instrucciones de instalaci√≥n de Envoy Proxy se pueden encontrar en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://www.getenvoy.io/</a> </p><br><p>  Por defecto en rpm no hay configuraci√≥n de servicio systemd. </p><br><p>  Agregue la configuraci√≥n del servicio systemd /etc/systemd/system/envoy.service: </p><br><pre> <code class="bash hljs">[Unit] Description=Envoy Proxy Documentation=https://www.envoyproxy.io/ After=network-online.target Requires=envoy-auth-server.service Wants=nginx.service [Service] User=root Restart=on-failure ExecStart=/usr/bin/envoy --config-path /etc/envoy/config.yaml [Install] WantedBy=multi-user.target</code> </pre> <br><p>  Debe crear el directorio / etc / envoy / y colocar la configuraci√≥n config.yaml all√≠. </p><br><p>  Por proxy enviado hay un chat de telegramas: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://t.me/envoyproxy_ru</a> </p><br><p>  Envoy Proxy no admite la distribuci√≥n de contenido est√°tico.  Entonces, ¬øqui√©n puede votar por la funci√≥n: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/envoyproxy/envoy/issues/378</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/469455/">https://habr.com/ru/post/469455/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../469445/index.html">Descripci√≥n general de AngularConnect 2019. Parte 2</a></li>
<li><a href="../469447/index.html">El camino de la inteligencia artificial de una idea fant√°stica a la industria cient√≠fica.</a></li>
<li><a href="../469449/index.html">Certificados EV SSL: ¬øhay vida despu√©s de la muerte?</a></li>
<li><a href="../469451/index.html">Filosof√≠a del cero</a></li>
<li><a href="../469453/index.html">Gesti√≥n de un equipo distribuido en modo multiproyecto (informe de revisi√≥n y video)</a></li>
<li><a href="../469457/index.html">Hacia d√≥nde conduce Extravaganza</a></li>
<li><a href="../469459/index.html">Conexi√≥n de dispositivos IoT en Smart City</a></li>
<li><a href="../469461/index.html">"A las estrellas": Antic√≥smico "Apocalipsis hoy"</a></li>
<li><a href="../469463/index.html">Tendencias y pron√≥sticos en el procesamiento del lenguaje natural</a></li>
<li><a href="../469465/index.html">Inicializaci√≥n en C ++ moderno</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>