<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⏱️ ♓️ 👵🏾 Was ist eine virtuelle Tischtabelle? 👩🏾‍🌾 😲 🔸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bei Slack stieß ich auf ein neues Akronym für mein C ++ - Akronym-Glossar : "VTT". Godbolt : 



test.o: In function `MyClass': test.cc:3: undefined r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Was ist eine virtuelle Tischtabelle?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474318/">  Bei Slack stieß ich auf ein neues Akronym für mein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C ++ - Akronym-Glossar</a> : "VTT".  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Godbolt</a> : <br><br><pre><code class="plaintext hljs">test.o: In function `MyClass': test.cc:3: undefined reference to `VTT for MyClass'</code> </pre> <br>  "VTT" bedeutet in diesem Zusammenhang "virtuelle Tabellentabelle".  Dies ist eine zusätzliche Datenstruktur, die (in Itanium C ++ ABI) beim Erstellen einiger Basisklassen verwendet wird, die selbst von virtuellen Basisklassen geerbt werden.  VTTs folgen denselben Layoutregeln wie virtuelle Tabellen (vtable) und Typinformationen (typeinfo). Wenn Sie also den obigen Fehler erhalten, können Sie "vTT" nur mental durch "vtable" ersetzen und mit dem Debuggen beginnen.  (Höchstwahrscheinlich haben Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schlüsselfunktion der</a> Klasse undefiniert gelassen).  Um zu sehen, warum VTT oder eine ähnliche Struktur erforderlich ist, beginnen wir mit den Grundlagen. <br><a name="habracut"></a><br><h3>  Entwurfsauftrag für nicht virtuelle Vererbung </h3><br>  Wenn wir eine Vererbungshierarchie haben, werden Basisklassen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ausgehend von den grundlegendsten erstellt</a> .  Um Charlie zu konstruieren, müssen wir zuerst seine Elternklassen MrsBucket und MrBucket rekursiv konstruieren. Um MrBucket zu konstruieren, müssen wir zuerst seine Elternklassen GrandmaJosephine und GrandpaJoe konstruieren. <br><br>  So: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> :</span></span> A {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D</span></span></span><span class="hljs-class"> :</span></span> C {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class"> :</span></span> B, D {}; <span class="hljs-comment"><span class="hljs-comment">//     // ABCDE</span></span></code> </pre> <br><h3>  Entwurfsauftrag für virtuelle Basisklassen </h3><br>  Aber die virtuelle Vererbung verwirrt alle Karten!  Mit der virtuellen Vererbung können wir eine rautenförmige Hierarchie haben, in der zwei verschiedene übergeordnete Klassen einen gemeinsamen Vorfahren haben können. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">G</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">M</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> G {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> G {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class"> :</span></span> M, F {}; <span class="hljs-comment"><span class="hljs-comment">//     // GMFE</span></span></code> </pre> <br>  Im letzten Abschnitt war jeder Konstruktor dafür verantwortlich, den Konstruktor seiner Basisklasse aufzurufen.  Aber jetzt haben wir eine virtuelle Vererbung, und die Konstruktoren M und F müssen irgendwie wissen, dass es nicht notwendig ist, G zu konstruieren, weil es üblich ist.  Wenn M und F in diesem Fall für die Konstruktion der Basisobjekte verantwortlich wären, würde das gemeinsame Basisobjekt zweimal konstruiert, was nicht sehr gut ist. <br><br>  Um mit Unterobjekten für die virtuelle Vererbung zu arbeiten, unterteilt Itanium C ++ ABI jeden Konstruktor in zwei Teile: den Basisobjektkonstruktor und den vollständigen Objektkonstruktor.  Der Konstruktor des Basisobjekts ist dafür verantwortlich, alle nicht virtuellen Vererbungsunterobjekte (und ihre Unterobjekte) zu erstellen, ihre vptr auf ihrer vtable zu installieren und den Code in geschweiften Klammern in C ++ - Code auszuführen).  Der Konstruktor des vollständigen Objekts, der jedes Mal aufgerufen wird, wenn Sie das vollständige C ++ - Objekt erstellen, ist für die Erstellung aller Unterobjekte der virtuellen Vererbung des abgeleiteten Objekts verantwortlich und erledigt dann den Rest. <br><br>  Betrachten Sie den Unterschied zwischen unserem ABCDE-Beispiel aus dem vorherigen Abschnitt und dem folgenden Beispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> A {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> C {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class"> :</span></span> B, D {}; <span class="hljs-comment"><span class="hljs-comment">//     // ACBDE</span></span></code> </pre> <br>  Der Konstruktor des vollständigen Objekts E ruft zuerst die Konstruktoren des Basisobjekts der virtuellen Unterobjekte A und C auf;  dann werden die Konstruktoren des nicht virtuellen Basisvererbungsobjekts B und D aufgerufen. B und D sind nicht länger für die Konstruktion von A bzw. C verantwortlich. <br><br><h3>  Entwerfen von vtable-Tabellen </h3><br>  Angenommen, wir haben eine Klasse mit einigen virtuellen Methoden, zum Beispiel ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Godbolt</a> ): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cat</span></span></span><span class="hljs-class"> {</span></span> Cat() { poke(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">poke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"meow"</span></span>); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lion</span></span></span><span class="hljs-class"> :</span></span> Cat { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> roar = <span class="hljs-string"><span class="hljs-string">"roar"</span></span>; Lion() { poke(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">poke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ roar += <span class="hljs-string"><span class="hljs-string">'!'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(roar.c_str()); } };</code> </pre> <br>  Wenn wir Lion konstruieren, konstruieren wir zunächst das grundlegende Cat-Unterobjekt.  Der Konstruktor von Cat ruft poke () auf.  Zu diesem Zeitpunkt haben wir nur ein Cat-Objekt - wir haben die Mitgliedsdaten, die zum Erstellen des Lion-Objekts erforderlich sind, noch nicht initialisiert.  Wenn der Cat-Konstruktor Lion :: poke () aufruft, kann er versuchen, das nicht initialisierte Mitglied von std :: string roar zu ändern, und wir erhalten UB.  Der C ++ - Standard verpflichtet uns daher, dies im Cat-Konstruktor zu tun. Ein Aufruf der virtuellen Methode poke () sollte Cat :: poke () aufrufen, nicht Lion :: poke ()! <br><br>  Es gibt kein Problem.  Der Compiler veranlasst einfach Cat :: Cat () (sowohl die Version für das Basisobjekt als auch die Version für das vollständige Objekt), indem das vptr-Objekt auf die vtable des Cat-Objekts gesetzt wird.  Lion :: Lion () ruft Cat :: Cat () auf und setzt dann vptr auf den Zeiger auf die vtable-Tabelle für das Cat-Objekt in Lion zurück, bevor der Code in Klammern ausgeführt wird.  Kein Problem! <br><br><h3>  Offsets für virtuelle Vererbung </h3><br>  Lassen Sie Cat virtuell von Animal erben.  In der vtable für Cat werden dann nicht nur die Funktionszeiger für die virtuellen Mitgliedsfunktionen von Cat gespeichert, sondern auch der Offset des virtuellen Unterobjekts Animal in Cat.  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Godbolt</a> .) <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *data = <span class="hljs-string"><span class="hljs-string">"hi"</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cat</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> Animal { Cat() { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(data); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Nermal</span></span></span><span class="hljs-class"> :</span></span> Cat {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Garfield</span></span></span><span class="hljs-class"> :</span></span> Cat { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> padding; };</code> </pre> <br>  Der Cat-Konstruktor fragt das Mitglied Animal :: data ab.  Wenn dieses Cat-Objekt das Basis-Unterobjekt des Nermal-Objekts ist, befinden sich seine Mitgliedsdaten im Offset 8 direkt hinter vptr.  Wenn das Cat-Objekt jedoch das zugrunde liegende Unterobjekt des Garfield-Objekts ist, befinden sich die Elementdaten auf Versatz 16 hinter vptr und Garfield :: padding.  Um dies zu bewältigen, speichert Itanium ABI die Offsets der virtuellen Basisobjekte in der vtable des Cat-Objekts.  In der Tabelle für Cat-in-Nermal wird die Tatsache beibehalten, dass Animal, das zugrunde liegende Cat-Unterobjekt, im Offset 8 gespeichert ist.  Die vtable für Cat-in-Garfield behält die Tatsache bei, dass Animal, das zugrunde liegende Cat-Unterobjekt, bei Offset 16 gespeichert ist. <br><br>  Kombinieren Sie dies nun mit dem vorherigen Abschnitt.  Der Compiler muss sicherstellen, dass Cat :: Cat () (sowohl die Basisobjektversion als auch die vollständige Objektversion) mit der Installation von vptr in der vtable für Cat-in-Nermal oder in der vtable für Cat-in-Garfield beginnt, je nach Typ am meisten derivative Fazilität!  Aber wie funktioniert es? <br><br>  Der Konstruktor des vollständigen Objekts für das am meisten abgeleitete Objekt muss vorberechnen, auf welche Tabelle vtable der vptr des Basis-Unterobjekts während der Erstellung des Objekts verweisen soll, und dann muss der Konstruktor des vollständigen Objekts für das am meisten abgeleitete Objekt diese Informationen an den Konstruktor des Basisobjekts des Basis-Unterobjekts weitergeben als versteckter Parameter!  Schauen wir uns den generierten Code für Cat :: Cat () ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Godbolt</a> ) an: <br><br><pre> <code class="cpp hljs">_ZN3CatC1Ev: #    Cat movq $_ZTV3Cat+<span class="hljs-number"><span class="hljs-number">24</span></span>, (%rdi) <span class="hljs-meta"><span class="hljs-meta"># this-&gt;vptr = &amp;vtable-for-Cat; retq _ZN3CatC2Ev: #     Cat movq (%rsi), %rax # fetch a value from rsi movq %rax, (%rdi) # this-&gt;vptr = *rsi; retq</span></span></code> </pre> <br>  Der Konstruktor des Basisobjekts akzeptiert nicht nur diesen versteckten Parameter in% rdi, sondern auch den versteckten VTT-Parameter in% rsi!  Der Basisobjektkonstruktor lädt die Adresse von (% rsi) und speichert die Adresse in der vtable des Cat-Objekts. <br><br>  Wer den Konstruktor des Basis-Cat-Objekts aufruft, ist dafür verantwortlich, vorherzusagen, welche Cat :: Cat () -Adresse in vptr geschrieben werden soll, und den Zeiger in (% rsi) auf diese Adresse zu setzen. <br><br><h3>  Warum brauchen wir eine andere Identitätsebene? </h3><br>  Betrachten Sie den Konstruktor eines vollständigen Nermal-Objekts. <br><br><pre> <code class="cpp hljs">_ZN3CatC2Ev: #    <span class="hljs-function"><span class="hljs-function">Cat </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">movq</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%rsi)</span></span></span><span class="hljs-function">, %rax #    rsi movq %rax, </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%rdi)</span></span></span><span class="hljs-function"> </span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-meta"># this-&gt;vptr = *rsi; retq _ZN6NermalC1Ev: #    Nermal pushq %rbx movq %rdi, %rbx movl $_ZTT6Nermal+8, %esi # %rsi = &amp;VTT-for-Nermal callq _ZN3CatC2Ev #     Cat movq $_ZTV6Nermal+24, (%rbx) # this-&gt;vptr = &amp;vtable-for-Nermal popq %rbx retq _ZTT6Nermal: .quad _ZTV6Nermal+24 # vtable-for-Nermal .quad _ZTC6Nermal0_3Cat+24 # construction-vtable-for-Cat-in-Nermal</span></span></span></span></code> </pre> <br>  Warum befindet sich _ZTC6Nermal0_3Cat + 24 im Datenbereich und seine Adresse wird an% rsi übergeben, anstatt nur _ZTC6Nermal0_3Cat + 24 direkt zu übergeben? <br><br><pre> <code class="cpp hljs">#   ? _ZN3CatC2Ev: #     Cat movq %rsi, (%rdi) <span class="hljs-meta"><span class="hljs-meta"># this-&gt;vptr = rsi; retq _ZN6NermalC1Ev: #     Nermal pushq %rbx movq %rdi, %rbx movl $_ZTC6Nermal0_3Cat+24, %esi # %rsi = &amp;construction-vtable-for-Cat-in-Nermal callq _ZN3CatC2Ev #     Cat movq $_ZTV6Nermal+24, (%rbx) # this-&gt;vptr = &amp;vtable-for-Nermal popq %rbx retq</span></span></code> </pre> <br>  Dies liegt daran, dass wir mehrere Vererbungsebenen haben können!  Auf jeder Vererbungsebene sollte der Konstruktor des Basisobjekts vptr festlegen und dann möglicherweise die Kontrolle über die Kette an den nächsten Basiskonstruktor übergeben, der vptrs auf einen anderen Wert setzen kann.  Dies impliziert eine Liste oder eine Tabelle mit Zeigern auf vtable. <br><br>  Hier ist ein konkretes Beispiel ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Godbolt</a> ): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VB</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> member_of_vb = <span class="hljs-number"><span class="hljs-number">42</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Grandparent</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> VB { Grandparent() {} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parent</span></span></span><span class="hljs-class"> :</span></span> Grandparent { Parent() {} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Gretel</span></span></span><span class="hljs-class"> :</span></span> Parent { Gretel() : VB{<span class="hljs-number"><span class="hljs-number">1000</span></span>} {} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Hansel</span></span></span><span class="hljs-class"> :</span></span> Parent { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> padding; Hansel() : VB{<span class="hljs-number"><span class="hljs-number">2000</span></span>} {} };</code> </pre> <br>  Das Grandparent-Basiskonstruktorobjekt muss sein vptr auf Grandparent setzen - etwas anderes, das die am meisten abgeleitete Klasse ist.  Der Konstruktor des übergeordneten Basisobjekts muss zuerst Grandparent :: Grandparent () mit dem entsprechenden% rsi aufrufen und dann vptr auf Parent setzen - etwas anderes, das die am meisten abgeleitete Klasse ist.  Eine Möglichkeit, dies für Gretel umzusetzen: <br><br><pre> <code class="cpp hljs">Gretel::Gretel() [  ]: pushq %rbx movq %rdi, %rbx movl $<span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>(%rdi) <span class="hljs-meta"><span class="hljs-meta"># imm = 0x3E8 movl $VTT for Gretel+8, %esi callq Parent::Parent() [  ] movq $vtable for Gretel+24, (%rbx) popq %rbx retq VTT for Gretel: .quad vtable for Gretel+24 .quad construction vtable for Parent-in-Gretel+24 .quad construction vtable for Grandparent-in-Gretel+24</span></span></code> </pre> <br>  Sie können in Godbolt sehen, dass der Konstruktor des Basisobjekts der Parent-Klasse zuerst Grandparent :: Grandparent () mit% rsi + 8 aufruft und dann sein eigenes vptr auf (% rsi) setzt.  Hier nutzen wir also die Tatsache, dass Gretel sozusagen sorgfältig einen Weg der Brotkrumen gelegt hat, dem alle ihre Basisklassen während des Baus folgten. <br><br>  Das gleiche VTT wird im Destruktor ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Godbolt</a> ) verwendet.  Soweit ich weiß, wird die Nullzeile der VTT-Tabelle nie verwendet.  Der Gretel-Konstruktor lädt die vtable für Gretel + 24 in vptr, weiß jedoch, dass diese Adresse statisch ist und niemals aus VTT geladen werden muss.  Ich denke, dass die Nullzeile der Tabelle nur aus historischen Gründen erhalten blieb.  (Und natürlich kann der Compiler es nicht einfach wegwerfen, da es eine Verletzung von Itanium ABI darstellt und es unmöglich ist, auf alten Code zu verlinken, der Itanium-ABI entspricht.) <br><br>  Das ist alles, wir haben uns eine Tabelle mit virtuellen Tabellen oder VTT angesehen. <br><br><h3>  Weitere Informationen </h3><br>  Sie finden VTT-Informationen an folgenden Stellen: <br><br>  StackOverflow: „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was ist die VTT für eine Klasse?</a>  ” <br>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=http://web.archive.org/web/20190930143149/">VTable-Hinweise zur Mehrfachvererbung in GCC C ++ Compiler v4.0.1</a> " (Morgan Deters, 2005) <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der</a> Abschnitt „VTT-Bestellung“ von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Itanium C ++ ABI</a> <br><br>  Abschließend muss ich noch einmal betonen, dass VTT eine Funktion von Itanium C ++ ABI ist und unter Linux, OSX usw. verwendet wird.  Das unter Windows verwendete MSVC-ABI verfügt nicht über VTT und verwendet einen völlig anderen Mechanismus für die virtuelle Vererbung.  Ich weiß (bis jetzt) ​​fast nichts über MSVC ABI, aber vielleicht werde ich eines Tages alles herausfinden und einen Beitrag darüber schreiben! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de474318/">https://habr.com/ru/post/de474318/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de474306/index.html">Ändern Sie die Stile für Zeigen, Fokussieren und aktiven Status.</a></li>
<li><a href="../de474308/index.html">In Python geschriebene Typen für HTTP-APIs: Instagram-Erfahrung</a></li>
<li><a href="../de474310/index.html">Gibt es Zufallszahlen in CSS?</a></li>
<li><a href="../de474312/index.html">Installieren der GUI unter Windows Server Core</a></li>
<li><a href="../de474316/index.html">Selbstgemachtes Elektroauto Teil 1. Wie alles begann und wie ich 1.000.000 Aufrufe auf Youtube erzielte</a></li>
<li><a href="../de474320/index.html">DDD-Gemeinschaftskrise</a></li>
<li><a href="../de474322/index.html">ScalaConf 2019 - John Preacher, Heiliger Gral und Professor Haskell</a></li>
<li><a href="../de474324/index.html">Warum dreht sich die Sonne um die Erde?</a></li>
<li><a href="../de474326/index.html">Den Unterschied zwischen CI und CD verstehen: „Wenn etwas Schmerzen verursacht, tun Sie es öfter“</a></li>
<li><a href="../de474330/index.html">Die Zusammenfassung interessanter Materialien für den mobilen Entwickler # 320 (28. Oktober - 3. November)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>