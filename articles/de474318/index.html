<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚è±Ô∏è ‚ôìÔ∏è üëµüèæ Was ist eine virtuelle Tischtabelle? üë©üèæ‚Äçüåæ üò≤ üî∏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bei Slack stie√ü ich auf ein neues Akronym f√ºr mein C ++ - Akronym-Glossar : "VTT". Godbolt : 



test.o: In function `MyClass': test.cc:3: undefined r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Was ist eine virtuelle Tischtabelle?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474318/">  Bei Slack stie√ü ich auf ein neues Akronym f√ºr mein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C ++ - Akronym-Glossar</a> : "VTT".  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Godbolt</a> : <br><br><pre><code class="plaintext hljs">test.o: In function `MyClass': test.cc:3: undefined reference to `VTT for MyClass'</code> </pre> <br>  "VTT" bedeutet in diesem Zusammenhang "virtuelle Tabellentabelle".  Dies ist eine zus√§tzliche Datenstruktur, die (in Itanium C ++ ABI) beim Erstellen einiger Basisklassen verwendet wird, die selbst von virtuellen Basisklassen geerbt werden.  VTTs folgen denselben Layoutregeln wie virtuelle Tabellen (vtable) und Typinformationen (typeinfo). Wenn Sie also den obigen Fehler erhalten, k√∂nnen Sie "vTT" nur mental durch "vtable" ersetzen und mit dem Debuggen beginnen.  (H√∂chstwahrscheinlich haben Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schl√ºsselfunktion der</a> Klasse undefiniert gelassen).  Um zu sehen, warum VTT oder eine √§hnliche Struktur erforderlich ist, beginnen wir mit den Grundlagen. <br><a name="habracut"></a><br><h3>  Entwurfsauftrag f√ºr nicht virtuelle Vererbung </h3><br>  Wenn wir eine Vererbungshierarchie haben, werden Basisklassen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ausgehend von den grundlegendsten erstellt</a> .  Um Charlie zu konstruieren, m√ºssen wir zuerst seine Elternklassen MrsBucket und MrBucket rekursiv konstruieren. Um MrBucket zu konstruieren, m√ºssen wir zuerst seine Elternklassen GrandmaJosephine und GrandpaJoe konstruieren. <br><br>  So: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> :</span></span> A {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D</span></span></span><span class="hljs-class"> :</span></span> C {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class"> :</span></span> B, D {}; <span class="hljs-comment"><span class="hljs-comment">//     // ABCDE</span></span></code> </pre> <br><h3>  Entwurfsauftrag f√ºr virtuelle Basisklassen </h3><br>  Aber die virtuelle Vererbung verwirrt alle Karten!  Mit der virtuellen Vererbung k√∂nnen wir eine rautenf√∂rmige Hierarchie haben, in der zwei verschiedene √ºbergeordnete Klassen einen gemeinsamen Vorfahren haben k√∂nnen. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">G</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">M</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> G {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> G {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class"> :</span></span> M, F {}; <span class="hljs-comment"><span class="hljs-comment">//     // GMFE</span></span></code> </pre> <br>  Im letzten Abschnitt war jeder Konstruktor daf√ºr verantwortlich, den Konstruktor seiner Basisklasse aufzurufen.  Aber jetzt haben wir eine virtuelle Vererbung, und die Konstruktoren M und F m√ºssen irgendwie wissen, dass es nicht notwendig ist, G zu konstruieren, weil es √ºblich ist.  Wenn M und F in diesem Fall f√ºr die Konstruktion der Basisobjekte verantwortlich w√§ren, w√ºrde das gemeinsame Basisobjekt zweimal konstruiert, was nicht sehr gut ist. <br><br>  Um mit Unterobjekten f√ºr die virtuelle Vererbung zu arbeiten, unterteilt Itanium C ++ ABI jeden Konstruktor in zwei Teile: den Basisobjektkonstruktor und den vollst√§ndigen Objektkonstruktor.  Der Konstruktor des Basisobjekts ist daf√ºr verantwortlich, alle nicht virtuellen Vererbungsunterobjekte (und ihre Unterobjekte) zu erstellen, ihre vptr auf ihrer vtable zu installieren und den Code in geschweiften Klammern in C ++ - Code auszuf√ºhren).  Der Konstruktor des vollst√§ndigen Objekts, der jedes Mal aufgerufen wird, wenn Sie das vollst√§ndige C ++ - Objekt erstellen, ist f√ºr die Erstellung aller Unterobjekte der virtuellen Vererbung des abgeleiteten Objekts verantwortlich und erledigt dann den Rest. <br><br>  Betrachten Sie den Unterschied zwischen unserem ABCDE-Beispiel aus dem vorherigen Abschnitt und dem folgenden Beispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> A {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> C {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class"> :</span></span> B, D {}; <span class="hljs-comment"><span class="hljs-comment">//     // ACBDE</span></span></code> </pre> <br>  Der Konstruktor des vollst√§ndigen Objekts E ruft zuerst die Konstruktoren des Basisobjekts der virtuellen Unterobjekte A und C auf;  dann werden die Konstruktoren des nicht virtuellen Basisvererbungsobjekts B und D aufgerufen. B und D sind nicht l√§nger f√ºr die Konstruktion von A bzw. C verantwortlich. <br><br><h3>  Entwerfen von vtable-Tabellen </h3><br>  Angenommen, wir haben eine Klasse mit einigen virtuellen Methoden, zum Beispiel ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Godbolt</a> ): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cat</span></span></span><span class="hljs-class"> {</span></span> Cat() { poke(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">poke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"meow"</span></span>); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lion</span></span></span><span class="hljs-class"> :</span></span> Cat { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> roar = <span class="hljs-string"><span class="hljs-string">"roar"</span></span>; Lion() { poke(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">poke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ roar += <span class="hljs-string"><span class="hljs-string">'!'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(roar.c_str()); } };</code> </pre> <br>  Wenn wir Lion konstruieren, konstruieren wir zun√§chst das grundlegende Cat-Unterobjekt.  Der Konstruktor von Cat ruft poke () auf.  Zu diesem Zeitpunkt haben wir nur ein Cat-Objekt - wir haben die Mitgliedsdaten, die zum Erstellen des Lion-Objekts erforderlich sind, noch nicht initialisiert.  Wenn der Cat-Konstruktor Lion :: poke () aufruft, kann er versuchen, das nicht initialisierte Mitglied von std :: string roar zu √§ndern, und wir erhalten UB.  Der C ++ - Standard verpflichtet uns daher, dies im Cat-Konstruktor zu tun. Ein Aufruf der virtuellen Methode poke () sollte Cat :: poke () aufrufen, nicht Lion :: poke ()! <br><br>  Es gibt kein Problem.  Der Compiler veranlasst einfach Cat :: Cat () (sowohl die Version f√ºr das Basisobjekt als auch die Version f√ºr das vollst√§ndige Objekt), indem das vptr-Objekt auf die vtable des Cat-Objekts gesetzt wird.  Lion :: Lion () ruft Cat :: Cat () auf und setzt dann vptr auf den Zeiger auf die vtable-Tabelle f√ºr das Cat-Objekt in Lion zur√ºck, bevor der Code in Klammern ausgef√ºhrt wird.  Kein Problem! <br><br><h3>  Offsets f√ºr virtuelle Vererbung </h3><br>  Lassen Sie Cat virtuell von Animal erben.  In der vtable f√ºr Cat werden dann nicht nur die Funktionszeiger f√ºr die virtuellen Mitgliedsfunktionen von Cat gespeichert, sondern auch der Offset des virtuellen Unterobjekts Animal in Cat.  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Godbolt</a> .) <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *data = <span class="hljs-string"><span class="hljs-string">"hi"</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cat</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> Animal { Cat() { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(data); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Nermal</span></span></span><span class="hljs-class"> :</span></span> Cat {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Garfield</span></span></span><span class="hljs-class"> :</span></span> Cat { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> padding; };</code> </pre> <br>  Der Cat-Konstruktor fragt das Mitglied Animal :: data ab.  Wenn dieses Cat-Objekt das Basis-Unterobjekt des Nermal-Objekts ist, befinden sich seine Mitgliedsdaten im Offset 8 direkt hinter vptr.  Wenn das Cat-Objekt jedoch das zugrunde liegende Unterobjekt des Garfield-Objekts ist, befinden sich die Elementdaten auf Versatz 16 hinter vptr und Garfield :: padding.  Um dies zu bew√§ltigen, speichert Itanium ABI die Offsets der virtuellen Basisobjekte in der vtable des Cat-Objekts.  In der Tabelle f√ºr Cat-in-Nermal wird die Tatsache beibehalten, dass Animal, das zugrunde liegende Cat-Unterobjekt, im Offset 8 gespeichert ist.  Die vtable f√ºr Cat-in-Garfield beh√§lt die Tatsache bei, dass Animal, das zugrunde liegende Cat-Unterobjekt, bei Offset 16 gespeichert ist. <br><br>  Kombinieren Sie dies nun mit dem vorherigen Abschnitt.  Der Compiler muss sicherstellen, dass Cat :: Cat () (sowohl die Basisobjektversion als auch die vollst√§ndige Objektversion) mit der Installation von vptr in der vtable f√ºr Cat-in-Nermal oder in der vtable f√ºr Cat-in-Garfield beginnt, je nach Typ am meisten derivative Fazilit√§t!  Aber wie funktioniert es? <br><br>  Der Konstruktor des vollst√§ndigen Objekts f√ºr das am meisten abgeleitete Objekt muss vorberechnen, auf welche Tabelle vtable der vptr des Basis-Unterobjekts w√§hrend der Erstellung des Objekts verweisen soll, und dann muss der Konstruktor des vollst√§ndigen Objekts f√ºr das am meisten abgeleitete Objekt diese Informationen an den Konstruktor des Basisobjekts des Basis-Unterobjekts weitergeben als versteckter Parameter!  Schauen wir uns den generierten Code f√ºr Cat :: Cat () ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Godbolt</a> ) an: <br><br><pre> <code class="cpp hljs">_ZN3CatC1Ev: #    Cat movq $_ZTV3Cat+<span class="hljs-number"><span class="hljs-number">24</span></span>, (%rdi) <span class="hljs-meta"><span class="hljs-meta"># this-&gt;vptr = &amp;vtable-for-Cat; retq _ZN3CatC2Ev: #     Cat movq (%rsi), %rax # fetch a value from rsi movq %rax, (%rdi) # this-&gt;vptr = *rsi; retq</span></span></code> </pre> <br>  Der Konstruktor des Basisobjekts akzeptiert nicht nur diesen versteckten Parameter in% rdi, sondern auch den versteckten VTT-Parameter in% rsi!  Der Basisobjektkonstruktor l√§dt die Adresse von (% rsi) und speichert die Adresse in der vtable des Cat-Objekts. <br><br>  Wer den Konstruktor des Basis-Cat-Objekts aufruft, ist daf√ºr verantwortlich, vorherzusagen, welche Cat :: Cat () -Adresse in vptr geschrieben werden soll, und den Zeiger in (% rsi) auf diese Adresse zu setzen. <br><br><h3>  Warum brauchen wir eine andere Identit√§tsebene? </h3><br>  Betrachten Sie den Konstruktor eines vollst√§ndigen Nermal-Objekts. <br><br><pre> <code class="cpp hljs">_ZN3CatC2Ev: #    <span class="hljs-function"><span class="hljs-function">Cat </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">movq</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%rsi)</span></span></span><span class="hljs-function">, %rax #    rsi movq %rax, </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%rdi)</span></span></span><span class="hljs-function"> </span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-meta"># this-&gt;vptr = *rsi; retq _ZN6NermalC1Ev: #    Nermal pushq %rbx movq %rdi, %rbx movl $_ZTT6Nermal+8, %esi # %rsi = &amp;VTT-for-Nermal callq _ZN3CatC2Ev #     Cat movq $_ZTV6Nermal+24, (%rbx) # this-&gt;vptr = &amp;vtable-for-Nermal popq %rbx retq _ZTT6Nermal: .quad _ZTV6Nermal+24 # vtable-for-Nermal .quad _ZTC6Nermal0_3Cat+24 # construction-vtable-for-Cat-in-Nermal</span></span></span></span></code> </pre> <br>  Warum befindet sich _ZTC6Nermal0_3Cat + 24 im Datenbereich und seine Adresse wird an% rsi √ºbergeben, anstatt nur _ZTC6Nermal0_3Cat + 24 direkt zu √ºbergeben? <br><br><pre> <code class="cpp hljs">#   ? _ZN3CatC2Ev: #     Cat movq %rsi, (%rdi) <span class="hljs-meta"><span class="hljs-meta"># this-&gt;vptr = rsi; retq _ZN6NermalC1Ev: #     Nermal pushq %rbx movq %rdi, %rbx movl $_ZTC6Nermal0_3Cat+24, %esi # %rsi = &amp;construction-vtable-for-Cat-in-Nermal callq _ZN3CatC2Ev #     Cat movq $_ZTV6Nermal+24, (%rbx) # this-&gt;vptr = &amp;vtable-for-Nermal popq %rbx retq</span></span></code> </pre> <br>  Dies liegt daran, dass wir mehrere Vererbungsebenen haben k√∂nnen!  Auf jeder Vererbungsebene sollte der Konstruktor des Basisobjekts vptr festlegen und dann m√∂glicherweise die Kontrolle √ºber die Kette an den n√§chsten Basiskonstruktor √ºbergeben, der vptrs auf einen anderen Wert setzen kann.  Dies impliziert eine Liste oder eine Tabelle mit Zeigern auf vtable. <br><br>  Hier ist ein konkretes Beispiel ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Godbolt</a> ): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VB</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> member_of_vb = <span class="hljs-number"><span class="hljs-number">42</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Grandparent</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> VB { Grandparent() {} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parent</span></span></span><span class="hljs-class"> :</span></span> Grandparent { Parent() {} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Gretel</span></span></span><span class="hljs-class"> :</span></span> Parent { Gretel() : VB{<span class="hljs-number"><span class="hljs-number">1000</span></span>} {} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Hansel</span></span></span><span class="hljs-class"> :</span></span> Parent { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> padding; Hansel() : VB{<span class="hljs-number"><span class="hljs-number">2000</span></span>} {} };</code> </pre> <br>  Das Grandparent-Basiskonstruktorobjekt muss sein vptr auf Grandparent setzen - etwas anderes, das die am meisten abgeleitete Klasse ist.  Der Konstruktor des √ºbergeordneten Basisobjekts muss zuerst Grandparent :: Grandparent () mit dem entsprechenden% rsi aufrufen und dann vptr auf Parent setzen - etwas anderes, das die am meisten abgeleitete Klasse ist.  Eine M√∂glichkeit, dies f√ºr Gretel umzusetzen: <br><br><pre> <code class="cpp hljs">Gretel::Gretel() [  ]: pushq %rbx movq %rdi, %rbx movl $<span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>(%rdi) <span class="hljs-meta"><span class="hljs-meta"># imm = 0x3E8 movl $VTT for Gretel+8, %esi callq Parent::Parent() [  ] movq $vtable for Gretel+24, (%rbx) popq %rbx retq VTT for Gretel: .quad vtable for Gretel+24 .quad construction vtable for Parent-in-Gretel+24 .quad construction vtable for Grandparent-in-Gretel+24</span></span></code> </pre> <br>  Sie k√∂nnen in Godbolt sehen, dass der Konstruktor des Basisobjekts der Parent-Klasse zuerst Grandparent :: Grandparent () mit% rsi + 8 aufruft und dann sein eigenes vptr auf (% rsi) setzt.  Hier nutzen wir also die Tatsache, dass Gretel sozusagen sorgf√§ltig einen Weg der Brotkrumen gelegt hat, dem alle ihre Basisklassen w√§hrend des Baus folgten. <br><br>  Das gleiche VTT wird im Destruktor ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Godbolt</a> ) verwendet.  Soweit ich wei√ü, wird die Nullzeile der VTT-Tabelle nie verwendet.  Der Gretel-Konstruktor l√§dt die vtable f√ºr Gretel + 24 in vptr, wei√ü jedoch, dass diese Adresse statisch ist und niemals aus VTT geladen werden muss.  Ich denke, dass die Nullzeile der Tabelle nur aus historischen Gr√ºnden erhalten blieb.  (Und nat√ºrlich kann der Compiler es nicht einfach wegwerfen, da es eine Verletzung von Itanium ABI darstellt und es unm√∂glich ist, auf alten Code zu verlinken, der Itanium-ABI entspricht.) <br><br>  Das ist alles, wir haben uns eine Tabelle mit virtuellen Tabellen oder VTT angesehen. <br><br><h3>  Weitere Informationen </h3><br>  Sie finden VTT-Informationen an folgenden Stellen: <br><br>  StackOverflow: ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was ist die VTT f√ºr eine Klasse?</a>  ‚Äù <br>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=http://web.archive.org/web/20190930143149/">VTable-Hinweise zur Mehrfachvererbung in GCC C ++ Compiler v4.0.1</a> " (Morgan Deters, 2005) <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der</a> Abschnitt ‚ÄûVTT-Bestellung‚Äú von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Itanium C ++ ABI</a> <br><br>  Abschlie√üend muss ich noch einmal betonen, dass VTT eine Funktion von Itanium C ++ ABI ist und unter Linux, OSX usw. verwendet wird.  Das unter Windows verwendete MSVC-ABI verf√ºgt nicht √ºber VTT und verwendet einen v√∂llig anderen Mechanismus f√ºr die virtuelle Vererbung.  Ich wei√ü (bis jetzt) ‚Äã‚Äãfast nichts √ºber MSVC ABI, aber vielleicht werde ich eines Tages alles herausfinden und einen Beitrag dar√ºber schreiben! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de474318/">https://habr.com/ru/post/de474318/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de474306/index.html">√Ñndern Sie die Stile f√ºr Zeigen, Fokussieren und aktiven Status.</a></li>
<li><a href="../de474308/index.html">In Python geschriebene Typen f√ºr HTTP-APIs: Instagram-Erfahrung</a></li>
<li><a href="../de474310/index.html">Gibt es Zufallszahlen in CSS?</a></li>
<li><a href="../de474312/index.html">Installieren der GUI unter Windows Server Core</a></li>
<li><a href="../de474316/index.html">Selbstgemachtes Elektroauto Teil 1. Wie alles begann und wie ich 1.000.000 Aufrufe auf Youtube erzielte</a></li>
<li><a href="../de474320/index.html">DDD-Gemeinschaftskrise</a></li>
<li><a href="../de474322/index.html">ScalaConf 2019 - John Preacher, Heiliger Gral und Professor Haskell</a></li>
<li><a href="../de474324/index.html">Warum dreht sich die Sonne um die Erde?</a></li>
<li><a href="../de474326/index.html">Den Unterschied zwischen CI und CD verstehen: ‚ÄûWenn etwas Schmerzen verursacht, tun Sie es √∂fter‚Äú</a></li>
<li><a href="../de474330/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 320 (28. Oktober - 3. November)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>