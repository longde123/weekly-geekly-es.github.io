<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧠 💆🏻 🚷 游戏中过场动画和动作序列的实现 🖕🏽 📴 🙏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在本文中，我将讨论如何在视频游戏中实现一系列动作和过场动画。 本文是本文的翻译，并且是与我在莫斯科的Lua上发表的主题相同的主题，因此，如果您喜欢观看视频，可以在这里观看。 

 文章代码是用Lua编写的，但是可以轻松地用其他语言编写（使用协程的方法除外，因为协程不是全部语言）。 
 
 本文介绍了...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>游戏中过场动画和动作序列的实现</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427135/"> <i>在本文中，我将讨论如何在视频游戏中实现一系列动作和过场动画。</i>  <i>本文是本文的翻译，并且是与我在莫斯科的Lua上发表的主题相同的主题，因此，如果您喜欢观看视频，可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里</a>观看。</i> <i><br><br></i>  <i>文章代码是用Lua编写的，但是可以轻松地用其他语言编写（使用协程的方法除外，因为协程不是全部语言）。</i> <i><br></i> <br> 本文介绍了如何创建一种机制，使您可以编写以下形式的过场动画： <br><br><pre><code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cutscene</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(player, npc)</span></span></span></span> player:goTo(npc) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> player:hasCompleted(quest) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> npc:say(<span class="hljs-string"><span class="hljs-string">"You did it!"</span></span>) delay(<span class="hljs-number"><span class="hljs-number">0.5</span></span>) npc:say(<span class="hljs-string"><span class="hljs-string">"Thank you"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> npc:say(<span class="hljs-string"><span class="hljs-string">"Please help me"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><h1> 参赛作品 </h1><br> 动作序列经常在视频游戏中找到。 例如，在过场动画中：角色遇到敌人，对他说些什么，敌人回答等等。 动作顺序可以在游戏中找到。 看一下这个gif： <br><br><img src="https://habrastorage.org/webt/5k/ry/ik/5kryik8wvq-b4ifoa3k3iobvolw.gif"><br><br>  1.门打开 <br>  2.角色进入房屋 <br>  3.门关上 <br>  4.屏幕逐渐变暗 <br>  5.级别变化 <br>  6.屏幕明亮地消失 <br>  7.角色进入咖啡厅 <br><br> 动作序列也可以用于编写NPC的行为脚本或执行首领战斗，其中首领一个接一个地执行某些动作。 <br><a name="habracut"></a><br><h1> 问题 </h1><br> 标准游戏循环的结构使动作序列的实现变得困难。 假设我们有以下游戏循环： <br><br><img src="https://habrastorage.org/webt/uc/xs/an/ucxsanil2ovbawdzqehjmfjpja4.png" width="240"><br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> game:isRunning() <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> processInput() dt = <span class="hljs-built_in"><span class="hljs-built_in">clock</span></span>.delta() update(dt) render() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br> 我们要实现以下场景：玩家接近NPC，NPC说：“您做到了！”，然后稍停片刻后说：“谢谢！”。 在理想的世界中，我们将这样写： <br><br><pre> <code class="lua hljs">player:goTo(npc) npc:say(<span class="hljs-string"><span class="hljs-string">"You did it!"</span></span>) delay(<span class="hljs-number"><span class="hljs-number">0.5</span></span>) npc:say(<span class="hljs-string"><span class="hljs-string">"Thank you"</span></span>)</code> </pre><br> 在这里，我们面临一个问题。 完成这些步骤需要一些时间。 某些动作甚至可能等待播放器的输入（例如，关闭对话框）。 除了<code>delay</code>功能，您不能调用相同的<code>sleep</code> -看起来游戏已冻结。 <br><br> 让我们看一下解决问题的几种方法。 <br><br><h1> 布尔，枚举，状态机 </h1><br> 实施一系列操作的最明显方法是将有关当前状态的信息存储在布尔，行或枚举中。 该代码将如下所示： <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cutsceneState == <span class="hljs-string"><span class="hljs-string">'playerGoingToNpc'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> player:continueGoingTo(npc) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> player:closeTo(npc) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> cutsceneState = <span class="hljs-string"><span class="hljs-string">'npcSayingYouDidIt'</span></span> dialogueWindow:show(<span class="hljs-string"><span class="hljs-string">"You did it!"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> cutsceneState == <span class="hljs-string"><span class="hljs-string">'npcSayingYouDidIt'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> dialogueWindow:wasClosed() <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> cutsceneState = <span class="hljs-string"><span class="hljs-string">'delay'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> ... ... <span class="hljs-comment"><span class="hljs-comment">--   ... end end</span></span></code> </pre><br> 这种方法很容易导致意大利面条式代码和if-else表达式的长链，因此我建议避免使用这种方法来解决问题。 <br><br><h1> 行动清单 </h1><br> 操作列表与状态机非常相似。 动作列表是一个接一个执行的动作的列表。 在游戏循环中，当前动作将调用<code>update</code>函数，即使动作花费很长时间，它也允许我们处理输入并渲染游戏。 操作完成后，我们继续进行下一个操作。 <br><br> 在我们要实现的过场动画中，我们需要执行以下操作：GoToAction，DialogueAction和DelayAction。 <br><br> 对于其他示例，我将在Lua中使用面向OOP的中产类库。 <br><br> 以下是<code>DelayAction</code>实现方式： <br><br><pre> <code class="lua hljs"><span class="hljs-comment"><span class="hljs-comment">--  function DelayAction:initialize(params) self.delay = params.delay self.currentTime = 0 self.isFinished = false end function DelayAction:update(dt) self.currentTime = self.currentTime + dt if self.currentTime &gt; self.delay then self.isFinished = true end end</span></span></code> </pre><br>  <code>ActionList:update</code>函数如下所示： <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ActionList:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self.isFinished <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.currentAction:update(dt) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.currentAction.isFinished <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self:goToNextAction() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self.currentAction <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.isFinished = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br> 最后，过场动画本身的实现： <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> makeCutsceneActionList(player, npc) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ActionList:<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> { GoToAction:<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> { entity = player, target = npc }, SayAction:<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> { entity = npc, <span class="hljs-type"><span class="hljs-type">text</span></span> = "You did it!" }, DelayAction:<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> { delay = <span class="hljs-number"><span class="hljs-number">0.5</span></span> }, SayAction:<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> { entity = npc, <span class="hljs-type"><span class="hljs-type">text</span></span> = "Thank you" } } <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-comment"><span class="hljs-comment">-- ... -    actionList:update(dt)</span></span></code> </pre><br>  <i>注意</i> ：在Lua中，可以这样调用<code>someFunction({ ... })</code> ： <code>someFunction{...}</code> 。 这使您可以编写<code>DelayAction:new{ delay = 0.5 }</code>而不是<code>DelayAction:new({delay = 0.5})</code> 。 <br><br> 看起来好多了。 该代码清楚地显示了操作顺序。 如果我们想添加一个新动作，我们可以轻松地做到这一点。 创建诸如<code>DelayAction</code>类的类非常简单，以使编写过场动画更加方便。 <br><br> 我建议您看一下Sean Middleditch关于动作列表的演示，其中提供了更复杂的示例。 <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/o6CaB-hmqoE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> 操作列表通常非常有用。 我将它们用于我的游戏已经有一段时间了，总体上还是很高兴的。 但是这种方法也有缺点。 假设我们要实现稍微复杂一点的过场动画： <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cutscene</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(player, npc)</span></span></span></span> player:goTo(npc) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> player:hasCompleted(quest) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> npc:say(<span class="hljs-string"><span class="hljs-string">"You did it!"</span></span>) delay(<span class="hljs-number"><span class="hljs-number">0.5</span></span>) npc:say(<span class="hljs-string"><span class="hljs-string">"Thank you"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> npc:say(<span class="hljs-string"><span class="hljs-string">"Please help me"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br> 要进行if / else仿真，您需要实现非线性列表。 这可以使用标签来完成。 可以对某些动作进行标记，然后根据某种条件，而不是转到下一个动作，可以转到具有所需标签的动作。 它可以工作，但是它不像上面的函数那样容易读写。 <br><br>  Lua协程使此代码成为现实。 <br><br><h1> 协程 </h1><br><h2>  Lua的Corua基础知识 </h2><br>  Corutin是一种可以暂停然后再恢复的功能。 协程与主程序在同一线程中执行。 没有为协程创建任何新线程。 <br><br> 要暂停<code>coroutine.yield</code> ，您需要调用<code>coroutine.yield</code>来恢复<code>coroutine.resume</code> 。 一个简单的例子： <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>) coroutine.<span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>() <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"world!"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> c = coroutine.<span class="hljs-built_in"><span class="hljs-built_in">create</span></span>(f) coroutine.<span class="hljs-built_in"><span class="hljs-built_in">resume</span></span>(c) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"uhh..."</span></span>) coroutine.<span class="hljs-built_in"><span class="hljs-built_in">resume</span></span>(c)</code> </pre><br> 程序输出： <br><br><pre>你好
呃...
世界
</pre><br><br> 运作方式如下。 首先，我们使用<code>coroutine.create</code>创建<code>coroutine.create</code> 。 此调用后，corutin无法启动。 为此，我们需要使用<code>coroutine.resume</code>运行它。 然后调用函数<code>f</code> ，该函数将写入“ hello”，并使用<code>coroutine.yield</code>暂停自身。 这类似于<code>return</code> ，但是我们可以使用<code>coroutine.resume</code>恢复<code>f</code> 。 <br><br> 如果在调用<code>coroutine.yield</code>时传递参数，那么它们将成为“主流”中对<code>coroutine.resume</code>的相应调用的返回值。 <br><br> 例如： <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... coroutine.<span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>(<span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-string"><span class="hljs-string">"some text"</span></span>) ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ok, num, text = coroutine.<span class="hljs-built_in"><span class="hljs-built_in">resume</span></span>(c) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(num, text) <span class="hljs-comment"><span class="hljs-comment">-- will print '42 "some text"'</span></span></code> </pre><br>  <code>ok</code>是一个变量，它使我们可以知道协程的状态。 如果<code>ok</code>是<code>true</code> ，那么使用协程，一切都很好，内部没有发生任何错误。 其后的返回值（ <code>num</code> ， <code>text</code> ）与传递给<code>yield</code>参数相同。 <br><br> 如果<code>ok</code>是<code>false</code> ，那么协程会出问题，例如，在其中调用了<code>error</code>函数。 在这种情况下，第二个返回值将是一条错误消息。 协程示例中发生错误： <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span> + notDefined) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> c = coroutine.<span class="hljs-built_in"><span class="hljs-built_in">create</span></span>(f) ok, msg = coroutine.<span class="hljs-built_in"><span class="hljs-built_in">resume</span></span>(c) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> ok <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Coroutine failed!"</span></span>, msg) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br> 结论： <br><br><pre>协程失败了！ 输入：4：尝试对nil值执行算术（全局'notDefined'）
</pre><br><br>  <code>coroutine.status</code>状态可以通过调用<code>coroutine.status</code>获得。  Corutin可能处于以下情况： <br><br><ul><li>  “正在运行”-协程当前正在运行。  <code>coroutine.status</code>是从corutin本身调用的 </li><li>  “已暂停”-Corutin已暂停或从未启动 </li><li>  “正常”-corutin已激活，但未执行。 也就是说，corutin在自身内部发射了另一种corutin </li><li>  “死”-协程已完成执行（即协程中的功能已完成） </li></ul><br> 现在，借助这一知识，我们可以实现基于协同程序的动作序列和过场动画的系统。 <br><br><h2> 使用corutin创建过场动画 </h2><br> 这是基本<code>Action</code>类在新系统上的外观： <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Action:launch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self:init() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self.finished <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> dt = coroutine.<span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>() self:update(dt) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> self:<span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br> 该方法类似于动作列表：在动作完成之前，将调用动作的<code>update</code>功能。 但是这里我们使用协程，并且在游戏循环的每个迭代中都<code>yield</code> （ <code>Action:launch</code>从某个协程调用<code>Action:launch</code> ）。 在游戏循环<code>update</code>某处，我们像这样恢复当前过场动画的执行： <br><br><pre> <code class="lua hljs">coroutine.<span class="hljs-built_in"><span class="hljs-built_in">resume</span></span>(c, dt)</code> </pre><br> 最后，创建一个过场动画： <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cutscene</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(player, npc)</span></span></span></span> player:goTo(npc) npc:say(<span class="hljs-string"><span class="hljs-string">"You did it!"</span></span>) delay(<span class="hljs-number"><span class="hljs-number">0.5</span></span>) npc:say(<span class="hljs-string"><span class="hljs-string">"Thank you"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-comment"><span class="hljs-comment">-- -  ... local c = coroutine.create(cutscene, player, npc) coroutine.resume(c, dt)</span></span></code> </pre><br>  <code>delay</code>功能的实现方法如下： <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delay</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(time)</span></span></span></span> action = DelayAction:new { delay = <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> } action:launch() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br> 创建此类包装程序可大大提高过场代码的可读性。  <code>DelayAction</code>实现如下： <br><br><pre> <code class="lua hljs"><span class="hljs-comment"><span class="hljs-comment">-- Action -   DelayAction local DelayAction = class("DelayAction", Action) function DelayAction:initialize(params) self.delay = params.delay self.currentTime = 0 self.isFinished = false end function DelayAction:update(dt) self.currentTime = self.currentTime + dt if self.currentTime &gt;= self.delayTime then self.finished = true end end</span></span></code> </pre><br> 此实现与我们在操作列表中使用的实现相同！ 让我们再次看一下<code>Action:launch</code>功能： <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Action:launch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self:init() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self.finished <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> dt = coroutine.<span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>() <span class="hljs-comment"><span class="hljs-comment">-- the most important part self:update(dt) end self:exit() end</span></span></code> </pre><br> 这里的主要内容是<code>while</code> ，该循环一直运行到动作完成为止。 看起来像这样： <br><br><img src="https://habrastorage.org/webt/l3/_n/xw/l3_nxwnzshpxqhho12yqyi-y52o.png"><br><br> 现在让我们看一下<code>goTo</code>函数： <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Entity:goTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(target)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> action = GoToAction:new { entity = self, target = target } action:launch() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GoToAction:initialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(params)</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GoToAction:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self.entity:closeTo(self.target) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> ... <span class="hljs-comment"><span class="hljs-comment">--  , AI else self.finished = true end end</span></span></code> </pre><br> 协程很好地处理事件。 实现<code>WaitForEventAction</code>类： <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WaitForEventAction:initialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(params)</span></span></span></span> self.finished = <span class="hljs-literal"><span class="hljs-literal">false</span></span> eventManager:subscribe { listener = self, eventType = params.eventType, callback = WaitForEventAction.onEvent } <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WaitForEventAction:onEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event)</span></span></span></span> self.finished = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br> 此功能不需要<code>update</code>方法。 它将执行（尽管它不会做任何事情……），直到收到具有所需类型的事件为止。 这是此类的实际应用<code>say</code>函数的实现： <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Entity:say</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(text)</span></span></span></span> DialogueWindow:show(text) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> action = WaitForEventAction:new { eventType = <span class="hljs-string"><span class="hljs-string">'DialogueWindowClosed'</span></span> } action:launch() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br> 简单易读。 对话框关闭时，将分派“ DialogueWindowClosed”类型的事件。  say动作结束，下一个动作开始执行。 <br><br> 使用协程，您可以轻松创建非线性过场动画和对话框树： <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> answer = girl:say(<span class="hljs-string"><span class="hljs-string">'do_you_love_lua'</span></span>, { <span class="hljs-string"><span class="hljs-string">'YES'</span></span>, <span class="hljs-string"><span class="hljs-string">'NO'</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> answer == <span class="hljs-string"><span class="hljs-string">'YES'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> girl:setMood(<span class="hljs-string"><span class="hljs-string">'happy'</span></span>) girl:say(<span class="hljs-string"><span class="hljs-string">'happy_response'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> girl:setMood(<span class="hljs-string"><span class="hljs-string">'angry'</span></span>) girl:say(<span class="hljs-string"><span class="hljs-string">'angry_response'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br><img src="https://habrastorage.org/webt/t4/e-/am/t4e-amhtwligikstvqtgi8bpyzu.gif"><br><br> 在此示例中， <code>say</code>函数比我之前显示的函数稍微复杂一些。 它会在对话中返回玩家的选择，但这并不难实现。 例如，可以在<code>WaitForEventAction</code>使用<code>WaitForEventAction</code> ，它将捕获PlayerChoiceEvent事件，然后返回其信息将包含在事件对象中的播放器的选择。 <br><br><h2> 稍微复杂一些的例子 </h2><br> 使用协程，您可以轻松创建教程和小任务。 例如： <br><br><pre> <code class="lua hljs">girl:say(<span class="hljs-string"><span class="hljs-string">"Kill that monster!"</span></span>) waitForEvent(<span class="hljs-string"><span class="hljs-string">'EnemyKilled'</span></span>) girl:setMood(<span class="hljs-string"><span class="hljs-string">'happy'</span></span>) girl:say(<span class="hljs-string"><span class="hljs-string">"You did it! Thank you!"</span></span>)</code> </pre><br><img src="https://habrastorage.org/webt/wx/du/kh/wxdukhci9lald-fph9ypbu5h5fg.gif"><br><br> 协程也可以用于AI。 例如，您可以创建一个函数，怪物可以使用该函数沿某些轨迹移动： <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">followPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(monster, path)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> numberOfPoints = <span class="hljs-built_in"><span class="hljs-built_in">path</span></span>:getNumberOfPoints() <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-comment"><span class="hljs-comment">--      while true do monster:goTo(path:getPoint(i)) if i &lt; numberOfPoints - 1 then i = i + 1 --     else --   i = 0 end end end</span></span></code> </pre><br><img src="https://habrastorage.org/webt/g7/m4/ou/g7m4ouls2l7al6xlovmm-qdbywc.gif"><br><br> 当怪物看到玩家时，我们可以简单地停止执行协程并将其删除。 因此， <code>followPath</code>内部的无限循环（ <code>while true</code> ）并不是真正的无限。 <br><br> 使用corutin，您可以执行“并行”操作。 在两个动作都完成之前，过场动画不会继续进行下一个动作。 例如，我们将制作一个过场动画，女孩和猫以不同的速度跑到朋友的位置。 他们来找她后，猫说“喵”。 <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cutscene</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cat, girl, meetingPoint)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> c1 = coroutine.<span class="hljs-built_in"><span class="hljs-built_in">create</span></span>( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> cat:goTo(meetingPoint) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> c2 = coroutine.<span class="hljs-built_in"><span class="hljs-built_in">create</span></span>( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> girl:goTo(meetingPoint) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) c1.<span class="hljs-built_in"><span class="hljs-built_in">resume</span></span>() c2.<span class="hljs-built_in"><span class="hljs-built_in">resume</span></span>() <span class="hljs-comment"><span class="hljs-comment">--  waitForFinish(c1, c2) --    cat:say("meow") ... end</span></span></code> </pre><br> 这里最重要的部分是<code>waitForFinish</code>函数，它是<code>WaitForFinishAction</code>类的包装，可以按以下方式实现： <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WaitForFinishAction:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> coroutine.<span class="hljs-built_in"><span class="hljs-built_in">status</span></span>(self.c1) == <span class="hljs-string"><span class="hljs-string">'dead'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> coroutine.<span class="hljs-built_in"><span class="hljs-built_in">status</span></span>(self.c2) == <span class="hljs-string"><span class="hljs-string">'dead'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.finished = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> coroutine.<span class="hljs-built_in"><span class="hljs-built_in">status</span></span>(self.c1) ~= <span class="hljs-string"><span class="hljs-string">'dead'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> coroutine.<span class="hljs-built_in"><span class="hljs-built_in">resume</span></span>(self.c1, dt) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> coroutine.<span class="hljs-built_in"><span class="hljs-built_in">status</span></span>(self.c2) ~= <span class="hljs-string"><span class="hljs-string">'dead'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> coroutine.<span class="hljs-built_in"><span class="hljs-built_in">resume</span></span>(self.c2, dt) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br> 如果允许同步第N个动作，则可以使此类更强大。 <br><br> 您还可以创建一个类，等待<i>一个</i>协程完成，而不是等待<i>所有</i>协程完成执行。 例如，它可以用于赛车迷你游戏。 在协程内部，将等待一名骑手到达终点线，然后执行一些动作序列。 <br><br><h2>  Corutin的优缺点 </h2><br> 协程是一个非常有用的机制。 使用它们，您可以编写易于阅读和修改的过场动画和游戏代码。 这类过场动画可以轻松地由修改者或非程序员（例如，游戏或关卡设计师）编写。 <br><br> 而且所有这些都是在一个线程中执行的，因此同步或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">竞态条件</a>没有问题。 <br><br> 该方法具有缺点。 例如，保存可能存在问题。 假设您的游戏中有一个使用协程实现的很长的教程。 在本教程中，播放器将无法保存，因为 为此，您需要保存协程的当前状态（包括协程的整个堆栈以及内部变量的值），以便在从保存中进一步加载时，可以继续本教程。 <br><br>  （ <i>注意</i> ：使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PlutoLibrary</a>库<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">，</a>协程可以序列化，但该库仅适用于Lua 5.1。） <br><br> 过场动画不会发生此问题，因为 通常在游戏中过场动画是不允许的。 <br><br> 如果将它分成小块，则可以解决长篇教程的问题。 假设玩家完成了本教程的第一部分，并且必须进入另一个房间才能继续本教程。 此时，您可以设置检查点或为玩家提供保存的机会。 在保存中，我们将编写类似“玩家完成了教程的第1部分”的内容。 接下来，玩家将学习本教程的第二部分，为此我们将使用另一个协程。 依此类推...在加载时，我们只是开始执行与玩家必须经过的零件相对应的协程。 <br><br><h1> 结论 </h1><br> 如您所见，有几种不同的方法可以实现一系列动作和过场动画。 在我看来，协程方法非常强大，我很高兴与开发人员分享。 我希望这种解决问题的方法可以使您的生活更轻松，并允许您在游戏中制作史诗般的过场动画。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN427135/">https://habr.com/ru/post/zh-CN427135/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN427117/index.html">基于星号的会议室</a></li>
<li><a href="../zh-CN427123/index.html">图灵游戏</a></li>
<li><a href="../zh-CN427129/index.html">威胁情报-信息安全的现代方法</a></li>
<li><a href="../zh-CN427131/index.html">熟悉Audiomania：有关生产，设计，办公室和业务的15种主题材料</a></li>
<li><a href="../zh-CN427133/index.html">分类-经典优化任务</a></li>
<li><a href="../zh-CN427137/index.html">中央银行统计数据：2018年，黑客从金融机构遭受网络攻击的收入下降了近14倍</a></li>
<li><a href="../zh-CN427139/index.html">[选拔]场地的开发，设计和推广：17种有用的材料</a></li>
<li><a href="../zh-CN427141/index.html">爆破手机</a></li>
<li><a href="../zh-CN427143/index.html">Hackaday的第二枚Retrocomputer徽章</a></li>
<li><a href="../zh-CN427145/index.html">学习现代遗传学，分子生物学，基因工程和基因组学的最佳方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>