<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç± üïú üóíÔ∏è As primeiras experi√™ncias usando o protocolo de streaming no exemplo de comunica√ß√£o de CPU e processador no FPGA Redd üì≠ ü§úüèº üßõ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nos artigos anteriores, j√° nos encontramos com o barramento Avalon-MM , onde MM significa Memory Mapped, ou seja, projetado na mem√≥ria. Este pneu √© ba...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>As primeiras experi√™ncias usando o protocolo de streaming no exemplo de comunica√ß√£o de CPU e processador no FPGA Redd</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462253/"><img src="https://habrastorage.org/webt/hx/9r/u0/hx9ru01kpi9-x1z8jztv7uaemjm.jpeg"><br><br>  Nos artigos anteriores, j√° nos encontramos com o barramento <b>Avalon-MM</b> , onde MM significa Memory Mapped, ou seja, projetado na mem√≥ria.  Este pneu √© bastante vers√°til.  V√°rios dispositivos mestre (mestre) e v√°rios dispositivos escravos podem ser conectados a ele.  J√° conectamos dois dispositivos principais ao mesmo tempo (Instruction Master e Data Master), porque o processador NIOS II possui uma arquitetura Harvard, portanto os barramentos de comando e de dados s√£o diferentes, mas muitos autores os conectam ao mesmo dispositivo comum para simplificar o desenvolvimento de software externo. para o √¥nibus. <br><br>  Se um bloco no barramento tiver a funcionalidade de acesso direto √† mem√≥ria (DMA), ele tamb√©m conter√° um mestre para o barramento. <br><br>  Na verdade, a principal inconveni√™ncia deste pneu √© baseada nesse fato (muitos l√≠deres, muitos seguidores).  Quando projetamos nosso escravo, tivemos que decodificar o endere√ßo.  Quando fiz meu l√≠der, houve muito mais barulho na arbitragem.  Mas um fio vermelho em toda a s√©rie de artigos √© a afirma√ß√£o de que o desenvolvimento sob Redd √© uma parte auxiliar do projeto, n√£o deve exigir muito trabalho.  E se pudermos nos libertar da rotina, devemos nos libertar dela. <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/ns/cc/m1/nsccm1g4bldwl-4okgx-puukhyk.png"><br><br>  Todos os artigos do ciclo: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Desenvolvimento do ‚Äúfirmware‚Äù mais simples para FPGAs instalados no Redd e depura√ß√£o usando o teste de mem√≥ria como exemplo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Desenvolvimento do ‚Äúfirmware‚Äù mais simples para FPGAs instalados em Redd.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2. C√≥digo do Programa</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Desenvolvimento de n√∫cleo pr√≥prio para incorpora√ß√£o em um sistema de processador baseado em FPGA</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Desenvolvimento de programas para o processador central Redd no exemplo de acesso ao FPGA</a> </li></ol><br>  O documento <b>Avalon Interface Specifications</b> j√° nos √© conhecido (em geral, eu n√£o dou links diretos, pois eles sempre mudam, para que toda a rede esteja repleta de artigos com links mortos, √© mais f√°cil encontrar a posi√ß√£o atual inserindo o nome no mecanismo de pesquisa) informa que, al√©m do √¥nibus <b>Avalon-MM</b> , tamb√©m h√° um √¥nibus <b>Avalon-ST</b> , onde ST significa Stream, ou seja, streaming.  O fato √© que muitas vezes os dados transmitidos t√™m uma estrutura de fluxo.  Sim, mesmo o setor cl√°ssico do disco r√≠gido.  Tem um tamanho fixo.  Deve ser passado do come√ßo ao fim.  Mesmo se considerarmos na √°rea endere√ß√°vel, os endere√ßos aumentar√£o linearmente.  E se voc√™ usar o bloco FIFO para armazenamento, os endere√ßos dentro dele estar√£o completamente ocultos de n√≥s.  Eles s√£o, mas trabalhar com eles n√£o √© nossa preocupa√ß√£o. <br><br>  O mesmo se aplica a muitos outros dados de streaming: eles sempre v√£o do come√ßo ao fim, sendo colocados em reposit√≥rios sequencialmente.  √â exatamente isso que protocolos de streaming s√£o usados ‚Äã‚Äãpara transferir esses dados.  Al√©m da falta de endere√ßamento expl√≠cito, o barramento <b>Avalon-ST</b> √© interessante, pois sempre conecta dois dispositivos: uma fonte e um receptor.  Sempre existem dois deles.  Um dispositivo √© sempre a fonte, o segundo √© sempre o receptor.  Portanto, problemas com a arbitragem deste barramento n√£o se preocupam.  √â assim que s√£o os pares t√≠picos de dispositivos conectados a esse barramento: <br><br><img src="https://habrastorage.org/webt/z_/ix/tz/z_ixtzpnxmb0fhhyoxgsqnydhvc.png"><br><br>  E aqui est√£o os sinais t√≠picos deste barramento: <br><br><img src="https://habrastorage.org/webt/ua/bh/ku/uabhkulgiofulvfomh0mw-mdz7g.png"><br><br>  Al√©m disso, as linhas de <b>erro</b> s√£o opcionais, elas transmitem c√≥digos de erro bin√°rios atribu√≠dos por n√≥s e podemos dizer que n√£o h√° c√≥digos de erro.  E as linhas num√©ricas do canal, como vimos acima, s√£o necess√°rias apenas se a desmultiplexa√ß√£o for realizada ainda mais.  Caso contr√°rio, o n√∫mero do canal n√£o √© necess√°rio.  Vamos ficar sem ele por enquanto.  Tr√™s linhas permanecem: de fato, dados, um sinal de pronto e um sinal de confirma√ß√£o de dados (strobe).  Bem, outro sinal de rel√≥gio, j√° que o √¥nibus √© s√≠ncrono. <br><br>  Da documenta√ß√£o, tamb√©m se segue que s√£o poss√≠veis mais tr√™s sinais, adicionando ao barramento as propriedades de transmiss√£o de pacotes claramente definidos: <br><br><img src="https://habrastorage.org/webt/ix/wa/rc/ixwarc27-jx3cqndio3gzxaim_g.png"><br><br>  Em geral, o pneu √© muito interessante e hoje come√ßaremos experimentos com ele.  Como j√° sabemos, o FPGA √© conectado ao barramento USB do complexo Redd atrav√©s da ponte <b>FT2232H</b> , operando no modo <b>FT245-SYNC</b> .  A rigor, os dados que passam por essa interface s√£o bastante fluidos.  Hoje vamos aprender como transferir esses dados para o nosso sistema de processador baseado no NIOS II.  √â uma pena que o protocolo <b>FT245-SYNC</b> , embora seja transmitido por streaming, n√£o esteja totalmente em conformidade com o barramento <b>Avalon-ST</b> .  Para salvar as pernas do chip, ele possui um barramento de dados bidirecional e o barramento <b>Avalon-ST</b> √© unidirecional.  Portanto, temos que fazer um bloco que coordene protocolos pr√≥ximos, mas n√£o correspondentes. <br><br>  J√° nos familiarizamos com o protocolo <b>FT245-SYNC</b> em um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dos artigos anteriores</a> .  Deixe-me lembr√°-lo de que sua descri√ß√£o pode ser encontrada no documento <b>AN_130 FT2232H Usado no modo FIFO s√≠ncrono no estilo FT245</b> .  Aqui est√° um diagrama de tempo t√≠pico da transmiss√£o de uma ponte para um FPGA <br><br><img src="https://habrastorage.org/webt/ea/-y/ly/ea-ylyf7hie2zal-gfjzyp_ehwy.png"><br><br>  Em geral, como programador, estou muito interessado no fato de que o pacote transmitido teria claramente marcado in√≠cio e fim.  Bem, para tornar mais l√≥gico na l√≥gica do protocolo UDP, j√° que se a transmiss√£o for no estilo TCP, voc√™ precisar√° adicionar dados de refer√™ncia especiais ao fluxo, que ser√£o gastos na minha programa√ß√£o, esfor√ßos e ciclos de processador ... Parece a linha RXF pode nos ajudar com isso.  Verificamos ... Preenchemos o ‚Äúfirmware‚Äù no FPGA para medir o desempenho, feito no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo anterior</a> , e conectamos a sonda do oscilosc√≥pio √† linha RXF.  Como um programa de teste para o processador central Redd, usamos a base, tamb√©m usada para medir o desempenho. Em vez de enviar grandes quantidades de dados, enviamos um bloco monol√≠tico de 0x400 bytes. <br><br><pre><code class="plaintext hljs">uint8_t temp [maxBlockSize]; memset (temp,0,sizeof (temp)); uint32_t dwWritten; FT_Write(ftHandle0, temp, 0x400, &amp;dwWritten);</code> </pre> <br>  Temos a seguinte imagem na linha RXF: <br><br><img src="https://habrastorage.org/webt/0-/yc/ic/0-ycici6rpo4urdmg8nlvyuem3w.png"><br><br>  √â claro que o microcircuito recebe 0x200 bytes de buffer (ou seja, quanto pode receber em um pacote USB2.0 HS), depois os envia para o canal.  Em geral, isso √© estranho, uma vez que a documenta√ß√£o afirma que dois buffers s√£o usados ‚Äã‚Äãem cada dire√ß√£o.  Durante a transmiss√£o, o segundo buffer deveria ter tido tempo para encher.  Infelizmente.  O final de seu preenchimento est√° claramente atrasado.  Na verdade, isso mostra por que o desempenho n√£o atinge os 52 megabytes te√≥ricos por segundo: uma grande porcentagem do tempo (embora n√£o 50%) simplesmente n√£o √© transmitida. <br><br>  Mas de uma maneira ou de outra, e descobrimos que √© poss√≠vel detectar o in√≠cio de um pacote em uma borda RXF negativa somente se o tamanho do pacote n√£o exceder 0x200 bytes.  Se enviarmos apenas comandos com uma pequena quantidade de dados para o dispositivo, isso √© bastante poss√≠vel.  Mas se enviarmos grandes fluxos de dados, teremos que usar um canal cont√≠nuo, semelhante em sua l√≥gica ao UART (ou, digamos, ao canal TCP), destacando os limites de pacotes de maneira puramente program√°tica. <br><br>  Em geral, para simplificar a apresenta√ß√£o, tomamos a vers√£o de streaming como base.  Hoje n√£o consideraremos pacotes.  Bem, qual vers√£o do √¥nibus <b>Avalon-ST</b> que tomamos como base √© clara.  Come√ßamos a projetar nosso bloco.  Como observado acima, temos que fazer n√£o apenas uma ponte, mas um comutador, porque o barramento <b>FT245FIFO √©</b> bidirecional e o barramento <b>Avalon-ST</b> √© unidirecional.  Ou seja, √© necess√°rio fazer dois barramentos <b>Avalon-ST</b> ao mesmo tempo: sa√≠da e entrada. <br><br><img src="https://habrastorage.org/webt/hr/hl/fm/hrhlfm67sw8-xemukkwo47lg3va.png"><br><br>  Estamos come√ßando a desenvolver lentamente um aut√¥mato que implementar√° a l√≥gica de que precisamos.  Obviamente, no artigo, essa l√≥gica ser√° simplificada ao m√°ximo.  Vamos come√ßar com a transfer√™ncia de dados do FPGA para o PC, pois esse processo √© um pouco mais simples (voc√™ n√£o precisa mudar o estado da linha do OE, sobre o qual falamos no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√∫ltimo artigo</a> ).  Ou seja, estamos implementando a porta Sink. <br><br>  Do lado do barramento <b>Avalon-ST</b> , escolhi o seguinte modo de opera√ß√£o (existem muitos no documento, mas para a interface com o <b>FT245-SYNC, este √© o</b> mais pr√≥ximo): <br><br><img src="https://habrastorage.org/webt/f_/rh/nm/f_rhnmctxwtl01xdlaiioun81jk.png"><br><br>  Deixe-me lembr√°-lo da dire√ß√£o dos sinais: <br><br><img src="https://habrastorage.org/webt/sd/cc/r-/sdccr--rw2vsk1xitskseckafiq.png"><br><br>  Ou seja, basta aguardar a confirma√ß√£o no √¥nibus ( <b>v√°lido</b> ), clicar nos dados e fechar esse fato com a linha <b>pronta</b> . <br><br>  Do lado do <b>FT245_FIFO, o</b> protocolo fica assim: <br><br><img src="https://habrastorage.org/webt/d-/nf/ki/d-nfkirvzei94d3kvkhntyea7pi.png"><br><br>  Acontece que devemos aguardar o sinal TXE e bloquear os dados com o sinal WR # (a polaridade √© inversa para ambos os sinais). <br><br>  TXE # √© muito semelhante em funcionalidade a <b>pronto</b> , e WR # √© <b>v√°lido</b> .  Os detalhes s√£o um pouco diferentes, mas a l√≥gica √© semelhante. <br><br>  Acontece que podemos destacar um √∫nico estado para PC, no qual as comuta√ß√µes mais simples de algumas linhas ser√£o executadas.  A condi√ß√£o para entrar nesse estado ser√° a disponibilidade de ambas as partes para a transmiss√£o, ou seja (TXE # == 0) AND (v√°lido == 1).  Assim que um pouco da prontid√£o acabar, voltamos ao modo inativo. <br><br>  O gr√°fico de transi√ß√£o do aut√¥mato ainda √© simples: <br><br><img src="https://habrastorage.org/webt/ci/gb/j9/cigbj9hrioumzbnck6pyeevv1ia.png"><br><br>  E a tabela de comuta√ß√£o √© assim (onde os nomes dos sinais s√£o amb√≠guos, os √≠ndices s√£o adicionados a eles, onde os nomes s√£o √∫nicos - n√£o h√° √≠ndices): <br><br><div class="scrollable-table"><table><tbody><tr><th>  Signal </th><th>  Status do ToPC </th><th>  Outras condi√ß√µes </th></tr><tr><td>  WR # </td><td>  N√ÉO (validSink) </td><td>  1 </td></tr><tr><td>  readySink </td><td>  N√ÉO (n¬∫ TXE) </td><td>  0 0 </td></tr><tr><td>  DATAFT245_FIFO </td><td>  DataSink </td><td>  Z </td></tr></tbody></table></div><br><br>  Passando para uma transfer√™ncia um pouco mais complexa da Origem para a FT245_FIFO.  Como vimos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no artigo anterior</a> , a complica√ß√£o √© mudar de dire√ß√£o com o sinal OE #: <br><br><img src="https://habrastorage.org/webt/al/xu/1-/alxu1-uqzen0dpj4n8bbgcruyck.png"><br><br>  Para o barramento <b>Avalon_ST,</b> tudo √© o mesmo de antes, portanto as imagens n√£o s√£o mostradas uma segunda vez, mas agora estamos na posi√ß√£o Fonte. <br><br>  Aqui, a linha RXF # corresponde √† linha <b>v√°lida</b> e a linha RD # corresponde √† linha <b>pronta</b> .  Bem, adicione alguns estados √† m√°quina: <br><br><img src="https://habrastorage.org/webt/pu/gs/fm/pugsfmp11c6b79fi8cwfud-wm-q.png"><br><br>  e a seguinte l√≥gica para sinais ativos neste estado: <br><br><div class="scrollable-table"><table><tbody><tr><th>  Signal </th><th>  dropOE </th><th>  fromPC </th><th>  Outras condi√ß√µes </th></tr><tr><td>  OE # </td><td>  0 0 </td><td>  0 0 </td><td>  1 </td></tr><tr><td>  RD # </td><td>  1 </td><td>  N√ÉO (readySource) </td><td>  1 </td></tr><tr><td>  dataSource </td><td>  Qualquer valor </td><td>  DATAFT245_FIFO </td><td>  Qualquer valor </td></tr><tr><td>  fonte v√°lida </td><td>  0 0 </td><td>  N√ÉO (RXF #) </td><td>  0 0 </td></tr></tbody></table></div><br>  √â claro que o esquema n√£o era o mais ideal.  Existem v√°rias nuances associadas a transbordamentos ou desobstru√ß√µes de buffer.  Mas n√£o deve haver nenhum tipo de perda de dados, mas quanto √† otimiza√ß√£o, voc√™ precisa come√ßar de algum lugar! <br><br>  Come√ßamos a transferir a teoria desenvolvida para o c√≥digo SystemVerilog.  √â verdade que n√£o podemos usar todos os recursos do SystemVerilog.  Foi o caso, escrevi um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">grande artigo</a> em que testei a capacidade de sintetiza√ß√£o pr√°tica dos belos recursos dessa linguagem com um ambiente de desenvolvimento real.  Aqui apenas pedimos o uso de interfaces, porque o sistema ter√° duas inst√¢ncias do <b>tipo Avalon-ST</b> .  Ai e ah.  Aqui est√° o c√≥digo do teste: <br><pre> <code class="plaintext hljs">interface AvalonST #(parameter width=8)(input clk); logic [width-1:0] data; logic ready; logic valid; modport source (input clk, ready, output data,valid); modport sink (input clk, data, valid, output ready); endinterface module FT245toAvalonST ( AvalonST.source source, AvalonST.sink sink ); //assign source.ready = sink.valid; assign sink.ready = source.valid; endmodule</code> </pre><br>  √â perfeitamente sintetizado no compilador principal (uma linha comentada ao excluir um coment√°rio provoca um erro para garantir que o sintetizador interpreta tudo corretamente), mas ao verificar o bot√£o <b>Analyze Synthesis Files</b> para um componente desse c√≥digo, √© <b>gerado</b> um erro que o tipo <b>AvalonST √©</b> desconhecido.  Ou seja, a an√°lise n√£o existe no SystemVerilog, mas no Verilog puro.  Que pena. <br><br><img src="https://habrastorage.org/webt/4x/ju/ma/4xjumaitxzkw5tig_pdponziq38.png"><br><br>  Al√©m disso, a linguagem √© determinada corretamente, apenas o analisador n√£o entende as interfaces entre as portas. <br><br><img src="https://habrastorage.org/webt/tp/vm/gn/tpvmgnmidvtcb1e5ngfteokprpi.png"><br><br>  Em geral, voc√™ precisa usar a sintaxe antiga e feia. <br><br><div class="spoiler">  <b class="spoiler_title">Com esta sintaxe, obtemos a seguinte interface de m√≥dulo:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">module FT245toAvalonST ( input clk, input reset, inout [7:0] ft245_data, input logic ft245_rxf, input logic ft245_txe, output logic ft245_rd, output logic ft245_wr, output logic ft245_oe, output logic ft245_siwu, input logic source_ready, output logic source_valid, output logic[7:0] source_data, output logic sink_ready, input logic sink_valid, input logic[7:0] sink_data );</code> </pre><br></div></div><br>  Rude, vintage, mas o que voc√™ pode fazer. <br><br><div class="spoiler">  <b class="spoiler_title">Percebemos o gr√°fico de transi√ß√£o do aut√¥mato sem frescuras:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">//    enum {idle, toPC, dropOE, fromPC} state = idle; //     always_ff @(posedge clk,posedge reset) begin if (reset == 1) begin state &lt;= idle; end else begin case (state) idle: begin if ((ft245_txe == 0) &amp;&amp; (sink_valid == 1)) state &lt;= toPC; else if ((ft245_rxf == 0)&amp;&amp;(source_ready == 1)) state &lt;= dropOE; end toPC: begin if (!((ft245_txe == 0) &amp;&amp; (sink_valid == 1))) state &lt;= idle; end dropOE: begin state &lt;= fromPC; end fromPC: begin if (!((ft245_rxf == 0)&amp;&amp;(source_ready == 1))) state &lt;= idle; end endcase end end</code> </pre><br></div></div><br>  O controle das sa√≠das, no entanto, requer alguma explica√ß√£o. <br><br><div class="spoiler">  <b class="spoiler_title">Parte das instala√ß√µes √© feita ‚Äúna testa‚Äù:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">//    //   ,        , //  -    . always_comb begin ft245_oe &lt;= 1; ft245_rd &lt;= 1; ft245_wr &lt;= 1; source_valid &lt;= 0; sink_ready &lt;= 0; //     , //     assign- case (state) idle: begin end toPC: begin ft245_wr &lt;= !(sink_valid); sink_ready &lt;= !(ft245_txe); end dropOE: begin ft245_oe &lt;= 0; end fromPC: begin ft245_oe &lt;= 0; ft245_rd &lt;= !(source_ready); source_valid &lt;= !(ft245_rxf); end endcase end</code> </pre><br></div></div><br>  Mas, digamos, para um barramento de dados bidirecional, uma solu√ß√£o t√≠pica deve ser aplicada.  Como lembramos, √© declarado na parte da interface da seguinte maneira: <br><br><pre> <code class="plaintext hljs"> inout [7:0] ft245_data,</code> </pre><br>  e a leitura pode ser feita da maneira usual.  No nosso caso, simplesmente agrupamos todos os dados nos dados do barramento <b>Avalon-ST de</b> sa√≠da: <br><br><pre> <code class="plaintext hljs">//          assign source_data = ft245_data;</code> </pre><br>  Mas, em geral, voc√™ sempre pode ler do √¥nibus e da maneira que quiser.  Mas voc√™ deve escrever usando o multiplexador.  Quando gravamos dados no barramento, esses dados devem vir de qualquer outro barramento pr√©-preparado.  Normalmente, uma vari√°vel do tipo <b>reg</b> (ou <b>l√≥gica</b> newfangled) √© <b>encerrada</b> em um m√≥dulo.  No nosso caso, esse √¥nibus j√° existe.  Este √© o barramento <b>sink_data</b> .  Em outros casos, o estado Z √© emitido. Se voc√™ estiver familiarizado com os circuitos, estar√° ciente de um buffer de sa√≠da t√≠pico.  Ele pula qualquer dado de entrada ou entra no estado Z.  Em nosso c√≥digo, esse multiplexador √© assim: <br><br><pre> <code class="plaintext hljs">//      inout- assign ft245_data = (state == toPC) ? sink_data : 8'hzz;</code> </pre><br>  E outro sinal ft245_siwu.  N√≥s nunca o usamos, portanto, de acordo com a documenta√ß√£o do FT2232H, puxe-o para a unidade: <br><br><pre> <code class="plaintext hljs">//   FTDI : // Tie this pin to VCCIO if not used. assign ft245_siwu = 1;</code> </pre><br>  Na verdade, √© tudo. <br><br><div class="spoiler">  <b class="spoiler_title">O m√≥dulo inteiro fica assim:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">module FT245toAvalonST ( input clk, input reset, inout [7:0] ft245_data, input logic ft245_rxf, input logic ft245_txe, output logic ft245_rd, output logic ft245_wr, output logic ft245_oe, output logic ft245_siwu, input logic source_ready, output logic source_valid, output logic[7:0] source_data, output logic sink_ready, input logic sink_valid, input logic[7:0] sink_data ); //    enum {idle, toPC, dropOE, fromPC} state = idle; //     always_ff @(posedge clk,posedge reset) begin if (reset == 1) begin state &lt;= idle; end else begin case (state) idle: begin if ((ft245_txe == 0) &amp;&amp; (sink_valid == 1)) state &lt;= toPC; else if ((ft245_rxf == 0)&amp;&amp;(source_ready == 1)) state &lt;= dropOE; end toPC: begin if (!((ft245_txe == 0) &amp;&amp; (sink_valid == 1))) state &lt;= idle; end dropOE: begin state &lt;= fromPC; end fromPC: begin if (!((ft245_rxf == 0)&amp;&amp;(source_ready == 1))) state &lt;= idle; end endcase end end //    //   ,        , //  -    . always_comb begin ft245_oe &lt;= 1; ft245_rd &lt;= 1; ft245_wr &lt;= 1; source_valid &lt;= 0; sink_ready &lt;= 0; //     , //     assign- case (state) idle: begin end toPC: begin ft245_wr &lt;= !(sink_valid); sink_ready &lt;= !(ft245_txe); end dropOE: begin ft245_oe &lt;= 0; end fromPC: begin ft245_oe &lt;= 0; ft245_rd &lt;= !(source_ready); source_valid &lt;= !(ft245_rxf); end endcase end // -  c  ,   ... //   FTDI : // Tie this pin to VCCIO if not used. assign ft245_siwu = 1; //      inout- assign ft245_data = (state == toPC) ? sink_data : 8'hzz; //          assign source_data = ft245_data; endmodule</code> </pre><br></div></div><br>  Como incluir o m√≥dulo na lista de dispon√≠veis para uso no sistema do processador, examinamos em detalhes em um dos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigos anteriores</a> , ent√£o apenas mostro o resultado na figura.  Lembro-me de que, para alcan√ß√°-lo, tive que adicionar dois barramentos <b>AVALON-ST</b> , um de <b>Conduit</b> , puxar sinais de um barramento <b>AVALON-MM</b> definido erroneamente e, quando n√£o houver um √∫nico sinal naquele barramento, basta exclu√≠-lo.  Ao longo do caminho, a figura mostra as configura√ß√µes que selecionei para os barramentos <b>AVALON-ST</b> (8 bits por s√≠mbolo, sem erros, o canal m√°ximo √© zero, a lat√™ncia √© zero). <br><br><img src="https://habrastorage.org/webt/-v/9t/ml/-v9tmldj2eyv4rsv8lb3reokzoa.png"><br><br>  Com o desenvolvimento de um m√≥dulo para encaixar pneus - √© isso.  Mas infelizmente, ah.  Desenvolver √© apenas o come√ßo do trabalho.  Implementar √© muito mais dif√≠cil.  Como pode ser visto a partir da posi√ß√£o do rolo na tela, o final do artigo ainda est√° longe.  Ent√£o, estamos come√ßando a criar um projeto simples que usa a <b>jun√ß√£o de</b> barramento <b>FT245-SYNC</b> com os barramentos <b>AVALON-ST</b> .  √â o mais simples.  Um projeto s√©rio n√£o se enquadra na estrutura de um √∫nico artigo de tamanho razo√°vel.  Agora simplificarei ap√≥s simplifica√ß√£o, simplesmente para que a aten√ß√£o dos leitores seja suficiente para o restante do texto, para que eles n√£o parem de ler em uma palavra.  A primeira simplifica√ß√£o √© que os <b>rel√≥gios de</b> 60 MHz para o <b>FT245_SYNC s√£o</b> gerados pelo <b>pr√≥prio</b> chip <b>FT2232H</b> .  Eu poderia adicionar duas linhas de rel√≥gio ao sistema, mas assim que todos virem, teremos tantas teias de aranha que minha m√£e n√£o sofrer√°.  Se eu ainda prestar aten√ß√£o √†s diferentes linhas do rel√≥gio, todos ficaremos confusos.  Portanto, eu simplesmente anuncio que hoje nosso sistema de processador funcionar√° com clock do chip <b>FT2232H</b> , e n√£o de um gerador comum. <br><br>  Por que voc√™ n√£o pode sempre fazer isso?  Muito simples: enquanto o <b>FT2232H</b> n√£o <b>estiver</b> no modo 245_SYNC, ele n√£o ter√° esses pulsos na sa√≠da.  Ou seja, voc√™ deve primeiro executar o programa para o processador central e s√≥ depois carregar tudo no FPGA.  Se criarmos um sistema para um cliente externo, essa solu√ß√£o criaria muitos problemas.  Sei por experi√™ncia pr√≥pria que eles ligavam para n√≥s regularmente e diziam que nada funciona, lembr√°vamos de bares, mas isso ajudaria por um tempo.  Mas estamos fazendo uma coisa interna e a usaremos apenas em condi√ß√µes de laborat√≥rio.  Ou seja, dentro da estrutura desta tarefa, isso √© permitido. <br><br>  Mas isso traz novos desafios.  Temos uma frequ√™ncia de 60 MHz e o bloco de rel√≥gio SDRAM que estamos usando atualmente est√° intimamente ligado a uma frequ√™ncia de 50 MHz.  Sim, verifiquei, 60 podem ser enviadas, mas vamos fingir que tentamos n√£o ir al√©m dos modos permitidos.  Nos artigos subseq√ºentes, tentarei mostrar como substituir esse bloco r√≠gido, mas hoje dizemos que, como nossa unidade de rel√≥gio da SDRAM n√£o pode trabalhar com a frequ√™ncia usada, a exclu√≠mos do sistema do processador SDRAM.  O programa e seus dados estar√£o totalmente localizados na mem√≥ria interna do FPGA.  Foi experimentalmente constatado que, na configura√ß√£o atual, os FPGAs podem ocupar no m√°ximo 28 kilobytes de RAM para esse neg√≥cio.  Acontece que voc√™ pode pegar volumes e n√£o v√°rios poderes de dois ... <br><br>  Al√©m disso, usaremos o rel√≥gio padr√£o e a unidade de redefini√ß√£o.  √â redefinido um pouco diferente do que usamos para SDRAM.  Para n√£o complicar o artigo, aproveitarei o fato de que o sistema em desenvolvimento sempre funcionar√° sob o controle de um depurador, portanto, iniciarei uma redefini√ß√£o no subsistema JTAG para depura√ß√£o. <br><br>  No total, temos um esbo√ßo do sistema do processador b√°sico (a linha de redefini√ß√£o mais dif√≠cil est√° destacada no momento, o marcador azul est√° na fonte de sinal): <br><br><img src="https://habrastorage.org/webt/zx/ug/nk/zxugnk3v9rhownqtdorprzuvqc8.png"><br><br>  onde a frequ√™ncia foi ajustada para o rel√≥gio e o bloco de redefini√ß√£o: <br><br><img src="https://habrastorage.org/webt/dj/hq/ap/djhqapk0jpgumyp0qrp34ucszhw.png"><br><br>  e para RAM - o volume: <br><br><img src="https://habrastorage.org/webt/pm/k2/vn/pmk2vngq6jhbl3yhydiarxcsm2i.png"><br><br>  Hoje, precisamos exibir o texto no terminal.  Portanto, adicionaremos um bloco t√£o interessante ao sistema: <br><br><img src="https://habrastorage.org/webt/9q/nx/r-/9qnxr-5owicrjxhlqmkeckfxxn8.png"><br><br>  Com este bloco, poderemos chamar fun√ß√µes semelhantes ao printf.  Al√©m do barramento AVALON_MM, ele tamb√©m deve conectar a sa√≠da de solicita√ß√£o de interrup√ß√£o. <br><br><img src="https://habrastorage.org/webt/gp/h6/rg/gph6rg59lvarzmtdeaq9wvsiohu.png"><br><br>  √â isso a√≠, a compra do sistema do processador est√° conclu√≠da.  √â hora de incorporar nossa unidade.  Para onde ele enviar√° os dados?  Entre os blocos dispon√≠veis, h√° uma mem√≥ria FIFO de duas portas muito interessante.  Seu charme reside no fato de que uma porta pode ser configurada no modo <b>AVALON-ST</b> e conect√°-la √† nossa unidade, e a segunda no modo <b>AVALON_MM</b> e trabalhar com ela usando o processador NIOS II.  Este maravilhoso bloco est√° localizado aqui: <br><br><img src="https://habrastorage.org/webt/fe/9o/ur/fe9ourutodpbj31wm9av_-pkfc4.png"><br><br>  Como temos dois <b>√¥nibus Avalon-ST</b> (um para leitura e outro para escrita), tamb√©m precisamos de dois blocos FIFO.  Agora, examinarei detalhadamente um deles, percorremos alguns quil√¥metros da Web (e v√°rias telas de texto com imagens) e, no segundo, dizemos que "isso pode ser feito por analogia", indicando apenas diferen√ßas.  Portanto, por enquanto, adicionamos apenas um bloco ao sistema e examinamos suas configura√ß√µes.  Existem muitas configura√ß√µes.  Pode-se simplesmente indicar os valores necess√°rios para que todos se refiram ao artigo como refer√™ncia, mas de repente algu√©m entra em uma situa√ß√£o que precisa ser configurada, mas n√£o h√° acesso √† rede (e, portanto, ao artigo).  Portanto, adicionarei configura√ß√µes iterativamente.  Primeiro √≥bvio, ent√£o - como o sistema exige, execute o di√°logo repetidamente.  Ent√£o todos sentir√£o o processo e poder√£o repeti-lo a qualquer momento.  Ent√£o  Por padr√£o, recebemos as seguintes configura√ß√µes: <br><br><img src="https://habrastorage.org/webt/yl/bt/14/ylbt14u32cw8xeqherwazdx8nx4.png"><br><br>  Agora vou fazer o FIFO, que coleta dados do <b>Avalon-ST</b> e os envia para o <b>Avalon-MM</b> .  Acontece que a primeira edi√ß√£o ser√° assim: <br><br><img src="https://habrastorage.org/webt/1w/m0/xx/1wm0xx_bdp9gjk9nqmb6sooxop0.png"><br><br>  Eu recebi este aviso interessante: <br><br><img src="https://habrastorage.org/webt/1u/a8/qs/1ua8qsawychkqv0nxjg_l5u3f4q.png"><br><br>  Acontece que quando pelo menos uma das portas √© projetada na mem√≥ria, a largura do barramento <b>Avalon-ST</b> deve ser estritamente de 32 bits.  E n√≥s temos um √¥nibus de 8 bits.  Como concordar com a profundidade dos bits, vou lhe dizer um pouco mais baixo, mas por enquanto estamos fazendo um barramento de 32 bits com um caractere de oito bits aqui.  Bem, desative o modo em lote, como foi decidido na parte te√≥rica. <br><br><img src="https://habrastorage.org/webt/oi/jh/k0/oijhk02tjofxdavtznc1m1es8w4.png"><br><br>  Em seguida √© a capacidade.  Suponha que eu coloque na fila 256 palavras (ou seja, 1024 bytes): <br><br><img src="https://habrastorage.org/webt/s4/ca/vl/s4cavlmtxomzl0gsc2dfwn2ovmg.png"><br><br>  Agora o status.  No come√ßo, eu n√£o atribui nenhuma import√¢ncia a isso e o programa congela firmemente.  Ent√£o agora eu sei que o status √© necess√°rio.  Como trabalharemos com a porta de sa√≠da programaticamente, adicionamos o status a ela. <br><br><img src="https://habrastorage.org/webt/0_/hc/hp/0_hchpmkhfrlg8pg3tjaqg3vpsi.png"><br><br>  e pegue o erro: <br><br><img src="https://habrastorage.org/webt/xk/e7/lg/xke7lgan6dpoohxssnvglenuhog.png"><br><br>  Bem ent√£o.  Adicione rel√≥gio duplo.  Basta conectar as duas entradas √† mesma linha do rel√≥gio, pois temos uma. <br>  Uhhhh  Total que temos: <br><br><img src="https://habrastorage.org/webt/iv/nv/pv/ivnvpvdfov3zeo6owfevsdhrq6k.png"><br><br>  Mas √© muito cedo para conectar esta empresa ao sistema comum.  Como descobrimos, o barramento <b>Avalon-ST de</b> 8 bits deixa o bloco que desenvolvemos e deve incluir o de 32 bits.  Como estamos?  Remodelar seu bloco?  N√£o!  Tudo foi feito diante de n√≥s.  Aqui est√° o que nos ajudar√°: <br><br><img src="https://habrastorage.org/webt/3g/2j/q7/3g2jq74qwjbcgmnvhdchryqi9xm.png"><br><br>  Adicione-o ao sistema.  Al√©m disso, como se trata de uma camada puramente de beleza, a colocamos entre o nosso bloco e o FIFO, usando a seta correspondente: <br><br><img src="https://habrastorage.org/webt/lt/pd/9q/ltpd9qytvl60ez2znbxu1qsudyq.png"><br><br>  Fazemos as seguintes configura√ß√µes: na entrada, temos um barramento de 8 bits, na sa√≠da de 32 bits.  Sinais de pacotes n√£o s√£o usados, sinais <b>prontos</b> e <b>v√°lidos</b> s√£o usados. <br><br><img src="https://habrastorage.org/webt/bo/-e/h1/bo-eh154mbqqyr0owj9vn96his8.png"><br><br>  √â hora de tecer uma web.  Primeiro, colocarei as linhas de streaming (na figura elas est√£o destacadas, os marcadores est√£o nos receptores de dados): <br><br><img src="https://habrastorage.org/webt/br/xu/uj/brxuujnbnsiazm3pxfnnr3tb-cc.png"><br><br>  Ou seja, o sinal da fonte do nosso bloco vai para a entrada do adaptador.  E da sa√≠da do adaptador para a entrada FIFO.  Como eu disse, todas as conex√µes no protocolo de streaming s√£o feitas ponto a ponto. <br>  Bem, agora suspendemos as linhas de redefini√ß√£o, as linhas do rel√≥gio e tamb√©m conectamos tudo ao barramento do sistema e √†s interrup√ß√µes ... <br><br><img src="https://habrastorage.org/webt/dc/tj/1g/dctj1gqgwbbs7-pcdf4urfbhvsy.png"><br><br>  Bem ... E agora, pelo mesmo princ√≠pio, adicionamos FIFO para emitir dados para o <b>FT245SYNC</b> .  Somente l√°, os dados entram no FIFO do <b>Avalon-MM</b> na forma de 32 bits.  Eles passam por um adaptador 32-em-8 e, em seguida, chegam √† entrada SINK do nosso bloco, que n√£o est√° conectado no circuito atual ... Temos o seguinte fragmento do circuito final (a mem√≥ria acabou com um √∫nico rel√≥gio): <br><br><img src="https://habrastorage.org/webt/eg/e5/kc/ege5kckjc4x5vwtsfaxmlp32rqo.png"><br><br>  Outras formalidades que j√° elaboramos bem nos experimentos descritos em artigos anteriores ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">na maioria dos casos - neste</a> ).  Atribu√≠mos vetores ao processador.  Para o sistema, chamamos a atribui√ß√£o autom√°tica de n√∫meros e endere√ßos de interrup√ß√£o.  N√≥s salvamos o sistema ... Todos lembram que o nome do sistema salvo deve corresponder ao nome do projeto para que o sistema esteja no n√≠vel superior da hierarquia?  Adicione o sistema ao projeto, fa√ßa um rascunho do projeto, atribua pernas.  Pessoalmente, eu trapacei: copiei as atribui√ß√µes do arquivo * .qsf do projeto de rascunho para o atual final (e voc√™ pode pegar meu projeto e copiar as linhas * .qsf correspondentes √†s suas, mas voc√™ pode simplesmente atribuir todas as pernas por meio da GUI).  Presto especial aten√ß√£o ao fato de que o sinal clk est√° conectado √† perna 23, e n√£o 25, como nos projetos anteriores.  Lembro que aqui estamos marcando a sa√≠da do FT2232. <br><br><img src="https://habrastorage.org/webt/9z/bx/sb/9zbxsbgsn4m_9wewmjestkse0fi.png"><br><br>  √ìtimo!  O hardware est√° pronto.  Passamos para o software.  Por onde come√ßamos?  Hoje esta quest√£o n√£o vale a pena.  Se come√ßarmos com um programa que roda no processador NIOS II, nada funcionar√° para n√≥s.  Primeiro, devemos colocar o FT2232 no modo 245-SYNC; somente ent√£o nosso sistema de processador receber√° pulsos de clock.  Portanto, come√ßamos com o c√≥digo do processador central. <br><br><div class="spoiler">  <b class="spoiler_title">Temos algo parecido com isto:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;cstdio&gt; #include &lt;sys/time.h&gt; #include &lt;unistd.h&gt; #include "ftd2xx.h" FT_HANDLE OpenFT2232H() { FT_HANDLE ftHandle0; static FT_DEVICE ftDevice; //      int nDevice = 0; while (true) { //     if (FT_Open(nDevice, &amp;ftHandle0) != FT_OK) { printf("No FT2232 found\n"); //  ,      return 0; } //     ? if (FT_GetDeviceInfo(ftHandle0, &amp;ftDevice, NULL, NULL, NULL, NULL) == FT_OK) { // ,    if (ftDevice == FT_DEVICE_2232H) { // ,     AN130 FT_SetBitMode(ftHandle0, 0xff, 0x00); usleep(1000000); //Sync FIFO mode FT_SetBitMode(ftHandle0, 0xff, 0x40); FT_SetLatencyTimer(ftHandle0, 2); FT_SetUSBParameters(ftHandle0, 0x10000, 0x10000); return ftHandle0; } } //    FT_Close(ftHandle0); //    nDevice += 1; } printf("No FT2232 found\n"); } int main() { FT_HANDLE ftHandle0 = OpenFT2232H(); if (ftHandle0 == 0) { printf("Cannot open device\n"); return -1; } int item; bool bWork = true; while (bWork) { printf("1 - Send 16 bytes\n"); printf("2 - Send 256 bytes\n"); printf("3 - Receive loop\n"); printf("0 - Exit\n"); scanf("%d", &amp;item); switch (item) { case 0: bWork = false; break; case 1: { static const unsigned char data[0x10] = { 0x00,0x01,0x02,0x03, 0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f }; DWORD dwWritten; FT_Write(ftHandle0, (void*)data, sizeof(data), &amp;dwWritten); } break; case 2: { unsigned char data[0x100]; for (size_t i = 0; i &lt; sizeof(data); i++) { data[i] = (unsigned char)i; } DWORD dwWritten; FT_Write(ftHandle0, (void*)data, sizeof(data), &amp;dwWritten); } break; case 3: { DWORD dwRxBytes; DWORD dwRead; DWORD buf[0x100]; while (true) { FT_GetQueueStatus(ftHandle0, &amp;dwRxBytes); if (dwRxBytes != 0) { printf("Received %d bytes (%d DWORDs)\n", dwRxBytes, dwRxBytes / sizeof(buf[0])); if (dwRxBytes &gt; sizeof(buf)) { dwRxBytes = sizeof(buf); } FT_Read(ftHandle0, buf, dwRxBytes, &amp;dwRead); for (DWORD i = 0; i &lt; dwRxBytes / sizeof(buf[0]);i++) { printf("0x%X, ",buf[i]); } printf("\n"); } } } break; } } // ,    FT_Close(ftHandle0); return 0; }</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A fun√ß√£o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenFT2232H () nos √©</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> familiar desde o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√∫ltimo artigo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . √â ela quem abre o dispositivo FT2232 e o coloca no modo que precisamos. Imediatamente ap√≥s o lan√ßamento bem-sucedido do programa, obtemos pulsos de clock e, com eles, a capacidade de depurar o programa para o NIOS II. Bem, a funcionalidade da fun√ß√£o principal √© t√£o simples quanto um banquinho. Envie alguns dados (1), envie muitos dados (2), receba dados (3). Observe que todos os dados s√£o enviados em blocos com m√∫ltiplos de quatro bytes. Isso √© tudo porque temos um adaptador 8 em 32. Na sa√≠da, os dados devem ir em duas palavras. Caso contr√°rio, tudo √© √≥bvio.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao desenvolver um programa para o NIOS II, voc√™ deve primeiro configurar o BSP. Lembro que eu criei o pr√≥prio programa de acordo com o modelo Hello World Small. Os campos alterados no BSP est√£o marcados em vermelho na figura abaixo (como o programa √© criado a partir do modelo e como o BSP √© corrigido foi discutido em detalhes em um dos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artigos anteriores</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Deixe-me lembr√°-lo de que seleciono a raiz da √°rvore, ou seja, o elemento Configura√ß√µes, para que todas as configura√ß√µes fiquem imediatamente vis√≠veis √† direita. </font></font><br><br><img src="https://habrastorage.org/webt/lc/mg/jh/lcmgjhu3udg8njitretcj5wp4vm.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em seguida, gere BSP e, em virtude do meu h√°bito, altero o nome do arquivo </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hello_world_small.c</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hello_world_small.cpp</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ap√≥s o qual limpo o projeto para que n√£o haja erros induzidos nessa renomea√ß√£o.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Realizo uma verifica√ß√£o do trabalho de maneira bastante superficial (um testador real certamente testaria minuciosamente a transfer√™ncia de grandes quantidades de dados que excedem o tamanho do FIFO, mas o objetivo do artigo √© mostrar os princ√≠pios b√°sicos e n√£o garantir que ele seja descartado devido ao seu tamanho insano). </font><font style="vertical-align: inherit;">E mostrarei os princ√≠pios b√°sicos em duas etapas. </font><font style="vertical-align: inherit;">O primeiro passo √© verificar a transfer√™ncia de dados do processador central para o NIOS II. </font><font style="vertical-align: inherit;">Para isso, desenvolvi o seguinte c√≥digo:</font></font><br><br><pre> <code class="plaintext hljs">extern "C" { #include "sys/alt_stdio.h" #include &lt;system.h&gt; #include &lt;altera_avalon_fifo_util.h&gt; } #include &lt;stdint.h&gt; int main() { while (1) { int level = IORD_ALTERA_AVALON_FIFO_LEVEL(FIFO_0_OUT_CSR_BASE); if (level != 0) { alt_printf("0x%x words received:\n",level); for (int i=0;i&lt;level;i++) { alt_printf("0x%x,",IORD_ALTERA_AVALON_FIFO_DATA (FIFO_0_OUT_BASE)); } alt_printf("\n"); } } /* Event loop never exits. */ while (1); return 0; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este programa est√° aguardando a exibi√ß√£o dos dados no FIFO. </font><font style="vertical-align: inherit;">Se eles aparecerem l√°, os exibe. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chegando ao teste. </font><font style="vertical-align: inherit;">Primeiro, vou fingir que esqueci de come√ßar o tempo. </font><font style="vertical-align: inherit;">Portanto, depois de ativar o Redd, carrego o ‚Äúfirmware‚Äù do FPGA e tento executar um programa de depura√ß√£o para o NIOS II. </font><font style="vertical-align: inherit;">Eu recebo esta mensagem:</font></font><br><br><img src="https://habrastorage.org/webt/88/1c/xk/881cxkj95xirw_0rdrrhyaf0ffm.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se voc√™ tem o mesmo, significa que realmente esqueceu de come√ßar a cronometrar o sistema do processador. Mas agora voc√™ sabe como identific√°-lo rapidamente. E para eliminar, √© necess√°rio e suficiente executar o programa que escrevemos para o processador central. Assim que ele inicia e inicializa a ponte FT2232, os pulsos de clock v√£o para o nosso processador e ser√° poss√≠vel repetir o processo de iniciar a depura√ß√£o. Al√©m disso, o programa para o processador central a essa altura pode ser conclu√≠do. Os pulsos do rel√≥gio n√£o v√£o a lugar algum: a ponte j√° est√° configurada para o modo </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FT245-SYNC</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No programa do processador central, pressione 1. Dependendo da situa√ß√£o, aparece no terminal: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x2 palavras recebidas: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x3020100,0x7060504, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x2 palavras recebidas:</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xb0a0908,0xf0e0d0c,</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x3 palavras recebidas: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x3020100,0x7060504,0xb0a0908, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x1 palavras recebidas: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xf0e0d0c,</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em princ√≠pio, pode haver 1, depois 3 palavras duplas, mas isso n√£o me ocorreu. Tudo depende de quantos bytes t√™m tempo de execu√ß√£o no barramento antes do in√≠cio da primeira exibi√ß√£o. E, se iniciado, no final, todos os outros bytes ter√£o tempo de execu√ß√£o, pois a transfer√™ncia de dados via JTAG n√£o √© um processo r√°pido. Se o barramento usasse sinais de pacotes, o programa seria capaz de ver os dados somente ap√≥s a conclus√£o da recep√ß√£o de pacotes. Em alguns casos, √© bom (ainda n√£o h√° pacote, por que devo v√™-lo? Especialmente se o pacote √© transit√≥rio), em alguns √© ruim (FIFO √© uma caixa preta, para o processamento final, os dados devem ser copiados para a RAM endere√ß√°vel, e isso √© melhor em paralelo com o recebimento de dados ) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os dados transmitidos s√£o colocados em palavras duplas na nota√ß√£o Little Endian. Deixe-me lembr√°-lo de que a seguinte matriz √© passada:</font></font><br><br><pre> <code class="plaintext hljs">static const unsigned char data[0x10] = { 0x00,0x01,0x02,0x03, 0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f };</code> </pre><br>  Isso mesmo.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se voc√™ selecionar o item 2 do programa para o processador central, uma mensagem ser√° exibida (para facilitar a leitura, as linhas ser√£o formatadas ao preparar o artigo): </font></font><br><br><pre> <code class="plaintext hljs">0x3 words received: 0x3020100,0x7060504,0xb0a0908, 0x3d words received: 0xf0e0d0c, 0x13121110,0x17161514,0x1b1a1918,0x1f1e1d1c, 0x23222120,0x27262524,0x2b2a2928,0x2f2e2d2c, 0x33323130,0x37363534,0x3b3a3938,0x3f3e3d3c, 0x43424140,0x47464544,0x4b4a4948,0x4f4e4d4c, 0x53525150,0x57565554,0x5b5a5958,0x5f5e5d5c, 0x63626160,0x67666564,0x6b6a6968,0x6f6e6d6c, 0x73727170,0x77767574,0x7b7a7978,0x7f7e7d7c, 0x83828180,0x87868584,0x8b8a8988,0x8f8e8d8c, 0x93929190,0x97969594,0x9b9a9998,0x9f9e9d9c, 0xa3a2a1a0,0xa7a6a5a4,0xabaaa9a8,0xafaeadac, 0xb3b2b1b0,0xb7b6b5b4,0xbbbab9b8,0xbfbebdbc, 0xc3c2c1c0,0xc7c6c5c4,0xcbcac9c8,0xcfcecdcc, 0xd3d2d1d0,0xd7d6d5d4,0xdbdad9d8,0xdfdedddc, 0xe3e2e1e0,0xe7e6e5e4,0xebeae9e8,0xefeeedec, 0xf3f2f1f0,0xf7f6f5f4,0xfbfaf9f8,0xfffefdfc,</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tudo tamb√©m √© verdade. </font><font style="vertical-align: inherit;">Prosseguimos para verificar a marcha √† r√©. </font><font style="vertical-align: inherit;">Substitu√≠mos o programa do NIOS II por este:</font></font><br><br><pre> <code class="plaintext hljs"> /*  -  2 */ uint32_t buf[] = {0x11223344,0x55667788,0x99aabbcc,0xddeeff00}; for (uint32_t i=0;i&lt;sizeof(buf)/sizeof(buf[0]);i++) { IOWR_ALTERA_AVALON_FIFO_DATA (FIFO_1_IN_BASE,buf[i]); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selecionamos o ponto 3 do programa para o processador central e executamos esta vers√£o do programa para o NIOS II. </font><font style="vertical-align: inherit;">Recebemos: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recebido 16 bytes (4 DWORDs) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x11223344, 0x55667788, 0x99AABBCC, 0xDDEEFF00,</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ambos os canais s√£o dif√≠ceis. </font><font style="vertical-align: inherit;">E vamos dar uma olhada em outra hora de alguma forma.</font></font><br><br><h3>  Conclus√£o </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este artigo discute os conceitos b√°sicos do protocolo de streaming de barramento </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avalon-ST</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Atrav√©s deste protocolo, a conex√£o do processador central Redd com o sistema do processador implementado no FPGA √© organizada. </font><font style="vertical-align: inherit;">Os leitores tiveram uma id√©ia do m√©todo mais simples de intera√ß√£o entre os processadores central e auxiliar. </font><font style="vertical-align: inherit;">Fa√ßa o download dos projetos criados durante o processo de desenvolvimento </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, o conhecimento adquirido sobre protocolos de streaming e seu uso √© muito b√°sico. </font><font style="vertical-align: inherit;">Nos artigos subsequentes, ser√° mostrado como, por meio desses protocolos, salvar com efici√™ncia dados na RAM din√¢mica localizada na placa Redd.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt462253/">https://habr.com/ru/post/pt462253/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt462221/index.html">Qu√£o decepcionado estou no Google Play</a></li>
<li><a href="../pt462227/index.html">Moscou, 9 de agosto - Hist√≥rias de back-end 4.0</a></li>
<li><a href="../pt462243/index.html">Aprimorando o desempenho do front-end do Magento com o ReactJS</a></li>
<li><a href="../pt462245/index.html">auto git bisect como um exemplo do kernel do Linux</a></li>
<li><a href="../pt462251/index.html">O modo de navega√ß√£o an√¥nima no navegador √© uma fic√ß√£o?</a></li>
<li><a href="../pt462257/index.html">Kafka em Kubernetes - isso √© bom?</a></li>
<li><a href="../pt462259/index.html">Fazendo um controlador para uma casa inteligente</a></li>
<li><a href="../pt462263/index.html">Pedal no ch√£o: crie outro manipulador de p√© para PC</a></li>
<li><a href="../pt462265/index.html">Python e cubos</a></li>
<li><a href="../pt462267/index.html">Conhe√ßa o PVS-Studio Static Analyzer for Java</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>