<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍🏫 👁‍🗨 👨 Pengodean suara 1600bit / s dengan neural vocoder LPCNet 🧘🏾 🏼 🙆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ini adalah kelanjutan dari artikel pertama tentang LPCNet . Dalam demo pertama, kami mempresentasikan arsitektur yang menggabungkan pemrosesan sinyal ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengodean suara 1600bit / s dengan neural vocoder LPCNet</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446656/"><img src="https://habrastorage.org/getpro/habr/post_images/6ba/d56/c2e/6bad56c2eecd2e1aad4190ba40d1be74.jpg"><br><br>  Ini adalah kelanjutan dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel pertama tentang LPCNet</a> .  Dalam demo pertama, kami mempresentasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">arsitektur</a> yang menggabungkan pemrosesan sinyal dan pembelajaran mendalam untuk meningkatkan efektivitas sintesis pidato saraf.  Kali ini kita akan mengubah LPCNet menjadi codec pidato saraf dengan bitrate sangat rendah (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel ilmiah</a> ).  Itu dapat digunakan pada peralatan saat ini dan bahkan pada ponsel. <br><br>  Untuk pertama kalinya, seorang neoder vocoder bekerja secara real time pada satu inti prosesor ponsel, dan bukan pada GPU berkecepatan tinggi.  Bitrate akhir 1600 bps adalah sekitar sepuluh kali lebih sedikit daripada codec broadband biasa.  Kualitasnya jauh lebih baik daripada vocoders yang ada dengan bitrate sangat rendah dan sebanding dengan codec yang lebih tradisional yang menggunakan bitrate lebih tinggi. <br><a name="habracut"></a><br><h3>  Encoder dan Vocoder Gelombang </h3><br>  Ada dua jenis besar codec ucapan: codec bentuk gelombang dan vocoder.  Encoder bentuk gelombang termasuk Opus, AMR / AMR-WB, dan semua codec yang dapat digunakan untuk musik.  Mereka mencoba untuk menyediakan bentuk gelombang yang didekodekan sedekat mungkin dengan aslinya - biasanya dengan mempertimbangkan beberapa fitur persepsi.  Vocoder, di sisi lain, sebenarnya adalah synthesizer.  Encoder mengekstrak informasi tentang pitch dan bentuk jalur bicara, meneruskan informasi ini ke decoder, dan dia menyintesis ulang pidato.  Ini hampir seperti pengenalan ucapan diikuti dengan membaca teks dalam synthesizer ucapan, kecuali bahwa pengkodean teks lebih sederhana / lebih cepat daripada pengenalan suara (dan menyampaikan sedikit informasi lebih lanjut). <br><br>  Vocoder sudah ada sejak tahun 70-an, tetapi karena decoder mereka melakukan sintesis wicara, mereka tidak bisa jauh lebih baik daripada sistem sintesis wicara konvensional, yang sampai saat ini terdengar hanya mengerikan.  Inilah sebabnya mengapa vocoders biasanya digunakan pada kecepatan di bawah 3 kB / s.  Selain itu, pembuat enkode gelombang hanya memberikan kualitas terbaik.  Ini berlanjut sampai baru-baru ini, ketika sistem sintesis pidato saraf seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WaveNet muncul</a> .  Tiba-tiba, sintesis mulai terdengar jauh lebih baik, dan, tentu saja, ada orang yang ingin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membuat vocoder dari WaveNet</a> . <br><br><h3>  Ikhtisar LPCNet </h3><br>  WaveNet menghasilkan ucapan berkualitas tinggi, tetapi membutuhkan ratusan gigaflop daya komputasi.  LPCNet secara signifikan mengurangi kompleksitas komputasi.  Vokoder didasarkan pada WaveRNN, yang meningkatkan WaveNet menggunakan jaringan saraf berulang (RNN) dan matriks jarang.  LPCNet lebih lanjut meningkatkan WaveRNN dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">prediksi linier</a> (LPC), yang berkinerja baik di vocoders yang lebih tua.  Ini memprediksi sampel dari kombinasi linear dari sampel sebelumnya dan, yang paling penting, membuatnya berkali-kali lebih cepat daripada jaringan saraf.  Tentu saja, ini tidak universal (jika tidak, vokalis tahun 70-an akan terdengar hebat), tetapi ini dapat secara serius mengurangi beban pada jaringan saraf.  Ini memungkinkan Anda untuk menggunakan jaringan yang lebih kecil dari WaveRNN tanpa mengorbankan kualitas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/652/8fc/7df/6528fc7df88256e797551173b11f5e1d.png"></div><br>  <i><font color="gray">Mari kita lihat lebih dekat pada LPCNet.</font></i>  <i><font color="gray">Bagian kuning di sebelah kiri dihitung sekali per frame, dan outputnya digunakan untuk frekuensi pengambilan sampel jaringan di sebelah kanan (biru).</font></i>  <i><font color="gray">Unit komputasi memprediksi sampel pada waktu t berdasarkan sampel sebelumnya dan koefisien prediksi linier</font></i> <br><br><h1>  Karakteristik kompresi </h1><br>  LPCNet mensintesis ucapan dari vektor 20 karakter per bingkai selama 10 ms.  Dari jumlah tersebut, 18 tanda adalah koefisien <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cepstral yang</a> mewakili bentuk spektrum.  Dua sisanya menggambarkan tinggi: satu parameter untuk periode pitch (periode pitch), dan yang lainnya untuk <i>kekuatan</i> (seberapa besar sinyal berkorelasi dengan dirinya sendiri, jika Anda memperkenalkan penundaan oleh pitch).  Jika Anda menyimpan parameter dalam bentuk nilai floating point, maka semua informasi ini memakan waktu hingga 64 kbit / s selama penyimpanan atau transmisi.  Ini terlalu banyak, karena bahkan codec Opus menyediakan pengodean suara berkualitas sangat tinggi hanya pada 16 kbit / s (untuk mono 16 kHz).  Jelas, Anda perlu menerapkan kompresi kuat di sini. <br><br><h3>  Tinggi </h3><br>  Semua codec sangat bergantung pada pitch, tetapi tidak seperti encoders bentuk gelombang, di mana pitch "hanya" membantu mengurangi redundansi, vocoder tidak memiliki cadangan.  Jika Anda memilih ketinggian yang salah, mereka akan mulai menghasilkan suara yang terdengar buruk (atau bahkan tidak terbaca).  Tanpa merinci (lihat artikel ilmiah), pembuat kode LPCNet berusaha keras untuk tidak membuat kesalahan dalam hal ketinggian.  Pencarian dimulai dengan pencarian <i>korelasi</i> waktu dalam sinyal ucapan.  Lihat di bawah ini cara kerja pencarian biasa. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3e4/024/a6a/3e4024a6aac9fcd8cd1fb8eb750918e6.gif"><br>  <i><font color="gray">Pitch adalah periode di mana pitch diulang.</font></i>  <i><font color="gray">Animasi mencari langkah yang sesuai dengan korelasi maksimum antara sinyal x (n) dan salinan x (nT) dengan penundaan.</font></i>  <i><font color="gray">Nilai T dengan korelasi maksimum adalah tinggi nada</font></i> <br><br>  Informasi ini perlu dikodekan dengan sesedikit mungkin bit tanpa menurunkan hasilnya terlalu banyak.  Karena kita melihat frekuensi secara alami pada skala logaritmik (misalnya, setiap oktaf musik menggandakan frekuensi sebelumnya), masuk akal dalam pengkodean logaritmik.  Ketinggian sinyal bicara pada kebanyakan orang (kami tidak mencoba untuk menutupi sopran di sini) adalah antara 62,5 dan 500 Hz.  Dengan tujuh bit (128 nilai yang mungkin) kami mendapatkan resolusi sekitar seperempat nada (perbedaan antara dan sebelum dan kembali adalah satu nada). <br><br>  Jadi, dengan ketinggian selesai?  Yah, tidak secepat itu.  Orang tidak berbicara seperti robot dari film tahun 1960-an.  Nada suara dapat bervariasi bahkan dalam paket 40 milidetik.  Anda perlu mempertimbangkan hal ini, meninggalkan bit sebagai parameter untuk mengubah ketinggian: 3 bit untuk mengkodekan perbedaan hingga 2,5 semiton antara awal dan akhir paket.  Akhirnya, Anda perlu kode korelasi langkah-langkah pitch, membedakan antara vokal dan konsonan (misalnya, s dan f).  Dua bit sudah cukup untuk korelasi. <br><br><h3>  Cepstrum </h3><br>  Sementara pitch berisi karakteristik eksternal dari bicara (prosodi, emosi, penekanan, ...), karakteristik spektral menentukan <i>apa</i> yang dikatakan (kecuali untuk bahasa nada seperti Cina, di mana pitch penting untuk makna).  Tali suara menghasilkan suara yang kira-kira sama untuk setiap vokal, tetapi bentuk saluran vokal menentukan suara mana yang akan diucapkan.  Jalur suara bertindak sebagai filter, dan tugas pembuat enkode adalah mengevaluasi filter ini dan meneruskannya ke dekoder.  Ini dapat dilakukan secara efektif jika Anda mengubah spektrum ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cepstrum</a> (ya, ini adalah "spektrum" dengan urutan huruf yang berubah, ini adalah kami orang-orang lucu dalam pemrosesan sinyal digital). <br><br>  Untuk sinyal input pada 16 kHz, cepstrum pada dasarnya mewakili vektor 18 angka setiap 10 ms, yang perlu dikompresi sebanyak mungkin.  Karena kami memiliki empat vektor dalam paket 40 ms dan biasanya mirip satu sama lain, kami ingin menghilangkan redundansi sebanyak mungkin.  Ini dapat dilakukan dengan menggunakan vektor tetangga sebagai prediktor dan hanya menyampaikan perbedaan antara prediksi dan nilai sebenarnya.  Pada saat yang sama, kami tidak ingin terlalu bergantung pada paket sebelumnya jika salah satunya hilang.  Sepertinya masalahnya sudah diselesaikan ... <br><br>  <font color="brown"><i>Jika Anda hanya memiliki palu, semuanya terlihat seperti paku - Abraham Maslow.</i></font> <br><br>  Jika Anda banyak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bekerja</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dengan codec video</a> , maka Anda mungkin menemukan konsep B-frame.  Tidak seperti codec video, yang membagi bingkai menjadi banyak paket, kami, sebaliknya, memiliki banyak bingkai dalam satu paket.  Kita mulai dengan menyandikan <i>bingkai kunci</i> , yaitu, vektor independen, dan <b>akhir</b> paket.  Vektor ini dikodekan tanpa prediksi, menempati 37 bit: 7 untuk energi total (koefisien cepstral pertama) dan 30 bit untuk parameter lain menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">vektor kuantisasi</a> (VQ).  Lalu datanglah B-frame (hierarkis).  Dari dua kata kunci (satu dari paket saat ini dan satu dari yang sebelumnya), sebuah cepstrum di antaranya diperkirakan.  Sebagai prediktor untuk mengkodekan perbedaan antara nilai riil dan prediksi, Anda dapat memilih salah satu dari dua bingkai kunci atau nilai rata-rata mereka.  Kami menggunakan VQ lagi dan menyandikan vektor ini menggunakan total 13 bit, termasuk pilihan prediktor.  Sekarang kita hanya memiliki dua vektor tersisa dan sangat sedikit bit.  Gunakan 3 bit terakhir untuk memilih prediktor untuk vektor yang tersisa.  Tentu saja, semua ini jauh lebih mudah dipahami dalam gambar: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/530/395/c02/530395c02aba2079c8e82e79f98071f4.png"></div><br>  <i><font color="gray">Prediksi dan kuantisasi cepstrum untuk paket k.</font></i>  <i><font color="gray">Vektor hijau dikuantisasi secara independen, vektor biru diprediksi, dan vektor merah menggunakan prediksi tanpa kuantisasi residual.</font></i>  <i><font color="gray">Prediksi ditunjukkan oleh panah.</font></i> <br><br><h3>  Menyatukan semuanya </h3><br>  Menambahkan semua hal di atas, kita mendapatkan 64 bit per paket 40 milidetik atau 1600 bit per detik.  Jika Anda ingin menghitung rasio kompresi, maka ucapan broadband terkompresi adalah 256 kbps (16 kHz pada 16 bit per sampel), yang berarti rasio kompresi 160 kali!  Tentu saja, Anda selalu dapat bermain dengan quantizer dan mendapatkan bitrate yang lebih rendah atau lebih tinggi (dengan efek yang sesuai pada kualitas), tetapi Anda harus memulai dari suatu tempat.  Berikut adalah tabel dengan tata letak tempat bit-bit ini pergi. <br><br><table><tbody><tr><td align="center" colspan="2">  <b>Alokasi bit</b> </td></tr><tr><td>  Parameter </td><td>  Sedikit </td></tr><tr><td>  Pitch pitch </td><td>  6 </td></tr><tr><td>  Modulasi tinggi </td><td>  3 </td></tr><tr><td>  Korelasi ketinggian </td><td>  2 </td></tr><tr><td>  Energi </td><td>  7 </td></tr><tr><td>  VP Cepstrum Independen (40 ms) </td><td>  30 </td></tr><tr><td>  Diprediksi VQ Cepstrum (20 ms) </td><td>  13 </td></tr><tr><td>  Interpolasi cepstrum (10 ms) </td><td>  3 </td></tr><tr><td>  Total </td><td>  64 </td></tr></tbody></table><br>  Pada 64 bit per paket 40 ms, pada 25 paket per detik, 1600 bps diperoleh. <br><br><h1>  Implementasi </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode sumber LPCNet</a> tersedia di bawah lisensi BSD.  Ini termasuk perpustakaan yang menyederhanakan penggunaan codec.  Harap perhatikan bahwa pengembangan belum selesai: baik format dan API <b>terikat untuk</b> berubah.  Repositori juga memiliki aplikasi demo <code>lpcnet_demo</code> di mana mudah untuk menguji codec dari baris perintah.  Lihat file README.md untuk instruksi lengkap. <br><br>  Yang ingin menggali lebih dalam, ada pilihan untuk melatih model baru dan / atau menggunakan LPCNet sebagai blok bangunan untuk aplikasi lain, seperti sintesis ucapan (LPCNet hanya satu komponen synthesizer, tidak melakukan sintesis sendiri). <br><br><h3>  Performa </h3><br>  Sintesis ucapan saraf membutuhkan banyak sumber daya.  Pada konferensi ICASSP tahun lalu, Bastian Klein dan rekan-rekannya dari Google / DeepMind menyajikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">codec 2.400 bps berbasis WaveNet</a> , menerima bitstream dari codec2.  Meskipun kedengarannya luar biasa, kompleksitas komputasi ratusan gigaflops berarti bahwa itu tidak dapat diluncurkan secara real-time tanpa GPU yang mahal dan upaya yang serius. <br><br>  Sebaliknya, codec 1600 bit / s kami hanya menghasilkan 3 gigaflops dan dirancang untuk bekerja secara real time pada peralatan yang jauh lebih terjangkau.  Bahkan, ini dapat digunakan hari ini dalam aplikasi nyata.  Diperlukan pengoptimalan menulis beberapa kode untuk set instruksi AVX2 / FMA dan Neon (hanya kode tertanam, tanpa assembler).  Berkat ini, kita sekarang dapat menyandikan (dan terutama men-decode) ucapan secara real time tidak hanya pada PC, tetapi juga pada ponsel yang kurang lebih modern.  Di bawah ini adalah kinerja prosesor x86 dan ARM. <br><br><table><tbody><tr><td colspan="4" align="center">  Performa </td></tr><tr><td>  CPU </td><td>  Frekuensi </td><td>  % dari satu inti </td><td>  Ke waktu nyata </td></tr><tr><td>  AMD 2990WX (Threadripper) </td><td>  3,0 GHz * </td><td>  14% </td><td>  7.0x </td></tr><tr><td>  Intel Xeon E5-2640 v4 (Broadwell) </td><td>  2,4 GHz * </td><td>  20% </td><td>  5.0x </td></tr><tr><td>  Snapdragon 855 (Cortex-A76 di <b>Galaxy S10</b> ) </td><td>  2,82 GHz </td><td>  31% </td><td>  3.2x </td></tr><tr><td>  Snapdragon 845 (Cortex-A75 pada <b>Pixel 3</b> ) </td><td>  2,5 GHz </td><td>  68% </td><td>  1.47x </td></tr><tr><td>  AMD A1100 (Cortex-A57) </td><td>  1,7 GHz </td><td>  102% </td><td>  0,98x </td></tr><tr><td>  BCM2837 (Cortex-A53 pada Raspberry Pi 3) </td><td>  1,2 GHz </td><td>  310% </td><td>  0,32x </td></tr><tr><td>  * mode turbo </td><td></td><td></td><td></td></tr></tbody></table><br><br>  Jumlahnya cukup menarik.  Meskipun hanya Broadwell dan Threadripper yang ditampilkan, pada platform x86, prosesor Haswell dan Skylake memiliki kinerja yang sama (dengan mempertimbangkan frekuensi clock).  Namun, prosesor ARM terasa berbeda satu sama lain.  Bahkan dengan mempertimbangkan perbedaan frekuensi A76 adalah lima hingga enam kali lebih cepat daripada A53: itu cukup diharapkan, karena A53 terutama digunakan untuk efisiensi energi (misalnya, dalam sistem big.LITTLE).  Namun demikian, LPCNet dapat bekerja secara real time pada telepon modern, hanya menggunakan satu inti.  Meskipun akan menyenangkan untuk menjalankannya secara real time di Raspberry Pi 3. Sekarang ini jauh, tetapi tidak ada yang mustahil. <br><br>  Pada x86, alasan pembatasan kinerja adalah lima kali maksimum teoretis.  Seperti yang Anda ketahui, operasi penggandaan matriks-vektor kurang efisien daripada operasi matriks-matriks karena ada lebih banyak unduhan per operasi - khususnya, satu unduhan matriks untuk setiap operasi FMA.  Di satu sisi, kinerja terkait dengan cache L2, yang hanya menyediakan 16 bit per siklus.  Di sisi lain, Intel mengklaim bahwa L2 dapat memberikan hingga 32 bit per siklus di Broadwell dan 64 bit per siklus di Skylake. <br><br><h1>  Hasil </h1><br>  Kami melakukan tes audio gaya MUSHRA untuk membandingkan kualitas pengkodean.  Kondisi pengujian: <br><br><ul><li>  <b>Contoh</b> : asli (jika Anda mendapatkan hasil yang lebih baik dari aslinya, jelas ada yang salah dengan tes Anda) <br></li><li>  <b>1600 bps LPCNet</b> : demo kami <br></li><li>  <b>LPNet Terkompresi</b> : “LPNet dengan 122 Unit Setara” dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel pertama</a> <br></li><li>  <b>Wideband Opus 9000 bps</b> : bitrate terendah di mana Opus 1.3 mengkodekan audio broadband <br></li><li>  <b>MELP pada 2400 bps</b> : vocoder terkenal dengan bit rate rendah (kualitasnya mirip dengan codec2) <br></li><li>  <b>Speex 4000 bps</b> : vocoder broadband ini tidak boleh digunakan, tetapi ini adalah referensi yang bagus untuk bagian bawah </li></ul><br>  Dalam tes pertama (set 1), kami memiliki delapan fragmen pidato dari dua pria dan dua wanita.  File di set pertama milik database yang sama (mis., Kondisi rekaman yang sama) yang digunakan untuk pelatihan, tetapi orang-orang tertentu ini dikecualikan dari set pelatihan.  Dalam tes kedua (set 2), kami menggunakan beberapa file dari tes Opus (tidak dikompresi), merekam suara dalam kondisi yang berbeda, untuk memastikan bahwa LPCNet pergi ke beberapa generalisasi.  Di kedua tes, masing-masing 100 peserta, sehingga kesalahannya cukup kecil.  Lihat hasil di bawah ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc6/e7d/cc5/dc6e7dcc5b08735cb492ad07bf7894af.svg"></div><br>  <i><font color="gray">Kualitas Subyektif (MUSHRA) dalam Dua Tes</font></i> <br><br>  Secara umum, LPCNet pada 1600 bps terlihat bagus - jauh lebih baik daripada MELP pada 2400 bps, dan tidak jauh di belakang Opus pada 9000 bps.  Pada saat yang sama, kualitas LPCNet yang tidak terkompresi sedikit lebih baik daripada Opus pada 9000 bps.  Ini berarti bahwa adalah mungkin untuk memberikan kualitas yang lebih baik daripada Opus dengan laju bit dalam kisaran 2000-6000 bps. <br><br><h3>  Dengarkan dirimu sendiri </h3><br>  Berikut adalah contoh dari tes audio: <br><br>  Wanita (set 1) <br><br><ul><li>  <a href="">Sampel</a> </li><li>  <a href="">LPCNet 1600 bps</a> </li><li>  <a href="">LPNet terkompresi</a> </li><li>  <a href="">Opus 9000 bps</a> </li><li>  <a href="">MELP 2400 bps</a> </li><li>  <a href="">Pidato 4000 bps</a> </li></ul><br>  Man (set 1) <br><br><ul><li>  <a href="">Sampel</a> </li><li>  <a href="">LPCNet 1600 bps</a> </li><li>  <a href="">LPNet terkompresi</a> </li><li>  <a href="">Opus 9000 bps</a> </li><li>  <a href="">MELP 2400 bps</a> </li><li>  <a href="">Pidato 4000 bps</a> </li></ul><br>  Campur (set 2) <br><br><ul><li>  <a href="">Sampel</a> </li><li>  <a href="">LPCNet 1600 bps</a> </li><li>  <a href="">LPNet terkompresi</a> </li><li>  <a href="">Opus 9000 bps</a> </li><li>  <a href="">MELP 2400 bps</a> </li><li>  <a href="">Pidato 4000 bps</a> </li></ul><br><br><h1>  Di mana ini bisa digunakan? </h1><br>  Kami percaya bahwa ini adalah teknologi yang keren, tetapi juga memiliki aplikasi praktis.  Berikut ini beberapa opsi. <br><br><h3>  VoIP di negara-negara yang terhubung dengan buruk </h3><br>  Tidak semua orang selalu memiliki koneksi berkecepatan tinggi.  Di beberapa negara, komunikasi sangat lambat dan tidak dapat diandalkan.  Codec pidato 1600-bit bekerja secara normal dalam kondisi seperti itu, bahkan mengirimkan paket beberapa kali untuk keandalan.  Tentu saja, karena overhead header paket (40 byte untuk IP + UDP + RTP), lebih baik membuat paket yang lebih besar: 40, 80, atau 120 ms. <br><br><h3>  Radio Amatir / HF </h3><br>  Selama sepuluh tahun sekarang, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">David Rowe</a> telah bekerja pada coding pidato untuk komunikasi radio.  Ia mengembangkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Codec2</a> , yang mentransmisikan suara dengan kecepatan 700 hingga 3200 bps.  Selama setahun terakhir, David dan saya membahas cara meningkatkan Codec2 menggunakan sintesis saraf, dan sekarang kami akhirnya melakukannya.  Dalam blognya, David <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menulis</a> tentang implementasi codec berbasis LPCNet untuk integrasi dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FreeDV</a> . <br><br><h3>  Peningkatan Keandalan dalam Paket Hilang </h3><br>  Kemampuan untuk menyandikan bitstream kualitas yang layak dalam sejumlah kecil bit berguna untuk menyediakan redundansi pada saluran yang tidak dapat diandalkan.  Opus memiliki mekanisme koreksi kesalahan maju (FEC) yang dikenal sebagai LBRR, yang mengkodekan frame sebelumnya dengan bitrate lebih rendah dan mengirimkannya dalam frame saat ini.  Ini bekerja dengan baik, tetapi menambahkan overhead yang signifikan.  Duplikasi aliran 1600 bit / s jauh lebih efisien. <br><br><h1>  Paket </h1><br>  Ada banyak kemungkinan untuk menggunakan LPCNet.  Misalnya, meningkatkan codec yang ada (Opus yang sama).  Seperti pada codec lain, kualitas Opus menurun cukup cepat pada bitrate sangat rendah (di bawah 8000 bps), karena codec gelombang tidak memiliki bit yang cocok dengan aslinya.  Tetapi informasi prediksi linear yang ditransmisikan cukup untuk LPCNet untuk mensintesis pidato yang terdengar layak - lebih baik daripada yang dapat dilakukan oleh Opus pada bitrate ini.  Selain itu, sisa informasi yang dikirimkan oleh Opus (perkiraan residu) membantu LPCNet mensintesis hasil yang lebih baik.  Dalam arti tertentu, LPCNet dapat digunakan sebagai post-filter mewah untuk meningkatkan kualitas Opus (atau codec lainnya) tanpa mengubah bitstream (mis., Sambil mempertahankan kompatibilitas penuh). <br><br><h1>  Sumber Daya Tambahan </h1><br><ol><li>  J.-M. Valin, J. Skoglund, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1,6 kbps wideband neural vocoder menggunakan LPCNet</a> , <i>Dikirim ke Interspeech 2019</i> , arXiv: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1903.12087</a> . </li><li>  J.-M. Valin, J. Skoglund, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LPCNet: Sintesis Neural Speech Lanjutan Melalui Prediksi Linier</a> , <i>Proc.</i>  <i>ICASSP, 2019</i> , arXiv: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1810.11846</a> . </li><li>  A. van den Oord, S. Dileman, H. Zen, K. Simonyan, O. Vinyals, A. Graves, N. Kalkhbrenner, E. Senor, K. Kavukuglu, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WaveNet: model generatif untuk suara yang tidak diproses</a> , 2016. </li><li>  N. Karlhbrenner, E. Elsen, C. Simonyan, S. Nouri, N. Casagrande, E. Lockhart, F. Stimberg, A. van den Oord, S. Dileman, K. Kavukuglu, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sintesis suara saraf yang efektif</a> , 2018. </li><li>  V.B.Klein, F.S.K. Lim, A.Lyubs, J.Skoglund, F. Stimberg, K. Wang, T.S. Walters, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengkodean ucapan bitrate rendah berdasarkan Wavenet</a> , 2018 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode sumber</a> LPCNet. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Codec untuk FreeDV berdasarkan LPCNet oleh</a> David Rowe. </li><li>  Bergabunglah dengan diskusi tentang pengembangan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">#opus di irc.freenode.net</a> (→ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">antarmuka web</a> ) </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id446656/">https://habr.com/ru/post/id446656/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id446638/index.html">Cisco HyperFlex vs. pesaing: menguji kinerja</a></li>
<li><a href="../id446640/index.html">20 proyek, 20 bahasa, batas waktu kemarin. Bagian 2</a></li>
<li><a href="../id446642/index.html">Daftar periksa untuk membuat dan menerbitkan aplikasi web</a></li>
<li><a href="../id446648/index.html">Pengembangan operator Kubernetes dengan Kerangka Operator</a></li>
<li><a href="../id446654/index.html">Bagaimana kami menyimpan ulasan kode</a></li>
<li><a href="../id446660/index.html">AI, siswa dan hadiah besar: bagaimana melakukan pembelajaran mesin di kelas 8</a></li>
<li><a href="../id446662/index.html">Transaksi dan mekanisme untuk kontrol mereka</a></li>
<li><a href="../id446664/index.html">SAP Forum 2019 hanya 2 minggu lagi! Apa yang akan ada di sana?</a></li>
<li><a href="../id446666/index.html">Peras kalkulator grafis: game di TI-83</a></li>
<li><a href="../id446668/index.html">Python untuk web: apa yang perlu diketahui junior untuk bekerja dan tumbuh</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>