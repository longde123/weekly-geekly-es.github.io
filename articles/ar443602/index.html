<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍💻 👊🏽 🍿 ما هو التعصب الصارم ولماذا نهتم؟ الجزء 2 🎠 📔 ☺️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="(أو كتابة تمويه ، سلوك غامض والمحاذاة ، يا إلهي!) 

 أيها الأصدقاء ، لا يتبقى سوى القليل من الوقت قبل إطلاق سلسلة رسائل جديدة في الدورة التدريبية "C +...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ما هو التعصب الصارم ولماذا نهتم؟ الجزء 2</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/443602/" style=";text-align:right;direction:rtl">  <b><i>(أو كتابة تمويه ، سلوك غامض والمحاذاة ، يا إلهي!)</i></b> <br><br>  أيها الأصدقاء ، لا يتبقى سوى القليل من الوقت قبل إطلاق سلسلة رسائل جديدة في الدورة التدريبية <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">"C ++ Developer"</a> .  لقد حان الوقت لنشر ترجمة للجزء الثاني من المادة ، والتي تحكي عن ما تكتبه التورية. <br><br>  <b>ما هو التورية الوصف؟</b> <br><br>  لقد وصلنا إلى النقطة التي قد نتساءل فيها لماذا قد نحتاج إلى أسماء مستعارة على الإطلاق؟  عادة لتنفيذ التورية الكتابة ، المعارف التقليدية.  الأساليب المستخدمة بكثرة تنتهك قواعد التعرجات الصارمة. <br><br><img src="https://habrastorage.org/webt/dz/u-/cd/dzu-cdwp2tjct7bc-stnxfnptpe.png"><br><br>  في بعض الأحيان ، نريد الالتفاف على نظام الكتابة وتفسير الكائن كنوع آخر.  إعادة تفسير قطعة الذاكرة كنوع آخر يسمى نوع <i>التورية التورية</i> .  تعد كتابة التورية مفيدة للمهام التي تتطلب الوصول إلى التمثيل الأساسي لكائن لعرض البيانات المقدمة أو نقلها أو معالجتها.  المناطق النموذجية التي يمكننا من خلالها مواجهة استخدام التورية في الكتابة: المترجمون ، التسلسل ، رمز الشبكة ، إلخ. <a name="habracut"></a><br>  تقليديًا ، تم تحقيق ذلك عن طريق أخذ عنوان الكائن ، وإلقائه على مؤشر إلى النوع الذي نريد أن نترجم إليه ، ثم الوصول إلى القيمة ، أو بمعنى آخر ، استخدام الأسماء المستعارة.  على سبيل المثال: <br><br><pre style=";text-align:right;direction:rtl"><code class="bash hljs">int x = 1 ; //   C <span class="hljs-built_in"><span class="hljs-built_in">float</span></span> *fp = (<span class="hljs-built_in"><span class="hljs-built_in">float</span></span>*)&amp;x ; //   //  C++ <span class="hljs-built_in"><span class="hljs-built_in">float</span></span> *fp = reinterpret_cast&lt;<span class="hljs-built_in"><span class="hljs-built_in">float</span></span>*&gt;(&amp;x) ; //   <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>( “%f\n”, *fp ) ;</code> </pre> <br>  كما رأينا في وقت سابق ، هذا هو التعرجات غير مقبولة ، وهذا سوف يسبب سلوك غير محدد.  لكن تقليديًا ، لم يستخدم المترجمون قواعد صارمة للتسميط ، وكان هذا النوع من الأكواد يعمل عادةً فقط ، والمستخدمون ، للأسف ، معتادون على السماح بمثل هذه الأشياء.  هناك طريقة شائعة بديلة لكتابة الكلمات هي من خلال الاتحاد ، وهي صالحة في C ، ولكنها ستتسبب في سلوك غير محدد في C ++ ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">انظر المثال</a> ): <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">union u1 { int n; <span class="hljs-built_in"><span class="hljs-built_in">float</span></span> f; } ; union u1 u; uf = 1.0f; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>( <span class="hljs-string"><span class="hljs-string">"%d\n”, un ); // UB(undefined behaviour)  C++ “n is not the active member”</span></span></code> </pre> <br>  هذا غير مقبول في C ++ ، ويعتقد البعض أن النقابات مخصصة فقط لتنفيذ أنواع متباينة ، ويرون أن استخدام النقابات لكتابة التورية يعتبر إساءة. <br><br>  <b>كيفية تنفيذ لعبة الكلمات؟</b> <br><br>  الطريقة المباركة القياسية لكتابة التورية في C و C ++ هي memcpy.  قد يبدو هذا الأمر معقدًا بعض الشيء ، لكن المحسن بحاجة إلى التعرف على استخدام memcpy للتورية وتحسينه وإنشاء سجل لتسجيل الخطوة.  على سبيل المثال ، إذا علمنا أن int64_t هو نفس حجم المضاعفة: <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">static_assert( sizeof( double ) == sizeof( int64_t ) ); // C++17   </code> </pre> <br>  يمكننا استخدام <code>memcpy</code> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">void func1( double d ) { std::int64_t n; std::memcpy(&amp;n, &amp;d, sizeof d); //…</code> </pre><br>  مع وجود مستوى كافٍ من التحسين ، يقوم أي مترجم حديث لائق بإنشاء كود مماثل لطريقة reinterpret_cast المذكورة سابقًا أو طريقة الصلة للحصول على التورية.  دراسة الكود الذي تم إنشاؤه ، نرى أنه يستخدم فقط سجل mov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مثال</a> ). <br><br>  <b>أنواع التورية والمصفوفات</b> <br><br>  ولكن ماذا لو أردنا تطبيق التورية لصفيف char غير موقَّع في سلسلة من int غير الموقَّعة ثم إجراء عملية على كل قيمة int غير موقعة؟  يمكننا استخدام memcpy لتحويل مصفوفة char غير موقعة إلى نوع int غير مجزأ مؤقت.  سيظل المحسن قادرًا على رؤية كل شيء من خلال memcpy وتحسين كل من الكائن المؤقت والنسخة ، والعمل مباشرة مع البيانات الأساسية ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مثال</a> ): <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">//  ,    int foo( unsigned int x ) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> x ; } // ,  len  sizeof(unsigned int) int bar( unsigned char *p, size_t len ) { int result = 0; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( size_t index = 0; index &lt; len; index += sizeof(unsigned int) ) { unsigned int ui = 0; std::memcpy( &amp;ui, &amp;p[index], sizeof(unsigned int) ); result += foo( ui ) ; } <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> result; }</code> </pre><br>  في هذا المثال ، نأخذ <code>char*p</code> ، نفترض أنه يشير إلى عدة أجزاء من بيانات <code>sizeof(unsigned int)</code> ، وتفسير كل جزء من البيانات على أنه <code>unsigned int</code> ، وحساب <code>foo()</code> لكل جزء من التورية ، ونلخصها في النتيجة ، ونعيد القيمة النهائية . <br><br>  يوضح التجميع لهيكل الحلقة أن المحسّن يحول الجسم إلى وصول مباشر إلى صفيف قاعدة <code>unsigned char</code> باعتباره <code>unsigned int</code> ، <code>eax</code> مباشرةً إلى <code>eax</code> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">add eax, dword ptr [rdi + rcx]</code> </pre> <br>  نفس الكود ، ولكن باستخدام <code>reinterpret_cast</code> لتنفيذ التورية (ينتهك التعابير الصارمة): <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">// ,  len  sizeof(unsigned int) int bar( unsigned char *p, size_t len ) { int result = 0; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( size_t index = 0; index &lt; len; index += sizeof(unsigned int) ) { unsigned int ui = *reinterpret_cast&lt;unsigned int*&gt;(&amp;p[index]); result += foo( ui ); } <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> result; }</code> </pre> <br>  <b>C ++ 20 و bit_cast</b> <br><br>  في C ++ 20 ، لدينا <code>bit_cast</code> ، والذي يوفر طريقة سهلة وآمنة للترجمة ، ويمكن استخدامه أيضًا في سياق <code>constexpr</code> . <br><br>  التالي مثال عن كيفية استخدام <code>bit_cast</code> لتفسير عدد صحيح غير <code>bit_cast</code> في <code>float</code> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مثال</a> ): <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">std::cout &lt;&lt; bit_cast&lt;<span class="hljs-built_in"><span class="hljs-built_in">float</span></span>&gt;(0x447a0000) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span> ; //,  sizeof(<span class="hljs-built_in"><span class="hljs-built_in">float</span></span>) == sizeof(unsigned int)</code> </pre> <br>  في حالة عدم وجود نفس الحجم بين الأنواع من وإلى ، فإن هذا يتطلب منا استخدام بنية وسيطة.  سنستخدم بنية تحتوي على صفيف أحرف متعددة من <code>sizeof(unsigned int)</code> (يفترض int 4-بايت غير موقعة) كنوع من ، و <code>unsigned int</code> كـ إلى. <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">struct uint_chars { unsigned char arr[sizeof( unsigned int )] = {} ; //  sizeof( unsigned int ) == 4 }; //  len  4 int bar( unsigned char *p, size_t len ) { int result = 0; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( size_t index = 0; index &lt; len; index += sizeof(unsigned int) ) { uint_chars f; std::memcpy( f.arr, &amp;p[index], sizeof(unsigned int)); unsigned int result = bit_cast&lt;unsigned int&gt;(f); result += foo( result ); } <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> result ; }</code> </pre> <br>  لسوء الحظ ، نحن بحاجة إلى هذا النوع الوسيط - وهذا هو الحد الحالي <code>bit_cast</code> . <br><br>  <b>محاذاة</b> <br><br>  في الأمثلة السابقة ، رأينا أن انتهاك قواعد التعرجات الصارمة يمكن أن يؤدي إلى استبعاد التخزين أثناء التحسين.  يمكن أن يؤدي انتهاك التعرجات الصارمة أيضًا إلى انتهاك متطلبات التوافق.  يقول كل من معايير C و C ++ أن الكائنات تخضع لمتطلبات المحاذاة التي تحد من المكان الذي يمكن وضع الكائنات فيه (في الذاكرة) وبالتالي يمكن الوصول إليها.  <i>C11 القسم 6.2.8 محاذاة حالات الكائنات</i> : <br><br>  تحتوي الأنواع الكاملة من الكائنات على متطلبات محاذاة تفرض قيودًا على العناوين التي يمكن وضع كائنات من هذا النوع عليها.  المحاذاة هي قيمة عددية معرفة بالتنفيذ والتي تمثل عدد البايتات بين العناوين المتتالية التي يمكن وضع هذا الكائن فيها.  يفرض نوع الكائن متطلبات محاذاة على كل كائن من هذا النوع: يمكن طلب محاذاة أكثر صرامة باستخدام <code>_Alignas</code> . <br><br>  <b>معيار مشروع C ++ 17 في القسم 1 [basic.align]</b> : <br><br>  لأنواع الكائنات متطلبات محاذاة (6.7.1 ، 6.7.2) تفرض قيودًا على العناوين التي يمكن وضع كائن من هذا النوع عليها.  المحاذاة هي قيمة عددية معرفة بالتنفيذ والتي تمثل عدد البايتات بين العناوين المتتالية التي يمكن عندها وضع كائن معين.  نوع الكائن يفرض شرط محاذاة على كل كائن من هذا النوع ؛  يمكن طلب محاذاة أكثر صرامة باستخدام محدد المحاذاة (10.6.2). <br><br>  يشير كل من C99 و C11 بشكل صريح إلى أن التحويل الذي ينتج عنه مؤشر غير محايد هو سلوك غير محدد ، القسم 6.3.2.3.  <i>المؤشرات</i> تقول: <br><blockquote style=";text-align:right;direction:rtl">  يمكن تحويل مؤشر إلى كائن أو نوع جزئي إلى مؤشر إلى كائن آخر أو نوع جزئي.  إذا لم يتم محاذاة المؤشر الناتج بشكل صحيح لنوع المؤشر ، فإن السلوك غير معرف.  ... <br></blockquote>  على الرغم من أن C ++ ليست واضحة ، أعتقد أن هذه الجملة من الفقرة 1 <code>[basic.align]</code> كافية: <br><blockquote style=";text-align:right;direction:rtl">  ... نوع الكائن يفرض شرط محاذاة على كل كائن من هذا النوع ؛  ... </blockquote>  <i><b>مثال</b></i> <br><br>  لذلك دعونا نفترض: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  alignof (char) و alignof (int) هما 1 و 4 على التوالي </li><li style=";text-align:right;direction:rtl">  sizeof (int) هو 4 </li></ul><br>  وبالتالي ، فإن تفسير صفيف char بحجم 4 على أنه <code>int</code> ينتهك التعرجات الصارمة ، وقد ينتهك أيضًا متطلبات المحاذاة إذا كان للصفيف محاذاة 1 أو 2 بايت. <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">char arr[4] = { 0x0F, 0x0, 0x0, 0x00 }; //        1  2  int x = *reinterpret_cast&lt;int*&gt;(arr); // Undefined behavior  </code> </pre> <br>  مما قد يؤدي إلى انخفاض الأداء أو خطأ ناقل في بعض الحالات.  في حين أن استخدام المحاذاة لفرض نفس المحاذاة لصفيف في int سيمنع متطلبات المحاذاة من الانهيار: <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">alignas(alignof(int)) char arr[4] = { 0x0F, 0x0, 0x0, 0x00 }; int x = *reinterpret_cast&lt;int*&gt;(arr);</code> </pre> <br>  <i><b>الذرية</b></i> <br><br>  عقاب آخر غير متوقع للوصول غير المتوازن هو أنه ينتهك atomicity بعض المباني.  قد لا تظهر المخازن الذرية ذرية لمؤشرات الترابط الأخرى في x86 إذا لم تكن محاذاة. <br><br>  <b>اصطياد الانتهاكات الصارمة</b> <br><br>  ليس لدينا العديد من الأدوات الجيدة لتتبع التعرجات الصارمة في C ++.  الأدوات التي لدينا سوف نلاحظ بعض حالات الانتهاكات وبعض حالات التحميل والتخزين غير المناسبين. <br><br>  يمكن لـ gcc باستخدام <code>-fstrict-aliasing</code> و <code>-Wstrict-aliasing</code> التقاط بعض الحالات ، على الرغم من أن ذلك لا يخلو من الإيجابيات / المشكلات الخاطئة.  على سبيل المثال ، ستنشئ الحالات التالية تحذيرًا في gcc ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مثال</a> ): <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">int a = 1; short j; <span class="hljs-built_in"><span class="hljs-built_in">float</span></span> f = 1.f; //   ,   TIS ,         <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%i\n"</span></span>, j = *(reinterpret_cast&lt;short*&gt;(&amp;a))); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%i\n"</span></span>, j = *(reinterpret_cast&lt;int*&gt;(&amp;f)));</code> </pre> <br>  على الرغم من أنه لن يلتقط هذه الحالة الإضافية ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مثال</a> ): <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">int *p; p=&amp;a; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%i\n"</span></span>, j = *(reinterpret_cast&lt;short*&gt;(p)));</code> </pre><br>  على الرغم من أن <code>clang</code> يحل هذه الأعلام ، إلا أنه لا يبدو أنه يقوم بالفعل بتنفيذ التحذير. <br><br>  أداة أخرى لدينا هي ASan ، والتي يمكنها التقاط وتخزين محاذاة بطريقة خاطئة.  على الرغم من أنها ليست انتهاكات مباشرة للتعرج الصارم ، إلا أنها نتيجة شائعة إلى حد ما.  على سبيل المثال ، ستنشئ الحالات التالية أخطاء وقت التشغيل أثناء التجميع باستخدام <code>-fsanitize=address</code> باستخدام <code>-fsanitize=address</code> <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">int *x = new int[2]; // 8 : [0,7]. int *u = (int*)((char*)x + 6); //     x    *u = 1; //    [6-9] <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>( <span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, *u ); //    [6-9]</code> </pre> <br>  الأداة الأخيرة التي أوصي بها هي خاصة بـ C ++ ، وفي الواقع ، ليست فقط أداة ، ولكن أيضًا ممارسة تشفير لا تسمح <code>-Wold-style-cast</code> كل من <code>gcc</code> و <code>clang</code> بإجراء تشخيصات <code>-Wold-style-cast</code> باستخدام <code>-Wold-style-cast</code> .  سيؤدي ذلك إلى فرض أي تورية كتابة غير محددة لاستخدام reinterpret_cast.  بشكل عام ، يجب أن تكون <code>reinterpret_cast</code> منارة لتحليل الشفرة بشكل أكثر شمولاً. <br>  من الأسهل أيضًا البحث في قاعدة البيانات عن <code>reinterpret_cast</code> لإجراء مراجعة. <br><br>  بالنسبة إلى C ، لدينا جميع الأدوات الموضحة بالفعل ، ولدينا أيضًا <code>tis-interpreter</code> ، وهو محلل ثابت يقوم بتحليل شامل للبرنامج لمجموعة فرعية كبيرة من C. وبالنظر إلى إصدارات C في المثال السابق ، حيث يتخطى استخدام - التعرج الدقيق - حالة واحدة ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مثال</a> ) <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">int a = 1; short j; <span class="hljs-built_in"><span class="hljs-built_in">float</span></span> f = 1.0 ; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%i\n"</span></span>, j = *((short*)&amp;a)); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%i\n"</span></span>, j = *((int*)&amp;f)); int *p; p=&amp;a; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%i\n"</span></span>, j = *((short*)p));</code> </pre><br>  يمكن لمترجم TIS اعتراض الثلاثة ، والمثال التالي يستدعي TIS kernel كمترجم TIS (يتم تحرير الإخراج للإيجاز): <br><br><pre style=";text-align:right;direction:rtl"> <code class="bash hljs">./bin/tis-kernel -sa example1.c ... example1.c:9:[sa] warning: The pointer (short *)(&amp; a) has <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> short *. It violates strict aliasing rules by accessing a cell with effective <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> int. ... example1.c:10:[sa] warning: The pointer (int *)(&amp; f) has <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> int *. It violates strict aliasing rules by accessing a cell with effective <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> <span class="hljs-built_in"><span class="hljs-built_in">float</span></span>. Callstack: main ... example1.c:15:[sa] warning: The pointer (short *)p has <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> short *. It violates strict aliasing rules by accessing a cell with effective <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> int.</code> </pre> <br>  وأخيرا ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">TySan</a> ، والتي هي قيد التطوير.  يضيف هذا المطهر معلومات التحقق من النوع إلى شريحة ذاكرة الظل ويتحقق من الوصول لتحديد ما إذا كانت تنتهك قواعد الاسم المستعار.  من المحتمل أن تكون الأداة قادرة على تتبع جميع انتهاكات الأسماء المستعارة ، ولكن قد يكون لها حمل كبير في وقت التشغيل. <br><br>  <b>استنتاج</b> <br><br>  لقد تعلمنا عن الأسماء المستعارة للقواعد في C و C ++ ، مما يعني أن المترجم يتوقع منا اتباع هذه القواعد بصرامة وقبول عواقب عدم الوفاء بها.  لقد علمنا ببعض الأدوات التي يمكن أن تساعدنا في تحديد بعض إساءة استخدام الاسم المستعار.  لقد رأينا أن الاستخدام المعتاد للتعرج هو لعبة الكلمات.  لقد تعلمنا أيضًا كيفية تنفيذه بشكل صحيح. <br><br>  يعمل المحسّنون تدريجياً على تحسين تحليل الاسم المستعار القائم على النوع ويقومون بالفعل باختراق بعض الأكواد التي تستند إلى انتهاكات التعرجات الصارمة.  يمكننا أن نتوقع أن تتحسن التحسينات وتكسر المزيد من الأكواد التي عملت من قبل. <br><br>  لدينا طرق متوافقة قياسية جاهزة لتفسير الأنواع.  في بعض الأحيان لبنيات التصحيح يجب أن تكون هذه الأساليب مجردة حرة.  لدينا العديد من الأدوات للكشف عن انتهاكات التعرجات الشديدة ، لكن بالنسبة إلى الإصدار C ++ ، فإنهم سيشاهدون جزءًا صغيرًا فقط من الحالات ، وبالنسبة لـ C باستخدام مترجم tis ، يمكننا تتبع معظم الانتهاكات. <br><br>  شكرًا لأولئك الذين علقوا على هذا المقال: ج. ف. باستين ، كريستوفر دي بيلا ، باسكال كووك ، مات ب. دزيوبينسكي ، باتريس روي وأولافور فاجي <br>  بالطبع ، في النهاية ، كل الأخطاء تعود إلى المؤلف. <br><br>  لذلك انتهت ترجمة مادة كبيرة إلى حد ما ، يمكن قراءة الجزء الأول منها <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">هنا</a> .  ونحن ندعوك عادة إلى <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">اليوم المفتوح</a> ، الذي سيعقد في 14 مارس من قبل رئيس قسم تطوير التكنولوجيا في Rambler &amp; Co - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Dmitry Shebordaev.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><br></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar443602/">https://habr.com/ru/post/ar443602/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar443588/index.html">أستاذ معهد ماساتشوستس للتكنولوجيا يكشف النقاب عن مستقبل الأطراف الاصطناعية في TED</a></li>
<li><a href="../ar443592/index.html">معيار RFID للواجهة الأمامية ISO 11785 من جهاز استقبال FM قديم وحطام المصعد</a></li>
<li><a href="../ar443594/index.html">مفترق طرق الاختبار والهندسة المعمارية: مقابلة مع نيل فورد</a></li>
<li><a href="../ar443598/index.html">هناك إبطال جماعي لشهادات TLS من العديد من المراجع المصدقة ، التي تم إنشاؤها عن طريق الخطأ على RNG 63 بت بدلاً من 64 بت</a></li>
<li><a href="../ar443600/index.html">أفضل وأسوأ الاتجاهات في MWC 2019</a></li>
<li><a href="../ar443604/index.html">أول موبايل: هاكاثون في أوزون</a></li>
<li><a href="../ar443606/index.html">Jenkins لنظام Android بناء باستخدام عامل ميناء</a></li>
<li><a href="../ar443608/index.html">المنزل الذكي / تحديثات في Lazurite</a></li>
<li><a href="../ar443612/index.html">نحن نستخدم محركات الأقراص الصلبة القديمة السيئة</a></li>
<li><a href="../ar443614/index.html">YouTrack 2019.1: حدد لوحات Agile وحقول البطاقات القابلة للتخصيص على لوحات Agile والمزيد</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>