<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕞 🥓 👨‍👧‍👧 Contrôle à distance de l'émulateur Fceux à l'aide de Python 🕠 🌓 👨🏼‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans l'article, je décrirai comment rendre l'émulateur NES contrôlé à distance, et un serveur pour lui envoyer des commandes à distance. 



 Pourquoi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Contrôle à distance de l'émulateur Fceux à l'aide de Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435428/">  Dans l'article, je décrirai comment rendre l'émulateur NES contrôlé à distance, et un serveur pour lui envoyer des commandes à distance. <br><br><img src="https://habrastorage.org/webt/fb/4n/te/fb4ntevb-6j5knunjyr3jq0wec0.png"><br><br><h2>  Pourquoi est-ce nécessaire? </h2><br>  Certains émulateurs de différentes consoles de jeux, dont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fceux</a> , vous permettent d'écrire et d'exécuter des scripts personnalisés sur Lua.  Mais Lua est un mauvais langage pour écrire des programmes sérieux.  C'est plutôt un langage pour appeler des fonctions écrites en C.  Les auteurs d'émulateurs l'utilisent uniquement en raison de la légèreté et de la facilité d'intégration.  Une émulation précise nécessite beaucoup de ressources processeur, et une vitesse d'émulation antérieure était l'un des principaux objectifs des auteurs, et s'ils se souvenaient de la possibilité d'actions de script, ce n'était pas le premier. <br><br>  Maintenant, la puissance du processeur moyen suffit pour émuler NES, pourquoi ne pas utiliser des langages de script puissants comme Python ou JavaScript dans les émulateurs? <br><br>  Malheureusement, aucun des émulateurs NES populaires n'a la capacité d'utiliser ces langues ou d'autres.  Je n'ai trouvé qu'un projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nintaco</a> peu connu, qui est également basé sur le noyau Fceux, pour une raison quelconque réécrit en Java.  J'ai ensuite décidé d'ajouter la possibilité d'écrire des scripts en Python pour contrôler moi-même l'émulateur. <br><br>  Mon résultat est le Proof-of-Concept de la capacité à contrôler l'émulateur, il ne prétend ni vitesse ni fiabilité, mais ça marche.  Je l'ai fait moi-même, mais comme la question de savoir comment contrôler l'émulateur à l'aide de scripts est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">assez</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">courante</a> , j'ai mis le code source sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github</a> . <br><a name="habracut"></a><br><h2>  Comment ça marche </h2><br><h3>  Du côté de l'émulateur </h3><br>  L'émulateur Fceux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">inclut déjà</a> plusieurs bibliothèques Lua incluses sous <a href="">forme de code compilé</a> .  L'un d'eux est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LuaSocket</a> .  C'est mal documenté, mais j'ai réussi à trouver un exemple de code de travail parmi la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">collection de scripts</a> <i><b>Xkeeper0</b></i> .  Il a utilisé des prises pour contrôler l'émulateur via Mirc.  En fait, le code qui ouvre le socket TCP est: <br><br><pre><code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(address, port, laddress, lport)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> sock, err = socket.tcp() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> sock <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> laddress <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> res, err = sock:bind(laddress, lport, <span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> res, err = sock:connect(address, port) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sock <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> sock2, err2 = connect(<span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span>, <span class="hljs-number"><span class="hljs-number">81</span></span>) sock2:settimeout(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">--it's our socket object print("Connected", sock2, err2)</span></span></code> </pre> <br>  Il s'agit d'un socket de bas niveau qui reçoit et envoie des données d'un octet. <br><br>  Dans l'émulateur Fceux, la boucle principale du script Lua ressemble à ceci: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-comment"><span class="hljs-comment">--  passiveUpdate() --,        emu.frameadvance() --       end end</span></span></code> </pre><br>  Une vérification des données du socket: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">passiveUpdate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> message, err, part = sock2:receive(<span class="hljs-string"><span class="hljs-string">"*all"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> message <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> message = part <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> message <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(message)&gt;<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-comment"><span class="hljs-comment">--print(message) local recCommand = json.decode(message) table.insert(commandsQueue, recCommand) coroutine.resume(parseCommandCoroutine) end end</span></span></code> </pre><br>  Le code est assez simple - les données sont lues à partir du socket, et si la prochaine commande est détectée, elle est analysée et exécutée.  L'analyse et l'exécution sont organisées à l'aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">coroutine</a> (coroutines) - il s'agit d'un concept puissant du langage Lua pour suspendre et poursuivre l'exécution de code. <br><br>  Et une autre chose importante à propos des scripts Lua dans Fceux - l'émulation peut être temporairement arrêtée à partir du script.  Comment organiser l'exécution continue du Lua-code et le réexécuter avec une commande reçue du socket?  Ce ne serait pas possible, mais il existe une capacité mal documentée d'appeler du code Lua même lorsque l'émulation est arrêtée (merci <b><i>feos de l'</i></b> avoir <b><i>pointé</i></b> ): <br><br><pre> <code class="lua hljs">gui.register(passiveUpdate) <span class="hljs-comment"><span class="hljs-comment">--undocumented. this function will call even if emulator paused</span></span></code> </pre><br>  Avec lui, vous pouvez arrêter et continuer d'émuler à l'intérieur de <b>passiveUpdate</b> - de cette façon, vous pouvez organiser l'installation des points d'arrêt de l'émulateur via une socket. <br><br><h3>  Commande côté serveur </h3><br>  J'utilise un protocole texte RPC basé sur JSON très simple.  Le serveur sérialise le nom de la fonction et les arguments dans une chaîne JSON et les envoie via le socket.  En outre, l'exécution du code s'arrête jusqu'à ce que l'émulateur réponde par une ligne pour terminer l'exécution de la commande.  La réponse contiendra les champs " <b>FUNCTIONNAME_finished</b> " et le résultat de la fonction. <br><br>  L'idée est implémentée dans la classe <b>syncCall</b> : <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">syncCall</span></span></span><span class="hljs-class">:</span></span> @classmethod <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">waitUntil</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cls, messageName)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""cycle for reading data from socket until needed message was read from it. All other messages will added in message queue"""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: cmd = messages.parseMessages(asyncCall.waitAnswer(), [messageName]) <span class="hljs-comment"><span class="hljs-comment">#print(cmd) if cmd != None: if len(cmd)&gt;1: return cmd[1] return @classmethod def call(cls, *params): """wrapper for sending [functionName, [param1, param2, ...]] to socket and wait until client return [functionName_finished, [result1,...]] answer""" sender.send(*params) funcName = params[0] return syncCall.waitUntil(funcName + "_finished")</span></span></code> </pre><br>  Avec cette classe, les méthodes Lua de l'émulateur Fceux peuvent être enveloppées dans des classes Python: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">emu</span></span></span><span class="hljs-class">:</span></span> @classmethod <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">poweron</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cls)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> syncCall.call(<span class="hljs-string"><span class="hljs-string">"emu.poweron"</span></span>) @classmethod <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pause</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cls)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> syncCall.call(<span class="hljs-string"><span class="hljs-string">"emu.pause"</span></span>) @classmethod <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unpause</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cls)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> syncCall.call(<span class="hljs-string"><span class="hljs-string">"emu.unpause"</span></span>) @classmethod <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">message</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cls, str)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> syncCall.call(<span class="hljs-string"><span class="hljs-string">"emu.message"</span></span>, str) @classmethod <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">softreset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cls)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> syncCall.call(<span class="hljs-string"><span class="hljs-string">"emu.softreset"</span></span>) @classmethod <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">speedmode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cls, str)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> syncCall.call(<span class="hljs-string"><span class="hljs-string">"emu.speedmode"</span></span>, str)</code> </pre><br>  Et puis appelé mot pour mot de la même manière que de Lua: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># : emu.poweron()</span></span></code> </pre><br><h3>  Méthodes de rappel </h3><br>  Dans Lua, vous pouvez enregistrer des rappels - des fonctions qui seront appelées lorsqu'une certaine condition est remplie.  Nous pouvons porter ce comportement sur le serveur en Python en utilisant l'astuce suivante.  Tout d'abord, nous enregistrons l'identifiant de la fonction de rappel écrit en Python et le transmettons au code Lua: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">callbacks</span></span></span><span class="hljs-class">:</span></span> functions = {} callbackList = [ <span class="hljs-string"><span class="hljs-string">"emu.registerbefore_callback"</span></span>, <span class="hljs-string"><span class="hljs-string">"emu.registerafter_callback"</span></span>, <span class="hljs-string"><span class="hljs-string">"memory.registerexecute_callback"</span></span>, <span class="hljs-string"><span class="hljs-string">"memory.registerwrite_callback"</span></span>, ] @classmethod <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">registerfunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cls, func)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> func == <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> hfunc = hash(func) callbacks.functions[hfunc] = func <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hfunc @classmethod <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cls, e)</span></span></span><span class="hljs-function">:</span></span> emu.message(<span class="hljs-string"><span class="hljs-string">"Python error: "</span></span> + str(e)) @classmethod <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkAllCallbacks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cls, cmd)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#print("check:", cmd) for callbackName in callbacks.callbackList: if cmd[0] == callbackName: hfunc = cmd[1] #print("hfunc:", hfunc) func = callbacks.functions.get(hfunc) #print("func:", func) if func: try: func(*cmd[2:]) #skip function name and function hash and save others arguments except Exception as e: callbacks.error(e) pass #</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> thread locking sender.send(callbackName + "_finished")</span></span></code> </pre><br>  Le code Lua enregistre également cet identifiant et enregistre un rappel Lua régulier, qui transférera le contrôle au code Python.  Ensuite, un thread séparé est créé dans le code Python uniquement pour vérifier que la commande de rappel de Lua n'a pas été acceptée: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">callbacksThread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> cycle = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: cycle += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: cmd = messages.parseMessages(asyncCall.waitAnswer(), callbacks.callbackList) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cmd: <span class="hljs-comment"><span class="hljs-comment">#print("Callback received:", cmd) callbacks.checkAllCallbacks(cmd) pass except socket.timeout: pass time.sleep(0.001)</span></span></code> </pre><br>  La dernière étape est qu'après l'exécution du rappel Python, le contrôle est retourné à Lua à l'aide de la <b>commande</b> " <b>CALLBACKNAME_finished</b> " pour informer l'émulateur que le rappel est terminé. <br><br><h2>  Comment exécuter un exemple </h2><br><ul><li>  Vous devez avoir exécuté <b>Python 3</b> et <b>Jupyter Notebook</b> sur le système.  Vous devez exécuter Jupyter avec la commande <br><br><pre> <code class="plaintext hljs">jupyter notebook</code> </pre><br></li><li>  Ouvrez l'ordinateur portable <b>FceuxPythonServer.py.ipynb</b> et exécutez la première ligne <br><img src="https://habrastorage.org/webt/ns/7k/_i/ns7k_i60y_7kscct2pmyqz1_fi8.png"><br></li><li>  Maintenant, vous devez exécuter l'émulateur Fceux, ouvrez le fichier ROM (j'utilise le jeu <b>Castlevania (U) (PRG0) [!]. Nes</b> dans mon exemple) et exécutez le script Lua avec le nom <i>fceux_listener.lua</i> .  Il doit se connecter à un serveur fonctionnant sur un ordinateur portable Jupyter. <br><br>  Ces actions peuvent être effectuées à l'aide de la ligne de commande: <br><br><pre> <code class="plaintext hljs">fceux.exe -lua fceux_listener.lua "Castlevania (U) (PRG0) [!].nes"</code> </pre><br></li><li>  Revenez maintenant au Jupyter Notebook.  Vous devriez voir un message sur une connexion réussie à l'émulateur: <br><br><img src="https://habrastorage.org/webt/41/on/es/41onesw9o66jmtyfexid7wpipbq.png"><br></li></ul><br>  C'est tout, vous pouvez envoyer des commandes de l'ordinateur portable Jupyter dans le navigateur directement à l'émulateur Fceux. <br><br>  Vous pouvez exécuter toutes les lignes de l'exemple d'ordinateur portable de manière séquentielle et observer le résultat dans l'émulateur. <br><br>  Exemple complet: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/spiiin/fceux_luaserver/blob/master/FceuxPythonServer.py.ipynb</a> <br><br>  Il contient des fonctions simples comme lire la mémoire: <br><br><img src="https://habrastorage.org/webt/sg/ut/du/sgutduhqvx6wqzgczn9seozyl08.png"><br><br>  Exemples de rappel plus complexes: <br><br><img src="https://habrastorage.org/webt/ul/qq/1q/ulqq1qufdcbol1zbw_6za2mtfdi.png"><br><br>  Et un script pour un jeu spécifique qui vous permet de déplacer les ennemis de <b>Super Mario Bros.</b>  avec la souris: <br><br><img src="https://habrastorage.org/webt/ie/iw/fa/ieiwfa__-dg4sck64cmekmbcy7y.png"><br><br>  Vidéo sur l'ordinateur portable: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/c3D5gljbkO0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3>  Limitations et applications </h3><br>  Le script n'a aucune protection contre les imbéciles et n'est pas optimisé pour la vitesse d'exécution - il serait préférable d'utiliser un protocole RPC binaire au lieu d'un texte et de regrouper les messages, mais mon implémentation ne nécessite pas de compilation.  Le script peut basculer les contextes d'exécution de Lua à Python et revenir 500 à 1000 fois par seconde sur mon ordinateur portable.  Cela suffit pour presque toutes les applications, à l'exception de cas spécifiques de débogage pixel par pixel ou ligne par ligne du processeur vidéo, mais Fceux n'autorise toujours pas de telles opérations à partir de Lua, donc cela n'a pas d'importance. <br><br>  Idées d'application possibles: <br><br><ul><li>  Comme exemple de mise en œuvre d'un tel contrôle pour d'autres émulateurs et langages </li><li>  Recherche de jeux </li><li>  Ajout de tricheurs ou de fonctionnalités pour organiser les passages TAS </li><li>  Insérer ou extraire des données et du code dans les jeux </li><li>  Amélioration des capacités des émulateurs - écriture de débogueurs, de scripts pour l'enregistrement et la visualisation de procédures pas à pas, bibliothèques de scripts, éditeurs de jeux </li><li>  Jeu en réseau, contrôle de jeu à l'aide d'appareils mobiles, de services à distance, de manettes de jeu ou d'autres appareils de contrôle, enregistrement et correctifs dans les services cloud </li><li>  Fonctionnalités Cross-Emulator </li><li>  Utilisation de Python ou d'autres bibliothèques de langage pour l'analyse des données et le contrôle du jeu (création de bots) </li></ul><br><h3>  Pile technologique </h3><br>  J'ai utilisé: <br><br>  <b>Fceux</b> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">www.fceux.com/web/home.html</a> <br>  Il s'agit d'un émulateur NES classique et la plupart des gens l'utilisent.  Il n'a pas été mis à jour depuis longtemps et n'est pas le meilleur des fonctionnalités, mais il reste l'émulateur par défaut de nombreux romhackers.  Aussi, je l'ai choisi car le support de socket Lua y est intégré, et il n'est pas nécessaire de le connecter moi-même. <br><br>  <b>Json.lua</b> - <a href="">github.com/spiiin/json.lua</a> <br>  Il s'agit d'une implémentation JSON en pur Lua.  Je l'ai choisi parce que je voulais faire un exemple qui ne nécessite pas de compilation de code.  Mais j'ai quand même dû bifurquer la bibliothèque, car certaines des bibliothèques intégrées à Fceux ont surchargé la fonction de bibliothèque <i><b>tostring</b></i> et ont interrompu la sérialisation (ma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">demande de pool</a> rejetée à l'auteur de la bibliothèque d'origine). <br><br>  <b>Python 3</b> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">www.python.org</a> <br>  Le serveur Fceux Lua ouvre le socket tcp et écoute les commandes reçues de celui-ci.  Un serveur qui envoie des commandes à l'émulateur peut être implémenté dans n'importe quelle langue.  J'ai choisi Python pour sa philosophie «Batterie incluse» - la plupart des modules sont inclus dans la bibliothèque standard (fonctionnant également avec les sockets et JSON).  Python connaît également la bibliothèque pour travailler avec les réseaux de neurones, et je veux essayer de les utiliser pour créer des bots dans les jeux NES. <br><br>  <b>Carnet Jupyter</b> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">jupyter.org</a> <br>  Jupyter Notebook est un environnement très cool pour exécuter de manière interactive du code Python.  Avec lui, vous pouvez écrire et exécuter des commandes dans un éditeur de feuille de calcul à l'intérieur du navigateur.  Il est également bon pour créer des exemples présentables. <br><br>  <b>Dexpot</b> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">www.dexpot.de</a> <br>  J'ai utilisé ce gestionnaire de bureau virtuel pour ancrer la fenêtre de l'émulateur au-dessus des autres.  Ceci est très pratique lors du déploiement du serveur en plein écran pour un suivi instantané des modifications dans la fenêtre de l'émulateur.  Les outils Windows natifs ne vous permettent pas d'organiser l'ancrage des fenêtres au-dessus des autres. <br><br><h2>  Les références </h2><br>  En fait, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le référentiel du projet</a> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nintaco</a> - Émulateur Java NES avec gestion à distance <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Collection emke-lua Xkeeper0</a> - une collection de divers scripts Lua <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mesen</a> est un émulateur NES moderne en C # avec de puissantes capacités de script Lua.  Jusqu'à présent, sans prise en charge de prise et télécommande. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CadEditor</a> est mon projet d'un éditeur de niveau universel pour NES et d'autres plateformes, ainsi que de puissants outils de recherche de jeux.  J'utilise le script et le serveur décrits dans l'article pour explorer les jeux et les ajouter à l'éditeur. <br><br>  J'apprécierais les commentaires, les tests et les tentatives d'utilisation du script. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr435428/">https://habr.com/ru/post/fr435428/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr435418/index.html">Utilisation de SQLite dans Flutter</a></li>
<li><a href="../fr435420/index.html">L'avenir de la lutte contre la criminalité est l'étude des arbres généalogiques</a></li>
<li><a href="../fr435422/index.html">Comment les gens expérimentés dans la Silicon Valley</a></li>
<li><a href="../fr435424/index.html">Analyser et Android: recommandations pour les développeurs novices</a></li>
<li><a href="../fr435426/index.html">Fonctionnement de Microsoft Excel avec les hauteurs de ligne</a></li>
<li><a href="../fr435430/index.html">Les nouvelles les plus cool CES 2019</a></li>
<li><a href="../fr435432/index.html">Nouvelle année, nouveau GitHub: dépôts privés gratuits illimités</a></li>
<li><a href="../fr435436/index.html">5 tendances de l'infrastructure informatique: prévisions pour 2019</a></li>
<li><a href="../fr435438/index.html">PHP: changer la structure de la base de données dans le développement d'équipe</a></li>
<li><a href="../fr435442/index.html">Entonnoir de changement</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>