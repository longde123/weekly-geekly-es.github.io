<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤙🏿 👩 🏈 Pelatihan Cisco 200-125 CCNA v3.0. Hari ke 49. Pengantar EIGRP 💇 👑 😗</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari ini kita akan memulai studi kita tentang protokol EIGRP, yang, bersama dengan studi OSPF, adalah topik paling penting dari kursus CCNA. 



 Nant...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pelatihan Cisco 200-125 CCNA v3.0. Hari ke 49. Pengantar EIGRP</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/466679/"> Hari ini kita akan memulai studi kita tentang protokol EIGRP, yang, bersama dengan studi OSPF, adalah topik paling penting dari kursus CCNA. <br><br><img src="https://habrastorage.org/webt/7i/fl/kt/7iflktllrby0jz07oada2df4g2c.jpeg"><br><br>  Nanti kita akan kembali ke bagian 2.5, dan sekarang setelah bagian 2.4 kita akan pergi ke bagian 2.6 "Mengkonfigurasi, Memverifikasi, dan Mengatasi Masalah EIGRP melalui IPv4 (kecuali untuk otentikasi, pemfilteran, penjumlahan manual, redistribusi, dan konfigurasi rintisan)". <br>  Hari ini kita akan memiliki pelajaran pengantar di mana saya akan memberitahu Anda tentang konsep protokol routing gateway EIGRP internal ditingkatkan, dan dalam dua pelajaran berikutnya kita akan melihat mengkonfigurasi dan troubleshooting robot dari protokol ini.  Tetapi pertama-tama, saya ingin memberi tahu Anda yang berikut. <a name="habracut"></a><br><br>  Selama beberapa pelajaran terakhir, kami telah belajar OSPF.  Sekarang saya ingin Anda ingat bahwa ketika kami mempelajari protokol RIP beberapa bulan yang lalu, Anda berbicara tentang loop rute loop dan teknologi yang mencegah perulangan lalu lintas.  Bagaimana saya bisa mencegah terjadinya loop routing ketika menggunakan OSPF?  Bisakah saya menggunakan metode seperti keracunan rute Rute atau membagi cakrawala Horizon?  Ini adalah pertanyaan yang harus Anda jawab sendiri.  Anda dapat menggunakan sumber daya tematik lainnya, tetapi temukan jawaban untuk pertanyaan ini.  Saya ingin Anda belajar bagaimana menemukan jawabannya sendiri, bekerja dengan sumber yang berbeda, dan meminta Anda untuk meninggalkan komentar Anda di bawah video ini sehingga saya dapat melihat berapa banyak siswa saya mengatasi tugas ini. <br><br>  Apa itu EIGRP?  Ini adalah protokol perutean hibrid yang menggabungkan fitur berguna dari protokol distance-vector, seperti RIP, dan protokol pemantauan keadaan tautan tipe-OSPF. <br><br><img src="https://habrastorage.org/webt/r5/ij/-q/r5ij-qkhil7nl0owlwbtpp2glhw.jpeg"><br><br>  EIGRP adalah protokol milik Cisco yang dibuat tersedia untuk umum pada tahun 2013.  Dia mengambil algoritma untuk membangun lingkungan dari protokol pelacakan status saluran, tidak seperti RIP, yang tidak membuat tetangga.  RIP juga bertukar tabel routing dengan peserta lain dalam protokol, tetapi OSPF membentuk lingkungan sebelum memulai pertukaran tersebut.  EIGRP bekerja dengan cara yang sama. <br><br>  RIP setiap 30 detik secara berkala memperbarui tabel perutean lengkap dan mengirimkan informasi tentang semua antarmuka dan semua rute ke semua tetangganya.  EIGRP tidak melakukan pembaruan penuh informasi secara berkala, melainkan menggunakan konsep pengiriman pesan Hello, seperti halnya OSPF.  Setiap beberapa detik, ia mengirim Halo untuk memastikan bahwa tetangga itu masih "hidup". <br><br>  Berbeda dengan protokol distance-vector, yang mempelajari seluruh topologi jaringan, sebelum memutuskan untuk membentuk rute, EIGRP, seperti RIP, membuat rute berdasarkan rumor.  Ketika saya mengatakan "rumor", maksud saya bahwa ketika tetangga mengatakan sesuatu, EIGRP setuju tanpa syarat.  Misalnya, jika seorang tetangga mengatakan bahwa ia tahu cara mencapai 10.1.1.2, EIGRP percaya padanya tanpa bertanya: "Bagaimana Anda tahu ini?  Ceritakan tentang topologi seluruh jaringan! " <br><br>  Hingga 2013, jika Anda hanya menggunakan infrastruktur Cisco, Anda dapat menggunakan EIGRP, karena protokol ini dibuat pada tahun 1994.  Namun, banyak perusahaan, bahkan menggunakan peralatan Cisco, tidak mau bekerja dengan tusukan ini.  Menurut pendapat saya, hari ini EIGRP adalah protokol routing dinamis terbaik karena jauh lebih mudah digunakan, tetapi orang-orang masih lebih suka OSPF.  Saya pikir ini karena fakta bahwa mereka tidak ingin "mengikat" diri mereka dengan produk Cisco.  Tetapi Cisco membuat protokol ini tersedia untuk umum karena mendukung peralatan jaringan pihak ketiga, seperti Juniper, dan jika Anda bekerja sama dengan perusahaan yang tidak menggunakan peralatan Cisco, Anda tidak akan memiliki masalah. <br><br>  Mari kita bertamasya singkat ke dalam sejarah protokol jaringan. <br><br><img src="https://habrastorage.org/webt/pm/kj/m0/pmkjm0shef8akrvzk3-qxj5vr78.jpeg"><br><br>  Protokol RIPv1, yang muncul pada 1980-an, memiliki sejumlah batasan, misalnya, jumlah harapan maksimum adalah 16, dan karenanya tidak dapat menyediakan perutean di jaringan besar.  Beberapa saat kemudian, kami mengembangkan protokol routing gateway IGRP internal, yang jauh lebih baik daripada RIP.  Namun, itu lebih merupakan protokol vektor jarak daripada protokol status saluran.  Pada akhir 80-an, standar terbuka muncul - protokol pemantauan saluran OSPFv2 untuk protokol IPv4. <br><br>  Pada awal 90-an, Cisco memutuskan bahwa IGRP perlu ditingkatkan dan merilis protokol routing gateway EIGRP internal yang ditingkatkan.  Itu jauh lebih efisien daripada OSPF karena menggabungkan fitur RIP dan OSPF.  Ketika kami mulai menjelajahinya, Anda akan melihat bahwa mengonfigurasi EIGRP jauh lebih mudah daripada OSPF.  Cisco mencoba membuat protokol yang akan memastikan konvergensi jaringan tercepat. <br><br>  Pada akhir 90-an, versi RIPv2 protokol tanpa kelas yang diperbarui dirilis.  Pada 2000-an, versi ketiga OSPF, RIPng, dan EIGRPv6 muncul yang mendukung IPv6.  Dunia secara bertahap mendekati transisi penuh ke IPv6, dan para pengembang protokol routing ingin bersiap untuk ini. <br><br>  Jika Anda ingat, kami mempelajari bahwa ketika memilih rute RIP yang optimal, sebagai protokol vektor jarak, dipandu oleh hanya satu kriteria - jumlah harapan minimum, atau jarak minimum ke antarmuka tujuan.  Jadi, router R1 akan memilih rute langsung ke router R3 terlepas dari kenyataan bahwa kecepatan pada rute ini - 64 kbit / s - beberapa kali lebih sedikit daripada kecepatan pada rute R1-R2-R3, sama dengan 1544 kbit / s.  Protokol RIP mempertimbangkan optimal rute lambat satu panjang hop daripada rute cepat 2 hop panjang. <br><br><img src="https://habrastorage.org/webt/sz/fi/qs/szfiqsigil_mar3mix7iuf-o5ko.jpeg"><br><br>  OSPF akan mempelajari seluruh topologi jaringan dan memutuskan untuk menggunakan rute melalui router R2 untuk berkomunikasi dengan router R3 lebih cepat.  RIP menggunakan jumlah harapan sebagai metrik, dan metrik OSPF adalah biayanya, yang dalam banyak kasus sebanding dengan bandwidth saluran. <br><br>  EIGRP juga berfokus pada biaya rute, tetapi metriknya jauh lebih kompleks daripada metrik OSPF dan bergantung pada banyak faktor, termasuk Bandwidth, Delay Delay, Keandalan Keandalan, kemacetan pemuatan, dan ukuran paket MTU maksimum.  Misalnya, jika sebuah simpul dimuat lebih dari yang lain, EIGRP akan menganalisis beban pada seluruh rute dan memilih simpul lain dengan beban yang lebih rendah. <br><br>  Dalam kursus CCNA, kami hanya akan mempertimbangkan faktor-faktor seperti pembentukan metrik seperti Bandwidth dan Delay, itulah yang akan digunakan rumus metrik. <br><br><img src="https://habrastorage.org/webt/xm/91/bd/xm91bde3pv3oqwgz7ls9dsrjs-q.jpeg"><br><br>  Protokol vektor RIP menggunakan dua konsep: jarak dan arah.  Jika kita memiliki 3 router, dan salah satunya terhubung ke jaringan 20.0.0.0, maka pilihan akan dibuat berdasarkan jarak - ini adalah harapan, dalam hal ini 1 hop, dan dalam arah, yaitu, ke arah mana - atas atau bawah - untuk mengirim lalu lintas . <br><br>  Selain itu, RIP menggunakan pembaruan informasi secara berkala, mengirimkan tabel routing lengkap ke seluruh jaringan setiap 30 detik.  Pembaruan ini menjalankan 2 fungsi.  Yang pertama adalah memperbarui tabel routing itu sendiri, dan yang kedua adalah memeriksa kelayakan tetangga.  Jika perangkat tidak menerima pembaruan tabel respons atau informasi rute baru dari tetangga dalam waktu 30 detik, ia memahami bahwa rute ke tetangga tidak lagi dapat digunakan.  Router mengirim pembaruan setiap 30 detik untuk mencari tahu apakah tetangga masih "hidup" dan apakah rute itu masih berlaku. <br><br>  Seperti yang saya katakan, teknologi Split Horizon digunakan untuk mencegah perutean loop.  Ini berarti bahwa pembaruan tidak dikirim kembali ke antarmuka dari mana asalnya.  Teknologi kedua untuk mencegah loop adalah Route Poison.  Jika koneksi ke jaringan 20.0.0.0 yang ditunjukkan dalam gambar terputus, router yang terhubung mengirimkan "rute beracun" ke tetangga, di mana ia melaporkan bahwa jaringan ini sekarang tersedia dalam 16 harapan, yaitu, praktis tidak mungkin tercapai.  Ini adalah cara kerja protokol RIP. <br><br>  Bagaimana cara kerja EIGRP?  Jika Anda ingat dari pelajaran tentang OSPF, protokol ini melakukan tiga fungsi: menetapkan lingkungan, menggunakan LSA memperbarui basis LSDB sesuai dengan perubahan dalam topologi jaringan dan membangun tabel routing.  Membangun lingkungan adalah prosedur yang agak rumit menggunakan banyak parameter.  Misalnya, memeriksa dan mengubah koneksi 2WAY - beberapa koneksi tetap dalam keadaan komunikasi dua arah, beberapa masuk ke kondisi FULL.  Tidak seperti OSPF, ini tidak terjadi dalam protokol EIGRP - hanya memeriksa 4 parameter. <br><br><img src="https://habrastorage.org/webt/gw/ty/nu/gwtynufgcwo5k3yu03vevpoor80.jpeg"><br><br>  Seperti OSPF, protokol ini mengirim pesan Hello yang berisi 10 parameter setiap 10 detik.  Yang pertama adalah kriteria otentikasi, jika telah dikonfigurasikan sebelumnya.  Dalam hal ini, semua perangkat tempat lingkungan dibuat harus memiliki parameter otentikasi yang sama. <br><br>  Parameter kedua digunakan untuk memverifikasi bahwa perangkat milik sistem otonom yang sama, yaitu, untuk membangun lingkungan menggunakan protokol EIGRP, kedua perangkat harus memiliki nomor sistem otonom yang sama.  Parameter ketiga digunakan untuk memverifikasi bahwa pesan Hello dikirim dari alamat IP yang sama dari sumber IP Sumber. <br><br>  Parameter keempat digunakan untuk memeriksa apakah koefisien variabel K-Values ​​cocok.  Protokol EIRGP menggunakan 5 koefisien tersebut dari K1 ke K5.  Jika Anda ingat, dengan nilai K = 0, parameter diabaikan, jika K = 1, maka parameter digunakan dalam rumus untuk menghitung metrik.  Dengan demikian, nilai K1-5 untuk perangkat yang berbeda harus cocok.  Dalam kursus CCNA, kita akan mengambil nilai-nilai koefisien ini secara default: K1 dan K3 adalah 1, dan K2, K4 dan K5 adalah 0. <br><br>  Jadi, jika 4 parameter ini cocok, EIGRP menjalin hubungan lingkungan, dan perangkat saling memasukkan dalam tabel tetangga.  Selanjutnya, perubahan dilakukan pada tabel topologi. <br><br><img src="https://habrastorage.org/webt/ur/jx/u8/urjxu8_hqr6xqrftq2ljn14cfne.jpeg"><br><br>  Semua pesan Hello dikirim ke alamat IP multicast 224.0.0.10, dan pembaruan, tergantung pada pengaturannya, dikirim ke alamat unicast tetangga atau ke alamat multicast.  Pembaruan ini tidak tiba melalui UDP atau TCP, tetapi menggunakan protokol berbeda yang disebut RTP, Protokol Transport yang Andal, atau Protokol Transport Keandalan.  Protokol ini memeriksa untuk melihat apakah tetangga telah menerima pembaruan, dan seperti namanya, fungsi utamanya adalah untuk memastikan komunikasi yang andal.  Jika pembaruan belum mencapai tetangga, transmisi akan diulang sampai dia menerimanya.  OSPF tidak memiliki mekanisme untuk memeriksa perangkat penerima, sehingga sistem tidak tahu apakah perangkat tetangga menerima pembaruan atau tidak. <br>  Jika Anda ingat, RIP mengirimkan pembaruan topologi jaringan lengkap setiap 30 detik.  EIGRP melakukan ini hanya jika perangkat baru muncul di jaringan atau ada perubahan yang terjadi.  Jika topologi subnet telah berubah, protokol akan mengirimkan pembaruan, tetapi bukan dari tabel topologi lengkap, tetapi hanya catatan dengan perubahan ini.  Jika sebuah subnet telah berubah, hanya topologinya yang akan diperbarui.  Sepertinya pembaruan parsial yang terjadi saat diperlukan. <br><br>  Seperti yang Anda tahu, OSPF mengirimkan LSA setiap 30 menit, terlepas dari apakah ada perubahan dalam jaringan.  EIGRP tidak akan mengirim pembaruan apa pun untuk jangka waktu yang lama sampai tidak ada perubahan dalam jaringan.  Karena itu, EIGRP jauh lebih efisien daripada OSPF. <br><br>  Setelah router bertukar paket pembaruan, tahap ketiga dimulai - pembentukan tabel routing berdasarkan metrik, yang dihitung oleh rumus yang ditunjukkan pada gambar.  Dia menghitung biaya dan, tergantung pada biaya ini, membuat keputusan. <br>  Misalkan R1 mengirim Hello ke R2, dan ia mengirim Hello ke R1.  Jika semua parameter cocok, router membuat tabel tetangga.  Dalam tabel ini, R2 menulis entri tentang router R1, dan R1 membuat entri tentang R2.  Setelah itu, router R1 mengirimkan pembaruan ke jaringan 10.1.1.0/24 yang terhubung dengannya.  Dalam tabel perutean, sepertinya informasi tentang alamat IP jaringan, antarmuka router yang menyediakan komunikasi dengannya, dan biaya rute melalui antarmuka ini.  Jika Anda ingat, biaya EIGRP adalah 90, dan kemudian nilai jarak Nilai jarak ditunjukkan, yang akan kita bicarakan nanti. <br><br><img src="https://habrastorage.org/webt/q6/bs/dz/q6bsdzvlgsua4o6e9bprevtsmgc.jpeg"><br><br>  Rumus lengkap metrik terlihat jauh lebih rumit, karena mencakup nilai koefisien K dan berbagai transformasi.  Bentuk lengkap rumus ditampilkan di situs web Cisco, tetapi jika Anda mengganti nilai default dari koefisien, itu akan dikonversi ke bentuk yang lebih sederhana - metriknya akan menjadi (bandwidth + Delay) * 256. <br><br><img src="https://habrastorage.org/webt/32/sb/yo/32sbyoy5twgtlrfmof2zhttrqwm.jpeg"><br><br>  Kami akan menggunakan bentuk rumus yang disederhanakan untuk menghitung metrik, di mana throughput dalam kilobit adalah 10 <sup>7</sup> dibagi dengan throughput paling rendah dari semua antarmuka yang mengarah ke jaringan tujuan bandwidth paling rendah, dan penundaan kumulatif adalah total keterlambatan dalam puluhan mikrodetik per semua antarmuka yang mengarah ke jaringan tujuan. <br><br>  Saat mempelajari EIGRP, kita perlu mempelajari empat definisi: Jarak Layak (jarak yang mungkin), Jarak yang Dilaporkan (jarak yang diumumkan), Penerus (router tetangga dengan biaya paling sedikit ke jaringan tujuan) dan Penentu Kelayakan (router tetangga cadangan).  Untuk memahami apa artinya, pertimbangkan topologi jaringan berikut. <br><br><img src="https://habrastorage.org/webt/ag/7f/wi/ag7fwihndh_quylewvv-mv1b3qo.jpeg"><br><br>  Kami mulai dengan membuat tabel routing R1 untuk memilih rute terbaik ke jaringan 10.1.1.0/24.  Di dekat masing-masing perangkat, bandwidth dalam kbit / s dan penundaan dalam ms ditunjukkan.  Kami menggunakan antarmuka GigabitEthernet dengan bandwidth 100 Mbps, atau 1.000.000 kbit / s, antarmuka FastEthernet dengan kecepatan 100.000 kbit / dtk, Ethernet dengan kecepatan 10.000 kbit / dtk dan antarmuka serial dengan kecepatan 1544 kbit / dtk.  Nilai-nilai ini dapat ditemukan dengan melihat karakteristik antarmuka fisik yang sesuai dalam pengaturan router. <br>  Bandwidth antarmuka Serial adalah 1544 kbit / s secara default, dan bahkan jika Anda memiliki garis 64 kbit / s, bandwidth akan tetap 1544 kbit / s.  Oleh karena itu, Anda sebagai administrator jaringan perlu memastikan bahwa Anda menggunakan nilai bandwidth yang benar.  Untuk antarmuka tertentu, dapat diatur menggunakan perintah bandwidth, dan menggunakan perintah penundaan Anda dapat mengubah nilai penundaan default.  Anda mungkin tidak perlu khawatir tentang nilai bandwidth default untuk antarmuka GigabitEthernet atau Ethernet, tetapi berhati-hatilah saat memilih kecepatan jalur jika Anda menggunakan antarmuka Serial. <br><br>  Harap dicatat bahwa dalam diagram ini, penundaan diindikasikan seolah-olah dalam milidetik ms, tetapi dalam kenyataannya itu adalah mikrodetik, saya hanya tidak memiliki huruf μ untuk penunjukan mikrodetik μs yang benar. <br><br>  Pertimbangkan dengan cermat keadaan berikut ini.  Jika Anda memasukkan perintah show g0 / 0 command, sistem akan menampilkan penundaan dalam puluhan mikrodetik, bukan hanya mikrodetik. <br><br>  Kami akan mempertimbangkan masalah ini secara terperinci dalam video berikutnya tentang konfigurasi EIGRP, untuk saat ini, ingatlah bahwa ketika mengganti nilai-nilai penundaan dalam rumus, 100 μs dari rangkaian berubah menjadi 10, karena rumus menggunakan puluhan mikrodetik, bukan unit. <br><br>  Dalam diagram, saya akan menunjuk dengan titik-titik merah antarmuka tempat throughput dan penundaan yang diperlihatkan berada. <br><br><img src="https://habrastorage.org/webt/qp/vd/rt/qpvdrtrpf-9eoiyqua17mr48euy.jpeg"><br><br>  Pertama-tama, kita perlu menentukan jarak yang memungkinkan.  Ini adalah metrik FD, yang dihitung dengan rumus.  Untuk bagian dari R5 ke jaringan eksternal, kita perlu membagi 10 <sup>7</sup> dengan 10 <sup>6</sup> , sebagai hasilnya kita mendapatkan 10. Di samping bandwidth ini kita perlu menambahkan penundaan sama dengan 1, karena kita memiliki 10 mikrodetik, yaitu, sepuluh.  Nilai 11 yang dihasilkan harus dikalikan dengan 256, yaitu, nilai metrik akan menjadi 2816. Ini adalah nilai FD untuk bagian jaringan ini. <br><br>  Router R5 akan mengirimkan nilai ini ke router R2, dan untuk R2 itu akan menjadi jarak yang dilaporkan, yaitu, nilai yang diinformasikan tetangga.  Dengan demikian, jarak RD yang dinyatakan untuk semua perangkat lain akan sama dengan jarak FD yang mungkin dari perangkat yang memberi tahu Anda tentang hal itu. <br><br>  Router R2 melakukan perhitungan FD sesuai dengan datanya, yaitu, ia membagi 10 <sup>7</sup> dengan 10 <sup>5</sup> dan mendapatkan 100. Kemudian ia menambah nilai ini jumlah keterlambatan pada rute ke jaringan eksternal: R5 delay sama dengan satu sepuluh mikrodetik dan delaynya sendiri sama dengan sepuluh puluhan .  Total keterlambatan akan menjadi 11 puluhan mikrodetik.  Tambahkan ke hasil seratus dan dapatkan 111, kalikan nilai ini dengan 256 dan dapatkan nilai FD = 28416.  Router R3 melakukan hal yang sama, setelah menghitungnya, ia mendapatkan nilai FD = 281856.  Router R4 menghitung nilai FD = 3072 dan mentransmisikannya ke R1 sebagai RD. <br><br>  Harap dicatat bahwa router R1 ketika menghitung FD tidak menggantikan bandwidth-nya 1.000.000 kbit / s dalam formula, tetapi bandwidth yang lebih rendah dari router R2, yang sama dengan 100.000 kbit / s, karena formula selalu menggunakan bandwidth minimum antarmuka yang mengarah ke jaringan tujuan .  Dalam hal ini, router R2 dan R5 berada di jalan menuju jaringan 10.1.1.0/24, tetapi karena bandwidth dari router kelima lebih besar, bandwidth terendah dari router R2 diganti ke dalam formula.  Total keterlambatan pada jalur R1-R2-R5 adalah 1 + 10 + 1 (puluhan) = 12, throughput yang berkurang adalah 100, dan jumlah angka-angka ini dikalikan 256 akan memberikan nilai FD = 30976. <br><br>  Jadi, semua perangkat telah menghitung FD dari antarmuka mereka, dan router R1 memiliki 3 rute yang mengarah ke jaringan tujuan.  Ini adalah rute R1-R2, R1-R3 dan R1-R4.  Router memilih jarak minimum yang mungkin FD, yang sama dengan 30.976 - ini adalah rute ke router R2.  Router ini menjadi Penerus, atau "penerus."  Tabel perutean juga menunjukkan penerus yang layak (penerus cadangan) - itu berarti bahwa dalam hal terjadi pemutusan antara R1 dan penerus, rute akan melalui router cadangan Penerus yang layak. <br><br> Feasible Successors    :   RD     ,  FD     Successor'.    R1-R2  FD=30976, RD   R1-R3  281856,  RD   R1-R4  3072.   3072 &lt; 30976,   Feasible Successors   R4. <br><br>  ,        R1-R2    10.1.1.0/24     R1-R4-R5.     RIP    ,   OSPF –  ,   EIGRP  .       EIGRP      . <br><br>  ,      Successor  Feasible Successor?    EIGRP   DUAL,        .     ,    EIGRP   ,      ,       .         . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/b1aHb7VtMvs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Terima kasih telah tinggal bersama kami.  Apakah Anda suka artikel kami?  Ingin melihat materi yang lebih menarik?  Dukung kami dengan melakukan pemesanan atau merekomendasikannya kepada teman-teman Anda, <b>diskon 30% untuk pengguna Habr pada analog unik dari server entry-level yang kami buat untuk Anda:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Seluruh kebenaran tentang VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps dari $ 20 atau bagaimana membagi server?</a>  (opsi tersedia dengan RAID1 dan RAID10, hingga 24 core dan hingga 40GB DDR4). <br><br>  <b>Dell R730xd 2 kali lebih murah?</b>  Hanya kami yang memiliki <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2 x Intel TetraDeca-Core Xeon 2x E5-2697v3 2.6GHz 14C 64GB DDR4 4x960GB SSD 1Gbps 100 TV dari $ 199</a> di Belanda!</b>  <b><b>Dell R420 - 2x E5-2430 2.2Ghz 6C 128GB DDR3 2x960GB SSD 1Gbps 100TB - mulai dari $ 99!</b></b>  Baca tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara Membangun Infrastruktur Bldg.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kelas menggunakan server Dell R730xd E5-2650 v4 seharga 9.000 euro untuk satu sen?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id466679/">https://habr.com/ru/post/id466679/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id466669/index.html">Tesla mengembangkan baterai yang mampu berjalan 1,6 juta km tanpa penggantian</a></li>
<li><a href="../id466671/index.html">PHP Digest No. 164 (27 Agustus - 9 September 2019)</a></li>
<li><a href="../id466673/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari 46. Pemeriksaan Kinerja OSPF</a></li>
<li><a href="../id466675/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari ke 47. Pemecahan Masalah OSPF</a></li>
<li><a href="../id466677/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari ke 48. OSPF Multizone</a></li>
<li><a href="../id466681/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari 50. Mengkonfigurasi EIGRP</a></li>
<li><a href="../id466683/index.html">Acara digital di Moskow 9-15 September</a></li>
<li><a href="../id466685/index.html">Melihat uang</a></li>
<li><a href="../id466689/index.html">Cara membuat kelas karakter di MMO Action seluler</a></li>
<li><a href="../id466691/index.html">Jadi semua RAML atau OAS (Swagger) yang sama?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>