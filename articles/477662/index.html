<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïó ‚òØÔ∏è ‚ÜóÔ∏è Acceso a neum√°ticos Redd en puentes FTDI üö≥ ü§û üê•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hemos completado un gran bloque te√≥rico que muestra c√≥mo construir un subsistema FPGA para el complejo Redd; c√≥mo organizar la comunicaci√≥n entre el F...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Acceso a neum√°ticos Redd en puentes FTDI</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477662/">  Hemos completado un gran bloque te√≥rico que muestra c√≥mo construir un subsistema FPGA para el complejo Redd;  c√≥mo organizar la comunicaci√≥n entre el FPGA y el procesador central del complejo;  lo f√°cil que es guardar flujos de datos de alta velocidad en la RAM, que est√° directamente conectada a la FPGA, para su posterior transferencia pausada al procesador central (o viceversa, para poner datos en esta RAM para su posterior salida r√°pida al canal).  Revisamos las t√©cnicas de rastreo del procesador Nios II.  Podemos optimizar el rendimiento del sistema del procesador basado en Nios II para que el trabajo sea lo m√°s eficiente posible.  En general, hemos estudiado toda la teor√≠a m√≠nima necesaria, y ser√≠a hora de pasar a la pr√°ctica dise√±ando un dispositivo no muy complejo, pero pr√°cticamente √∫til ... Pero hay un PERO. <br><br>  Por los comentarios sobre los art√≠culos, not√© que algunos lectores creen que Redd y FPGA son como Lenin y el Partido.  Que est√°n inextricablemente unidos.  De hecho, esto no es as√≠ en absoluto.  Solo quer√≠a comenzar una conversaci√≥n sobre el complejo Redd con algo interesante, pero ¬øqu√© podr√≠a ser m√°s interesante que FPGA?  Bueno, y comenzar una conversaci√≥n, interrumpir media palabra es est√∫pido.  Y finalmente, el gran bloque l√≥gico est√° completo.  Y para mostrar que los FPGA est√°n lejos de todo Redd, propongo hacer aproximadamente tres art√≠culos sobre cosas que no est√°n relacionadas con ellos.  Bueno, y despu√©s de completar este bloque, ya vaya a la pr√°ctica de FPGA. <br><br><img src="https://habrastorage.org/webt/nu/nw/7p/nunw7p7f7c5hcnmlsv7haliroz8.png"><br><a name="habracut"></a><br><h2>  Introduccion </h2><br>  Lo m√°s sorprendente es que tan pronto como decid√≠ hacer una digresi√≥n sobre otros temas, los buenos jefes me lanzaron a una batalla dif√≠cil en un proyecto donde se est√° trabajando con el lenguaje VHDL y Xilinx FPGA.  En primer lugar, es por eso que durante mucho tiempo no tom√© un bol√≠grafo en general, y en segundo lugar, est√° claro que la preparaci√≥n de art√≠culos pr√°cticos requiere una gran cantidad de experimentos.  Es algo dif√≠cil lidiar con VHDL / Verilog y Xilinx / Altera al mismo tiempo.  Por lo tanto, un descanso en las historias sobre FPGAs tendr√≠a que hacerse de todos modos. <br><br>  Entonces  En el <a href="https://habr.com/ru/post/452656/">primer art√≠culo de la serie,</a> ya examinamos el diagrama estructural del complejo Redd.  Hag√°moslo una vez m√°s. <br><br><img src="https://habrastorage.org/webt/vf/hv/da/vfhvda1kmsax-zkxaue4xu_ysmk.png"><br><br>  En el art√≠culo de hoy, es poco probable que los expertos en Linux encuentren mucha informaci√≥n valiosa, pero vale la pena repasar las im√°genes superficialmente.  Aquellos que, como yo, est√°n acostumbrados a trabajar desde Windows, encontrar√°n una lista de t√©cnicas listas para usar que le permiten trabajar con el complejo.  En general, este art√≠culo traer√° las habilidades de esos y otros grupos de lectores a un denominador com√∫n. <br><br><div class="spoiler">  <b class="spoiler_title">Art√≠culos anteriores del ciclo</b> <div class="spoiler_text"><ol><li>  <a href="https://habr.com/ru/post/452656/">Desarrollo del "firmware" m√°s simple para FPGAs instalados en Redd, y depuraci√≥n utilizando la prueba de memoria como ejemplo.</a> </li><li>  <a href="https://habr.com/ru/post/453682/">Desarrollo del "firmware" m√°s simple para FPGAs instalados en Redd.</a>  <a href="https://habr.com/ru/post/453682/">Parte 2. C√≥digo del programa.</a> </li><li>  <a href="https://habr.com/ru/post/454938/">Desarrollo de su propio n√∫cleo para incrustar en un sistema de procesador basado en FPGA.</a> </li><li>  <a href="https://habr.com/ru/post/456008/">Desarrollo de programas para el procesador central Redd sobre el ejemplo de acceso a la FPGA.</a> </li><li>  <a href="https://habr.com/ru/post/462253/">Los primeros experimentos utilizando el protocolo de transmisi√≥n en el ejemplo de la CPU y la comunicaci√≥n del procesador en el FPGA Redd.</a> </li><li>  <a href="https://habr.com/ru/post/464795/">Merry Quartusel, o c√≥mo el procesador ha llegado a tal vida.</a> </li><li>  <a href="https://habr.com/ru/post/467353/">M√©todos de optimizaci√≥n de c√≥digo para Redd.</a>  <a href="https://habr.com/ru/post/467353/">Parte 1: efecto cach√©.</a> </li><li>  <a href="https://habr.com/ru/post/468027/">M√©todos de optimizaci√≥n de c√≥digo para Redd.</a>  <a href="https://habr.com/ru/post/468027/">Parte 2: memoria no almacenada en cach√© y operaci√≥n de bus paralelo.</a> </li><li>  <a href="https://habr.com/ru/post/469985/">Amplia optimizaci√≥n de c√≥digo: reemplazar un generador de reloj para mejorar el rendimiento del sistema.</a> </li></ol><br></div></div><br><h2>  Bloques UART (puertos serie) </h2><br>  En el diagrama de bloques, vemos el controlador FT4232 que implementa 4 puertos seriales (UART): <br><br><img src="https://habrastorage.org/webt/75/bh/hy/75bhhyfnu_19uedfnkc7bzyrido.png"><br><br>  Pero si habla un poco m√°s globalmente, entonces el complejo Redd no tiene cuatro, sino seis puertos seriales.  Acabo de mencionar que cuatro tienen niveles de CMOS, y dos m√°s est√°n soldados en la placa base, porque el complejo se basa en una PC com√∫n. <br><br><img src="https://habrastorage.org/webt/14/vj/pl/14vjplsdplqalj4lcm-4g4nmnvg.png"><br><br>  En consecuencia, tienen niveles: RS232 (m√°s o menos 12 voltios).  Puertos RS232: todo est√° claro con ellos, se muestran en forma de dos conectores DB-9 est√°ndar, <br><br><img src="https://habrastorage.org/webt/xk/d0/h6/xkd0h6xvaxlz7gxl8v-r4t9n8de.png"><br><br>  ¬øY d√≥nde buscar l√≠neas con niveles CMOS?  En general, en un conector com√∫n.  Su pinout se muestra en el diagrama del circuito el√©ctrico.  Hay, entre otras cosas, contactos correspondientes a UART. <br><br><img src="https://habrastorage.org/webt/nm/pv/cr/nmpvcraxowuy0oea7wkin1aqulu.png"><br><br>  Externamente, este conector tiene el siguiente aspecto: <br><br><img src="https://habrastorage.org/webt/mf/qa/8h/mfqa8hkbar6y7u8shn39eiend2a.png"><br><br>  C√≥mo usarlo depende de la tarea.  Puede hacer un arn√©s para conectar cada dispositivo.  Este enfoque es √∫til si alguien usa el complejo Redd para probar peri√≥dicamente dispositivos fabricados del mismo tipo.  Pero el objetivo principal del complejo sigue siendo depurar el equipo que se est√° desarrollando.  Y en este caso, es m√°s f√°cil conectarse temporalmente.  Este patr√≥n temporal es visible en los protectores de pantalla para todos los art√≠culos: los cables de Aruino se insertan directamente en el conector.  Por supuesto, contar los contactos sigue siendo un placer, y si accidentalmente salen volando, es tan dif√≠cil restaurar la conmutaci√≥n que es m√°s f√°cil volver a conectar todo desde cero;  por lo tanto, para facilitar la vida, hay una placa elevadora a la que puede conectarse al menos con la ayuda de conectores de dos filas, al menos con el mismo cableado Arduino. <br><br><img src="https://habrastorage.org/webt/rb/we/66/rbwe66z9f5eahs3efqpxq93di6e.png"><br><br><h2>  Acceso al software UART </h2><br>  El puerto serie es un elemento bien establecido y bien estandarizado, por lo tanto, trabajar con √©l no pasa por algunas bibliotecas FTDI espec√≠ficas, sino por medios est√°ndar.  Veamos c√≥mo se ven estas herramientas en Linux. <br><br><h4>  Nombres de puerto </h4><br>  De una serie de art√≠culos y foros en la red, se deduce que los nombres de puerto proporcionados por los adaptadores de serie USB est√°n en el formato / dev / ttyUSB0, / dev / ttyUSB1, y as√≠ sucesivamente.  En Linux, todos los dispositivos se pueden ver usando los mismos comandos que para ver directorios comunes (de hecho, los dispositivos son los mismos archivos).  Veamos qu√© nombres hay en nuestro sistema.  Le damos el comando: <br>  <b>ls / dev /</b> <br><br><img src="https://habrastorage.org/webt/dj/ho/4g/djho4ghfwyceuqy6fjzezh3gyo8.png"><br><br>  Los nombres que nos interesan est√°n resaltados en rojo.  Algo muchos de ellos.  ¬øQu√© puerto corresponde a qu√©?  Aquellos que est√°n bien versados ‚Äã‚Äãen Linux conocen miles de hechizos para todas las ocasiones.  Pero para aquellos que todav√≠a trabajaban con Windows 3.1 (bueno, en paralelo con la anciana RT-11), todav√≠a es dif√≠cil de recordar, con la edad el nuevo es m√°s dif√≠cil de recordar.  Por lo tanto, es m√°s f√°cil encontrar todo cada vez, usando formas simples.  Y destaqu√© la entrada a este camino simple con un marco verde.  Subdirectorio condicional serial.  Ahora estamos mirando el <b>/ dev /</b> namespace.  Y veamos el espacio <b>/ dev / serial</b> : <br><br><img src="https://habrastorage.org/webt/kw/fc/31/kwfc3189zwxl3ut80xwehvplt70.png"><br><br>  Genial  Nos adentramos en la jerarqu√≠a, miramos el espacio <b>/ dev / serial / by-id</b> .  Solo mirando hacia el futuro, dir√© que para la visualizaci√≥n correcta debe usar el <b>comando ls</b> con el interruptor <b>‚Äìl</b> (gracias a mi jefe por la aclaraci√≥n).  Es decir, le damos el comando: <br>  <b>ls ‚Äìl / dev / serial / by-id</b> <br><br><img src="https://habrastorage.org/webt/qq/vl/vd/qqvlvdgcgak3c5cembrbmj4myue.png"><br><br>  Por un lado, todo est√° bien.  Ahora sabemos qu√© nombres en el espacio <b>/ dev / ttyUSBX</b> corresponden a qu√© dispositivo.  En particular, los puertos organizados por el puente FT4232 (Quad) tienen nombres de <b>ttyUSB3</b> a <b>ttyUSB6</b> .  Pero por otro lado, al considerar este sitio, me di cuenta de que en Par√≠s, en la c√°mara de pesas y medidas, necesariamente debe haber una habitaci√≥n en la que se coloque el est√°ndar del desorden ... Porque de alguna manera necesitas poder medir su valor.  Bueno, digamos que la falta de puertos <b>/ dev / ttyUSB0</b> y <b>/ dev / ttyUSB1</b> puede explicarse f√°cilmente.  Pero, ¬øc√≥mo explicar que los puertos "nativos" basados ‚Äã‚Äãen la descendencia del puente FTDI instalado est√°n numerados entre los tres primeros y que el controlador prol√≠fico de terceros, insertado para un proyecto espec√≠fico, tom√≥ el puerto n√∫mero 2?  ¬øC√≥mo se puede trabajar en un entorno as√≠?  Ma√±ana alguien conectar√° otro controlador al complejo (ya que el complejo permite que diferentes grupos de desarrolladores trabajen con diferentes equipos al mismo tiempo), y los puertos se retiran nuevamente.  ¬øQu√© puertos necesitamos registrar en el archivo de configuraci√≥n para una aplicaci√≥n que funcione? <br><br>  Resulta que no todo es tan malo.  En primer lugar, el nombre amarillo <b>/ dev / ttyUSB3</b> y el nombre azul <b>/ dev / serial / by-id / usb-FTDI_Quad_RS232-HS-if00-port0</b> son dos alias del mismo dispositivo.  Y la segunda opci√≥n tambi√©n se puede presentar como el nombre del puerto, pero ya es m√°s permanente que la primera.  Es cierto, en este caso, todo es algo malo.  Se puede conectar un controlador externo basado en FT4232 en el complejo, y ya ser√° necesario ocuparse de su numeraci√≥n.  Y aqu√≠ "en segundo lugar" viene en nuestra ayuda.  A saber, otra convenci√≥n de nomenclatura alternativa.  Recordamos que el directorio <b>/ dev / serial</b> conten√≠a no solo el subdirectorio <b>/ by-id</b> , sino tambi√©n el subdirectorio <b>/ by-path</b> .  Verificamos su contenido (se encuentra en la parte inferior de la siguiente figura, debajo de una l√≠nea roja). <br><br><img src="https://habrastorage.org/webt/y1/mm/xa/y1mmxabnvjburuzedzirgzusjbm.png"><br><br>  Todo aqu√≠ est√° vinculado a la arquitectura f√≠sica.  Y ya he dicho muchas veces que todos los controladores dentro del complejo est√°n soldados a las placas, por lo que la jerarqu√≠a interna no cambiar√°.  Por lo tanto, el nombre <b>/dev/serial/by-path/pci-0000:00:15.0-usb-0:6.5:1.0-port0</b> ser√° el m√°s dif√≠cil. <br><br>  En total, tenemos la siguiente forma de buscar el nombre del puerto (debe hacerse una vez, los resultados para su instancia del complejo se pueden poner en la tabla y usar constantemente): <br><br><ol><li>  Emita el comando <b>ls ‚Äìl / dev / serial / by-id</b> . </li><li>  Emita el <b>comando ls ‚Äìl / dev / serial / by-path</b> . </li><li>  A partir de los resultados del punto 1, busque el nombre del puerto correspondiente al puerto requerido del puente requerido.  Encuentre el mismo nombre de puerto en los resultados del p√°rrafo 2. Tome el nombre f√≠sico correspondiente a este p√°rrafo. </li></ol><br>  Para los puertos atendidos por el controlador en la placa base, todo es un poco m√°s complicado.  Aqu√≠ no puedes hacer el camino desde el comando m√°s simple " <b>ls / dev</b> ", pero debes recordar algo (bueno, o al menos recuerda que puedes contactar aqu√≠ para obtener ayuda).  En todas partes dice que los nombres de puerto t√≠picos son <b>ttyS0-ttyS3</b> .  La pregunta sigue siendo, ¬øen qu√© nombres son los puertos reales en nuestro sistema?  Encontr√© el siguiente hechizo respondiendo esta pregunta: <br>  <b>ls / sys / class / tty / * / device / driver</b> <br><br>  Aqu√≠ est√° la respuesta del sistema: <br><br><img src="https://habrastorage.org/webt/oc/gi/v7/ocgiv7g8ffmcmzr_bfypwrn__6g.png"><br><br>  Resulta que necesitamos usar los nombres <b>/ dev / ttyS2</b> y <b>/ dev / ttyS3</b> .  ¬øPor qu√©? No lo s√©.  Pero una cosa agrada: aqu√≠ no se prev√©n cambios especiales, por lo tanto, estas constantes pueden recordarse y usarse sin temor a que cambien. <br><br><h4>  Desarrollo de c√≥digo </h4><br>  Al desarrollar, debe usar la maravillosa <b>Gu√≠a de programaci√≥n en serie para sistemas operativos POSIX</b> (el primer enlace directo que obtiene es <a href="https://www.cmrr.umn.edu/~strupp/serial.html" rel="nofollow">https://www.cmrr.umn.edu/~strupp/serial.html</a> , pero nadie sabe cu√°nto tiempo durar√°).  Es especialmente importante que indique c√≥mo trabajar con un conjunto completo de se√±ales, porque los puertos en el complejo est√°n completamente implementados.  Es cierto que hoy usaremos solo las l√≠neas Tx y Rx. <br><br>  Por lo general, doy los resultados de la forma de onda, pero ahora resulta que estoy en condiciones casi reales: el complejo est√° ubicado donde mis manos no pueden alcanzar, por lo que no puedo conectar la sonda del osciloscopio.  Para ver al menos alg√∫n resultado, a petici√≥n m√≠a, los colegas agregaron un par de publicaciones al complejo de acuerdo con el siguiente esquema cl√°sico: <br><br><img src="https://habrastorage.org/webt/4k/it/be/4kitbevmwnyxbllumfdz0qzr2a0.png"><br><br>  Intentemos transferir de un puerto a otro.  En nuestro caso, los puertos <b>/dev/serial/by-path/pci-0000:00:15.0-usb-0:6.5:1.2-port0</b> y <b>/dev/serial/by-path/pci-0000:00:15.0- est√°n conectados usb-0: 6.5: 1.3-port0</b> . <br><br>  Ya discutimos c√≥mo se escriben los programas para el procesador central de Redd en uno de los <a href="https://habr.com/ru/post/456008/">art√≠culos anteriores</a> , por lo que hoy nos limitaremos solo al texto del programa escrito bajo la impresi√≥n del documento <b>Gu√≠a de programaci√≥n en serie para sistemas operativos POSIX</b> .  En realidad, el principal punto interesante es cambiar la estrategia de recepci√≥n a la lectura sin bloqueo, el resto es trivial.  Sin embargo, dado el desorden en los ejemplos en la red sobre este tema, es mejor tener una muestra trivial a mano (ver√° m√°s adelante que incluso un ejemplo basado en este maravilloso documento no funcion√≥ al 100%, el c√≥digo a continuaci√≥n difiere de los c√°nones descritos en √©l en una l√≠nea, pero m√°s sobre eso a continuaci√≥n). <br><br><div class="spoiler">  <b class="spoiler_title">El mismo c√≥digo de muestra</b> <div class="spoiler_text"><pre><code class="plaintext hljs">#include &lt;cstdio&gt; #include &lt;unistd.h&gt; /* UNIX standard function definitions */ #include &lt;fcntl.h&gt; /* File control definitions */ #include &lt;errno.h&gt; /* Error number definitions */ #include &lt;termios.h&gt; /* POSIX terminal control definitions */ int OpenUART(const char* portName, speed_t baudRate) { //   int fd = open(portName, O_RDWR | O_NOCTTY | O_NDELAY); //     if (fd == -1) { return fd; } //     fcntl(fd, F_SETFL, FNDELAY); //    termios options; tcgetattr(fd, &amp;options); // ,       // ,   .  ... cfsetspeed(&amp;options, baudRate); //    ... // 1  ,   , 8    options.c_cflag &amp;= ~PARENB; options.c_cflag &amp;= ~CSTOPB; options.c_cflag &amp;= ~CSIZE; options.c_cflag |= CS8; options.c_cflag |= (CLOCAL | CREAD); // , ... tcsetattr(fd, TCSANOW, &amp;options); return fd; } int main() { printf("hello from ReddUARTTest!\n"); int fd1 = OpenUART("/dev/serial/by-path/pci-0000:00:15.0-usb-0:6.5:1.3-port0", 9600); int fd2 = OpenUART("/dev/serial/by-path/pci-0000:00:15.0-usb-0:6.5:1.2-port0", 9600); if ((fd1 != -1) &amp;&amp; (fd2 != -1)) { static const unsigned char dataForSend[] = {0xff,0xfe,0xfd,0xfb}; //      write(fd1, dataForSend, sizeof(dataForSend)); unsigned char dataForReceive[128]; ssize_t cnt = 0; //     ,  , //         int readSteps = 0; //      ,   while (cnt &lt; (ssize_t)sizeof(dataForSend)) { readSteps += 1; ssize_t rd = read(fd2, dataForReceive + cnt, sizeof(dataForReceive) - cnt); //   - ,     if (rd &lt;= 0) { usleep(1000); } else //  -   { cnt += rd; } } //   printf("%d read operations\n", readSteps); printf("Read Data: "); for (unsigned int i = 0; i &lt; cnt; i++) { printf("%X ", dataForReceive[i]); } printf("\n"); } else { printf("Error with any port open!\n"); } //   if (fd1 != -1) { close(fd1); } if (fd2 != -1) { close(fd2); } return 0; }</code> </pre> <br></div></div><br>  Ejecutar: obtenemos el resultado previsto: <br><br><pre> <code class="plaintext hljs">hello from ReddUARTTest! 14 read operations Read Data: FF FE FD FB</code> </pre><br>  Se puede ver que 4 bytes ocuparon 14 intentos, es decir, la lectura no estaba bloqueando.  A veces, el sistema devolvi√≥ un estado de "no hay datos nuevos" y el programa se suspendi√≥ durante un milisegundo. <br><br>  En general, todo est√° bien, pero sin un osciloscopio no puedo estar seguro de que dos puertos basados ‚Äã‚Äãen el mismo chip realmente establezcan la velocidad.  Ya salt√© sobre el hecho de que la velocidad era la misma (para eso ten√≠a un controlador), pero no el que orden√©.  Al menos, verifiquemos que al menos est√© controlado.  Para hacer esto, establecer√© la velocidad del puerto de recepci√≥n para duplicar la del puerto de transmisi√≥n.  Y conociendo la f√≠sica del proceso de transferencia de datos, puede predecir c√≥mo se distorsionan estos datos durante la recepci√≥n.  Veamos la transferencia del byte 0xff en forma gr√°fica.  S - bit de inicio (siempre hay cero), P - bit de parada (siempre hay uno), 0-7 - bits de datos (para la constante 0xFF - todas las unidades). <br><br><img src="https://habrastorage.org/webt/kx/0p/cz/kx0pczh7nor5fcn1nhkor8nrwum.png"><br><br>  Ahora superpongamos esta vista con una vista de c√≥mo todo ser√° visto por un receptor que opera al doble de la velocidad: <br><br><img src="https://habrastorage.org/webt/mp/n7/qn/mpn7qngefktxruxtyrex7ykrpwk.png"><br><br>  Genial  Debe aceptarse el valor "1111 1110" (los datos van al bit menos significativo hacia adelante), es decir, 0xFE.  La segunda mitad del valor transmitido no afecta la recepci√≥n, ya que las unidades corresponden al silencio en la l√≠nea.  Es decir, transmitimos un byte, un byte tambi√©n vendr√°. <br><br>  Construiremos el mismo gr√°fico para la verificaci√≥n, que corresponder√° al valor 0xFE transmitido: <br><br><img src="https://habrastorage.org/webt/do/e6/x2/doe6x2t9aapieqiat4gtkp9j8_y.png"><br><br>  Espere el valor "1111 1000" o 0xF8.  Bueno, verifiquemos qu√© esperar con el valor pasado 0xFD: <br><br><img src="https://habrastorage.org/webt/c9/er/d0/c9erd0bsjla_b5bkwpmmzbqnrlm.png"><br><br>  Obtenemos el valor 0xE6.  Bueno, para el valor transmitido 0xFB obtenemos el 0x9E recibido (puede trazar el gr√°fico y verlo usted mismo).  Genial  Cambiamos una sola l√≠nea en la aplicaci√≥n de prueba, reemplazando la velocidad de 9600 con 19200: <br><br><pre> <code class="plaintext hljs"> int fd2 = OpenUART("/dev/serial/by-path/pci-0000:00:15.0-usb-0:6.5:1.2-port0", 19200);</code> </pre><br>  Comenzamos y obtenemos este resultado del trabajo: <br><br><pre> <code class="plaintext hljs">hello from ReddUARTTest! 9 read operations Read Data: FE F8 E6 9E</code> </pre><br>  Por cierto, no hice en vano este control.  Al principio, utilic√© otras funciones de configuraci√≥n de velocidad (par cfsetispeed / cfsetospeed), ¬°y no funcionaron!  Gracias a esta prueba, el problema se identific√≥ y resolvi√≥ a tiempo.  Cuando trabajas con equipos, nunca puedes confiar en la intuici√≥n.  ¬°Todo debe ser revisado! <br><br><h4>  Administraci√≥n de l√≠nea de alimentaci√≥n 220 voltios </h4><br>  En general, las l√≠neas el√©ctricas de 220 voltios no est√°n relacionadas con el tema del art√≠culo (puentes FTDI), pero s√≠ est√°n relacionadas con el tema de esta secci√≥n (puertos seriales).  Echemos un vistazo r√°pido a ellos. <br><br><img src="https://habrastorage.org/webt/fj/py/1f/fjpy1fqzjfykydgxo28fctebh1c.png"><br><br>  Cuando enumeramos los puertos, vimos este nombre: <br><br><img src="https://habrastorage.org/webt/rt/0g/k7/rt0gk7ammjno5n1hgfh5waz85ri.png"><br><br>  Este es un puerto serie virtual.  Es tan virtual que no importa qu√© par√°metros tenga (velocidad de puerto, n√∫mero de bits, formato de paridad, etc.).  Independientemente de los par√°metros que haya configurado, a√∫n podr√° manejar comandos perfectamente.  Y son estos equipos los que controlan las tomas de corriente en el complejo. <br><br><img src="https://habrastorage.org/webt/yc/ry/sk/ycryskkv2xpfkxnex41xbn5pooo.png"><br><br>  Al desarrollar el sistema de comando, se decidi√≥ abandonar las interfaces de comando complejas.  La administraci√≥n toma un byte, sin enmarcar cadenas y otros adornos, aunque el byte es textual (de modo que se pueda transferir convenientemente desde el terminal al depurar).  Esta concisi√≥n se explica f√°cilmente: la interfaz de cadena le permite lidiar con la interferencia en un canal UART inseguro.  Pero en nuestro caso, f√≠sicamente, el trabajo pasa por el canal USB, que est√° protegido por c√≥digos de control c√≠clicos.  El procesamiento del flujo de retorno requiere escribir c√≥digo adicional o vaciar constantemente los b√∫feres, lo que no siempre es conveniente.  Es por eso que no hay puntos de referencia para las cadenas, no hay respuestas.  Se cree que el canal es estable.  Si desea una respuesta, puede solicitarla expl√≠citamente.  Es decir, el rendimiento del bloque siempre se puede verificar f√°cilmente enviando un byte adicional despu√©s del comando. <br><br>  Considere los comandos que se pueden enviar: <br><div class="scrollable-table"><table><tbody><tr><th>  El equipo </th><th>  Cita </th></tr><tr><td>  'A' </td><td>  Enciende la primera salida </td></tr><tr><td>  'a' </td><td>  Apague la primera salida </td></tr><tr><td>  'B' </td><td>  Enciende la segunda salida </td></tr><tr><td>  'b' </td><td>  Apague la segunda salida </td></tr><tr><td>  'C' </td><td>  Encienda la tercera salida (si hay) </td></tr><tr><td>  'c' </td><td>  Apague la tercera salida (si la hay) </td></tr><tr><td>  '?' </td><td>  Restaurar estado de salida </td></tr></tbody></table></div><br>  El comando '?'  (signo de interrogaci√≥n) es el √∫nico que devuelve una respuesta.  En respuesta a esto, siempre vienen 3 bytes, cada uno de los cuales corresponde al estado de una de las salidas.  En realidad, los estados corresponden a los comandos.  Por ejemplo, 'abc': las tres salidas ahora est√°n apagadas, 'Abc': la primera est√° encendida, la segunda y la tercera est√°n apagadas, etc. <br><br>  Para los experimentos con este subsistema, sugiero no escribir un programa especial (no es diferente del que se dio anteriormente, solo los datos enviados a los puertos ser√°n diferentes), sino usar las herramientas del sistema operativo y jugar interactivamente con sockets. <br><br>  Despu√©s de muchos experimentos con el seguimiento del puerto a trav√©s del comando cat y el env√≠o de comandos en una ventana paralela usando el programa echo, me di cuenta de que por alguna raz√≥n no pod√≠a lograr resultados en un par de terminales ssh basadas en masilla (incluso jugando con esos puertos con los que solo que experiment√≥ perfectamente con su programa).  Por lo tanto, tuve que instalar el programa minicom est√°ndar.  D√©jame recordarte el comando de instalaci√≥n: <br>  <b>sudo apt-get minicom</b> <br><br>  A continuaci√≥n, ejec√∫telo con el comando: <br>  <b>minicom ‚ÄìD / dev / ttyACM0</b> <br><br>  El nombre del puerto es corto, porque con los experimentos manuales es m√°s f√°cil ingresarlo.  En el trabajo de software, como siempre, es mejor usar un nombre que est√© vinculado a la jerarqu√≠a de hardware.  Una vez m√°s, noto que no configuro ning√∫n otro par√°metro de puerto porque es virtual.  Funcionar√° con cualquier configuraci√≥n. <br><br>  Luego presionamos el signo de interrogaci√≥n en el terminal e instant√°neamente (sin avance de l√≠nea) obtenemos una respuesta <br><br><img src="https://habrastorage.org/webt/41/my/-j/41my-jjk9cffmmflot_zk_ph0ck.png"><br><br>  Esto significa que todas las salidas est√°n actualmente apagadas.  Digamos que queremos encender la segunda salida.  Presione la 'B' may√∫scula.  No hay reacci√≥n en la pantalla.  Presione '?' Nuevamente, obtenemos una nueva l√≠nea con la respuesta: <br><br><img src="https://habrastorage.org/webt/5i/uz/-r/5iuz-rrjfbmier5bfmazwx1svb0.png"><br><br>  Todo funciona  No olvide apagar 220 voltios (comando 'b').  Puede salir del terminal presionando sucesivamente ctrl + A, luego X. El experimento ha finalizado. <br><br><h2>  Neum√°ticos SPI y I <sup>2</sup> C </h2><br>  Los buses SPI (que tambi√©n pueden funcionar en modo Quad-SPI) y I <sup>2</sup> C se implementan en combinaci√≥n con puentes universales.  Es decir, en general, el complejo tiene dos puentes, cada uno de los cuales se puede encender en modo SPI o en I <sup>2</sup> C. En el diagrama estructural, la secci√≥n correspondiente se ve as√≠: <br><br><img src="https://habrastorage.org/webt/uy/lp/6k/uylp6kc6vcqjrlwluk5nxzpcezc.png"><br><br>  La esencia de encender los autobuses finales es visible desde el diagrama del circuito el√©ctrico.  Considere solo uno de los dos controladores: <br><br><img src="https://habrastorage.org/webt/ah/rj/ah/ahrjahvujglcs3uoxl-wsdxfcpy.png"><br><br>  Por lo tanto, los autobuses SPI e I <sup>2</sup> C no se cruzan de ninguna manera.  Las restricciones en su uso conjunto est√°n determinadas solo por las restricciones impuestas por FTDI en el controlador FT4222H.  Desafortunadamente, la documentaci√≥n establece que solo una interfaz puede estar activa a la vez: <br><br><img src="https://habrastorage.org/webt/zc/7d/dw/zc7ddwfm-tstpt9lumoydqexceu.png"><br><br>  C√≥mo gestionar las l√≠neas CFG1_0..CFG1_1 y CFG2_0..CFG2_1, nos encontraremos en el pr√≥ximo art√≠culo.  Ahora creemos que todos est√°n anulados. <br><br>  En general, el trabajo con el controlador est√° muy bien descrito en el documento <b>FT4222H USB2.0 TO QUADSPI / I2C BRIDGE IC</b> , por lo tanto, no consideraremos las caracter√≠sticas de los modos de operaci√≥n de los controladores.  Todo est√° muy claro en el documento mencionado. <br><br>  En cuanto al soporte de software, su descripci√≥n se puede encontrar en el documento no menos notable <b>AN_329 Gu√≠a del usuario para LibFT4222</b> .  Ya hemos trabajado dos veces con el puente FTDI: en la segunda mitad de <a href="https://habr.com/ru/post/456008/">este art√≠culo</a> y en la segunda mitad de <a href="https://habr.com/ru/post/462253/">este</a> .  Por lo tanto, al comparar este documento con estos art√≠culos, puede resolverlo r√°pidamente y comenzar a escribir su propio c√≥digo.  Perm√≠tanme mostrarles el c√≥digo de referencia que env√≠a datos al bus SPI, sin detenerse en los detalles de su implementaci√≥n, parece dolorosamente que ya se ha analizado con FT2232. <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo que env√≠a datos al bus SPI.</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include "../ftd2xx/ftd2xx.h" #include "../LibFT4222/inc/LibFT4222.h" void SpiTest (int pos) { FT_HANDLE ftHandle = NULL; FT_STATUS ftStatus; FT4222_STATUS ft4222Status; //   ftStatus = FT_Open(pos, &amp;ftHandle); if (FT_OK != ftStatus) { // open failed printf ("error: Cannot Open FTDI Device\n"); return; } ft4222Status = FT4222_SPIMaster_Init(ftHandle, SPI_IO_SINGLE, CLK_DIV_4, CLK_IDLE_LOW, CLK_LEADING, 0x01); if (FT4222_OK != ft4222Status) { printf ("error: Cannot switch to SPI Master Mode\n"); // spi master init failed return; } uint8 wrBuf [] = {0x9f,0xff,0xff,0xff,0xff,0xff,0xff}; uint8 rdBuf [sizeof (wrBuf)]; uint16 dwRead; ft4222Status = FT4222_SPIMaster_SingleReadWrite (ftHandle,rdBuf,wrBuf,sizeof (wrBuf),&amp;dwRead,TRUE); if (FT4222_OK != ft4222Status) { printf ("error: Error on ReadWrite\n"); } else { printf ("received: "); for (int i=0;i&lt;6;i++) { printf ("0x%X ",rdBuf[i]); } printf ("\n"); } FT4222_UnInitialize(ftHandle); FT_Close(ftHandle); }</code> </pre><br></div></div><br><h4>  Piezas de bus SPI </h4><br>  Los desarrolladores de c√≥digo para microcontroladores a menudo usan el bus SPI como generador de una frecuencia predeterminada.  De hecho, los pulsos generados puramente mediante programaci√≥n a trav√©s de l√≠neas GPIO dependen de muchos factores.  En primer lugar, ramificar, girar el bucle, requiere ciclos de procesador.  En segundo lugar, las interrupciones, DMA y otros factores imprevistos pueden interferir con el procesador.  SPI es m√°s o menos estable, s√© capaz de poner bytes en el b√∫fer.  Una aplicaci√≥n t√≠pica del bloque SPI, que no tiene una relaci√≥n directa con este SPI en s√≠, es el control de los LED RGB, para los cuales la precisi√≥n de establecer la duraci√≥n de los pulsos es muy importante. <br><br>  Desafortunadamente, esto no es aceptable para los puentes FTDI.  El fragmento de c√≥digo anterior generar√° estos pulsos en el bus: <br><br><img src="https://habrastorage.org/webt/dv/zx/pe/dvzxpe6cevog4qaklf2zy8tkdye.png"><br><br>  En este caso, las reglas de funcionamiento de SPI no se violan, desde el punto de vista de este bus, todo funciona correctamente.  Solo tenga en cuenta que las soluciones personalizadas habituales en los controladores no funcionar√°n aqu√≠.  Es cierto que el complejo tiene muchos conectores USB gratuitos.  Todos los bloques no est√°ndar pueden desarrollarse por separado y conectarse a ellos. <br><br><h4>  Partes de neum√°ticos I <sup>2</sup> C </h4><br>  Lo √∫nico que tiene sentido es indicar la ausencia de resistencias pull-up para el bus I <sup>2</sup> C en el lado del complejo.  Pero esto es normal: en el lado del dispositivo de trabajo, todav√≠a hay un ascensor.  Hoy en d√≠a, un pull-up puede ser de cualquier voltaje, por lo que es l√≥gico que est√© configurado en el dispositivo de destino. <br><br><h2>  Conclusi√≥n </h2><br>  Hoy adquirimos habilidades pr√°cticas para trabajar con neum√°ticos implementados por puentes FTDI.  En general, trabajar con ellos es est√°ndar, es solo que todo el conocimiento se resume en un solo art√≠culo, para no buscarlos poco a poco.  La pr√≥xima vez consideraremos un m√≥dulo que controla dispositivos no est√°ndar, implementado sobre la base del controlador STM32.  En el diagrama estructural, esta secci√≥n le corresponde: <br><br><img src="https://habrastorage.org/webt/ic/w4/9g/icw49gdqjdx26qahasd425ul-sm.png"><br><br>  Pero realmente, todo es un poco m√°s interesante all√≠ ... </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/477662/">https://habr.com/ru/post/477662/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../477648/index.html">MVCC en PostgreSQL-3. Versiones de fila</a></li>
<li><a href="../477650/index.html">Cifrado del tr√°fico TLS seg√∫n los algoritmos GOST-2012 con Stunnel</a></li>
<li><a href="../477654/index.html">Probar el operador mejorado instanceof en Java 14</a></li>
<li><a href="../477656/index.html">A√∫n as√≠, ¬øpor qu√© necesitas hacer?</a></li>
<li><a href="../477658/index.html">Restauraci√≥n activa: ¬øpuede la recuperaci√≥n ante desastres ser m√°s r√°pida? Mucho mas rapido?</a></li>
<li><a href="../477668/index.html">29 de noviembre, 6 p.m. - devleads-mitap</a></li>
<li><a href="../477670/index.html">Lo que da la automatizaci√≥n de prueba</a></li>
<li><a href="../477672/index.html">Derechos y obligaciones de los miembros del equipo: aspectos legales y culturales.</a></li>
<li><a href="../477674/index.html">¬øAI significa amor?</a></li>
<li><a href="../477678/index.html">Perspectivas para la televisi√≥n digital en Rusia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>