<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤷🏻 👨🏽‍💻 🔴 Comment les tailles des tableaux C sont devenues une partie de l'interface binaire de la bibliothèque 🧓🏿 🐋 💈</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La plupart des compilateurs C vous permettent d'accéder à un tableau extern avec des limites non définies, par exemple: 



 extern int external_array...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment les tailles des tableaux C sont devenues une partie de l'interface binaire de la bibliothèque</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451182/"> La plupart des compilateurs C vous permettent d'accéder à un tableau <code>extern</code> avec des limites non définies, par exemple: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> external_array[]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array_get</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> external_array[index]; }</code> </pre> <br>  La définition de external_array peut être dans une autre unité de traduction et peut ressembler à ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> external_array[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> };</code> </pre> <br>  La question est de savoir ce qui se passe si cette définition séparée change comme ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> external_array[<span class="hljs-number"><span class="hljs-number">4</span></span>] = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span> };</code> </pre> <br>  Ou alors: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> external_array[<span class="hljs-number"><span class="hljs-number">2</span></span>] = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> };</code> </pre> <a name="habracut"></a><br>  L'interface binaire sera-t-elle préservée (à condition qu'il existe un mécanisme permettant à l'application de déterminer la taille du tableau au moment de l'exécution)? <br><br>  Curieusement, sur de nombreuses architectures, l' <i>augmentation de la taille du tableau</i> viole la compatibilité d'interface binaire (ABI).  La réduction de la taille de la baie peut également entraîner des problèmes de compatibilité.  Dans cet article, nous allons examiner de plus près la compatibilité ABI et expliquer comment éviter les problèmes. <br><br><h1>  Liens dans la section des données du fichier exécutable </h1><br>  Pour comprendre comment la taille du tableau devient une partie de l'interface binaire, nous devons d'abord examiner les liens dans la section des données du fichier exécutable.  Bien sûr, les détails dépendent de l'architecture spécifique, et ici nous nous concentrerons sur l'architecture x86-64. <br><br>  L'architecture x86-64 prend en charge l'adressage par rapport au compteur de programme, c'est-à-dire que l'accès à la variable de tableau global, comme dans la fonction <code>array_get</code> présentée précédemment, peut être compilé en une seule instruction <code>movl</code> : <br><br><pre> <code class="cpp hljs">array_get: <span class="hljs-function"><span class="hljs-function">movl </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">external_array</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(,%rdi,</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">4</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">, %eax ret</span></span></code> </pre> <br>  À partir de cela, l'assembleur crée un fichier objet dans lequel l'instruction est marquée comme <code>R_X86_64_32S</code> . <br><br><pre> <code class="plaintext hljs">0000000000000000 : 0: mov 0x0(,%rdi,4),%eax 3: R_X86_64_32S external_array 7: retq</code> </pre> <br>  Ce déplacement indique à l'éditeur de liens ( <code>ld</code> ) comment remplir l'emplacement correspondant de la variable <code>external_array</code> pendant la liaison lors de la création de l'exécutable. <br><br>  Cela a deux conséquences importantes. <br><br><ul><li>  Étant donné que le décalage de la variable est déterminé au moment de la génération, au moment de l'exécution, il n'y a pas de surcharge pour le déterminer.  Le seul prix est l'accès à la mémoire elle-même. <br></li><li>  Pour déterminer le décalage, vous devez connaître la taille de toutes les données variables.  Sinon, il serait impossible de calculer le format de la section de données lors de la mise en page. </li></ul><br>  Pour les implémentations C orientées vers l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exécutable et le format de lien (ELF)</a> , comme dans GNU / Linux, les références aux variables <code>extern</code> ne contiennent pas de tailles d'objet.  Dans l'exemple <code>array_get</code> taille de l'objet est inconnue même du compilateur.  En fait, l'ensemble du fichier assembleur ressemble à ceci (en omettant uniquement les informations de promotion de <code>-fno-asynchronous-unwind-tables</code> , ce qui est techniquement requis pour la conformité psABI): <br><br><pre> <code class="plaintext hljs"> .file "get.c" .text .p2align 4,,15 .globl array_get .type array_get, @function array_get: movl external_array(,%rdi,4), %eax ret .size array_get, .-array_get .ident "GCC: (GNU) 8.3.1 20190223 (Red Hat 8.3.1-2)" .section .note.GNU-stack,"",@progbits</code> </pre> <br>  Il n'y a aucune information de taille pour <code>external_array</code> dans ce fichier assembleur: la seule référence de caractère est sur la ligne avec l'instruction <code>movl</code> , et les seules données numériques dans l'instruction sont la taille de l'élément de tableau (implicite par <code>movl</code> multiplié par 4). <br><br>  Si ELF nécessite des tailles pour les variables non définies, il sera même impossible de compiler la fonction <code>array_get</code> . <br><br>  Comment l'éditeur de liens obtient-il la taille réelle des caractères?  Il regarde la définition du symbole et utilise les informations de taille qu'il y trouve.  Cela permet au compilateur de calculer la disposition de la section de données et de remplir les mouvements de données avec les décalages appropriés. <br><br><h1>  Objets ELF courants </h1><br>  Les implémentations C pour ELF ne nécessitent pas que le programmeur ajoute du balisage au code source pour indiquer si la fonction ou la variable se trouve dans l'objet actuel (qui peut être la bibliothèque ou le fichier exécutable principal) ou dans un autre objet.  L'éditeur de liens et le chargeur dynamique s'en occuperont. <br><br>  Dans le même temps, on souhaitait que les fichiers exécutables ne réduisent pas les performances en modifiant le modèle de compilation.  Cela signifie que lors de la compilation du code source du programme principal (c'est-à-dire sans <code>-fPIC</code> , et dans ce cas particulier sans <code>-fPIE</code> ), la fonction <code>array_get</code> compilée <i>exactement</i> dans <i>la même</i> séquence de commandes avant d'introduire des objets partagés dynamiques.  De plus, peu importe si la variable <code>external_array</code> est définie dans le fichier exécutable le plus basique ou si un objet partagé est chargé séparément au moment de l'exécution.  Les instructions créées par le compilateur sont les mêmes dans les deux cas. <br><br>  Comment est-ce possible?  Après tout, les objets ELF courants sont indépendants de la position.  Ils sont chargés à <i>des adresses aléatoires et imprévisibles</i> lors de l'exécution.  Cependant, le compilateur génère une séquence de code machine qui nécessite que ces variables soient situées à un <i>décalage fixe calculé pendant la liaison</i> , bien avant le démarrage du programme. <br><br>  Le fait est qu'un seul objet chargé (le fichier exécutable principal) utilise ces décalages fixes.  Tous les autres objets (le chargeur dynamique lui-même, la bibliothèque d'exécution C et toute autre bibliothèque utilisée par le programme) sont compilés et compilés en tant qu'objets complètement indépendants de la position (PIC).  Pour ces objets, le compilateur charge l'adresse réelle de chaque variable à partir de la table de décalage globale (GOT).  Nous pouvons voir ce rond-point si nous <code>array_get</code> exemple <code>-fPIC</code> avec <code>-fPIC</code> , ce qui conduit à un tel code d'assembly: <br><br><pre> <code class="plaintext hljs">array_get: movq external_array@GOTPCREL(%rip), %rax movl (%rax,%rdi,4), %eax ret</code> </pre> <br>  Par conséquent, l'adresse de la variable <code>external_array</code> n'est plus codée en dur et peut être modifiée au moment de l'exécution en initialisant correctement l'enregistrement GOT.  Cela signifie qu'au moment de l'exécution, la définition de <code>external_array</code> peut être dans le même objet partagé, un autre objet partagé ou le programme principal.  Le chargeur dynamique trouvera la définition appropriée sur la base des règles de recherche de caractères ELF et associera la référence de symbole non définie à sa définition en mettant à jour l'enregistrement GOT à son adresse réelle. <br><br>  Nous revenons à l'exemple d'origine, où la fonction <code>array_get</code> est dans le programme principal, donc l'adresse de la variable est spécifiée directement.  L'idée clé implémentée dans l'éditeur de liens est que le programme principal fournira une définition de variable <code>external_array</code> , <i>même si elle est réellement définie dans un objet commun au moment de l'exécution</i> .  Au lieu de spécifier la définition initiale de la variable dans l'objet partagé, le chargeur dynamique sélectionnera une <i>copie de la</i> variable dans la section des données du fichier exécutable. <br><br>  Cela a deux conséquences importantes.  Tout d'abord, rappelez-vous que <code>external_array</code> est défini comme suit: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> external_array[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> };</code> </pre> <br>  Il y a ici un initialiseur qui doit être appliqué à la définition dans le fichier exécutable principal.  Pour ce faire, dans le fichier exécutable principal, un lien vers l'emplacement de <i>copie de</i> copie du symbole est placé.  La <code>readelf -rW</code> affiche en déplaçant <code>R_X86_64_COPY</code> . <br><br><pre>  La section de réinstallation '.rela.dyn' à l'offset 0x408 contient 3 entrées:
     Type d'informations de décalage Valeur du symbole Nom du symbole + ajout
 0000000000403ff0 0000000100000006 R_X86_64_GLOB_DAT 0000000000000000 __libc_start_main@GLIBC_2.2.5 + 0
 0000000000403ff8 0000000200000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0
 0000000000404020 0000000300000005 R_X86_64_COPY 0000000000404020 tableau_externe + 0 </pre><br>  Comme les autres mouvements, le mouvement de copie est géré par le chargeur dynamique.  Il comprend une opération de copie simple au niveau du bit.  La cible de la copie est déterminée par le décalage de déplacement ( <code>0000000000404020</code> dans l'exemple).  La source est déterminée lors de l'exécution en fonction du nom du symbole ( <code>external_array</code> ) et de sa valeur.  Lors de la création d'une copie, le chargeur dynamique examinera également la taille du caractère pour obtenir le nombre d'octets à copier.  Pour rendre tout cela possible, le symbole <code>external_array</code> est automatiquement exporté du fichier exécutable en tant que symbole spécifique afin qu'il soit visible par le chargeur dynamique au moment de l'exécution.  La table des symboles dynamiques ( <code>.dynsym</code> ) reflète cela, comme le montre la commande <code>readelf -sW</code> : <br><br><pre>  La table de symboles '.dynsym' contient 4 entrées:
    Num: Valeur Taille Type Lier Vis Ndx Nom
      0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 
      1: 0000000000000000 0 FUNC GLOBAL DEFAULT UND __libc_start_main@GLIBC_2.2.5 (2)
      2: 0000000000000000 0 NOTYPE FAIBLE DEFAUT UND __gmon_start__
      3: 0000000000404020 12 OBJET GLOBAL DEFAULT 22 tableau_externe </pre><br>  D'où proviennent les informations sur la taille de l'objet (12 octets, dans cet exemple)?  L'éditeur de liens ouvre tous les objets courants, recherche sa définition et prend des informations sur la taille.  Comme précédemment, cela permet à l'éditeur de liens de calculer la disposition de la section de données afin que des décalages fixes puissent être utilisés.  Encore une fois, la taille de la définition dans l'exécutable principal est fixe et ne peut pas être modifiée au moment de l'exécution. <br><br>  L'éditeur de liens dynamique redirige également les liens symboliques des objets partagés vers la copie déplacée dans l'exécutable principal.  Cela garantit que dans l'ensemble du programme, il n'y a qu'une seule copie de la variable, comme l'exige la sémantique du langage C. Sinon, si la variable change après l'initialisation, les mises à jour à partir du fichier exécutable principal ne seront pas visibles pour les objets partagés dynamiques et vice versa. <br><br><h1>  Impact sur la compatibilité binaire </h1><br>  Que se passe-t-il si nous modifions la définition de <code>external_array</code> dans un objet partagé sans lier (ou recompiler) le programme principal?  Tout d'abord, envisagez d' <i>ajouter</i> un élément de tableau. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> external_array[<span class="hljs-number"><span class="hljs-number">4</span></span>] = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span> };</code> </pre> <br>  Cela générera un avertissement du chargeur dynamique lors de l'exécution: <br><br> <code>main-program: Symbol `external_array' has different size in shared object, consider re-linking</code> <br> <br>  Le programme principal contient toujours une définition <code>external_array</code> avec un espace pour seulement 12 octets.  Cela signifie que la copie est incomplète: seuls les trois premiers éléments du tableau sont copiés.  Par conséquent, l'accès à l'élément de tableau <code>extern_array[3]</code> pas défini.  Cette approche affecte non seulement le programme principal, mais également tout le code du processus, car toutes les références à <code>extern_array</code> ont été redirigées vers la définition du programme principal.  Cela inclut un objet générique qui fournit une définition <code>extern_array</code> .  Il n'est probablement pas prêt à faire face à une situation où un élément de tableau dans sa propre définition a disparu. <br><br>  Que diriez-vous de changer dans la direction opposée, de supprimer un élément? <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> external_array[<span class="hljs-number"><span class="hljs-number">2</span></span>] = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> };</code> </pre> <br>  Si le programme évite d'accéder à l'élément de tableau <code>extern_array[2]</code> , car il détecte en quelque sorte la longueur réduite du tableau, alors cela fonctionnera.  Après le tableau, il y a de la mémoire inutilisée, mais cela ne cassera pas le programme. <br><br>  Cela signifie que nous obtenons la règle suivante: <br><br><ul><li>  L'ajout d'éléments à une variable de tableau global viole la compatibilité binaire. <br></li><li>  La suppression d'éléments peut rompre la compatibilité s'il n'existe aucun mécanisme qui empêche l'accès aux éléments supprimés. </li></ul><br>  Malheureusement, l'avertissement du chargeur dynamique semble plus inoffensif qu'il ne l'est en réalité, et pour les éléments distants, il n'y a aucun avertissement. <br><br><h1>  Comment éviter cette situation </h1><br>  La détection des modifications ABI est assez facile avec des outils comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">libabigail</a> . <br><br>  Le moyen le plus simple d'éviter cette situation consiste à implémenter une fonction qui renvoie l'adresse du tableau: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> local_array[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_external_array</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> local_array; }</code> </pre> <br>  Si la définition du tableau ne peut pas être rendue statique en raison de la façon dont il est utilisé dans la bibliothèque, nous pouvons plutôt masquer sa visibilité et également empêcher son exportation et, par conséquent, éviter le problème de troncature: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> local_array[<span class="hljs-number"><span class="hljs-number">3</span></span>] __attribute__ ((visibility (<span class="hljs-string"><span class="hljs-string">"hidden"</span></span>))) = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> };</code> </pre> <br>  Tout est beaucoup plus compliqué si la variable de tableau est exportée pour des raisons de compatibilité descendante.  Étant donné que le tableau de la bibliothèque est tronqué, l'ancien programme principal avec une définition de tableau plus courte ne pourra pas fournir l'accès au tableau complet pour le nouveau code client s'il est utilisé avec le même tableau global.  Au lieu de cela, la fonction d'accès peut utiliser un tableau séparé (statique ou masqué), ou peut-être un tableau séparé pour les éléments ajoutés à la fin.  L'inconvénient est qu'il n'est pas possible de tout stocker dans un tableau continu si la variable de tableau est exportée pour une compatibilité descendante.  La conception de l'interface secondaire devrait refléter cela. <br><br>  En utilisant le contrôle de version des caractères, vous pouvez exporter plusieurs versions avec des tailles différentes, sans jamais changer la taille dans une version particulière.  En utilisant ce modèle, les nouveaux programmes associés utiliseront toujours la dernière version, probablement avec la plus grande taille.  Étant donné que la version et la taille du symbole sont fixées en même temps par l'éditeur de liens, elles sont toujours cohérentes.  La bibliothèque GNU C utilise cette approche pour les variables historiques <code>sys_errlist</code> et <code>sys_siglist</code> .  Cependant, cela ne fournit toujours pas un seul tableau continu. <br><br>  Tout bien considéré, une fonction d'accesseur (par exemple, la fonction <code>get_external_array</code> ci-dessus) est la meilleure approche pour éviter ce problème de compatibilité ABI. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr451182/">https://habr.com/ru/post/fr451182/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr451172/index.html">Julia: fonctions et structures en tant que fonctions</a></li>
<li><a href="../fr451174/index.html">Adaptation de programmes pour ZX Spectrum à TR-DOS par des moyens modernes. Partie 1</a></li>
<li><a href="../fr451176/index.html">Nouvelles du monde d'OpenStreetMap n ° 458 (23/04/2019 - 09/09/2019)</a></li>
<li><a href="../fr451178/index.html">Essai de collision de l'atterrissage du parachute de l'équipage du dragon</a></li>
<li><a href="../fr451180/index.html">PCB remplace deux moteurs linéaires</a></li>
<li><a href="../fr451184/index.html">Blue Origin Blue Moon Project: les gens sur la Lune d'ici 2024</a></li>
<li><a href="../fr451186/index.html">Référentiel LINSTOR et son intégration avec OpenNebula</a></li>
<li><a href="../fr451188/index.html">Sberbank ou là et retour</a></li>
<li><a href="../fr451196/index.html">Séparation des profils client et freelance</a></li>
<li><a href="../fr451198/index.html">Le rôle de la réalité augmentée et de la réalité virtuelle dans la NBA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>