<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§õüèª üí™üèº üß• Kleinstm√∂gliche Schriftart ü§æüèΩ üëßüèø üìÉ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aufgabe: Verwenden Sie m√∂glichst wenig Ressourcen, um aussagekr√§ftigen Text zu rendern. 


- Wie klein kann eine lesbare Schrift sein? 
- Wie viel Spe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kleinstm√∂gliche Schriftart</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460697/"><p>  Aufgabe: Verwenden Sie m√∂glichst wenig Ressourcen, um aussagekr√§ftigen Text zu rendern. </p><br><ul><li>  Wie klein kann eine lesbare Schrift sein? </li><li> Wie viel Speicher wird zum Speichern ben√∂tigt? </li><li>  Wie viel Code wird ben√∂tigt, um es zu verwenden? </li></ul><br><p>  Mal sehen, was wir bekommen.  Spoiler </p><br><p><img src="https://habrastorage.org/webt/6k/jr/6m/6kjr6md92hgpbm7gvs8ia3o1cti.png"></p><a name="habracut"></a><br><h2 id="vvedenie-v-bitmepy">  Einf√ºhrung in Bitmaps </h2><br><p> Computer pr√§sentieren Bitmaps als Bitmaps.  Es geht nicht um das <code>.bmp</code> Format, sondern um eine M√∂glichkeit, Pixel im Speicher zu speichern.  Um zu verstehen, was passiert, m√ºssen wir etwas dar√ºber lernen. </p><br><h3 id="sloi">  Ebenen </h3><br><p>  Ein Bild enth√§lt normalerweise mehrere <em>Ebenen</em> √ºbereinander.  Meistens entsprechen sie den Koordinaten des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RGB-Farbraums</a> .  Eine Schicht f√ºr <em>Rot</em> , eine f√ºr <em>Gr√ºn</em> und eine f√ºr <em>Blau</em> .  Wenn das Bildformat Transparenz unterst√ºtzt, wird eine vierte Ebene daf√ºr erstellt, die normalerweise als <em>Alpha bezeichnet wird</em> .  Grob gesagt ist ein Farbbild drei (oder vier, wenn es einen Alphakanal gibt) Schwarzwei√ü, die √ºbereinander liegen. </p><br><ul><li>  RGB ist nicht der einzige Farbraum.  Das JPEG-Format verwendet beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">YUV</a> .  In diesem Artikel ben√∂tigen wir jedoch nicht den Rest der Farbr√§ume, daher ber√ºcksichtigen wir sie nicht. </li></ul><br><p>  Eine Reihe von Ebenen kann auf zwei Arten im Speicher dargestellt werden.  Entweder werden sie separat gespeichert oder Werte aus verschiedenen Ebenen werden verschachtelt.  Im letzteren Fall werden Ebenen als <em>Kan√§le bezeichnet</em> , und so funktionieren die meisten modernen Formate. </p><br><p>  Angenommen, wir haben eine 4x4-Zeichnung mit drei Ebenen: <em>R</em> f√ºr Rot, <em>G</em> f√ºr Gr√ºn und <em>B</em> f√ºr die blaue Komponente jedes Pixels.  Es kann so dargestellt werden: </p><br><pre> <code class="plaintext hljs"> RRRR RRRR RRRR RRRR GGGG GGGG GGGG GGGG BBBB BBBB BBBB BBBB</code> </pre> <br><p>  Alle drei Schichten werden separat gespeichert.  Das alternierende Format sieht anders aus: </p><br><pre> <code class="plaintext hljs"> RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB</code> </pre> <br><ul><li>  Jedes Dreifach von Zeichen entspricht <strong>genau</strong> einem Pixel </li><li>  Die Werte innerhalb des Tripels sind in <em>RGB-</em> Reihenfolge.  Manchmal kann eine andere Reihenfolge verwendet werden (z. B. <em>BGR</em> ), aber diese ist die h√§ufigste. </li></ul><br><p>  Der Einfachheit halber habe ich die Pixel in Form einer zweidimensionalen Matrix angeordnet, da klarer ist, wo sich dieses oder jenes Tripel im Bild befindet.  Tats√§chlich ist der Computerspeicher jedoch nicht zweidimensional, sondern eindimensional, sodass das 4x4-Bild folgenderma√üen gespeichert wird: </p><br><pre> <code class="plaintext hljs">RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB</code> </pre> <br><h3 id="bpp">  bpp </h3><br><p>  Die Abk√ºrzung <em>bpp</em> bezieht sich auf die Anzahl der Bits oder Bytes pro Pixel (Bits / Bytes pro Pixel).  M√∂glicherweise haben <code>3bpp</code> <code>24bpp</code> oder <code>3bpp</code> .  Diese beiden Eigenschaften bedeuten dasselbe - <strong>24 <em>Bit</em> pro Pixel</strong> oder <strong>3 <em>Bytes</em> pro Pixel</strong> .  Da ein Byte immer 8 Bits enth√§lt, k√∂nnen Sie anhand des Werts der betreffenden Einheiten erraten. </p><br><h3 id="predstavlenie-v-pamyati">  Speicherdarstellung </h3><br><p>  <code>24bpp</code> , auch bekannt als <code>3bpp</code> - das am h√§ufigsten verwendete Format zum Speichern von Blumen.  So sieht ein <strong>einzelnes Pixel</strong> in <em>RGB-</em> Reihenfolge auf der Ebene einzelner Bits aus. </p><br><pre> <code class="plaintext hljs"> 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  RRRRRRRRGGGGGGGGBBBBB BBB</code> </pre> <br><ul><li>  Ein Byte f√ºr <em>R</em> , eines f√ºr <em>G</em> und eines f√ºr <em>B</em> , insgesamt drei Bytes. </li><li>  Jeder von ihnen enth√§lt einen Wert von 0 bis 255. </li></ul><br><p>  Wenn also das angegebene Pixel die folgende Farbe hat: </p><br><ul><li> <code>R 255</code> </li> <li> <code>G 80</code> </li> <li> <code>B 100</code> </li> </ul><br><p>  Dann werden <code>255</code> im ersten Byte, <code>80</code> im zweiten und <code>100</code> im dritten Byte gespeichert. </p><br><p>  Meistens werden diese Werte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hexadezimal dargestellt</a> .  Sagen Sie <code>#ff5064</code> .  Dies ist viel bequemer und kompakter: <code>R = 0xff</code> (d. H. <code>R=255</code> in Dezimalzahl), <code>G = 0x50</code> (= <code>G=80</code> ), <code>B=0x64</code> (= <code>B=100</code> ). </p><br><ul><li>  Die hexadezimale Darstellung hat eine n√ºtzliche Eigenschaft.  Da jedes Farbbyte durch zwei Zeichen dargestellt wird, codiert jedes Zeichen <strong>genau ein</strong> halbes Byte oder vier Bits.  4 Bits werden √ºbrigens als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Knabbern bezeichnet</a> . </li></ul><br><h3 id="shirina-stroki">  Linienbreite </h3><br><p>  Wenn Pixel nacheinander verlaufen und jeder mehr als einen Kanal enth√§lt, k√∂nnen die Daten leicht verwechselt werden.  Es ist nicht bekannt, wann eine Zeile endet und die n√§chste beginnt. Um eine Datei mit einer Bitmap zu interpretieren, m√ºssen Sie die Bildgr√∂√üe und den <em>bpp kennen</em> .  In unserem Fall hat das Bild eine Breite von <code>w = 4</code> Pixel und jedes dieser Pixel enth√§lt 3 Bytes, sodass die Zeichenfolge mit 12 (im allgemeinen Fall <code>w*bpp</code> ) Bytes codiert ist. </p><br><ul><li>  Ein String wird nicht immer mit genau <code>w*bpp</code> Bytes codiert.  Oft werden "versteckte" Pixel hinzugef√ºgt, um die Bildbreite auf eine bestimmte Gr√∂√üe zu bringen.  Zum Beispiel ist das Skalieren von Bildern schneller und bequemer, wenn ihre Gr√∂√üe in Pixel einer Zweierpotenz entspricht.  Daher kann die Datei ein Bild von 120 x 120 Pixel enthalten (f√ºr den Benutzer zug√§nglich), das jedoch als Bild von 128 x 128 Pixel gespeichert ist.  Wenn ein Bild auf dem Bildschirm angezeigt wird, werden diese Pixel ignoriert.  Wir m√ºssen sie jedoch nicht kennen. </li></ul><br><p>  Die Koordinate eines beliebigen Pixels <code>(x, y)</code> in der eindimensionalen Darstellung ist <code>(y * w + x) * bpp</code> .  Dies ist im Allgemeinen offensichtlich: <code>y</code> ist die Zeilennummer, jede Zeile enth√§lt <code>w</code> Pixel, also ist <code>y * w</code> der Anfang der gew√ºnschten Zeile, und <code>+x</code> f√ºhrt uns zum gew√ºnschten <code>x</code> darin.  Und da die Koordinaten nicht in Bytes, sondern in Pixeln angegeben sind, wird dies alles mit der Gr√∂√üe des <code>bpp</code> Pixels multipliziert, in diesem Fall in Bytes.  Da das Pixel eine Gr√∂√üe ungleich Null hat, m√ºssen Sie ausgehend von der empfangenen Koordinate genau <code>bpp</code> Bytes lesen, und wir erhalten eine vollst√§ndige Darstellung des gew√ºnschten Pixels. </p><br><h2 id="atlas-shrifta">  Schriftatlas </h2><br><p>  Tats√§chlich vorhandene Monitore zeigen nicht ein Pixel als Ganzes an, sondern drei Subpixel - rot, blau und gr√ºn.  Wenn Sie den Monitor unter Vergr√∂√üerung betrachten, sehen Sie ungef√§hr Folgendes: </p><br><p><img src="https://habrastorage.org/webt/w8/nb/c9/w8nbc98aixpbrxgvffsccmxelyk.png"></p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wikipedia</a> Zeichnung </li></ul><br><p>  Wir sind an LCD interessiert, da Sie diesen Text h√∂chstwahrscheinlich von einem solchen Monitor aus lesen.  Nat√ºrlich gibt es Fallstricke: </p><br><ul><li>  Nicht alle Matrizen verwenden genau diese Reihenfolge von Subpixeln, manchmal BGR. </li><li>  Wenn Sie den Monitor drehen (z. B. im Querformat auf das Telefon schauen), dreht sich auch das Muster und die Schriftart funktioniert nicht mehr. </li><li>  Unterschiedliche Matrixausrichtungen und die Anordnung der Subpixel erfordern eine √úberarbeitung der Schriftart. </li><li>  Insbesondere funktioniert es nicht bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AMOLED-Displays</a> , die das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PenTile-Layout verwenden</a> .  Solche Anzeigen werden am h√§ufigsten in mobilen Ger√§ten verwendet. </li></ul><br><p>  Die Verwendung von Subpixel-Hacks zur Erh√∂hung der Aufl√∂sung wird als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Subpixel-Rendering bezeichnet</a> .  Hier k√∂nnen Sie beispielsweise √ºber die Verwendung in der Typografie lesen. </p><br><p>  Zum Gl√ºck hat Matt Sarnov bereits mithilfe von Subpixel-Rendering eine winzige <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Millitext-</a> Schriftart erstellt.  Manuell schuf er dieses winzige Bild: </p><br><p><img src="https://habrastorage.org/webt/p7/jk/xe/p7jkxececbln6pxlatfoa9kyymq.png"></p><br><p>  Was, wenn Sie genau auf den Monitor schauen, so aussieht: </p><br><p><img src="https://habrastorage.org/webt/8n/wz/fq/8nwzfqilnvn_jronmwqbfnodllg.png"></p><br><p>  Und hier ist es, programmatisch um das 12-fache erh√∂ht: </p><br><p><img src="https://habrastorage.org/webt/fa/9p/us/fa9puspiilp5ip-50cuyxfyrdva.png"></p><br><p>  Basierend auf seiner Arbeit habe ich einen Schriftatlas erstellt, in dem jedes Zeichen einer Spalte von <code>1x5</code> Pixel entspricht.  Die Zeichenreihenfolge ist wie folgt: </p><br><pre> <code class="plaintext hljs">0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ</code> </pre> <br><p><img src="https://habrastorage.org/webt/qe/ip/_v/qeip_vlwmjwfnnbbuz9cq6rhfn4.png"></p><br><p>  Der gleiche Atlas wurde um das 12-fache erh√∂ht: </p><br><p><img src="https://habrastorage.org/webt/m3/ds/eg/m3dseggtbsmpgnmvlekvlz2aqow.png"></p><br><p>  Mit 36 ‚Äã‚Äãverwendeten Zeichen werden genau 36 <code>365</code> Pixel <code>365</code> .  Wenn wir davon ausgehen, dass jedes Pixel 3 Bytes belegt, ben√∂tigen wir <code>36*5*3 = 540</code> Bytes, um das gesamte Bild zu speichern (ca <em>.: im Original eine verwirrende Reihe von √Ñnderungen am Alphakanal, L√∂schen von Metadaten usw.). n. In der √úbersetzung habe ich es weggelassen und nur die endg√ºltige Version der Datei verwendet</em> .  Eine PNG-Datei, die durch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pngcrush</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">optipng geleitet wird,</a> ben√∂tigt noch weniger: </p><br><pre> <code class="plaintext hljs"># wc -c &lt; font-crushed.png 390</code> </pre> <br><p>  Sie k√∂nnen jedoch eine noch kleinere Gr√∂√üe erzielen, wenn Sie einen etwas anderen Ansatz verwenden </p><br><h1 id="szhatie">  Komprimierung </h1><br><p>  Der aufmerksame Leser konnte feststellen, dass der Atlas nur 7 Farben verwendet: </p><br><ol><li> <code>#ffffff</code> </li> <li> <code>#ff0000</code> </li> <li> <code>#00ff00</code> </li> <li> <code>#0000ff</code> </li> <li> <code>#00ffff</code> </li> <li> <code>#ff00ff</code> </li> <li> <code>#ffff00</code> </li> </ol><br><h2 id="palitra">  Palette </h2><br><p>  In solchen Situationen ist es oft einfacher, eine Palette zu erstellen.  Dann k√∂nnen Sie f√ºr jedes Pixel nicht drei Bytes Farbe speichern, sondern nur die Farbnummer in der Palette.  In unserem Fall reichen 3 Bits ( <code>7 &lt; 2^3</code> ) aus, um aus 7 Farben auszuw√§hlen.  Wenn wir jedem Pixel einen Drei-Bit-Wert zuweisen, passt der gesamte Atlas in <em>68 Bytes</em> . </p><br><ul><li>  Der Leser, der sich mit Datenkomprimierung auskennt, kann antworten, dass es im Allgemeinen so etwas wie "Bruchbits" gibt und in unserem Fall <strong>2,875 Bits pro Pixel</strong> ausreichen.  Diese Dichte kann mit schwarzer Magie erreicht werden, die als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">arithmetische Codierung bekannt ist</a> .  Wir werden dies nicht tun, da die arithmetische Codierung eine komplizierte Sache ist und 68 Bytes bereits ein bisschen sind. </li></ul><br><h2 id="vyravnivanie">  Ausrichtung </h2><br><p>  Die Drei-Bit-Codierung hat einen schwerwiegenden Nachteil.  Pixel k√∂nnen nicht gleichm√§√üig auf 8-Bit-Bytes verteilt werden. Dies ist wichtig, da Bytes der kleinste adressierbare Speicherbereich sind.  Angenommen, wir m√∂chten drei Pixel speichern: </p><br><pre> <code class="plaintext hljs">ABC</code> </pre> <br><p>  Wenn jedes 3 Bits ben√∂tigt, werden 2 Bytes ben√∂tigt, um sie zu speichern ( <code>-</code> zeigt nicht verwendete Bits an): </p><br><pre> <code class="plaintext hljs">bit 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 pixel AAABBBCCC - - - - - - -</code> </pre> <br><p>  Wichtig ist, dass Pixel <strong>C</strong> nicht nur einen leeren Raum hinterl√§sst.  Es wird zwischen zwei Bytes <em>gerissen</em> .  Wenn wir die folgenden Pixel hinzuf√ºgen, k√∂nnen sie beliebig relativ zu den Bytegrenzen positioniert werden.  Die einfachste L√∂sung w√§re die Verwendung von Nibble pro Pixel, da 8 perfekt durch 4 geteilt ist und Sie genau zwei Pixel in jedem Byte platzieren k√∂nnen.  Dies erh√∂ht jedoch die Gr√∂√üe des Atlas um ein Drittel von <strong>68 Byte</strong> auf <strong>90 Byte</strong> . </p><br><ul><li>  Tats√§chlich kann die Datei mithilfe von Palindromcodierung, Intervallcodierung und anderen Komprimierungstechniken noch kleiner gemacht werden.  Wie bei der arithmetischen Codierung verschieben wir diese Techniken auf den n√§chsten Artikel. </li></ul><br><h2 id="bitovyy-bufer">  Bitpuffer </h2><br><p>  Gl√ºcklicherweise ist die Arbeit mit 3-Bit-Werten grunds√§tzlich nicht unm√∂glich.  Sie m√ºssen nur √ºberwachen, an welcher Position innerhalb des Bytes wir gerade schreiben oder lesen.  Die folgende einfache Klasse konvertiert einen 3-Bit-Datenstrom in ein Array von Bytes. </p><br><ul><li>  Aus Gr√ºnden der Lesbarkeit ist der Code in JS geschrieben, aber dieselbe Methode wird auf andere Sprachen verallgemeinert. </li><li>  Verwendete Reihenfolge von Low Byte bis High ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Little Endian</a> ) </li></ul><br><pre> <code class="plaintext hljs">class BitBuffer { constructor(bytes) { this.data = new Uint8Array(bytes); this.offset = 0; } write(value) { for (let i = 0; i &lt; 3; ) { // bits remaining const remaining = 3 - i; // bit offset in the byte ie remainder of dividing by 8 const bit_offset = this.offset &amp; 7; // byte offset for a given bit offset, ie divide by 8 const byte_offset = this.offset &gt;&gt; 3; // max number of bits we can write to the current byte const wrote = Math.min(remaining, 8 - bit_offset); // mask with the correct bit-width const mask = ~(0xff &lt;&lt; wrote); // shift the bits we want to the start of the byte and mask off the rest const write_bits = value &amp; mask; // destination mask to zero all the bits we're changing first const dest_mask = ~(mask &lt;&lt; bit_offset); value &gt;&gt;= wrote; // write it this.data[byte_offset] = (this.data[byte_offset] &amp; dest_mask) | (write_bits &lt;&lt; bit_offset); // advance this.offset += wrote; i += wrote; } } to_string() { return Array.from(this.data, (byte) =&gt; ('0' + (byte &amp; 0xff).toString(16)).slice(-2)).join(''); } };</code> </pre> <br><p>  Laden Sie die Atlas-Datei herunter und codieren Sie sie: </p><br><pre> <code class="plaintext hljs">const PNG = require('png-js'); const fs = require('fs'); // this is our palette of colors const Palette = [ [0xff, 0xff, 0xff], [0xff, 0x00, 0x00], [0x00, 0xff, 0x00], [0x00, 0x00, 0xff], [0x00, 0xff, 0xff], [0xff, 0x00, 0xff], [0xff, 0xff, 0x00] ]; // given a color represented as [R, G, B], find the index in palette where that color is function find_palette_index(color) { const [sR, sG, sB] = color; for (let i = 0; i &lt; Palette.length; i++) { const [aR, aG, aB] = Palette[i]; if (sR === aR &amp;&amp; sG === aG &amp;&amp; sB === aB) { return i; } } return -1; } // build the bit buffer representation function build(cb) { const data = fs.readFileSync('subpixels.png'); const image = new PNG(data); image.decode(function(pixels) { // we need 3 bits per pixel, so w*h*3 gives us the # of bits for our buffer // however BitBuffer can only allocate bytes, dividing this by 8 (bits for a byte) // gives us the # of bytes, but that division can result in 67.5 ... Math.ceil // just rounds up to 68. this will give the right amount of storage for any // size atlas. let result = new BitBuffer(Math.ceil((image.width * image.height * 3) / 8)); for (let y = 0; y &lt; image.height; y++) { for (let x = 0; x &lt; image.width; x++) { // 1D index as described above const index = (y * image.width + x) * 4; // extract the RGB pixel value, ignore A (alpha) const color = Array.from(pixels.slice(index, index + 3)); // write out 3-bit palette index to the bit buffer result.write(find_palette_index(color)); } } cb(result); }); } build((result) =&gt; console.log(result.to_string()));</code> </pre> <br><p>  Wie erwartet passt der Atlas auf <strong>68 Bytes</strong> , was sechsmal kleiner ist als die PNG-Datei. </p><br><p>  ( <em>Anmerkung per.: Der Autor ist etwas unaufrichtig: Er hat die Palette und die Bildgr√∂√üe nicht gespeichert, was nach meinen Sch√§tzungen 23 Bytes mit einer festen Palettengr√∂√üe erfordert und die Bildgr√∂√üe auf 91 Bytes erh√∂ht.</em> ) </p><br><p>  Nun konvertieren wir das Bild in eine Zeichenfolge, damit Sie es in den Quellcode einf√ºgen k√∂nnen.  Im Wesentlichen macht die <code>to_string</code> Methode dies: Sie repr√§sentiert den Inhalt jedes Bytes als Hexadezimalzahl. </p><br><pre> <code class="plaintext hljs">305000000c0328d6d4b24cb46d516d4ddab669926a0ddab651db76150060009c0285 e6a0752db59054655bd7b569d26a4ddba053892a003060400d232850b40a6b61ad00</code> </pre> <br><p>  Die resultierende Zeichenfolge ist jedoch immer noch ziemlich lang, da wir uns auf ein Alphabet mit 16 Zeichen beschr√§nkt haben.  Sie k√∂nnen es durch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">base64</a> ersetzen, in dem viermal so viele Zeichen vorhanden sind. </p><br><pre> <code class="plaintext hljs">to_string() { return Buffer.from(this.data).toString('base64'); }</code> </pre> <br><p>  In base64 sieht der Atlas folgenderma√üen aus: </p><br><pre> <code class="plaintext hljs">MFAAAAwDKNbUsky0bVFtTdq2aZJqDdq2Udt2FQBgAJwCheagdS21kFRlW9e1adJqTdugU4kqADBgQA0jKFC0CmthrQA=</code> </pre> <br><p>  Diese Zeile kann fest in das JS-Modul codiert und zum Rastern des Texts verwendet werden. </p><br><h1 id="rasterizaciya">  Rasterisierung </h1><br><p>  Um Speicherplatz zu sparen, wird jeweils nur ein Buchstabe dekodiert. </p><br><pre> <code class="plaintext hljs">const Alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; const Atlas = Uint8Array.from(Buffer.from('MFAAAAwDKNbUsky0bVFtTdq2aZJqDdq2Udt2FQBgAJwCheagdS21kFRlW9e1adJqTdugU4kqADBgQA0jKFC0CmthrQA=', 'base64')); const Palette = [ [0xff, 0xff, 0xff], [0xff, 0x00, 0x00], [0x00, 0xff, 0x00], [0x00, 0x00, 0xff], [0x00, 0xff, 0xff], [0xff, 0x00, 0xff], [0xff, 0xff, 0x00] ]; // at the given bit offset |offset| read a 3-bit value from the Atlas read = (offset) =&gt; { let value = 0; for (let i = 0; i &lt; 3; ) { const bit_offset = offset &amp; 7; const read = Math.min(3 - i, 8 - bit_offset); const read_bits = (Atlas[offset &gt;&gt; 3] &gt;&gt; bit_offset) &amp; (~(0xff &lt;&lt; read)); value |= read_bits &lt;&lt; i; offset += read; i += read; } return value; }; // for a given glyph |g| unpack the palette indices for the 5 vertical pixels unpack = (g) =&gt; { return (new Uint8Array(5)).map((_, i) =&gt; read(Alphabet.length*3*i + Alphabet.indexOf(g)*3)); }; // for given glyph |g| decode the 1x5 vertical RGB strip decode = (g) =&gt; { const rgb = new Uint8Array(5*3); unpack(g).forEach((value, index) =&gt; rgb.set(Palette[value], index*3)); return rgb; }</code> </pre> <br><p>  Die <code>decode</code> nimmt ein Zeichen als Eingabe und gibt die entsprechende Spalte im Quellbild zur√ºck.  Was hier beeindruckend ist, ist, dass es nur <strong>5 Bytes</strong> Speicher ben√∂tigt, um ein einzelnes Zeichen zu decodieren, plus <strong>~ 1,875</strong> Bytes, um das gew√ºnschte St√ºck des Arrays zu lesen, d. H.  durchschnittlich <strong>6,875</strong> pro Brief.  Wenn Sie <strong>68 Bytes</strong> zum Speichern des Arrays und <strong>36 Bytes</strong> zum Speichern des Alphabets hinzuf√ºgen, stellt sich heraus, dass Sie <em>theoretisch</em> Text mit 128 Bytes RAM rendern k√∂nnen. </p><br><ul><li>  Dies ist m√∂glich, wenn Sie den Code in C oder Assembler neu schreiben.  Vor dem Hintergrund des JS-Overheads bedeutet dies eine Einsparung von √úbereinstimmungen. </li></ul><br><p>  Es bleibt nur, diese Spalten zu einem Ganzen zusammenzufassen und ein Bild mit Text zur√ºckzugeben. </p><br><pre> <code class="plaintext hljs">print = (t) =&gt; { const c = t.toUpperCase().replace(/[^\w\d ]/g, ''); const w = c.length * 2 - 1, h = 5, bpp = 3; // * 2 for whitespace const b = new Uint8Array(w * h * bpp); [...c].forEach((g, i) =&gt; { if (g !== ' ') for (let y = 0; y &lt; h; y++) { // copy each 1x1 pixel row to the the bitmap b.set(decode(g).slice(y * bpp, y * bpp + bpp), (y * w + i * 2) * bpp); } }); return {w: w, h: h, data: b}; };</code> </pre> <br><p>  Dies ist die kleinstm√∂gliche Schriftart. </p><br><pre> <code class="plaintext hljs">const fs = require('fs'); const result = print("Breaking the physical limits of fonts"); fs.writeFileSync(`${result.w}x${result.h}.bin`, result.data);</code> </pre> <br><p>  F√ºgen Sie einen kleinen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Imagemagick hinzu</a> , um das Bild in einem lesbaren Format zu erhalten: </p><br><pre> <code class="plaintext hljs"># convert -size 73x5 -depth 8 rgb:73x5.bin done.png</code> </pre> <br><p>  Und hier ist das Endergebnis: </p><br><p><img src="https://habrastorage.org/webt/jv/lf/gs/jvlfgsoyr4xbnxsbzuzax3shp4s.png"></p><br><p>  Es wird auch um das 12-fache erh√∂ht: </p><br><p><img src="https://habrastorage.org/webt/6k/jr/6m/6kjr6md92hgpbm7gvs8ia3o1cti.png"></p><br><p>  Es wurde von einem schlecht kalibrierten Monitormakro aufgenommen: </p><br><p><img src="https://habrastorage.org/webt/pd/qp/li/pdqplibvzty8wtoxosah5d3phxe.png"></p><br><p>  Und schlie√ülich ist es auf dem Monitor besser: </p><br><p><img src="https://habrastorage.org/webt/ge/oz/rh/geozrhsclx2squmratxt8flet1a.png"></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de460697/">https://habr.com/ru/post/de460697/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de460675/index.html">Datenextraktion beim maschinellen Lernen</a></li>
<li><a href="../de460683/index.html">Laravel Event Projector und Event Generation Concept</a></li>
<li><a href="../de460685/index.html">Wir verteilen Dateien von Google Drive mit nginx</a></li>
<li><a href="../de460687/index.html">Wie Dosen von innen aussehen</a></li>
<li><a href="../de460695/index.html">Was ist DAA und wie hilft dieses System Drohnen?</a></li>
<li><a href="../de460699/index.html">Habr Weekly # 10 / Super Services und E-Pass, Smartphones und Russen, "Spionageger√§te", Leben ohne Satelliten</a></li>
<li><a href="../de460701/index.html">Kurs "Start in Data Science": der erste Schritt in der Arbeit mit Daten</a></li>
<li><a href="../de460703/index.html">Blauer Ozean der M√∂glichkeiten: Von null bis 400 tausend Videointerviews</a></li>
<li><a href="../de460707/index.html">Ist es Zeit f√ºr Spieleentwickler, ihren Fans nicht mehr zuzuh√∂ren?</a></li>
<li><a href="../de460709/index.html">√úberlegungen zu Agile</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>