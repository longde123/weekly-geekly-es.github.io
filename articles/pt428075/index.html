<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🤝‍👨🏻 👨🏽‍💼 💤 Mesmo assim, você não pode fazê-lo! - Usando interfaces e injeção de dependência para projetos de longo prazo 🌅 😋 🏦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Olá pessoal! 

 Finalmente, temos um contrato para atualizar o livro de Mark Siman, " Dependency Injection in .NET " - o principal é que ele termine o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mesmo assim, você não pode fazê-lo! - Usando interfaces e injeção de dependência para projetos de longo prazo</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/428075/">  Olá pessoal! <br><br>  Finalmente, temos um contrato para atualizar o livro de Mark Siman, " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Dependency Injection in .NET</a> " - o principal é que ele termine o mais rápido possível.  Também temos um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">livro</a> no editor do respeitado Dinesh Rajput sobre padrões de design na primavera 5, onde um dos capítulos também é dedicado à implementação de dependências. <br><br>  Há muito tempo procuramos um material interessante que lembre os pontos fortes do paradigma de DI e esclareça nosso interesse nele - e agora ele foi encontrado.  É verdade que o autor preferiu dar exemplos no Go.  Esperamos que isso não impeça que você siga seus pensamentos e ajude a entender os princípios gerais da inversão de controle e trabalhar com interfaces, se este tópico estiver próximo de você. <br><br>  A coloração emocional do original é um pouco mais silenciosa, o número de pontos de exclamação na tradução é reduzido.  Boa leitura! <br><a name="habracut"></a><br>  O uso de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">interfaces</a> é uma técnica compreensível que permite criar código fácil de testar e extensível.  Estive repetidamente convencido de que esta é a ferramenta de design de arquitetura mais poderosa de todas. <br><br>  O objetivo deste artigo é explicar o que são interfaces, como são usadas e como fornecem extensibilidade e testabilidade de código.  Por fim, o artigo deve mostrar como as interfaces podem ajudar a otimizar o gerenciamento de entrega de software e simplificar o planejamento! <br><br>  <b>Interfaces</b> <br><br>  A interface descreve o contrato.  Dependendo da linguagem ou estrutura, o uso de interfaces pode ser ditado explícita ou implicitamente.  Portanto, na linguagem Go, as <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">interfaces são ditadas explicitamente</a> .  Se você tentar usar uma entidade como uma interface, mas ela não será totalmente consistente com as regras dessa interface, ocorrerá um erro em tempo de compilação.  Por exemplo, executando o exemplo acima, obtemos o seguinte erro: <br><br><pre><code class="hljs sql">prog.go:22:85: cannot <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> BadPricer literal (<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> BadPricer) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> StockPricer <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> argument <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> isPricerHigherThan100: BadPricer does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> implement StockPricer (<span class="hljs-keyword"><span class="hljs-keyword">missing</span></span> CurrentPrice method) Program exited.</code> </pre> <br>  Interfaces é uma ferramenta para ajudar a desconectar o chamador do chamado, isso é feito usando um contrato. <br><br>  Vamos concretizar esse problema usando um exemplo de programa para negociação automática de câmbio.  O programa do trader será chamado com um preço de compra definido e um símbolo de cotação.  Em seguida, o programa irá para a bolsa de valores para descobrir a cotação atual deste ticker.  Além disso, se o preço de compra deste ticker não exceder o preço fixado, o programa fará uma compra. <br><br><img src="https://habrastorage.org/webt/pp/hx/mv/pphxmvus0-rkxh-vffl9o18bjsq.png"><br><br>  De uma forma simplificada, a arquitetura deste programa pode ser representada da seguinte maneira.  A partir do exemplo acima, fica claro que a operação de obtenção do preço atual depende diretamente do protocolo HTTP, pelo qual o programa contata o serviço de câmbio. <br><br>  O estado da <code>Action</code> também depende diretamente do HTTP.  Assim, ambos os estados devem entender completamente como usar o HTTP para extrair dados de troca e / ou concluir transações. <br><br>  Aqui está a aparência da implementação: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">analyze</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ticker </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, maxTradePrice </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">, err)</span></span></span></span> { resp, err := http.Get( <span class="hljs-string"><span class="hljs-string">"http://stock-service.com/currentprice/"</span></span> + ticker ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   } defer resp.Body.Close() body, err := ioutil.ReadAll(resp.Body) // ... currentPrice := parsePriceFromBody(body) var hasTraded bool var err error if currentPrice &lt;= maximumTradePrice { err = doTrade(ticker, currentPrice) if err == nil { hasTraded = true } } return hasTraded, err }</span></span></code> </pre> <br>  Aqui, o chamador ( <code>analyze</code> ) depende diretamente do HTTP.  Ela precisa saber como as solicitações HTTP são formuladas.  Como é feita a análise deles?  Como lidar com novas tentativas, tempos limite, autenticação, etc.  Ela tem um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">controle</a> próximo do <code>http</code> .  <b>Sempre que chamamos de análise, também devemos chamar a biblioteca <code>http</code></b> . <br><br>  Como a interface pode nos ajudar aqui?  No contrato fornecido pela interface, você pode descrever o <b>comportamento</b> , e não a <b>implementação</b> específica. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> StockExchange <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { CurrentPrice(ticker <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> }</code> </pre> <br>  O exposto acima define o conceito do <code>StockExchange</code> .  Diz aqui que o <code>StockExchange</code> suporta a chamada da única função <code>CurrentPrice</code> .  Essas três linhas me parecem a técnica arquitetônica mais poderosa de todas.  Eles nos ajudam a controlar as dependências de aplicativos com muito mais confiança.  Fornecer testes.  Forneça extensibilidade. <br><br>  <b>Injeção de Dependência</b> <br><br>  Para entender completamente o valor das interfaces, você precisa dominar a técnica chamada "injeção de dependência". <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Injeção de dependência</a> significa que o chamador fornece algo necessário ao chamador.  Geralmente fica assim: o chamador configura o objeto e depois o passa para o chamado.  Em seguida, a parte chamada abstrai da configuração e implementação.  Nesse caso, há uma mediação conhecida.  Considere uma solicitação para o serviço HTTP Rest.  Para implementar o cliente, precisamos usar uma biblioteca HTTP que possa formular, enviar e receber solicitações HTTP. <br><br>  Se colocarmos a solicitação HTTP atrás da interface, o chamador poderá ser desconectado e ela "não saberá" que a solicitação HTTP realmente ocorreu. <br><br>  O chamador deve fazer apenas uma chamada de função genérica.  Pode ser uma chamada local, uma chamada remota, uma chamada HTTP, uma chamada RPC, etc.  O interlocutor não está ciente do que está acontecendo e, geralmente, combina perfeitamente com ela, desde que obtenha os resultados esperados.  A seguir, mostramos como seria a injeção de dependência em nosso método de <code>analyze</code> . <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">analyze</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(se StockExchange, ticker </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, maxTradePrice </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { currentPrice := se.CurrentPrice(ticker) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hasTraded <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> err error <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> currentPrice &lt;= maximumTradePrice { err = doTrade(ticker, currentPrice) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { hasTraded = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasTraded, err }</code> </pre> <br>  Nunca deixo de me surpreender com o que está acontecendo aqui.  Invertemos completamente nossa árvore de dependência e começamos a controlar melhor o programa inteiro.  Além disso, mesmo visualmente toda a implementação se tornou mais limpa e compreensível.  Vimos claramente que o método de análise deve escolher o preço atual, verificar se esse preço é adequado para nós e, se for o caso, fazer um acordo. <br><br>  Mais importante, nesse caso, desconectamos o chamador do chamador.  Como o chamador e toda a implementação são separados da chamada usando a interface, você pode estender a interface criando muitas implementações diferentes.  As interfaces permitem criar muitas implementações específicas diferentes, sem a necessidade de alterar o código da parte chamada! <br><br><img src="https://habrastorage.org/webt/c8/us/5_/c8us5_mv_y2tmittjhk33ahgw7i.png"><br><br>  O status "obter preço atual" neste programa depende apenas da interface do <code>StockExchange</code> .  Esta implementação não sabe <b>nada</b> sobre como entrar em contato com o serviço de troca, como os preços são armazenados ou como são feitas as solicitações.  Verdadeira ignorância feliz.  Além disso, bilateral.  A implementação <code>HTTPStockExchange</code> também não sabe nada sobre a análise.  Sobre o contexto em que a análise será realizada, quando realizada - porque os desafios ocorrem indiretamente. <br><br>  Como os fragmentos de programa (aqueles que dependem de interfaces) não precisam ser alterados ao alterar / adicionar / excluir implementações específicas, <b>esse design acaba sendo durável</b> .  Suponha que descobrimos que o <code>StockService</code> geralmente não <code>StockService</code> disponível. <br><br>  Como o exemplo acima é diferente de chamar uma função?  Ao aplicar uma chamada de função, a implementação também ficará mais limpa.  A diferença é que, quando você chama a função, ainda precisamos recorrer ao HTTP.  O método de <code>analyze</code> simplesmente delegará a tarefa da função, que deve chamar <code>http</code> , em vez de chamar o próprio <code>http</code> diretamente.  Toda a força dessa técnica está na "injeção", ou seja, na medida em que o chamador fornece a interface para o chamado.  É exatamente assim que ocorre a inversão de dependência, em que os preços de obtenção dependem apenas da interface e não da implementação. <br><br>  <b>Várias implementações prontas para uso</b> <br><br>  Nesta fase, temos a função de <code>analyze</code> e a interface <code>StockExchange</code> , mas na verdade não podemos fazer nada de útil.  Acabei de anunciar nosso programa.  No momento, é impossível chamá-lo, pois ainda não temos uma única implementação específica que atenda aos requisitos de nossa interface. <br><br>  A ênfase principal no diagrama a seguir é feita no estado "obter preço atual" e sua dependência na interface do <code>StockExchange</code> .  A seguir, mostramos como duas implementações completamente diferentes coexistem e o preço atual não é conhecido.  Além disso, as duas implementações não estão relacionadas uma à outra, cada uma delas depende apenas da interface do <code>StockExchange</code> . <br><br><img src="https://habrastorage.org/webt/c8/us/5_/c8us5_mv_y2tmittjhk33ahgw7i.png"><br><br>  Produção <br><br>  A implementação HTTP original já existe na implementação de <code>analyze</code> primária;  tudo o que resta para nós é extraí-lo e encapsulá-lo atrás de uma implementação concreta da interface. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> HTTPStockExchange <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(se HTTPStockExchange)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CurrentPrice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ticker </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">float64</span></span></span></span> { resp, err := http.Get( <span class="hljs-string"><span class="hljs-string">"http://stock-service.com/currentprice/"</span></span> + ticker ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   } defer resp.Body.Close() body, err := ioutil.ReadAll(resp.Body) // ... return parsePriceFromBody(body) }</span></span></code> </pre> <br>  O código que vinculamos anteriormente à função de análise agora é autônomo e satisfaz a interface do <code>StockExchange</code> , ou seja, agora podemos transmiti-lo para <code>analyze</code> .  Como você se lembra dos diagramas acima, a análise não está mais associada à dependência de HTTP.  Usando a interface, o <code>analyze</code> não "imagina" o que acontece nos bastidores.  Ele só sabe que lhe será garantido um objeto com o qual ele pode chamar <code>CurrentPrice</code> . <br><br>  Também aqui aproveitamos as virtudes típicas do encapsulamento.  Antes, quando as solicitações de http eram vinculadas à análise, a única maneira de se comunicar com a troca via http era indireta - através do método de <code>analyze</code> .  Sim, poderíamos encapsular essas chamadas em funções e executar a função independentemente, mas as interfaces nos forçam a desconectar o chamador do chamador.  Agora podemos testar o <code>HTTPStockExchange</code> independentemente do chamador.  Isso afeta fundamentalmente o escopo de nossos testes e como entendemos e respondemos a falhas de teste. <br><br>  <b>Teste</b> <br><br>  No código existente, temos a estrutura <code>HTTPStockService</code> , que nos permite garantir separadamente que ele pode se comunicar com o serviço de troca e analisar as respostas recebidas dele.  Mas agora vamos garantir que a análise possa manipular corretamente a resposta da interface do <code>StockExchange</code> , além disso, que essa operação seja confiável e reproduzível. <br><br><pre> <code class="go hljs">currentPrice := se.CurrentPrice(ticker) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> currentPrice &lt;= maxTradePrice { err := doTrade(ticker, currentPrice) }</code> </pre> <br>  Nós poderíamos usar a implementação com HTTP, mas isso teria muitas desvantagens.  Fazer chamadas de rede no teste de unidade pode ser lento, especialmente para serviços externos.  Devido a atrasos e uma conexão de rede instável, os testes podem não ser confiáveis.  Além disso, se precisarmos de testes com a declaração de que podemos concluir a transação e testes com a declaração de que podemos filtrar os casos em que a transação NÃO deve ser concluída, seria difícil encontrar dados reais de produção que atendam de maneira confiável a ambos. condições.  Pode-se escolher <code>maxTradePrice</code> , imitando artificialmente cada uma das condições dessa maneira, por exemplo, com <code>maxTradePrice := -100</code> transação não deve ser concluída e <code>maxTradePrice := 10000000</code> obviamente deve terminar com a transação. <br><br>  Mas o que acontece se uma certa cota nos é alocada no serviço de câmbio?  Ou se tivermos que pagar acesso?  Nós realmente (e devemos) pagar ou gastar nossa cota quando se trata de testes de unidade?  Idealmente, os testes devem ser executados o mais rápido possível, para que sejam rápidos, baratos e confiáveis.  Eu acho que, a partir deste parágrafo, fica claro por que usar uma versão com HTTP puro é irracional em termos de teste! <br><br>  <b>Existe uma maneira melhor, e envolve o uso de interfaces!</b> <br><br>  Tendo uma interface, você pode fabricar cuidadosamente a implementação do <code>StockExchange</code> , o que nos permitirá <code>analyze</code> rapidez, segurança e confiabilidade. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> StubExchange <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Price <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(se StubExchange)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CurrentPrice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ticker </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">float64</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> se.Price } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestAnalyze_MakeTrade</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { se := StubExchange{Price: <span class="hljs-number"><span class="hljs-number">10</span></span>} maxTradePrice := <span class="hljs-number"><span class="hljs-number">11</span></span> traded, err := analyze(se, <span class="hljs-string"><span class="hljs-string">"TSLA"</span></span>, maxTradePrice) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { t.Errorf(<span class="hljs-string"><span class="hljs-string">"expected err == nil received: %s"</span></span>, err) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !traded { t.Error(<span class="hljs-string"><span class="hljs-string">"expected traded == true"</span></span>) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestAnalyze_DontTrade</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { se := StubExchange{Price: <span class="hljs-number"><span class="hljs-number">10</span></span>} maxTradePrice := <span class="hljs-number"><span class="hljs-number">9</span></span> traded, err := analyze(se, <span class="hljs-string"><span class="hljs-string">"TSLA"</span></span>, maxTradePrice) <span class="hljs-comment"><span class="hljs-comment">//  }</span></span></code> </pre> <br>  O stub do serviço de câmbio é usado acima, graças ao qual o ramo de interesse para nós na <code>analyze</code> é lançado.  Em seguida, são feitas declarações em cada um dos testes para garantir que a análise faça o que é necessário.  Embora este seja um programa de teste, minha experiência sugere que componentes / arquitetura, onde as interfaces são usadas aproximadamente dessa maneira, também são testados quanto à durabilidade no código de batalha !!!  Graças às interfaces, podemos usar o <code>StockExchange</code> controlado em memória, que fornece testes confiáveis, facilmente configuráveis, fáceis de entender, reprodutíveis e rápidos! <br><br>  <b>Soltar - Configuração do chamador</b> <br><br>  Agora que discutimos como usar interfaces para desconectar o chamador do chamado e como realizar várias implementações, ainda não abordamos um aspecto crítico.  Como configurar e fornecer uma implementação específica em um horário estritamente definido?  Você pode chamar diretamente a função de análise, mas o que fazer na configuração de produção? <br><br>  É aqui que a implementação de dependências é útil. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ticker = flag.String(<span class="hljs-string"><span class="hljs-string">"ticker"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"stock ticker symbol to trade for"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maxTradePrice = flag.Float64(<span class="hljs-string"><span class="hljs-string">"maxtradeprice"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"max price to pay for a share of the ticker symbol."</span></span> se := HTTPStockExchange{} analyze(se, *ticker, *maxTradePrice) }</code> </pre> <br>  Assim como no nosso caso de teste, a implementação concreta específica do StockExchange que será usada com a <code>analyze</code> é configurada pelo chamador fora da análise.  Então é passado (injetado) para <code>analyze</code> .  Isso garante que a análise de nada se saiba sobre como o <code>HTTPStockExchange</code> configurado.  Talvez desejemos fornecer o domínio http que usaremos na forma de um sinalizador de linha de comando e, em seguida, a análise não precisará ser alterada.  Ou o que fazer se precisarmos fornecer algum tipo de autenticação ou token para acessar o <code>HTTPStockExchange</code> , que será extraído do ambiente?  Mais uma vez, a análise não deve mudar. <br><br>  A configuração ocorre em um nível fora da <code>analyze</code> , liberando completamente a análise da necessidade de configurar suas próprias dependências.  Assim, é alcançada uma separação estrita de tarefas. <br><br><img src="https://habrastorage.org/webt/nq/jt/_i/nqjt_id9j2-yc7rzozkrldtrwxq.png"><br><br>  <b>Decisões sobre prateleiras</b> <br><br>  Talvez os exemplos acima sejam suficientes, mas ainda existem muitas outras vantagens em interfaces e injeção de dependência.  As interfaces permitem adiar decisões sobre implementações específicas.  Embora as decisões exijam que decidamos qual comportamento apoiaremos, elas ainda nos permitem tomar decisões sobre implementações específicas posteriormente.  Suponhamos que sabíamos que queríamos fazer transações automatizadas, mas ainda não tínhamos certeza de qual provedor de cotações usaríamos.  Uma classe semelhante de soluções é constantemente tratada ao trabalhar com data warehouses.  O que nosso programa deve usar: mysql, postgres, redis, sistema de arquivos, cassandra?  Por fim, tudo isso são detalhes de implementação, e as interfaces nos permitem adiar as decisões finais sobre esses problemas.  Eles nos permitem desenvolver a lógica de negócios de nossos programas e mudar para soluções tecnológicas específicas no último momento! <br><br>  Apesar de esta técnica deixar muitas possibilidades, algo mágico acontece no nível do planejamento do projeto.  Imagine o que acontecerá se adicionarmos mais uma dependência à interface do Exchange. <br><br><img src="https://habrastorage.org/webt/pb/bf/x-/pbbfx-mcx9oabbpa-tkkeivgtnq.png"><br><br>  Aqui, reconfiguraremos nossa arquitetura na forma de um gráfico acíclico direcionado, para que, assim que concordarmos com os detalhes da interface do Exchange, possamos COMPETITAMENTE continuar trabalhando com o pipeline usando <code>HTTPStockExchange</code> .  Criamos uma situação em que a adição de uma nova pessoa ao projeto nos ajuda a avançar mais rapidamente.  Ajustando nossa arquitetura dessa maneira, é melhor ver onde, quando e por quanto tempo podemos envolver outras pessoas no projeto, a fim de agilizar a entrega de todo o projeto.  Além disso, como a conexão entre nossas interfaces é fraca, geralmente é fácil se envolver no trabalho, começando pelas interfaces de implementação.  Você pode desenvolver, testar e testar o <code>HTTPStockExchange</code> completamente independentemente do nosso programa! <br><br>  A análise de dependências arquitetônicas e o planejamento de acordo com essas dependências podem acelerar drasticamente os projetos.  Usando essa técnica específica, pude concluir rapidamente projetos para os quais vários meses foram alocados. <br><br>  <b>Adiante</b> <br><br>  Agora deve ficar mais claro como as interfaces e a implementação de dependências garantem a durabilidade do programa projetado.  Suponha que alteremos nosso provedor de cotação ou inicie o fluxo de cotas e salve-as em tempo real;  existem tantas outras possibilidades quanto você quiser.  O método de análise em sua forma atual oferecerá suporte a qualquer implementação adequada para integração com a interface do <code>StockExchange</code> . <br><br><pre> <code class="go hljs">se.CurrentPrice(ticker)</code> </pre> <br>  Assim, em muitos casos, você pode fazer sem alterações.  Não em todos, mas nos casos previsíveis que podemos encontrar.  Não estamos apenas imunes à necessidade de alterar o código de <code>analyze</code> e verificar novamente sua funcionalidade principal, mas podemos oferecer facilmente novas implementações ou alternar entre fornecedores.  Também podemos expandir ou atualizar sem problemas as implementações específicas que já temos, sem a necessidade de alterar ou verificar <code>analyze</code> ! <br><br>  Espero que os exemplos acima demonstrem de forma convincente como o enfraquecimento da comunicação entre entidades no programa através do uso de interfaces reorienta completamente as dependências e separa o chamador do chamador.  Graças a esse desapego, o programa não depende de uma implementação específica, mas depende de um <b>comportamento</b> específico.  Esse comportamento pode ser fornecido por uma ampla variedade de implementações.  Esse princípio crítico de design também é chamado de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">digitação de pato</a> . <br><br>  O conceito de interfaces e a dependência do comportamento, e não da implementação, são tão poderosos que considero as interfaces como uma linguagem primitiva - sim, isso é bastante radical.  Espero que os exemplos discutidos acima sejam bastante convincentes, e você concorda que as interfaces e a injeção de dependência devem ser usadas desde o início do projeto.  Em quase todos os projetos em que trabalhei, foi necessário não um, mas pelo menos duas implementações: para produção e para teste. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt428075/">https://habr.com/ru/post/pt428075/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt428063/index.html">Navegadores recusam suporte para TLS 1.0 e 1.1</a></li>
<li><a href="../pt428065/index.html">Menos não significa pior: skyrmions e paredes de domínio em ferromagnetos</a></li>
<li><a href="../pt428067/index.html">AntiFuzzing: Segurança através da obscuridade!?</a></li>
<li><a href="../pt428069/index.html">Otimize o balanceamento de carga na infraestrutura Veeam Backup & Replication</a></li>
<li><a href="../pt428073/index.html">Rust 1.30 Release</a></li>
<li><a href="../pt428077/index.html">React.js: um guia para iniciantes</a></li>
<li><a href="../pt428079/index.html">Aplicando princípios do SOLID para reagir ao desenvolvimento de aplicativos</a></li>
<li><a href="../pt428081/index.html">Usando o RxJS no React Development para gerenciar o estado do aplicativo</a></li>
<li><a href="../pt428083/index.html">A análise da Web influencia a matriz - o sistema estratégico da Avinash Koshik</a></li>
<li><a href="../pt428085/index.html">Frontend responde: top 10 (?) HolyJS 2018 Piter relatórios</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>