<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçü§ù‚Äçüë®üèª üë®üèΩ‚Äçüíº üí§ Mesmo assim, voc√™ n√£o pode faz√™-lo! - Usando interfaces e inje√ß√£o de depend√™ncia para projetos de longo prazo üåÖ üòã üè¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° pessoal! 

 Finalmente, temos um contrato para atualizar o livro de Mark Siman, " Dependency Injection in .NET " - o principal √© que ele termine o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mesmo assim, voc√™ n√£o pode faz√™-lo! - Usando interfaces e inje√ß√£o de depend√™ncia para projetos de longo prazo</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/428075/">  Ol√° pessoal! <br><br>  Finalmente, temos um contrato para atualizar o livro de Mark Siman, " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Dependency Injection in .NET</a> " - o principal √© que ele termine o mais r√°pido poss√≠vel.  Tamb√©m temos um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">livro</a> no editor do respeitado Dinesh Rajput sobre padr√µes de design na primavera 5, onde um dos cap√≠tulos tamb√©m √© dedicado √† implementa√ß√£o de depend√™ncias. <br><br>  H√° muito tempo procuramos um material interessante que lembre os pontos fortes do paradigma de DI e esclare√ßa nosso interesse nele - e agora ele foi encontrado.  √â verdade que o autor preferiu dar exemplos no Go.  Esperamos que isso n√£o impe√ßa que voc√™ siga seus pensamentos e ajude a entender os princ√≠pios gerais da invers√£o de controle e trabalhar com interfaces, se este t√≥pico estiver pr√≥ximo de voc√™. <br><br>  A colora√ß√£o emocional do original √© um pouco mais silenciosa, o n√∫mero de pontos de exclama√ß√£o na tradu√ß√£o √© reduzido.  Boa leitura! <br><a name="habracut"></a><br>  O uso de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">interfaces</a> √© uma t√©cnica compreens√≠vel que permite criar c√≥digo f√°cil de testar e extens√≠vel.  Estive repetidamente convencido de que esta √© a ferramenta de design de arquitetura mais poderosa de todas. <br><br>  O objetivo deste artigo √© explicar o que s√£o interfaces, como s√£o usadas e como fornecem extensibilidade e testabilidade de c√≥digo.  Por fim, o artigo deve mostrar como as interfaces podem ajudar a otimizar o gerenciamento de entrega de software e simplificar o planejamento! <br><br>  <b>Interfaces</b> <br><br>  A interface descreve o contrato.  Dependendo da linguagem ou estrutura, o uso de interfaces pode ser ditado expl√≠cita ou implicitamente.  Portanto, na linguagem Go, as <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">interfaces s√£o ditadas explicitamente</a> .  Se voc√™ tentar usar uma entidade como uma interface, mas ela n√£o ser√° totalmente consistente com as regras dessa interface, ocorrer√° um erro em tempo de compila√ß√£o.  Por exemplo, executando o exemplo acima, obtemos o seguinte erro: <br><br><pre><code class="hljs sql">prog.go:22:85: cannot <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> BadPricer literal (<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> BadPricer) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> StockPricer <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> argument <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> isPricerHigherThan100: BadPricer does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> implement StockPricer (<span class="hljs-keyword"><span class="hljs-keyword">missing</span></span> CurrentPrice method) Program exited.</code> </pre> <br>  Interfaces √© uma ferramenta para ajudar a desconectar o chamador do chamado, isso √© feito usando um contrato. <br><br>  Vamos concretizar esse problema usando um exemplo de programa para negocia√ß√£o autom√°tica de c√¢mbio.  O programa do trader ser√° chamado com um pre√ßo de compra definido e um s√≠mbolo de cota√ß√£o.  Em seguida, o programa ir√° para a bolsa de valores para descobrir a cota√ß√£o atual deste ticker.  Al√©m disso, se o pre√ßo de compra deste ticker n√£o exceder o pre√ßo fixado, o programa far√° uma compra. <br><br><img src="https://habrastorage.org/webt/pp/hx/mv/pphxmvus0-rkxh-vffl9o18bjsq.png"><br><br>  De uma forma simplificada, a arquitetura deste programa pode ser representada da seguinte maneira.  A partir do exemplo acima, fica claro que a opera√ß√£o de obten√ß√£o do pre√ßo atual depende diretamente do protocolo HTTP, pelo qual o programa contata o servi√ßo de c√¢mbio. <br><br>  O estado da <code>Action</code> tamb√©m depende diretamente do HTTP.  Assim, ambos os estados devem entender completamente como usar o HTTP para extrair dados de troca e / ou concluir transa√ß√µes. <br><br>  Aqui est√° a apar√™ncia da implementa√ß√£o: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">analyze</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ticker </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, maxTradePrice </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">, err)</span></span></span></span> { resp, err := http.Get( <span class="hljs-string"><span class="hljs-string">"http://stock-service.com/currentprice/"</span></span> + ticker ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   } defer resp.Body.Close() body, err := ioutil.ReadAll(resp.Body) // ... currentPrice := parsePriceFromBody(body) var hasTraded bool var err error if currentPrice &lt;= maximumTradePrice { err = doTrade(ticker, currentPrice) if err == nil { hasTraded = true } } return hasTraded, err }</span></span></code> </pre> <br>  Aqui, o chamador ( <code>analyze</code> ) depende diretamente do HTTP.  Ela precisa saber como as solicita√ß√µes HTTP s√£o formuladas.  Como √© feita a an√°lise deles?  Como lidar com novas tentativas, tempos limite, autentica√ß√£o, etc.  Ela tem um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">controle</a> pr√≥ximo do <code>http</code> .  <b>Sempre que chamamos de an√°lise, tamb√©m devemos chamar a biblioteca <code>http</code></b> . <br><br>  Como a interface pode nos ajudar aqui?  No contrato fornecido pela interface, voc√™ pode descrever o <b>comportamento</b> , e n√£o a <b>implementa√ß√£o</b> espec√≠fica. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> StockExchange <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { CurrentPrice(ticker <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> }</code> </pre> <br>  O exposto acima define o conceito do <code>StockExchange</code> .  Diz aqui que o <code>StockExchange</code> suporta a chamada da √∫nica fun√ß√£o <code>CurrentPrice</code> .  Essas tr√™s linhas me parecem a t√©cnica arquitet√¥nica mais poderosa de todas.  Eles nos ajudam a controlar as depend√™ncias de aplicativos com muito mais confian√ßa.  Fornecer testes.  Forne√ßa extensibilidade. <br><br>  <b>Inje√ß√£o de Depend√™ncia</b> <br><br>  Para entender completamente o valor das interfaces, voc√™ precisa dominar a t√©cnica chamada "inje√ß√£o de depend√™ncia". <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Inje√ß√£o de depend√™ncia</a> significa que o chamador fornece algo necess√°rio ao chamador.  Geralmente fica assim: o chamador configura o objeto e depois o passa para o chamado.  Em seguida, a parte chamada abstrai da configura√ß√£o e implementa√ß√£o.  Nesse caso, h√° uma media√ß√£o conhecida.  Considere uma solicita√ß√£o para o servi√ßo HTTP Rest.  Para implementar o cliente, precisamos usar uma biblioteca HTTP que possa formular, enviar e receber solicita√ß√µes HTTP. <br><br>  Se colocarmos a solicita√ß√£o HTTP atr√°s da interface, o chamador poder√° ser desconectado e ela "n√£o saber√°" que a solicita√ß√£o HTTP realmente ocorreu. <br><br>  O chamador deve fazer apenas uma chamada de fun√ß√£o gen√©rica.  Pode ser uma chamada local, uma chamada remota, uma chamada HTTP, uma chamada RPC, etc.  O interlocutor n√£o est√° ciente do que est√° acontecendo e, geralmente, combina perfeitamente com ela, desde que obtenha os resultados esperados.  A seguir, mostramos como seria a inje√ß√£o de depend√™ncia em nosso m√©todo de <code>analyze</code> . <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">analyze</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(se StockExchange, ticker </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, maxTradePrice </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { currentPrice := se.CurrentPrice(ticker) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hasTraded <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> err error <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> currentPrice &lt;= maximumTradePrice { err = doTrade(ticker, currentPrice) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { hasTraded = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasTraded, err }</code> </pre> <br>  Nunca deixo de me surpreender com o que est√° acontecendo aqui.  Invertemos completamente nossa √°rvore de depend√™ncia e come√ßamos a controlar melhor o programa inteiro.  Al√©m disso, mesmo visualmente toda a implementa√ß√£o se tornou mais limpa e compreens√≠vel.  Vimos claramente que o m√©todo de an√°lise deve escolher o pre√ßo atual, verificar se esse pre√ßo √© adequado para n√≥s e, se for o caso, fazer um acordo. <br><br>  Mais importante, nesse caso, desconectamos o chamador do chamador.  Como o chamador e toda a implementa√ß√£o s√£o separados da chamada usando a interface, voc√™ pode estender a interface criando muitas implementa√ß√µes diferentes.  As interfaces permitem criar muitas implementa√ß√µes espec√≠ficas diferentes, sem a necessidade de alterar o c√≥digo da parte chamada! <br><br><img src="https://habrastorage.org/webt/c8/us/5_/c8us5_mv_y2tmittjhk33ahgw7i.png"><br><br>  O status "obter pre√ßo atual" neste programa depende apenas da interface do <code>StockExchange</code> .  Esta implementa√ß√£o n√£o sabe <b>nada</b> sobre como entrar em contato com o servi√ßo de troca, como os pre√ßos s√£o armazenados ou como s√£o feitas as solicita√ß√µes.  Verdadeira ignor√¢ncia feliz.  Al√©m disso, bilateral.  A implementa√ß√£o <code>HTTPStockExchange</code> tamb√©m n√£o sabe nada sobre a an√°lise.  Sobre o contexto em que a an√°lise ser√° realizada, quando realizada - porque os desafios ocorrem indiretamente. <br><br>  Como os fragmentos de programa (aqueles que dependem de interfaces) n√£o precisam ser alterados ao alterar / adicionar / excluir implementa√ß√µes espec√≠ficas, <b>esse design acaba sendo dur√°vel</b> .  Suponha que descobrimos que o <code>StockService</code> geralmente n√£o <code>StockService</code> dispon√≠vel. <br><br>  Como o exemplo acima √© diferente de chamar uma fun√ß√£o?  Ao aplicar uma chamada de fun√ß√£o, a implementa√ß√£o tamb√©m ficar√° mais limpa.  A diferen√ßa √© que, quando voc√™ chama a fun√ß√£o, ainda precisamos recorrer ao HTTP.  O m√©todo de <code>analyze</code> simplesmente delegar√° a tarefa da fun√ß√£o, que deve chamar <code>http</code> , em vez de chamar o pr√≥prio <code>http</code> diretamente.  Toda a for√ßa dessa t√©cnica est√° na "inje√ß√£o", ou seja, na medida em que o chamador fornece a interface para o chamado.  √â exatamente assim que ocorre a invers√£o de depend√™ncia, em que os pre√ßos de obten√ß√£o dependem apenas da interface e n√£o da implementa√ß√£o. <br><br>  <b>V√°rias implementa√ß√µes prontas para uso</b> <br><br>  Nesta fase, temos a fun√ß√£o de <code>analyze</code> e a interface <code>StockExchange</code> , mas na verdade n√£o podemos fazer nada de √∫til.  Acabei de anunciar nosso programa.  No momento, √© imposs√≠vel cham√°-lo, pois ainda n√£o temos uma √∫nica implementa√ß√£o espec√≠fica que atenda aos requisitos de nossa interface. <br><br>  A √™nfase principal no diagrama a seguir √© feita no estado "obter pre√ßo atual" e sua depend√™ncia na interface do <code>StockExchange</code> .  A seguir, mostramos como duas implementa√ß√µes completamente diferentes coexistem e o pre√ßo atual n√£o √© conhecido.  Al√©m disso, as duas implementa√ß√µes n√£o est√£o relacionadas uma √† outra, cada uma delas depende apenas da interface do <code>StockExchange</code> . <br><br><img src="https://habrastorage.org/webt/c8/us/5_/c8us5_mv_y2tmittjhk33ahgw7i.png"><br><br>  Produ√ß√£o <br><br>  A implementa√ß√£o HTTP original j√° existe na implementa√ß√£o de <code>analyze</code> prim√°ria;  tudo o que resta para n√≥s √© extra√≠-lo e encapsul√°-lo atr√°s de uma implementa√ß√£o concreta da interface. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> HTTPStockExchange <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(se HTTPStockExchange)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CurrentPrice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ticker </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">float64</span></span></span></span> { resp, err := http.Get( <span class="hljs-string"><span class="hljs-string">"http://stock-service.com/currentprice/"</span></span> + ticker ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   } defer resp.Body.Close() body, err := ioutil.ReadAll(resp.Body) // ... return parsePriceFromBody(body) }</span></span></code> </pre> <br>  O c√≥digo que vinculamos anteriormente √† fun√ß√£o de an√°lise agora √© aut√¥nomo e satisfaz a interface do <code>StockExchange</code> , ou seja, agora podemos transmiti-lo para <code>analyze</code> .  Como voc√™ se lembra dos diagramas acima, a an√°lise n√£o est√° mais associada √† depend√™ncia de HTTP.  Usando a interface, o <code>analyze</code> n√£o "imagina" o que acontece nos bastidores.  Ele s√≥ sabe que lhe ser√° garantido um objeto com o qual ele pode chamar <code>CurrentPrice</code> . <br><br>  Tamb√©m aqui aproveitamos as virtudes t√≠picas do encapsulamento.  Antes, quando as solicita√ß√µes de http eram vinculadas √† an√°lise, a √∫nica maneira de se comunicar com a troca via http era indireta - atrav√©s do m√©todo de <code>analyze</code> .  Sim, poder√≠amos encapsular essas chamadas em fun√ß√µes e executar a fun√ß√£o independentemente, mas as interfaces nos for√ßam a desconectar o chamador do chamador.  Agora podemos testar o <code>HTTPStockExchange</code> independentemente do chamador.  Isso afeta fundamentalmente o escopo de nossos testes e como entendemos e respondemos a falhas de teste. <br><br>  <b>Teste</b> <br><br>  No c√≥digo existente, temos a estrutura <code>HTTPStockService</code> , que nos permite garantir separadamente que ele pode se comunicar com o servi√ßo de troca e analisar as respostas recebidas dele.  Mas agora vamos garantir que a an√°lise possa manipular corretamente a resposta da interface do <code>StockExchange</code> , al√©m disso, que essa opera√ß√£o seja confi√°vel e reproduz√≠vel. <br><br><pre> <code class="go hljs">currentPrice := se.CurrentPrice(ticker) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> currentPrice &lt;= maxTradePrice { err := doTrade(ticker, currentPrice) }</code> </pre> <br>  N√≥s poder√≠amos usar a implementa√ß√£o com HTTP, mas isso teria muitas desvantagens.  Fazer chamadas de rede no teste de unidade pode ser lento, especialmente para servi√ßos externos.  Devido a atrasos e uma conex√£o de rede inst√°vel, os testes podem n√£o ser confi√°veis.  Al√©m disso, se precisarmos de testes com a declara√ß√£o de que podemos concluir a transa√ß√£o e testes com a declara√ß√£o de que podemos filtrar os casos em que a transa√ß√£o N√ÉO deve ser conclu√≠da, seria dif√≠cil encontrar dados reais de produ√ß√£o que atendam de maneira confi√°vel a ambos. condi√ß√µes.  Pode-se escolher <code>maxTradePrice</code> , imitando artificialmente cada uma das condi√ß√µes dessa maneira, por exemplo, com <code>maxTradePrice := -100</code> transa√ß√£o n√£o deve ser conclu√≠da e <code>maxTradePrice := 10000000</code> obviamente deve terminar com a transa√ß√£o. <br><br>  Mas o que acontece se uma certa cota nos √© alocada no servi√ßo de c√¢mbio?  Ou se tivermos que pagar acesso?  N√≥s realmente (e devemos) pagar ou gastar nossa cota quando se trata de testes de unidade?  Idealmente, os testes devem ser executados o mais r√°pido poss√≠vel, para que sejam r√°pidos, baratos e confi√°veis.  Eu acho que, a partir deste par√°grafo, fica claro por que usar uma vers√£o com HTTP puro √© irracional em termos de teste! <br><br>  <b>Existe uma maneira melhor, e envolve o uso de interfaces!</b> <br><br>  Tendo uma interface, voc√™ pode fabricar cuidadosamente a implementa√ß√£o do <code>StockExchange</code> , o que nos permitir√° <code>analyze</code> rapidez, seguran√ßa e confiabilidade. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> StubExchange <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Price <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(se StubExchange)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CurrentPrice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ticker </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">float64</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> se.Price } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestAnalyze_MakeTrade</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { se := StubExchange{Price: <span class="hljs-number"><span class="hljs-number">10</span></span>} maxTradePrice := <span class="hljs-number"><span class="hljs-number">11</span></span> traded, err := analyze(se, <span class="hljs-string"><span class="hljs-string">"TSLA"</span></span>, maxTradePrice) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { t.Errorf(<span class="hljs-string"><span class="hljs-string">"expected err == nil received: %s"</span></span>, err) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !traded { t.Error(<span class="hljs-string"><span class="hljs-string">"expected traded == true"</span></span>) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestAnalyze_DontTrade</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { se := StubExchange{Price: <span class="hljs-number"><span class="hljs-number">10</span></span>} maxTradePrice := <span class="hljs-number"><span class="hljs-number">9</span></span> traded, err := analyze(se, <span class="hljs-string"><span class="hljs-string">"TSLA"</span></span>, maxTradePrice) <span class="hljs-comment"><span class="hljs-comment">//  }</span></span></code> </pre> <br>  O stub do servi√ßo de c√¢mbio √© usado acima, gra√ßas ao qual o ramo de interesse para n√≥s na <code>analyze</code> √© lan√ßado.  Em seguida, s√£o feitas declara√ß√µes em cada um dos testes para garantir que a an√°lise fa√ßa o que √© necess√°rio.  Embora este seja um programa de teste, minha experi√™ncia sugere que componentes / arquitetura, onde as interfaces s√£o usadas aproximadamente dessa maneira, tamb√©m s√£o testados quanto √† durabilidade no c√≥digo de batalha !!!  Gra√ßas √†s interfaces, podemos usar o <code>StockExchange</code> controlado em mem√≥ria, que fornece testes confi√°veis, facilmente configur√°veis, f√°ceis de entender, reprodut√≠veis e r√°pidos! <br><br>  <b>Soltar - Configura√ß√£o do chamador</b> <br><br>  Agora que discutimos como usar interfaces para desconectar o chamador do chamado e como realizar v√°rias implementa√ß√µes, ainda n√£o abordamos um aspecto cr√≠tico.  Como configurar e fornecer uma implementa√ß√£o espec√≠fica em um hor√°rio estritamente definido?  Voc√™ pode chamar diretamente a fun√ß√£o de an√°lise, mas o que fazer na configura√ß√£o de produ√ß√£o? <br><br>  √â aqui que a implementa√ß√£o de depend√™ncias √© √∫til. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ticker = flag.String(<span class="hljs-string"><span class="hljs-string">"ticker"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"stock ticker symbol to trade for"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maxTradePrice = flag.Float64(<span class="hljs-string"><span class="hljs-string">"maxtradeprice"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"max price to pay for a share of the ticker symbol."</span></span> se := HTTPStockExchange{} analyze(se, *ticker, *maxTradePrice) }</code> </pre> <br>  Assim como no nosso caso de teste, a implementa√ß√£o concreta espec√≠fica do StockExchange que ser√° usada com a <code>analyze</code> √© configurada pelo chamador fora da an√°lise.  Ent√£o √© passado (injetado) para <code>analyze</code> .  Isso garante que a an√°lise de nada se saiba sobre como o <code>HTTPStockExchange</code> configurado.  Talvez desejemos fornecer o dom√≠nio http que usaremos na forma de um sinalizador de linha de comando e, em seguida, a an√°lise n√£o precisar√° ser alterada.  Ou o que fazer se precisarmos fornecer algum tipo de autentica√ß√£o ou token para acessar o <code>HTTPStockExchange</code> , que ser√° extra√≠do do ambiente?  Mais uma vez, a an√°lise n√£o deve mudar. <br><br>  A configura√ß√£o ocorre em um n√≠vel fora da <code>analyze</code> , liberando completamente a an√°lise da necessidade de configurar suas pr√≥prias depend√™ncias.  Assim, √© alcan√ßada uma separa√ß√£o estrita de tarefas. <br><br><img src="https://habrastorage.org/webt/nq/jt/_i/nqjt_id9j2-yc7rzozkrldtrwxq.png"><br><br>  <b>Decis√µes sobre prateleiras</b> <br><br>  Talvez os exemplos acima sejam suficientes, mas ainda existem muitas outras vantagens em interfaces e inje√ß√£o de depend√™ncia.  As interfaces permitem adiar decis√µes sobre implementa√ß√µes espec√≠ficas.  Embora as decis√µes exijam que decidamos qual comportamento apoiaremos, elas ainda nos permitem tomar decis√µes sobre implementa√ß√µes espec√≠ficas posteriormente.  Suponhamos que sab√≠amos que quer√≠amos fazer transa√ß√µes automatizadas, mas ainda n√£o t√≠nhamos certeza de qual provedor de cota√ß√µes usar√≠amos.  Uma classe semelhante de solu√ß√µes √© constantemente tratada ao trabalhar com data warehouses.  O que nosso programa deve usar: mysql, postgres, redis, sistema de arquivos, cassandra?  Por fim, tudo isso s√£o detalhes de implementa√ß√£o, e as interfaces nos permitem adiar as decis√µes finais sobre esses problemas.  Eles nos permitem desenvolver a l√≥gica de neg√≥cios de nossos programas e mudar para solu√ß√µes tecnol√≥gicas espec√≠ficas no √∫ltimo momento! <br><br>  Apesar de esta t√©cnica deixar muitas possibilidades, algo m√°gico acontece no n√≠vel do planejamento do projeto.  Imagine o que acontecer√° se adicionarmos mais uma depend√™ncia √† interface do Exchange. <br><br><img src="https://habrastorage.org/webt/pb/bf/x-/pbbfx-mcx9oabbpa-tkkeivgtnq.png"><br><br>  Aqui, reconfiguraremos nossa arquitetura na forma de um gr√°fico ac√≠clico direcionado, para que, assim que concordarmos com os detalhes da interface do Exchange, possamos COMPETITAMENTE continuar trabalhando com o pipeline usando <code>HTTPStockExchange</code> .  Criamos uma situa√ß√£o em que a adi√ß√£o de uma nova pessoa ao projeto nos ajuda a avan√ßar mais rapidamente.  Ajustando nossa arquitetura dessa maneira, √© melhor ver onde, quando e por quanto tempo podemos envolver outras pessoas no projeto, a fim de agilizar a entrega de todo o projeto.  Al√©m disso, como a conex√£o entre nossas interfaces √© fraca, geralmente √© f√°cil se envolver no trabalho, come√ßando pelas interfaces de implementa√ß√£o.  Voc√™ pode desenvolver, testar e testar o <code>HTTPStockExchange</code> completamente independentemente do nosso programa! <br><br>  A an√°lise de depend√™ncias arquitet√¥nicas e o planejamento de acordo com essas depend√™ncias podem acelerar drasticamente os projetos.  Usando essa t√©cnica espec√≠fica, pude concluir rapidamente projetos para os quais v√°rios meses foram alocados. <br><br>  <b>Adiante</b> <br><br>  Agora deve ficar mais claro como as interfaces e a implementa√ß√£o de depend√™ncias garantem a durabilidade do programa projetado.  Suponha que alteremos nosso provedor de cota√ß√£o ou inicie o fluxo de cotas e salve-as em tempo real;  existem tantas outras possibilidades quanto voc√™ quiser.  O m√©todo de an√°lise em sua forma atual oferecer√° suporte a qualquer implementa√ß√£o adequada para integra√ß√£o com a interface do <code>StockExchange</code> . <br><br><pre> <code class="go hljs">se.CurrentPrice(ticker)</code> </pre> <br>  Assim, em muitos casos, voc√™ pode fazer sem altera√ß√µes.  N√£o em todos, mas nos casos previs√≠veis que podemos encontrar.  N√£o estamos apenas imunes √† necessidade de alterar o c√≥digo de <code>analyze</code> e verificar novamente sua funcionalidade principal, mas podemos oferecer facilmente novas implementa√ß√µes ou alternar entre fornecedores.  Tamb√©m podemos expandir ou atualizar sem problemas as implementa√ß√µes espec√≠ficas que j√° temos, sem a necessidade de alterar ou verificar <code>analyze</code> ! <br><br>  Espero que os exemplos acima demonstrem de forma convincente como o enfraquecimento da comunica√ß√£o entre entidades no programa atrav√©s do uso de interfaces reorienta completamente as depend√™ncias e separa o chamador do chamador.  Gra√ßas a esse desapego, o programa n√£o depende de uma implementa√ß√£o espec√≠fica, mas depende de um <b>comportamento</b> espec√≠fico.  Esse comportamento pode ser fornecido por uma ampla variedade de implementa√ß√µes.  Esse princ√≠pio cr√≠tico de design tamb√©m √© chamado de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">digita√ß√£o de pato</a> . <br><br>  O conceito de interfaces e a depend√™ncia do comportamento, e n√£o da implementa√ß√£o, s√£o t√£o poderosos que considero as interfaces como uma linguagem primitiva - sim, isso √© bastante radical.  Espero que os exemplos discutidos acima sejam bastante convincentes, e voc√™ concorda que as interfaces e a inje√ß√£o de depend√™ncia devem ser usadas desde o in√≠cio do projeto.  Em quase todos os projetos em que trabalhei, foi necess√°rio n√£o um, mas pelo menos duas implementa√ß√µes: para produ√ß√£o e para teste. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt428075/">https://habr.com/ru/post/pt428075/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt428063/index.html">Navegadores recusam suporte para TLS 1.0 e 1.1</a></li>
<li><a href="../pt428065/index.html">Menos n√£o significa pior: skyrmions e paredes de dom√≠nio em ferromagnetos</a></li>
<li><a href="../pt428067/index.html">AntiFuzzing: Seguran√ßa atrav√©s da obscuridade!?</a></li>
<li><a href="../pt428069/index.html">Otimize o balanceamento de carga na infraestrutura Veeam Backup & Replication</a></li>
<li><a href="../pt428073/index.html">Rust 1.30 Release</a></li>
<li><a href="../pt428077/index.html">React.js: um guia para iniciantes</a></li>
<li><a href="../pt428079/index.html">Aplicando princ√≠pios do SOLID para reagir ao desenvolvimento de aplicativos</a></li>
<li><a href="../pt428081/index.html">Usando o RxJS no React Development para gerenciar o estado do aplicativo</a></li>
<li><a href="../pt428083/index.html">A an√°lise da Web influencia a matriz - o sistema estrat√©gico da Avinash Koshik</a></li>
<li><a href="../pt428085/index.html">Frontend responde: top 10 (?) HolyJS 2018 Piter relat√≥rios</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>