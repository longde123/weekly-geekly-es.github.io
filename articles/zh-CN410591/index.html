<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📦 👩🏻‍🍳 🈹 70年代至90年代初第一台计算机的处理器的情感历史 🕑 🕤 😸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我碰巧在不同处理器的汇编器中编程。 排在最后的是Xilinx MicroBlaze。 我决定就这些几乎不可思议的铁件的功能发表一些看法，就像匹诺曹的魔术钥匙一样，它们在虚拟现实和大众创造力的神奇土地上为我们打开了大门。 关于现代系统x86，x86-64，ARM，ARM-64等的功能 我可能不会再写了...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>70年代至90年代初第一台计算机的处理器的情感历史</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/410591/"> 我碰巧在不同处理器的汇编器中编程。 排在最后的是Xilinx MicroBlaze。 我决定就这些几乎不可思议的铁件的功能发表一些看法，就像匹诺曹的魔术钥匙一样，它们在虚拟现实和大众创造力的神奇土地上为我们打开了大门。 关于现代系统x86，x86-64，ARM，ARM-64等的功能 我可能不会再写了，这个话题很大而且很复杂。 因此，我计划以Intel 80486和Motorola 68040结尾。我还想包括我正在处理的IBM / 370。 这些系统离用户群还很远，但是同时对计算机技术产生了巨大的影响。 他们只是没有为该主题分配足够的时间，他们没有使用处理器芯片，并且由于某种原因，它们本身似乎已经完全消失了。 我真的希望我的资料能吸引行家的注意，他们可以添加一些他们从未考虑过或不知道的内容。 <br><br> 作为说明材料，我附上了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Rosetta的一块</a>小<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">石头</a> -用于使用快门算法在不同处理器和系统上计算数量π的程序，该程序声称是最快的实现方法。 <br><br><a name="habracut"></a><br><h2> 英特尔8080和8085 </h2><br>  1974年上半年制造出的第一个真正的芯片上处理器，目前仍在生产中并正在使用。 在世界范围内被克隆很多次，在苏联它的代号为KR580VM80A。 从某种意义上说，现代的PC英特尔处理器仍然可以轻松地显示出其对这款遗留产品的亲和力。 我本人未为该处理器编写代码，但是熟悉z80的体系结构，所以我敢提出一些意见。 <br><br> 像其他用于PC的英特尔处理器一样，8080指令系统很难被称为理想处理器，但它具有通用性，灵活性和强大的吸引力。 与其他竞争对手相比，摩托罗拉6800和MOS Technology 6502、8080在数量上略有不同，尽管它们有些笨拙，但却为用户提供了一个8位电池A，一个16位半累加器和兼职快速HL索引寄存器，16位SP堆栈指针，以及另外两个16位寄存器Sun和DE。 寄存器BC，DE和HL可用作6字节寄存器。 此外，8080还支持一组几乎完整的状态标志：进位，符号，零位，甚至奇偶校验和半传输。  8080指令集中的某些指令长期以来一直是速度冠军。 例如，XCHG命令仅在4个时钟周期内交换16位DE和HL寄存器的内容-速度非常快！ 许多其他团队虽然没有创造如此生动的记录，但长期以来也处于最佳状态： <br><br><ul><li>  XTHL-在堆栈顶部交换HL寄存器的内容和数据，需要18个时钟周期-这似乎很多，即使在真正的16位8086上，这样的命令也需要22个时钟周期，而对于6800或6502来说，很难想象这样的命令; </li><li>  DAD-将10个时钟周期的另一个16位寄存器（BC，DE甚至SP）添加到HL半累加器。 通过设置进位标志，这是真正的16位加法。 如果您自己加上HL，您将获得快速的16位左移或2倍乘法运算，这是全乘法和除法运算的关键操作； </li><li>  PUSH和POP-分别放在堆栈中，并从堆栈中或从寄存器中分别从堆栈中删除16位值。 以11和10个周期执行。 这些是8080处理内存的最快操作，并且在性能方面SP会自动递增或递减。 例如，可以使用PUSH使用具有来自3个寄存器（BC，DE，HL）的值的模式快速填充存储器。 根本没有命令可以处理带有堆栈的8位数据。 </li><li>  LXI-在16个时钟周期内将16位常量加载到寄存器（HL，DE，BC，SP）； </li><li>  RNZ，RZ，RNC，RC，RPO，RPE，RP，RM-子例程的条件返回，使代码更整洁，无需编写额外的条件分支。 这些团队被遗弃在x86架构中，可能徒劳的代码变得更好了。 </li></ul><br> 该处理器用在第一台Altair 8800个人计算机中，该计算机在1975年初的杂志出版后变得非常流行。顺便说一句，苏联的类似出版物直到1980年才出现，其相关性直到1986年才出现。 <br><br><img src="https://img.newatlas.com/altair-8800-clone-0.jpg?auto=format%2Ccompress&amp;fit=max&amp;h=670&amp;q=60&amp;w=1000&amp;s=a0b62f09568803467c43a40736f5f4df" align="left"><br>  <i>首先几乎是个人电脑</i> <i><br></i> <br> 英特尔8080成为开发了第一个大规模专业CP / M操作系统的基础，该操作系统在1980年代中期之前一直占据着微型计算机的主导地位。 <br><br> 现在谈谈缺点。  8080需要三个电压-5、5和12伏。 处理中断既麻烦又缓慢。 通常，如果我们将8080与即将面世的竞争对手进行比较，则它并不放松。 当以与8080相同的频率运行时，6502可能会快3倍。 <br><br> 但是，在8080的体系结构中，事实证明这是对未来的正确愿景，即70年代未知的事实是处理器将比内存快。  8080 DE和BC寄存器比通用寄存器更像是现代手动缓存的原型。  8080的起始频率为2 MHz，而竞争对手的起始频率仅为1，这消除了性能上的差异。 <br><br> 很难将8080称为100％的8位处理器。 当然，他有一个8位ALU，但是有许多16位指令比仅使用8位模拟量要快。 对于某些团队来说，根本没有8位类似物。  XCHG团队的本质和时间安排是100％16位。 有真正的16位寄存器。 因此，我敢于部分地将8080称为16位。 从符号总数计算处理器容量指数很有趣，但是据作者所知，还没有人做过这样的工作。 <br><br> 作者不知道英特尔为何拒绝直接支持使用其处理器开发8位PC的原因。 英特尔始终以政治的复杂性和歧义性而著称。 长期以来，英特尔一直在以色列经营工厂，直到90年代末一直是秘密的事实，说明了它与政治的联系。 英特尔实际上并没有尝试改进8080，而是将时钟频率仅提高到了3MHz（小MHz）。 实际上，使用相关的8080 z80处理器将8位市场转移到Zilog，该处理器能够非常成功地与主要竞争对手“终结者” 6502对抗。 <br><br> 在苏联和俄罗斯，国产克隆8080成为许多大众计算机的基础，这些计算机一直流行到90年代初。 当然，这是Radio-86RK，Mikrosh，多色Orion-128，Vector和Corvette。 但是，廉价且经过改进的基于zX Spectrum z80的zX克隆击败了Clone Wars。 <br><br><img src="https://www.old-games.ru/forum/attachments/d64acd00877a00143c992eeffc16e35d-jpg.75531/"><br>  <i>这是一台真正的PC。</i> <br><br>  1976年初，英特尔推出了8085处理器，该处理器与8080兼容，但远远优于其前身。 它已经不需要-5和12伏特的电源，并且简化了连接图，改进了中断的工作，时钟频率从3提升至非常坚固的6 MHz，命令系统扩展了几个有用的指令：16位减法，16位移位在短短7个周期内向右移动（这是非常快的），通过传输标志向左旋转16位，加载具有8位偏移量的16位寄存器（此命令也可以与SP堆栈指针一起使用），将HL寄存器写入DE寄存器中的地址类似于h  HL流经DE。 除向右移动外，所有上述指令均以10个周期执行-有时比其相应指令或z80上的仿真要快得多。 添加了更多的指令，甚至两个新的标志标记。 在新标记中，值得注意的是溢出标记，尽管实际上不支持使用它。 此外，许多用于处理字节数据的指令也得到了快速发展。 这是非常重要的，因为在许多具有8080或z80的系统上，引入了延迟滴答，由于8080上存在额外的滴答，因此延迟了执行时间几乎两倍。 例如，在家用计算机中，寄存器-寄存器类型的Vector指令执行了8个时钟周期，如果那里有8085或z80，则这些相同的指令将仅在4个时钟周期中执行。  XTHL指令甚至快了两步。 使用新指令，您可以编写代码以复制存储块，这比Z80处理器的LDI / LDD命令快！ 但是，某些指令（例如16位递增和递减，PUSH和条件返回）每个时钟变慢。 <br><br>  8085具有处理中断的内置支持，在许多情况下，无需系统中有单独的中断控制器和串行输入/输出端口，就可以进行处理。 如前所述，在8085中，它们没有完全支持溢出标志，因此带符号的数字算术仍然有些不完整。 <br><br> 但是，我可以再次重复公式“由于作者不明的原因”，英特尔拒绝推广8085作为主处理器。 直到80年代，才出现了一些相当成功的基于8085的系统，第一台于1981年成为IBM PC的前身，几乎是其竞争对手-IBM System / 23 Datamaster。 然后在1982年，发布了一款具有出色图形性能的真力时Z-100的非常快的计算机，其中8085在5 MHz下工作。  1983年，日本Kyotronic公司创建了非常成功的KC-85护膝，其他公司也生产了该护膝的变体：Tandy生产了TRS-80 100型，NEC-PC-8201a，Olivetti-M-10。 总共发布了超过一千万的此类计算机！ 在90年代初期的苏联/ RF中，基于国产克隆IM1821VM85A的尝试试图改进某些系统，例如矢量计算机。 令人惊讶的是，1997年到达火星的Sojourner流浪者的主处理器是8085，频率为2 MHz！ <br><br> 实际上，英特尔为z80赋予了绿色。 几年后，在争夺16位市场的竞争中，英特尔的行为完全不同，开始提起诉讼，禁止在美国销售v20和v30处理器。 有趣的是，日本NEC公司提到的处理器可以切换到与8080完全二进制兼容的模式，这使它们成为8080体系结构中最快的处理器。 <br><br> 英特尔的另一个秘密是拒绝发布扩展的命令系统，包括对新标志的支持。 但是，这些处理器的官方制造商之一已发布了整个团队系统。 如此奇怪的拒绝的原因是什么？ 一个只能猜。 也许Zilog扮演的角色与AMD曾经扮演过的角色相似，并且创造了竞争的面貌，而8085可以使Zilog破产吗？ 也许关键是希望使命令系统更接近于当时设计的8086？ 后者似乎令人怀疑。 英特尔8086在8085发布之后已经发布了两年多，很难相信它的命令系统在1975年就已经为人所知。 在任何情况下，都只能使用宏处理器来实现与8080和8085至8086的兼容性，有时还可以用自己的几个替换一个8080/8085命令。 而且，两个发布的新指令8085在8086中根本不可行。 很难解释为什么英特尔在8086发布后不发布有关新团队的信息。我们只能假设这很可能是市场问题。 人为地恶化了8085的规格，在这种背景下，我们得到了更出色的8086。 <br><br><h2> 摩托罗拉6800及其近亲 </h2><br> 摩托罗拉处理器一直以几个非常吸引人的“亮点”而著称，同时还存在一些抽象性和实用性低下的架构解决方案。 所有相关处理器的主要“亮点”是第二个完整且非常快速的寄存器电池。 <br><br>  6800是世界上第一个只需要一个电源（5伏）的处理器-这是非常有用的创新。 由于16位索引寄存器的独特性（对于8位体系结构而言很麻烦），因此Ho 6800对该产品的编程和使用造成了不便。 它于1974年发布，不晚于8080，但从未成为任何著名计算机系统的基础。 有趣的是，6502开发人员Chuck Peddle和Bill Mensch称6800错误为“太大”。 但是，他和他的变体被广泛用作微控制器。 也许值得一提的是，英特尔自1971年以来就开始制造处理器，这使摩托罗拉处于领先地位，而6800是第一个处理器。 如果您将6800与8080而不是其前身8008进行比较，那么6800将是更可取的。 摩托罗拉以68000/20/30/40几乎赶上了英特尔。 您可能还会注意到，在70年代，摩托罗拉是一家比英特尔更大的公司。 <br><br> 还生产了许多6800变体：6801、6802、6803、6805，...它们中的大多数是带有内置存储器和输入/输出端口的微控制器。  6803是6801的简化版本，在很晚的时候（1983年）就用于其一流的计算机Tandy TRS-80 MC-10和其法国克隆的Matra Alice，与Commodore VIC-20（1980）或Sinclair ZX81（1981）相当。  6801/6803指令系统得到了显着改进，增加了16位指令，乘法。...出现了一种不寻常的无条件分支指令（BRN-从不分支），该分支从未执行！ 一些说明变得更快。 <br><br>  680x完全支持带符号整数的工作，z80和6502支持的情况更糟，而8080和8085几乎没有这种支持。 但是，在8位软件中，很少需要这种支持。 <br><br>  6809于1978年发布，当时16位时代已经从8086开始，并且具有非常完善的命令系统，包括将两个字节的电池相乘以在11个周期内获得16位结果（相比之下，8086进行此操作需要70个周期） 。 在某些情况下，两节电池可以组合为一个16位，从而给出快速的16位指令。  6809在8位处理器-12中具有两个索引寄存器和创纪录的寻址方法。在这些寻址方法中，对于8位芯片来说是唯一的，例如相对于指令计数器具有自动递增或递减的索引，具有偏移量的索引。  6809有使用两种类型的中断的有趣机会：您可以使用具有部分自动寄存器保存功能的快速中断和具有完​​整寄存器保存功能的中断-6809具有用于中断信号FIRQ（快速屏蔽），IRQ（可屏蔽），NMI（非屏蔽）的三个输入。 使用快速指令一次读取和设置所有标志有时也很方便。 <br><br> 但是，内存操作需要超过6502个时钟周期，索引寄存器在8位环境中仍然是笨拙的16位恐龙，有些操作由于其速度太慢而令人震惊，例如，将一个字节的电池转移到另一个字节需要6个周期，并且交换它们的内容为8个周期（与8080相比，其中4个周期进行16位交换）！ 由于某种原因，立即提供了两个堆栈指针，这可能是死锁体系结构VAX-11的影响-在具有64 KB内存的8位体系结构中，它看起来很尴尬。 甚至存在一个有趣的名称SEX的指令也不能解决6809的所有问题。 通常，在相同的频率下6809仍比6502快一些，但是它需要相同的存储速度。 我设法用32位除数和16位除法器（32/16 = 32.16）对6809进行了除法，仅进行了520个以上的周期，而对于6502，我的除法不能少于650个。 第二个电池是一个很大的优势，但是6502的其他功能（尤其是反向传输）只能将此优势降低到指定的25％。 但是事实证明，与16位常量的乘积比6502的表与768字节的表的乘积要慢。  6809允许您使用已安装页面（直接页面）的寻址来编写紧凑而快速的代码，但是这种寻址方式使代码变得相当混乱。 该寻址的本质是在特殊寄存器中设置数据地址的高字节，并在命令中仅指定地址的低字节。 在6502中使用的是只有固定高字节值的同一系统，该系统称为零页面寻址。 对已安装页面进行寻址直接类似于在x86中使用DS段寄存器，不仅适用于64 KB的段，而且适用于仅256字节的段。  6800的另一个牵强的架构是使用从高到低的字节顺序（Big Endian），这减慢了16位加减运算的速度。  6809与6800指令代码不完全兼容，6809是摩托罗拉的最后一个8位处理器；在进一步的开发中，决定改用68008。 <br><br> 可以假定，摩托罗拉花了很多钱来推广6809。提及此处理器，这仍然是正确的。 大约6809年，有许多有利的评论，但在某些星云，概括性和模糊性方面有所不同。  6809被定位为基于8位微处理器的超级处理器。 几乎为他制作了Unix，OS-9和UniFlex操作系统。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他大声疾呼作为苹果Macintosh的主要处理器，然后如史蒂夫·乔布斯（Steve Jobs）的电影中所说，只有他的情感干预才决定过渡到更有前途的68,000。当然，6809是一个很好的处理器，但总的来说，它只比其竞争对手出现早于6502更好（三年前）和z80（两个）。人们只能猜测，如果摩托罗拉将至少一半的精力花在开发6809和开发6809上，那将发生什么。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6809被用于一些相当知名的计算机系统。其中最著名的是美国计算机Tandy Color或Tandy Coco，以及他们的英国或威尔士克隆Dragon-32 / 64。 80年代计算机市场的特点是透明度高，Tandy Coco主要只在美国发行，除英国外，Dragons在西班牙也颇受欢迎。在法国，由于某种原因6809成为汤姆逊系列80年代大规模计算机的基础，该系列在除法国以外的其他地方几乎不为人知。 6809还至少在两个系统中用作第二个处理器：在Commodore SuperPET 9000系列中以及在BBC Micro计算机的TUBE接口的小规模机顶盒中，现在几乎被遗忘了。该处理器还用于作者所不了解的其他系统中，尤其是日语系统。他还在游戏机领域获得了一定的分布。值得一提的是其中一个控制台Vectrex，它使用一种独特的技术-矢量显示。</font></font><br><br><img src="https://i.imgur.com/DOVW3CM.jpg"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Color CoCo 3</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 680x上有一个有趣的未记录的说明，名称为“ Halt and Catch Fire”（HCF），该名称用于电子级测试，例如，使用示波器。它的使用会导致处理器冻结，只有重新启动处理器（复位），处理器才可以退出。这些处理器还具有其他未记录的说明。在6800中，例如存在与直接加载寄存器常量对称的指令，即将指令直接卸载到该指令后面的地址的指令！</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">像8080、8085或z80 6809一样，很难调用纯粹的8位。 6309在形式上甚至很难称呼8位，它是由日本东芝公司生产的（我找不到确切的生产年份，但是有一些数据表明1982年）是与6809完全兼容的处理器。但是，可以切换该处理器进入新模式，该模式在保持与6809几乎完全兼容的同时，提供了几乎一个数量级的巨大机遇。这些功能隐藏在官方文档中，但于1988年在Usenet网络上发布。添加了两个以上的电池，但是使用它们的说明要比使用前两个电池慢得多。大多数指令的执行时间已大大减少。增加了一些团队，其中，对于此类处理器来说，用16位除法器（32/16 = 16.16）对32位除数进行34个周期的符号除法简直是不可思议的，并且该除法器取自内存。还有一个28位时钟周期的16位乘法与32位结果。还添加了非常有用的指令，用于以6 + 3n的运行时间快速复制内存块，其中n是要复制的字节数，您可以使用减少或增加的地址进行复制。相同的指令可用于快速填充给定字节的内存。执行时，可能会发生中断。仍然有新的按位运算，空寄存器等。执行未知指令和除以0时会添加中断。6309是8位处理器（或可寻址内存大小为64 KB的处理器）中技术进步的巅峰之作。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6309与6809终端完全兼容，使其成为彩色Tandy或Dragons的流行升级。</font><font style="vertical-align: inherit;">使用6309的新功能的操作系统有特殊版本。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOS Technology 6502和WDC 65816 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是一个命运非常戏剧化的处理器。</font><font style="vertical-align: inherit;">没有其他处理器可以与之相比。</font><font style="vertical-align: inherit;">它的出现和实施伴随着非常大规模的事件和后果。</font><font style="vertical-align: inherit;">我将列出其中一些：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 摩托罗拉（Motorola）的衰弱，其能力在一段时间内超过了英特尔的能力； </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOS技术的破坏； </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 停止开发6502并停滞不前，几乎没有现代化。 </font></font></li></ul><br> 一切始于这样一个事实，即摩托罗拉出于完全未知的原因拒绝支持那些提议改进一般中等水平的6800处理器的年轻工程师。他们不得不离开公司，继续在规模较小但前景良好的MOS Technology公司工作，在那里他们很快准备了两个处理器使用NMOS技术制成的6501和6502。 第一个与6800兼容，但是在其他方面它们是相同的。  6501/6502团队成功地引进了新的芯片制造技术，从而从根本上降低了新处理器的成本。  1975年，MOS Technology可以25美元的价格提供6502美元的价格，而Intel 8080和Motorola 6800的起始价格是1974年的360美元。  1975年，摩托罗拉和英特尔降低了价格，但仍接近100美元。  MOS Technology专家声称他们的处理器比6800快4倍。这对我来说似乎是个疑问：6502可以更快地处理内存，但是第二块6800电池大大加快了许多计算的速度。 我可以估计6502平均快于不超过2倍。 摩托罗拉开始对其前雇员提起诉讼-据称他们利用了公司的许多技术秘密。 在此过程中，可以确定离开摩托罗拉的一名工程师在6800上发布了一些机密文件，这与同事的设置背道而驰。 究竟是他的行为还是站在他身后的一些指导力量仍然未知。 由于这个原因和其他不完全清楚的原因，摩托罗拉迫使其财务能力很小的MOS Technology支付了20万美元的巨额费用，并放弃了6501的生产。在与Zilog类似的情况下，英特尔采取了截然不同的行动。 尽管必须承认，MOS Technology有时试图用摩托罗​​拉花的巨款为自己的目的推广6800时风险太大。 <br><br> 故事中进一步出现了传奇的Commodore公司及其传奇的创始人杰克·特拉米耶尔（Jack Tramiel），阴影笼罩着决定公司政策的公司首席金融家的形象-一个名叫Irving Gould的人。 杰克从欧文（Irving）获得了一笔贷款，并用这笔钱用了几笔，以温和，不道德的策略来迫使MOS Tecchnology成为准将的一部分。 此后，也许与特拉梅尔的意愿背道而驰，特拉梅尔不得不屈服于胡德，6502的开发实际上停止了，尽管事实上早在1976年就有可能生产工作频率高达10 MHz的6502原型，尽管关于此的信息只是在一个人多年后才出现叫比尔·门施（Bill Mensch）（他是离开摩托罗拉的团队成员），他一再发表大声但基本上是空洞的陈述，并在6502的命运中扮演了相当模糊的角色。  6502首席开发人员Chuck Peddle永远退出了处理器的开发。  6502不仅继续在Commodore生产，而且还在西部设计中心（WDC）的Bill Mensch创建的公司中生产。 奇怪的是，以前的6502团队将来都不会与他合作。 <br><br> 围绕着6502的戏剧并没有就此结束。  1980年，罗克韦尔的AIM65互动杂志刊登了一篇简短的匿名文章，指出所有6502都带有一个名为JMP（xxFF）的危险错误。 文章的语气暗示了一些与众不同的地方。 随后，这种态度转变为苹果公司在此问题上的立场，并成为一种主流。 尽管严格来说，没有“ bug”。 当然，对于那些习惯了那些年大型系统的舒适处理器的专家来说，其中的一项功能（在微处理器中相当合适甚至有用）似乎是个烦人的错误。 但是实际上，这种伤害某人感觉的行为已在1976年的官方文档中以及提到的文章出现之前出现的编程教科书中进行了描述。  Bill Mensch消除了“错误”，Bill Mensch大概在1983年，即65816发布之后，制造了6502（CMOS 6502）。虽然Intel，摩托罗拉和其他公司制造了新一代16位处理器，但是6502仅在微观上得到了改进并使其与人为部分不相容。 除了消除“错误”之外，还进行了许多更改，特别是导致在执行几条指令时进行了更改，每条指令的速度变慢，但同时在某些牵强的学术意义上，它们变得更加正确。 但是，我必须承认，已经期望并使用了一些新的说明。 另一方面，绝大多数新指令仅占用代码空间，几乎没有增加6502的功能，从而留下了更少的新代码以进行可能的升级。  Commodore和Japanese Ricoh（最受欢迎的NES游戏机的制造商）不接受这些更改。 该材料的作者本人多次遇到此“错误”的问题。 他一无所知，为Commodore编写程序。 然后，他将其中一个转移到使用一组6502命令的系统。 出现了不兼容性，我不得不更改代码，进行条件编译。 事实证明，6502的代码更庞大，更慢。 然后，他在6502.org论坛上提出了这个问题，该论坛的大多数参与者来自苹果世界。 我问如果指示的“错误”使程序崩溃，是否有人可以举一个例子。 我仅收到情感和一般性评论；没有提出具体示例。 <br><br><img src="https://habrastorage.org/webt/f-/8q/mv/f-8qmv2x4io6ga8qxomqg0dxqnw.png"> 臭虫！ <br><br>  65C02已获得许多公司的许可，特别是NCR，GTE，Rockwell，Synekertek和Sanyo。 从IIe型号开始在Apple II中使用，尽管许多IIe都使用NMOS6502。65C02 6512变体也用于后来的BBC Micro型号。  Atari使用了NMOS6502。除了CMOS 6502外，Synertek和Rockwell还生产了NMOS6502。顺便说一下，NMOS 6502有其自己的未记录指令集，其性质与“秘密”命令8085完全不同。在6502中，这些指令是所用技术的副作用，因此它们中的大多数几乎没有用，但是有几个，例如，用一个命令一次加载或卸载两个寄存器，而另一些命令可使代码更快，更紧凑。 <br><br> 还有其他尝试升级6502的尝试。在1979年同一年，有一篇文章显示Atari计算机正在准备生产6509处理器（不要与后来出现的与Commodore公司同名的处理器混淆），该处理器有望将命令执行速度提高25％，并且许多新产品说明。 但是由于精度未知的原因，该处理器并未投入生产。 准将只进行了微观升级。 特别是在那里，他们转向了HMOS技术和静态内核的生产，这使得减慢处理器的速度成为可能。 从编程的角度来看，最有趣的是6509处理器，尽管它是非常原始的形式，但在为此目的专门分配的两条指令的帮助下，最多只能寻址1 MB的内存。 在极受欢迎的Commodore 64和128中，有6510/8510处理器，在不太成功的264系列中有7501/8501。 这些处理器分别只有6个和7个内置I / O位端口，而7501/8501不支持不可屏蔽的中断。 罗克韦尔生产的65C02型号具有扩展的32位操作（类似于z80位指令）指令集，但是，据我所知，此类处理器未在计算机中使用，而这些位指令本身更可能仅在嵌入式系统中使用。 顺便说一下，此扩展是由Bill Mensch制作的。 <br><br> 这部戏曲的最后一幕涉及6502，这是在80年代上半年向美国市场推出了基于6502的频率为2 MHz的计算机的预防。 这影响了外国人-英国人BBC Micro，他们的生产公司Acorn为美国制造了大批计算机，但事实证明是徒劳的。 某种锁起作用了，计算机不得不紧急地重做到欧洲标准。 尽管存在一些问题（特别是根据电气设备的标准），但仍允许使用半美洲计算机，但正式使用加拿大的Commodore CBM II（1982）计算机。 也许由于他们没有图形模式甚至没有彩色文本的事实-即使是时尚的保时捷设计也无法弥补这一点。 失败者中排在最后的是100％的美国Apple III（1980年）-众所周知，史蒂夫·乔布斯（Steve Jobs）与苹果公司的管理层一样，为阻止这款计算机的出现做出了很多努力。 乔布斯显然要求不可能的规格和管理-不切实际的期限。 我们会找出他们的动机吗？  1983年发布的Apple III Plus设法消除了Apple III的缺陷，但由于不愿与Macintosh计算机竞争，Apple管理层于1984年悄然关闭了该项目。 仅在1985年，当8位技术时代开始时，Commodore 128出现了，它可以在其一种模式下使用6502，时钟速度为2 MHz。 但是在这里，结果也更像是在开玩笑，因为实际上不支持这种模式，并且实际上没有程序。 仅在80年代下半叶，美国才开始为Apple II生产游戏机加速器，自1988年以来，开始生产具有4 MHz处理器的Apple IIc +模型。 为什么会这样呢？ 也许因为6502在2或3 MHz上（并且在80年代初就已经生产）可以完成许多任务，尤其是在游戏方面，可以成功地与基于Intel 8088或Motorola 68000的系统竞争。1991年，Commodore Corporation关闭一个有趣的，尽管是迟来的，基于频率为3.54 MHz的4510处理器的C65项目。  4510-这是最快的6502，仅在1988年制造，最后提到的是对循环的最优化，最终使速度提高了25％。 因此，C65中的处理器的速度接近4.52 MHz上具有6502的系统。 令人惊讶的是，此最快的6502带有一组扩展的指令（在某些细节上，此扩展证明比65816更成功）自此以后从未在任何地方使用过。 <br><br>  C128和Apple III Plus具有一个内存管理单元（MMU），它允许使用多个堆栈和零页，寻址超过64 KB的内存，等等。在C128中，MMU被人为调整为仅使用128 KB的内存。 对于BBC Micro，生产了在3 MHz（1984）和4 MHz（1986）时具有6502的调音台。 <br><br><img src="http://www.starringthecomputer.com/snapshots/jewel_of_the_nile_cbm_ii.jpg"><br>  <i>反广告-尼罗河明珠上的小人公寓中有多个保时捷PET瓶（1985年）-好莱坞只有苹果的时代尚未到来</i> <br><br> 现在说一下6502指令系统，该处理器的主要特点是它的制作速度几乎是最快的，几乎没有额外的时钟周期，在8080/8085 / z80 / 8088/68000处理器中尤其如此。 实际上，后来出现并受到直接影响的是6502 RISC体系结构处理器的思想。 从80486开始，在英特尔处理器中，相同的思想占主导地位。 另外，6502对中断的反应速度最快，这使其在某些嵌入式系统中非常有用。  6502有一个电池和两个索引寄存器，此外，前256个字节的存储器可以用在特殊命令中，既可以用作更快的存储器，也可以用作一组16位寄存器（其功能与8080 / z80中的BC和DE寄存器几乎相同）用于非常强大的寻址方法。 某些算术指令（移位，旋转，递增和递减）可以直接与存储器一起使用，而无需使用寄存器。 没有16位指令-它是100％8位处理器。 除了特有的英特尔奇偶校验标志体系结构，所有主要标志均受支持。 还有一些不正常的第十模式异常标志。 英特尔和摩托罗拉处理器使用特殊的纠正指令来处理十进制数字，而6502可以切换到第十模式，这使其在速度上的优势与十进制相比甚至比二进制数字更为重要。 令人印象深刻的是，对于8位操作数的6502表乘法，在不到30个时钟周期内获得16位结果，而辅助表的大小为2048字节。 慢慢地，6502会产生内存的大量复制操作-每字节14个时钟周期。 <br><br>  6502可以与另一个设备（例如另一个6502）并行工作。据我所知，从未生产过这种双处理器系统。 通常使用视频控制器来代替第二个处理器，该视频控制器与6502共享内存。 <br><br>  65816由WDC在1983年发布。有趣的是，Bill Mensch从Apple获得了有关新处理器的规格。 当然，这是向前迈出的一大步，但显然是迟来的，并且存在很大的体系结构缺陷。  65816没有被任何人视为主要的Intel或Motorola处理器的竞争者-它已经是次要局外人，已经被编程为进一步失去头寸。  65816具有两个重要优点-相对便宜，并且与仍很受欢迎的6502几乎兼容。在随后的几年中，Bill Mensch甚至没有尝试以某种方式改善自己的头脑，进行循环优化，使用Z寄存器用扩展的一页替换零页的地址（这是在4510年完成的），至少要加倍... WDC仅将最大时钟频率提高到90年代中期到14 MHz（此处理器在C64 SuperCPU的流行加速器中使用，频率为20 MHz）。 但是，即使是现在（2019年！），WDC出于某种原因也只能在同一14 MHz上提供65816。  65816最多可以使用16 MB的内存，但是用于此目的的寻址方法远非最佳。 例如，索引寄存器只能是8位或16位，堆栈只能放置在前64 KB的内存中，只有在那里，您才能使用已安装页面的便捷短寻址（直接页面-零页面的泛化），使用大于64 KB的内存相对笨拙，... 65816具有16位ALU，但具有8位数据总线，因此在算术运算中它仅比6502快50％。尽管如此，65816的发布量却超过10亿。 当然，许多指令65816明显地补充了6502架构中的空白，例如，用于每字节7个时钟周期的大量复制存储器的指令。 您还可以添加65816使用几乎所有指令代码（256个中的255个）。 最后一个未使用的代码用于将来从未出现的指令。 <br><br> 史蒂夫·沃兹尼亚克（Steve Wozniak）积极参与开发的Apple IIx原本应该使用65816，但是只有在1984年才可以生产该处理器，第一批65816就有缺陷，这导致了过多的延迟，结果整个项目都被关闭了。 <br><br> 还有一个选件65816 65802，它使用16位地址总线并与6502连接器兼容。基于该处理器的Apple II进行了升级，但是只有在专门为其编写的程序上进行这种升级，您才能获得一点加速。 <br><br>  6502被用于许多计算机系统中，其中最流行的是8位Commodore，Atari，Apple，NES。 有趣的是，将6502用作Commodore Amiga计算机的键盘控制器，并在高性能Apple Macintosh IIfx中使用了两个10 MHz的6502。 这里值得一提的是1977年至1996年生产的Atari游戏机-售出了大约3500万个！  65816在颇受欢迎的Apple IIgs计算机，Super NES游戏机以及罕见的英语计算机Acorn Communicator中使用。 <br><br>  1984年，在Byte杂志上刊登<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">了一篇文章，</a>内容是关于[苹果计算机的不良副本] [苏联制造]，上面有红色横幅，列宁和行军士兵的图片。 这篇文章引用了这台计算机的一个有趣的价格-17,000美元（这是一个荒唐的数字，实际价格约为4000卢布），具有讽刺意味的是，如果苏联制造商想在西方出售产品，则必须大幅降低价格。 玛瑙主要用于学校教育。 较旧的Agate型号几乎100％与Apple兼容] [并且具有一些非常有用的扩展。 <br><br> 您只能幻想如果6502能够以与其竞争对手相同的速度发展，将会发生什么。 在我看来，零页存储器到寄存器的逐步转移以及指令系统的逐步扩展以及对周期的同时优化，将使6502“终结者”在速度方面保持领先，直到90年代初。 模式16以及随后的32位的引入将允许使用大量的内存和更快的命令。 他的竞争对手会反对吗？ <br><br> 最后，我想谈一些一般的哲学考虑。 为什么6502刹车了，没有更光明的未来？ 也许是由于他确实可以极大地挤压大型公司并创造一个全新的现实。 但是6502团队为此成立了吗？ 相反，他们只是想做一个更好的处理器。 <br><br> 很快，在21世纪初，由于牵强的理由提起诉讼，Lexra公司被击败了，该公司生产了5年的各种创新处理器。 这个悲伤的故事让人想起MOS Technology的情况。 <br><br><h2>  Zilog z80 </h2><br> 该处理器与6502一起成为了第一批个人计算机的主处理器。 在其出现和使用的历史上没有戏剧性的事件。  Zilog未能成功生产出下一代处理器，这只会引起人们的兴趣。  Z80于1976年开始生产，其变型仍在生产中。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">曾经有一次，甚至比尔·盖茨本人也宣布支持基于z80的系统。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">许多巧合是有趣的。与6502一样，Z80的主要开发人员费德里科·法金（Federico Faggin）从英特尔离开了这家大公司。在使用z80进行工作之后，Federico几乎不使用下一代处理器Z8000，并且在80年代初离开了他的公司，因此他将来将不再处理处理器。然后，他创建了一些相对成功的创业公司，创建了通信系统，触摸板和数码相机。您可以提到，除了z80之外，他还在Zilog中开发了成功且仍在生产的Z8微控制器。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与8080相比，Z80是一种更易于集成到计算机系统中的处理器。它仅需一个电源电压，并且内置了对动态内存再生的支持。此外，由于与8080完全兼容，它具有许多新命令，第二组主寄存器和几个全新寄存器。奇怪的是Zilog拒绝使用8080汇编程序助记符，而是开始使用自己的助记符，这些助记符更适合z80扩展命令系统。 GNU软件世界中的Intel x86汇编器也发生了类似的情况，由于某些原因，它们默认情况下也使用自己的约定在汇编器中编写程序。 Z80增加了对溢出标志的支持，英特尔仅在8086中增加了对这种标志的支持。但是，z80中的此标志与奇偶校验标志组合在一起，因此，与8086中的标志同时，不能同时使用两个标志。在z80中，就像在6502中一样，仅基本检查一个标志的值，即一次不会检查两个或三个标志，这对于比较“严格大于”，“小于或等于”以及所有有效标志都是必要的-在这种情况下，您必须进行多次检查，其中一个在8086、6800或PDP-11上就足够了。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在新的z80指令中，用于每字节21个周期的大容量复制内存的指令以及内存中有趣的字节搜索命令尤其令人印象深刻。</font><font style="vertical-align: inherit;">但是，最有趣的是EXX命令，该命令将48个字节的寄存器存储器，BC，DE，HL寄存器的内容与它们的双精度字互换，它们仅用4个周期运行！</font><font style="vertical-align: inherit;">即使是32位ARM，也需要至少6个时钟周期来进行相同的操作。</font><font style="vertical-align: inherit;">尽管有时它们是有用的，但其余的其他说明并不那么令人印象深刻。</font><font style="vertical-align: inherit;">增加了更多：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 16位减法带借位，16位加法带传输15个周期； </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 一元减电池的8个滴答声; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 具有从存储器读取和使用BC，DE，SP，IX，IY寄存器（不仅仅是HL）进行写入的能力； </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 所有8位寄存器的移位，旋转和输入输出； </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 通过位数检查，设置和重置的操作； </font></font></li><li>    (JR); </li><li>  . </li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大多数新命令都相当慢，但是正确使用它们仍然可以使代码更快，更紧凑。对于使用新的16位寄存器IX和IY尤其如此，这些寄存器可用于新的寻址方法。有趣的是，IX和IY索引寄存器出现在Z80中，以吸引6800个用户过渡到Z80！但是我敢于表达自己的观点，由于使用这些寄存器的命令中存在几乎无用的字节偏移，因此使用Z80索引寄存器进行的操作相当不成功。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z80中的许多8080团队的节奏都更快，这是非常明显的加速。但是，对于16位算术基本的ADD命令，每个周期变慢，这使得算术通常更快，甚至只有一点点。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与8080相比，用于处理中断的系统变得更加有趣。使用z80，您既可以使用不可屏蔽的中断，也可以使用三种方法（其中一种与8080兼容）来使用屏蔽的中断。屏蔽中断2的最有趣的模式，它允许您灵活地更改代码的地址以处理该中断。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z80有很多未记录的指令，其中许多指令在切换至CMOS技术时就消失了，但是幸存的指令实际上已成为标准，并已被某些公司记录。特别有用的指令使您可以处理笨拙的16位寄存器IX和IY的各个字节。除了未说明的指令外，Z80还具有其他未说明的属性，例如，状态寄存器中的两个特殊标志。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当然，z80甚至比8080有权被称为16位的权利还要大。 z80的假设数字容量指标显然要高一些，但是z80的ALU实际上是4位是矛盾的！在电子方面，z80和8080是完全不同的芯片。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关于比较z80和6502的性能的文章很多，因为这些处理器在第一批大型计算机中被广泛使用。在这个主题中有几个困难的时刻，没有这些困难的时刻，很难保持客观性。由于存在大量z80寄存器，因此以高于存储器工作频率的频率使用是很自然的。因此，在4 MHz下的z80可以使用与在1.3 MHz下的6502或6809相同的内存。根据许多为两个处理器编写代码的经验丰富的程序员所说，它们在相同的频率6502上平均比z80快2.4到2.6倍。该材料的作者对此表示赞同。您只需要补充一点，为z80编写好的快速代码非常困难，您需要不断优化寄存器的使用，并尽可能使用堆栈来处理内存。如果您努力尝试，那么我认为您可以将z80和6502之间的差异减小到约2.2倍。而且，如果您不尝试忽略计时，那么您可以轻松地将差值提高到4倍。在某些情况下，z80可以表现出非常快的性能。在填充内存的任务上，使用PUSH命令的z80甚至可以比6502快一点，但这是以禁止中断为代价的。在复制内存块时，z80仅慢1.5倍。尤其令人印象深刻的是，将32位除以16除数，z80仅慢1.7倍。顺便说一句，这种超级共享是由俄罗斯程序员实现的。因此，我们得到z80在3.5 MHz时的ZX频谱比C64在1 MHz时从6502快约一半半。值得注意的是例如，由于视频生成支持方案，大多数带有z80或6502的系统的时钟部分会从处理器中移走，因此，对于流行的Amstrad CPC / PCW计算机，实际的处理器频率是3.2 MHz，而不是完整的4。在6502的系统中，通常可以关闭屏幕以获得最佳处理器性能。如果我们以内存而不是处理器的频率为基础，事实证明z80比6502快25-40％。最后的结果可以用以下事实来说明：频率为2 MHz的内存z80可以以高达6 MHz的频率运行，并且6502仅高达2 MHz。如果我们以内存而不是处理器的频率为基础，事实证明z80比6502快25-40％。最后一个结果可以用以下事实来说明：频率为2 MHz的内存z80可以以高达6 MHz的频率运行，并且6502仅高达2 MHz。如果我们以内存而不是处理器的频率为基础，事实证明z80比6502快25-40％。最后一个结果可以用以下事实来说明：频率为2 MHz的内存z80可以以高达6 MHz的频率运行，并且6502仅高达2 MHz。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z80被用于许多计算机系统。 Tandy TRS-80s在美国，欧洲的ZX Spectrum以及后来的Amstrad CPC和PCW都非常受欢迎。奇怪的是，直到90年代中期，Amstrad PCW计算机仍然具有实用性，并且在90年代末一直大量且积极地用于其预期目的。在日本和其他国家/地区，他们在全球范围内生产了相当成功的MSX计算机。颇受欢迎的C128也可以使用z80，但这里的用户更容易感到尴尬-1985年末发布的8位z80计算机正式时钟为2 MHz，实际上只能在1.6 MHz下工作。这甚至比70年代中期8080年代的第一批系统还要慢。使用CP / M操作系统的计算机范围包括至少三打相当知名的系统。</font></font><br><br><img src="http://www.old-computers.com/museum/photos/Amstrad_9512_Running_s1.jpg"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这样的PC甚至在90年代中期看起来还不错，但z80的速度却比ZX Spectrum的慢。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作者知道的最快的基于z80的计算机系统是BBC Micro，它带有TUBE机顶盒，z80B的频率为6 MHz，自1984年以来就开始生产。正如他们所说，“无刹车”时，该系统可以全速运行。自1979年以来，Apple就制造了类似的游戏机。后来，其中一些游戏机在8 MHz或更高频率下使用Z80H。有趣的是，1980年，微软从此类游戏机的销售中获得了最大的利润。您还可以提及自1994年以来制造的Amstrad PCW16，它使用CMOS Z80的频率为16 MHz。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在日本，与z80兼容的R800是为MSX TurboR（1990）系统制造的。 R800中已添加了具有32位结果的硬件16位乘法。尽管将其与16位常量相乘时，可以通过时钟更快地获得与768字节表的表相乘。有一种观点认为，R800是一种非常简化的Z800，其工作频率约为总线频率的四倍，后者约为7.16 MHz。因此，R800的内部频率约为28.64 MHz！</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zilog本身一直在非常不一致且非常缓慢地改进Z80。首批Z80的工作频率高达2.5 MHz，此后不久出现的Z80A将最大频率提高到4 MHz-这些处理器成为大多数使用Z80的流行计算机的基础。 Z80B出现在1980年，但是相对很少使用，例如，在提到的BBC Micro控制台或晚期（1989年）的SamCoupé计算机中使用。 Z80H出现在80年代中期，并且可以在高达8 MHz的频率下运行-尚未在已知计算机中使用。有趣的是，Zilog产品在芯片上有专门的陷阱，供那些试图对其进行复制的人使用，例如，基本的Z80有9个陷阱，并且根据这样做的评论，他们将复制过程放慢了将近一年的时间。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z80的更深层次升级受到Zilog创建与英特尔16位处理器竞争的处理器的渴望的阻碍。 1978年，不久之后的8086发行了Z8000，与z80不兼容。该处理器无法抵御英特尔的竞争对手，尤其是摩托罗拉-68000在几乎所有方面都超过了Z8000，尽管Z8000在大约十二种不同的廉价系统中使用，通常用于Unix变体。有趣的是，IBM甚至没有将Z8000视为IBM PC的可能处理器，因为Zilog由将与IBM竞争的埃克森美孚（Exxon）资助。也许由于Z8000的失败，Zilog于1980年成为埃克森美孚的子公司。还尝试创建具有竞争力的32位处理器。 1986年，Z80000出现了，与Z8000兼容，这是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其他任何地方。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并没有找到应用程序。在某些情况下，尤其是Zilog团队对资金过多的投诉非常奇怪，这表明Zilog出于某种不清楚的原因，可能破坏了其作为埃克森美孚公司一部分的工作。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">唯一的疑问就是Zilog为什么放弃其方法，该方法在Z80上显示出超级成功的结果，即使处理器与Intel处理器在程序上兼容，但它们的最佳性能同时又在硬件级别上完全不同。随后，许多公司特别是AMD，Cyrix，VIA成功地使用了这种方法。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基于Z80的新处理器的创建被推迟到1985年，当时Z800才被制造出来。但是，Zilog的主要工作是针对Z80000，很少发布Z800。 1986年，在z80000发生故障之后，Z280得以发布，这是Z800的略微改进版本，尤其是它可以在比总线频率高几倍的内部频率下工作-这种新颖性为Intel 486DX2和486DX4处理器带来了巨大的成功。 Z280还具有其他有希望的功能，后来被其他公司成功应用。但是，也许由于性能低下-Z280尽管进行了许多技术创新，但只能使用相对较低的时钟速度，因此该处理器也</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无处不在</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">找不到应用程序。可以相信Z280大致相当于Intel 80286的功能，但是使用与80286相同的时钟频率时，Z280的速度要慢至少50％。也许如果Z280在5年前出现，那么它可能会非常成功。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与日本日立公司的合作获得了最大的成功，日立公司于1985年发布了其超级Z80 HD64180，其功能与英特尔80186类似，后者允许使用512 KB内存，增加了十几条新指令，但是一些几乎没有标准的未记录指令Z80不支持。 HD64180已在某些计算机系统中使用。 Zilog获得了HD64180的许可，并开始生产带有Z64180标记的产品。 Zilog设法略微改进了该处理器，特别是增加了对使用1 MB内存的支持，并于1986年底发布了该处理器。这种新的处理器称为Z180，成为时钟和频率高达33 MHz的一系列处理器和控制器的基础。它在一些罕见的MSX2计算机上使用，但更像是控制器。好奇的Z280和Z180以及一年前的对应型号80286和80166出现在一年内。 1994年，在Z180的基础上生产了32位Z380，该Z380仍与z80兼容，容量与英特尔80386或摩托罗拉68020大致相当-Zilog与竞争对手相比差距了将近10年。早在21世纪，就已经在Z180的基础上再次生产出了非常成功的eZ80处理器控制器，其时序几乎类似于6502的时序。它们被用于各种设备，特别是网卡，DVD驱动器，计算器，...早在21世纪，就已经在Z180的基础上再次生产了非常成功的eZ80处理器控制器，其时序几乎类似于6502的时序，它们被用于各种设备，特别是网卡，DVD驱动器，计算器，...早在21世纪，就已经在Z180的基础上再次生产了非常成功的eZ80处理器控制器，其时序几乎类似于6502的时序，它们被用于各种设备，特别是网卡，DVD驱动器，计算器，...</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 德州仪器（TI）TMS9900 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于这个非常特殊的代码处理器，我从未能够编写。</font><font style="vertical-align: inherit;">这是可用于个人计算机的第一个16位处理器。</font><font style="vertical-align: inherit;">自1976年以来生产。</font><font style="vertical-align: inherit;">使用从高到低（大端）的少得多的通用字节顺序。</font><font style="vertical-align: inherit;">该订单仍仅在Motorola 6800和68000系列处理器以及巨型IBM / 370的体系结构中使用。</font><font style="vertical-align: inherit;">本文中的所有其他处理器都使用反向字节顺序（Little Endian）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TMS9900仅具有三个16位寄存器：命令计数器，状态寄存器和伪寄存器基址寄存器。该处理器使用分配给32个字节的内存作为16个双字节寄存器。这种存储器的使用在某种程度上让人联想到架构6502中的零页存储器。使用基址寄存器，TMS9900可以非常快速地更改上下文。这类似于Z80，它具有两个寄存器上下文。标志系统的独特之处在于它的独创性，以及典型的进位，零（相等），溢出，奇偶校验标志，还有两个更独特的逻辑和算术标志标志。使用堆栈和例程类似于将来的RISC处理器。根本没有完成的堆栈；可以使用伪寄存器之一来完成堆栈。调用该子例程时，将为计数器和基数选择一个新值，并且所有三个寄存器都存储在新上下文的伪寄存器中。因此，子例程调用更像是程序中断调用。 TMS9900具有一个内置的中断控制器，旨在与最多16个硬件中断一起使用。</font></font><br><br><img src="https://habrastorage.org/webt/bs/ir/lv/bsirlvxf7fobwzwpdcvxkcnousc.jpeg"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第一台16位家用计算机-它甚至具有彩色图像</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，命令系统看起来非常令人印象深刻。甚至有乘法和除法。独特的指令X允许您在内存中的任何地址执行一条指令，然后继续执行下一条指令。命令执行相当慢，最快的指令仅在8个时钟周期内执行，算术命令在14个时钟周期内执行，但52个时钟周期内的乘法（16 * 16 = 32），尤其是124个时钟周期内的除法（32/16 = 16,16）可能是创纪录的在70年代的处理器中最快。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TMS9900需要三个-5、5和12伏的电源电压和四个相位的时钟信号-这些是我所知道的处理器中的反记录。 1979年，该处理器向IBM专家展示，他们当时正在为正在开发的原型IBM PC寻找处理器。 TMS9900的明显缺点（可寻址性仅为64 KB内存，缺少必要的控制器架构，相对缓慢）给人留下了相应的印象，英特尔8088被选为PC的未来领导者。为解决控制器缺乏的问题，德州仪器（TI）还生产了带有8位总线的TMS9900版本TMS -9980，工作速度降低了33％。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TMS9900用于TI99 / 4和TI99 / 4A计算机，它们在美国相当流行，到1983年，Commodore VIC-20计算机在价格战中被“压垮”。令人好奇的是，由于这场战争，德州仪器（TI）被迫将其计算机价格降低到令人难以置信的水平。 1983年的价格为49美元（1979年的价格为1150美元！），并以巨大的损失为自己卖出。例如，我们可以举出相对较不受欢迎的计算机Commodore + 4，该计算机于1986年停产，但其价格直到1989年才跌至49美元。 T99 / 4A于1984年停止生产，当时由于价格极低，它开始流行。此计算机只能称为16位。因为它只有256字节（！）的RAM存储器，并且所有ROM存储器都是通过16位总线寻址的。其余的内存和I / O设备通过慢速8位总线工作。因此，可以更正确地将家用BK-0010视为第一台家用16位计算机。奇怪的是，TI99 / 4和TI99 / 4A使用3 MHz的处理器-与BK-0010完全相同。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在TI-99 / 4和TI99 / 4A中，使用了相当成功的TMS9918芯片作为视频控制器，这成为了全球非常流行的MSX标准以及其他一些计算机和游戏机的基础。</font><font style="vertical-align: inherit;">在日本的Yamaha公司，该视频芯片得到了显着改进，并随后被用于特别升级TI-99 / 4和TI99 / 4A！</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TI99 / 4系列是计算机的罕见示例，其中处理器的制造商与计算机相同。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DEC PDP-11处理器 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自70年代初以来，DEC在世界上占主导地位的时代已经开始了10年。 DEC计算机比IBM生产的计算机便宜得多，因此吸引了没有IBM系统的小型组织的注意。大规模专业编程的时代也始于这些计算机。 PDP-11系列计算机非常成功。从70年代初到90年代初，制造了各种PDP-11模型。在苏联，它们被成功克隆并成为第一个大规模流行的计算机系统。克隆中有名称为SM的计算机，分别是Electronics-60 / 81/85，DVK-1 / 2/3，BK-0010 / 0011（BK0010是商店中第一款可以购买的PC）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，DEC还推广了VAX-11系列的价格更高，功能更复杂的计算机，这种情况在某种程度上被政治化了。从70年代下半叶开始，DEC几乎停止了PDP-11生产线的开发，特别是没有引入支持16个数字的汇编程序。自70年代中期以来，PDP-11系统的性能几乎保持不变。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PDP-11使用了与主命令系统兼容的不同处理器，例如LSI-11，F-11，J-11。在70年代后期，DEC为T-11微型计算机制造了一种廉价的处理器。但是，由于不明原因，尽管计算机系统制造商从来没有注意到它，尽管看似大型高质量的软件可以在将来使用它转移到系统中。一个例外是Atari游戏机模型。 T-11仅在嵌入式设备的世界中得到了广泛使用，尽管在功能方面，它比z80略胜一筹。在苏联，生产了接近DEC处理器的处理器K1801BM1，K1801BM2，K1801BM3，以及DEC处理器的精确副本。后者价格昂贵得多，并且批量生产。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PDP-11体系结构处理器的命令系统以几乎完全的正交性，令人愉悦的质量而著称，但是如果将其发挥到极致，它可能会创建荒谬的命令。 PDP-11处理器指令系统已经影响了许多体系结构，尤其是Motorola 68000。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PDP-11命令系统严格为16位。所有8个通用寄存器（该体系结构中的指令计数器为常规R7寄存器）均为16位，状态寄存器（包含典型标志）也为16位，指令的大小为1至3个16位字。命令中的每个操作数可以是任何类型的（尽管有例外，例如XOR指令）-这是正交的。在这些类型中，有普通寄存器或存储器。 80年代的程序员有时不理解为什么英特尔x86指令系统中没有内存存储指令。这是PDP-11学派的影响，您可以在其中轻松地为每个操作数编写完整地址。当然，这很慢，特别是对于90年代初期典型的内存缓慢的系统来说，速度特别慢。也可以通过寄存器，带偏移量的寄存器，具有自动减量或增量的寄存器来访问存储器。PDP-11指令系统的一个功能是可以通过寄存器双重间接访问存储器，例如，</font></font><br><br><pre><code class="plaintext">MOV @(R0)+,@-(R1)</code> </pre> <br> 表示与C / C ++语言运算符相同 <br><br><pre> <code class="plaintext">**–r1 = **r1++;</code> </pre> <br>  ，其中r0和r1声明为 <br><br><pre> <code class="plaintext">signed short **r0, **r1;</code> </pre> <br> 另一个例子，一个命令 <br><br><pre> <code class="plaintext">MOVB @11(R2),@-20(R3)</code> </pre> <br> 对应于 <br><br><pre> <code class="plaintext">**(r3-20) = **(r2+11);</code> </pre> <br> 其中r2和r3声明为 <br><br><pre> <code class="plaintext">char **r2, **r3;</code> </pre> <br> 在当今流行的体系结构中，一个团队离不开这样的团队；可能至少需要10个团队。 您还可以获取相对于命令计数器当前值的地址。 我将以更简单的寻址方式给出另一个示例。 团队 <br><br><pre> <code class="plaintext">ADD #16,11(R4)</code> </pre> <br> 可以映射Intel x86体系结构 <br><br><pre> <code class="plaintext">ADD [BX+11],16</code> </pre> <br> 在DEC汇编程序中，习惯上是从左向右写入操作数，这与Intel从右向左写入不同。 有理由相信x86的GNU汇编器是在PDP-11汇编器的影响下制造的。 <br><br> 乘法和除法命令仅是符号命令，并非在所有处理器上都可用。 十进制数算法也是可选的-这就是所谓的DEC术语商业算法。 出于完全正交的好奇心，我将举一个命令示例 <br><br><pre> <code class="plaintext">MOV #11,#22</code> </pre> <br> 执行后变成 <br><br><pre> <code class="plaintext">MOV #11,#11</code> </pre> <br>  -这是将立即数用作操作数的示例。 另一个好奇的团队是独特的MARK命令，该命令的代码必须被压入堆栈，并且永远不能明确使用。  PDP-11体系结构中的调用例程也有些特殊。 相应的命令首先将分配的寄存器（可以是任何寄存器）保存在堆栈中，然后将指令计数器保存在该寄存器中，然后才将新值写入指令计数器。 子程序的返回命令必须执行相反的操作，并且知道在调用子程序时使用了哪个寄存器。 使用命令计数器作为普通寄存器可以获得非常奇怪和不可预测的效果。 <br><br> 有趣的是，在PDP-11程序员中，发展了一种直接使用机器代码的文化。 例如，调试时，程序员可以在没有反汇编程序的情况下工作。 甚至无需组装就可以直接在内存中编写小程序！ <br><br> 当然，团队的时机在高速特性上并没有什么不同。 一次令人惊讶的发现是，在BK的家用计算机上，从寄存器到寄存器的传输命令需要多达12个周期（使用ROM中的代码时需要10个周期），并且带有两个间接间接寻址的两个操作数的命令执行了100个以上的周期。  Z80进行8位的16位寄存器传输。但是，BC的缓慢并不是由处理器引起的，而是由家用存储器质量差引起的，必须根据BC的特性来调整其性能。 如果使用了足够快的存储器，那么BC也将在8个时钟周期内发送16个寄存器位。 一旦有很多争议，哪个比BC或Spectrum更快？ 必须马上说，使用高32 KB内存时，Spectrum是最快的8位个人计算机之一。 因此，Spectrum比BC快，但幅度不大也就不足为奇了。 而且，如果BC在没有刹车的情况下使用内存，那么速度可能会更快一些。 <br><br> 代码密度也是PDP-11架构的弱点。 指令代码应为机器字长度的倍数-2个字节，在使用字节参数或简单的命令（如设置或重置标志）时，这尤其令人不快。 <br><br> 尝试制造基于PDP-11架构的个人计算机很有趣。  Terak 8510 / a是世界上最早出现在比Apple [和Commodore PET稍晚一点，并且比Tandy TRS-80稍早一点的时间]的PC，它具有黑白图形并且可以下载不完整版本的Unix。 据我所知，这台PC非常昂贵，仅在美国的高等教育系统中使用过。 自1978年以来，该计算机以组装Heathkit H11的套件形式生产。  DEC本身也试图制造自己的PC，但是非常不一致。 例如，DEC发行了基于z80和8088的PC，显然与它的主要发展背道而驰。 基于PDP-11 DEC PRO-325 / 350/380架构的人员与基础架构有些人为的不兼容，这使得很难使用部分软件。 微型计算机技术的最佳个性化是在苏联制造的BK，DVK和CC NT ...顺便说一句，Electronics-85是DEC PRO-350的非常准确的克隆。 此外，类似于PDP-11架构的CP1600处理器用于Intellivision游戏机中，该游戏机在80年代初很流行。 <br><br><img src="https://hsto.org/storage2/054/de2/ed6/054de2ed61ad81127c1d7db0f7171100.jpg"><br>  <i>家用16位家用计算机（1985）-几乎与PDP-11兼容</i> <br><br>  DVK中使用的K1802BM2大约是K1801BM1的两倍，K1801BM3甚至更快，并且速度与Intel 8086接近。 <br><br> 在较旧的PDP-11型号和附近的家用计算机中，处理器可以寻址多达4 MB的内存，但一个程序最多只能分配64 KB的内存。 在速度方面，这些处理器的每兆赫兹操作数也接近8086，尽管它的速度仍然较慢。 <br><br><h2>  DEC VAX-11的CPU </h2><br>  VAX-11系统在80年代非常流行，尤其是在高等教育中。 现在，在不了解这些系统的体系结构的情况下，很难理解这些年中描述的一些概念。  VAX-11比PDP-11贵，但它们更面向通用编程，但仍比IBM / 370系统便宜得多。 对于VAX架构，在80年代中期开始生产V-11处理器，在那之前，一直使用处理器组件。 <br><br>  VAX-11体系结构是32位的，它使用16个寄存器，其中像PDP-11一样，有一个命令计数器。 假定使用两个堆栈，其中一个用于存储子帧。 另外，寄存器之一被分配为与被调用函数的参数一起使用。 因此，将16个寄存器中的3个分配给堆栈。  VAX-11命令系统的强大之处以及非常罕见且通常唯一的命令（例如，用于处理位字段或几种类型的队列，计算CRC，乘以10行）的功能，一定会让您惊叹不已。许多命令采用三地址版本（两个ARM）和两个地址（如x86），但是有四个地址命令，例如EDIV的扩展除法。 当然，支持使用实数。 <br><br> 但是VAX-11的等级和价格非常慢。 即使是4 MHz的超简单型6502，也可能会超过VAX-11 / 730系列中最慢的一个，而最快的VAX-11系统-大型机柜和“整体家具套件”也达到了首批PC AT的性能水平。 当80286出现时，很明显，VAX-11的日子已经过去了，即使采用基于80286的系统的制动也无法从根本上改变任何东西。 来自Acorn的更直接的英国人在1985年生产ARM的时候没有隐藏任何东西，他说ARM便宜得多，而且速度明显快得多。 但是，VAX-11直到90年代初一直很重要，与PC相比仍具有一些优势，尤其是用于磁盘的更快的系统。 <br><br>  VAX-11可能是最后一个大规模系统，在该系统中，组装工人的便利性比速度更重要。 从某种意义上说，这种方法已经转向了现代流行的脚本语言。 <br><br><img src="https://gordonbell.azurewebsites.net/Digital/timeline/photos/vax11-785.jpg" align="left">  <i>图为VAX-11 / 785（这也是一台计算机，1984年），在VAX-11中是最快的，就处理器速度而言，它可与IBM PC AT或ARM评估系统媲美。</i> <br><br> 令人惊讶的是，关于VAX-11系统的文献很少。 好像某种关于遗忘的奇怪法律正在生效。 与政治密切相关并与苏联历史相关的几次事件都与这种建筑的历史有关。  PDP-11体系结构的开发遭到实际拒绝的原因可能是其价格便宜以及其在苏联的成功克隆。  VAX-11克隆耗费了一个数量级的大量资源，并导致了死胡同。 对VAX-11的兴趣来自于使用1984年4月1日著名的克里姆林宫Vax等绘画作品，当时苏联领导人康斯坦丁·切尔年科（Konstantin Chernenko）提出在连接Usenet网络时喝伏特加酒。 另一个笑话是，某些VAX-11芯片上印有破碎的俄语信息，说明VAX-11的性能如何。  :) <br><br> 到80年代末，一些VAX-11模型已在苏联克隆，但这种克隆的产生很少，几乎从未使用过。 <br><br> 可以在网络上使用几种VAX-11系统。 并将它们与与其竞争的IBM / 370系统进行比较。 <br><br><h2> 英特尔：8086至80486 </h2><br> 当然，在70年代制造的最好的处理器之一是8086，以及价格更便宜的几乎是模拟的8088。这些处理器的体系结构令人愉快地与众不同，因为它没有机械的借用和对抽象理论的坚持，周到和平衡的体系结构，平衡和专注进一步发展。 在x86架构的缺点中，可以将其称为繁琐的操作，并且倾向于大量增加指令的数量。 <br><br>  8086的巧妙设计解决方案之一是分段寄存器的发明。 实际上，这同时实现了两个目标：程序的“免费”可移植性，最大大小为64 KB（在80年代中期之前，一个程序的计算机存储量非常大），可寻址性高达1 MB。 您还可以注意到，与8080或z80一样，8086也具有一个特殊的地址空间，用于64 KB大小的I / O端口（y 8080和8085，此卷为256字节）。 只有四个段寄存器：用于代码，用于堆栈和两个用于数据。 因此，可以快速使用64 * 4 = 256 KB的内存，但是即使在80年代中期，这也非常有用。 实际上，代码的大小没有问题，因为可以使用所谓的长子程序调用来加载和保存两个寄存器中的完整地址。 一个子程序的大小只有64 KB的限制-这对于许多现代应用程序来说已足够。 快速寻址大于64 KB的数据阵列的可能性产生了一定的问题-使用此类阵列时，每次访问时都需要加载段寄存器和地址本身，这使使用这种大型阵列的速度降低了数倍。 <br><br> 段寄存器的实现方式使得在机器代码中几乎看不见它们的存在，这使得在时间到来时很容易拒绝它们。 <br><br>  8086体系结构保持了与8080体系结构的相似性，这使得将程序从8080（甚至z80）传输到8086的工作量相对较小，尤其是在程序源代码可用的情况下。 <br><br> 团队8086的执行速度没有差异，但与竞争对手相当，例如，一年后出现的Motorola 68000。 新产品之一，是车队的回头车，略微加速了通常不急促的8086。 <br><br>  8086使用八个16位寄存器，其中一些可用作两个字节的寄存器，另一些可用作索引的寄存器。 因此，8086寄存器在某种程度上是异构的，但它具有很好的平衡性，并且使用起来非常方便。 顺便说一下，这种异质性使您可以拥有更密集的代码。  8086使用与8080相同的标志，外加一些新标志。 例如，出现了一个标志，它对于PDP-11体系结构是典型的-分步执行。 <br><br>  8086允许您使用非常有趣的寻址模式，例如，一个地址可以由两个寄存器的总和以及一个恒定的16位混合组成，在该地址上叠加一个段寄存器的值。 地址总和中只能保留两个或什至一个词。 在PDP-11上使用一个命令执行此操作将不起作用。 大多数8086指令都不允许两个类型的内存操作数；其中一个操作数必须是一个寄存器。 但是有些字符串命令只知道如何使用两个地址来处理内存。 字符串命令使您可以进行快速块复制（每个字节或单词17个度量），搜索，填充，加载和比较。 另外，在使用I / O端口时可以使用字符串命令。  8086使用命令前缀的想法非常有趣，允许经常使用非常有用的附加功能，而不会显着增加命令编码方案的复杂性。 <br><br>  8086是所有计算机系统中使用堆栈的最佳组织之一。 使用8086仅需使用两个寄存器（BP和SP），就可以在组织带有参数的例程调用时解决所有问题。 <br><br> 团队中有符号和无符号乘法与除法。 甚至还有用于乘法和除法命令的独特十进制调整命令。 很难说8086命令系统中显然缺少某些东西。 相反，相反。 将32位除数划分为16位除法器以获得32位私有和16位余数可能需要多达300个时钟周期-并不是特别快，但是比任何8位处理器上的这种除法要快几倍（6309除外）速度可达到68000。x86除法具有一项意想不到的功能-它以不可预测的方式改变了标志的标志... <br><br> 值得补充的是，在x86架构中，继承自8080的XCHG团队得到了改进。 另外，后来的处理器开始使用指令XADD，CMPXCHG和CMPXCHG8B，它们也可以执行参数的原子交换。 这样的指令是x86的功能之一，很难在其他架构的处理器上找到它们。 <br><br> 我们可以总结一下，8086是一款非常成功的处理器，结合了编程的便利性和对存储器的限制（这是它们的时间特征）。  8086的使用相对很少，让便宜的8088成为了我们时代主要PC架构（IBM PC架构）的第一个处理器。  8088使用8位数据总线，这使其速度稍慢一些，但它使构建基于该总线的客户更容易访问的系统成为可能。 <br><br> 有趣的是，英特尔从根本上拒绝对其处理器进行改进，而是选择开发下一代处理器。 作为日本最大的第二分包商（NEC）之一，日本公司NEC在80年代初比英特尔大得多。日本公司决定改进8088和8086，发布与插槽兼容的V20和V30处理器，速度最高可提高30％。  NEC甚至提议英特尔成为其分包商！ 英特尔反而对NEC提起了诉讼，但未能成功。 出于某种原因，维基百科完全忽略了英特尔与NEC之间的这场激烈对决。 <br><br>  80186和80286出现在1982年。因此，可以假设英特尔有两个几乎独立的开发团队。  80186是8086的改进，它通过一些命令和缩短的时间，以及x86架构中的几种典型集成电路：时钟发生器，计时器，DMA / DAP，中断控制器，延迟发生器等。这样的处理器似乎可以大大简化生产基于它的计算机，但是由于某种原因内置的中断控制器与IBM PC不兼容，因此几乎从未在PC上使用过。 作者仅了解基于BBC Micro计算机的BBC Master 512系统，该系统甚至不使用内置电路，甚至不使用计时器，但是还有更多系统使用80186。80186的可寻址内存与8086中的方式相同，大小为1 MB。 日本NEC公司生产的80186类似物与IBM PC兼容。 <br><br>  80286的时序比80,186还要好，其中22个小节的奇妙除法（32/16 = 16,16）特别值得注意-从那时起就没有学会除法做得更快！  80286支持与所有新的80186团队一起工作，并且支持许多团队以新的受保护模式工作。  80286是第一款内置支持保护模式的处理器，它可以组织内存保护，正确使用特权指令和访问虚拟内存。 尽管在新模式下工作会产生很多问题（保护模式制作得不太成功）并且相对很少使用，但这是一个很大的突破。 在这种新模式下，段寄存器获得了新的质量，每个任务最多可以使用16 MB的可寻址内存和1 GB的虚拟内存。  80286的最大问题是无法从保护模式切换到实模式，那时大多数程序都在该模式下工作。 使用未公开的“秘密” LOADALL指令，可以在内存和实模式下使用16 MB。 <br><br> 在80286中，指令操作数中地址的计算开始由单独的方案执行，并且不再减慢命令的执行速度。 例如，这增加了有趣的功能 <br><br><pre> <code class="plaintext">LEA AX,[BX+SI+4000]</code> </pre> <br> 仅用3个周期，就可以执行两次加法并将结果传输到AX寄存器！ <br><br> 受保护模式下的分段寄存器已成为完整内存管理系统（MMU）的一部分。 在实模式下，这些寄存器仅部分提供MMU功能。 <br><br> 使用80286的制造商和特定系统的数量很多，但是，当然，第一批具有性能指标的IBM PC AT计算机在个人计算机中几乎是很棒的。 在这些计算机上，内存的速度开始从处理器开始落后，出现了延迟状态，但是这似乎是暂时的。 <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与8086/8088中一样，在80286中，不能正确地100％实现中断的工作，这在极少数情况下可能导致非常不愉快的后果。例如，80286的POPF命令在执行期间始终允许中断，并且在8086/8088上执行带有两个前缀的命令（例如，使用REP ES：MOVSB）时，在调用中断后，其中一个前缀会丢失。 POPF中的一个错误仅出现在80286的早期版本中。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">受保护的模式80286极为不便，将所有内存分为不超过64 KB的段，并且需要复杂的软件支持才能使用虚拟内存。自从1985年问世以来，80386使得在保护模式下的工作变得非常舒适，可以使用多达4 GB的可寻址内存，并可以在模式之间轻松切换。另外，为了支持多任务处理，为8086的程序创建了虚拟8086模式。对于虚拟内存，可以使用相对易于管理的页面模式。 80386及其所有创新都保留了与为80286编写的程序的完全兼容性。在80386的创新中，我们还可以提到将寄存器扩展到32位并增加了两个新的段寄存器。时机已经改变，但模棱两可。快速移位器已添加这样就可以以一个定时进行多次换档。但是，由于某种原因，这种创新大大降低了循环移位指令的执行速度。乘法的速度已经比80286的速度慢了一些。相反，使用内存的速度有所提高，但这不适用于字符串命令，后者的速度比80286还快。该材料的作者经常碰到这样的观点，即在实模式下使用16-最后，在相同频率下，位码80286仍比80386快一点。该材料的作者不止一次地提出这样的观点，即在实模式下使用16位代码80286，最后，它仍然比相同频率下的80386快一点。该材料的作者不止一次地提出这样的观点，即在实模式下使用16位代码80286，最后，它仍然比相同频率下的80386快一点。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在80386中添加了新命令，其中大多数仅提供了处理数据的新方法，实际上在某些情况下通过优化复制了可用的命令。</font><font style="vertical-align: inherit;">例如，添加了以下命令：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 按编号检查，设置和重置位，类似于z80的设置； </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 位扫描BSF和BSR； </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 复制带有扩展名或零扩展名的值，MOVSX和MOVZX； </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 根据SETxx操作的标志值设置值； </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 双班SHLD，SHRD。 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在80386出现之前，x86处理器只能使用短的，一字节偏移量的条件跳转-这通常非常不足。使用80386，可以使用两个（或在32位地址模式下为四个）字节的偏移量，尽管新转换的代码变长了两倍（或三倍），但其执行时间与以前相同，短暂的过渡。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过引入4个硬件断点，从根本上改善了调试支持，甚至可以在无法更改的内存地址处停止程序。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与80286相比，主保护模式变得更易于管理，后者使许多继承的命令变得不必要。在主保护模式下，所谓的平面模式使用最大4 GB的段，这将所有段寄存器变成微妙的形式。半文档化的虚幻模式甚至可以像平面模式一样使用所有内存，但是从实模式可以轻松安装和管理。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">英特尔凭借80386拒绝共享其技术，实际上成为了IBM PC架构的处理器的垄断制造商，而随着Motorola的衰弱，它成为其他个人计算机架构的处理器的垄断制造商。</font><font style="vertical-align: inherit;">直到90年代初，基于80386的系统才非常昂贵，当时它们终于以25至40 MHz的频率向大众用户普及。</font><font style="vertical-align: inherit;">C 80386 IBM开始失去其作为IBM PC兼容计算机的领先制造商的地位。</font><font style="vertical-align: inherit;">这尤其体现在以下事实：康柏计算机是1986年基于80386的第一台PC。</font></font><br><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">很难不钦佩80386的创造者所做的大量工作及其成果。</font><font style="vertical-align: inherit;">我什至不敢建议80386所包含的成就要比1970年以前甚至1980年以前人类的所有技术成就都要多。</font></font><br><br></p><p>      80386.   .     ,               .       80386 ,    .     IBTS  XBTS.   80386DX/SX,   AMD,   Intel (     ),      ,       EAX,            POPAD  PUSHAD  ,     BX.       .      ,        .    . <br><br>  ARM      .   ,  ARM   .  Intel  80486.             Intel           –   . <br><br>  80486                ARM  .     -   .  ,           ,   8088!      ,  8 ,  -.    , , CMPXCHG –       IBTS  XBTS (,             80386).     –  ,             32-  BSWAP.           –     .      . <br><br>     80486   .  ,      80486,  VX FT,    Apricot –    1989   18  40  ,     –  60 !           Intel       ARM  Acorn. IBM      80486  1990,    PS/2 90  $17000. <br><br>     Intel  ,   .      ,     8086. ,        ,        AAD  AAM      ,   (      Pentium  15 !).      AND/OR/XOR    , , AND BX,7      (83 E3 07).  ,    ,       ,        80386. ,      8086  80286     ,       .      ADD/ADC/SBB/SUB,      . ,  ,   ,    (?)      .           –       .  , ,   SAL/SHL ( D0 E0, D0 F0  D1 E0, D1 F0)   . ,    ,     . ,     .   ,  Intel     ,     ?  SALC      1995  20 !    ICEBP    10   1985  1995.       LOADALL  LOADALLD –      ,                80286  80386 .        UD1 (0F B9),      .    . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在苏联，8088和8086处理器克隆的生产已被掌握，不可能完全复制80286。 </font></font><br><br></p><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 摩托罗拉：68,000至68040 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 摩托罗拉是唯一一家可以在一段时间内与英特尔在个人计算机处理器生产方面成功竞争的公司。 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">68000于1979年发布，乍一看看上去比8086更令人印象深刻。它具有16个32位寄存器（更确切地说甚至是17个），一个单独的命令计数器和一个状态寄存器。可以直接寻址16 MB的内存，这对大型阵列没有任何限制。但是，对68000的功能进行仔细分析后发现，并非所有功能都像看起来那样好。在那些年中，即使对于中型组织来说，拥有超过1 MB的内存也是无法实现的。 68000中的代码密度比8086中的要差-这意味着具有相同功能的代码将占用68000多的空间。后者也是由于这样的事实，即68k代码的长度应为2个字节的倍数，而x86应该为1。但是有关代码密度的信息是有争议的，因为有证据表明在某些情况下68000可以比8086好在16个寄存器中，有8个是可寻址的，在某些方面，它们是x86段寄存器的稍微高级些的类似物。 ALU和数据总线是16位的，因此对32位数据的操作比您预期的要慢。寄存器到寄存器操作的执行时间为4个周期，而8086的执行时间仅为2个周期。直到20世纪80年代中期，基于68000的计算机比基于Intel 8088的计算机要昂贵得多，但是68000无法与虚拟内存一起使用并且没有硬件支持使用实数，这使其不适用于最高级的系统。比基于Intel 8088的处理器要高，但是68000不能与虚拟内存一起使用，并且不支持对实数进行操作的硬件支持，这使其不适用于最高级的系统。比基于Intel 8088的处理器要高，但是68000不能与虚拟内存一起使用，并且不支持对实数进行操作的硬件支持，这使其不适用于最高级的系统。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与往常一样，在摩托罗拉的产品中，68000架构显示出一些笨拙和牵强的奇特之处。例如，两个堆栈或两个进位标志（一个用于功能，一个用于操作）。带有标志的奇怪之处并不在那里结束。由于某些原因，许多团队，甚至包括MOVE，都充满了进位和溢出标志的标志。另一个奇怪的是，用于保存算术标志状态的命令（在68000中可以正常工作）已从68010开始在所有处理器中享有特权。某些操作对它们的非优化感到烦恼，例如，将零写入CLR内存的操作比使用MOVE将常数0写入内存的操作要慢。或向左移动比向其自身添加操作数慢。实际上有一些不必要的命令，例如，算术和逻辑左移都有。甚至具有比8086段寄存器看似优越的优点的地址寄存器也有许多令人讨厌的缺点。例如，在它们中，需要加载多达4个字节，而不是在8086中加载两个字节，这四个字节之一是多余的。 68000命令系统与60年代开发的PDP-11命令系统具有许多相似之处。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与x86或ARM相比，摩托罗拉的代码看起来更笨拙。另一方面，据我估计，6.8万个仍比8086快20-30％。然而，680x0代码也具有自己的特殊美感和优雅，x86的机械性较差。此外，正如与</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eab.abime.net</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">专家的通信所</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">显示的</font></a><font style="vertical-align: inherit;">，68k的代码密度通常比x86更好。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">总体而言，68000是一款优秀的处理器，带有大型指令系统。它被用于许多传奇性的个人计算机中：在90年代初生产的第一批Apple Macintosh计算机中，在第一批Commodore Amiga多媒体计算机中，在相对便宜和高质量的Atari ST计算机中。 68,000还被用于使用Unix变体的相对便宜的计算机中，尤其是在颇受欢迎的Tandy 16B中。有趣的是，IBM与PC的开发同时进行了基于68000的System 9000计算机的开发，该系统在PC推出不到一年的时间内就发布了。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">68010出现的时间显然很晚，仅在1982年，与此同时，英特尔发布了80286，使个人计算机达到了微型计算机的水平。 68010与68000连接器兼容，但是其命令系统略有不同，因此用68010取代68000并不流行。不兼容是由牵强的原因导致的，该原因使68,000个以上与组织虚拟化支持的理想理论保持一致。 68010只是略微一点，比68000快不超过10％。很明显68010损失了80286，甚至比同年出现的800186还要弱；像80186一样，68010几乎从未在个人计算机中使用过。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">68008也于1982年发布，可能希望重蹈8088的覆辙。这是68000，但带有8位数据总线，使其可以用于较便宜的系统。但是68008与68000一样，没有命令行，这使其比68000慢50％。因此，68008甚至比8088慢一点，因为8088，由于命令行，它仅慢20％比8086。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基于此，克莱夫·辛克莱爵士（Sir Clive Sinclair）制作了Spectrum QL-这是一台非常有趣的计算机，由于价格较低，可以与Atari ST和类似计算机竞争。但是Clive同时明显地过早地开始在电动汽车的开发上投入大量精力，而把QL（量子跃迁-量子跃迁）留给了次要任务，而由于一些不成功的设计解决方案，导致Clive的计算机和整个公司过早地关闭了（该公司成为了一部分Amstrad，拒绝提供QL）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">计算68000的位索引会很有趣，在我看来，它显然高于16，尽管更可能不高于24。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自1984年问世以来，68020再次将摩托罗拉带回了第一位置。该处理器已经实现了许多非常有趣和有希望的新产品。最强的效果肯定是由指令管道产生的，有时它使您可以一次执行多达三个指令！在那几年，32位地址总线看起来还为时过早，因此，生产了价格便宜的带有24位总线的68020EC处理器。但是32位数据总线看起来相当合适，可以大大加快工作速度。新颖性还着眼于内置高速缓存，尽管容量很小，只有256个字节，但由于主动态内存无法跟上处理器的速度，因此可以显着提高性能。快速除法（64/32 = 32.32）和乘法（32 * 32 = 64）分别增加了大约80个和最多45个小节的快速运算。指令的时序通常得到了显着改善，例如，除法（32/16 = 16.16）开始执行的时间约为45个周期（68000中超过140个周期）。在最有利的情况下，某些指令可以完全不占用周期地执行！添加了新的寻址模式，尤其是缩放功能-在x86中，该模式仅在明年出现在80386中。其他新的寻址模式允许使用双重间接寻址，同时使用多个偏移量-此处PDP-11被大大超越。具有缩放功能-在x86中，该模式仅在明年出现在80386中。其他新的寻址模式允许使用双重间接寻址，同时使用多个偏移量-PDP-11在此被大大超越。具有缩放功能-在x86中，该模式仅在明年出现在80386中。其他新的寻址模式允许使用双间接寻址，并使用多个偏移量-此处PDP-11被大大超越。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是一些新的指令，例如具有位字段的繁重运算或具有10个数字的新运算，这些运算对于快速除法和乘法来说就不必要了，看起来更像是推车中的第五个轮子，而不是本质上有用的东西。具有双重间接寻址的地址模式在理论上看起来很有趣，但实际上很少需要，而且执行速度很慢。与80286不同，68020需要花费一些时间来计算操作数的地址，即所谓的有效地址。 68020的除法速度几乎是奇迹除法器80286的两倍。乘法和某些运算也较慢。 68020没有集成的内存管理系统（MMU），但是连接多达八个协处理器的奇特功能无法解决此问题。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">68020被广泛用于大型的Apple Macintosh II，Macintosh LC和Commodore Amiga 1200计算机，并且还用于多个Unix系统。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">80386的出现及其内置的，非常坚固的MMU和32位总线和寄存器使摩托罗拉再次排名第二。68030自1987年以来首次出现，能够在短时间内重新夺回摩托罗拉的领导地位。 68030具有集成的内存管理系统和加倍的缓存，分为用于指令和数据的缓存-这是非常有前途的新产品。另外，68030可以使用更快的内存访问接口，这可以将内存操作速度提高近三分之一。但是，尽管进行了所有创新，但在相同频率下68030的速度比80386略慢。但是，68030的可用频率最高为50 MHz，而80386的最高频率只有40 MHz，这使得基于68030的顶级系统速度稍快。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">68030用于Apple Macintosh II系列计算机，Commodore Amiga 3000，Atari TT，Atari Falcon和其他一些计算机。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">凭借68040，摩托罗拉再次试图超越英特尔。该处理器在80486之后的一年后出现，但是就有用的品质而言，它不能超过它。实际上，拥有更重载命令系统的摩托罗拉无法支持它，从某种意义上说，它失去了跟踪。在68040中，他们只能放置一个非常短的协处理器来处理实数，并且芯片本身的预热大大超过80486。根据lowendmac.com/benchmarks 68040上的结果，它仅比68030快2.1倍，这意味着68040的速度比80486略慢相同的频率。 68040实际上在流行的计算机中找不到应用程序。只有其更便宜的选件68LC040（没有集成协处理器）才有明显的用途。可是该芯片的第一个版本存在严重的硬件缺陷，甚至不允许使用协处理器的软件仿真！</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">摩托罗拉一直在数学协处理器方面遇到问题。</font><font style="vertical-align: inherit;">如前所述，摩托罗拉尚未针对68000/68010发布这种协处理器，而英特尔自1980年以来就发布了非常成功的8087。为68020/68030处理器，立即生产了两个68881协处理器及其改进的引脚兼容版本68882。但是为了获得显着的性能提升，需要对68882的代码进行与68881不同的编译。应该</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">说Intel x86的数学协处理器仍然存在问题-某些函数（例如某些参数的正弦值）的计算精度非常小，</font><font style="vertical-align: inherit;">有时不超过4个字符。</font><font style="vertical-align: inherit;">因此，现代编译器通常在不借助协处理器的服务的情况下计算此类函数。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 美国国家半导体32016 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是1982年首次提出在计算机中使用的第一个真正的32位处理器。该处理器最初计划为芯片上的VAX-11，但是由于无法与DEC协商，美国国家半导体（NS）必须将处理器仅制造类似的单独部件。在VAX-11架构上。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分页虚拟内存的使用始于此处理器-今天，它已成为主流技术。但是对虚拟内存的支持不是内置在处理器中，而是需要一个协处理器。还需要一个单独的协处理器来处理实数。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NS32016指令系统非常庞大，类似于VAX-11指令系统，特别是具有用于子程序框架的单独堆栈。地址总线是24位的，这使您最多可以使用16 MB的内存。 32016的特色是带有标志的作品。除了标准进位标志（也可以用作条件转换的标志），溢出，符号，相等（或零）之外，还有L（较少）标志，这意味着较少就像进位用于比较。传输情况类似于Motorola 680x0处理器。出于某种原因，该溢出标志被称为F。存在分步模式，特权模式和（唯一性！）标志来选择当前堆栈。执行算术指令时，未设置符号，零，少数（L）的标志，只能通过比较命令进行设置。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以使用八个32位通用寄存器。另外，还有一个命令计数器，两个堆栈指针，一个子程序框架堆栈指针，一个程序基本指针（这是唯一的），一个模块基本指针（也很罕见），一个指向中断向量表的指针，配置寄存器和寄存器条件。在速度方面，NS32016相当于68,000。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">据我所知，32016仅与BBC Micro个人计算机一起用作第二处理器。</font><font style="vertical-align: inherit;">它是1984年非常昂贵且享有盛誉的前缀。</font><font style="vertical-align: inherit;">可以订购频率为6、8和10 MHz的处理器。</font><font style="vertical-align: inherit;">后者存在一些技术问题，而且非常昂贵。</font><font style="vertical-align: inherit;">32016的软件非常少，仅由Acorn，类似于Panos的Unix操作系统和Acorn BASIC制造。</font><font style="vertical-align: inherit;">BBC Micro没有使用MMU芯片-尽管可以连接MMU芯片，但是没有程序可以使用它。</font><font style="vertical-align: inherit;">甚至没有提供算术协处理器。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">众所周知，这种非常复杂的处理器具有严重的硬件错误，已经修复了多年。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 橡子臂 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6502的思想，即使其更简单，更便宜，更好，在1985年发布的ARM-1处理器Acorn的近乎神奇的发展中得到了延续，与英特尔的技术奇迹处理器80386同时出现。ARM的体积缩小了一个数量级。晶体管的数量，因此消耗的能量明显减少，并且平均速度要快得多。当然，ARM没有任何MMU甚至除法和乘法运算，因此在某些基于除法80386的计算中可能会更快。但是，ARM的优势是如此之大，以至于如今它已成为最庞大的处理器架构。已经发布了超过1000亿个这样的处理器。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在Acorn对32016处理器进行研究之后，ARM的发展始于1983年。该研究表明，在许多计算中，6502的工作频率可能比它快得多，而性能似乎要强得多。然后80286已经可用，表现出非常好的性能，但是Intel也许感觉到小公司Acorn的潜力很小，因此拒绝提供其处理器进行测试。同时，技术80286并未像80386那样被关闭，而是被转移给了许多公司，因此历史仍在等待揭露这种不寻常的故障的细节。也许如果Intel允许使用其处理器，那么Acorn将会使用它，并且不会开始开发ARM。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ARM由几个人开发，并使用BBC Micro BASIC测试了命令系统。开发本身发生在前杂物间的建筑中，该杂物间通常被称为谷仓或谷仓。处理器的首次亮相结果并不成功。 1986年，发布了一个名为ARM评估系统的BBC Micro机顶盒，除了处理器外还包含4 MB的内存（这几年来很多），这使该机顶盒成为非常昂贵的产品（其价格超过4,000英镑，即大约4,000英镑）。 $ 6,000）。当然，如果将它与当时具有速度可比功能的计算机进行比较，那么前缀竟然便宜了一个数量级，甚至便宜了将近两个。但是新系统的程序很少。这有点奇怪由于很有可能将Unix移植到该系统上，因此可以使用许多不需要MMU的Unix变体，所以有PDP-11、68000、80186甚至8088的Unix变体。很好奇的是在90年代移植了Acorn Archimedes的Linux可能是由于Acorn不愿将ARM技术转让给其他公司而导致了针对ARM引入真正的Unix的延迟。</font></font><br><br><img src="http://www.computinghistory.org.uk/userdata/images/large/70/88/product-77088.jpg"><br> <i>    ARM</i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">橡子的行销政策不太成功，到1985年，公司陷入了非常困难的财务状况。除了ARM以外，Acorn还尝试进行昂贵的商业计算机开发，但由于选择了32016处理器的缺点而失败，Acorn Communicator也不是很成功。相对成功但不完全兼容IBM PC的Master 512计算机的开发非常昂贵。此外，大量资金被用于进入美国市场的失败尝试，意大利公司Olivetti凭借其相当成功的基于Intel 8086和80286的计算机被允许进入一个假设的大型游戏框架以接管Acorn。顺便说一句，在橡子收购之后Olivetti在美国市场上的作用很快就减弱了。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作为Olivetti的一部分，Acorn已经开发了带有内置乘法命令的改进型ARM2芯片，在此基础上制造了当时令人赞叹的Archimedes个人计算机，该产品的第一批型号于1987年面世。但是，Olivetti管理层的目标是与IBM PC兼容计算机和他不想利用自己的资源来出售橡子产品。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ARM提供了16个32位寄存器供使用（如果考虑系统需求的寄存器，实际上还有更多）。像PDP-11架构一样，寄存器之一R15是命令计数器。几乎所有操作都在1个周期内执行。特别是对于过渡，乘法和内存访问，需要采取更多措施。相比之下，与那些年的主要处理器相比，ARM的独特之处在于没有像堆栈这样的典型结构。如有必要，可通过其中一个寄存器来实现堆栈。调用子例程时，不使用堆栈；相反，返回地址存储在为其分配的寄存器中。这种方案显然不适用于嵌套调用，而嵌套调用必须组织一个堆栈。 ARM的独特功能是命令计数器（26位）的组合，也就是说，它允许使用状态寄存器寻址多达64 MB的内存。在此组合寄存器中为标志分配了八位，由于未使用地址的低两位，因此又获得了该寄存器中的另外两个位，因为代码必须在4字节字的边界上对齐。处理器可以访问字节和4字节的字，不能直接访问16位数据。 ARM数据指令为3地址。 RISC体系结构的一个特征是仅将寄存器存储器类型的命令用于装载和卸载数据。 ARM具有内置的快速移位器（Barrel Shifter），它使您可以将命令中寄存器之一的值移位任意次，而无需花费时钟周期。例如，可以用一个单周期加法命令将寄存器R0的值乘以65并将结果放入寄存器R1中可以用一个单周期加法命令将寄存器R0的值乘以65并将结果放入寄存器R1中</font></font><br><br><pre> <code class="plaintext">ADD R1, R0, R0 shl 6</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，然后乘以63</font></font><br><br><pre> <code class="plaintext">RSB R1, R0, R0 shl 6</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指令系统具有反减法，这特别允许该指令的特殊情况下为一进制负号并加快除法速度。 ARM的另一个独特功能是：其所有指令都是有条件的。每个指令有16种情况（标志组合）。仅当当前标志集与该指令中的标志匹配时，才执行该指令。通常，在其他体系结构的处理器中，此类执行仅针对条件转换进行。 ARM的此功能在许多情况下都可以避免缓慢的过渡操作。后者还有助于在执行算术运算时可以拒绝设置状态标志。与6809处理器一样，使用ARM，您可以同时使用快速中断和常规中断。也在中断模式下，高编号的寄存器被系统寄存器替换，这使中断处理程序更紧凑和更快。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与x86处理器指令系统相比，ARM指令系统包含的基本指令要少得多。但是ARM上的指令本身非常灵活和强大。几条非常方便且功能强大的ARM指令没有80386的类似物，例如，RSB（反向减法），BIC（与取反，PDP-11具有这样的命令），4地址MLA（与求和相乘），LDM和STM（从内存中加载或卸载多个寄存器，类似于68k处理器的MOVEM命令）。几乎所有的ARM指令都是3地址的，几乎所有80386指令的操作数都不超过2。 ARM指令系统更正交-所有寄存器都是可互换的，只有寄存器R14和R15例外。大多数ARM命令可能需要3-4个80386命令进行仿真，而大多数80386命令可以使用2-3个ARM命令进行仿真。有趣的带有8 MHz处理器的Acorn Archimedes计算机硬件上的IBM PC XT模拟器比真正的PC XT计算机还要快。在带有78000 MHz的68000处理器的Commodore Amiga计算机上，仿真器只能以不超过真实PC XT的10-15％的速度运行。同样有趣的是，首批25 MHz 68030的NeXT计算机在相同的8 MHz ARM级别上显示了整数计算的性能。苹果公司打算在莫比乌斯项目[]中制造苹果计算机的后继计算机，但是事实证明，这台计算机的仿真模式不仅超越了苹果计算机[]，而且还超越了基于68k处理器的Macintosh，该项目已关闭！在带有78000 MHz的68000处理器的Commodore Amiga计算机上，仿真器只能以不超过真实PC XT的10-15％的速度运行。同样有趣的是，首批25 MHz 68030的NeXT计算机在相同的8 MHz ARM级别上显示了整数计算的性能。苹果公司打算在Möbius项目中制造苹果的后继计算机[]，但是事实证明，这台计算机在仿真模式下的原型不仅胜过苹果公司[]，而且还超越了基于68k处理器的Macintosh，该项目已经关闭！在带有78000 MHz的68000处理器的Commodore Amiga计算机上，仿真器只能以不超过真实PC XT的10-15％的速度运行。同样有趣的是，首批25 MHz 68030的NeXT计算机在相同的8 MHz ARM级别上显示了整数计算的性能。苹果公司打算在Möbius项目中制造苹果的后继计算机[]，但是事实证明，这台计算机在仿真模式下的原型不仅胜过苹果公司[]，而且还超越了基于68k处理器的Macintosh，该项目已经关闭！该计算机在仿真模式下的原型不仅超越了Apple []，而且超越了基于68k处理器的Macintosh，该项目已关闭！该计算机在仿真模式下的原型不仅超越了Apple []，而且超越了基于68k处理器的Macintosh，该项目已关闭！</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在ARM的缺点中，有一个可以指出将常量加载到寄存器中的问题。尽管常数可以反转和移位，但一次只能加载8位。因此，加载完整的32位常量最多需要4个命令。当然，您可以使用一个命令从内存中加载常数，但是由于指定的偏移量只能为12位，因此会出现指定此地址的问题。 ARM的另一个缺点是代码密度相对较低，这会使程序变得更大，并且最重要的是降低了处理器缓存的效率。但是，这可能是该平台编译器质量低下的结果。长期以来，ARM的一个显着缺点是缺乏对内存管理（MMU）的内置支持-例如，在90年代初期，Apple就需要这种支持。用于ARM架构的用于实数的协处理器也开始大量使用。 ARM没有x86拥有的高级调试工具。 ARM的标准汇编语言仍然存在一些奇怪之处：习惯上写以逗号分隔的移位器操作。因此，代替了简单的形式</font></font><pre> <code class="plaintext">R1 shl 7</code> </pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -将寄存器R1的内容向左移动7位-您需要写 </font></font><pre> <code class="plaintext">R1, shl 7</code> </pre>  。 <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从1989年开始，带有内置缓存的ARM3面市。</font><font style="vertical-align: inherit;">1990年，ARM开发团队从Acorn分离出来，并使用Apple和VLSI创建了ARM Holding。</font><font style="vertical-align: inherit;">据Acorn-Olivetti管理层称，分离的原因之一是开发ARM的成本太高。</font><font style="vertical-align: inherit;">随后，橡果停止了其独立存在，ARM Holding变成了一家大公司。</font><font style="vertical-align: inherit;">苹果公司希望在其牛顿计算机中安装一个ARM处理器，而不依赖于其他计算机制造商，这导致了橡果与ARM控股公司的分离。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ARM在整数数据上显示出性能，在相同频率下超过80486达到10-20％！</font><font style="vertical-align: inherit;">英特尔能够获得使用时钟倍频技术的好处，然后用奔腾处理器将其牢固地修复。</font><font style="vertical-align: inherit;">DEC StrongARM能够在1996年短暂恢复领导地位，此后该技术被Intel收购，后者自此成为ARM体系结构处理器的主要制造商。</font><font style="vertical-align: inherit;">因此，有两个中心来开发此体系结构。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ARM技术的进一步发展也很令人好奇，但这是另一个故事。</font><font style="vertical-align: inherit;">值得一提的是，由于90年代苹果公司能够避免破产，这归功于ARM控股公司的股份。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 一些结论，假设和问题。 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">很难摆脱这样一种感觉，即8位处理器只是对计算机历史舞台上70年代和80年代主要角色的不受欢迎的需求。实际上，最成功的8拍打器6502被冻结了。英特尔和摩托罗拉相当放慢了自己对小型处理器的开发速度，并限制了其他开发人员。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我几乎可以肯定，Amiga或Atari ST在与6502兼容的20位或24位地址的4 MHz处理器上比68000可以更好，更快地工作。Bill Mensch最近表示，今天10GHz的6502并不难。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果Commodore CBM II可以分享其成功的Amstrad PCW系列开始在更高的频率上使用经过优化的z80，那么该系列很有可能会在10年前成为现实。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果ARM于1982年制造出来，那世界将是什么样？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果家用计算机不是复制和开发最昂贵的技术而是最有前途的技术，将会是什么样？</font></font><p></p><p></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN410591/">https://habr.com/ru/post/zh-CN410591/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN410581/index.html">酗酒是痴呆的最快方法</a></li>
<li><a href="../zh-CN410583/index.html">三星Gear VR：使用一个月后的印象</a></li>
<li><a href="../zh-CN410585/index.html">如何成为魔术师（第1部分）</a></li>
<li><a href="../zh-CN410587/index.html">苹果打算独家向矿业公司购买钴</a></li>
<li><a href="../zh-CN410589/index.html">能够适应全球变暖的海洋生态系统</a></li>
<li><a href="../zh-CN410593/index.html">电报进行另一轮ICO</a></li>
<li><a href="../zh-CN410597/index.html">另一个智能家居设备</a></li>
<li><a href="../zh-CN410599/index.html">一波来自采矿场的设备盗窃横扫冰岛</a></li>
<li><a href="../zh-CN410601/index.html">今天的教育机器人是什么</a></li>
<li><a href="../zh-CN410603/index.html">所有权宣言</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>