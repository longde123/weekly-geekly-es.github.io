<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõÄüèø üóùÔ∏è üßëüèæ‚Äçü§ù‚ÄçüßëüèΩ An√°lise est√°tica do c√≥digo PHP usando PHPStan, Phan e Salmo como exemplo ‚ú°Ô∏è ‚õ™Ô∏è ‚óºÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O Badoo existe h√° mais de 12 anos. Temos muito c√≥digo PHP (milh√µes de linhas) e provavelmente at√© as linhas escritas h√° 12 anos foram preservadas. Tem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>An√°lise est√°tica do c√≥digo PHP usando PHPStan, Phan e Salmo como exemplo</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/426605/"><img src="https://habrastorage.org/webt/yj/nq/4_/yjnq4_9tdzj0noyiimybxjpoctk.jpeg"><br><br>  O Badoo existe h√° mais de 12 anos.  Temos muito c√≥digo PHP (milh√µes de linhas) e provavelmente at√© as linhas escritas h√° 12 anos foram preservadas.  Temos c√≥digo gravado nos dias do PHP 4 e PHP 5. Carregamos o c√≥digo duas vezes por dia e cada layout cont√©m cerca de 10 a 20 tarefas.  Al√©m disso, os programadores podem publicar corre√ß√µes urgentes - pequenas altera√ß√µes.  E no dia de tais corre√ß√µes, ganhamos algumas d√∫zias.  Em geral, nosso c√≥digo est√° mudando muito ativamente. <br><br>  Estamos constantemente √† procura de oportunidades para acelerar o desenvolvimento e melhorar a qualidade do c√≥digo.  Ent√£o, um dia, decidimos implementar a an√°lise de c√≥digo est√°tico.  O que veio disso, leia abaixo do corte. <br><a name="habracut"></a><br><h1>  Tipos estritos: por que ainda n√£o o estamos usando </h1><br>  Uma vez, iniciou-se uma discuss√£o em nosso bate-papo corporativo sobre PHP.  Um dos novos funcion√°rios contou como, no local de trabalho anterior, eles introduziram as dicas obrigat√≥rias do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tipo</a> strict_types + escalar para todo o c√≥digo - e isso reduziu significativamente o n√∫mero de bugs na produ√ß√£o. <br><br>  A maioria dos veteranos do bate-papo era contra essa inova√ß√£o.  O principal motivo foi que o PHP n√£o possui um compilador que verifique todos os tipos no c√≥digo no est√°gio de compila√ß√£o, e se voc√™ n√£o tiver 100% de cobertura do c√≥digo com testes, sempre haver√° o risco de que erros apare√ßam na produ√ß√£o, o que n√£o temos quer permitir. <br><br>  Obviamente, strict_types encontrar√° uma certa porcentagem de erros causados ‚Äã‚Äãpela incompatibilidade de tipos e como o PHP "silenciosamente" converte tipos.  Mas muitos programadores experientes em PHP j√° sabem como o sistema de tipos em PHP funciona, por quais regras a convers√£o de tipos acontece e, na maioria dos casos, eles escrevem c√≥digo de trabalho correto. <br><br>  Mas a ideia de ter um certo sistema mostrando onde no c√≥digo h√° uma incompatibilidade de tipos, gostamos.  Pensamos em alternativas para strict_types. <br><br>  No come√ßo, quer√≠amos at√© corrigir o PHP.  Quer√≠amos que, se a fun√ß√£o usasse algum tipo de escalar (digamos int) e outro tipo escalar (como float), ent√£o TypeError (que √© uma exce√ß√£o em si) n√£o seria lan√ßado, mas ocorreria uma convers√£o de tipo, bem como registrar esse evento em error.log.  Isso nos permitiria encontrar todos os lugares onde nossas suposi√ß√µes sobre tipos est√£o incorretas.  Mas esse patch parecia arriscado para n√≥s, e at√© poderia haver problemas com depend√™ncias externas que n√£o estavam prontas para esse comportamento. <br><br>  Abandonamos a id√©ia de corrigir o PHP, mas com o tempo tudo coincidiu com os primeiros lan√ßamentos do analisador est√°tico Phan, os primeiros commits feitos pelo pr√≥prio Rasmus Lerdorf.  Ent√£o, tivemos a ideia de tentar analisadores de c√≥digo est√°tico. <br><br><h1>  O que √© an√°lise de c√≥digo est√°tico? </h1><br>  Os analisadores de c√≥digo est√°tico apenas leem o c√≥digo e tentam encontrar erros nele.  Eles podem executar verifica√ß√µes muito simples e √≥bvias (por exemplo, a exist√™ncia de classes, m√©todos e fun√ß√µes e outras mais complicadas (por exemplo, procurar incompatibilidades de tipos, condi√ß√µes de corrida ou vulnerabilidades no c√≥digo) .A chave √© que os analisadores n√£o executam c√≥digo - eles analise o texto do programa e verifique erros t√≠picos (e n√£o muito). <br><br>  O exemplo mais √≥bvio de um analisador de c√≥digo PHP est√°tico s√£o as inspe√ß√µes no PHPStorm: quando voc√™ escreve um c√≥digo, destaca chamadas incorretas para fun√ß√µes, m√©todos, incompatibilidades de tipo de par√¢metro, etc. No entanto, o PHPStorm n√£o executa seu c√≥digo PHP - apenas o analisa. <br><br>  Observo que neste artigo estamos falando de analisadores que procuram erros no c√≥digo.  H√° outra classe de analisadores - eles verificam o estilo de escrita do c√≥digo, a complexidade ciclom√°tica, os tamanhos dos m√©todos, os comprimentos das linhas etc. N√£o consideramos esses analisadores aqui. <br><br>  Embora nem tudo o que os analisadores que estamos considerando encontre seja precisamente um erro.  Por engano, quero dizer o c√≥digo que Fatal criar√° na produ√ß√£o.  Muitas vezes, o que os analisadores descobrem √© provavelmente uma imprecis√£o.  Por exemplo, um tipo de par√¢metro incorreto pode ser especificado no PHPDoc.  Essa imprecis√£o n√£o afeta a opera√ß√£o do c√≥digo, mas subsequentemente o c√≥digo evoluir√° - outro programador pode cometer um erro. <br><br><h1>  Analisadores de c√≥digo PHP existentes </h1><br>  Existem tr√™s analisadores de c√≥digo PHP populares: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PHPStan</a> . <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Salmo</a> . <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Phan</a> . <br></li></ol><br>  E h√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Exakat</a> , que n√£o tentamos. <br><br>  No lado do usu√°rio, todos os tr√™s analisadores s√£o os mesmos: voc√™ os instala (provavelmente atrav√©s do Composer), os configura e depois pode iniciar a an√°lise de todo o projeto ou grupo de arquivos.  Como regra, o analisador pode exibir belamente os resultados no console.  Voc√™ tamb√©m pode produzir os resultados no formato JSON e us√°-los no IC. <br><br>  Todos os tr√™s projetos est√£o agora se desenvolvendo ativamente.  Seus mantenedores s√£o muito ativos na resposta a problemas no GitHub.  Frequentemente, no primeiro dia ap√≥s a cria√ß√£o de um ticket, eles reagem a ele pelo menos (comente ou coloque uma tag como bug / aprimoramento).  Muitos bugs que encontramos foram corrigidos em alguns dias.  Mas gosto especialmente do fato de que os mantenedores do projeto se comunicam ativamente entre si, relatam bugs e enviam solicita√ß√µes pull. <br><br>  Implementamos e usamos todos os tr√™s analisadores.  Cada um tem suas pr√≥prias nuances, seus pr√≥prios insetos.  Por√©m, o uso de tr√™s analisadores ao mesmo tempo facilita a compreens√£o de onde est√° o problema real e onde est√° o falso positivo. <br><br><h2>  O que os analisadores podem fazer </h2><br>  Os analisadores t√™m muitos recursos em comum. Primeiro, veremos o que todos eles podem fazer e depois passaremos aos recursos de cada um deles. <br><br><h3>  Verifica√ß√µes padr√£o </h3><br>  Obviamente, os analisadores realizam todas as verifica√ß√µes de c√≥digo padr√£o pelo fato de: <br><br><ul><li>  O c√≥digo n√£o cont√©m erros de sintaxe; <br></li><li>  existem todas as classes, m√©todos, fun√ß√µes, constantes; <br></li><li>  existem vari√°veis; <br></li><li>  no PHPDoc, as dicas s√£o verdadeiras. <br></li></ul><br>  Al√©m disso, os analisadores verificam o c√≥digo em busca de argumentos e vari√°veis ‚Äã‚Äãn√£o utilizados.  Muitos desses erros levam a fatais reais no c√≥digo. <br><br>  √Ä primeira vista, pode parecer que bons programadores n√£o cometem tais erros, mas √†s vezes temos pressa, √†s vezes copia e cola, √†s vezes simplesmente desatentos.  E nesses casos, essas verifica√ß√µes economizam muito. <br><br><h3>  Verifica√ß√µes de tipo de dados </h3><br>  Obviamente, os analisadores est√°ticos tamb√©m realizam verifica√ß√µes padr√£o em rela√ß√£o aos tipos de dados.  Se estiver escrito no c√≥digo que a fun√ß√£o aceita, digamos, int, o analisador verificar√° se h√° lugares onde um objeto √© passado para essa fun√ß√£o.  Para a maioria dos analisadores, voc√™ pode configurar a gravidade do teste e simular strict_types: verifique se nenhuma string ou Boolean √© passada para esta fun√ß√£o. <br><br>  Al√©m das verifica√ß√µes padr√£o, os analisadores ainda t√™m muito o que fazer. <br><br>  <b>Tipos de uni√£o</b> <br><br>  Todos os analisadores suportam o conceito de tipos de uni√£o.  Suponha que voc√™ tenha uma fun√ß√£o como: <br><br><pre><code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> string|int|bool $yes_or_no */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isYes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($yes_or_no)</span></span></span><span class="hljs-function"> :</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (\is_bool($yes_or_no)) {         <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $yes_or_no;     } <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> (is_numeric($yes_or_no)) {         <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $yes_or_no &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>;     } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {         <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> strtoupper($yes_or_no) == <span class="hljs-string"><span class="hljs-string">'YES'</span></span>;     } }</code> </pre> <br>  Seu conte√∫do n√£o √© muito importante - o tipo do par√¢metro de entrada <code>string|int|bool</code> √© importante.  Ou seja, a vari√°vel <code>$yes_or_no</code> √© uma sequ√™ncia de caracteres, um n√∫mero inteiro ou um <code>Boolean</code> . <br><br>  Usando PHP, este tipo de par√¢metro de fun√ß√£o n√£o pode ser descrito.  Mas no PHPDoc, isso √© poss√≠vel, e muitos editores (como o PHPStorm) entendem. <br><br>  Nos analisadores est√°ticos, esse tipo √© chamado de <b>tipo de uni√£o</b> e eles s√£o muito bons em verificar esses tipos de dados.  Por exemplo, se escrevemos a fun√ß√£o acima dessa maneira (sem verificar o valor <code>Boolean</code> ): <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> string|int|bool $yes_or_no */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isYes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($yes_or_no)</span></span></span><span class="hljs-function"> :</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_numeric($yes_or_no)) {        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $yes_or_no &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>;    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> strtoupper($yes_or_no) == <span class="hljs-string"><span class="hljs-string">'YES'</span></span>;    } }</code> </pre> <br>  os analisadores veriam que uma string ou um booleano poderia chegar ao strtoupper e retornar um erro - voc√™ n√£o pode passar um booleano para o strtoupper. <br><br>  Esse tipo de verifica√ß√£o ajuda os programadores a lidar corretamente com erros ou situa√ß√µes em que uma fun√ß√£o n√£o pode retornar dados.  Geralmente escrevemos fun√ß√µes que podem retornar alguns dados ou <code>null</code> : <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// load()  null   \User $User = UserLoader::load($user_id); $User-&gt;getName();</span></span></code> </pre> <br>  No caso de tal c√≥digo, o analisador informar√° que a vari√°vel <code>$User</code> aqui pode ser <code>null</code> e esse c√≥digo pode levar a fatal. <br><br>  <b>Digite false</b> <br><br>  Na pr√≥pria linguagem PHP, existem algumas fun√ß√µes que podem retornar algum valor ou falso.  Se escrev√™ssemos tal fun√ß√£o, como documentar√≠amos seu tipo? <br><br><pre> <code class="php hljs">         <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> resource|bool */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fopen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function"> </span></span>{       ‚Ä¶ }</code> </pre> <br>  Formalmente, tudo parece ser verdade aqui: fopen retorna resource ou <code>false</code> (que √© do tipo <code>Boolean</code> ).  Mas quando dizemos que uma fun√ß√£o retorna algum tipo de tipo de dado, significa que pode retornar <b>qualquer</b> valor de um conjunto pertencente a esse tipo de dado.  No nosso exemplo, para o analisador, isso significa que <code>fopen()</code> pode retornar <code>true</code> .  E, por exemplo, no caso desse c√≥digo: <br><br><pre> <code class="php hljs">$fp = fopen(<span class="hljs-string"><span class="hljs-string">'some.file'</span></span>,<span class="hljs-string"><span class="hljs-string">'r'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($fp === <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) {     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } fwrite($fp, <span class="hljs-string"><span class="hljs-string">"some string"</span></span>);</code> </pre> <br>  os analisadores reclamariam que <code>fwrite</code> aceita o primeiro recurso de par√¢metro e passamos <code>bool</code> (porque o analisador v√™ que uma op√ß√£o verdadeira √© poss√≠vel).  Por esse motivo, todos os analisadores entendem um tipo de dados "artificial" como <code>false</code> e, em nosso exemplo, podemos escrever <code>@return false|resource</code> .  O PHPStorm tamb√©m entende essa descri√ß√£o do tipo. <br><br>  <b>Formas de matriz</b> <br><br>  Muitas vezes, matrizes em PHP s√£o usadas como um tipo de <code>record</code> - uma estrutura com uma lista clara de campos, onde cada campo tem seu pr√≥prio tipo.  Obviamente, muitos programadores j√° usam classes para isso.  Mas temos muito c√≥digo legado no Badoo, e os arrays s√£o usados ‚Äã‚Äãativamente l√°.  E tamb√©m acontece que os programadores s√£o pregui√ßosos demais para criar uma classe separada para alguma estrutura √∫nica e, nesses locais, as matrizes tamb√©m s√£o frequentemente usadas. <br><br>  O problema com essas matrizes √© que n√£o h√° uma descri√ß√£o clara dessa estrutura (uma lista de campos e seus tipos) no c√≥digo.  Os programadores podem cometer erros ao trabalhar com essa estrutura: esque√ßa os campos obrigat√≥rios ou adicione as teclas "esquerda", confundindo ainda mais o c√≥digo. <br><br>  Os analisadores permitem inserir uma descri√ß√£o dessas estruturas: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> array{scheme:string,host:string,path:string} $parsed_url */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showUrl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $parsed_url)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ }</code> </pre> <br>  Neste exemplo, descrevemos uma matriz com tr√™s campos de sequ√™ncia: <code>scheme, host</code> e <code>path</code> .  Se dentro da fun√ß√£o nos voltarmos para outro campo, o analisador mostrar√° um erro. <br><br>  Se voc√™ n√£o descrever os tipos, os analisadores tentar√£o "adivinhar" a estrutura da matriz, mas, como mostra a pr√°tica, eles realmente n√£o ter√£o sucesso com nosso c√≥digo.  :) <br><br>  Essa abordagem tem uma desvantagem.  Suponha que voc√™ tenha uma estrutura usada ativamente no c√≥digo.  Voc√™ n√£o pode declarar um pseud√≥tipo em um local e us√°-lo em qualquer lugar.  Voc√™ precisar√° registrar o PHPDoc com a descri√ß√£o da matriz em qualquer parte do c√≥digo, o que √© muito inconveniente, especialmente se houver muitos campos na matriz.  Tamb√©m ser√° problem√°tico editar esse tipo posteriormente (adicionar e remover campos). <br><br>  <b>Descri√ß√£o dos tipos de chave de matriz</b> <br><br>  No PHP, chaves de matriz podem ser n√∫meros inteiros e seq√º√™ncias de caracteres.  √Äs vezes, tipos podem ser importantes para an√°lise est√°tica (e tamb√©m para programadores).  Analisadores est√°ticos permitem que voc√™ descreva as chaves do array no PHPDoc: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> array&lt;int, \User&gt; $users */</span></span> $users = UserLoaders::loadUsers($user_ids);</code> </pre> <br>  Neste exemplo, usando PHPDoc, adicionamos uma dica de que na matriz <code>$users</code> as chaves s√£o inteiras e os valores s√£o objetos da classe <code>\User</code> .  Poder√≠amos descrever o tipo como \ Usu√°rio [].  Isso informa ao analisador que existem objetos na classe <code>\User</code> na matriz, mas n√£o nos diz nada sobre o tipo de chaves. <br><br>  O PHPStorm suporta esse formato para descrever matrizes a partir da vers√£o 2018.3. <br><br>  <b>Seu espa√ßo para nome no PHPDoc</b> <br><br>  O PHPStorm (e outros editores) e os analisadores est√°ticos podem entender o PHPDoc de maneira diferente.  Por exemplo, os analisadores suportam este formato: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> array{scheme:string,host:string,path:string} $parsed_url */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showUrl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($parsed_url)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ }</code> </pre> <br>  Mas o PHPStorm n√£o o entende.  Mas podemos escrever assim: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> array $parsed_url * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@phan</span></span></span><span class="hljs-comment">-param array{scheme:string,host:string,path:string} $parsed_url * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@psalm</span></span></span><span class="hljs-comment">-param array{scheme:string,host:string,path:string} $parsed_url */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showUrl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($parsed_url)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ }</code> </pre> <br>  Nesse caso, os analisadores e o PHPStorm ser√£o satisfeitos.  O PHPStorm usar√° o <code>@param</code> e os analisadores usar√£o suas pr√≥prias tags PHPDoc. <br><br><h3>  Recursos do PHP </h3><br>  Esse tipo de teste √© melhor ilustrado pelo exemplo. <br><br>  Todos sabemos o que a fun√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">explodir ()</a> pode retornar?  Se voc√™ olhar para a documenta√ß√£o, parece que ela retorna uma matriz.  Mas se voc√™ examin√°-lo com mais cuidado, veremos que ele tamb√©m pode retornar falso.  De fato, ele pode retornar nulo e um erro se voc√™ passar os tipos errados, mas passar o valor errado com o tipo de dados errado j√° √© um erro, portanto essa op√ß√£o n√£o √© interessante para n√≥s agora. <br><br>  Formalmente, do ponto de vista do analisador, se uma fun√ß√£o pode retornar falso ou uma matriz, provavelmente o c√≥digo deve procurar falso.  Mas a fun√ß√£o explode () retornar√° false somente se o delimitador (primeiro par√¢metro) for igual a uma string vazia.  Geralmente, ele √© explicitamente escrito no c√≥digo, e os analisadores podem verificar se n√£o est√° vazio, o que significa que, nesse local, a fun√ß√£o explode () retorna com precis√£o uma matriz e n√£o √© necess√°ria uma verifica√ß√£o falsa. <br><br>  O PHP tem alguns recursos.  Os analisadores gradualmente adicionam verifica√ß√µes apropriadas ou as aprimoram, e n√≥s, programadores, n√£o precisamos mais lembrar de todos esses recursos. <br><br>  Passamos √† descri√ß√£o de analisadores espec√≠ficos. <br><br><h2>  PHPStan </h2><br>  Desenvolvimento de um certo Ond≈ôej Mirtes da Rep√∫blica Tcheca.  Desenvolvido ativamente desde o final de 2016. <br><br>  Para come√ßar a usar o PHPStan, voc√™ precisa: <br><br><ol><li>  Instale (a maneira mais f√°cil de fazer isso √© atrav√©s do Composer). <br></li><li>  (opcional) Configure. <br></li><li>  No caso mais simples, basta executar: <br></li></ol><br> <code>vendor/bin/phpstan analyse ./src</code> <br> <br>  (em vez de <code>src</code> pode haver uma lista de arquivos espec√≠ficos que voc√™ deseja verificar). <br><br>  O PHPStan ler√° o c√≥digo PHP dos arquivos transferidos.  Se ele encontrar aulas desconhecidas, ele tentar√° carreg√°-las com carregamento autom√°tico e atrav√©s da reflex√£o para entender sua interface.  Voc√™ tamb√©m pode transferir o caminho para o arquivo <code>Bootstrap</code> atrav√©s do qual voc√™ configura o carregamento autom√°tico e anexar alguns arquivos adicionais para simplificar a an√°lise do PHPStan. <br><br>  Principais recursos: <br><br><ol><li>  √â poss√≠vel analisar n√£o toda a base de c√≥digo, mas apenas uma parte - as classes desconhecidas PHPStan tentar√£o carregar o carregamento autom√°tico. <br></li><li>  Se, por algum motivo, algumas de suas aulas n√£o estiverem no carregamento autom√°tico, o PHPStan n√£o poder√° encontr√°-las e cometer√° um erro. <br></li><li>  Se voc√™ estiver usando ativamente m√©todos m√°gicos por meio de <code>__call / __get / __set</code> , poder√° escrever um plugin para o PHPStan.  Plugins para Symfony, Doutrina, Laravel, Zombaria, etc. j√° existem. <br></li><li>  De fato, o PHPStan realiza o carregamento autom√°tico n√£o apenas para classes desconhecidas, mas em geral para todos.  Temos muitos c√≥digos antigos escritos antes do aparecimento de classes an√¥nimas, quando criamos uma classe em um arquivo e instanciamos instantaneamente e, possivelmente, at√© chamamos alguns m√©todos.  O carregamento autom√°tico ( <code>include</code> ) desses arquivos leva a erros, porque o c√≥digo n√£o √© executado em um ambiente normal. <br></li><li>  Configura no formato <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neon</a> (nunca ouvi dizer que esse formato foi usado em outro lugar). <br></li><li>  N√£o h√° suporte para suas tags PHPDoc como <code>@phpstan-var, @phpstan-return</code> , etc. <br></li></ol><br>  Outra caracter√≠stica √© que os erros t√™m texto, mas n√£o h√° tipo.  Ou seja, o texto do erro √© retornado a voc√™, por exemplo: <br><br><ul><li> <code>Method \SomeClass::getAge() should return int but returns int|null</code> <br> </li><li> <code>Method \SomeOtherClass::getName() should return string but returns string|null</code> <br> </li></ul><br>  Neste exemplo, ambos os erros s√£o basicamente a mesma coisa: o m√©todo deve retornar um tipo, mas, na realidade, ele retorna o outro.  Mas os textos dos erros s√£o diferentes, embora semelhantes.  Portanto, se voc√™ deseja filtrar quaisquer erros no PHPStan, fa√ßa-o apenas atrav√©s de express√µes regulares. <br><br>  Para compara√ß√£o, em outros analisadores, os erros t√™m um tipo.  Por exemplo, no Phan, esse erro √© do tipo <code>PhanPossiblyNullTypeReturn</code> e voc√™ pode especificar na configura√ß√£o que n√£o precisa verificar esses erros.  Al√©m disso, tendo o tipo de erro, √© poss√≠vel, por exemplo, coletar facilmente estat√≠sticas sobre erros. <br><br>  Como n√£o usamos Laravel, Symfony, Doctrine e solu√ß√µes similares, e raramente usamos m√©todos m√°gicos em nosso c√≥digo, o principal recurso do PHPStan acabou n√£o sendo reclamado por n√≥s.  ; (Al√©m disso, devido ao fato de o PHPStan incluir <b>todas</b> as classes sendo verificadas, √†s vezes sua an√°lise simplesmente n√£o funciona em nossa base de c√≥digo. <br><br>  No entanto, o PHPStan continua sendo √∫til para n√≥s: <br><br><ul><li>  Se voc√™ precisar verificar v√°rios arquivos, o PHPStan √© visivelmente mais r√°pido que o Phan e um pouco (20-50%) mais r√°pido que o Salmo. <br></li><li>  Os relat√≥rios do PHPStan facilitam a localiza√ß√£o de <code>false-positive</code> em outros analisadores.  Geralmente, se houver algum <code>fatal</code> expl√≠cito no c√≥digo, ele ser√° mostrado por todos os analisadores (ou pelo menos dois dos tr√™s). <br></li></ul><br><br>  <b>Atualiza√ß√£o:</b> <br>  O autor do PHPStan Ond≈ôej Mirtes tamb√©m leu nosso artigo e nos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">disse</a> que o PhpStan, como o Salmo, tem um site com uma ‚Äúcaixa de areia‚Äù: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://phpstan.org/</a> .  Isso √© muito conveniente para relat√≥rios de erros: voc√™ reproduz o erro e fornece um link no GitHub. <br><br><h2>  Phan </h2><br>  Desenvolvido por Etsy.  Comete primeiro de Rasmus Lerdorf. <br><br>  Dos tr√™s em quest√£o, Phan √© o √∫nico analisador est√°tico <b>real</b> (no sentido de que n√£o executa nenhum dos seus arquivos - ele analisa <b>toda a</b> sua base de c√≥digos e analisa o que voc√™ diz).  Mesmo para analisar v√°rios arquivos em nossa base de c√≥digo, ele precisa de aproximadamente 6 GB de RAM, e esse processo leva de quatro a cinco minutos.  Por√©m, uma an√°lise completa de toda a base de c√≥digo leva de seis a sete minutos.  Para compara√ß√£o, o Salmo analisa em algumas dezenas de minutos.  E com o PHPStan n√£o conseguimos obter uma an√°lise completa de toda a base de c√≥digo porque inclui classes de inclus√£o. <br><br>  A experi√™ncia de Phan √© dupla.  Por um lado, √© o analisador mais est√°vel e de alta qualidade, encontra muitos problemas e h√° menos problemas quando √© necess√°rio analisar toda a base de c√≥digos.  Por outro lado, possui duas caracter√≠sticas desagrad√°veis. <br><br>  Sob o cap√¥, Phan usa a extens√£o php-ast.  Aparentemente, esse √© um dos motivos pelos quais a an√°lise de toda a base de c√≥digo √© relativamente r√°pida.  Mas o php-ast mostra a representa√ß√£o interna da √°rvore AST, como aparece no pr√≥prio PHP.  E no pr√≥prio PHP, a √°rvore AST n√£o cont√©m informa√ß√µes sobre coment√°rios localizados dentro da fun√ß√£o.  Ou seja, se voc√™ escreveu algo como: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> int $type */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($type)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> \My\Object $obj **/</span></span>   $obj = MyFactory::createObjectByType($type);   ‚Ä¶ }</code> </pre> <br>  ent√£o, dentro da √°rvore AST, h√° informa√ß√µes sobre o PHPDoc externo para a fun√ß√£o <code>doSomething()</code> , mas n√£o h√° informa√ß√µes de ajuda do PHPDoc dentro da fun√ß√£o.  E, consequentemente, Phan tamb√©m n√£o sabe nada sobre ela.  Esta √© a causa mais comum de <code>false-positive</code> em Phan.  Existem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">algumas recomenda√ß√µes</a> sobre como inserir dicas de ferramentas (por meio de strings ou assert-s), mas, infelizmente, elas s√£o muito diferentes do que nossos programadores est√£o acostumados.  Parcialmente, resolvemos esse problema escrevendo um plugin para o Phan.  Mas os plugins ser√£o discutidos abaixo. <br><br>  A segunda caracter√≠stica desagrad√°vel √© que Phan n√£o analisa bem as propriedades dos objetos.  Aqui est√° um exemplo: <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> string|null */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $a; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $a = null)</span></span></span><span class="hljs-function"> </span></span>{      <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;a = $a; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;a &amp;&amp; strpos(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;a, <span class="hljs-string"><span class="hljs-string">'a'</span></span>) === <span class="hljs-number"><span class="hljs-number">0</span></span>) {          var_dump(<span class="hljs-string"><span class="hljs-string">"test1"</span></span>);      } } }</code> </pre> <br>  Neste exemplo, Phan lhe dir√° que em strpos voc√™ pode passar nulo.  Voc√™ pode saber mais sobre esse problema aqui: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/phan/phan/issues/204</a> . <br><br>  Sum√°rio  Apesar de algumas dificuldades, Phan √© um desenvolvimento muito interessante e √∫til.  Al√©m desses dois tipos de <code>false-positive</code> , ele quase n√£o comete erros, ou comete erros, mas em algum c√≥digo realmente complexo.  Tamb√©m gostamos que a configura√ß√£o esteja em um arquivo PHP - isso d√° alguma flexibilidade.  Phan tamb√©m sabe como trabalhar como servidor de idiomas, mas n√£o usamos esse recurso, pois o PHPStorm √© suficiente para n√≥s. <br><br><h3>  Plugins </h3><br>  O Phan possui uma API de desenvolvimento de plugins bem desenvolvida.  Voc√™ pode adicionar suas pr√≥prias verifica√ß√µes, melhorar a infer√™ncia de tipo para o seu c√≥digo.  Essa API <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">possui documenta√ß√£o</a> , mas √© especialmente interessante o fato de j√° existirem plug-ins em funcionamento que podem ser usados ‚Äã‚Äãcomo exemplos. <br><br>  Conseguimos escrever dois plugins.  O primeiro foi destinado a uma verifica√ß√£o √∫nica.  Quer√≠amos avaliar como nosso c√≥digo est√° pronto para o PHP 7.3 (em particular, para descobrir se ele tem constantes que n√£o <code>case-insensitive</code> ).  Est√°vamos quase certos de que n√£o existiam essas constantes, mas tudo poderia acontecer em 12 anos - deveria ser verificado.  E n√≥s escrevemos um plugin para o Phan que juraria se o terceiro par√¢metro fosse usado em <code>define()</code> . <br><br><div class="spoiler">  <b class="spoiler_title">O plugin √© muito simples</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span>(strict_types=<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Phan</span></span>\<span class="hljs-title"><span class="hljs-title">AST</span></span>\<span class="hljs-title"><span class="hljs-title">ContextNode</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Phan</span></span>\<span class="hljs-title"><span class="hljs-title">CodeBase</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Phan</span></span>\<span class="hljs-title"><span class="hljs-title">Language</span></span>\<span class="hljs-title"><span class="hljs-title">Context</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Phan</span></span>\<span class="hljs-title"><span class="hljs-title">Language</span></span>\<span class="hljs-title"><span class="hljs-title">Element</span></span>\<span class="hljs-title"><span class="hljs-title">Func</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Phan</span></span>\<span class="hljs-title"><span class="hljs-title">PluginV2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Phan</span></span>\<span class="hljs-title"><span class="hljs-title">PluginV2</span></span>\<span class="hljs-title"><span class="hljs-title">AnalyzeFunctionCallCapability</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">ast</span></span>\<span class="hljs-title"><span class="hljs-title">Node</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DefineThirdParamTrue</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PluginV2</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnalyzeFunctionCallCapability</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAnalyzeFunctionCallClosures</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CodeBase $code_base)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{   $define_callback = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(       CodeBase $code_base,                  Context $context,                  Func $function,                  array $args    )</span></span></span><span class="hljs-function"> </span></span>{      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (\count($args) &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) {         <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;      }       <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;emitIssue(       $code_base,      $context,      <span class="hljs-string"><span class="hljs-string">'PhanDefineCaseInsensitiv'</span></span>,      <span class="hljs-string"><span class="hljs-string">'Define with 3 arguments'</span></span>,      []      );    };    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [          <span class="hljs-string"><span class="hljs-string">'define'</span></span> =&gt; $define_callback,    ]; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DefineThirdParamTrue();</code> </pre> <br></div></div><br><br>  No Phan, plugins diferentes podem ser pendurados em diferentes eventos.  Em particular, plug-ins com a interface <code>AnalyzeFunctionCallCapability</code> acionados quando uma chamada de fun√ß√£o √© analisada.  Neste plug-in, fizemos com que, quando chamamos a fun√ß√£o <code>define()</code> , nossa fun√ß√£o an√¥nima seja chamada, que verifica que <code>define()</code> n√£o <code>define()</code> mais que dois argumentos.  Ent√£o, come√ßamos o Phan, localizamos todos os lugares onde <code>define()</code> foi chamado com tr√™s argumentos e garantimos que n√£o tiv√©ssemos <code>case-insensitive-</code> . <br><br>  Usando o plugin, tamb√©m resolvemos parcialmente o problema de <code>false-positive</code> quando o Phan n√£o v√™ dicas do PHPDoc dentro do c√≥digo. <br><br>  Geralmente usamos m√©todos de f√°brica que recebem uma constante como entrada e criam um objeto a partir dela.  Frequentemente, o c√≥digo se parece com isso: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> \Objects\Controllers\My $Object */</span></span> $Object = \Objects\Factory::create(\Objects\Config::MY_CONTROLLER);</code> </pre> <br>  O Phan n√£o entende essas dicas do PHPDoc, mas nesse c√≥digo a classe de objeto pode ser obtida a partir do nome da constante passada ao m√©todo <code>create()</code> .  O Phan permite que voc√™ escreva um plug-in que √© acionado quando analisa o valor de retorno de uma fun√ß√£o.  E com esse plug-in, voc√™ pode informar ao analisador qual tipo a fun√ß√£o retorna nesta chamada. <br><br>  Um exemplo deste plugin √© mais complexo.  Mas h√° um bom exemplo no c√≥digo Phan em <code>vendor/phan/phan/src/Phan/Plugin/Internal/DependentReturnTypeOverridePlugin.php.</code> <br><br>  No geral, estamos muito satisfeitos com o analisador Phan.  Os <code>false-positive</code> listados acima aprendemos parcialmente (em casos simples, com c√≥digo simples) a filtrar.  Depois disso, Phan se tornou um analisador quase de refer√™ncia.  No entanto, a necessidade de analisar imediatamente toda a base de c√≥digo (tempo e muita mem√≥ria) ainda complica o processo de sua implementa√ß√£o. <br><br><h2>  Salmo </h2><br>  O salmo √© um desenvolvimento do Vimeo.  Honestamente, eu nem sabia que o Vimeo usa PHP at√© ver o Salmo. <br><br>  Este analisador √© o mais novo dos tr√™s.  Quando li as not√≠cias de que o Vimeo lan√ßou o Salmo, fiquei perplexo: "Por que investir no Salmo se voc√™ j√° possui Phan e PHPStan?"  Mas o Salmo tem seus pr√≥prios recursos √∫teis. <br><br>  O Salmo seguiu os passos do PHPStan: voc√™ tamb√©m pode fornecer uma lista de arquivos para an√°lise, que ser√£o analisados ‚Äã‚Äãe conectar classes que n√£o s√£o encontradas com o carregamento autom√°tico.  Ao mesmo tempo, ele <b>apenas</b> conecta classes que n√£o foram encontradas e os arquivos que solicitamos para an√°lise n√£o ser√£o inclu√≠dos (isso √© diferente do PHPStan).  A configura√ß√£o √© armazenada em um arquivo XML (para n√≥s, √© mais prov√°vel que seja um sinal de menos, mas n√£o muito cr√≠tico). <br><br>  O Salmo tem um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">site</a> em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√°rea</a> restrita onde voc√™ pode escrever e analisar o c√≥digo PHP.  Isso √© muito conveniente para relat√≥rios de erros: voc√™ reproduz o erro no site e fornece o link no GitHub.  E, a prop√≥sito, o site descreve todos os tipos poss√≠veis de erros.  Para compara√ß√£o: no PHPS, os erros n√£o t√™m tipos e, no Phan, existem, mas n√£o existe uma lista √∫nica que possa ser encontrada. <br><br>  Tamb√©m gostamos que, ao emitir erros, o Salmo mostra imediatamente as linhas de c√≥digo onde foram encontradas.  Isso simplifica <b>bastante a</b> leitura dos relat√≥rios. <br><br>  Mas talvez o recurso mais interessante do Psalm sejam suas tags PHPDoc personalizadas, que permitem melhorar a an√°lise (especialmente a defini√ß√£o de tipos).  Listamos os mais interessantes deles. <br><br><h3>  @ psalm-ignore-nullable-return </h3><br>  Ocorre que formalmente um m√©todo pode retornar <code>null</code> , mas o c√≥digo j√° est√° organizado de tal maneira que isso nunca acontece.  Nesse caso, √© muito conveniente adicionar uma dica do PHPDoc ao m√©todo / fun√ß√£o - e o Salmo considerar√° que <code>null</code> n√£o <code>null</code> retornado. <br><br>  Existe uma dica semelhante para false: <code>@psalm-ignore-falsable-return</code> . <br><br><h3>  Tipos de fechamento </h3><br>  Se voc√™ j√° se interessou por programa√ß√£o funcional, pode ter notado que muitas vezes uma fun√ß√£o pode retornar outra fun√ß√£o ou assumir alguma fun√ß√£o como par√¢metro.  No PHP, esse estilo pode ser muito confuso para seus colegas, e uma das raz√µes √© que o PHP n√£o possui padr√µes para documentar essas fun√ß√µes.  Por exemplo: <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_filter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $ar, \Closure $func)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ }</code> </pre> <br>  Como um programador pode entender qual interface a fun√ß√£o possui no segundo par√¢metro?  Quais par√¢metros devem ser tomados?  O que ela deveria retornar? <br><br>  O Salmo suporta sintaxe para descrever fun√ß√µes no PHPDoc: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> array $ar * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@psalm</span></span></span><span class="hljs-comment">-param Closure(int):bool $func */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_filter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $ar, \Closure $func)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ }</code> </pre> <br>  Com essa descri√ß√£o, j√° est√° claro que voc√™ precisa passar uma fun√ß√£o an√¥nima para <code>my_filter</code> , que aceitar√° um int e return bool.  E, √© claro, o Salmo verificar√° se voc√™ tem exatamente essa fun√ß√£o passada no seu c√≥digo. <br><br><h3>  Enums </h3><br>  Suponha que voc√™ tenha uma fun√ß√£o que aceita um par√¢metro de string e voc√™ s√≥ pode passar certas strings para l√°: <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isYes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $yes_or_no)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-function"> </span></span>{     $yes_or_no = strtolower($yes_or_no)     <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>($yes_or_no)  {           <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'yes'</span></span>:                 <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>;          <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'no'</span></span>:                 <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>;           <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>:                <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \InvalidArgumentException(‚Ä¶);     } }</code> </pre><br>  O Salmo permite que voc√™ descreva o par√¢metro desta fun√ß√£o assim: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@psalm</span></span></span><span class="hljs-comment">-param 'Yes'|'No' $yes_or_no **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isYes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $yes_or_no)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ }</code> </pre> <br>  Nesse caso, o Salmo tentar√° entender quais valores espec√≠ficos s√£o passados ‚Äã‚Äãpara essa fun√ß√£o e lan√ßar√° erros se houver valores diferentes de <code>Yes</code> e <code>No</code> <br><br>  Leia mais sobre enum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br><h3>  Aliases de tipo </h3><br>  Anteriormente, na descri√ß√£o das <code>array shapes</code> da <code>array shapes</code> mencionei que, embora os analisadores permitam descrever a estrutura das matrizes, n√£o √© muito conveniente us√°-la, pois a descri√ß√£o da matriz deve ser copiada em locais diferentes.  A solu√ß√£o correta, √© claro, √© usar classes em vez de matrizes.  Mas, no caso de muitos anos de legado, isso nem sempre √© poss√≠vel. <br><br>   ,      ,    ,    : <br><br><ul><li> ; <br></li><li> closure; <br></li><li> union- (,       ); <br></li><li> enum. <br></li></ul><br>   ,      ,    PHPDoc    , ,  .   Psalm      .    alias      PHPDoc   <code>alias</code> .  ,  :      PHP-.      . ,   Psalm. <br><br><h3> Generics aka templates </h3><br>     . ,     : <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">identity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $x; }</code> </pre> <br>     ?      ?   ? <br><br> , ,    , ‚Äî <code>mixed</code> ,             . <br><br>     <code>mixed</code> ‚Äî  .  ,            .    ,   <code>identity()</code>  /  ,    :     ,   .       -.  ,   : <br><br><pre> <code class="php hljs">$i = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">// int $y = identity($i);</span></span></code> </pre> <br>       <code>(int)</code> ,  ,      <code>$y</code> ( <code>int</code> ). <br><br>       ?  Psalm     PHPDoc-: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@template</span></span></span><span class="hljs-comment"> T * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@psalm</span></span></span><span class="hljs-comment">-param T $x * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@psalm</span></span></span><span class="hljs-comment">-return T */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">identity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($x)</span></span></span><span class="hljs-function"> </span></span>{ $return $x; }</code> </pre> <br>   templates   Psalm   ,  /     . <br><br>  Psalm      templates: <br><br> ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">vendor/vimeo/psalm/src/Psalm/Stubs/CoreGenericFunctions.php</a> ; <br> ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">vendor/vimeo/psalm/src/Psalm/Stubs/CoreGenericClasses.php</a> . <br><br>      Phan,      : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/phan/phan/wiki/Generic-Types</a> . <br><br>  ,  Psalm  . ,    ¬´¬ª              .   ,  Psalm    ,    ,       Phan  PHPStan.     . <br><br><h2>    PHPStorm </h2><br>      :          ,   .    ,      ,    . <br><br>             .     Phan,    language server.    PHPStorm, ,   . <br><br> ,  ,  PHPStorm     ( ),       .         ‚Äî Php Inspections (EA Extended).     ‚Äî   ,   ,         .  ,      . ,      scopes     -   scopes. <br><br>     ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">deep-assoc-completion</a> .         . <br><br><h1>    Badoo </h1><br>     ? <br><br>       ,         . <br><br>     ,   .  ,     ,    <code>git diff</code>      / ,       ,     () .       ,    . <br><br> ,     :      -    <code>git diff</code> .     .             ,    .         . , ,  ,          ,    . <br><br>     ,     ,       : <br><br><img src="https://habrastorage.org/webt/zj/e2/rt/zje2rtxhy1nkwsamex4umguv4yw.png"><br><br>           <code>false-positive</code> . ,  ,   Phan        ,   ,     . ,   -    Phan      ,     ,      . <br><br><h1>     QA </h1><br>        : <br><br><ul><li>     ; <br></li><li>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">code review</a> ; <br></li><li>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> . <br></li></ul><br><br>   ‚Äî ,  ,      ,     .      : <br><br><ul><li>    100%  (   ,        ); <br></li><li>     ,      code review; <br></li><li>      ,        . <br></li></ul><br>         <code>strict types</code> .          ,  <code>strict types</code> ,    : <br><br><ul><li>     ,     <code>strict types</code> ,   ; <br></li><li>     ,     (,    ,        ); <br></li><li>        ,    PHP (,   <code>union types</code> ,    PHP); <br></li><li>       <code>strict types</code> ,        . <br></li></ul><br><h1>  :   </h1><br>  ,        .   . <br><br> -,     , ,      -  ,    . <br><br> -,     ,     ‚Äî  , ,     PHPDoc.        ‚Äî   . <br><br> -,     .  ,     -  ,            PHPDoc.  :) <br><br>  ,  ,     .    ,      . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt426605/">https://habr.com/ru/post/pt426605/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt426591/index.html">Mestre em Posturas: Fique Vivo</a></li>
<li><a href="../pt426593/index.html">DJI Phantom 4 RTK: mapeamento de pr√≥xima gera√ß√£o</a></li>
<li><a href="../pt426595/index.html">Richard Hamming ‚ÄúCap√≠tulo inexistente‚Äù: como sabemos o que sabemos (de 1 a 10 minutos em 40)</a></li>
<li><a href="../pt426597/index.html">Madrobots na IFA 2018. Parte 2 - Projetores inteligentes: do XGIMI ao Anker</a></li>
<li><a href="../pt426603/index.html">Espiral girat√≥ria: matem√°tica e alucina√ß√µes</a></li>
<li><a href="../pt426609/index.html">O Office 365 e outros produtos MS adicionam E / S de voz para disl√©xicos</a></li>
<li><a href="../pt426611/index.html">Integra√ß√£o ao SAP ERP, usando o Django-python como exemplo, usando o protocolo oData (restante)</a></li>
<li><a href="../pt426613/index.html">N√£o deixe a impressora 3D pregui√ßosa</a></li>
<li><a href="../pt426615/index.html">Escrevendo uma CLI no NodeJS</a></li>
<li><a href="../pt426617/index.html">Licen√ßa para dirigir um carro ou por que os aplicativos devem ser de atividade √∫nica</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>