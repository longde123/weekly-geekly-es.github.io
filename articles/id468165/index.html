<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⏯️ 👟 🕥 Cara menggambar browser. Laporan Yandex 📦 🤙🏽 🤒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sampai baru-baru ini, saya bekerja di tim Yandex.Browser dan membuat presentasi di konferensi YaTalks setelah pengalaman ini. Laporan itu tentang apa ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara menggambar browser. Laporan Yandex</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/468165/">  Sampai baru-baru ini, saya bekerja di tim Yandex.Browser dan membuat presentasi di konferensi YaTalks setelah pengalaman ini.  Laporan itu tentang apa yang dimiliki browser di bawah tenda dan bagaimana halaman Anda berubah menjadi piksel di layar.  Frontend minimum, hanya bagian dalam browser, hanya hardcore. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/1a/v_/yd/1av_ydaayfggjaxus6mfz_dtazu.jpeg"></a> <br><br>  - Halo semuanya, nama saya Kostya.  Anehnya, sekarang saya bekerja di tim jaringan virtual Yandex.Cloud.  Sebelum itu, saya telah bekerja di tim Browser selama lebih dari lima tahun, jadi hari ini saya akan berbicara tentang hal-hal yang umum bagi kami dan Anda. <br><br><a name="habracut"></a>  Seperti yang Anda duga, saya tidak begitu mengerti di bagian depan.  Jika Anda berbicara kepada saya tentang Bereaksi atau hal lain seperti itu, saya mungkin tidak akan mengerti Anda.  Tetapi saya melakukan banyak hal di browser: decoding video, logika bisnis.  Termasuk saya menghabiskan banyak waktu melakukan hal-hal yang berbeda dalam rendering browser.  Hari ini kita akan memiliki, misalnya, program pendidikan tentang perangkat internal browser.  Saya akan mencoba membahas hal-hal paling menarik yang kami lakukan di Yandex.Browser atau Google di Chromium. <br><br><img src="https://habrastorage.org/webt/cu/uk/m0/cuukm04v2xohnl0t4x2u86qf6je.jpeg"><br><br>  Jika kita berbicara tentang rendering di browser, maka ini adalah hal yang sangat rumit, yang terdiri dari sejumlah besar komponen.  Pertama-tama, Anda harus mengunduh sumber daya untuk menunjukkannya.  Maka Anda harus mengurai mereka, membangun pohon DOM, gaya, tata letak, dll. Tiga poin pertama kemungkinan besar akrab bagi Anda.  Laporan saya akan lebih fokus pada tiga bagian lainnya: Lukisan, Rasterisasi, dan Penggabungan - apa yang terjadi di bawah tenda ketika Anda sudah menulis tata letak.  Hanya dengan kata-kata saja sepertinya itu tentang hal yang sama - pada kenyataannya, ini adalah komponen yang sama sekali berbeda. <br><br><img src="https://habrastorage.org/webt/pv/zd/ww/pvzdwwy3xvf6s3os0z3edvey3hw.jpeg"><br>  ￼ <br>  Mari kita mulai dengan Pengecatan dan Pengomposisian.  Tentang apa semua ini?  Mari kita kembali ke banyak, bertahun-tahun yang lalu, ketika web tidak serumit sekarang, ketika tidak ada semua jenis 3D, animasi CSS dan hal-hal lainnya.  Lalu bagaimana menggambar browser?  Bayangkan bahwa Anda memiliki halaman Anda, di atasnya beberapa elemen indah, gambar, dll. Browser dicat semua ini pada satu tekstur yang kuat, dalam blok memori yang besar.  Dia tahu cara menggambar setiap elemen, dan jika kami memiliki perubahan, mereka disorot dengan warna kuning, sesuatu seperti yang berikut terjadi. <br><br>  Browser mengumpulkan mereka di area yang ditunjukkan di sini dengan warna biru.  Ada perubahan di area ini, mari kita gambarkan kembali.  Semua yang ada di area ini digambar ulang dan disalin ke teksturnya. <br><br>  Itu bekerja untuk dirinya sendiri.  Kemudian orang-orang pintar datang dengan animasi CSS 3D, hal-hal lain.  Kami dapat memiliki banyak rendering di tempat yang berbeda.  Jika kita memutar satu pemintal, menggambar ulang seluruh elemen pie yang berada di bawahnya tidak terlalu efektif. <br><br><img src="https://habrastorage.org/webt/lp/9p/sh/lp9pshbw-k3xjwunjubol_xvo5k.jpeg"><br><br>  Kemudian orang pintar lainnya memutuskan untuk mengulang semuanya sedikit.  Kami memiliki semacam pohon DOM, kami membangunnya di memori.  Ini adalah objek plus, mereka dibandingkan dengan tata letak apa yang Anda tulis. <br><br><img src="https://habrastorage.org/webt/mq/m4/m6/mqm4m6-oocbnsypvc2uu_t1wame.jpeg"><br><br>  Dan kemudian keajaiban mulai terjadi.  Browser mengonversi seluruh pohon DOM ke pohon Objek Render.  Hal ini tahu cara menggambar setiap elemen DOM tertentu.  Artinya, dia tahu apa yang perlu dilakukan agar sesuatu muncul di layar alih-alih pohon atau elemen-P Anda. <br><br><img src="https://habrastorage.org/webt/qh/lc/li/qhlcli9pyhe2-k1ikbuhytv5itu.jpeg"><br><br>  Pohon berikutnya adalah pohon lapisan.  Apa ini  Setiap elemen kami dapat dikaitkan dengan satu lapisan, dan satu Lapisan Render dapat berisi beberapa objek sekaligus.  Mengapa ini dilakukan?  Ini ditunjukkan dengan sangat baik di sini.  Kami menghasilkan seperangkat lapisan, masing-masing memiliki elemen tertentu.  Sekarang, anggaplah sesuatu berubah pada salah satu layer - animasi terjadi, elemen cap terbang.  Lalu kita menggambar ulang hanya satu lapisan, dan sisanya, misalnya latar belakang, tetap tidak berubah.  Kami kemudian hanya menempelkannya ke komposit dan pada output kami mendapatkan gambar akhir - kerangka animasi saat ini. <br><br><img src="https://habrastorage.org/webt/lz/y5/4m/lzy54mvjeae-hnulzhsafu68m5g.jpeg"><br><br>  Ada sekumpulan alasan untuk membuat layer baru.  Misalnya, sebuah layer dibuat untuk menyajikan animasi CSS 3D, kanvas, elemen video di atasnya - secara umum, sesuatu yang berkaitan dengan animasi berat, cocok untuk menggambar ulang secara terpisah dari semua konten lainnya. <br><br><img src="https://habrastorage.org/webt/0z/m3/tu/0zm3tuitlzjxxqdiyldzh26xd60.jpeg"><br><br>  Namun pendekatan ini memiliki beberapa masalah.  Sekarang Anda perlu menyalakan bahan bakar.  Pikirkan tentang apa yang akan digambarkan di sini?  Hanya ada dua elemen. <br><br><img src="https://habrastorage.org/webt/gl/c6/op/glc6opdar5a1kpd4oblgxin6cgg.jpeg"><br><br>  Di sini  Meskipun, tampaknya, unsur-unsur itu terletak satu per satu.  Mengapa kanvas terbang?  Di negara kami, mereka diatur secara berurutan, saya tidak mengatur pesanan apa pun. <br><br><img src="https://habrastorage.org/webt/gh/fk/8h/ghfk8hcwyrsk1se3g69uxobhs0y.jpeg"><br><br>  Mari menyulitkan.  Di sini kita memiliki div lain, seperti ini. <br><br><img src="https://habrastorage.org/webt/sp/fy/kw/spfykw2_mvn88iagm46zaonkteg.jpeg"><br><br>  Secara umum, perilaku yang diharapkan.  Kami memiliki div di atas div, tetapi kanvas untuk beberapa alasan di atas.  Keajaiban!  Oke, mari kita tambahkan contoh ini lagi. <br><br><img src="https://habrastorage.org/webt/k9/0r/jq/k90rjqxakei6oiidlklf5s2i1ia.jpeg"><br><br>  Tepat satu baris telah berubah, saya menambahkan transformasi. <br><br><img src="https://habrastorage.org/webt/os/dm/bp/osdmbp6jkrfzdmrgabry61pjngi.jpeg"><br><br>  Dan sekarang kita memiliki segalanya yang terletak dengan benar - setidaknya dalam hal kanvas dan div.  Tetapi div ini masih terletak di bawah, meskipun itu adalah elemen berikutnya dalam tata letak kita. <br><br>  Ini disebut bug pengomposisian fundamental.  Jika Anda mencari pelacak Chromium, Anda akan melihat banyak bug yang ditautkan dengan yang kuno.  Dia disebut itu. <br><br><img src="https://habrastorage.org/webt/kp/go/nx/kpgonxbu5yxy_7immr2urgfurva.jpeg"><br><br>  Jadi apa yang terjadi?  Seperti yang saya katakan, beberapa elemen diberikan pada Layer Render, beberapa tidak.  Beberapa ditarik bersama dengan yang lain.  Berikut ini terjadi: elemen div tetap di lapisan yang sama dengan latar belakang.  Kanvas menabrak lapisan yang terpisah.  Dan z-pemesanan hanya dilakukan antar lapisan.  Karena kami memiliki latar belakang dan div di satu layer dan kanvas di layer lain, kami mendapatkan bug: kanvas tumpang tindih dengan div. <br><br>  Tapi begitu kita memindahkan elemen div ini ke layer terpisah dan mulai menggunakan z-order secara normal, ia juga mulai memahami siapa yang ada di belakang siapa.  Dan di sini semuanya diterjemahkan "normal". <br><br><img src="https://habrastorage.org/webt/nl/ju/4j/nlju4jxtrt-1x7fjliv5hy8io3i.jpeg"><br><br>  Dan salah satu inisiatif terakhir yang telah dikembangkan selama beberapa tahun adalah yang disebut Slimming Paint, yang seharusnya memperbaikinya.  Artinya adalah bahwa kita perlu memisahkan Lukisan dari pementasan, yaitu, memahami apa yang perlu dilakukan untuk menggambar elemen-elemen ini, dari bagaimana kemudian menyusun mereka satu sama lain.  Jika kita memiliki tata letak yang sederhana, itu berubah menjadi sesuatu seperti itu.  Ada daftar perintah sederhana yang perlu Anda lakukan untuk mendapatkan konten halaman.  Dan jika kita kembali ke contoh ini, akan terlihat seperti ini. <br><br><img src="https://habrastorage.org/webt/yd/fw/s7/ydfws7bge3oaylgwnr7mlojtivy.jpeg"><br>  ￼ <br>  Yaitu, kami katakan: ini cat untuk Anda, ini isinya untuk Anda - tolong beri saya sesuatu.  Itu memberikan daftar untuk rendering, yang pergi ke Kompositor, dan Kompositor memahami bagaimana membagi semua konten menjadi beberapa lapisan sehingga mereka biasanya berada relatif satu sama lain. <br><br>  Dan jika Anda belum menyadarinya, ini adalah tangkapan layar dari Chrome.  Saya membuatnya sekitar dua minggu yang lalu, yaitu, bug itu masih hidup.  Proyek belum selesai, sekarang sedang dalam proses pengembangan. <br><br><img src="https://habrastorage.org/webt/lk/dv/j0/lkdvj0dnnveu2o_jlmdtykxcwus.jpeg"><br>  ￼ <br>  Yaitu, Kompositor dari daftar ini dan beberapa pengetahuan rahasia yang lolos dapat memahami bagaimana cara meletakkannya ke dalam lapisan. <br><br><img src="https://habrastorage.org/webt/li/lk/qu/lilkquciiebcpc3hjnvv_jjxuvy.jpeg"><br>  ￼ <br>  Selain fakta bahwa pendekatan ini pada dasarnya akan memperbaiki bug ini, kami juga mendapatkan perubahan rendering yang cukup murah.  Misalkan kita memiliki daftar perintah draw dan perubahan terjadi - misalkan elemen B pergi, elemen E ditambahkan.  Kemudian kita bisa menyimpan kedua daftar bersama tanpa khawatir tentang pohon, dll. Pada output kita mendapatkan daftar elemen baru untuk rendering, dan, mungkin, daftar layer baru yang akan dikompilasi di masa depan. <br><br>  Ini adalah cerita pendek tentang apa yang terjadi ketika browser mengimplementasikan Paint, dan apa yang terjadi setelah ia mencoba membuat layer. <br>  ￼ <br>  Mari kita beralih ke topik lain: Rasterisasi.  Hanya dalam Rasterisasi di Yandex.Browser, banyak hal telah dilakukan, dan saya juga melakukan ini.  Apa arti rasterisasi?  Pada output dari tahap sebelumnya, ketika kita melakukan Paint, ada daftar perintah yang harus kita implementasikan untuk mendapatkan beberapa jenis gambar.  Rasterisasi adalah transformasi daftar perintah menjadi piksel nyata. <br><br><img src="https://habrastorage.org/webt/ap/ya/oo/apyaooljngenpae6hwzfksmptqc.jpeg"><br><br><img src="https://habrastorage.org/webt/nu/pr/pr/nuprprco-z2msvg-jcj2hnkxvic.jpeg"><br><br>  Jika Anda membuka More tools → tab Rendering di inspektur browser, maka ada tanda centang Batas layer.  Dan Anda melihat grid seperti itu.  Apa yang sedang terjadi di sini?  Saat browser menggambar halaman, itu sebenarnya tidak melakukan semuanya sekarang.  Browser mengambil dan memecah setiap lapisan menjadi sejumlah kotak kecil seperti itu.  Secara historis, mereka berukuran 256 x 256 piksel.  Artinya, setiap lapisan dibagi menjadi begitu banyak tekstur yang terpisah.  Isi dari ubin saat ini kemudian ditarik ke setiap tekstur, dan kemudian mereka semua direkatkan menjadi satu tekstur besar. <br><br><img src="https://habrastorage.org/webt/1i/fr/-m/1ifr-m5llhmdoal3f-ecr9fv3mw.jpeg"><br><br>  Ini sangat membantu.  Pertama-tama, kita hanya dapat menggambar ulang ubin yang telah diubah.  Tetapi itu juga memungkinkan kita untuk memprioritaskan rendering.  Artinya, pertama-tama, ubin yang dilihat pengguna, yang disebut viewport, harus digambar.  Maka kita harus segera menggambar perbatasan, inilah yang ada di sekitar viewport.  Selanjutnya adalah arah dari gulungan: jika digulir ke bawah, kita menarik sebanyak mungkin ke bawah.  Jika naik - gambarlah sebanyak mungkin ke atas.  Jika kita masih memiliki kuota memori, kita akan menggambar sesuatu yang lain, tetapi bukan fakta bahwa itu akan tetap pada titik ini. <br><br><img src="https://habrastorage.org/webt/gb/aa/b1/gbaab12sjafchhn1okxtdml2yju.jpeg"><br><br>  Jadi kami mendapatkan pembaruan konten yang cukup murah di halaman.  Misalkan kita mengambil bingkai saat ini dan pengguna menonaktifkan sesuatu - misalnya, teks yang disorot.  Kemudian kami hanya menggambar ubin yang telah berubah. <br><br><img src="https://habrastorage.org/webt/qc/q5/it/qcq5itbfqab7ylojm1nabcwopra.jpeg"><br><br>  Yaitu, ubin hijau adalah ubin yang tetap dari rendering sebelumnya, yang merah yang kami gambarkan kembali.  Namun pendekatan ini memiliki kelebihan lain. <br><br><img src="https://habrastorage.org/webt/5f/xy/ip/5fxyipvzx6gfrkoy4yxl6foplgi.jpeg"><br><br>  Kita dapat melakukan - dan Chrome melakukannya - yang disebut optimasi redraws kecil.  Misalkan Anda memiliki semacam pendorong, kursor, atau sesuatu seperti itu melakukan sedikit menggambar ulang dalam persegi panjang kecil.  Maka kita tidak perlu menggambar ulang seluruh kotak.  Ini logis.  Misalnya, jika kursor kami berkedip, maka hanya kursor yang digambar ulang.  Ini sangat menghemat CPU. <br><br><img src="https://habrastorage.org/webt/d1/if/je/d1ifjeax-iui5g2798qeywqbkxe.jpeg"><br><br>  Optimasi selanjutnya telah mereka lakukan.  Di mana bisa ada inefisiensi?  Apakah ubinnya digeser?  Ide bagus, tapi saya cenderung ke yang lain.  Ini hanya kotak putih.  Ini adalah ubin putih di mana tidak ada satu piksel pun yang diambil.  Tapi itu adalah tekstur.  Membutuhkan memori 256 hingga 256 kali empat byte. <br><br><img src="https://habrastorage.org/webt/_u/rd/jz/_urdjzgxmievvqxncbbqnmk-iqg.jpeg"><br><br>  Optimalisasi lain yang ditemukan di Chrome: dan mari kita ambil petak-petak ini, satu warna, dan menyandikannya bukan dengan sekelompok piksel, tetapi, pada kenyataannya, dengan koordinator, ukuran dan warna.  Internet sekarang penuh dengan halaman dengan banyak area monokrom untuk monitor besar.  Dan halaman seperti itu dioptimalkan sesuai, kami mendapatkan banyak penghematan memori. <br><br>  Kami di Yandex melangkah lebih jauh dan memutuskan untuk melakukan percobaan yang lebih spesifik.  Menurut Anda di mana Anda bisa menabung lebih banyak? <br><br>  Kami memiliki ubin.  Konten di dalamnya terletak di beberapa area kecil - sebuah strip, kata Yandex.  Mengapa kita perlu menggambar secara keseluruhan, jika kontennya sangat kecil, dan yang lainnya monokrom? <br><br><img src="https://habrastorage.org/webt/rc/lp/3l/rclp3lba5zrbbyy4i97k6fghoga.jpeg"><br><br>  Apa yang telah kita lakukan  Inilah yang secara spesifik saya lakukan.  Kami membagi setiap ubin menjadi lima ubin.  Jika konten di dalamnya hanya di tengah, maka kami memilih tekstur untuk konten ini hanya untuk apa yang dilakukan di tengah.  Ini area merah.  Segala sesuatu yang lain kita kode dengan cara yang sama - ukuran, koordinat, dan warna. <br><br><img src="https://habrastorage.org/webt/s2/5s/ue/s25sue2gc7yyi1wqmmuw8enuoi8.jpeg"><br><br>  Artinya, khususnya di halaman ini, semua area ini sekarang menjadi non-tekstur.  Bukan byte dalam memori yang digunakan, tetapi hanya perintah tentang apa yang perlu kita gambar di sini, isi dengan satu warna.  Ini memberi kami penghematan rata-rata sekitar 40% pada memori GPU per pengguna. <br><br><img src="https://habrastorage.org/webt/-i/xu/-l/-ixu-l42br_ztso413cld8ph4pw.jpeg"><br><br>  Pada halaman yang lebih kompleks, terlihat seperti ini.  Mengingat bahwa halaman yang lebih kompleks menggunakan lebih banyak lapisan, dan setiap lapisan adalah ubin yang terpisah, Anda dapat menyimpan sedikit di setiap lapisan. <br><br>  Jika Anda mengaktifkan tanda centang ini sekarang, Anda tidak akan melihat kotak persegi panjang seperti itu, tetapi yang ini. <br><br><img src="https://habrastorage.org/webt/m3/a4/yc/m3a4yc5_thakslwlcxkhhvx4a80.jpeg"><br><br>  Apa itu, mengapa ubin begitu luas di sini, dan mengapa jumlahnya sedikit?  Arti di sini adalah sebagai berikut.  Di Chrome, mereka berpikir: mengapa kita tidak hanya mengkomposisikan perangkat keras, tetapi juga merender perangkat keras.  Apa yang mereka lakukan  Kami memiliki daftar perintah tentang apa yang perlu dilakukan: menggambar persegi panjang, isi dengan warna, dll. Semua ini berlaku untuk GPU, dan GPU menarik tekstur seperti itu.  Redrawing sangat cepat, jadi ubin juga bisa dibuat besar.  Berikut ini adalah sedikit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">video</a> serigala, tetapi itu menunjukkan dengan sangat baik keuntungan yang terjadi pada ponsel karena fakta bahwa rendering menjadi perangkat keras dipercepat.  Saya pikir perbedaannya di sini sangat, sangat nyata. <br><br>  Komunikasi antara pengembang browser dan vendor front-end tampaknya sangat berguna bagi saya.  Ini tidak sering terjadi, tetapi memberi banyak manfaat.  Karena itu, ketika kolega kami dari departemen lain datang kepada kami dan bertanya bagaimana membuat tata letak lebih cepat dan lebih baik, kami mencoba untuk membantu mereka dan berbicara tentang tempat-tempat di mana ada sesuatu yang tidak optimal dan Anda dapat mempercepat. <br><br>  Dan saya tidak akan bosan mengulangi saran saya.  (Saya tidak akan mengutip di sini, ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan besar</a> terpisah tentang hal ini. - Komentar penulis.) <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Di sini</a> saya telah menyusun satu set tautan yang bermanfaat, tentang rendering dan tidak hanya, tetapi juga sedikit tentang Yandex.Browser.  Terima kasih </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id468165/">https://habr.com/ru/post/id468165/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id468145/index.html">Tes atau tipe? - Versi karat</a></li>
<li><a href="../id468151/index.html">Kerentanan GeekBrains: Mengapa membayar uang untuk kursus jika Anda bisa mengunduhnya?</a></li>
<li><a href="../id468157/index.html">Perspektif EcmaScript pada teori umum OOP</a></li>
<li><a href="../id468161/index.html">Para termasyhur serakah: mengapa energi matahari tidak menaklukkan dunia dan bagaimana "mineral Rusia" dapat menyelamatkannya</a></li>
<li><a href="../id468163/index.html">Oracle VM Server untuk SPARC for Dummies (How-to)</a></li>
<li><a href="../id468167/index.html">Hidup dan belajar. Bagian 4. Belajar sambil bekerja?</a></li>
<li><a href="../id468169/index.html">Sejarah dan warisan JQuery</a></li>
<li><a href="../id468175/index.html">Blog pengembangan Frontend layak dibaca</a></li>
<li><a href="../id468179/index.html">Analisis: bagaimana infrastruktur pasar sekuritas Rusia bekerja</a></li>
<li><a href="../id468181/index.html">Silent Trinity: mengeksplorasi versi baru kerangka pasca-eksploitasi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>