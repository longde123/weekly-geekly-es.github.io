<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏽 ♣️ 🚳 Membalikkan rekayasa emulator NES dalam game untuk GameCube 🤵🏼 👫 💮</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saat mencari cara untuk mengaktifkan menu pengembang yang tersisa di Animal Crossing, termasuk menu pemilihan gim untuk emulator NES, saya menemukan f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Membalikkan rekayasa emulator NES dalam game untuk GameCube</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417117/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/499/dc8/2e4/499dc82e445ffd6bfd607d4f834ccd5a.png" alt="gambar"></div><br>  Saat mencari cara untuk mengaktifkan menu pengembang yang tersisa di Animal Crossing, termasuk menu pemilihan gim untuk emulator NES, saya menemukan fungsi menarik yang ada di gim asli dan terus-menerus aktif, tetapi tidak pernah digunakan oleh Nintendo. <br><br>  Selain game NES / Famicom dalam game, Anda dapat mengunduh game NES baru dari kartu memori. <br><br>  Saya juga berhasil menemukan cara untuk menggunakan bootloader ROM ini untuk menambal kode dan data saya ke dalam permainan, yang memungkinkan Anda untuk mengeksekusi kode melalui kartu memori. <br><br><h2>  Pendahuluan - Objek Konsol NES </h2><br>  Gim NES biasa, yang dapat diperoleh dari Animal Crossing, adalah bagian-bagian furnitur yang terpisah dalam bentuk konsol NES dengan kartrid yang diletakkan di atasnya. <br><br>  Setelah menemukan objek ini di rumah Anda dan berinteraksi dengannya, Anda dapat menjalankan satu-satunya permainan ini.  Gambar di bawah ini menunjukkan Excitebike dan Golf. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/40e/e33/409/40ee334095bd1151c3c968a84f8cf92b.png"></div><a name="habracut"></a><br>  Ada juga objek Konsol NES yang umum di mana tidak ada game bawaan.  Ini dapat dibeli dari Redd, dan kadang-kadang diperoleh melalui peristiwa acak, misalnya, dengan membaca di papan pengumuman kota bahwa konsol dimakamkan di titik acak di kota. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f41/d20/687/f41d20687aed7d6a4d044a5a5d084045.png"></div><br>  Objek ini terlihat seperti konsol NES di mana tidak ada kartrid. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35c/010/9a3/35c0109a32b31deeb202280773f363a0.png"></div><br>  Masalah dengan objek ini adalah ia dianggap tidak dapat dimainkan.  Setiap kali Anda berinteraksi dengannya, Anda hanya melihat pesan yang mengatakan bahwa Anda tidak memiliki perangkat lunak game. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9e/6d3/3b8/a9e6d33b8e039a2f17c12fd134cf0308.png"></div><br>  Ternyata objek ini sebenarnya mencoba memindai kartu memori untuk file yang dirancang khusus berisi gambar ROM untuk NES!  Emulator NES yang digunakan untuk menjalankan game tertanam tampaknya merupakan emulator NES standar penuh untuk GameCube, dan mampu meluncurkan sebagian besar game. <br><br>  Sebelum menunjukkan fitur-fitur ini, saya akan menjelaskan proses rekayasa balik mereka. <br><br><h2>  Cari ROM bootloader pada kartu memori </h2><br><h3>  Kami mencari menu pengembang </h3><br>  Awalnya, saya ingin menemukan kode yang mengaktifkan berbagai menu pengembang, seperti menu pemilihan peta atau menu pilihan permainan untuk emulator NES.  Menu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Forest Map Select</a> , berkat Anda dapat dengan mudah memuat lokasi yang berbeda dari permainan, cukup mudah ditemukan - Saya hanya mencari garis FOREST MAP SELECT yang muncul di bagian atas layar (dapat dilihat di berbagai video dan tangkapan layar di Internet) ) <br><br>  Dalam “FOREST MAP SELECT” ada referensi silang data ke fungsi <code>select_print_wait</code> , yang mengarah ke sekelompok fungsi lain yang juga memiliki awalan <code>select_*</code> , termasuk fungsi <code>select_init</code> .  Mereka ternyata adalah fungsi yang mengontrol menu pemilihan peta. <br><br>  Fungsi <code>select_init</code> mengarah ke fungsi menarik lainnya yang disebut <code>game_get_next_game_dlftbl</code> .  Fungsi ini menghubungkan semua menu dan "adegan" lain yang dapat Anda jalankan: layar dengan logo Nintendo, layar utama, menu pilihan kartu, menu emulator NES (Famicom), dan sebagainya.  Itu dimulai pada awal prosedur permainan utama, menemukan fungsi inisialisasi adegan mana yang harus dijalankan, dan menemukan entri dalam struktur data tabel yang disebut <code>game_dlftbls</code> .  Tabel ini berisi tautan ke fungsi pemrosesan berbagai adegan, serta beberapa data lainnya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d93/cbc/019/d93cbc0191a754e6bb566525f1a21666.png"></div><br>  Sebuah penelitian yang cermat terhadap blok pertama dari fungsi menunjukkan bahwa ia memuat fungsi "next game init", dan kemudian mulai membandingkannya dengan serangkaian fungsi init yang terkenal: <br><br><ul><li> <code>first_game_init</code> </li> <li> <code>select_init</code> </li> <li> <code>play_init</code> </li> <li> <code>second_game_init</code> </li> <li> <code>trademark_init</code> </li> <li> <code>player_select_init</code> </li> <li> <code>save_menu_init</code> </li> <li> <code>famicom_emu_init</code> </li> <li> <code>prenmi_init</code> </li> </ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2e6/785/bae/2e6785bae4c526f3acba034d4f7e4b2e.png"></div><br>  Salah satu fungsi pointer yang dia cari adalah <code>famicom_emu_init</code> , yang bertanggung jawab untuk menjalankan emulator NES / Famicom.  <code>game_get_next_game_init</code> hasil <code>game_get_next_game_init</code> ke <code>famicom_emu_init</code> atau <code>famicom_emu_init</code> di debugger Dolphin, saya dapat menampilkan menu khusus.  Langkah selanjutnya adalah menentukan bagaimana pointer ini diatur dengan cara normal selama eksekusi program.  Satu-satunya hal yang fungsi <code>game_get_next_game_init</code> adalah memuat nilai pada offset <code>0xC</code> argumen pertama ke <code>game_get_next_game_dlftbl</code> . <br><br>  Melacak nilai-nilai ini yang diatur dalam berbagai struktur data sedikit membosankan, jadi saya akan langsung ke inti.  Hal terpenting yang saya temukan: <br><br><ul><li>  Ketika permainan dimulai dengan cara yang biasa, ia melakukan urutan tindakan berikut: <br><ul><li> <code>first_game_init</code> </li> <li> <code>second_game_init</code> </li> <li> <code>trademark_init</code> </li> <li> <code>play_init</code> </li> </ul></li><li>  <code>player_select_init</code> menetapkan init berikutnya untuk <code>select_init</code> .  Layar ini seharusnya memungkinkan Anda untuk memilih pemain segera setelah memilih kartu, tetapi tampaknya itu tidak berfungsi dengan benar. </li></ul><br>  Saya juga menemukan satu fungsi tanpa nama yang mendefinisikan fungsi init emulator, tetapi saya tidak menemukan apa pun yang mengatur fungsi init ke nilai init dari pemain atau pilihan peta. <br><br>  Pada titik ini, saya menyadari bahwa saya memiliki masalah bodoh lain dengan cara saya memuat nama fungsi di IDA: karena ekspresi reguler yang digunakan untuk memotong garis dalam file simbol debug, saya melewatkan semua nama fungsi mulai dengan huruf besar .  Fungsi yang diatur oleh <code>famicom_emu_init</code> tampak seperti transisi antar adegan, dan, tentu saja, disebut <code>Game_play_fbdemo_wipe_proc</code> . <br><br>  <code>Game_play_fbdemo_wipe_proc</code> menangani transisi antar adegan, seperti screen <code>Game_play_fbdemo_wipe_proc</code> dan blackout. <br><br>  Dalam kondisi tertentu, transisi layar dilakukan dari gameplay biasa ke tampilan emulator.  Dialah yang mengatur fungsi init emulator. <br><br><h3>  Menangani Objek Konsol </h3><br>  Sebenarnya, penangan objek furnitur untuk konsol NES membuat pengalih transisi layar beralih ke emulator.  Ketika seorang pemain berinteraksi dengan salah satu konsol, <code>aMR_FamicomEmuCommonMove</code> . <br><br>  Saat memanggil fungsi, <code>r6</code> berisi nilai indeks yang sesuai dengan angka dalam nama file game NES di <code>famicom.arc</code> : <br><br><ul><li> <code>01_nes_cluclu3.bin.szs</code> </li> <li> <code>02_usa_balloon.nes.szs</code> </li> <li> <code>03_nes_donkey1_3.bin.szs</code> </li> <li> <code>04_usa_jr_math.nes.szs</code> </li> <li> <code>05_pinball_1.nes.szs</code> </li> <li> <code>06_nes_tennis3.bin.szs</code> </li> <li> <code>07_usa_golf.nes.szs</code> </li> <li> <code>08_punch_wh.nes.szs</code> </li> <li> <code>09_usa_baseball_1.nes.szs</code> </li> <li> <code>10_cluclu_1.qd.szs</code> </li> <li> <code>11_usa_donkey3.nes.szs</code> </li> <li> <code>12_donkeyjr_1.nes.szs</code> </li> <li> <code>13_soccer.nes.szs</code> </li> <li> <code>14_exbike.nes.szs</code> </li> <li> <code>15_usa_wario.nes.szs</code> </li> <li> <code>16_usa_icecl.nes.szs</code> </li> <li> <code>17_nes_mario1_2.bin.szs</code> </li> <li> <code>18_smario_0.nes.szs</code> </li> <li> <code>19_usa_zelda1_1.nes.szs</code> </li> </ul><br>  ( <code>.arc</code> adalah format arsip file berpemilik.) <br><br>  Ketika <code>r6</code> tidak sama dengan nol, itu diteruskan dalam panggilan <code>aMR_RequestStartEmu</code> .  Dalam hal ini, transisi ke emulator dipicu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f78/268/1d7/f782681d712b4098ad6f9269cf2df5cc.png"></div><br>  Namun, jika <code>r6</code> adalah nol, maka fungsi <code>aMR_RequestStartEmu_MemoryC</code> dipanggil <code>aMR_RequestStartEmu_MemoryC</code> .  Menetapkan nilai dalam debugger ke 0, saya menerima pesan "Saya tidak memiliki perangkat lunak apa pun."  Saya tidak segera ingat bahwa saya perlu memeriksa objek Konsol NES untuk memastikannya menyetel ulang nilai <code>r6</code> , tetapi ternyata indeks nol digunakan untuk objek konsol tanpa kartrid. <br><br>  Meskipun <code>aMR_RequestStartEmu</code> hanya menyimpan nilai indeks dalam beberapa jenis struktur data, <code>aMR_RequestStartEmu_MemoryC</code> melakukan operasi yang jauh lebih kompleks ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d23/844/831/d23844831e1e9f9b8ef5b6a4306948ab.png"></div><br>  Blok kode ketiga ini memanggil <code>aMR_GetCardFamicomCount</code> dan memeriksa hasil yang tidak nol, jika tidak, melewatkan sebagian besar hal menarik di sisi kiri grafik fungsi. <br><br>  <code>aMR_GetCardFamicomCount</code> memanggil <code>famicom_get_disksystem_titles</code> , yang kemudian memanggil <code>memcard_game_list</code> , dan di sini semuanya menjadi sangat menarik. <br><br>  <code>memcard_game_list</code> memasang kartu memori dan mulai berkeliling dalam siklus tulis file, memeriksa masing-masing dari beberapa nilai.  Dengan melacak fungsi dalam debugger, saya dapat memahami bahwa itu membandingkan nilai dengan masing-masing file saya pada kartu memori. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da1/e17/dd1/da1e17dd1b1acd6552eeeabaedc586fb.png"></div><br>  Fungsi memutuskan apakah akan mengunduh file atau tidak, tergantung pada hasil pemeriksaan beberapa baris.  Pertama, ia memeriksa keberadaan garis "GAFE" dan "01", yang merupakan pengidentifikasi permainan dan perusahaan.  01 adalah singkatan dari Nintendo, GAFE adalah singkatan dari Animal Crossing.  Saya pikir itu singkatan dari GameCube Animal Forest English. <br><br>  Dia kemudian memeriksa baris "DobutsunomoriP_F_" dan "SAVE".  Dalam hal ini, baris pertama harus cocok, tetapi bukan yang kedua.  Ternyata "DobutsunomoriP_F_SAVE" adalah nama file yang menyimpan data game yang disematkan untuk NES.  Oleh karena itu, semua file kecuali yang ini akan dimuat dengan awalan "DobutsunomoriP_F_". <br><br>  Menggunakan debugger Dolphin untuk melewati perbandingan string dengan "SIMPAN" dan membuat trik permainan untuk percaya bahwa file "SIMPAN" saya dapat diunduh dengan aman, saya mendapatkan menu ini setelah menggunakan konsol NES: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d4/1d2/696/1d41d26963aeaf11450155f1d7d53085.png"></div><br>  Saya menjawab "Ya" dan mencoba memuat file save sebagai game, setelah itu saya pertama kali melihat layar crash game bawaan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41e/662/4cc/41e6624cc68fe28e897cd1803ba1a39a.png"></div><br>  Hebat!  Sekarang saya tahu bahwa dia sebenarnya mencoba mengunduh permainan dari kartu memori, dan saya dapat mulai menganalisis format untuk menyimpan file untuk melihat apakah ROM yang sebenarnya dapat diunduh. <br><br>  Hal pertama yang saya coba lakukan adalah mencoba mencari di mana nama permainan dibaca dari file kartu memori.  Mencari baris "FEFSC" yang ada di pesan "Apakah Anda ingin memutar &lt;nama&gt;?", Saya menemukan offset di mana ia dibaca dari file: <code>0x642</code> .  Saya menyalin file simpan, mengubah nama file menjadi “DobutsunomoriP_F_TEST”, mengubah byte pada offset <code>0x642</code> menjadi “TESTING” dan mengimpor save yang diubah, setelah itu nama yang saya butuhkan muncul di menu. <br><br>  Setelah menambahkan beberapa file lagi dalam format ini, beberapa opsi muncul di menu: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/235/ca3/668/235ca3668ae0a02ad2609847bdf193c0.png"></div><br><h3>  Unduh ROM </h3><br>  Jika <code>aMR_GetCardFamicomCount</code> dikembalikan bukan nol, maka memori dialokasikan pada heap, <code>famicom_get_disksystem_titles</code> secara langsung dipanggil <code>famicom_get_disksystem_titles</code> , setelah itu sekelompok offset acak ditentukan dalam struktur data.  Alih-alih menguraikan di mana nilai-nilai ini akan dibaca, saya mulai mempelajari daftar fungsi <code>famicom</code> . <br><br>  Ternyata saya membutuhkan <code>famicom_rom_load</code> .  Ini mengontrol pemuatan ROM, baik dari kartu memori, atau dari sumber daya internal permainan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/999/22b/462/99922b462892ef544d45e849da1c54a5.png"></div><br>  Yang paling penting di blok "boot from memory card" ini adalah ia memanggil <br>  <code>memcard_game_load</code> .  Dia me-mount file pada kartu memori lagi, membacanya dan mem-parsing.  Di sinilah opsi format file yang paling penting menjadi jelas. <br><br><h4>  Nilai checksum </h4><br>  Hal pertama yang terjadi setelah file diunggah adalah perhitungan checksum.  Fungsi <code>calcSum</code> , yang merupakan algoritma yang sangat sederhana yang menjumlahkan nilai semua byte dalam data dari kartu memori.  Delapan bit terbawah dari hasilnya harus nol.  Artinya, untuk lulus pemeriksaan ini, Anda perlu menjumlahkan nilai semua byte dalam file sumber, menghitung nilai yang perlu ditambahkan sehingga delapan bit terbawah menjadi nol, dan kemudian menetapkan nilai ini ke byte checksum dalam file. <br><br>  Jika verifikasi gagal, maka Anda menerima pesan tentang ketidakmungkinan membaca dengan benar kartu memori, dan tidak ada yang terjadi.  Selama debugging, yang harus saya lakukan adalah melewati pemeriksaan ini. <br><br><h4>  Salin ROM </h4><br>  Menjelang akhir <code>memcard_game_load</code> , hal menarik lainnya terjadi.  Ada beberapa blok kode yang lebih menarik antara itu dan checksum, tetapi tidak ada satupun yang mengarah ke percabangan yang mengabaikan pelaksanaan perilaku ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc8/376/55d/cc837655d2ec1b207b0f7420db856a1e.png"></div><br>  Jika nilai integer 16-bit tertentu yang dibaca dari kartu memori tidak sama dengan nol, maka sebuah fungsi dipanggil yang memeriksa header kompresi di buffer.  Itu memeriksa untuk format kompresi Nintendo eksklusif dengan melihat awal Yay0 atau buffer Yaz0.  Jika salah satu dari baris ini ditemukan, fungsi unpack disebut.  Jika tidak, fungsi salin salinan sederhana dilakukan.  Bagaimanapun, setelah itu, variabel yang disebut <code>nesinfo_data_size</code> . <br><br>  Petunjuk lain dari konteks di sini adalah bahwa file ROM untuk permainan NES tertanam menggunakan kompresi Yaz0, dan baris ini ada di header file mereka. <br><br>  Setelah mengamati nilai yang diperiksa nol, dan buffer dialihkan ke fungsi pemeriksaan kompresi, saya segera mengetahui dari mana game itu dibaca dari dalam file pada kartu memori.  Pemeriksaan nol dilakukan untuk bagian buffer 32-byte yang disalin dari offset <code>0x640</code> dalam file, yang kemungkinan besar adalah header ROM.  Fungsi ini juga memeriksa bagian lain dari file tersebut, dan di dalamnya ada nama game tersebut (dimulai dengan byte ketiga dari header). <br><br>  Di jalur eksekusi kode yang saya temukan, buffer ROM terletak tepat setelah buffer header 32-byte ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c2/01f/34c/7c201f34c3b9427c288654d487acbcbf.png"></div><br>  Informasi ini cukup untuk mencoba membuat file ROM yang berfungsi.  Saya hanya mengambil salah satu file Animal Crossing lainnya dan mengeditnya di hex editor untuk mengganti nama file dengan <code>DobutsunomoriP_F_TEST</code> dan menghapus semua area di mana saya ingin menempelkan data. <br><br>  Untuk uji coba, saya menggunakan Pinball game ROM, yang sudah ada dalam game, dan memasukkan isinya setelah header 32-byte.  Alih-alih menghitung nilai checksum, saya mengatur breakpoint sehingga saya hanya melewatkan <code>calcSum</code> dan juga mengamati hasil pemeriksaan lain yang mungkin mengarah ke cabang yang melewatkan proses boot ROM. <br><br>  Akhirnya, saya mengimpor file baru melalui manajer kartu memori Dolphin, memulai kembali permainan, dan mencoba untuk meluncurkan konsol. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/199/d08/799/199d087997375f8666284220e7ffcc62.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/527/be8/5f5/527be85f54ab8f37609047d323c6b442.png"></div><br>  Berhasil!  Ada beberapa bug grafis kecil yang terkait dengan parameter Dolphin, yang memengaruhi mode grafis yang digunakan oleh emulator NES, tetapi secara umum gim ini bekerja dengan baik.  (Pada build Dolphin yang lebih baru, ini seharusnya berfungsi secara default.) <br><br>  Untuk memastikan bahwa permainan lain juga mulai, saya mencoba menulis beberapa ROM lain yang tidak ada dalam permainan.  Battletoads dimulai, tetapi berhenti bekerja setelah teks layar splash (setelah pengaturan lebih lanjut saya berhasil membuatnya dimainkan).  Mega Man, di sisi lain, bekerja dengan sempurna: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/923/5a2/7da/9235a27da4d094a496a477cc24cd4846.png"></div><br>  Untuk mempelajari cara membuat file ROM baru yang dapat dimuat tanpa campur tangan para debugger, saya harus mulai menulis kode dan lebih memahami parsing format file. <br><br><h3>  Format File ROM Eksternal </h3><br>  Bagian terpenting dari penguraian file terjadi di <code>memcard_game_load</code> .  Ada enam bagian utama blok parsing kode dalam fungsi ini: <br><br><ul><li>  Checksum </li><li>  Simpan nama file </li><li>  Header file ROM </li><li>  Buffer tidak dikenal disalin tanpa pemrosesan apa pun </li><li>  Komentar teks, ikon dan pemuat spanduk (untuk membuat file penyimpanan baru) </li><li>  Bootloader ROM </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f00/194/51e/f0019451e2d0070900f75c62cb83535a.png"></div><br><h4>  Checksum </h4><br>  Delapan bit terbawah dari jumlah semua nilai byte dalam file save harus nol.  Berikut ini adalah kode Python sederhana yang menghasilkan byte checksum yang diperlukan: <br><br><pre> <code class="python hljs">checksum = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> byte_val <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> new_data_tmp: checksum += byte_val checksum = checksum % (<span class="hljs-number"><span class="hljs-number">2</span></span>**<span class="hljs-number"><span class="hljs-number">32</span></span>) <span class="hljs-comment"><span class="hljs-comment"># keep it 32 bit checkbyte = 256 - (checksum % 256) new_data_tmp[-1] = checkbyte</span></span></code> </pre> <br>  Mungkin ada tempat khusus untuk menyimpan byte checksum, tetapi menambahkannya ke ruang kosong di akhir file save berfungsi dengan baik. <br><br><h4>  Nama file </h4><br>  Sekali lagi, nama file save harus dimulai dengan "DobutsunomoriP_F_" dan diakhiri dengan sesuatu yang tidak mengandung "SAVE".  Nama file ini disalin beberapa kali, dan dalam satu kasus huruf "F" diganti dengan "S".  Ini akan menjadi nama file penyimpanan untuk game NES ("DobutsunomoriP_S_NAME"). <br><br><h4>  Header ROM </h4><br>  Salinan langsung header 32-byte dimuat ke dalam memori.  Beberapa nilai dalam header ini digunakan untuk menentukan cara menangani bagian selanjutnya.  Pada dasarnya, ini adalah beberapa nilai ukuran 16-bit dan bit parameter yang dikemas. <br><br>  Jika Anda melacak pointer yang disalin oleh header sampai ke awal fungsi dan menemukan posisi argumennya, tanda tangan dari fungsi di bawah ini akan menunjukkan bahwa ia sebenarnya memiliki tipe <code>MemcardGameHeader_t*</code> . <br><br><pre> <code class="python hljs">memcard_game_load(unsigned char *, int, unsigned char **, char *, char *, MemcardGameHeader_t *, unsigned char *, unsigned long, unsigned char *, unsigned long)</code> </pre> <br><h4>  Buffer tidak dikenal </h4><br>  Periksa nilai ukuran 16-bit dari header.  Jika tidak sama dengan nol, maka jumlah byte yang sesuai secara langsung disalin dari buffer file ke blok baru memori yang dialokasikan.  Ini memindahkan penunjuk data dalam buffer file sehingga penyalinan lebih lanjut dapat dilanjutkan dari bagian berikutnya. <br><br><h4>  Spanduk, ikon dan komentar </h4><br>  Nilai ukuran lain diperiksa di header, dan jika tidak sama dengan nol, fungsi pemeriksaan kompresi file dipanggil.  Jika perlu, algoritma pembongkaran akan diluncurkan, setelah itu <code>SetupExternCommentImage</code> . <br><br>  Fungsi ini melakukan tiga hal: "komentar", gambar spanduk dan ikon.  Untuk masing-masing, ada kode di header ROM yang menunjukkan cara menanganinya.  Ada beberapa opsi berikut: <br><br><ol><li>  Gunakan nilai default </li><li>  Salin dari bagian banner / ikon / komentar dalam file ROM </li><li>  Salin dari buffer alternatif </li></ol><br>  Nilai default kode menyebabkan ikon atau spanduk dimuat dari sumber pada disk, dan nama file simpan dan komentar (deskripsi teks dari file) diberi nilai "Animal Crossing" dan "NES Cassette Save Data".  Begini tampilannya: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/906/519/045/906519045718e74cf565c2983401692c.png"></div><br>  Nilai kedua kode hanya menyalin nama permainan dari file ROM (alternatif untuk "Animal Crossing"), dan kemudian mencoba untuk menemukan string "] ROM" di komentar file dan menggantinya dengan "] SIMPAN".  Rupanya, file yang ingin dirilis Nintendo seharusnya dalam format nama "Game Name [NES] ROM" atau yang serupa. <br><br>  Untuk ikon dan spanduk, kode mencoba menentukan format gambar, mendapatkan nilai ukuran tetap yang sesuai dengan format ini, dan kemudian menyalin gambar. <br><br>  Pada nilai kode terakhir, nama file dan deskripsi disalin tanpa perubahan dari buffer, dan ikon dan spanduk juga diambil dari buffer alternatif. <br><br><h4>  ROM </h4><br>  Jika Anda dengan hati-hati melihat tangkapan layar <code>memcard_game_load</code> copying ROM, Anda dapat melihat bahwa nilai 16-bit diperiksa untuk kesetaraan ke nol digeser ke kiri oleh 4 bit (dikalikan dengan 16), dan kemudian digunakan sebagai ukuran fungsi <code>memcpy</code> jika kompresi tidak terdeteksi.  Ini adalah nilai ukuran lain yang ada di header. <br><br>  Jika ukurannya tidak sama dengan nol, maka data ROM diperiksa untuk kompresi, dan kemudian disalin. <br><br><h3>  Pencarian buffer dan bug tidak dikenal </h3><br>  Walaupun mengunduh ROM baru cukup aneh, hal yang paling menarik tentang loader ROM ini bagi saya adalah bahwa sebenarnya ini adalah satu-satunya bagian dari permainan yang menerima input pengguna dengan ukuran variabel dan menyalinnya ke lokasi memori yang berbeda.  Hampir semuanya menggunakan buffer ukuran konstan.  Hal-hal seperti nama dan teks huruf mungkin tampak berbeda panjangnya, tetapi pada dasarnya ruang kosong hanya diisi dengan spasi.  String zero-terminated jarang digunakan, menghindari bug kerusakan memori umum, seperti menggunakan <code>strcpy</code> dengan buffer yang terlalu kecil untuk menyalin string ke dalamnya. <br><br>  Saya sangat tertarik dengan kemungkinan menemukan exploit dari gim tersebut berdasarkan pada menyimpan file, dan sepertinya ini adalah pilihan terbaik. <br><br>  Sebagian besar operasi file ROM yang dijelaskan di atas menggunakan salinan ukuran konstan, dengan pengecualian buffer dan data ROM yang tidak diketahui.  Sayangnya, kode yang memproses buffer ini mengalokasikan ruang yang sama persis dengan yang diperlukan untuk menyalinnya, sehingga tidak ada overflow, dan pengaturan ukuran file ROM yang sangat besar tidak terlalu berguna. <br><br>  Tetapi saya masih ingin tahu apa yang terjadi pada buffer ini, yang disalin tanpa pemrosesan apa pun. <br><br><h4>  Penangan Label Informasi NES </h4><br>  Saya kembali ke <code>famicom_rom_load</code> .  Setelah memuat ROM dari kartu memori atau disk, beberapa fungsi dipanggil: <br><br><ul><li> <code>nesinfo_tag_process1</code> </li> <li> <code>nesinfo_tag_process2</code> </li> <li> <code>nesinfo_tag_process3</code> </li> </ul><br>  Setelah melacak tempat penyangga yang tidak dikenal disalin, saya memastikan bahwa tugas ini dilakukan oleh fungsi-fungsi ini.  Mereka mulai dengan panggilan ke <code>nesinfo_next_tag</code> , yang melakukan algoritma sederhana: <br><br><ul><li>  Cek apakah pointer yang ditentukan <code>nesinfo_tags_end</code> pointer di <code>nesinfo_tags_end</code> .  Jika kurang dari <code>nesinfo_tags_end</code> atau <code>nesinfo_tags_end</code> adalah nol, maka ia memeriksa keberadaan string "END" di header pointer. <br><br><ul><li>  Jika "END" tercapai, atau penunjuk telah naik ke atau di atas <code>nesinfo_tags_end</code> , maka fungsi mengembalikan nol. </li><li>  Jika tidak, byte pada offset <code>0x3</code> pointer ditambahkan ke 4 dan ke pointer saat ini, setelah itu nilai dikembalikan. </li></ul></li></ul><br>  Ini memberitahu kita bahwa ada beberapa jenis format label dari nama tiga huruf, nilai ukuran data dan data itu sendiri.  Hasilnya adalah penunjuk ke label berikutnya, karena label saat ini dilewati ( <code>cur_ptr + 4</code> melompati nama tiga huruf dan satu byte, dan <code>size_byte</code> melewatkan data). <br><br>  Jika hasilnya tidak nol, maka fungsi pemrosesan label melakukan serangkaian perbandingan string untuk mengetahui label mana yang perlu diproses.  Beberapa nama label yang diperiksa di <code>nesinfo_tag_process1</code> : VEQ, VNE, GID, GNO, BBR, dan QDS. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f1/094/08b/0f109408b8d01ec8cf4522445463e378.png"></div><br>  Jika kecocokan label ditemukan, beberapa kode handler dijalankan.  Beberapa penangan tidak melakukan apa pun selain menampilkan label dalam pesan debug.  Lainnya memiliki penangan yang lebih kompleks.  Setelah memproses label, fungsi mencoba untuk mendapatkan label berikutnya dan melanjutkan pemrosesan. <br><br>  Untungnya, ada banyak pesan debugging terperinci yang ditampilkan ketika tag terdeteksi.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mereka semua dalam bahasa Jepang, jadi pertama-tama mereka harus diterjemahkan dari Shift-JIS dan diterjemahkan. Misalnya, pesan untuk QDS mungkin bertuliskan "Memuat area penyimpanan disk" atau "Karena ini adalah proses pertama, buat area penyimpanan disk". Pesan untuk BBR bertuliskan "memuat cadangan baterai" atau "karena ini adalah awal pertama, kami melakukan pembersihan". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kedua kode ini juga memuat beberapa nilai dari bagian data label mereka dan menggunakannya untuk menghitung offset dalam data ROM, setelah itu mereka melakukan operasi penyalinan. Jelas, mereka bertanggung jawab untuk menentukan bagian-bagian dalam memori ROM yang terkait dengan pelestarian negara.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada juga tag "HSC" dengan pesan debug yang mengatakan bahwa ia sedang memproses catatan poin. </font><font style="vertical-align: inherit;">Dia mendapatkan offset dalam ROM dari data tag-nya, serta nilai catatan skor asli. </font><font style="vertical-align: inherit;">Tanda ini dapat digunakan untuk menunjukkan tempat di memori game NES untuk menyimpan skor tinggi, mungkin untuk menyimpan dan mengembalikannya di masa mendatang. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tag ini membuat sistem pengunduhan metadata ROM yang cukup rumit. </font><font style="vertical-align: inherit;">Selain itu, banyak dari mereka mengarah pada panggilan </font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berdasarkan nilai yang dikirimkan dalam label data.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Perburuan serangga </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kebanyakan tag yang mengarah pada manipulasi memori tidak terlalu berguna untuk eksploitasi, karena semuanya memiliki nilai offset dan ukuran maksimum yang ditentukan sebagai bilangan bulat 16-bit. </font><font style="vertical-align: inherit;">Ini cukup untuk bekerja dengan ruang alamat NES 16-bit, tetapi tidak cukup untuk menulis nilai target yang bermanfaat, seperti pointer ke fungsi atau mengembalikan alamat pada tumpukan di ruang alamat GameCube 32-bit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, ada beberapa kasus di mana nilai ukuran offset yang ditransmisikan </font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dapat melebihi </font></font><code>0xFFFF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> QDS </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QDS memuat offset 24-bit dari data tag-nya, serta nilai ukuran 16-bit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hal yang baik di sini adalah bahwa offset digunakan untuk menghitung alamat tujuan dari operasi penyalinan. Alamat dasar offset adalah awal dari data yang diunduh, sumber salinan ada dalam file ROM kartu memori, dan ukurannya ditentukan oleh nilai ukuran 16-bit dari label. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nilai 24-bit memiliki nilai maksimum </font></font><code>0xFFFFFF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang jauh lebih dari apa yang diperlukan untuk menulis di luar data ROM yang dimuat. Namun, ada masalah tertentu ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yang pertama adalah bahwa meskipun nilai ukuran maksimum sama </font></font><code>0xFFFF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pada awalnya digunakan untuk mengatur ulang partisi memori. Jika nilai ukuran terlalu tinggi (tidak jauh lebih besar </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), maka ini akan mengatur ulang tanda "QDS" dalam kode game.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan di situlah letak masalahnya, karena </font></font><code>nesinfo_tag_process1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sebenarnya disebut dua kali. Untuk pertama kalinya, dia menerima beberapa informasi tentang ruang yang dia butuhkan untuk mempersiapkan data yang disimpan. Tag QDS dan BBR tidak sepenuhnya diproses pada proses pertama. Setelah dijalankan pertama kali, sebuah tempat disiapkan untuk menyimpan data, dan fungsinya dipanggil lagi. Kali ini, tag QDS dan BBR sepenuhnya diproses, tetapi jika string nama tag dihapus dari memori, maka tidak mungkin untuk mencocokkan tag lagi! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini dapat dihindari dengan menetapkan nilai ukuran yang lebih kecil. Masalah lain adalah bahwa nilai offset hanya dapat bergerak maju dalam memori, dan data ROM NES terletak di tumpukan yang cukup dekat dengan akhir memori yang tersedia.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah mereka hanya ada beberapa tumpukan, dan tidak satu pun dari mereka memiliki sesuatu yang sangat berguna, seperti pointer fungsi yang jelas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam kasus normal, Anda bisa menggunakan ini untuk mengeksploitasi heap overflow, tetapi dalam implementasi yang </font></font><code>malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">digunakan untuk heap ini, beberapa byte pemeriksaan kesehatan dalam blok telah ditambahkan </font></font><code>malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Kita dapat menulis lebih dari nilai pointer di blok heap berikutnya. Tanpa pemeriksaan kesehatan, ini dapat digunakan untuk menulis ke area memori sewenang-wenang ketika dipanggil </font></font><code>free</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk blok tumpukan yang terlibat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, implementasi yang digunakan di sini </font></font><code>malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memeriksa pola byte tertentu ( </font></font><code>0x7373</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) di awal blok berikutnya dan sebelumnya yang akan dimanipulasi ketika dipanggil</font></font><code>free</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Jika dia tidak menemukan byte ini, maka dia memanggil </font></font><code>OSPanic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan gamenya membeku.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/516/68f/447/51668f447b75887250574f1ad1ec1800.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak dapat memengaruhi keberadaan byte ini di beberapa lokasi target, tidak mungkin untuk menulis di sini. </font><font style="vertical-align: inherit;">Dengan kata lain, tidak mungkin untuk merekam sesuatu di tempat yang sewenang-wenang tanpa bisa merekam sesuatu di dekat tempat ini. </font><font style="vertical-align: inherit;">Mungkin ada beberapa cara untuk membuat nilai yang </font></font><code>0x73730000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">disimpan di tumpukan langsung di depan alamat kembali </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tempat yang merujuk nilai, yang ingin kita tulis ke alamat tujuan (itu juga akan diperiksa seolah-olah itu adalah pointer ke heap block), tetapi ini sulit untuk mencapai dan menggunakannya dalam eksploitasi.</font></font><br><br><h5> <code>nesinfo_update_highscore</code> </h5> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fungsi lain tentang tag QDS, BBR dan HSC adalah ini </font></font><code>nesinfo_update_highscore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ukuran tanda QDS, BBR, dan OFS (offset) digunakan untuk menghitung offset yang digunakan untuk merekam, dan tanda HSC mencakup perekaman di lokasi tersebut. Fungsi ini dilakukan untuk setiap frame yang diproses oleh emulator NES. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nilai offset maksimum untuk setiap label dalam hal ini, bahkan untuk QDS, adalah sama </font></font><code>0xFFFF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Namun, selama siklus pemrosesan label, nilai dimensi dari label BBR dan QDS sebenarnya </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menumpuk</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ini berarti bahwa beberapa tanda dapat digunakan untuk menghitung hampir semua nilai ofset. Batasannya adalah jumlah label yang dapat ditampung di bagian data label ROM dalam file pada kartu memori, dan itu juga memiliki ukuran maksimum </font></font><code>0xFFFF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alamat dasar yang ditambahkan offset adalah </font></font><code>0x800C3180</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">buffer data simpanan. </font><font style="vertical-align: inherit;">Alamat ini jauh lebih rendah daripada data ROM, yang memberi kita lebih banyak kebebasan dalam memilih lokasi rekaman. </font><font style="vertical-align: inherit;">Sebagai contoh, akan cukup sederhana untuk menulis ulang alamat pengirim di stack ke alamat tersebut </font></font><code>0x812F95DC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sayangnya, ini juga tidak berhasil. </font><font style="vertical-align: inherit;">Ternyata itu </font></font><code>nesinfo_tag_process1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">juga memeriksa ukuran akumulasi dari offset dari label ini, dan menggunakan ukuran ini untuk menginisialisasi ruang:</font></font><br><br><pre> <code class="cpp hljs">bzero(nintendo_hi_0, ((offset_sum + <span class="hljs-number"><span class="hljs-number">0xB</span></span>) * <span class="hljs-number"><span class="hljs-number">4</span></span>) + <span class="hljs-number"><span class="hljs-number">0x40</span></span>)</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b3/531/0ab/7b35310ab9bae3406ee423acd1c1a1a5.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan nilai offset yang saya coba hitung, ini mengarah pada fakta bahwa </font></font><code>0x48D91EC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(76.386.796) byte memori </font><font style="vertical-align: inherit;">telah dihapus </font><font style="vertical-align: inherit;">, itulah sebabnya mengapa game tersebut mengalami crashed secara spektakuler.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tanda PAT </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya sudah mulai kehilangan harapan, karena semua tag yang membuat panggilan tanpa kondom </font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">telah gagal bahkan sebelum saya berhasil menggunakannya. Saya memutuskan untuk mendokumentasikan tujuan dari setiap tag, dan secara bertahap mencapai tag tersebut </font></font><code>nesinfo_tag_process2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebagian besar penangan label </font></font><code>nesinfo_tag_process2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak pernah memulai, karena mereka hanya bekerja ketika penunjuk adalah </font></font><code>nesinfo_rom_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nol. Tidak ada dalam kode yang memberikan nilai bukan nol pada pointer ini. Ini diinisialisasi dengan nilai nol dan tidak pernah digunakan lagi. Saat memuat ROM hanya diatur </font></font><code>nesinfo_data_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, jadi sepertinya kode mati. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, ada satu label yang masih bisa berfungsi ketika bukan nol </font></font><code>nesinfo_rom_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: PAT. Ini adalah label yang paling sulit dalam suatu fungsi </font></font><code>nesinfo_tag_process2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5a/8fa/e47/b5a8fae47c7ba7f82b2ee9810a950c6e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini juga digunakan sebagai pointer </font></font><code>nesinfo_rom_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tetapi tidak pernah memeriksanya nol. </font><font style="vertical-align: inherit;">Tag PAT membaca buffer data tag-nya sendiri, memproses kode yang menghitung offset. </font><font style="vertical-align: inherit;">Offset ini ditambahkan ke pointer </font></font><code>nesinfo_rom_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk menghitung alamat tujuan, dan kemudian byte disalin dari buffer patch ke lokasi ini. </font><font style="vertical-align: inherit;">Penyalinan ini dilakukan dengan memuat dan menyimpan byte, tidak menggunakan instruksi </font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, jadi saya belum menyadarinya sebelumnya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setiap buffer data tanda PAT memiliki kode jenis 8-bit, ukuran patch 8-bit, dan nilai offset 16-bit, diikuti oleh data patch.</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jika kodenya 2, maka nilai offset ditambahkan ke jumlah offset saat ini. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jika kodenya 9, maka offset digeser ke atas sebanyak 4 bit dan ditambahkan ke jumlah offset saat ini. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jika kodenya 3, maka jumlah offset diset ulang ke 0. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ukuran maksimum label informasi NES adalah 255, mis. Ukuran patch PAT terbesar adalah 251 byte. </font><font style="vertical-align: inherit;">Namun, beberapa tanda PAT dapat digunakan, yaitu, Anda dapat menambal lebih dari 251 byte, serta menambal ruang yang tidak bersebelahan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selama kita memiliki serangkaian sol PAT dengan kode 2 atau kode 9, offset dari pointer tujuan terus menumpuk. </font><font style="vertical-align: inherit;">Saat menyalin data tambalan, ini diatur ulang ke nol, tetapi jika Anda menggunakan ukuran tambalan nol, ini bisa dihindari. </font><font style="vertical-align: inherit;">Jelas bahwa ini dapat digunakan untuk menghitung beberapa offset acak dengan pointer nol </font></font><code>nesinfo_rom_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menggunakan banyak tanda PAT. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, ada dua lagi pemeriksaan nilai kode ...</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika kode berada di antara </font></font><code>0x80</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>0xFF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, kemudian ditambahkan ke </font></font><code>0x7F80</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan kemudian bergeser ke atas 16 bit. </font><font style="vertical-align: inherit;">Kemudian ditambahkan ke nilai offset 16-bit dan digunakan sebagai alamat akhir untuk tambalan.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini memungkinkan kami untuk menetapkan alamat tujuan untuk tambalan dalam rentang dari </font></font><code>0x80000000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hingga </font></font><code>0x807FFFFF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">! </font><font style="vertical-align: inherit;">Di sinilah sebagian besar kode Animal Crossing berada dalam memori. </font><font style="vertical-align: inherit;">Ini berarti bahwa kita dapat menambal kode Animal Crossing itu sendiri menggunakan label metadata ROM dari file pada kartu memori. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan bantuan patch loader kecil, Anda bahkan dapat dengan mudah mengunduh patch yang lebih besar dari kartu memori ke alamat apa pun. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebagai pemeriksaan cepat, saya membuat tambalan yang menyertakan "zuru mode 2" (mode pengembang game, dijelaskan dalam </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">artikel</font></a><font style="vertical-align: inherit;"> saya </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sebelumnya</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) ketika pengguna memuat ROM dari peta game. </font><font style="vertical-align: inherit;">Ternyata cheat combo dari tombol hanya mengaktifkan mode "zuru mode 1", yang tidak memiliki akses ke fungsi yang dimiliki Mode 2. Dengan tambalan ini, berkat kartu memori, kita bisa mendapatkan akses penuh ke mode pengembang di perangkat keras nyata.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/864/d51/d15/864d51d15fa180ea3fab552a0dd4977b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tanda patch akan diproses saat ROM melakukan booting. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/499/dc8/2e4/499dc82e445ffd6bfd607d4f834ccd5a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Setelah memuat ROM, Anda harus keluar dari emulator NES untuk melihat hasilnya. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/694/6ea/3a2/6946ea3a20e0290b75eeba8bbf400d10.png"></div><br>  Itu berhasil! <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Format Label Info Patch </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tanda informasi dalam file simpan yang menjalankan tambalan ini terlihat seperti ini: </font></font><br><br> <code>000000 5a 5a 5a 00 50 41 54 08 a0 04 6f 9c 00 00 00 7d &gt;ZZZ.PAT...o....}&lt; <br> 000010 45 4e 44 00 &gt;END.&lt;</code> <br> <br><ul><li> <code>ZZZ \x00</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: tanda mulai diabaikan. </font></font><code>0x00</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apakah ukuran buffer datanya: nol.</font></font></li><li> <code>PAT \x08 \xA0 \x04 \x6F\x9C \x00\x00\x00\x7D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Patch </font></font><code>0x80206F9C</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di </font></font><code>0x0000007D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><ul><li> <code>0x08</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apakah ukuran buffer label. </font></font></li><li> <code>0xA0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ketika ditambahkan </font></font><code>0x7F80</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menjadi </font></font><code>0x8020</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yaitu, 16 bit atas dari alamat tujuan.</font></font></li><li> <code>0x04</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apakah ukuran data tambalan ( </font></font><code>0x0000007D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font></li><li> <code>0x6F9C</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apakah 16 bit terbawah dari alamat tujuan. </font></font></li><li> <code>0x0000007D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apakah data tambalan. </font></font></li></ul></li><li> <code>END \x00</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : tanda penanda akhir. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda ingin bereksperimen sendiri dengan membuat patcher atau ROM menyimpan file, maka di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/jamchamb/ac-nesrom-save-generator,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> saya memposting kode yang sangat sederhana untuk membuat file. </font><font style="vertical-align: inherit;">Patch seperti yang ditunjukkan di atas dapat dihasilkan dengan perintah berikut:</font></font><br><br> <code>$ ./patcher.py Patcher /dev/null zuru_mode_2.gci -p 80206F9c 0000007D</code> <br> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eksekusi kode sewenang-wenang </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berkat tag ini, Anda dapat mencapai eksekusi kode arbitrer di Animal Crossing. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tapi inilah rintangan terakhir: menggunakan tambalan untuk data berfungsi dengan baik, tetapi masalah muncul ketika menambal instruksi kode. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika tambalan direkam, gim terus mengikuti instruksi lama yang ada di tempatnya. Ini sepertinya masalah caching, dan sebenarnya itu. CPU GameCube memiliki cache instruksi, seperti dijelaskan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam spesifikasi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk memahami bagaimana Anda bisa menghapus cache, saya mulai mempelajari fungsi-fungsi yang berhubungan dengan cache dari dokumentasi GameCube SDK, dan menemukan </font></font><code>ICInvalidateRange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Fungsi ini membatalkan blok instruksi yang di-cache di alamat memori yang ditentukan, yang memungkinkan memori instruksi yang dimodifikasi dijalankan dengan kode yang diperbarui.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, tanpa kemampuan untuk menjalankan kode asli, kami masih tidak dapat menelepon </font></font><code>ICInvalidateRange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Agar eksekusi kode berhasil, kita perlu satu trik lagi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mempelajari implementasi </font></font><code>malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk kemungkinan menggunakan exploit dengan heap overflow, saya belajar bahwa fungsi implementasi </font></font><code>malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dapat dinonaktifkan secara dinamis menggunakan struktur data yang disebut </font></font><code>my_malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>my_malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memuat pointer ke implementasi saat ini </font></font><code>malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atau </font></font><code>free</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dari tempat statis di memori, dan kemudian memanggil fungsi ini, meneruskan semua argumen yang diteruskan ke </font></font><code>my_malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Emulator NES aktif digunakan</font></font><code>my_malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk mengalokasikan dan membebaskan memori untuk data NES terkait ROM, jadi saya yakin itu akan diluncurkan beberapa kali pada waktu yang sama dengan tanda PAT. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena </font></font><code>my_malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memuat pointer dari memori dan membuat transisi ke sana, saya dapat mengubah proses eksekusi program hanya dengan menimpa pointer sehingga menunjuk ke fungsi saat ini </font></font><code>malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atau </font></font><code>free</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Caching alat tidak akan mencegah hal ini terjadi, karena tidak ada instruksi yang harus diubah </font></font><code>my_malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengembang proyek penggemar Dōbutsu no Mori e +, bernama Cuyler, menulis pemuat seperti itu di assembler PowerPC dan menunjukkan penggunaannya untuk menyuntikkan kode baru dalam video ini: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://www.youtube.com/watch?v=BdxN7gP6WIc</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">(Dōbutsu no Mori e + adalah iterasi Animal Crossing terakhir di GameCube, yang memiliki pembaruan terbanyak. Dirilis hanya di Jepang.) Patch mengunduh beberapa kode yang memungkinkan pemain untuk membuat objek dengan memasukkan ID mereka dengan huruf dan menekan tombol Z.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/BdxN7gP6WIc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berkat ini, Anda dapat mengunduh mod, cheat dan homebrew dalam salinan Animal </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crossing biasa di GameCube sungguhan.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id417117/">https://habr.com/ru/post/id417117/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id417107/index.html">Pembuat game sementara True: learn () tentang pemrograman gamedev, masalah VR, dan simulasi ML</a></li>
<li><a href="../id417109/index.html">Richard Hamming: Bab 10. Teori Pengkodean - I</a></li>
<li><a href="../id417111/index.html">Konferensi online: streaming vs webinar</a></li>
<li><a href="../id417113/index.html">Printer Italia 3D di Rusia: Raise3D N1 Dual - modelling dan prototyping</a></li>
<li><a href="../id417115/index.html">Untuk mengubur atau membakar Flutter.io?</a></li>
<li><a href="../id417119/index.html">Pagination di Vue.js</a></li>
<li><a href="../id417123/index.html">Integrasi Spark Streaming dan Kafka</a></li>
<li><a href="../id417125/index.html">Rapat RTC .Net: undang ke pertemuan pertama</a></li>
<li><a href="../id417127/index.html">Tesla Menandatangani Perjanjian untuk Membangun Gigafactory 3 di Cina</a></li>
<li><a href="../id417129/index.html">Alam semesta pikiran</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>