<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äç‚öñÔ∏è üíú ‚ùì Optimisation du rendu d'une sc√®ne du dessin anim√© Disney "Moana". Parties 4 et 5 ‚èèÔ∏è üìä üöç</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="J'ai une branche pbrt, que j'utilise pour tester de nouvelles id√©es, mettre en ≈ìuvre des id√©es int√©ressantes √† partir d'articles scientifiques, et en ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimisation du rendu d'une sc√®ne du dessin anim√© Disney "Moana". Parties 4 et 5</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417939/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fe/8a1/30a/6fe8a130ad8c4f43d16d964991b3852f.jpg" alt="image"></div><br>  J'ai une branche pbrt, que j'utilise pour tester de nouvelles id√©es, mettre en ≈ìuvre des id√©es int√©ressantes √† partir d'articles scientifiques, et en g√©n√©ral pour √©tudier tout ce qui aboutit g√©n√©ralement √† une nouvelle √©dition du livre sur le <em>rendu physique</em> .  Contrairement √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pbrt-v3</a> , que nous nous effor√ßons de garder le plus pr√®s possible du syst√®me d√©crit dans le livre, dans ce fil, nous pouvons tout changer.  Aujourd'hui, nous verrons comment des changements plus radicaux dans le syst√®me r√©duiront consid√©rablement l'utilisation de la m√©moire dans la sc√®ne avec l'√Æle du dessin anim√© Disney <em>"Moana"</em> . <br><br>  Note sur la m√©thodologie: dans les trois posts pr√©c√©dents, toutes les statistiques ont √©t√© mesur√©es pour la version WIP (Work In Progress) de la sc√®ne avec laquelle je travaillais avant sa sortie.  Dans cet article, nous allons passer √† la version finale, qui est un peu plus compliqu√©e. <br><br>  Lors du rendu de la derni√®re sc√®ne d'√Ælot de <em>Moana</em> , 81 Go de RAM ont √©t√© utilis√©s pour stocker la description de la sc√®ne pour pbrt-v3.  Actuellement, pbrt-next utilise 41 Go, soit environ la moiti√©.  Pour obtenir ce r√©sultat, il suffisait de faire de petites modifications qui s'√©talaient sur plusieurs centaines de lignes de code. <br><a name="habracut"></a><br><h2>  Primitives r√©duites </h2><br>  Rappelons que dans pbrt <code>Primitive</code> est une combinaison de g√©om√©trie, de son mat√©riau, de la fonction de rayonnement (s'il s'agit d'une source de lumi√®re) et d'enregistrements sur l'environnement √† l'int√©rieur et √† l'ext√©rieur de la surface.  Dans pbrt-v3, <code>GeometricPrimitive</code> stocke les √©l√©ments suivants: <br><br><pre> <code class="cpp hljs"> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Shape&gt; shape; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Material&gt; material; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;AreaLight&gt; areaLight; MediumInterface mediumInterface;</code> </pre> <br>  Comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">indiqu√© pr√©c√©demment</a> , la plupart de la zone de temps <code>areaLight</code> est <code>nullptr</code> , et le <code>MediumInterface</code> contient une paire de <code>nullptr</code> .  Donc, dans pbrt-next, j'ai ajout√© une option <code>Primitive</code> appel√©e <code>SimplePrimitive</code> , qui ne stocke que des pointeurs sur la g√©om√©trie et le mat√©riau.  Dans la mesure du possible, il est utilis√© <code>GeometricPrimitive</code> possible au lieu de <code>GeometricPrimitive</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimplePrimitive</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Primitive { <span class="hljs-comment"><span class="hljs-comment">// ... std::shared_ptr&lt;Shape&gt; shape; std::shared_ptr&lt;Material&gt; material; };</span></span></code> </pre> <br>  Pour les instances d'objets non anim√©s, nous avons maintenant <code>TransformedPrimitive</code> , qui ne stocke qu'un pointeur sur la primitive et la transformation, ce qui nous fait √©conomiser environ 500 octets d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">espace gaspill√©</a> que l'instance <code>AnimatedTransform</code> ajout√© au moteur de rendu <code>TransformedPrimitive</code> pbrt-v3. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TransformedPrimitive</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Primitive { <span class="hljs-comment"><span class="hljs-comment">// ... std::shared_ptr&lt;Primitive&gt; primitive; std::shared_ptr&lt;Transform&gt; PrimitiveToWorld; };</span></span></code> </pre> <br>  (Il y a <code>AnimatedPrimitive</code> au cas o√π vous auriez besoin d'une conversion anim√©e en pbrt-next.) <br><br>  Apr√®s toutes ces modifications, les statistiques indiquent que seulement 7,8 Go sont utilis√©s sous <code>Primitive</code> , au lieu de 28,9 Go dans pbrt-v3.  Bien que nous ayons √©conomis√© 21 Go, ce n'est pas autant que la diminution que nous pourrions attendre des estimations pr√©c√©dentes;  nous reviendrons sur cet √©cart √† la fin de cette partie. <br><br><h2>  G√©om√©trie r√©duite </h2><br>  De plus, pbrt-next a consid√©rablement r√©duit la quantit√© de m√©moire occup√©e par la g√©om√©trie: l'espace utilis√© pour les triangles maill√©s est pass√© de 19,4 Go √† 9,9 Go, et l'espace de stockage pour les courbes de 1,4 √† 1,1 Go.  Un peu plus de la moiti√© de ces √©conomies proviennent de la simplification de la classe <code>Shape</code> base. <br><br>  Dans pbrt-v3, <code>Shape</code> apporte plusieurs membres qui se r√©percutent dans toutes les impl√©mentations <code>Shape</code> - ce sont plusieurs aspects auxquels il est facile d'acc√©der dans les impl√©mentations <code>Shape</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Shape</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// .... const Transform *ObjectToWorld, *WorldToObject; const bool reverseOrientation; const bool transformSwapsHandedness; };</span></span></code> </pre> <br>  Pour comprendre pourquoi ces variables membres posent des probl√®mes, il sera utile de comprendre comment les maillages triangulaires sont repr√©sent√©s dans pbrt.  Tout d'abord, il y a la classe <code>TriangleMesh</code> , qui stocke les sommets et les tampons d'index pour le maillage entier: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TriangleMesh</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nTriangles, nVertices; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; vertexIndices; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Point3f[]&gt; p; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Normal3f[]&gt; n; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br>  Chaque triangle du maillage est repr√©sent√© par la classe <code>Triangle</code> , qui h√©rite de <code>Shape</code> .  L'id√©e est de garder le <code>Triangle</code> plus petit possible: ils ne stockent qu'un pointeur sur le maillage dont ils font partie, et un pointeur sur l'offset dans le tampon d'index auquel commencent les indices de ses sommets: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Triangle</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Shape { <span class="hljs-comment"><span class="hljs-comment">// ... std::shared_ptr&lt;TriangleMesh&gt; mesh; const int *v; };</span></span></code> </pre> <br>  Lorsque les impl√©mentations <code>Triangle</code> doivent trouver les positions de leurs sommets, il effectue l'indexation correspondante pour les obtenir de <code>TriangleMesh</code> . <br><br>  Le probl√®me avec <code>Shape</code> pbrt-v3 est que les valeurs qui y sont stock√©es sont les m√™mes pour tous les triangles du maillage, il est donc pr√©f√©rable de les enregistrer de chaque maillage entier dans <code>TriangleMesh</code> , puis de donner √† <code>Triangle</code> acc√®s √† une seule copie des valeurs communes. <br><br>  Ce probl√®me a √©t√© corrig√© dans pbrt-next: la classe <code>Shape</code> base dans pbrt-next ne contient pas de tels membres, et donc chaque <code>Triangle</code> est de 24 octets de moins.  La <code>Curve</code> g√©om√©trie utilise une strat√©gie similaire et b√©n√©ficie √©galement d'une forme plus compacte. <br><br><h2>  Tampons triangulaires partag√©s </h2><br>  Malgr√© le fait que la sc√®ne de l'√Æle de <em>Moana utilise</em> largement l'instanciation d'objets pour r√©p√©ter explicitement la g√©om√©trie, j'√©tais curieux de savoir √† quelle fr√©quence la r√©utilisation des tampons d'index, des tampons de coordonn√©es de texture, etc. est utilis√©e pour diverses mailles de triangle. <br><br>  J'ai √©crit une petite classe qui hache ces tampons √† la r√©ception et les stocke dans le cache, et j'ai modifi√© <code>TriangleMesh</code> pour qu'il v√©rifie le cache et utilise la version d√©j√† enregistr√©e de tout tampon redondant dont il a besoin.  Le gain √©tait tr√®s bon: j'ai r√©ussi √† me d√©barrasser de 4,7 Go de volume exc√©dentaire, ce qui est bien plus que ce √† quoi je m'attendais. <br><br><h2>  Crash avec std :: shared_ptr </h2><br>  Apr√®s toutes ces modifications, les statistiques rapportent environ 36 Go de m√©moire allou√©e connue, et au d√©but du rendu, <code>top</code> indique l'utilisation de 53 Go.  Affaires. <br><br>  J'avais peur d'une autre s√©rie de descentes lentes du <code>massif</code> pour savoir quelle m√©moire allou√©e manquait dans les statistiques, mais une lettre d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Arseny Kapulkin</a> est apparue dans ma bo√Æte de r√©ception.  Arseny m'a expliqu√© que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mes estimations pr√©c√©dentes</a> de l'utilisation de la m√©moire <code>GeometricPrimitive</code> √©taient tr√®s fausses.  J'ai d√ª le comprendre pendant longtemps, mais j'ai ensuite r√©alis√©;  un grand merci √† Arseny pour avoir signal√© l'erreur et les explications d√©taill√©es. <br><br>  Avant d'√©crire √† Arseny, j'ai imagin√© l'impl√©mentation de <code>std::shared_ptr</code> comme suit: dans ces lignes, il y a un descripteur commun qui stocke le nombre de r√©f√©rences et un pointeur sur l'objet plac√© lui-m√™me: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shared_ptr_info</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; refCount; T *ptr; };</code> </pre> <br>  Ensuite, j'ai sugg√©r√© que l'instance <code>shared_ptr</code> pointe simplement vers elle et l'utilise: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shared_ptr</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... T *operator-&gt;() { return info-&gt;ptr; } shared_ptr_info&lt;T&gt; *info; };</span></span></code> </pre> <br>  En bref, j'ai suppos√© que <code>sizeof(shared_ptr&lt;&gt;)</code> est identique √† la taille du pointeur et que 16 octets d'espace suppl√©mentaire sont gaspill√©s sur chaque pointeur partag√©. <br><br>  Mais ce n'est pas le cas. <br><br>  Dans mon impl√©mentation syst√®me, le descripteur commun est de 32 octets de taille et 16 octets de <code>sizeof(shared_ptr&lt;&gt;)</code> .  Par cons√©quent, <code>GeometricPrimitive</code> , qui se compose principalement de <code>std::shared_ptr</code> , est environ deux fois plus grand que mes estimations.  Si vous vous demandez pourquoi cela s'est produit, ces deux messages Stack Overflow expliquent les raisons en d√©tail: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2</a> . <br><br>  Dans presque tous les cas d'utilisation de <code>std::shared_ptr</code> dans pbrt-next, il n'est pas n√©cessaire qu'ils soient des pointeurs partag√©s.  En faisant un piratage fou, j'ai remplac√© tout ce que je pouvais par <code>std::unique_ptr</code> , qui a en fait la m√™me taille qu'un pointeur normal.  Par exemple, voici √† quoi ressemble <code>SimplePrimitive</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimplePrimitive</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Primitive { <span class="hljs-comment"><span class="hljs-comment">// ... std::unique_ptr&lt;Shape&gt; shape; const Material *material; };</span></span></code> </pre> <br>  La r√©compense s'est av√©r√©e plus importante que ce √† quoi je m'attendais: l'utilisation de la m√©moire au d√©but du rendu est pass√©e de 53 Go √† 41 Go - une √©conomie de 12 Go, compl√®tement inattendue il y a quelques jours, et le montant total est presque la moiti√© de celui utilis√© par pbrt-v3.  Super! <br><br>  Dans la partie suivante, nous terminerons enfin cette s√©rie d'articles - examinons la vitesse de rendu dans pbrt-next et discutons d'id√©es d'autres fa√ßons de r√©duire la quantit√© de m√©moire n√©cessaire pour cette sc√®ne. <br><br><h2>  Partie 5 </h2><br>  Pour r√©sumer cette s√©rie d'articles, nous commencerons par explorer la vitesse de rendu de la sc√®ne insulaire du dessin anim√© Disney <em>"Moana"</em> dans pbrt-next - la branche pbrt que j'utilise pour tester de nouvelles id√©es.  Nous effectuerons des changements plus radicaux que ce qui est possible dans pbrt-v3, qui devrait adh√©rer au syst√®me d√©crit dans notre livre.  Nous concluons par une discussion sur les domaines √† am√©liorer, du plus simple au l√©g√®rement extr√™me. <br><br><h2>  Temps de rendu </h2><br>  Pbrt-next a apport√© de nombreuses modifications aux algorithmes de transfert de lumi√®re, y compris des modifications √† l'√©chantillonnage BSDF et des am√©liorations aux algorithmes de roulette russe.  Par cons√©quent, il trace plus de rayons que pbrt-v3 pour rendre cette sc√®ne, il n'est donc pas possible de comparer directement le temps d'ex√©cution de ces deux moteurs de rendu.  La vitesse est g√©n√©ralement proche, √† une exception importante pr√®s: lors du rendu d'une sc√®ne d'√Ælot √† partir de <em>Moana</em> , illustr√© ci-dessous, pbrt-v3 passe 14,5% du temps d'ex√©cution √† rechercher des textures <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ptex</a> .  Cela me paraissait tout √† fait normal, mais pbrt-next ne passe que 2,2% du temps d'ex√©cution.  Tout cela est terriblement int√©ressant. <br><br>  Apr√®s avoir √©tudi√© les statistiques, nous obtenons <sup>1</sup> : <br><br> <code>pbrt-v3: <br>   Ptex 20828624 <br>  Ptex 712324767 <br> <br> pbrt-next: <br>   Ptex 3378524 <br>  Ptex 825826507</code> <br> <br>  Comme nous le voyons dans pbrt-v3, la texture ptex est lue sur le disque en moyenne toutes les 34 recherches de texture.  Dans pbrt-next, il n'est lu qu'apr√®s 244 recherches, c'est-√†-dire que les E / S disque ont diminu√© d'environ 7 fois.  J'ai sugg√©r√© que cela se produise parce que pbrt-next calcule les diff√©rences de rayons pour les rayons indirects, ce qui conduit √† acc√©der √† des niveaux de textures MIP plus √©lev√©s, ce qui cr√©e √† son tour une s√©rie d'acc√®s plus int√©gr√©e au cache de texture ptex, r√©duit le nombre d'√©checs de cache, et donc le nombre d'op√©rations d'E / S <sup>2</sup> .  Une br√®ve v√©rification a confirm√© ma supposition: lorsque la diff√©rence de faisceau a √©t√© d√©sactiv√©e, la vitesse ptex est devenue bien pire. <br><br>  L'augmentation de la vitesse ptex n'a pas seulement affect√© le co√ªt de l'informatique et des E / S.  Dans un syst√®me √† 32 CPU, pbrt-v3 n'a acc√©l√©r√© que 14,9 fois apr√®s avoir analys√© la description de la sc√®ne.  pbrt montre g√©n√©ralement une mise √† l'√©chelle parall√®le proche du lin√©aire, donc cela m'a plut√¥t d√©√ßu.  En raison du nombre beaucoup plus faible de conflits pendant les verrous dans ptex, la version pbrt-next √©tait 29,2 fois plus rapide dans un syst√®me √† 32 processeurs et 94,9 fois plus rapide dans un syst√®me √† 96 processeurs - nous revenons aux indicateurs qui nous conviennent. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fe/8a1/30a/6fe8a130ad8c4f43d16d964991b3852f.jpg"></div><br>  <i>Racines de la sc√®ne de l'√Æle Moana rendues par pbrt avec une r√©solution de 2048x858 √† 256 √©chantillons par pixel.</i>  <i>Le temps de rendu total sur une instance de Google Compute Engine avec 96 CPU virtuels avec une fr√©quence de 2 GHz en pbrt-next est de 41 min 22 s.</i>  <i>L'acc√©l√©ration due au mulithreading pendant le rendu √©tait 94,9 fois.</i>  <i>(Je ne comprends pas tr√®s bien ce qui se passe avec le mappage de relief.)</i> <br><br><h2>  Travailler pour l'avenir </h2><br>  Diminuer la quantit√© de m√©moire utilis√©e dans des sc√®nes aussi complexes est une exp√©rience passionnante: √©conomiser quelques gigaoctets avec un petit changement est beaucoup plus agr√©able que des dizaines de m√©gaoctets enregistr√©s dans une sc√®ne plus simple.  J'ai une bonne liste de ce que j'esp√®re apprendre √† l'avenir, si le temps le permet.  Voici un bref aper√ßu. <br><br><h3>  M√©moire tampon triangle encore d√©croissante </h3><br>  M√™me avec l'utilisation r√©p√©t√©e de tampons qui stockent les m√™mes valeurs pour plusieurs maillages triangulaires, une grande quantit√© de m√©moire est toujours utilis√©e sous les tampons triangulaires.  Voici une ventilation de l'utilisation de la m√©moire pour diff√©rents types de tampons triangulaires dans la sc√®ne: <br><br><table><thead><tr><th>  Tapez </th><th>  La m√©moire </th></tr></thead><tbody><tr><td>  √âl√©ments de campagne </td><td>  2,5 Go </td></tr><tr><td>  Normal </td><td>  2,5 Go </td></tr><tr><td>  UV </td><td>  98 Mo </td></tr><tr><td>  Indices </td><td>  252 Mo </td></tr></tbody></table><br>  Je comprends que rien ne peut √™tre fait avec les positions des sommets transmises, mais pour d'autres donn√©es, il y a des √©conomies.  Il existe de nombreux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">types de repr√©sentations de vecteurs normaux sous une forme √©conome en m√©moire</a> qui offre divers compromis entre la taille de la m√©moire et le nombre de calculs.  L'utilisation de l'une des repr√©sentations 24 bits ou 32 bits r√©duira l'espace occup√© par les normales √† 663 Mo et 864 Mo, ce qui nous fera √©conomiser plus de 1,5 Go de RAM. <br><br>  Dans cette sc√®ne, la quantit√© de m√©moire utilis√©e pour stocker les coordonn√©es de texture et les tampons d'index est √©tonnamment petite.  Je suppose que cela s'est produit en raison de la pr√©sence de nombreuses plantes g√©n√©r√©es de mani√®re proc√©durale dans la sc√®ne et parce que toutes les variations du m√™me type de plante ont la m√™me topologie (et donc le tampon d'index) avec param√©trage (et donc coordonn√©es UV).  √Ä son tour, la r√©utilisation des tampons correspondants est assez efficace. <br><br>  Pour d'autres sc√®nes, l'√©chantillonnage des coordonn√©es UV 16 bits des textures ou l'utilisation de valeurs flottantes √† demi-pr√©cision, selon leur plage de valeurs, peut √™tre tout √† fait appropri√©.  Il semble que dans cette sc√®ne, toutes les valeurs de coordonn√©es de texture soient nulles ou √©gales √† un, ce qui signifie qu'elles peuvent √™tre repr√©sent√©es par un <em>bit</em> - c'est-√†-dire qu'il est possible de r√©duire la m√©moire occup√©e de 32 fois.  Cet √©tat de fait est probablement d√ª √† l'utilisation du format ptex pour la texturation, ce qui √©limine le besoin d'atlas UV.  Compte tenu de la faible quantit√© actuellement occup√©e par les coordonn√©es de texture, la mise en ≈ìuvre de cette optimisation n'est pas particuli√®rement n√©cessaire. <br><br>  pbrt utilise toujours des entiers 32 bits pour les tampons d'index.  Pour les petites mailles de moins de 256 sommets, seuls 8 bits par index sont suffisants, et pour les mailles de moins de 65 536 sommets, 16 bits peuvent √™tre utilis√©s.  Changer pbrt pour l'adapter √† ce format ne sera pas tr√®s difficile.  Si nous voulions optimiser au maximum, nous pourrions s√©lectionner exactement autant de bits que n√©cessaire pour repr√©senter la plage requise dans les indices, tandis que le prix serait d'augmenter la complexit√© de trouver leurs valeurs.  Malgr√© le fait que maintenant seulement un quart de gigaoctet de m√©moire est utilis√© pour les indices de vertex, cette t√¢che ne semble pas tr√®s int√©ressante par rapport aux autres. <br><br><h3>  Utilisation maximale de la m√©moire de g√©n√©ration BVH </h3><br>  Plus t√¥t, nous n'avons pas encore discut√© d'un autre d√©tail de l'utilisation de la m√©moire: juste avant le rendu, un pic √† court terme de 10 Go de m√©moire suppl√©mentaire est utilis√©.  Cela se produit lorsque le (grand) BVH de la sc√®ne enti√®re est construit.  Le code de construction du BVH du rendu pbrt est √©crit pour √™tre ex√©cut√© en deux phases: tout d'abord, il cr√©e un BVH avec la <a href="">repr√©sentation traditionnelle</a> : deux pointeurs enfants vers chaque n≈ìud.  Apr√®s avoir construit l'arbre, il est converti en <a href="">un sch√©ma efficace en m√©moire</a> dans lequel le premier enfant du n≈ìud est situ√© directement derri√®re lui dans la m√©moire, et le d√©calage par rapport au deuxi√®me enfant est stock√© sous forme d'entier. <br><br>  Une telle s√©paration √©tait n√©cessaire du point de vue de l'enseignement aux √©tudiants - il √©tait beaucoup plus facile de comprendre les algorithmes pour construire BVH sans chaos associ√© √† la n√©cessit√© de convertir l'arbre en une forme compacte pendant le processus de construction.  Cependant, le r√©sultat est ce pic d'utilisation de la m√©moire;  compte tenu de son influence sur la sc√®ne, l'√©limination de ce probl√®me semble s√©duisante. <br><br><h3>  Convertir des pointeurs en entiers </h3><br>  Dans diverses structures de donn√©es, il existe de nombreux pointeurs 64 bits qui peuvent √™tre repr√©sent√©s comme des entiers 32 bits.  Par exemple, chaque <code>SimplePrimitive</code> contient un pointeur sur un <code>Material</code> .  La plupart des exemples de <code>Material</code> sont communs √† de nombreuses primitives de la sc√®ne et il n'y en a jamais plus de quelques milliers;  par cons√©quent, nous pouvons stocker un seul vecteur <code>vector</code> global <code>vector</code> tous les mat√©riaux: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Material *&gt; allMaterials;</code> </pre> <br>  et il suffit de stocker des d√©calages entiers 32 bits pour ce vecteur dans <code>SimplePrimitive</code> , ce qui nous fait gagner 4 octets.  La m√™me astuce peut √™tre utilis√©e avec un pointeur sur le <code>TriangleMesh</code> dans chaque <code>Triangle</code> , ainsi que dans de nombreux autres endroits. <br><br>  Apr√®s un tel changement, il y aura une l√©g√®re redondance dans l'acc√®s aux panneaux eux-m√™mes, et le syst√®me deviendra un peu moins compr√©hensible pour les √©tudiants essayant de comprendre son travail;  en outre, c'est probablement le cas lorsque, dans le contexte de pbrt, il vaut mieux garder l'impl√©mentation un peu plus compr√©hensible, mais au prix d'une optimisation incompl√®te de l'utilisation de la m√©moire. <br><br><h3>  H√©bergement bas√© sur les ar√®nes (zones) </h3><br>  Pour chaque <code>Triangle</code> et primitive individuels, un appel distinct est effectu√© vers <code>new</code> (en fait <code>make_unique</code> , mais c'est la m√™me chose).  De telles allocations de m√©moire conduisent √† l'utilisation de la comptabilit√© des ressources suppl√©mentaires, occupant environ cinq gigaoctets de m√©moire, non comptabilis√©s dans les statistiques.  √âtant donn√© que la dur√©e de vie de tous ces emplacements est la m√™me - jusqu'√† ce que le rendu soit termin√© - nous pouvons nous d√©barrasser de cette comptabilit√© suppl√©mentaire en les s√©lectionnant dans l' <a href="">ar√®ne m√©moire</a> . <br><br><h3>  Kaki vtable </h3><br>  Ma derni√®re id√©e est terrible, et je m'en excuse, mais elle m'a intrigu√©. <br><br>  Chaque triangle de la sc√®ne a une charge suppl√©mentaire d'au moins deux pointeurs vtable: un pour <code>Triangle</code> et un autre pour <code>SimplePrimitive</code> .  C'est 16 octets.  La sc√®ne de l'√Æle de <em>Moana</em> compte au total 146 162 124 triangles uniques, ce qui ajoute pr√®s de 2,2 Go de pointeurs vtables redondants. <br><br>  Et si nous n'avions pas de classe de base abstraite pour <code>Shape</code> et que chaque impl√©mentation de g√©om√©trie n'h√©ritait de rien?  Cela nous permettrait d'√©conomiser de l'espace sur des pointeurs vtables, mais, bien s√ªr, lors du passage d'un pointeur vers une g√©om√©trie, nous ne saurions pas de quel type de g√©om√©trie il s'agit, c'est-√†-dire qu'il serait inutile. <br><br>  Il s'av√®re que sur les processeurs x86 modernes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">, seuls 48 bits de pointeurs 64 bits</a> sont r√©ellement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">utilis√©s</a> .  Par cons√©quent, il y a 16 bits suppl√©mentaires que nous pouvons emprunter pour stocker des informations ... par exemple, comme la g√©om√©trie vers laquelle nous pointons.  √Ä son tour, en ajoutant un peu de travail, nous pouvons revenir √† la possibilit√© de cr√©er un analogue d'appels √† des fonctions virtuelles. <br><br>  Voici comment cela se produira: nous d√©finissons d'abord une structure <code>ShapeMethods</code> qui contient des pointeurs vers des fonctions, comme <sup>3</sup> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShapeMethods</span></span></span><span class="hljs-class"> {</span></span> Bounds3f (*WorldBound)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *); <span class="hljs-comment"><span class="hljs-comment">// Intersect, etc. ... };</span></span></code> </pre> <br>  Chaque impl√©mentation de g√©om√©trie impl√©mentera une fonction de contrainte, une fonction d'intersection, etc., recevant un analogue du pointeur <code>this</code> comme premier argument: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Bounds3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangleWorldBound</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//       Triangle. Triangle *tri = (Triangle *)t; // ...</span></span></code> </pre> <br>  Nous aurions une table globale des structures <code>ShapeMethods</code> dans laquelle le <em>ni√®me</em> √©l√©ment serait pour un type de g√©om√©trie d'index <em>n</em> : <br><br><pre> <code class="cpp hljs">ShapeMethods shapeMethods[] = { { TriangleWorldBound, <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> }, { CurveWorldBound, <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br>  Lors de la cr√©ation de la g√©om√©trie, nous encodons son type dans certains des bits inutilis√©s du pointeur de retour.  Ensuite, en tenant compte du pointeur sur la g√©om√©trie dont nous voulons effectuer l'appel sp√©cifique, nous extrayions ce type d'index du pointeur et l' <code>shapeMethods</code> comme index dans <code>shapeMethods</code> pour trouver le pointeur de fonction correspondant.  Essentiellement, nous impl√©menterions vtable manuellement, en traitant nous-m√™mes la r√©partition.  Si nous faisions cela √† la fois pour la g√©om√©trie et pour les primitives, alors nous √©conomiserions 16 octets par <code>Triangle</code> , mais en m√™me temps, nous avons fait un chemin assez difficile. <br><br>  Je suppose qu'un tel hack pour impl√©menter la gestion des fonctions virtuelles n'est pas nouveau, mais je n'ai pas pu trouver de liens vers celui-ci sur Internet.  Voici la page Wikipedia sur les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pointeurs marqu√©s</a> , mais elle examine des choses comme le nombre de liens.  Si vous connaissez un meilleur lien, envoyez-moi une lettre. <br><br>  En partageant ce hack maladroit, je peux terminer la s√©rie de messages.  Encore merci √† Disney d'avoir publi√© cette sc√®ne.  C'√©tait incroyablement amusant de travailler avec;  les engrenages dans ma t√™te continuent de tourner. <br><br><h2>  Remarques </h2><br><ol><li>  Au final, pbrt-next trace plus de rayons dans cette sc√®ne que pbrt-v3, ce qui explique probablement l'augmentation du nombre d'op√©rations de recherche. </li><li>  Les diff√©rences de rayons pour les rayons indirects dans pbrt-next sont calcul√©es en utilisant le m√™me <a href="">hack</a> utilis√© dans l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">extension de cache de texture</a> pour pbrt-v3. ,     ,        . </li><li>   <a href="">Rayshade   </a> .   ,   C    .  Rayshade          . </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr417939/">https://habr.com/ru/post/fr417939/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr417929/index.html">Extrait du livre ¬´Un jour dans la vie du cerveau. Neurobiologie de la conscience de l'aube au cr√©puscule ¬ª</a></li>
<li><a href="../fr417931/index.html">Techniques de r√©tention des joueurs: exemples de jeux de diff√©rents genres</a></li>
<li><a href="../fr417933/index.html">Semaine de la s√©curit√© 27: faux iPhone et prix de la s√©curit√©</a></li>
<li><a href="../fr417935/index.html">M√©mos sur l'intelligence artificielle, l'apprentissage automatique, le deep learning et le Big Data</a></li>
<li><a href="../fr417937/index.html">Est-ce que les gens ¬´en fer¬ª cr√©ent des logiciels?</a></li>
<li><a href="../fr417941/index.html">O√π l'eau dans la bouilloire dispara√Æt-elle?</a></li>
<li><a href="../fr417943/index.html">Sans serveur et React 2: tour de passe-passe et aucune fraude</a></li>
<li><a href="../fr417945/index.html">De quels outils dispose la sonde solaire Parker</a></li>
<li><a href="../fr417947/index.html">Visualisation des donn√©es pour votre projet web</a></li>
<li><a href="../fr417949/index.html">Comment ai-je √©crit la biblioth√®que C ++ 11 standard ou pourquoi boost est si effrayant. Chapitre 4.2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>