<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👧🏻 👨🏿‍🎨 🤲🏻 Guide du débutant pour le développement de serveurs Web avec Node.js 🙅🏿 👨🏾‍🍳 🧑🏽‍🤝‍🧑🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendant la majeure partie de ma carrière Web, j'ai travaillé exclusivement du côté client. Concevoir des mises en page adaptatives, créer des visualis...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Guide du débutant pour le développement de serveurs Web avec Node.js</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435970/">  Pendant la majeure partie de ma carrière Web, j'ai travaillé exclusivement du côté client.  Concevoir des mises en page adaptatives, créer des visualisations à partir de grandes quantités de données, créer des tableaux de bord d'application, etc. Mais je n'ai jamais eu à traiter directement le routage ou les requêtes HTTP.  Jusqu'à récemment. <br><br>  Ce message est une description de la façon dont j'ai appris plus sur le développement Web côté serveur à l'aide de Node.js, et une brève comparaison de l'écriture d'un simple serveur HTTP utilisant 3 environnements différents, Express, Koa.js et Hapi.js. <br><br>  Remarque: si vous êtes un développeur Node.js expérimenté, vous penserez probablement que tout cela est élémentaire / simple.  ¯ \ _ (ツ) _ / ¯. <br><a name="habracut"></a><br>
<h3>  Quelques bases du réseau </h3><br>  Lorsque j'ai commencé à travailler dans l'industrie du Web il y a quelques années, j'ai rencontré un cours sur les réseaux informatiques par le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">professeur David Veteral</a> sur Coursera.  Malheureusement, il n'est plus disponible, mais des conférences sont toujours disponibles sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le site Web de Pearson</a> . <br><br>  J'ai vraiment aimé ce cours car il expliquait ce qui se passait sous le capot d'une manière compréhensible, donc si vous pouvez prendre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le</a> manuel des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">réseaux informatiques</a> , lisez tous les détails sur les merveilles du réseau. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tz/ij/my/tzijmyfk0da6oiy2_qljlgiz7yi.jpeg" alt="image"></div><br>  Ici, cependant, je ne parlerai que brièvement du contexte.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HTTP (Hypertext Transfer Protocol)</a> est un protocole de communication utilisé dans les réseaux informatiques.  Il en existe de nombreux sur Internet, tels que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SMTP (Simple Mail Transfer Protocol)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">FTP (File Transfer Protocol)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">POP3 (Post Office Protocol 3)</a> , etc. <br><br>  Ces protocoles permettent aux appareils dotés d'un matériel / logiciel complètement différent de communiquer entre eux, car ils fournissent des formats de message, des règles, une syntaxe et une sémantique bien définis, etc.  Cela signifie que même si l'appareil prend en charge un protocole spécifique, il peut communiquer avec n'importe quel autre appareil.  sur le net. <br><br><img src="https://habrastorage.org/webt/p6/vd/mw/p6vdmwx1vzpq_bbkzbpqzrepvq8.png" alt="image"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">De TCP / IP vs OSI: quelle est la différence entre les deux modèles?</a> <br><br>  Les systèmes d'exploitation prennent généralement en charge les protocoles réseau, tels que HTTP, prêts à l'emploi, ce qui explique pourquoi nous n'avons pas besoin d'installer explicitement de logiciel supplémentaire pour accéder à Internet.  La plupart des protocoles réseau prennent en charge une connexion ouverte entre deux appareils, ce qui leur permet de transférer des données dans les deux sens. <br><br>  Le HTTP sur lequel le réseau s'exécute est différent.  Il est connu sous le nom de protocole sans connexion car il est basé sur un mode de fonctionnement demande / réponse.  Les navigateurs Web envoient au serveur des demandes d'images, de polices, de contenu, etc., mais une fois la demande terminée, la connexion entre le navigateur et le serveur est déconnectée. <br><br><img src="https://habrastorage.org/webt/go/q5/bg/goq5bgxj17-zzxi4sjdovt1y37m.png" alt="image"><br><br><h3>  Serveurs et clients </h3><br>  Le terme serveur peut être un peu déroutant pour les personnes qui débutent dans l'industrie pour la première fois, car il peut désigner à la fois le matériel (ordinateurs physiques qui hébergent tous les fichiers et logiciels requis par les sites Web) et le logiciel (un programme qui permet aux utilisateurs d'accéder à ces fichiers en ligne). <br><br>  Aujourd'hui, nous allons parler du côté logiciel des choses.  Mais d'abord, quelques définitions.  L'URL signifie Universal Resource Locator et se compose de 3 parties: <b>protocole</b> , <b>serveur</b> et <b>fichier demandé</b> . <br><br><img src="https://habrastorage.org/webt/lj/gd/2f/ljgd2fxjq0rzhabqnqawi5tm4ie.png" alt="image"><br>  Structure d'URL <br><br>  Le protocole HTTP définit plusieurs méthodes que le navigateur peut utiliser pour demander au serveur d'effectuer un tas d'actions différentes, dont les plus courantes sont GET et POST.  Lorsqu'un utilisateur clique sur un lien ou entre une URL dans la barre d'adresse, le navigateur envoie une demande GET au serveur pour récupérer la ressource spécifiée dans l'URL. <br><br>  Le serveur doit savoir comment traiter cette demande HTTP afin de recevoir le fichier correct, puis le renvoyer au navigateur qui l'a demandé.  Le logiciel de serveur Web le plus populaire qui gère cela est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=http://">Apache</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">NGINX</a> . <br><br><img src="https://habrastorage.org/webt/om/tm/0-/omtm0-wfyp4aokdrgre1c9p2mi8.png" alt="image"><br>  <i>Les serveurs Web traitent les demandes entrantes et y répondent en conséquence</i> <br><br>  Les deux sont des progiciels open source complets qui incluent des fonctionnalités telles que les schémas d'authentification, la réécriture d'URL, la journalisation et le proxy, pour n'en nommer que quelques-uns.  Apache et NGINX sont écrits en C. Techniquement, vous pouvez écrire un serveur Web dans n'importe quelle langue.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://docs.python.org/3/library/">Python</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://golang.org/pkg/net/">golang.org/pkg/net/http</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://blog.appsignal.com/2016/11/23/ruby-magic-building-a-30-line-">Ruby</a> , cette liste peut durer un certain temps.  C’est juste que certaines langues font certaines choses mieux que d’autres. <br><br><h3>  Création d'un serveur HTTP avec Node.js </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Node.js</a> est un runtime Javascript construit sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">moteur Javascript Chrome V8</a> .  Il est livré avec le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://nodejs.org/api/">module http</a> , qui fournit un ensemble de fonctions et de classes pour la construction d'un serveur HTTP. <br><br>  Pour ce serveur HTTP de base, nous utiliserons également le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">système de fichiers</a> , le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">chemin</a> et l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">URL</a> , qui sont des modules natifs Node.js. <br><br>  Commencez par importer les modules requis. <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> http = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'http'</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   HTTP-  Node.js const fs = require('fs') //      const path = require('path') //        const url = require('url') //     URL</span></span></code> </pre> <br>  Nous allons également créer un dictionnaire de types MIME afin de pouvoir attribuer le type MIME approprié à la ressource demandée en fonction de son extension.  Une liste complète des types MIME se trouve dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Internet Assigned Numbers Authority</a> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mimeTypes = { <span class="hljs-string"><span class="hljs-string">'.html'</span></span>: <span class="hljs-string"><span class="hljs-string">'text/html'</span></span>, <span class="hljs-string"><span class="hljs-string">'.js'</span></span>: <span class="hljs-string"><span class="hljs-string">'text/javascript'</span></span>, <span class="hljs-string"><span class="hljs-string">'.css'</span></span>: <span class="hljs-string"><span class="hljs-string">'text/css'</span></span>, <span class="hljs-string"><span class="hljs-string">'.ico'</span></span>: <span class="hljs-string"><span class="hljs-string">'image/x-icon'</span></span>, <span class="hljs-string"><span class="hljs-string">'.png'</span></span>: <span class="hljs-string"><span class="hljs-string">'image/png'</span></span>, <span class="hljs-string"><span class="hljs-string">'.jpg'</span></span>: <span class="hljs-string"><span class="hljs-string">'image/jpeg'</span></span>, <span class="hljs-string"><span class="hljs-string">'.gif'</span></span>: <span class="hljs-string"><span class="hljs-string">'image/gif'</span></span>, <span class="hljs-string"><span class="hljs-string">'.svg'</span></span>: <span class="hljs-string"><span class="hljs-string">'image/svg+xml'</span></span>, <span class="hljs-string"><span class="hljs-string">'.json'</span></span>: <span class="hljs-string"><span class="hljs-string">'application/json'</span></span>, <span class="hljs-string"><span class="hljs-string">'.woff'</span></span>: <span class="hljs-string"><span class="hljs-string">'font/woff'</span></span>, <span class="hljs-string"><span class="hljs-string">'.woff2'</span></span>: <span class="hljs-string"><span class="hljs-string">'font/woff2'</span></span> }</code> </pre><br>  Nous pouvons maintenant créer un serveur HTTP avec la fonction <code>http.createServer()</code> , qui retournera une nouvelle instance de <code>http.Server</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = http.createServer()</code> </pre> <br>  Nous passerons la fonction de gestionnaire de <code>createServer()</code> à <code>createServer()</code> avec les objets request et response.  Cette fonction est appelée une fois à chaque fois qu'une requête HTTP arrive sur le serveur. <br><br><pre> <code class="javascript hljs">server.on(<span class="hljs-string"><span class="hljs-string">'request'</span></span>, (req, res) =&gt; { <span class="hljs-comment"><span class="hljs-comment">//     })</span></span></code> </pre><br>  Le serveur est démarré en appelant la méthode <code>listen</code> de l'objet <code>server</code> avec le numéro de port sur lequel nous voulons que le serveur écoute, par exemple <code>5000</code> . <br><br><pre> <code class="javascript hljs">server.listen(<span class="hljs-number"><span class="hljs-number">5000</span></span>)</code> </pre> <br>  L'objet de <code>request</code> est une instance de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://nodejs.org/api/http.html&amp;usg=ALkJrhiiapv4_yQNdlT2XzW74IdGip_fmg#http_class_">IncomingMessage</a> et nous permet d'accéder à toutes les informations sur la demande, telles que l'état de la réponse, les en-têtes et les données. <br><br>  L'objet de <code>response</code> est une instance de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://nodejs.org/api/http.html&amp;usg=ALkJrhiiapv4_yQNdlT2XzW74IdGip_fmg#http_class_">ServerResponse</a> , qui est un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">flux inscriptible</a> et fournit de nombreuses méthodes pour renvoyer des données au client. <br><br>  Dans le gestionnaire de requêtes, nous voulons effectuer les opérations suivantes: <br><br><ul><li>  Analyser la demande entrante et la traiter sans extensions <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> parsedUrl = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> URL(req.url, <span class="hljs-string"><span class="hljs-string">'https://node-http.glitch.me/'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pathName = parsedUrl.pathname <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> ext = path.extname(pathName) <span class="hljs-comment"><span class="hljs-comment">//   URL    '/',   '/' //      URL    'Location' if (pathName !== '/' &amp;&amp; pathName[pathName.length - 1] === '/') { res.writeHead(302, {'Location': pathName.slice(0, -1)}) res.end() return } //     ,  index.html //     «.html»       if (pathName === '/') { ext = '.html' pathName = '/index.html' } else if (!ext) { ext = '.html' pathName += ext }</span></span></code> </pre> <br></li><li>  Effectuer quelques vérifications élémentaires pour déterminer si la ressource demandée existe et répondre en conséquence <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     ,       const filePath = path.join(process.cwd(), '/public', pathName) // ,       fs.exists(filePath, function (exists, err) { //     ,  404 Not Found if (!exists || !mimeTypes[ext]) { console.log('  : ' + pathName) res.writeHead(404, {'Content-Type': 'text/plain'}) res.write('404 Not Found') res.end() return } //        200 OK, //       res.writeHead(200, {'Content-Type': mimeTypes[ext]}) //        const fileStream = fs.createReadStream(filePath) fileStream.pipe(res) })</span></span></code> </pre> <br></li></ul><br>  Tout le code est hébergé sur Glitch, et vous pouvez remixer le projet si vous le souhaitez. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://glitch.com/edit/&amp;usg=ALkJrhjO4dYMTpQYqwW4fFPRA0ZKrpUzsQ#!/node-">https://glitch.com/edit/#!/node-http</a> <br><br><h3>  Création d'un serveur HTTP avec des frameworks Node.js </h3><br>  Les frameworks Node.js tels <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">qu'Express</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Koa.js</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Hapi.js</a> sont livrés avec diverses fonctions middleware utiles, en plus de nombreuses autres fonctionnalités pratiques qui évitent aux développeurs d'avoir à écrire pour eux-mêmes. <br><br>  Personnellement, je pense qu'il vaut mieux d'abord apprendre les bases sans framework, juste pour comprendre ce qui se passe sous le capot, puis devenir fou avec n'importe quel framework que vous aimez. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Express</a> a son propre plugin intégré pour servir des fichiers statiques, donc le code requis pour effectuer les mêmes actions que dans son propre Node.js est beaucoup plus court. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> express = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'express'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = express() <span class="hljs-comment"><span class="hljs-comment">//         app.use(express.static('public')) //  index.html,      //     res.sendFile() app.get('/', (req, res) =&gt; { res.sendFile(__dirname + '/public/index.html') }) app.listen(5000)</span></span></code> </pre> <br>  Koa.js n'a pas de plugin similaire à l'intérieur de son noyau, donc tout plugin requis doit être installé séparément.  La dernière version de Koa.js utilise des fonctions asynchrones en faveur des rappels.  Vous pouvez utiliser le plugin <code>koa-static</code> pour servir des fichiers statiques. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> serve = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'koa-static'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> koa = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'koa'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> koa() <span class="hljs-comment"><span class="hljs-comment">//         //   koa-static    index.html    app.use(serve(__dirname + '/public')) app.listen(5000)</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Hapi.js</a> prend en charge la personnalisation et s'articule autour de la personnalisation de l'objet <code>server</code> .  Il utilise des plugins pour étendre des fonctionnalités telles que le routage, l'authentification, etc.  Pour servir des fichiers statiques, nous avons besoin d'un plugin appelé <code>inert</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hapi = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'hapi'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> inert = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'inert'</span></span>) <span class="hljs-comment"><span class="hljs-comment">//        const server = new hapi.Server({ port: 5000, routes: { files: { relativeTo: path.join(__dirname, 'public') } } }) const init = async () =&gt; { // server.register()      await server.register(inert) // inert     //       server.route({ method: 'GET', path: '/{param*}', handler: { directory: { path: '.', redirectToSlash: true, index: true } } }) await server.start() } init()</span></span></code> </pre> <br>  Chacune de ces plateformes a ses avantages et ses inconvénients, et elles seront plus évidentes pour les applications plus grandes, et pas seulement pour servir une seule page HTML.  Le choix de la structure dépendra grandement des exigences réelles du projet sur lequel vous travaillez. <br><br><h3>  Achèvement </h3><br>  Si le côté réseau des choses a toujours été une boîte noire pour vous, j'espère que cet article pourra servir d'introduction utile au protocole qui fournit le réseau.  Je recommande également fortement de lire la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation de l'API Node.js</a> , qui est très bien écrite et très utile pour tout débutant sur Node.js en général. <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HTTP par MDN</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://nodejs.org/en/docs/guides/anatomy-of-an-">Anatomie d'une transaction HTTP</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://medium.com/from-the-scratch/http-server-what-do-you-need-to-know-to-build-a-simple-">Serveur HTTP: tout ce que vous devez savoir pour créer un serveur HTTP simple à partir de zéro</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr435970/">https://habr.com/ru/post/fr435970/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr435958/index.html">Le condensé de matières fraîches du monde du front-end de la dernière semaine n ° 347 (7-13 janvier 2019)</a></li>
<li><a href="../fr435960/index.html">Expérience de pensée: Flutter on Go</a></li>
<li><a href="../fr435962/index.html">25e anniversaire d'Aeron: sensations et impressions de la version mise à jour d'Aeron Remastered</a></li>
<li><a href="../fr435964/index.html">Ethereum prévoit d'être 99% plus économique</a></li>
<li><a href="../fr435968/index.html">Présentation des algorithmes de Deep Machine Learning pour les robots</a></li>
<li><a href="../fr435972/index.html">Présentation de la programmation réactive au printemps</a></li>
<li><a href="../fr435974/index.html">Three.js - faire des contrôles pour l'espace ou le planétarium</a></li>
<li><a href="../fr435976/index.html">WebAssembly en production et le «champ de mines» de la Smart TV: un entretien avec Andrei Nagikh</a></li>
<li><a href="../fr435978/index.html">Solutions de contournement de la protection biométrique</a></li>
<li><a href="../fr435984/index.html">Réseaux de neurones et philosophie du langage</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>