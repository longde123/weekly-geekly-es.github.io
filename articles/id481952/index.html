<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨ğŸ¼â€ğŸš€ ğŸ• ğŸ« Hitachi sekarat, bash, dan techno-necrophilia ğŸ“¯ ğŸ›ŒğŸ¾ ğŸŒ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Perhatian: solusi yang dijelaskan dalam artikel ini tidak profesional, mungkin dibuat berdasarkan kesalahpahaman struktur dan prinsip pengoperasian ha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hitachi sekarat, bash, dan techno-necrophilia</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481952/"><p>  Perhatian: solusi yang dijelaskan dalam artikel ini tidak profesional, mungkin dibuat berdasarkan kesalahpahaman struktur dan prinsip pengoperasian hard drive.  Mengulangi langkah-langkah di atas dapat membahayakan peralatan. </p><br><p>  Baru-baru ini saya menemukan sebuah <a href="https://habr.com/ru/post/443612/">artikel</a> tentang menggunakan HDD lama dengan blok buruk dan berpikir bahwa pengalaman saya mungkin juga menarik bagi seseorang. </p><br><p>  Suatu kali, kenalan meminta saya untuk membantu menangani laptop yang mereka tidak dapat menginstal ulang Windows.  Laptop itu, dilihat dari penampilannya, memiliki kehidupan yang sulit: retakan dalam kasus ini, sudut penyok, rak rusak.  Jelas bahwa masalahnya adalah kerusakan pada hard drive sebagai akibat dari beberapa pukulan, yang juga dikonfirmasi oleh smart: lebih dari 200 operasi sensor G, 500 Count Sektor yang Direalokasi dan masih ada dalam Pending Saat Ini.  Nah, orang-orang, tentu saja, saya menginstal SSD, dan menyalin informasi dari sekrup mereka ke dalam gambar dengan perintah: </p><br><pre><code class="bash hljs">dd <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>=/dev/sdb of=/media/hddimages/ht320.img bs=409600 conv=noerror,notrunc,sync</code> </pre> <br><p><a name="habracut"></a>  Parameter "conv = noerror, notrunc, sync" diperlukan sehingga jika terjadi kesalahan dalam membaca sektor-sektor tertentu, nol ditulis ke alamat-alamat ini dalam file output, dan data ditulis ke tempatnya tanpa bias. </p><br><p>  Itu terjadi ketika membaca dalam blok besar (400kb), disk tidak membaca seluruh blok, dan yang lebih kecil tidak hanya membaca 1 sektor.  Sektor-sektor di sini adalah 4kb, jadi setelah lulus pertama dari dd, jika ada kesalahan membaca, saya mencoba membaca bagian ini lagi di blok 4kb: </p><br><pre> <code class="bash hljs">n=&lt;&gt;;dd <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>=/dev/sdb of=/media/hddimages/ht320.img bs=4096 conv=noerror,notrunc,sync skip=<span class="hljs-variable"><span class="hljs-variable">$n</span></span> seek=<span class="hljs-variable"><span class="hljs-variable">$n</span></span> count=100</code> </pre> <br><p>  Parameter lewati dan cari diperlukan agar membaca dan menulis dimulai dengan indentasi yang sama dari awal disk.  Lekukan itu sendiri diambil dari output dari eksekusi dd pertama, hanya untuk mencocokkan ukuran blok, kalikan jumlahnya dengan 100. </p><br><p>  Kadang-kadang, disk ketika mengakses bad sector menggantung untuk waktu yang lama, begitu banyak sehingga hanya penyambungan kembali ke daya membantu dan sekitar 5 tahun yang lalu kompleks perangkat keras-perangkat lunak dibuat (berbicara dengan keras, bahkan dengan mikrokontroler) untuk pembacaan otomatis hards buruk dengan rekoneksi daya otomatis jika juga kurangnya respons yang panjang.  Itu menarik dan diizinkan, dengan menghubungkan hard dan memasukkan perintah, setelah 10 hari untuk mendapatkan gambar yang paling lengkap.  Tetapi pahlawan eksperimental dari artikel tersebut tidak menggantung ketat, jadi tidak perlu untuk mendapatkan kruk berat yang dijelaskan. </p><br><p>  Jadi, disk itu dianggap, saya memasang semua bagian gambar melalui losetup dengan offset awal partisi dari fdisk, dikalikan dengan ukuran blok logis dalam mbr - 512 byte, saya menyalin semua data kepada orang-orang di SSD baru.  Jika disk tidak dipasang atau banyak file tidak dapat dibaca, saya akan membuka gambar dengan R-Studio dan mengembalikannya, tetapi dari gambar itu sendiri. </p><br><p>  Tetapi yang sulit, meskipun sudah dikalahkan, sangat disayangkan untuk dibuang, jadi saya memutuskan untuk menghidupkannya kembali.  Secara teoritis, pengontrol disk menandai sektor-sektor sebagai rusak dan menugaskan kembali sektor-sektor cadangan ke alamat-alamatnya jika terjadi upaya berulang yang gagal untuk menulis atau kesalahan baca yang tidak dapat dipulihkan (menggunakan ECC). </p><br><p>  Untuk memulai, saya mencoba untuk menghapus disk (dd if = / dev / zero ...) dan membaca setelah itu: kecepatannya juga tidak stabil, disk membeku dan kadang-kadang kesalahan input / output terjadi, tetapi secara cerdas jumlah relocks dan pending bertambah.  Setelah beberapa siklus, smart tidak terlalu banyak berubah, pending tidak pindah, dan hang dengan kesalahan terjadi setiap kali di tempat yang sama atau sangat dekat.  Saya mencoba untuk memformat ulang secara manual dengan perintah "hdparm --make-bad-sector", tetapi ini tidak bekerja pada model ini dan saya sampai pada kesadaran bahwa hanya menghapus-membaca, serta membaca-menulis, tidak akan dapat menampilkan semua area masalah.  Memang, jika bit yang rusak, terlepas dari apa yang mereka coba tulis untuk itu, lebih mungkin dibaca sebagai "1", maka ketika menulis untuk itu, "1", bacaan berikutnya akan terjadi tanpa kesalahan, tetapi ketika menulis pola yang berbeda, itu mungkin terdapat cukup banyak ketidakkonsistenan sehingga ECC gagal dan terjadi kesalahan baca yang tidak dapat diperbaiki, dan setelah beberapa kasus seperti itu, sektor ini menerima status "Buruk".  Omong-omong, nilai yang terekam dapat sangat ditumpangkan pada distribusi bit yang rusak sehingga nilai salah baca akan memuaskan ECC.  Oleh karena itu, untuk memaksimalkan identifikasi semua sektor buruk, Anda perlu membuat pola yang relatif acak, menulisnya ke disk, membaca dan membandingkan nilainya.  Ada juga sektor yang tidak stabil, yang mengubah nilai mereka secara bertahap dari waktu ke waktu atau setelah memproses tetangganya. </p><br><p>  Mengingat semua hal di atas, saya memutuskan untuk menerapkan strategi berikut dalam skrip bash: </p><br><ul><li>  kami menghasilkan pola acak dan mempertimbangkan checksum untuk itu; </li><li>  kami membaca cerdas; </li><li>  tulis disk dalam nol; </li><li>  baca disc; </li><li>  kami menulis disk dalam pola acak dengan membaca blok yang baru direkam dan membandingkan jumlah ceknya; </li><li>  kami membaca disk setelah rekaman penuh, memeriksa jumlah cek dari setiap blok; </li><li>  kami membaca cerdas; </li><li>  swa-uji; </li><li>  kebagian 1. </li></ul><br><p>  Kami melanjutkan cara ini sampai sektor yang salah membaca dan kesalahan IO berhenti terjadi atau sampai sekrup benar-benar tertutup.  Ngomong-ngomong, bagaimana tes mandiri bekerja untuk model disk ini, saya tidak bisa membayangkan;  Saya tidak tahu berapa lama berbeda dari short'a (meskipun mungkin lama bekerja dengan seluruh permukaan, dan pendek - berfokus pada statistik yang dikumpulkan sebelumnya, seperti dengan format: penuh dan cepat).  Saya harap ini mendorong sekrup untuk memperhitungkan pengalaman terkini dan memetakan kembali sektor-sektor buruk. </p><br><p>  Ketika saya selesai menulis skrip bash, saya menjalankannya dan memeriksa hasilnya pada hari berikutnya - saya melihat verifikasi sangat lambat, sementara beban prosesor tidak mencapai 60% pada inti apa pun.  Ini membuat saya bermain dengan ukuran blok, menguji berbagai algoritma hash untuk checksum, mencoba verifikasi langsung berbeda, dan tidak membandingkan checksum, tetapi saya tidak bisa mencapai kecepatan pemrosesan di atas 12 megabyte per detik.  Akibatnya, saya berhenti membandingkan blok 400kb dengan diff, dan saya menghitung checksum hanya jika ada ketidakcocokan hanya untuk analisis log selanjutnya. </p><br><div class="spoiler">  <b class="spoiler_title">Scriptnya berubah seperti ini:</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash #    hddtest.sh diskdev logfile [blocksize] diskdev="$1"; test_log="$2"; #"~/work/hdd/test.log" blsz="${409600:-$3}"; n="1"; sizebyte=`fdisk -l "$diskdev"|grep "Disk $diskdev:"|cut -d" " -f5`; let sizebl=$sizebyte/$blsz; #"781428" for 320GB while true;do echo "starting iteration $n"; dd if=/dev/urandom of=fil bs="$blsz" count=1; md5ok=`md5sum fil|cut -d" " -f1`; cp fil fil_"$n"; echo "random pattern md5sum $md5ok"&gt;&gt;"$test_log"; smartctl -A "$diskdev"&gt;&gt;"$test_log"; echo "filling disk with zeroes"&gt;&gt;"$test_log"; dd if=/dev/zero of="$diskdev" bs="$blsz"; #count="$sizebl"; echo "disk is wiped fully"&gt;&gt;"$test_log"; dd of=/dev/null if="$diskdev" bs="$blsz"; # count="$sizebl"; echo "writing disk with fil-pattern"&gt;&gt;"$test_log"; i="0"; while [ "$i" -le "$sizebl" ]; do #echo "writing fil: $i "&gt;&gt;"$test_log"; dd if=fil of="$diskdev" bs="$blsz" seek="$i"; dd if=/dev/null of=tst; dd if="$diskdev" bs="$blsz" of=tst skip="$i" count=1 conv=notrunc,noerror,sync; #md5tst=`md5sum tst|cut -d" " -f1`; verf=`diff -s fil tst|sed 's/.* //g'`; if [ "$verf" != "identical" ]; #if [ "$md5ok" != "$md5tst" ]; then md5tst=`md5sum tst|cut -d" " -f1`; echo "$i : md5 $md5tst is not ok"&gt;&gt;"$test_log"; cp tst tst_"$n"_"$i"; fi; let i="$i"+1; done; echo "test of full writed with fil-pattern disk"&gt;&gt;"$test_log"; i="0"; while [ "$i" -le "$sizebl" ]; do #echo "after writing test: $i"&gt;&gt;"$test_log"; dd if=/dev/null of=tst; dd if="$diskdev" bs="$blsz" of=tst skip="$i" count=1 conv=notrunc,noerror,sync; #md5tst=`md5sum tst|cut -d" " -f1`; verf=`diff -s fil tst|sed 's/.* //g'`; if [ "$verf" != "identical" ]; #if [ "$md5ok" != "$md5tst" ]; then md5tst=`md5sum tst|cut -d" " -f1`; echo "$i : md5 $md5tst is not ok"&gt;&gt;"$test_log"; cp tst tst_"$n"_"$i"; fi; let i="$i"+1; done; smartctl -A "$diskdev" &gt;&gt;"$test_log"; smartctl -t long "$diskdev"&gt;&gt;"$test_log"; sleep 5000; #smartctl -t short "$diskdev"&gt;&gt;"$test_log"; #sleep 240; let n="$n"+1; done</span></span></code> </pre></div></div><br><p>  Seperti yang ditunjukkan oleh log setelah eksekusi berulang kali dari skrip, semua bad sector berada di 13 GB pertama dari disk, ada beberapa "fokus" kekalahan (mungkin, ketika head hit, permukaannya tergores dan tergores).  Untuk 15 menjalankan terakhir, disk belum melihat sektor yang tertunda, semuanya sudah dipetakan kembali, tetapi di suatu tempat di tengah Gigabyte ke-13 satu blok atau blok tidak jauh dari itu dibaca secara tidak benar ke alamat yang berbeda.  Selain itu, satu blok dapat dianggap salah untuk 2 siklus berturut-turut, lalu 2 kali salah dan benar lagi.  Jadi untuk menangkap 10 sektor buruk terakhir adalah operasi yang panjang.  Sebanyak 1.268 sektor remap!  Dan pada akhirnya, saya memiliki kejutan: ketika semuanya sudah bekerja secara stabil, setelah swa uji berikutnya, parameter Count Sektor yang Direalokasi menjadi â€œ0â€ dan hanya Hitungan Acara yang Direalokasi dan catatan dari 5 kesalahan terakhir (dengan alamat dan waktu dari mulai bekerja) disimpan dalam jurnal. </p><br><p>  Meskipun operasi stabil, saya tetap memutuskan untuk meminimalkan interaksi dengan daerah yang rusak agar tidak melukai kepala tentang kemungkinan penyimpangan di tempat-tempat dengan permukaan pelat yang rusak, dan saya tidak ingin mempercayai sektor lokal dalam jangka panjang.  Saya hanya mundur sedikit dengan margin dan membuat partisi yang dimulai dengan Gigabyte ke-15.  Dan, seperti yang diperlihatkan waktu, cakram terasa cukup baik dan telah bekerja dengan stabil di laptop yang dapat dipakai selama 10 bulan. </p><br><p>  Meskipun tidak mungkin untuk sepenuhnya memercayai disk yang dipulihkan dan kelayakan ekonomi dari usaha itu diragukan, kadang-kadang hasilnya hanya merupakan tambahan yang menyenangkan untuk cara yang baik. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id481952/">https://habr.com/ru/post/id481952/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id481942/index.html">Kembali ke masa depan: apa yang disajikan game modern pada tahun 2010</a></li>
<li><a href="../id481944/index.html">Apa yang menentukan posisi situs pada halaman pencarian?</a></li>
<li><a href="../id481946/index.html">Metode Komunikasi dalam Tim Microsoft: Saluran VS Obrolan</a></li>
<li><a href="../id481948/index.html">Bagaimana cara membuat robot virtual?</a></li>
<li><a href="../id481950/index.html">Tutorial: Boot Musim Semi Reaktif</a></li>
<li><a href="../id481954/index.html">Bagaimana dan mengapa saya bisa meretas VR</a></li>
<li><a href="../id481956/index.html">Mencari programmer yang hilang. Pencarian Tahun Baru</a></li>
<li><a href="../id481958/index.html">Kapan Anda menjadi penandatangan di mail.ru atau bagaimana cara menyeberang tank T-34 dengan antarmuka email</a></li>
<li><a href="../id481960/index.html">2. Tumpukan elastis: analisis log keamanan. Logstash</a></li>
<li><a href="../id481964/index.html">Cara mengatur rilis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>