<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📪 🤛🏿 🧖 PIM原则 🤼 🤱🏻 🔀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="PIM协议是一组用于在路由器之间的网络上传输多播的协议。 邻居关系的构建方式与动态路由协议相同。 PIMv2每30秒将Hello消息发送到保留的多播地址224.0.0.13（所有PIM路由器）。 该消息包含保留计时器-通常为3.5 * Hello Timer，默认为105秒。 
  
 PIM使用两...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PIM原则</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450582/"> PIM协议是一组用于在路由器之间的网络上传输多播的协议。 邻居关系的构建方式与动态路由协议相同。  PIMv2每30秒将Hello消息发送到保留的多播地址224.0.0.13（所有PIM路由器）。 该消息包含保留计时器-通常为3.5 * Hello Timer，默认为105秒。 <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/e67/8a0/1fc/e678a01fc7879ecf22bc6f9a3825f9a6.jpg" alt="我的形象"></a> <br>  PIM使用两种主要的操作模式-密集和稀疏模式。 让我们从密集模式开始。 <a name="habracut"></a><br>  <b>基于源的分发树。</b> <br> 建议在各种组播组的客户端数量众多的情况下使用密集模式模式。 路由器收到多播流量时，首先要做的是检查其RPF规则。  RPF-此规则用于检查具有单播路由表的组播源。 根据单播路由表的版本，流量必须到达隐藏该主机的接口。 该机制解决了组播传输过程中出现环路的问题。 <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/6cd/08c/fb6/6cd08cfb6842680447d56860334af52c.png" alt="我的形象"></a> <br> 多播消息中的R3将识别多播的源（源IP），并从其单播表中检查R1和R2的两个流。 表（R1到R3）指示的接口中的流将进一步传输，而R2中的流将被丢弃，因为要到达多播源，必须通过S0 / 1发送数据包。 <br> 问题是，如果具有相同度量的两条等效路由会发生什么？ 在这种情况下，路由器将为这些路由选择下一跳。 谁拥有更高的IP地址，他赢了。 如果需要更改此行为，可以使用ECMP。 更多细节<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里</a> 。 <br> 在检查了RPF规则之后，路由器将一个组播数据包发送到它的所有PIM邻居，但接收该数据包的邻居除外。 其他PIM路由器重复此过程。 多播数据包从源传递到最终收件人的路径形成一棵树，称为-基于源的分发树，最短路径树（SPT），源树。 三种不同的名称，任意选择。 <br> 如何解决问题，因为有些路由器没有放弃某些组播流，并且没有人可以将其发送给更高级别的路由器。 为此，发明了修剪机制。 <br>  <b>修剪消息。</b> <br> 例如，尽管R3根据RPF的规则将其丢弃，但R2将继续发送R3多播。 为什么要加载频道？  R3发送PIM剪枝消息，R2收到此消息后，将从该流的传出接口列表（应从中发送此流量的接口列表）中删除S0 / 1接口。 <br><blockquote> 以下是PIM Prune消息的更正式定义： <br> 一个路由器将PIM Prune消息发送到第二个路由器，以使第二个路由器从特定的（S，G）SPT中删除在其上接收到Prune的链接。 </blockquote><br>  R2收到剪枝消息后，将剪枝定时器设置为3分钟。 三分钟后，它将再次开始发送流量，直到收到下一条Prune消息为止。 这是在PIMv1中。 <br> 并且在PIMv2中添加了状态刷新计时器（默认为60秒）。 一旦从R3发送了修剪消息，此计时器就在R3上启动。 此计时器到期后，R3将发送一个状态刷新消息，此消息会将3分钟的修剪计时器重置为该组的R2。 <br> 发送剪枝消息的原因： <br><ul><li> 当多播数据包未能通过RPF检查时。 </li><li> 没有本地连接的客户端请求多播组（IGMP加入），并且没有可以向其发送多播流量的PIM邻居时（非修剪接口）。 </li></ul><br>  <b>嫁接消息。</b> <br> 想象一下，R3不需要R2的流量，发送Prune并从R1接收多播。 但是突然之间，通道落在R1-R3和R3之间，没有多播。 您可以等待3分钟，直到R2上的Prune Timer过期。  3分钟的等待时间很长，以免等待，您需要发送一条消息，从修剪状态立即在R2上立即显示此接口S0 / 1。 该消息将是嫁接消息。 收到Graft消息后，R2将发送Graft-ACK作为响应。 <br>  <b>修剪优先。</b> <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/bc7/1d0/e9f/bc71d0e9f81b292e75d4a016a9b657ef.png" alt="我的形象"></a> <br> 让我们看看这个方案。  R1在具有两个路由器的网段中广播多播。  R3接收和广播流量，R2接收，但是没有人广播流量。 它将修剪消息发送到此段中的R1。  R1应该从列表中删除Fa0 / 0并在此段中停止广播，但是R3会如何？ 和R3在同一段中，他也从Prune收到了此消息，并意识到了情况的悲剧。 在R1停止广播之前，它将计时器设置为3秒，并在3秒后停止广播。  3秒-R3花费了很多时间，以免丢失多播。 因此，R3尽快为该组发送Pim Join消息，R1不再认为停止广播。 关于下面的加入帖子。 <br>  <b>声明消息。</b> <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/f1d/9d1/d68/f1d9d1d6855fdc188deb28c75bde2d0d.png" alt="我的形象"></a> <br> 想象一下这种情况：两个路由器同时广播到同一网络。 它们从源接收相同的流，并且都将其广播到e0接口后面的相同网络。 因此，他们需要确定谁将是该网络的唯一广播公司。 断言消息用于此目的。 当R2和R3检测到多播流量重复时，即它们自己在R2和R3上广播的多播，而它们自己广播的多播，则路由器会明白这里出了问题。 在这种情况下，路由器发送Assert消息，其中包括管理距离和到达多播源所通过的路由度量-10.1.1.10。 获奖者如下： <br><ol><li>  AD较低的那个。 </li><li> 如果AD相等，则谁具有较低的度量。 </li><li> 如果存在相等性，则将其广播此多播的网络中具有较高IP的那个。 </li></ol><br> 赢得投票，路由器将成为指定路由器。  Pim Hello也用于选择DR。 在本文的开头，显示了PIM Hello消息，您可以在其中看到DR字段。 获胜者是在此链接上具有更高IP地址的那个。 <br> 有用的盘子： <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/3de/e1a/c84/3dee1ac8448b1fceaa9f1972eff802b7.png" alt="我的形象"></a> <br>  <b>MROUTE表。</b> <br> 在初步回顾了PIM协议的操作之后，我们需要弄清楚如何使用多播路由表。  mroute表存储有关客户端请求哪些流以及来自多播服务器的流的信息。 <br> 例如，当在某个接口上收到IGMP成员资格报告或PIM加入时，类型（*，G）的条目将添加到路由表中： <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/afd/3ed/52c/afd3ed52cef0f9f105a0b58dff18edee.jpg" alt="我的形象"></a> <br> 该条目表示已收到地址为238.38.38.38的流量请求。  DC标志表示组播将在密集模式下工作，C标志表示接收者直接连接到路由器，即路由器接收到IGMP成员资格报告和PIM加入。 <br> 如果有类似（S，G）的记录，则表明我们有一个多播流： <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/a78/cf2/332/a78cf23325ddc6e0c3d65322340d7ff6.jpg" alt="我的形象"></a> <br> 在S字段192.168.1.11中，我们已经注册了多播源的IP地址，它将通过RPF规则进行检查。 如果出现问题，首先要做的是检查单播表中到源的路由。 在“传入接口”字段中，指示多播到达的接口。 在单播路由表中，到源的路由必须引用此处指定的接口。 传出接口指示多播将重定向到的位置。 如果为空，则没有向路由器发送此流量的请求。 有关所有标志的更多信息，请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a> 。 <br>  <b>PIM稀疏模式。</b> <br> 稀疏模式策略与密集模式相反。 当稀疏模式接收到多播流量时，它将仅通过存在对此流请求的接口发送流量，例如，请求此流量的Pim Join或IGMP Report消息。 <br>  SM和DM的相似元素： <br><ul><li> 邻居关系的构建方式与PIM DM中的相同。 </li><li>  RPF规则有效。 </li><li>  DR的选择类似。 </li><li>  Prune Overrides引擎和Assert消息相似。 </li></ul><br> 为了控制谁需要网络上的何处，何处以及什么多播流量，需要一个公共信息中心。 这样的中心，我们将有集合点（RP）。 任何需要某种多播流量的人或开始接收来自源的多播流量的人，然后将其发送到RP。 <br> 当RP接收到多播流量时，它将把它发送到先前请求此流量的那些路由器。 <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/025/d45/651/025d4565117dce5f8da07609c823c63e.jpg" alt="我的形象"></a> <br> 想象一下这样的拓扑，其中RP是R3。  R1收到来自S1的流量后，便立即将此组播数据包封装在单播PIM注册消息中，并将其发送给RP。 他怎么知道谁是RP？ 在这种情况下，它是静态配置的，稍后我们将讨论动态RP调整。 <br><blockquote>  ip pim rp地址3.3.3.3 </blockquote><br>  RP会看起来-是否有想要接收此流量的人提供任何信息？ 假设不是。 然后，RP将向R1发送一个PIM Register-Stop消息，这意味着没有人需要该多播，注册被拒绝。  R1将不发送多播。 但是多播源将发送它，因此R1在接收到Register-Stop之后将启动Register-Suppression计时器，该计时器为60秒。 在计时器到期前5秒钟，R1将向RP端发送一个空注册消息，其中包含Null-Register位（即，没有封装的组播数据包）。  RP反过来会像这样： <br><ul><li> 如果没有收件人，则它将以注册停止消息作为响应。 </li><li> 如果收件人出现，那么他将不会以任何方式回答他。  R1在5秒钟内未收到拒绝注册的请求，将感到高兴，并将向RP发送带有封装的多播的注册消息。 </li></ul><br> 当多播到达RP时，似乎已经解决了，现在让我们尝试回答RP如何将流量传递给接收者的问题。 在这里，您需要介绍一个新概念-根路径树（RPT）。  RPT是一棵树，在RP中的根向每个PIM-SM路由器上分支的接收者增长。  RP通过接收PIM Join消息来创建它，并将新分支添加到树中。 每个下游路由器也是如此。 一般规则如下所示： <br><ul><li> 当PIM-SM路由器在任何接口上（隐藏了RP的接口除外）在任何接口上收到PIM Join消息时，都会向树添加新分支。 </li><li> 当PIM-SM路由器从直接连接的主机接收到IGMP成员资格报告时，也会添加一个分支。 </li></ul><br> 想象一下，我们在R5路由器上有一个228.8.8.8组的多播客户端。 一旦R5从主机接收到IGMP成员资格报告，R5就向RP方向发送PIM加入，并且它本身在树中添加了一个查看主机的接口。 接下来，R4从R5接收PIM Join，将Gi0 / 1接口添加到树中，并向RP方向发送PIM Join。 最后，RP（R3）收到一个PIM Join并将Gi0 / 0添加到树中。 因此，获得了多播接收者的注册。 我们正在建立根R3-Gi0 / 0→R4-Gi0 / 1→R5-Gi0 / 0的树。 <br> 之后，PIM Join将发送到R1，R1将开始发送多播流量。 重要的是要注意，如果主机在多播广播开始之前请求了流量，则RP将不会发送PIM Join，也不会向R1端发送任何内容。 <br> 如果在发送多播时突然突然，主机停止想要接收它，一旦RP在Gi0 / 0接口上接收到PIM Prune，则立即将PIM寄存器-停止直接发送到R1，然后通过Gi0 / 1接口发送PIM Prune消息。  PIM寄存器停止通过单播发送到PIM寄存器到达的地址。 <br> 就像我们之前说过的，一旦路由器向另一个路由器（例如R4上的R5）发送PIM Join，则将一个条目添加到R4： <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/9f7/730/678/9f7730678743efb4e9670d18fcd54525.jpg" alt="我的形象"></a> <br> 并且计时器启动以重置该计时器，R5必须不断地PIM Join消息，否则R4将被排除在外发列表中。  R5将每60条PIM加入消息发送一次。 <br>  <b>最短路径树切换。</b> <br> 我们将在R1和R5之间添加一个接口，查看流量如何在此拓扑结构中流动。 <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/afd/113/eb0/afd113eb01e7deda4c389fbb1a02060a.jpg" alt="我的形象"></a> <br> 假设流量是根据旧方案R1-R2-R3-R4-R5发送和接收的，此处我们连接并配置了R1和R5之间的接口。 <br> 首先，我们必须在R5上重建单播路由表，现在可以通过R5 Gi0 / 2接口访问网络192.168.1.0/24。 现在，当R5在Gi0 / 1接口上接收到多播时，他知道RPF规则不满足，因此在Gi0 / 2上接收多播会更合乎逻辑。 它应与RPT断开连接，并构建一个称为“最短路径树（SPT）”的较短树。 为此，他通过Gi0 / 2向R1发送一个PIM Join，并且R1也开始通过Gi0 / 2发送多播。 现在，R5必须取消订阅RPT，以免获得两份副本。 为此，他发送一条Prune消息来指示源的IP地址，并插入一个特殊位-RPT位。 这意味着我不需要发送流量，这里有更好的树。  RP还向R1 PIM剪枝侧发送消息，但不发送Register-Stop消息。 另一个功能：R5现在将不断地将PIM Prune发送到RP，因为R1继续每分钟向RP发送PIM寄存器。  RP，直到有新的人希望这种流量会拒绝他。  R5通知RP它继续通过SPT接收多播。 <br>  <b>动态RP搜索。</b> <b><br></b>  <b>自动RP</b> <br> 该技术是Cisco专有的，并不特别流行，但仍然有效。 自动RP包括两个主要步骤： <br>  1）RP向保留地址224.0.1.39发送RP通告消息，声明自己对所有组或某些组的RP。 此消息每分钟发送一次。 <br>  2）需要一个RP映射代理，该代理将发送RP发现消息，指示哪个RP侦听哪些组。 正是从该消息中，普通的PIM路由器将自行确定RP。 映射代理可以是RP路由器本身，也可以是任何单独的PIM路由器。  RP-Discovery使用一分钟的计时器发送到地址224.0.1.40。 <br> 让我们更详细地看一下该过程： <br> 将R3设置为RP： <br><blockquote>  ip pim send-rp-announce环回0作用域10 </blockquote><br>  R2作为映射代理： <br><blockquote>  ip pim send-rp-discovery回送0范围10 </blockquote><br> 在所有其他方面，我们希望通过自动RP实现RP： <br><blockquote>  ip pim autorp侦听器 </blockquote><br> 一旦我们配置了R3，它将开始发送RP-Announce： <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/aae/ae2/565/aaeae25659fbacd4ba49ae4c5486f46f.jpg" alt="我的形象"></a> <br> 并且R2，在设置映射代理后，将等待RP-Announce消息。 仅当他发现至少一个RP时，他才开始发送RP-Discovery： <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/fb8/e44/7c2/fb8e447c26e33ecda18cb82c5f05c938.jpg" alt="我的形象"></a> <br> 因此，普通路由器（PIM RP侦听器）一收到此消息，便会知道在哪里寻找RP。 <br> 自动RP的主要问题之一是，为了接收RP通告和RP发现消息，您需要将PIM Join发送到地址224.0.1.39-40，并且要发送，您需要知道RP在哪里。 鸡肉和鸡蛋的经典问题。 为了解决这个问题，发明了PIM稀疏密集模式。 如果路由器不知道RP，则以密集模式工作；如果知道，则以稀疏模式工作。 当在普通路由器的接口上配置了PIM稀疏模式和ip pim autorp listener命令时，该路由器将仅在直接直接进行多播的Auto-RP协议（224.0.1.39-40）下工作在密集模式下。 <br>  <b>BootStrap路由器（BSR）。</b> <br> 此功能类似于自动RP。 每个RP发送一个映射代理消息，该消息收集映射信息，然后通知所有其他路由器。 我们对过程的描述类似于自动RP： <br>  1）一旦我们将R3配置为RP的候选者，则命令： <br><blockquote>  ip pim rp-候选人回送0 </blockquote><br>  R3不会做任何事情，为了开始发送特殊消息，他首先需要找到一个映射代理。 因此，我们进入第二步。 <br>  2）将R2配置为映射代理： <br><blockquote>  ip pim bsr-候选人回送0 </blockquote><br>  R2开始发送PIM Bootstrap消息，在该消息中，它指示自己为映射代理： <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/729/3a4/ad1/7293a4ad164ed8342ff42ceffee9a32b.jpg" alt="我的形象"></a> <br> 该消息发送到地址224.0.013，PIM协议将其用于其他消息。 他向各个方向发送它们，因此没有像Auto-RP一样出现鸡肉和鸡蛋的问题。 <br>  3）RP收到路由器BSR的消息后，会立即向路由器BSR的地址发送单播消息： <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/5ed/217/8c1/5ed2178c151886f79c1e6197b9b5385b.jpg" alt="我的形象"></a> <br> 此后，当BSR接收到有关RP的信息时，它将通过多播将其发送到所有PIM路由器都侦听的地址224.0.0.13。 因此，对于BSR中的常规路由器，没有<i>ip pim autorp listener命令的</i>类似物。 <br>  <b>具有组播源发现协议（MSDP）的Anycast RP。</b> <br>  Auto-RP和BSR允许我们按以下方式分配RP上的负载：每个多播组只有一个活动RP。 使一个组播组的负载分配为多个RP无效。  MSDP通过向RP路由器发出相同的IP地址（掩码为255.255.255.255）来实现此目的。  MSDP使用以下方法之一识别信息：静态，自动RP或BSR。 <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/406/51a/032/40651a032dadaaf6e0c51cbf06c3fbf3.png" alt="我的形象"></a> <br> 在图片中，我们具有带有MSDP的自动RP配置。 两个RP在Loopback 1接口上都配置了IP地址172.16.1.1/32，并用于所有组。 当RP公告时，两个路由器都引用此地址谈论自己。 收到信息后，自动RP映射代理将发送有关RP的RP-发现，其地址为172.16.1.1/32。 关于网络172.16.1.1/32，我们分别告诉使用IGP和的路由器。 因此，PIM路由器从到网络172.16.1.1/32的路由上表示为下一跳的RP请求或注册流。  MSDP协议本身是为RP设计的，用于交换多播信息消息。 <br> 考虑以下拓扑： <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/2ba/f2d/dc4/2baf2ddc4deb54ebb671a6fb52282a41.jpg" alt="我的形象"></a> <br>  Switch6将流量广播到地址238.38.38.38，到目前为止，只有RP-R1知道它。  Switch7和Switch8在此请求了该组。 路由器R5和R4将分别向R1和R3发送PIM Join。 怎么了 直到R5上的13.13.13.13为止的路由都将根据IGP度量标准引用R1，与R4相同。 <br>  RP-R1知道该流并开始向R5广播它，但是R4对此一无所知，因为R1不会发送它。 因此，需要MSDP。 我们在R1和R5上进行配置： <br><blockquote>  R1上的ip msdp对等端3.3.3.3 connect-source Loopback1 </blockquote><br><blockquote>  R3上的ip msdp对等1.1.1.1 connect-source Loopback3 </blockquote><br> 他们将在彼此之间发起会话，并且在接收到任何流后将向其RP邻居报告该会话。 <br>  RP-R1收到来自Switch6的流后，将立即向单播MSDP Source-Active发送一条消息，该消息包含诸如（S，G）之类的信息-有关组播源和目的地的信息。 现在，当RP-R3知道诸如Switch6之类的源时，当它从R4收到对此流的请求时，它将在路由表的引导下发送到Switch6 PIM Join。 因此，已收到这种PIM加入的R1将开始向RP-R3发送流量。 <br>  MSDP在TCP上运行，RP相互发送keepalive消息以验证可行性。 计时器为60秒。 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将MSDP对等体划分为不同域的功能仍然难以理解，因为Keepalive和SA消息并不表示属于任何域。</font><font style="vertical-align: inherit;">另外，在此拓扑中，还根据各种域的指示对配置进行了测试-操作上没有差异。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果有人可以澄清，请乐意阅读评论。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关于这一点，我想完成本文。</font><font style="vertical-align: inherit;">以下是使用的有用材料和链接：</font></font><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CCIE路由和交换v5.0官方证书指南，第2卷，第五版，Narbik Kocharians，Terry Vinson。 </font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">网络最小。</font><font style="vertical-align: inherit;">第九部分。</font><font style="vertical-align: inherit;">多播</font></font></a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN450582/">https://habr.com/ru/post/zh-CN450582/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN450568/index.html">每种毒药都有其自己的解毒剂。 如何保存或至少尝试（更新：关于家庭中毒的解毒剂）</a></li>
<li><a href="../zh-CN450572/index.html">Samba DC作为Windows 2012R2 AD域中的第二个控制器以及Windows和Linux上客户端的漫游文件夹</a></li>
<li><a href="../zh-CN450574/index.html">创建一个多人.io网络游戏</a></li>
<li><a href="../zh-CN450576/index.html">Messenger匿名的新规则</a></li>
<li><a href="../zh-CN450578/index.html">广播中听到了什么？ 我们接收并解码最有趣的信号。 第2部分，甚高频</a></li>
<li><a href="../zh-CN450586/index.html">Fish Redux-用于Flutter的新Redux库</a></li>
<li><a href="../zh-CN450592/index.html">在德国，电动汽车的旅行费用可能会比柴油汽车的旅行费用更高</a></li>
<li><a href="../zh-CN450594/index.html">斐波那契偶数</a></li>
<li><a href="../zh-CN450596/index.html">11. Check Point入门R80.20。 威胁预防政策</a></li>
<li><a href="../zh-CN450598/index.html">关于“黄雨”和“橙色剂”</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>