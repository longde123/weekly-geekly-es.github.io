<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🈷️ 📥 😭 Flattern. Schlüssel! Wofür sind sie? 👨🏻‍💼 🧜🏿 ✊🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der key ist in fast jedem Widget-Konstruktor zu finden, wird jedoch in der Entwicklung selten verwendet. Keys behalten den Status bei, wenn Widgets im...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Flattern. Schlüssel! Wofür sind sie?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446050/"><p><img src="https://habrastorage.org/webt/bd/bp/o2/bdbpo2nvc1jntzhrnowfckpywh0.jpeg"></p><br><p> Der <code>key</code> ist in fast jedem Widget-Konstruktor zu finden, wird jedoch in der Entwicklung selten verwendet.  <code>Keys</code> behalten den Status bei, wenn Widgets im Widget-Baum verschoben werden.  In der Praxis bedeutet dies, dass sie nützlich sein können, um den Bildlaufort oder den Speicherstatus des Benutzers zu speichern, wenn sich die Sammlung ändert. </p><br><p>  Dieser Artikel wurde aus dem folgenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Video</a> angepasst.  Wenn Sie lieber hören / sehen als lesen möchten, erhalten Sie im Video das gleiche Material. </p><a name="habracut"></a><br><h2 id="sekretnaya-informaciya-o-keys">  Geheime Informationen über <code>keys</code> </h2><br><p>  Meistens ... brauchst du keine <code>keys</code> .  Im Allgemeinen schadet das Hinzufügen nicht, dies ist jedoch auch nicht erforderlich, da sie einfach als neues Schlüsselwort oder als neue Typdeklaration auf beiden Seiten einer neuen Variablen erfolgen (ich spreche von Ihnen, <code>Map&lt;Foo, Bar&gt; aMap = Map&lt;Foo, Bar&gt;()</code> ). </p><br><blockquote>  Wenn Sie jedoch feststellen, dass Sie Widgets in der Sammlung hinzufügen, entfernen oder neu anordnen, die einen bestimmten Status enthalten und vom gleichen Typ sind, sollten Sie auf die <code>keys</code> achten! </blockquote><p>  Um zu demonstrieren, warum Sie beim Ändern einer Sammlung von Widgets <code>keys</code> benötigen, habe ich eine äußerst einfache Anwendung mit zwei farbenfrohen Widgets geschrieben, die beim Klicken auf eine Schaltfläche die Position ändern: </p><br><p><img src="https://habrastorage.org/webt/n3/qy/l1/n3qyl1ute2ckxrbmjoasonmttra.gif"></p><br><p>  In dieser Version der Anwendung habe ich zwei zustandslose Widgets mit zufälliger Farbe ( <code>StatelessWidget</code> ) im <code>Row</code> und PositionedTiles-Widget mit dem Status ( <code>StatefulWidget</code> ), um die Reihenfolge der <code>StatefulWidget</code> zu speichern.  Wenn ich unten auf die Schaltfläche <code>FloatingActionButton</code> klicke, ändern die Farb-Widgets ihre Position in der Liste korrekt: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; runApp(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MaterialApp(home: PositionedTiles())); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTiles</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatefulWidget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">State&lt;StatefulWidget&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; PositionedTilesState(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTilesState</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTiles</span></span></span><span class="hljs-class">&gt; </span></span>{ List&lt;Widget&gt; tiles = [ StatelessColorfulTile(), StatelessColorfulTile(), ]; <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BuildContext context)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Scaffold( body: Row(children: tiles), floatingActionButton: FloatingActionButton( child: Icon(Icons.sentiment_very_satisfied), onPressed: swapTiles), ); } swapTiles() { setState(() { tiles.insert(<span class="hljs-number"><span class="hljs-number">1</span></span>, tiles.removeAt(<span class="hljs-number"><span class="hljs-number">0</span></span>)); }); } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatelessColorfulTile</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatelessWidget</span></span></span><span class="hljs-class"> </span></span>{ Color myColor = UniqueColorGenerator.getColor(); <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BuildContext context)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Container( color: myColor, child: Padding(padding: EdgeInsets.all(<span class="hljs-number"><span class="hljs-number">70.0</span></span>))); } }</code> </pre> <br><p>  Wenn wir jedoch unseren Farb-Widgets Status hinzufügen (sie zu <code>StatefulWidget</code> ) und die Farbe darin speichern, sieht es so aus, als ob nichts passiert, wenn wir auf die Schaltfläche klicken: </p><br><p><img src="https://habrastorage.org/webt/ou/xm/mh/ouxmmh4qaybwgmg3pezne9ocwwo.gif"></p><br><pre> <code class="java hljs">List&lt;Widget&gt; tiles = [ StatefulColorfulTile(), StatefulColorfulTile(), ]; ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatefulColorfulTile</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatefulWidget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">ColorfulTileState </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; ColorfulTileState(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ColorfulTileState</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ColorfulTile</span></span></span><span class="hljs-class">&gt; </span></span>{ Color myColor; <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.initState(); myColor = UniqueColorGenerator.getColor(); } <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BuildContext context)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Container( color: myColor, child: Padding( padding: EdgeInsets.all(<span class="hljs-number"><span class="hljs-number">70.0</span></span>), )); } }</code> </pre> <br><p>  Zur Erklärung: Der obige Code ist insofern fehlerhaft, als er den Farbaustausch nicht anzeigt, wenn der Benutzer auf die Schaltfläche klickt.  Um diesen Fehler zu beheben, müssen Sie den farbigen <code>StatefulWidget</code> Widgets den <code>key</code> hinzufügen. Anschließend werden die Widgets wie gewünscht ausgetauscht: </p><br><p><img src="https://habrastorage.org/webt/se/zh/am/sezham9ms7u158mzemvce1wwlhu.gif"></p><br><pre> <code class="java hljs">List&lt;Widget&gt; tiles = [ StatefulColorfulTile(key: UniqueKey()), <span class="hljs-comment"><span class="hljs-comment">// Keys added here StatefulColorfulTile(key: UniqueKey()), ]; ... class StatefulColorfulTile extends StatefulWidget { StatefulColorfulTile({Key key}) : super(key: key); // NEW CONSTRUCTOR @override ColorfulTileState createState() =&gt; ColorfulTileState(); } class ColorfulTileState extends State&lt;ColorfulTile&gt; { Color myColor; @override void initState() { super.initState(); myColor = UniqueColorGenerator.getColor(); } @override Widget build(BuildContext context) { return Container( color: myColor, child: Padding( padding: EdgeInsets.all(70.0), )); } }</span></span></code> </pre> <br><p>  Dies ist jedoch nur erforderlich, wenn Sie Widgets mit Status in dem Teilbaum haben, den Sie ändern.  Wenn der gesamte Teilbaum des Widgets in Ihrer Sammlung keinen Status hat, werden keine Schlüssel benötigt. <br>  So!  Alles in allem alles, was Sie wissen müssen, um <code>keys</code> in <code>Flutter</code> .  Aber wenn Sie etwas tiefer in das Geschehen einsteigen wollen ... </p><br><hr><br><h2 id="razbiraemsya-pochemu-keys-inogda-neobhodimy">  Verstehen, warum <code>keys</code> manchmal notwendig sind </h2><br><p>  Du bist immer noch hier, oder?  Dann kommen Sie näher und entdecken Sie die wahre Natur von Elementbäumen und Widgets, um ein Flatter-Magier zu werden!  Wahahaha!  Ha ha!  Ha ha!  Tut mir leid. </p><br><p>  Wie Sie wissen, erstellt Flutter in jedem Widget das entsprechende Element.  So wie Flutter einen Widget-Baum erstellt, erstellt er auch einen Elementbaum (ElementTree).  ElementTree ist extrem einfach, es enthält nur die Typinformationen jedes Widgets und einen Link zu untergeordneten Elementen.  Sie können sich ElementTree als das Grundgerüst Ihrer Flutter-Anwendung vorstellen.  Es zeigt die Struktur Ihrer Anwendung, aber alle zusätzlichen Informationen finden Sie unter dem Link zum Quell-Widget. </p><br><p>  Das Zeilen-Widget im obigen Beispiel enthält eine Reihe geordneter Slots für jedes seiner untergeordneten Elemente.  Wenn wir die Farb-Widgets in Row neu anordnen, geht Flutter um ElementTree herum, um zu überprüfen, ob die Skelettstruktur der Anwendung identisch ist. </p><br><p><img src="https://habrastorage.org/webt/ha/dh/vy/hadhvybi_mhjvuwdiiucmmx2w6i.gif"></p><br><p>  Die Validierung beginnt mit einem RowElement und geht dann zu den untergeordneten Elementen über.  ElementTree überprüft, ob das neue Widget denselben Typ und <code>key</code> wie das alte hat. In diesem Fall aktualisiert das Element seinen Link zum neuen Widget.  In der zustandslosen Version des Codes haben Widgets keinen <code>key</code> , daher überprüft Flutter einfach nur den Typ.  (Wenn zu viele Informationen gleichzeitig vorhanden sind, sehen Sie sich das animierte Diagramm oben an.) </p><br><p>  Unter ElementTree für Status-Widgets sieht es etwas anders aus.  Nach wie vor gibt es Widgets und Elemente, aber es gibt auch einige Statusobjekte für Widgets, in denen Farbinformationen und nicht in den Widgets selbst gespeichert sind. </p><br><p><img src="https://habrastorage.org/webt/dh/ay/sh/dhayshomjpkfv7b45fxmx1ecduw.gif"></p><br><p>  Bei farbigen <code>StatefulWidget</code> Widgets ohne <code>key</code> geht Flutter beim Ändern der Reihenfolge von zwei Widgets um ElementTree herum, überprüft den Typ des RowWidget und aktualisiert den Link.  Anschließend überprüft das Farb-Widget-Element, ob das entsprechende Widget vom gleichen Typ ist, und aktualisiert den Link.  Das gleiche passiert mit dem zweiten Widget.  Da Flutter ElementTree und den entsprechenden Status verwendet, um zu bestimmen, was tatsächlich auf Ihrem Gerät angezeigt werden soll, scheinen aus unserer Sicht die Widgets nicht ausgetauscht worden zu sein! </p><br><p><img src="https://habrastorage.org/webt/nu/yw/ah/nuywahtbnrv2bfvrwb0osfj1fye.gif"></p><br><p>  In der festen Version des Codes in farbigen Widgets mit Status im Konstruktor habe ich die <code>key</code> definiert.  Wenn wir nun die Widgets in <code>Row</code> ändern, stimmen sie nach Typ wie zuvor überein, aber die <code>key</code> für das Farb-Widget und für das entsprechende Element in ElementTree sind unterschiedlich.  Dies führt dazu, dass Flutter diese Elemente der Farb-Widgets deaktiviert und die Verknüpfungen zu ihnen in ElementTree entfernt, beginnend mit dem ersten, der nicht mit dem <code>key</code> übereinstimmt. </p><br><p><img src="https://habrastorage.org/webt/iz/vw/os/izvwos_wwqsng-afywi2az2shsu.gif"></p><br><p>  Anschließend sucht Flutter im ElementTree mit dem entsprechenden <code>key</code> nach den Widgets im Zeilenelement.  Wenn es übereinstimmt, wird ein Link zum Widget-Element hinzugefügt.  Flattern tut für jedes Kind ohne Link.  Jetzt zeigt Flutter an, was wir erwarten. Die Farb-Widgets ändern ihre Position, wenn ich auf die Schaltfläche klicke. </p><br><p>  Daher sind <code>keys</code> nützlich, wenn Sie die Reihenfolge oder Anzahl der Widgets mit dem Status in der Sammlung ändern.  In diesem Beispiel habe ich die Farbe gespeichert.  Oft ist der Zustand jedoch nicht so offensichtlich.  Eine Animation abspielen, Benutzereingaben anzeigen und durch einen Ort scrollen - alles hat einen Status. </p><br><hr><br><h2 id="kogda-mne-ispolzovat-keys">  Wann sollte ich <code>keys</code> ? </h2><br><p>  Kurze Antwort: Wenn Sie der Anwendung <code>keys</code> hinzufügen müssen, sollten Sie diese oben im Widget-Teilbaum mit dem Status hinzufügen, den Sie speichern möchten. </p><br><p>  Ein häufiger Fehler, den ich gesehen habe, ist, dass die Leute denken, dass sie den <code>key</code> nur für das erste Widget mit Status definieren müssen, aber es gibt Nuancen.  Glaubst du mir nicht?  Um zu zeigen, in welchen Problemen wir uns befinden könnten, habe ich meine Farb-Widgets in <code>Padding</code> Widgets eingeschlossen und die Tasten für die Farb-Widgets belassen. </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; runApp(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MaterialApp(home: PositionedTiles())); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTiles</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatefulWidget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">State&lt;StatefulWidget&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; PositionedTilesState(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTilesState</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTiles</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Stateful tiles now wrapped in padding (a stateless widget) to increase height // of widget tree and show why keys are needed at the Padding level. List&lt;Widget&gt; tiles = [ Padding( padding: const EdgeInsets.all(8.0), child: StatefulColorfulTile(key: UniqueKey()), ), Padding( padding: const EdgeInsets.all(8.0), child: StatefulColorfulTile(key: UniqueKey()), ), ]; @override Widget build(BuildContext context) { return Scaffold( body: Row(children: tiles), floatingActionButton: FloatingActionButton( child: Icon(Icons.sentiment_very_satisfied), onPressed: swapTiles), ); } swapTiles() { setState(() { tiles.insert(1, tiles.removeAt(0)); }); } } class StatefulColorfulTile extends StatefulWidget { StatefulColorfulTile({Key key}) : super(key: key); @override ColorfulTileState createState() =&gt; ColorfulTileState(); } class ColorfulTileState extends State&lt;ColorfulTile&gt; { Color myColor; @override void initState() { super.initState(); myColor = UniqueColorGenerator.getColor(); } @override Widget build(BuildContext context) { return Container( color: myColor, child: Padding( padding: EdgeInsets.all(70.0), )); } }</span></span></code> </pre> <br><p>  Jetzt erhalten Widgets auf Knopfdruck völlig zufällige Farben! </p><br><p><img src="https://habrastorage.org/webt/w2/ge/lb/w2gelbrnaw_hlvftimjhe-vhhim.gif"></p><br><p>  So sehen der Widget-Baum und ElementTree mit den hinzugefügten <code>Padding</code> Widgets aus: </p><br><p><img src="https://habrastorage.org/webt/k-/br/0o/k-br0o5hmbvzwvjodwemswze0na.jpeg"></p><br><p>  Wenn wir die Positionen von untergeordneten Widgets ändern, sieht der Übereinstimmungsalgorithmus zwischen Elementen und Widgets eine Ebene im Elementbaum aus.  Im Diagramm sind die Kinder der Kinder abgedunkelt, so dass nichts von der ersten Ebene ablenkt.  Auf dieser Ebene stimmt alles richtig überein. </p><br><p><img src="https://habrastorage.org/webt/j6/tt/zp/j6ttzpgzdbpupkzqw4s1vlsyz6g.gif"></p><br><p>  Auf der zweiten Ebene stellt Flutter fest, dass der <code>key</code> Farbelements nicht mit dem <code>key</code> Widgets übereinstimmt. Daher wird dieses Element deaktiviert, verworfen und alle Links zu ihm entfernt.  <code>keys</code> in diesem Beispiel verwendeten <code>keys</code> sind <code>LocalKeys</code> .  Dies bedeutet, dass Flutter beim Abgleichen eines Widgets mit Elementen nur auf einer bestimmten Ebene des Baums nach <code>keys</code> sucht. </p><br><p>  Da er das Farb-Widget-Element auf dieser Ebene mit dem entsprechenden <code>key</code> nicht finden kann, erstellt er ein neues und initialisiert einen neuen Status, wodurch das Widget in diesem Fall orange wird! </p><br><p><img src="https://habrastorage.org/webt/2q/mn/xk/2qmnxkwb7xpxtyi3jgbefvg70mi.gif"></p><br><p>  Wenn wir <code>keys</code> für <code>Padding</code> Widgets definieren: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; runApp(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MaterialApp(home: PositionedTiles())); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTiles</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatefulWidget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">State&lt;StatefulWidget&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; PositionedTilesState(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTilesState</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTiles</span></span></span><span class="hljs-class">&gt; </span></span>{ List&lt;Widget&gt; tiles = [ Padding( <span class="hljs-comment"><span class="hljs-comment">// Place the keys at the *top* of the tree of the items in the collection. key: UniqueKey(), padding: const EdgeInsets.all(8.0), child: StatefulColorfulTile(), ), Padding( key: UniqueKey(), padding: const EdgeInsets.all(8.0), child: StatefulColorfulTile(), ), ]; @override Widget build(BuildContext context) { return Scaffold( body: Row(children: tiles), floatingActionButton: FloatingActionButton( child: Icon(Icons.sentiment_very_satisfied), onPressed: swapTiles), ); } swapTiles() { setState(() { tiles.insert(1, tiles.removeAt(0)); }); } } class StatefulColorfulTile extends StatefulWidget { StatefulColorfulTile({Key key}) : super(key: key); @override ColorfulTileState createState() =&gt; ColorfulTileState(); } class ColorfulTileState extends State&lt;ColorfulTile&gt; { Color myColor; @override void initState() { super.initState(); myColor = UniqueColorGenerator.getColor(); } @override Widget build(BuildContext context) { return Container( color: myColor, child: Padding( padding: EdgeInsets.all(70.0), )); } }</span></span></code> </pre> <br><p>  Flutter bemerkt das Problem und aktualisiert die Links korrekt, wie in unserem vorherigen Beispiel.  Die Ordnung im Universum wird wiederhergestellt. </p><br><p><img src="https://habrastorage.org/webt/xp/4w/h0/xp4wh0wpzgd-5wxtxdkwu3jogps.gif"></p><br><hr><br><h2 id="kakoy-tip-key-mne-sleduet-ispolzovat">  Welche Art von <code>Key</code> soll ich verwenden? </h2><br><p>  Flutter-APIs gaben uns die Wahl zwischen mehreren <code>Key</code> .  Welche Art von <code>key</code> Sie verwenden sollten, hängt davon ab, was die Unterscheidungsmerkmale von Elementen sind, die <code>keys</code> benötigen.  Sehen Sie sich die Informationen an, die Sie in den jeweiligen Widgets speichern. </p><br><p>  Stellen Sie sich die folgende Aufgabenanwendung [1] vor, in der Sie die Reihenfolge der Elemente in der Aufgabenliste basierend auf der Priorität ändern und anschließend löschen können. </p><br><p><img src="https://habrastorage.org/webt/nz/qb/8g/nzqb8g-8ywgycp0g_xe-6p7-xk0.gif"></p><br><p>  <strong>ValueKey</strong> <br>  In diesem Fall können wir erwarten, dass der Text des Absatzes über die Implementierung dauerhaft und eindeutig ist.  Wenn ja, dann ist dies wahrscheinlich ein guter Kandidat für <code>ValueKey</code> , wo der Text "Wert" ist. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TodoItem( key: ValueKey(todo.task), todo: todo, onDismissed: (direction) =&gt; _removeTodo(context, todo), );</code> </pre> <br><p>  <strong>Objektschlüssel</strong> <br>  Alternativ können Sie die Adressbuchanwendung verwenden, in der Informationen zu jedem Benutzer aufgelistet sind.  In diesem Fall speichert jedes untergeordnete Widget eine komplexere Kombination von Daten.  Jedes der einzelnen Felder, z. B. Name oder Geburtstag, kann mit einem anderen Eintrag übereinstimmen, die Kombination ist jedoch eindeutig.  In diesem Fall ist <code>ObjectKey</code> höchstwahrscheinlich die beste <code>ObjectKey</code> . </p><br><p><img src="https://habrastorage.org/webt/jk/jz/av/jkjzavsw7v74t_dnnmb79mvukd0.png"></p><br><p>  <strong>Uniquekey</strong> <br>  Wenn Sie mehrere Widgets in der Sammlung mit demselben Wert haben oder wirklich sicherstellen möchten, dass sich jedes Widget von allen anderen unterscheidet, können Sie <code>UniqueKey</code> .  Ich habe <code>UniqueKey</code> in der Beispielanwendung zum Wechseln der Farben verwendet, da wir keine anderen konstanten Daten hatten, die in unseren Widgets gespeichert würden, und wir nicht wussten, welche Farbe das Widget beim Erstellen haben würde. </p><br><p>  Eine Sache, die Sie <strong>jedoch nicht</strong> als <code>key</code> <strong>möchten,</strong> ist eine Zufallszahl.  Jedes Mal, wenn ein Widget erstellt wird, wird eine neue Zufallszahl generiert und Sie verlieren die Konsistenz zwischen den Frames.  In diesem Szenario dürfen Sie überhaupt keine <code>keys</code> ! </p><br><p>  <strong>PageStorageKeys</strong> <br>  <code>PageStorageKeys</code> sind spezielle <code>keys</code> , die den aktuellen Status des <code>PageStorageKeys</code> enthalten, damit die Anwendung ihn zur späteren Verwendung speichern kann. </p><br><p><img src="https://habrastorage.org/webt/dx/db/if/dxdbif6yn7hlszee_-hbzbaevn8.gif"></p><br><p>  <strong>Globalkeys</strong> <br>  Es gibt zwei Optionen für die Verwendung von <code>GlobalKeys</code> : Sie ermöglichen Widgets, die <code>GlobalKeys</code> an einer beliebigen Stelle in der Anwendung zu ändern, ohne den Status zu verlieren, und können verwendet werden, um auf Informationen zu einem anderen Widget in einem völlig anderen Teil des Widget-Baums zuzugreifen.  Als Beispiel für das erste Szenario können Sie sich vorstellen, dass Sie dasselbe Widget auf zwei verschiedenen Bildschirmen <code>GlobalKey</code> möchten, aber mit demselben Status, damit die <code>GlobalKey</code> gespeichert werden, verwenden Sie <code>GlobalKey</code> .  Im zweiten Fall kann es vorkommen, dass Sie das Kennwort überprüfen müssen, aber keine Statusinformationen für andere Widgets in der Baumstruktur freigeben möchten.  <code>GlobalKeys</code> kann auch zum Testen nützlich sein, indem der <code>key</code> um auf ein bestimmtes Widget zuzugreifen und Informationen über dessen Status anzufordern. </p><br><p><img src="https://habrastorage.org/webt/eh/rq/bl/ehrqble5pcoeqrh7ktl0j0_dm5s.gif"></p><br><p>  Oft (aber nicht immer!) <code>GlobalKeys</code> bisschen wie globale Variablen.  Oft können sie durch <code>InheritedWidgets</code> oder etwas wie Redux oder die BLoC-Vorlage ersetzt werden. </p><br><hr><br><h2 id="kratkoe-zaklyuchenie">  Kurzer Abschluss </h2><br><p>  Verwenden Sie im Allgemeinen <code>Keys</code> wenn Sie den Status zwischen Widget-Teilbäumen beibehalten möchten.  Dies geschieht am häufigsten, wenn Sie die Sammlung von Widgets desselben Typs ändern.  Platzieren Sie den <code>key</code> oben im Widget-Teilbaum, den Sie speichern möchten, und wählen Sie den <code>key</code> basierend auf den im Widget gespeicherten Daten aus. </p><br><p>  Herzlichen Glückwunsch, Sie sind jetzt auf dem Weg, ein Flatter-Magier zu werden!  Oh, ich sagte ein Zauberer?  Ich meinte den Zauberer [2], wie denjenigen, der den Anwendungsquellcode schreibt ... was fast genauso gut ist.  ... fast. </p><br><p>  [1] Inspiration zum Schreiben des hier erhaltenen To-Do-Anwendungscodes <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/brianegan/flutter_architecture_samples/tree/master/vanilla</a> <br>  [2] Der Autor verwendet das Wort <code>sorcerer</code> und fügt später vor dem <code>sourcerer</code> einen zusätzlichen Buchstaben <code>sourcerer</code> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de446050/">https://habr.com/ru/post/de446050/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de446038/index.html">Eine kurze Anleitung zum Erstellen von Orakeln, Autogöttern und Fehlern zweiter Ordnung</a></li>
<li><a href="../de446040/index.html">Full Stack Confession: Beruf, Religion, Träume</a></li>
<li><a href="../de446042/index.html">DJI Mavic 2 Pro nach sechs Monaten Gebrauch</a></li>
<li><a href="../de446046/index.html">Die Expansion des Universums ist der größte Irrtum in der Geschichte der Wissenschaft</a></li>
<li><a href="../de446048/index.html">Die Vereinigung von Arduino und dem klassischen Prozessor</a></li>
<li><a href="../de446052/index.html">Erstellen Sie die Stimme und den Ton Ihres Produkts</a></li>
<li><a href="../de446054/index.html">Backup bereit: Urlaubsmythen zerstören</a></li>
<li><a href="../de446056/index.html">Eine einfache Möglichkeit, mit Ihrer Website zu sprechen</a></li>
<li><a href="../de446058/index.html">So erstellen Sie SDN - Acht Open Source-Tools</a></li>
<li><a href="../de446060/index.html">Synthese hochmolekularer Träume</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>