<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üà∑Ô∏è üì• üò≠ Flattern. Schl√ºssel! Wof√ºr sind sie? üë®üèª‚Äçüíº üßúüèø ‚úäüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der key ist in fast jedem Widget-Konstruktor zu finden, wird jedoch in der Entwicklung selten verwendet. Keys behalten den Status bei, wenn Widgets im...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Flattern. Schl√ºssel! Wof√ºr sind sie?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446050/"><p><img src="https://habrastorage.org/webt/bd/bp/o2/bdbpo2nvc1jntzhrnowfckpywh0.jpeg"></p><br><p> Der <code>key</code> ist in fast jedem Widget-Konstruktor zu finden, wird jedoch in der Entwicklung selten verwendet.  <code>Keys</code> behalten den Status bei, wenn Widgets im Widget-Baum verschoben werden.  In der Praxis bedeutet dies, dass sie n√ºtzlich sein k√∂nnen, um den Bildlaufort oder den Speicherstatus des Benutzers zu speichern, wenn sich die Sammlung √§ndert. </p><br><p>  Dieser Artikel wurde aus dem folgenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Video</a> angepasst.  Wenn Sie lieber h√∂ren / sehen als lesen m√∂chten, erhalten Sie im Video das gleiche Material. </p><a name="habracut"></a><br><h2 id="sekretnaya-informaciya-o-keys">  Geheime Informationen √ºber <code>keys</code> </h2><br><p>  Meistens ... brauchst du keine <code>keys</code> .  Im Allgemeinen schadet das Hinzuf√ºgen nicht, dies ist jedoch auch nicht erforderlich, da sie einfach als neues Schl√ºsselwort oder als neue Typdeklaration auf beiden Seiten einer neuen Variablen erfolgen (ich spreche von Ihnen, <code>Map&lt;Foo, Bar&gt; aMap = Map&lt;Foo, Bar&gt;()</code> ). </p><br><blockquote>  Wenn Sie jedoch feststellen, dass Sie Widgets in der Sammlung hinzuf√ºgen, entfernen oder neu anordnen, die einen bestimmten Status enthalten und vom gleichen Typ sind, sollten Sie auf die <code>keys</code> achten! </blockquote><p>  Um zu demonstrieren, warum Sie beim √Ñndern einer Sammlung von Widgets <code>keys</code> ben√∂tigen, habe ich eine √§u√üerst einfache Anwendung mit zwei farbenfrohen Widgets geschrieben, die beim Klicken auf eine Schaltfl√§che die Position √§ndern: </p><br><p><img src="https://habrastorage.org/webt/n3/qy/l1/n3qyl1ute2ckxrbmjoasonmttra.gif"></p><br><p>  In dieser Version der Anwendung habe ich zwei zustandslose Widgets mit zuf√§lliger Farbe ( <code>StatelessWidget</code> ) im <code>Row</code> und PositionedTiles-Widget mit dem Status ( <code>StatefulWidget</code> ), um die Reihenfolge der <code>StatefulWidget</code> zu speichern.  Wenn ich unten auf die Schaltfl√§che <code>FloatingActionButton</code> klicke, √§ndern die Farb-Widgets ihre Position in der Liste korrekt: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; runApp(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MaterialApp(home: PositionedTiles())); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTiles</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatefulWidget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">State&lt;StatefulWidget&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; PositionedTilesState(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTilesState</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTiles</span></span></span><span class="hljs-class">&gt; </span></span>{ List&lt;Widget&gt; tiles = [ StatelessColorfulTile(), StatelessColorfulTile(), ]; <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BuildContext context)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Scaffold( body: Row(children: tiles), floatingActionButton: FloatingActionButton( child: Icon(Icons.sentiment_very_satisfied), onPressed: swapTiles), ); } swapTiles() { setState(() { tiles.insert(<span class="hljs-number"><span class="hljs-number">1</span></span>, tiles.removeAt(<span class="hljs-number"><span class="hljs-number">0</span></span>)); }); } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatelessColorfulTile</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatelessWidget</span></span></span><span class="hljs-class"> </span></span>{ Color myColor = UniqueColorGenerator.getColor(); <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BuildContext context)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Container( color: myColor, child: Padding(padding: EdgeInsets.all(<span class="hljs-number"><span class="hljs-number">70.0</span></span>))); } }</code> </pre> <br><p>  Wenn wir jedoch unseren Farb-Widgets Status hinzuf√ºgen (sie zu <code>StatefulWidget</code> ) und die Farbe darin speichern, sieht es so aus, als ob nichts passiert, wenn wir auf die Schaltfl√§che klicken: </p><br><p><img src="https://habrastorage.org/webt/ou/xm/mh/ouxmmh4qaybwgmg3pezne9ocwwo.gif"></p><br><pre> <code class="java hljs">List&lt;Widget&gt; tiles = [ StatefulColorfulTile(), StatefulColorfulTile(), ]; ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatefulColorfulTile</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatefulWidget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">ColorfulTileState </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; ColorfulTileState(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ColorfulTileState</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ColorfulTile</span></span></span><span class="hljs-class">&gt; </span></span>{ Color myColor; <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.initState(); myColor = UniqueColorGenerator.getColor(); } <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BuildContext context)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Container( color: myColor, child: Padding( padding: EdgeInsets.all(<span class="hljs-number"><span class="hljs-number">70.0</span></span>), )); } }</code> </pre> <br><p>  Zur Erkl√§rung: Der obige Code ist insofern fehlerhaft, als er den Farbaustausch nicht anzeigt, wenn der Benutzer auf die Schaltfl√§che klickt.  Um diesen Fehler zu beheben, m√ºssen Sie den farbigen <code>StatefulWidget</code> Widgets den <code>key</code> hinzuf√ºgen. Anschlie√üend werden die Widgets wie gew√ºnscht ausgetauscht: </p><br><p><img src="https://habrastorage.org/webt/se/zh/am/sezham9ms7u158mzemvce1wwlhu.gif"></p><br><pre> <code class="java hljs">List&lt;Widget&gt; tiles = [ StatefulColorfulTile(key: UniqueKey()), <span class="hljs-comment"><span class="hljs-comment">// Keys added here StatefulColorfulTile(key: UniqueKey()), ]; ... class StatefulColorfulTile extends StatefulWidget { StatefulColorfulTile({Key key}) : super(key: key); // NEW CONSTRUCTOR @override ColorfulTileState createState() =&gt; ColorfulTileState(); } class ColorfulTileState extends State&lt;ColorfulTile&gt; { Color myColor; @override void initState() { super.initState(); myColor = UniqueColorGenerator.getColor(); } @override Widget build(BuildContext context) { return Container( color: myColor, child: Padding( padding: EdgeInsets.all(70.0), )); } }</span></span></code> </pre> <br><p>  Dies ist jedoch nur erforderlich, wenn Sie Widgets mit Status in dem Teilbaum haben, den Sie √§ndern.  Wenn der gesamte Teilbaum des Widgets in Ihrer Sammlung keinen Status hat, werden keine Schl√ºssel ben√∂tigt. <br>  So!  Alles in allem alles, was Sie wissen m√ºssen, um <code>keys</code> in <code>Flutter</code> .  Aber wenn Sie etwas tiefer in das Geschehen einsteigen wollen ... </p><br><hr><br><h2 id="razbiraemsya-pochemu-keys-inogda-neobhodimy">  Verstehen, warum <code>keys</code> manchmal notwendig sind </h2><br><p>  Du bist immer noch hier, oder?  Dann kommen Sie n√§her und entdecken Sie die wahre Natur von Elementb√§umen und Widgets, um ein Flatter-Magier zu werden!  Wahahaha!  Ha ha!  Ha ha!  Tut mir leid. </p><br><p>  Wie Sie wissen, erstellt Flutter in jedem Widget das entsprechende Element.  So wie Flutter einen Widget-Baum erstellt, erstellt er auch einen Elementbaum (ElementTree).  ElementTree ist extrem einfach, es enth√§lt nur die Typinformationen jedes Widgets und einen Link zu untergeordneten Elementen.  Sie k√∂nnen sich ElementTree als das Grundger√ºst Ihrer Flutter-Anwendung vorstellen.  Es zeigt die Struktur Ihrer Anwendung, aber alle zus√§tzlichen Informationen finden Sie unter dem Link zum Quell-Widget. </p><br><p>  Das Zeilen-Widget im obigen Beispiel enth√§lt eine Reihe geordneter Slots f√ºr jedes seiner untergeordneten Elemente.  Wenn wir die Farb-Widgets in Row neu anordnen, geht Flutter um ElementTree herum, um zu √ºberpr√ºfen, ob die Skelettstruktur der Anwendung identisch ist. </p><br><p><img src="https://habrastorage.org/webt/ha/dh/vy/hadhvybi_mhjvuwdiiucmmx2w6i.gif"></p><br><p>  Die Validierung beginnt mit einem RowElement und geht dann zu den untergeordneten Elementen √ºber.  ElementTree √ºberpr√ºft, ob das neue Widget denselben Typ und <code>key</code> wie das alte hat. In diesem Fall aktualisiert das Element seinen Link zum neuen Widget.  In der zustandslosen Version des Codes haben Widgets keinen <code>key</code> , daher √ºberpr√ºft Flutter einfach nur den Typ.  (Wenn zu viele Informationen gleichzeitig vorhanden sind, sehen Sie sich das animierte Diagramm oben an.) </p><br><p>  Unter ElementTree f√ºr Status-Widgets sieht es etwas anders aus.  Nach wie vor gibt es Widgets und Elemente, aber es gibt auch einige Statusobjekte f√ºr Widgets, in denen Farbinformationen und nicht in den Widgets selbst gespeichert sind. </p><br><p><img src="https://habrastorage.org/webt/dh/ay/sh/dhayshomjpkfv7b45fxmx1ecduw.gif"></p><br><p>  Bei farbigen <code>StatefulWidget</code> Widgets ohne <code>key</code> geht Flutter beim √Ñndern der Reihenfolge von zwei Widgets um ElementTree herum, √ºberpr√ºft den Typ des RowWidget und aktualisiert den Link.  Anschlie√üend √ºberpr√ºft das Farb-Widget-Element, ob das entsprechende Widget vom gleichen Typ ist, und aktualisiert den Link.  Das gleiche passiert mit dem zweiten Widget.  Da Flutter ElementTree und den entsprechenden Status verwendet, um zu bestimmen, was tats√§chlich auf Ihrem Ger√§t angezeigt werden soll, scheinen aus unserer Sicht die Widgets nicht ausgetauscht worden zu sein! </p><br><p><img src="https://habrastorage.org/webt/nu/yw/ah/nuywahtbnrv2bfvrwb0osfj1fye.gif"></p><br><p>  In der festen Version des Codes in farbigen Widgets mit Status im Konstruktor habe ich die <code>key</code> definiert.  Wenn wir nun die Widgets in <code>Row</code> √§ndern, stimmen sie nach Typ wie zuvor √ºberein, aber die <code>key</code> f√ºr das Farb-Widget und f√ºr das entsprechende Element in ElementTree sind unterschiedlich.  Dies f√ºhrt dazu, dass Flutter diese Elemente der Farb-Widgets deaktiviert und die Verkn√ºpfungen zu ihnen in ElementTree entfernt, beginnend mit dem ersten, der nicht mit dem <code>key</code> √ºbereinstimmt. </p><br><p><img src="https://habrastorage.org/webt/iz/vw/os/izvwos_wwqsng-afywi2az2shsu.gif"></p><br><p>  Anschlie√üend sucht Flutter im ElementTree mit dem entsprechenden <code>key</code> nach den Widgets im Zeilenelement.  Wenn es √ºbereinstimmt, wird ein Link zum Widget-Element hinzugef√ºgt.  Flattern tut f√ºr jedes Kind ohne Link.  Jetzt zeigt Flutter an, was wir erwarten. Die Farb-Widgets √§ndern ihre Position, wenn ich auf die Schaltfl√§che klicke. </p><br><p>  Daher sind <code>keys</code> n√ºtzlich, wenn Sie die Reihenfolge oder Anzahl der Widgets mit dem Status in der Sammlung √§ndern.  In diesem Beispiel habe ich die Farbe gespeichert.  Oft ist der Zustand jedoch nicht so offensichtlich.  Eine Animation abspielen, Benutzereingaben anzeigen und durch einen Ort scrollen - alles hat einen Status. </p><br><hr><br><h2 id="kogda-mne-ispolzovat-keys">  Wann sollte ich <code>keys</code> ? </h2><br><p>  Kurze Antwort: Wenn Sie der Anwendung <code>keys</code> hinzuf√ºgen m√ºssen, sollten Sie diese oben im Widget-Teilbaum mit dem Status hinzuf√ºgen, den Sie speichern m√∂chten. </p><br><p>  Ein h√§ufiger Fehler, den ich gesehen habe, ist, dass die Leute denken, dass sie den <code>key</code> nur f√ºr das erste Widget mit Status definieren m√ºssen, aber es gibt Nuancen.  Glaubst du mir nicht?  Um zu zeigen, in welchen Problemen wir uns befinden k√∂nnten, habe ich meine Farb-Widgets in <code>Padding</code> Widgets eingeschlossen und die Tasten f√ºr die Farb-Widgets belassen. </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; runApp(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MaterialApp(home: PositionedTiles())); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTiles</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatefulWidget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">State&lt;StatefulWidget&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; PositionedTilesState(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTilesState</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTiles</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Stateful tiles now wrapped in padding (a stateless widget) to increase height // of widget tree and show why keys are needed at the Padding level. List&lt;Widget&gt; tiles = [ Padding( padding: const EdgeInsets.all(8.0), child: StatefulColorfulTile(key: UniqueKey()), ), Padding( padding: const EdgeInsets.all(8.0), child: StatefulColorfulTile(key: UniqueKey()), ), ]; @override Widget build(BuildContext context) { return Scaffold( body: Row(children: tiles), floatingActionButton: FloatingActionButton( child: Icon(Icons.sentiment_very_satisfied), onPressed: swapTiles), ); } swapTiles() { setState(() { tiles.insert(1, tiles.removeAt(0)); }); } } class StatefulColorfulTile extends StatefulWidget { StatefulColorfulTile({Key key}) : super(key: key); @override ColorfulTileState createState() =&gt; ColorfulTileState(); } class ColorfulTileState extends State&lt;ColorfulTile&gt; { Color myColor; @override void initState() { super.initState(); myColor = UniqueColorGenerator.getColor(); } @override Widget build(BuildContext context) { return Container( color: myColor, child: Padding( padding: EdgeInsets.all(70.0), )); } }</span></span></code> </pre> <br><p>  Jetzt erhalten Widgets auf Knopfdruck v√∂llig zuf√§llige Farben! </p><br><p><img src="https://habrastorage.org/webt/w2/ge/lb/w2gelbrnaw_hlvftimjhe-vhhim.gif"></p><br><p>  So sehen der Widget-Baum und ElementTree mit den hinzugef√ºgten <code>Padding</code> Widgets aus: </p><br><p><img src="https://habrastorage.org/webt/k-/br/0o/k-br0o5hmbvzwvjodwemswze0na.jpeg"></p><br><p>  Wenn wir die Positionen von untergeordneten Widgets √§ndern, sieht der √úbereinstimmungsalgorithmus zwischen Elementen und Widgets eine Ebene im Elementbaum aus.  Im Diagramm sind die Kinder der Kinder abgedunkelt, so dass nichts von der ersten Ebene ablenkt.  Auf dieser Ebene stimmt alles richtig √ºberein. </p><br><p><img src="https://habrastorage.org/webt/j6/tt/zp/j6ttzpgzdbpupkzqw4s1vlsyz6g.gif"></p><br><p>  Auf der zweiten Ebene stellt Flutter fest, dass der <code>key</code> Farbelements nicht mit dem <code>key</code> Widgets √ºbereinstimmt. Daher wird dieses Element deaktiviert, verworfen und alle Links zu ihm entfernt.  <code>keys</code> in diesem Beispiel verwendeten <code>keys</code> sind <code>LocalKeys</code> .  Dies bedeutet, dass Flutter beim Abgleichen eines Widgets mit Elementen nur auf einer bestimmten Ebene des Baums nach <code>keys</code> sucht. </p><br><p>  Da er das Farb-Widget-Element auf dieser Ebene mit dem entsprechenden <code>key</code> nicht finden kann, erstellt er ein neues und initialisiert einen neuen Status, wodurch das Widget in diesem Fall orange wird! </p><br><p><img src="https://habrastorage.org/webt/2q/mn/xk/2qmnxkwb7xpxtyi3jgbefvg70mi.gif"></p><br><p>  Wenn wir <code>keys</code> f√ºr <code>Padding</code> Widgets definieren: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; runApp(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MaterialApp(home: PositionedTiles())); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTiles</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatefulWidget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">State&lt;StatefulWidget&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; PositionedTilesState(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTilesState</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTiles</span></span></span><span class="hljs-class">&gt; </span></span>{ List&lt;Widget&gt; tiles = [ Padding( <span class="hljs-comment"><span class="hljs-comment">// Place the keys at the *top* of the tree of the items in the collection. key: UniqueKey(), padding: const EdgeInsets.all(8.0), child: StatefulColorfulTile(), ), Padding( key: UniqueKey(), padding: const EdgeInsets.all(8.0), child: StatefulColorfulTile(), ), ]; @override Widget build(BuildContext context) { return Scaffold( body: Row(children: tiles), floatingActionButton: FloatingActionButton( child: Icon(Icons.sentiment_very_satisfied), onPressed: swapTiles), ); } swapTiles() { setState(() { tiles.insert(1, tiles.removeAt(0)); }); } } class StatefulColorfulTile extends StatefulWidget { StatefulColorfulTile({Key key}) : super(key: key); @override ColorfulTileState createState() =&gt; ColorfulTileState(); } class ColorfulTileState extends State&lt;ColorfulTile&gt; { Color myColor; @override void initState() { super.initState(); myColor = UniqueColorGenerator.getColor(); } @override Widget build(BuildContext context) { return Container( color: myColor, child: Padding( padding: EdgeInsets.all(70.0), )); } }</span></span></code> </pre> <br><p>  Flutter bemerkt das Problem und aktualisiert die Links korrekt, wie in unserem vorherigen Beispiel.  Die Ordnung im Universum wird wiederhergestellt. </p><br><p><img src="https://habrastorage.org/webt/xp/4w/h0/xp4wh0wpzgd-5wxtxdkwu3jogps.gif"></p><br><hr><br><h2 id="kakoy-tip-key-mne-sleduet-ispolzovat">  Welche Art von <code>Key</code> soll ich verwenden? </h2><br><p>  Flutter-APIs gaben uns die Wahl zwischen mehreren <code>Key</code> .  Welche Art von <code>key</code> Sie verwenden sollten, h√§ngt davon ab, was die Unterscheidungsmerkmale von Elementen sind, die <code>keys</code> ben√∂tigen.  Sehen Sie sich die Informationen an, die Sie in den jeweiligen Widgets speichern. </p><br><p>  Stellen Sie sich die folgende Aufgabenanwendung [1] vor, in der Sie die Reihenfolge der Elemente in der Aufgabenliste basierend auf der Priorit√§t √§ndern und anschlie√üend l√∂schen k√∂nnen. </p><br><p><img src="https://habrastorage.org/webt/nz/qb/8g/nzqb8g-8ywgycp0g_xe-6p7-xk0.gif"></p><br><p>  <strong>ValueKey</strong> <br>  In diesem Fall k√∂nnen wir erwarten, dass der Text des Absatzes √ºber die Implementierung dauerhaft und eindeutig ist.  Wenn ja, dann ist dies wahrscheinlich ein guter Kandidat f√ºr <code>ValueKey</code> , wo der Text "Wert" ist. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TodoItem( key: ValueKey(todo.task), todo: todo, onDismissed: (direction) =&gt; _removeTodo(context, todo), );</code> </pre> <br><p>  <strong>Objektschl√ºssel</strong> <br>  Alternativ k√∂nnen Sie die Adressbuchanwendung verwenden, in der Informationen zu jedem Benutzer aufgelistet sind.  In diesem Fall speichert jedes untergeordnete Widget eine komplexere Kombination von Daten.  Jedes der einzelnen Felder, z. B. Name oder Geburtstag, kann mit einem anderen Eintrag √ºbereinstimmen, die Kombination ist jedoch eindeutig.  In diesem Fall ist <code>ObjectKey</code> h√∂chstwahrscheinlich die beste <code>ObjectKey</code> . </p><br><p><img src="https://habrastorage.org/webt/jk/jz/av/jkjzavsw7v74t_dnnmb79mvukd0.png"></p><br><p>  <strong>Uniquekey</strong> <br>  Wenn Sie mehrere Widgets in der Sammlung mit demselben Wert haben oder wirklich sicherstellen m√∂chten, dass sich jedes Widget von allen anderen unterscheidet, k√∂nnen Sie <code>UniqueKey</code> .  Ich habe <code>UniqueKey</code> in der Beispielanwendung zum Wechseln der Farben verwendet, da wir keine anderen konstanten Daten hatten, die in unseren Widgets gespeichert w√ºrden, und wir nicht wussten, welche Farbe das Widget beim Erstellen haben w√ºrde. </p><br><p>  Eine Sache, die Sie <strong>jedoch nicht</strong> als <code>key</code> <strong>m√∂chten,</strong> ist eine Zufallszahl.  Jedes Mal, wenn ein Widget erstellt wird, wird eine neue Zufallszahl generiert und Sie verlieren die Konsistenz zwischen den Frames.  In diesem Szenario d√ºrfen Sie √ºberhaupt keine <code>keys</code> ! </p><br><p>  <strong>PageStorageKeys</strong> <br>  <code>PageStorageKeys</code> sind spezielle <code>keys</code> , die den aktuellen Status des <code>PageStorageKeys</code> enthalten, damit die Anwendung ihn zur sp√§teren Verwendung speichern kann. </p><br><p><img src="https://habrastorage.org/webt/dx/db/if/dxdbif6yn7hlszee_-hbzbaevn8.gif"></p><br><p>  <strong>Globalkeys</strong> <br>  Es gibt zwei Optionen f√ºr die Verwendung von <code>GlobalKeys</code> : Sie erm√∂glichen Widgets, die <code>GlobalKeys</code> an einer beliebigen Stelle in der Anwendung zu √§ndern, ohne den Status zu verlieren, und k√∂nnen verwendet werden, um auf Informationen zu einem anderen Widget in einem v√∂llig anderen Teil des Widget-Baums zuzugreifen.  Als Beispiel f√ºr das erste Szenario k√∂nnen Sie sich vorstellen, dass Sie dasselbe Widget auf zwei verschiedenen Bildschirmen <code>GlobalKey</code> m√∂chten, aber mit demselben Status, damit die <code>GlobalKey</code> gespeichert werden, verwenden Sie <code>GlobalKey</code> .  Im zweiten Fall kann es vorkommen, dass Sie das Kennwort √ºberpr√ºfen m√ºssen, aber keine Statusinformationen f√ºr andere Widgets in der Baumstruktur freigeben m√∂chten.  <code>GlobalKeys</code> kann auch zum Testen n√ºtzlich sein, indem der <code>key</code> um auf ein bestimmtes Widget zuzugreifen und Informationen √ºber dessen Status anzufordern. </p><br><p><img src="https://habrastorage.org/webt/eh/rq/bl/ehrqble5pcoeqrh7ktl0j0_dm5s.gif"></p><br><p>  Oft (aber nicht immer!) <code>GlobalKeys</code> bisschen wie globale Variablen.  Oft k√∂nnen sie durch <code>InheritedWidgets</code> oder etwas wie Redux oder die BLoC-Vorlage ersetzt werden. </p><br><hr><br><h2 id="kratkoe-zaklyuchenie">  Kurzer Abschluss </h2><br><p>  Verwenden Sie im Allgemeinen <code>Keys</code> wenn Sie den Status zwischen Widget-Teilb√§umen beibehalten m√∂chten.  Dies geschieht am h√§ufigsten, wenn Sie die Sammlung von Widgets desselben Typs √§ndern.  Platzieren Sie den <code>key</code> oben im Widget-Teilbaum, den Sie speichern m√∂chten, und w√§hlen Sie den <code>key</code> basierend auf den im Widget gespeicherten Daten aus. </p><br><p>  Herzlichen Gl√ºckwunsch, Sie sind jetzt auf dem Weg, ein Flatter-Magier zu werden!  Oh, ich sagte ein Zauberer?  Ich meinte den Zauberer [2], wie denjenigen, der den Anwendungsquellcode schreibt ... was fast genauso gut ist.  ... fast. </p><br><p>  [1] Inspiration zum Schreiben des hier erhaltenen To-Do-Anwendungscodes <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/brianegan/flutter_architecture_samples/tree/master/vanilla</a> <br>  [2] Der Autor verwendet das Wort <code>sorcerer</code> und f√ºgt sp√§ter vor dem <code>sourcerer</code> einen zus√§tzlichen Buchstaben <code>sourcerer</code> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de446050/">https://habr.com/ru/post/de446050/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de446038/index.html">Eine kurze Anleitung zum Erstellen von Orakeln, Autog√∂ttern und Fehlern zweiter Ordnung</a></li>
<li><a href="../de446040/index.html">Full Stack Confession: Beruf, Religion, Tr√§ume</a></li>
<li><a href="../de446042/index.html">DJI Mavic 2 Pro nach sechs Monaten Gebrauch</a></li>
<li><a href="../de446046/index.html">Die Expansion des Universums ist der gr√∂√üte Irrtum in der Geschichte der Wissenschaft</a></li>
<li><a href="../de446048/index.html">Die Vereinigung von Arduino und dem klassischen Prozessor</a></li>
<li><a href="../de446052/index.html">Erstellen Sie die Stimme und den Ton Ihres Produkts</a></li>
<li><a href="../de446054/index.html">Backup bereit: Urlaubsmythen zerst√∂ren</a></li>
<li><a href="../de446056/index.html">Eine einfache M√∂glichkeit, mit Ihrer Website zu sprechen</a></li>
<li><a href="../de446058/index.html">So erstellen Sie SDN - Acht Open Source-Tools</a></li>
<li><a href="../de446060/index.html">Synthese hochmolekularer Tr√§ume</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>