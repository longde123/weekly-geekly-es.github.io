<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍘 👦🏻 👍 在给定间隔内有效生成数字 🤱🏽 🤕 🆖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我在随机数生成上的绝大多数帖子主要涉及各种生成方案的特性。 这可能出乎意料，但是随机算法的性能可能不取决于所选的生成方案，而是取决于其他因素。 在这篇文章（我受Daniel Lemyr的一篇精彩文章的启发 ）中，我们将研究导致随机数生成性能下降的主要原因，该性能通常超过PRN引擎的性能。 

 想象...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在给定间隔内有效生成数字</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455702/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21b/913/a41/21b913a412f4fcae1d02afabc90b236c.svg" alt="图片"></div><br> 我在随机数生成上的绝大多数帖子主要涉及各种生成方案的特性。 这可能出乎意料，但是随机算法的性能可能不取决于所选的生成方案，而是取决于其他因素。 在这篇文章（我<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">受Daniel Lemyr的一篇</a>精彩<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文章的启发</a> ）中，我们将研究导致随机数生成性能下降的主要原因，该性能通常超过PRN引擎的性能。 <br><br> 想象一下这种情况： <br><br> 作为作业，Juan和Sasha在C ++中实现了相同的随机算法，该算法将在同一台大学计算机上运行，​​并具有一个数据集。 它们的代码几乎相同，只是在随机数的生成上有所不同。  Juan急于上音乐课，因此他只是选择了Mersenne旋风。 另一方面，Sasha花了一些额外的时间进行研究。  Sasha对几种最快的PRNG进行了基准测试，最近他从社交网络上获悉，并选择了最快的PRNG。 在会议上，Sasha不耐烦地吹牛，他问Juan：“您使用了哪种PRNG系统？” <br><br>  “就我个人而言，我只是采用了Mersenne涡流-它是语言内置的，并且似乎运行得很好。” <br><br>  “哈！”萨沙回答。  “我使用了<code>jsf32</code> 。 它比古老而缓慢的梅森旋风要快得多！ 我的程序在3分15秒内运行！” <br><br>  “嗯，还不错，但是我可以在不到一分钟的时间内做到这一点，”胡安耸耸肩说。  “那么，我必须去听音乐会。 你愿意和我一起去吗？ <br><br>  “不，”萨莎回答。  “我……呃……需要再次查看我的代码。” <br><br> 这种尴尬的虚构情况<em>并不是</em>特别虚构。 它基于实际结果。 如果您的随机算法的运行速度没有我们期望的快，并且瓶颈似乎是随机数生成，那么奇怪的是，问题可能出在随机数生成器上！ <br><a name="habracut"></a><br><h3> 简介：实践中的随机数 </h3><br> 大多数现代高质量随机数生成器都会创建填充有随机位的机器字，也就是说，它们通常会生成间隔为[0..2 <sup>32</sup> ]或[0..2 <sup>64</sup> ）的数字。 但是在许多使用情况下，用户需要一定时间间隔的数字-例如，掷骰子或选择随机纸牌，需要以较小的恒定间隔数字。 但是，从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">混合</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">储层采样</a>到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">随机二叉搜索树</a> ，许多算法都需要从其他间隔中获取数字。 <br><br><h3> 方法 </h3><br> 我们将研究许多不同的方法。 为了简化讨论，我们将在间隔[0 .. <em>k</em> ）中生成数字，而不是在间隔[ <em>i..j</em> ]或[ <em>i..j</em> ]中生成数字。 有了这样的方案，我们可以，例如，通过设置<em>k</em> = <em>j</em> - <em>i</em> ，在间隔[0 .. <em>k</em> ）中生成一个数字，然后将其加<em>i</em>来生成间隔[ <em>i</em> .. <em>j</em> ）中的数字。 <br><br><h4> 内置C ++工具 </h4><br> 许多语言都有内置工具，可以在指定间隔内获取随机数。 例如，要从用52种卡以脚本语言（例如Perl和Python）从卡组中取出卡，我们可以分别编写<code>int(rand(52))</code>和<code>random.randint(0,52)</code> 。  [注意  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">CryptoPirate</a>用户： <i>在我看来，这是一个错误，在python randint（a，b）中生成从a到b的数字，包括b。</i>  <i>并且由于卡片组中有52张卡片，并且第一张卡片为“ 0”，因此应该为random.randint（0,51）</i> 。]在C ++中，我们可以<code>uniform_int_distribution</code>相同的<code>uniform_int_distribution</code>使用<code>uniform_int_distribution</code> 。 <br><br> 用C ++代码实现这种方法很简单： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::uniform_int_distribution&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>&gt; dist(<span class="hljs-number"><span class="hljs-number">0</span></span>, range<span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dist(rng); }</code> </pre> <br> 通常，内置工具使用以下描述的一种技术，但是大多数用户只是简单地使用这些工具，而没有考虑“幕后”的情况，而是认为这些工具设计正确并且非常有效。 在C ++中，内置工具更加复杂，因为它们应该能够与相当任意的生成引擎一起使用-生成值介于-3到17之间的生成器可能是非常有效的，并且可以与<code>std::uniform_int_distribution</code>一起使用，以任意间隔创建数字，例如[0..1000）。 也就是说，对于大多数使用内置C ++工具的情况来说，它们太复杂了。 <br><br><h4> 该分部的经典余数（偏斜） </h4><br> 让我们从过度简化的方法过渡到过于简单的方法。 <br><br> 当我学习编程时，我们使用余数运算符生成了间隔中的数字（例如，在52张牌中选择一张牌）。 为了获得区间[0..52）中的数字，我们编写了<code>rand() % 52</code> 。 <br><br> 在C ++中，可以按以下方式实现此方法： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rng() % range; }</code> </pre> <br> 尽管这种方法很简单，但它说明了在正确的间隔中获取数字通常是一项缓慢的任务的原因-它需要除法（以计算由<code>%</code>运算符获得的余数）。 除法通常比其他算术运算至少慢一个数量级，因此单个算术运算要比快速PRNG执行的所有工作花费更长的时间。 <br><br> 但是除了低速外，它还<em>歪斜了</em> 。 要了解为什么<code>rand() % 52</code>返回不正确的数字，请假设<code>rand()</code>在区间[0..2 <sup>32</sup> <code>rand()</code>创建数字，并注意52不会将2 <sup>32</sup>完全除，而是将其除以82 595 524次48.也就是说，如果我们使用<code>rand() % 52</code> ，那么我们将有82 595 525种方法来选择牌组中的前48张牌，而只有82 595 524种方法来选择后四张牌。 换句话说，最后四张卡（可能是国王！）的歪斜为0.00000121％。 当我还是一个学生，写有关扔骰子或抽奖卡的作业时，通常没有人关心这种微小的变形，但是随着间隔的增加，变形呈线性增长。 对于32位PRNG，小于2 <sup>24</sup>的有限间隔的斜率小于0.5％，但大于2 <sup>31的</sup>斜率则为50％-一些数字返回的频率是其他数字的两倍。 <br><br> 在本文中，我们将主要考虑使用策略消除系统错误的技术，但是可能值得一提的是，对于64位PRNG，普通应用程序中的偏斜值可以忽略不计。 <br><br> 另一个问题可能是某些发生器的弱位较低。 例如，GPRS系列Xoroshiro +和Xoshiro +的低位不通过统计测试。 当我们执行<code>% 52</code> （因为52是偶数）时，我们将低阶位直接传递到输出。 <br><br><h4> 乘以浮点数（偏斜） </h4><br> 另一种常用技术是使用PRNG，该PRNG会在间隔[0..1）中生成浮点数，然后将这些数字转换为所需的间隔。 这种方法在Perl中使用， <a href="">建议</a>使用<code>int(rand(10))</code>在区间[0..10）中生成整数，方法是生成浮点数，然后向下舍入。 <br><br> 在C ++中，这种方法是这样写的： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bounded_rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">rng_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; rng, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> range)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> zeroone = <span class="hljs-number"><span class="hljs-number">0x1</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>p<span class="hljs-number"><span class="hljs-number">-32</span></span> * rng(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> range * zeroone; }</code> </pre> <br>  （请注意， <code>0x1.0p-32</code>是2 <sup>-32</sup>的二进制浮点常数，我们将其用于将间隔[0..2 <sup>32</sup> ]中的随机整数转换为单位间隔中的两倍； 相反，我们可以使用<code>ldexp(rng(), -32)</code>进行这种转换，但是当我对该方法进行基准测试时，结果却慢得多。） <br><br> 这种方法与经典除法方法一样偏斜，但是偏斜出现的方式有所不同。 例如，如果我们选择区间[0..52）中的数字，则数字0、13、26和39的出现频率将比其他数字少一次。 <br><br> 当泛化为64位时，此版本更加令人不快，因为它需要尾数至少为64位的浮点类型。 在具有Linux和macOS的x86机器上，我们可以使用<code>long double</code>来利用具有64位尾数的精度更高的x86浮点数，但是<code>long double</code>并不普遍移植到所有系统上-在某些系统中， <code>long double</code>等于<code>double</code> 。 <br><br> 有一个好的方面-这种方法比具有低位低位的PRNG的残留解决方案要快。 <br><br><h4> 整数乘法（倾斜） </h4><br> 乘法方法可以适用于固定算法而不是浮点算法。 实际上，我们只是不断地乘以2 <sup>32</sup> ， <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> x = rng(); <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(x) * <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(range); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m &gt;&gt; <span class="hljs-number"><span class="hljs-number">32</span></span>; }</code> </pre> <br> 这个版本似乎需要64位算术运算，在x86处理器上，一个好的编译器会将这段代码编译为32位<code>mult</code>指令（这给了我们两个32位输出值，其中一个是返回值）。 可以期望该版本很快，但是它的偏斜与浮点数相乘的方法完全一样。 <br><br><h4> 掉落分割（无偏斜） </h4><br> 我们可以将浮点乘法方案修改为基于除法的方案。 代替乘以<code>x * range / 2**32</code>我们计算<code>x / (2**32 / range)</code> 。 由于我们正在使用整数算术，因此此版本中的舍入将以不同方式执行，有时会生成超出所需间隔的值。 如果我们丢弃这些值（例如，摆脱它们并生成新值），那么结果就是我们得到了一种没有失真的技术。 <br><br> 例如，在使用32位PRNG拔出卡的情况下，我们可以生成一个32位编号并将其除以2 32/52 = 82595524，以选择卡。 如果32位PRNG中的随机值小于52×82595524 = 2 32/32-48，则此技术有效。如果PRNR中的随机值是生成器区间上部的最后48个值之一，则需要丢弃它并寻找另一个。 <br><br> 我们针对该版本的代码使用了一种技巧，即不使用64位数学运算就将2 <sup>32</sup>除以<code>range</code> 。 为了直接计算<code>2**32 / range</code>我们需要表示数字2 <sup>32</sup> ，该数字太大（乘以1！），不能表示为32位整数。 取而代之的是，我们考虑到对于无符号整数，一元取反运算<code>range</code>计算出的正值为2 <sup>32</sup> - <code>range</code> ； 将该值除以<code>range</code> ，得到的响应小于<code>2**32 / range</code> 。 <br><br> 因此，用于使用除法和除法生成数字的C ++代码如下所示： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-comment"><span class="hljs-comment">// calculates divisor = 2**32 / range uint32_t divisor = ((-range) / range) + 1; if (divisor == 0) // overflow, it's really 2**32 return 0; for (;;) { uint32_t val = rng() / divisor; if (val &lt; range) return val; } }</span></span></code> </pre> <br> 当然，此方法需要两个基于除法的慢速运算，通常比其他算术运算要慢，因此您不应期望它很快。 <br><br><h4> 除法的其余部分（双精度）-OpenBSD技术 </h4><br> 我们也可以采用drop方法消除经典除法余数方法中的偏斜。 在使用纸牌的示例中，我们再次需要删除48个值。 在此版本中，我们（等效地）丢弃<em>前</em> 48个值，而不是丢弃<em>后</em> 48个值。 <br><br> 这是这种方法在C ++中的实现： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-comment"><span class="hljs-comment">// calculates 2**32 % range uint32_t t = (-range) % range; for (;;) { uint32_t r = rng(); if (r &gt;= t) return r % range; } }</span></span></code> </pre> <br> 该技术消除了偏斜，但是它需要两个耗时的除法运算以及每个输出值的其余部分（并且您可能需要一个内部生成器来创建多个数字）。 因此，应该预期该方法将比经典的偏斜方法慢大约两倍。 <br><br>  <a href=""><code> arc4random_uniform</code> OpenBSD <code> arc4random_uniform</code></a> （在OS X和iOS上也使用）使用此策略。 <br><br><h4> 除法的余数（单个）-不偏斜-Java方法 </h4><br>  Java使用一种不同的方法在仅使用一个余数除法运算的间隔中生成数字，但极少数情况下会丢弃结果。 代码： <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bounded_rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rng_t&amp; rng, uint32_t range)</span></span></span><span class="hljs-function"> </span></span>{ uint32_t x, r; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { x = rng(); r = x % range; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (x - r &gt; (-range)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r; }</code> </pre> <br> 要了解此选项为何起作用，您需要考虑一下。 与以前的版本不同，该版本基于残差，该残差通过从内部生成引擎中删除部分最低值来消除偏差，而该版本从引擎间隔的上部滤除值。 <br><br><h4> 斜整数乘法-Lemira方法 </h4><br> 就像我们从除法的其余部分中消除偏差一样，我们可以消除整数乘法技术中的偏差。 该技术是Lemyr发明的。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> t = (-range) % range; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> x = rng(); <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(x) * <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(range); <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> l = <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>(m); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (l &lt; t); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m &gt;&gt; <span class="hljs-number"><span class="hljs-number">32</span></span>; }</code> </pre> <br><h4> 放置位掩码（无歪斜）-Apple技术 </h4><br> 在我们的最后一种方法中，除法和余数运算被完全消除。 取而代之的是，它使用简单的屏蔽操作来获得间隔[0..2 <sup><em>k</em></sup> ）中的随机数，其中<em>k</em>是最小值，使得2 <sup><em>k</em></sup>大于该间隔。 如果该值对于我们的间隔而言太大，我们将其丢弃并尝试获取另一个。 代码如下所示： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> mask = ~<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); --range; mask &gt;&gt;= __builtin_clz(range|<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { x = rng() &amp; mask; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (x &gt; range); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; }</code> </pre> <br> 苹果公司（在macOS Sierra版本中）对<code>arc4random_uniform</code>代码进行<a href="">了自己的修订</a>时，采用了这种方法。 <br><br><h3> 对标基本技术 </h3><br> 现在，我们可以评估几种方法。 不幸的是，当我们担心单个部门的成本时，基准测试就变得不容易了。 没有基准可以考虑到影响应用领域的所有因素，并且不能保证您的应用的最佳选择肯定是我的最佳选择。 <br><br> 我们使用三个基准，并使用许多不同的PRNG进行测试。 <br><br><h4> 基准大洗牌 </h4><br> 可能最明显的基准是混合。 在此基准测试中，我们模拟执行大规模混合。 为了对大小为<em>N</em>的数组进行排序<em>，</em>我们必须在[0 .. <em>N</em> ），[0 ..（ <em>N</em> -1）），...，[0..1）的间隔中生成数字。 在此基准测试中，我们将假设<em>N</em>是最大可能数（对于<code>uint32_t</code>它是2 <sup>32</sup> -1）。 代码： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0xffffffff</span></span>; i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; --i) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bval = bounded_rand(rng, i); assert(bval &lt; i); sum += bval; }</code> </pre> <br> 请注意，我们通过将每个数字加到<code>sum</code> “使用”每个数字（这样它就不会被优化丢弃），但是我们不会执行任何混合操作来关注数字的生成。 <br><br> 对于测试64位生成，我们有一个类似的测试，但是执行与混合大小为2 64-1的数组相对应的测试是不切实际的（因为要完成这个更大的基准需要花费数千年的时间）。 取而代之的是，我们跨越了整个64位间隔，但是生成的输出值数量与32位测试中的数量相同。 代码： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0xffffffff</span></span>; i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; --i) { <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> bound = (<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(i)&lt;&lt;<span class="hljs-number"><span class="hljs-number">32</span></span>) | i; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> bval = bounded_rand(rng, bound ); assert(bval &lt; bound); sum += bval; }</code> </pre> <br><h5> 梅森涡旋结果 </h5><br> 下面显示的结果证明了对于使用Mersenne涡旋并在32位代码（使用<code>libstdc++</code> <code>std::mt19937</code> ）和类似的64位代码（使用<code>libstdc++</code> <code>std:mt19937_64</code> ）进行测试时，我们测试的每种方法的基准性能） 结果是具有不同种子值的15次运行的几何平均值，然后对其进行归一化，以便经典除法余数方法具有单个运行时间。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b9f/3eb/53f/b9f3eb53f894a14ac2698f44090b23a6.svg"></div><br> 似乎我们对性能有明确的答案-似乎您可以构建用于完善性能的技术，并询问自己<code>libstdc++</code>开发人员在编写如此糟糕的32位数字实现时在考虑什么。 但是，与基准测试一样，情况比这些结果看上去要复杂得多。 首先，存在结果可能特定于梅森涡旋的风险，因此我们将扩展许多经过测试的PRNG。 其次，基准本身可能存在一个细微的问题。 让我们首先处理第一个问题。 <br><br><h5> 不同PRNG的结果 </h5><br> 我们将使用<code>arc4_rand32</code> ， <code>chacha8r</code> ， <code>gjrand32</code> ， <code>jsf32</code> ， <code>mt19937</code> ， <code>pcg32</code> ， <code>pcg32_fast</code> ， <code>sfc32</code> ， <code>splitmix32</code> ， <code>xoroshiro64+</code> ， <code>xorshift*64/32</code> 64/ <code>xoshiro128+</code> ， <code>xoshiro128+</code>和<code>xoshiro128**</code>和带有<code>gjrand64</code> 64位<code>gjrand64</code>来测试32位<code>arc4_rand32</code> <code>jsf64</code> ， <code>mcg128</code> ， <code>mcg128_fast</code> ， <code>mt19937_64</code> ， <code>pcg64</code> ， <code>pcg64_fast</code> ， <code>sfc64</code> ， <code>splitmix64</code> ， <code>xoroshiro128+</code> ， <code>xorshift*128/64</code> <code>xoshiro256+</code> / <code>xoshiro256*</code> ， <code>xoshiro256+</code>和<code>xoshiro256*</code> 。 这些套件将为我们提供一些缓慢的PRN和许多非常快速的PRN。 <br><br> 结果如下： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2dc/8c8/f1a/2dc8c8f1af9aa517a92260e7cbd3a73e.svg"></div><br> 我们可以看到Mersenne涡旋产生的关键差异。 更快的PRNG将平衡移向边界代码，因此不同方法之间的差异变得更加明显，尤其是在64位PRNR的情况下。 随着<code>libstc++</code>实现<code>libstc++</code>那么可怕。 <br><br><h5> 结论 </h5><br> 在此基准测试中，基于乘以偏差的方法在速度上是有优势的。 在许多情况下，相对于PRNG的大小，边界会很小，并且性能绝对至关重要。 在这种情况下，轻微的偏差不太可能产生明显的效果，但PRNG速度会有所提高。 一个这样的例子是带有随机参考点的Quicksort。 在偏斜方法中，位掩码技术看起来很有希望。 <br><br> 但是，在做出严肃的结论之前，我们需要指出该基准测试的巨大问题-大部分时间都花在非常高的边界上，这很可能会给较大的间隔过分重视。 因此，我们需要转到第二个基准。 <br><br><h4> 基准小洗牌 </h4><br>     ,     « » (). : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">0xffff</span></span>; ++j) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0xffff</span></span>; i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; --i) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bval = bounded_rand(rng, i); assert(bval &lt; i); sum += bval; } }</code> </pre> <br><h5>    </h5><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c5/d3b/4bd/6c5d3b4bdb5f2e45cd805a051d79ab9a.svg"></div><br><h5>    </h5><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45a/9ae/8c0/45a9ae8c040cb4d297fe82f00fa06e3c.svg"></div><br><h5> 结论 </h5><br>                ,      . <br><br><h4>     </h4><br>     ,     ;        ,    ,     . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bit = <span class="hljs-number"><span class="hljs-number">1</span></span>; bit != <span class="hljs-number"><span class="hljs-number">0</span></span>; bit &lt;&lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">0x1000000</span></span>; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bound = bit | (i &amp; (bit - <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bval = bounded_rand(rng, bound); assert(bval &lt; bound); sum += bval; } }</code> </pre> <br><h5>    </h5><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f34/65c/447/f3465c447f9b19b430bb43533a655c2f.svg"></div><br><h5>    </h5><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64b/c58/2a2/64bc582a2fde24fd0faedbeaabb9f64c.svg"></div><br><h5> 结论 </h5><br>      .     ,      ,     , ,    . <br><br>      ,      ,          . <br><br><h3>   </h3><br>             , -     ,    .   ,       . <br><br><h4>       </h4><br>          , : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-comment"><span class="hljs-comment">// calculates 2**32 % range uint32_t t = (-range) % range; for (;;) { uint32_t r = rng(); if (r &gt;= t) return r % range; } }</span></span></code> </pre> <br>  <code>range</code>       ,     <em> </em> .         ,     ,        . <br><br>      : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> r = rng(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (r &lt; range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> t = (-range) % range; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (r &lt; t) r = rng(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r % range; }</code> </pre> <br>       « Mod  » (. ),   «   ».   ,       (   ). <br><br><h5>   Large-Shuffle </h5><br>        64-  (  mod  ),         32- .   ,       . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb4/61d/b52/bb461db52be4a7d983dd7f97844179c0.svg"></div><br><h5>   Small-Shuffle </h5><br>   ,      small-shuffle      ,       .            .     (OpenBSD)        (Java). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f07/2bd/fe2/f072bdfe2660cf0f8789b124a8f02646.svg"></div><br><h5>      </h5><br>          . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/219/b1d/add/219b1daddfa6a55a2cb485b3ae774016.svg"></div><br> ,       :        . <br><br><h4>     </h4><br>    <code>a % b</code>  ,   ,  <code>a &lt; b</code>    <code>a</code> ,    .   <code>a/2 &lt; b</code> ,    <code>a - b</code> . ,   <br><br><pre> <code class="cpp hljs">a %= b;</code> </pre> <br>    <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &gt;= b) { a -= b; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &gt;= b) a %= b; }</code> </pre> <br>    ,                . <br><br><h5>   Large-Shuffle </h5><br>        large-shuffle.      64- ,     .      (  OpenBSD)            . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c56/e1a/669/c56e1a669836477e46f870bd1bc7a6c9.svg"></div><br>      -  ,         . <br><br><h5>   Small-Shuffle </h5><br>        small-shuffle,      ,     .    ,     . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fa/4db/b65/6fa4dbb65b9a3f6c6f9e8ba4f7b455db.svg"></div><br><h5>      </h5><br>        . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0e/ae7/758/e0eae77583cc457a9e923540ad954257.svg"></div><br><h4> :    </h4><br>              ,           .               . <br><br><h5>    32-  </h5><br>      32-  ,       ,    32-  : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21b/913/a41/21b913a412f4fcae1d02afabc90b236c.svg"></div><br>   ,   ,  <code>pcg32_fast</code>      —      Xoroshiro (    ).     ,     -       —      .  ,           5%,   ,     «». <br><br><h5>    64-  </h5><br>      64-  ,       ,    32-  .   ,     32-  ,          64-   ,   32- . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/928/16c/b24/92816cb249e7f76c4ed4e11c65f67475.svg"></div><br>   ,  <code>mcg128_fast</code>  ,          5%,       . <code>pcg64</code>  <code>pcg64_fast</code>    <code>mcg128_fast</code> ,       128-    (, LCG)  128-    (, MCG).   ,          , <code>pcg64</code>    20%  64-  . <br><br>     ,     ,      64- ,  64-   ,  32-. <br><br><h3> 结论 </h3><br>      ,       (, 32-  )          45%.                     66%;  ,      . <br><br>    ( ) —    (   ).  : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> x = rng(); <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(x) * <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(range); <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> l = <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>(m); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (l &lt; range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> t = -range; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t &gt;= range) { t -= range; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t &gt;= range) t %= range; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (l &lt; t) { x = rng(); m = <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(x) * <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(range); l = <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>(m); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m &gt;&gt; <span class="hljs-number"><span class="hljs-number">32</span></span>; }</code> </pre> <br>         ,          . <br><br><h3> :    </h3><br>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub</a> .     23   <code>bounded_rand</code>   26   (13 32-   13 64-),    (GCC 8  LLVM 6),    26 * 23 * 2 = 1196  ,       15 seed,   1196 * 15 = 17 940   ,       .       48-     Xeon E7-4830v3   2,1 .          . <br><br>        . ,    <code>jsf32.STD-libc++</code> ,   — <code>mt19937.BIASED_FP_MULT_SCALE</code> .   3,    69,6%  .            . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN455702/">https://habr.com/ru/post/zh-CN455702/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN455692/index.html">ASZP：重新造型或剧院开始于衣架</a></li>
<li><a href="../zh-CN455694/index.html">下一代计费架构：过渡到Tarantool</a></li>
<li><a href="../zh-CN455696/index.html">未来的电子状态。 第二部分</a></li>
<li><a href="../zh-CN455698/index.html">《 JavaScript的工作原理》一书</a></li>
<li><a href="../zh-CN455700/index.html">帮助我们优化前端的4个技巧</a></li>
<li><a href="../zh-CN455710/index.html">为什么我们在勒罗伊·梅林（Leroy Merlin）需要我们自己的俄罗斯开发部门来容纳200人</a></li>
<li><a href="../zh-CN455714/index.html">使用IFTTT和Django自动将Google表单导出到概念</a></li>
<li><a href="../zh-CN455716/index.html">15个部署商业智能软件的最佳实践</a></li>
<li><a href="../zh-CN455720/index.html">我们如何为广告系统构建UI</a></li>
<li><a href="../zh-CN455722/index.html">Python占用大量内存或如何减少对象的大小？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>