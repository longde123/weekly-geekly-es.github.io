<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚶🏻 🧚🏾 🎎 Affichage de texte Android 👩🏿‍🏫 👊🏿 👩🏻‍🤝‍👨🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'affichage d'informations textuelles est probablement la partie la plus fondamentale et la plus importante de nombreuses applications Android. Cet ar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Affichage de texte Android</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redmadrobot/blog/461787/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/mc/2_/_o/mc2__o7rq1m6ex9alol6ivz5vey.png"></div><br><p>  L'affichage d'informations textuelles est probablement la partie la plus fondamentale et la plus importante de nombreuses applications Android.  Cet article parlera de TextView.  Chaque développeur, à commencer par «Hello World», est constamment confronté à cet élément d'interface utilisateur.  De temps en temps, lorsque vous travaillez avec du texte, vous devez penser à implémenter diverses solutions de conception ou à améliorer les performances lors du rendu de l'écran. </p><br><p>  Je vais parler du périphérique TextView et de certaines subtilités de son utilisation.  Des conseils clés ont été tirés de rapports sur les anciennes E / S Google </p><a name="habracut"></a><br><h1 id="textview-pod-kapotom">  TextView sous le capot </h1><br><p>  Pour le rendu de texte dans Android, une pile entière de bibliothèques différentes est utilisée sous le capot.  Ils peuvent être divisés en deux parties principales - le code java et le code natif: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hb/p0/gg/hbp0ggycnpeisn8v8hwyqkkmvfq.png" width="800"></div><br><p>  Le code Java fait essentiellement partie du SDK Android disponible pour les développeurs d'applications et ses nouvelles fonctionnalités peuvent être portées vers la bibliothèque de support. </p><br><p>  Le noyau TextView lui-même est écrit en C ++, ce qui limite le portage à la bibliothèque de support des nouvelles fonctionnalités implémentées à partir de nouvelles versions du système d'exploitation.  Le noyau est constitué des bibliothèques suivantes: </p><br><ul><li>  Minikin est utilisé pour mesurer la longueur du texte, des sauts de ligne et des mots par syllabes. </li><li>  ICU fournit un support Unicode. </li><li>  HarfBuzz trouve pour les caractères Unicode les éléments graphiques (glyphes) correspondants dans les polices. </li><li>  FreeType crée des bitmaps de glyphes. </li><li>  Skia est un moteur pour dessiner des graphiques 2D. </li></ul><br><h2 id="izmerenie-dliny-teksta-i-perenos-strok">  Mesurer la longueur du texte et les sauts de ligne </h2><br><p>  Si vous passez la ligne à la bibliothèque Minikin, qui est utilisée à l'intérieur de TextView, la première chose qu'elle détermine est de savoir quels glyphes la ligne se compose: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qt/1o/uk/qt1ouktu4gn9x0wncbgiy2a7qkg.png" width="800"></div><br>
<p> Comme vous pouvez le voir dans cet exemple, faire correspondre les caractères Unicode avec les glyphes ne sera pas toujours un à un: ici, 3 caractères à la fois correspondront à un glyphe ffi.  De plus, il convient de noter que les glyphes nécessaires peuvent être trouvés dans différentes polices système. </p><br><p>  Trouver des glyphes uniquement dans les polices système peut entraîner des difficultés, en particulier si les icônes ou les emojis sont affichés à travers les caractères, et il est censé combiner les caractères de différentes polices sur une seule ligne.  Par conséquent, à partir d' <strong>Android Q (29)</strong> , il est devenu possible de créer votre propre liste de polices fournies avec l'application.  Cette liste sera utilisée pour rechercher des glyphes: </p><br><pre> <code class="kotlin hljs">textView.typeface = TypeFace.CustomFallbackBuilder( FontFamily.Builder( Font.Builder(assets, “lato.ttf”).build() ).build() ).addCustomFallback( FontFamily.Builder( Font.Builder(assets, “kosugi.ttf”).build() ).build() ).build()</code> </pre> <br><p>  Désormais, à l'aide de <code>CustomFallbackBuilder</code> lors de la mise en correspondance de caractères avec des glyphes, le SDK <code>CustomFallbackBuilder</code> la famille de polices spécifiée dans l'ordre, et s'il est introuvable, la recherche se poursuit dans les polices système (et grâce à la méthode <code>setSystemFallback()</code> , vous pouvez spécifier la famille de polices système préférée).  <code>CustomFallbackBuilder</code> a une limite sur le nombre de familles de polices - vous ne pouvez pas ajouter plus de 64 polices. </p><br><p>  La bibliothèque Minikin divise les chaînes en mots et mesure les mots individuels.  Pour accélérer le travail, en commençant par <strong>Lollipop (21)</strong> , un cache système <abbr title="moins récemment utilisé">LRU</abbr> de mots est utilisé.  Un tel cache donne un énorme gain de performances: un appel à <code>Paint.measureText()</code> pour un mot mis en cache prendra en moyenne 3% du temps lors du premier calcul de sa taille. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/d2/f1/om/d2f1omfjlqmmfqalip3whmes-1o.png" width="800"></div><br><p>  Si le texte ne correspond pas à la largeur spécifiée, Minikin organise les sauts de ligne et les mots dans le texte.  À partir de <strong>Marshmallow (23),</strong> vous pouvez contrôler son comportement en spécifiant les attributs spéciaux <code>breakStrategy</code> et <code>hyphenationFrequency</code> pour TextView. </p><br><p>  Avec la valeur <code>breakStrategy=simple</code> bibliothèque arrangera simplement les tirets séquentiellement, en passant par le texte: dès que la ligne cesse de tenir, la césure est placée avant le dernier mot. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/im/lc/cr/imlccruuhjr59qzrtpwjmrf6hhk.png" width="600"></div><br><p>  Dans la valeur <code>balanced</code> bibliothèque essaiera de faire des sauts de ligne afin que les lignes soient alignées en largeur. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/v5/ys/kc/v5yskcuiwypdyponmrdqep7zaq8.png" width="600"></div><br><p>  <code>high_quality</code> a presque le même comportement que <code>balanced</code> , à l'exception de quelques différences (l'une d'entre elles: sur l'avant-dernière ligne, la césure peut être non seulement des mots séparés, mais aussi des mots par syllabes). </p><br><p>  L'attribut <code>hyphenationFrequency</code> permet de contrôler la stratégie d'habillage des mots par syllabes.  Une valeur <code>none</code> ne fera pas de césure automatique, <code>normal</code> fera une petite fréquence de césure et <code>full</code> , en conséquence, utilisera le nombre maximum de mots. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ng/cr/hs/ngcrhsphklaxxe842klpnx8mhnw.png" width="600"></div><br><p>  Performances de rendu du texte en fonction des indicateurs sélectionnés (mesurées sur <strong>Android P (28)</strong> ): </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tx/5r/33/tx5r339s93s1nq6go8hieqhv6fq.png" width="600"></div><br><p>  Compte tenu d'une performance assez forte, les développeurs de Google, à partir de la version <strong>Q (29)</strong> et d' <strong>AppCompat 1.1.0</strong> , ont décidé de désactiver la césure par défaut.  Si l'habillage de mots est important dans l'application, vous devez maintenant l'activer explicitement. </p><br><p>  Lors de l'utilisation de l'habillage de mots, il faut tenir compte du fait que la langue actuellement sélectionnée dans le système d'exploitation affectera le fonctionnement de la bibliothèque.  Selon la langue, le système sélectionnera des dictionnaires spéciaux avec des règles de transfert. </p><br><h1 id="stili-teksta">  Styles de texte </h1><br><p>  Il existe plusieurs façons de styliser du texte dans Android: </p><br><ul><li>  <strong>Un style unique</strong> qui s'applique à l'ensemble de l'élément TextView. </li><li>  <strong>Multi-style (multi style)</strong> - plusieurs styles à la fois, qui peuvent être appliqués au texte, au niveau du paragraphe ou des caractères individuels.  Il existe plusieurs façons de procéder: <br><ul><li>  dessin de texte sur toile </li><li>  balises html </li><li>  éléments de balisage spéciaux - étendues </li></ul></li></ul><br><p>  Un style unique implique l'utilisation de styles XML ou d'attributs XML dans le balisage TextView.  Dans ce cas, le système appliquera les valeurs des ressources dans l'ordre suivant: Apparence du texte, thème (Thème), style par défaut (Style par défaut), style de l'application, et la priorité la plus élevée est les valeurs des attributs View. </p><br><p>  L'utilisation des ressources est une solution assez simple, mais, malheureusement, elle ne vous permet pas d'appliquer du style à certaines parties du texte. </p><br><p>  Les balises HTML sont une autre solution simple qui fournit des fonctionnalités telles que la mise en gras de mots individuels, l'italique ou même la mise en évidence de listes avec des points dans le texte.  Tout ce dont le développeur a besoin est d'appeler la méthode <code>Html.fromHtml()</code> , qui transformera le texte balisé en texte balisé par des étendues.  Mais cette solution a des capacités limitées, car elle ne reconnaît qu'une partie des balises html et ne prend pas en charge les styles CSS. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> text = <span class="hljs-string"><span class="hljs-string">"My text &lt;ul&gt;&lt;li&gt;bullet one&lt;/li&gt;&lt;li&gt;bullet two&lt;/li&gt;&lt;/ul&gt;"</span></span> myTextView.text = Html.fromHtml(text)</code> </pre> <br><p>  Différentes méthodes de style TextView peuvent être combinées, mais il convient de se rappeler la priorité d'une méthode particulière, qui affectera le résultat final: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zm/hr/hl/zmhrhluqvvcv77s1b85gkxbtcww.png" width="400"></div><br><p>  Une autre façon - dessiner du texte sur la toile - donne au développeur un contrôle total sur la sortie de texte: par exemple, vous pouvez dessiner du texte le long d'une ligne courbe.  Mais une telle solution, selon les exigences, peut être assez difficile à mettre en œuvre et dépasse le cadre de cet article. </p><br><h1 id="spans">  Portées </h1><br><p>  TextView utilise des étendues pour affiner les styles.  En utilisant des étendues, vous pouvez changer la couleur d'une plage de caractères, faire une partie du texte sous forme de liens, changer la taille du texte, dessiner un point devant un paragraphe, etc. </p><br><p>  On peut distinguer les catégories de portées suivantes: </p><br><ul><li>  <strong>Portées de caractères</strong> - appliquées au niveau des caractères d'une chaîne. <br><ul><li>  <strong>Apparence affectant</strong> - ne modifiez pas la taille du texte. </li><li>  <strong>Affectation métrique</strong> - redimensionner le texte. </li></ul></li><li>  <strong>Portées de paragraphe</strong> - appliquées au niveau du paragraphe. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zy/os/x2/zyosx2ovroe15y3bd94qridaaou.png"></div><br><p>  Le framework Android a des interfaces et des classes abstraites avec des méthodes qui sont appelées pendant <code>onMeasure()</code> et le rendu de TextView, ces méthodes permettent aux travées d'accéder à des objets de niveau inférieur comme <code>TextPaint</code> et <code>Canvas</code> .  En utilisant l'étendue, le framework Android vérifie quelles interfaces cet objet implémente pour appeler les méthodes nécessaires. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fv/do/er/fvdoerpx8zxykjxvt9ru4kigica.png" width="600"></div><br><p>  Le cadre Android définit environ 20+ portées, donc avant de créer le vôtre, il est préférable de vérifier si le SDK convient. </p><br><h3 id="appearance-vs-metric-affecting-spans">  Apparence vs métrique affectant les portées </h3><br><p>  La première catégorie de plages affecte l'apparence des caractères de la chaîne: couleur des caractères, couleur d'arrière-plan, caractères soulignés ou barrés, etc.  Ces <code>UpdateAppearance</code> implémentent l'interface <code>UpdateAppearance</code> et héritent de la classe <code>CharacterStyle</code> , qui permet d'accéder à l'objet <code>TextPaint</code> . </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/or/8f/zl/or8fzltp5mvoyhvdey8tz1uoqhg.png"></div><br><p>  Les mesures affectant la durée affectent la taille du texte et de la mise en page.Par conséquent, l'utilisation d'une telle durée nécessite non seulement de redessiner le TextView, mais également l'appel de <code>onMeasure()</code> / <code>onLayout()</code> .  Ces plages sont généralement héritées de la classe <code>MetricAffectingSpan</code> , qui hérite du <code>CharacterStyle</code> mentionné ci-dessus. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_h/hs/hd/_hhshd0pcadvdievngojmtsqzlu.png"></div><br><h2 id="character-vs-paragraph-affecting-spans">  Caractère vs paragraphe affectant les portées </h2><br><p>  La portée du paragraphe affecte un bloc de texte entier: il peut modifier l'alignement, le retrait ou même insérer un point au début d'un paragraphe.  Ces plages doivent être héritées de la classe <code>ParagraphStyle</code> et insérées dans le texte exactement du début du paragraphe jusqu'à sa fin.  Si la plage est incorrecte, la plage ne fonctionnera pas. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/76/_n/uj/76_nujhr8rrwz-mne8bgq8p2pfu.png"></div><br><p>  Sur Android, les paragraphes sont considérés comme la partie du texte séparée par des retours à la ligne ( <code>\n</code> ). </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/s1/p1/kq/s1p1kq9esdaakdpwh_rkxdvdygw.png"></div><br><h2 id="napisanie-svoih-spanov">  Écrire vos échelles </h2><br><p>  Lors de l'écriture de vos propres plages, vous devez décider de ce que la plage affectera afin de choisir de quelle classe hériter: </p><br><ul><li>  Affecte le texte au niveau du caractère -&gt; <code>CharacterStyle</code> </li><li>  Affecte le texte au niveau du paragraphe -&gt; <code>ParagraphStyle</code> </li><li>  Affecte l'affichage du texte → <code>UpdateAppearance</code> </li><li>  Affecte la taille du texte - <code>UpdateLayout</code> </li></ul><br><p>  Voici un exemple de durée pour changer la police: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomTypefaceSpan</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> font: Typeface?) : MetricAffectingSpan() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateMeasureState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(textPaint: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">TextPaint</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = update(textPaint) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateDrawState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(textPaint: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">TextPaint</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = update(textPaint) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(textPaint: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">TextPaint</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { textPaint.apply { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> old = typeface <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> oldStyle = old?.style ?: <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> font = Typeface.create(font, oldStyle) typeface = font <span class="hljs-comment"><span class="hljs-comment">//    } } }</span></span></code> </pre> <br><p>  Imaginez que nous voulons créer notre propre étendue pour mettre en évidence des blocs de code, pour cela, nous modifierons notre étendue précédente - après avoir ajouté la police, nous ajouterons également un changement dans la couleur d'arrière-plan du texte: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodeBlockSpan</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> font: Typeface?) : MetricAffectingSpan() { … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(textPaint: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">TextPaint</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { textPaint.apply { <span class="hljs-comment"><span class="hljs-comment">//    … bgColor = lightGray //    } } }</span></span></code> </pre> <br><p>  Appliquez span au texte: </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//    span spannable.setSpan(CodeBlockSpan(typeface), ...)</span></span></code> </pre> <br><p>  Mais vous pouvez obtenir exactement le même résultat en combinant deux <code>CustomTypefaceSpan</code> : prenez nos précédents <code>CustomTypefaceSpan</code> et <code>BackgroundColorSpan</code> du framework Android: </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//    spannable.setSpan(BackgroundColorSpan(lightGray), ...) //   spannable.setSpan(CustomTypefaceSpan(typeface), ...)</span></span></code> </pre> <br><p>  Ces deux solutions auront une différence.  Le fait est que les plages auto-écrites ne peuvent pas implémenter l'interface <code>Parcelable</code> , contrairement à celles du système. </p><br><p>  Lors de la transmission d'une ligne stylisée via Intent ou le presse-papiers en cas de plage de balisage auto-écrite ne sera pas enregistrée.  Lorsque vous utilisez des étendues du framework, le balisage reste. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/is/nw/uu/isnwuux9cosllp6h0kgawifcepo.png" width="600"></div><br><h2 id="ispolzovanie-spanov-v-tekste">  Utilisation de portées dans le texte </h2><br><p>  Il existe deux interfaces pour le texte stylisé dans le cadre: <code>Spanned</code> et <code>Spannable</code> (avec un balisage inchangé et mutable, respectivement) et trois implémentations: <code>SpannedString</code> (texte inchangé), <code>SpannableString</code> (texte inchangé) et <code>SpannableStringBuilder</code> (texte mutable). </p><br><div class="scrollable-table"><table><thead><tr><th></th><th>  Texte mutable </th><th>  Balisage variable </th></tr></thead><tbody><tr><td>  Chaîne <strong>étendue</strong> </td><td>  non </td><td>  non </td></tr><tr><td>  Chaîne <strong>extensible</strong> </td><td>  non </td><td>  oui </td></tr><tr><td>  <strong>Constructeur Spannablestring</strong> </td><td>  oui </td><td>  oui </td></tr></tbody></table></div><br><p>  <code>SpannableStringBuilder</code> , par exemple, est utilisé dans un <code>EditText</code> qui doit changer de texte. </p><br><p>  Vous pouvez ajouter une nouvelle étendue à une ligne en utilisant la méthode: </p><br><p> <code>setSpan(Object what, int start, int end, int flags)</code> </p> <br><p>  La plage est passée par le premier paramètre, puis la plage d'indices dans le texte est indiquée.  Et le dernier paramètre peut être contrôlé, quel sera le comportement de la plage lors de l'insertion de nouveau texte: si la plage s'étendra au texte inséré au début ou à la fin (si vous insérez un nouveau texte au milieu, la plage s'y appliquera automatiquement, quelles que soient les valeurs d'indicateur) . </p><br><p>  Les classes répertoriées ci-dessus diffèrent non seulement sur le plan sémantique, mais également sur la façon dont elles sont organisées en interne: <code>SpannedString</code> et <code>SpannableString</code> utilisent des tableaux pour stocker des plages, et <code>SpannableStringBuilder</code> utilise une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">arborescence d'intervalles</a> . </p><br><p>  Si vous effectuez des tests pour la vitesse de rendu du texte en fonction du nombre de plages, vous obtiendrez les résultats suivants: lorsque vous utilisez jusqu'à ~ 250 plages consécutives, <code>SpannableString</code> et <code>SpannableStringBuilder</code> fonctionnent approximativement à la même vitesse, mais si les éléments de balisage dépassent 250, <code>SpannableString</code> démarre à perdre.  Ainsi, si la tâche consiste à appliquer un style à du texte, alors lors du choix d'une classe, il faut être guidé par des exigences sémantiques: si la ligne et les styles seront modifiables.  Mais si le balisage nécessite plus de 250 étendues, vous devez toujours donner la <code>SpannableStringBuilder</code> à <code>SpannableStringBuilder</code> . </p><br><h2 id="proverka-na-nalichie-spana-v-tekste">  Vérifier la durée dans le texte </h2><br><p>  La tâche se produit périodiquement pour vérifier si une ligne étendue a une étendue spécifique.  Et sur Stackoverflow, vous pouvez trouver ce code: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasSpan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(spanned: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Spanned</span></span></span></span><span class="hljs-function"><span class="hljs-params">, clazz: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Class</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> spans: Array&lt;<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> T&gt; = spanned.getSpans(<span class="hljs-number"><span class="hljs-number">0</span></span>, spanned.length, clazz) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> spans.isNotEmpty() }</code> </pre> <br><p>  Une telle solution fonctionnera, mais elle est inefficace: vous devez parcourir toutes les étendues, vérifier si chacune d'entre elles appartient au type passé, collecter le résultat dans un tableau et, à la fin, vérifier simplement que le tableau n'est pas vide. </p><br><p>  Une solution plus efficace serait d'utiliser la méthode <code>nextSpanTransition()</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasSpan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(spanned: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Spanned</span></span></span></span><span class="hljs-function"><span class="hljs-params">, clazz: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Class</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> limit = spanned.length <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> spanned.nextSpanTransition(<span class="hljs-number"><span class="hljs-number">0</span></span>, limit, clazz) &lt; limit }</code> </pre> <br><h2 id="razmetka-teksta-v-razlichnyh-yazykovyh-resursah">  Balisage de texte dans diverses ressources linguistiques </h2><br><p>  Une telle tâche peut se produire lorsque vous souhaitez mettre en évidence un mot spécifique à l'aide du balisage dans diverses ressources de chaîne.  Par exemple, nous devons mettre en évidence le mot <em>«text»</em> dans la version anglaise et <em>«texto»</em> dans l'espagnol: </p><br><pre> <code class="xml hljs"><span class="hljs-comment"><span class="hljs-comment">&lt;!-- values-en/strings.xml --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"title"</span></span></span><span class="hljs-tag">&gt;</span></span>Best practices for text in Android<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!-- values-es/strings.xml --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">”title”</span></span></span><span class="hljs-tag">&gt;</span></span>Texto en Android: mejores prácticas<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Si vous avez besoin de quelque chose de simple, par exemple, pour surligner le mot en gras, vous pouvez utiliser les balises html habituelles ( <code>&lt;b&gt;</code> ).  Dans l'interface utilisateur, il vous suffit de définir la ressource de chaîne dans TextView: </p><br><pre> <code class="kotlin hljs">textView.setText(R.string.title)</code> </pre> <br><p>  Mais si vous avez besoin de quelque chose de plus complexe, par exemple, changer la police, alors le HTML ne peut plus être utilisé.  La solution consiste à utiliser la <code>&lt;annotation&gt;</code> spéciale.  Cette balise vous permet de définir n'importe quelle paire clé-valeur dans un fichier xml.  Lorsque nous tirons une chaîne des ressources, ces balises sont automatiquement converties en plages d' <code>Annotation</code> , organisées dans le texte avec les clés et les valeurs correspondantes.  Après cela, vous pouvez analyser la liste des annotations dans le texte et appliquer les étendues nécessaires. </p><br><p>  Supposons que nous devons changer la police à l'aide de <code>CustomTypefaceSpan</code> . </p><br><p>  Ajoutez une balise et définissez une clé de <em>«police»</em> et une valeur - le type de police que nous voulons utiliser est <em>«title_emphasis»</em> : <br></p><pre> <code class="xml hljs"><span class="hljs-comment"><span class="hljs-comment">&lt;!-- values-en/strings.xml --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"title"</span></span></span><span class="hljs-tag">&gt;</span></span>Best practices for <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">annotation</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">font</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">”title_emphasis”</span></span></span><span class="hljs-tag">&gt;</span></span>text<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">annotation</span></span></span><span class="hljs-tag">&gt;</span></span> in Android<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!-- values-es/strings.xml --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">”title”</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">annotation</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">font</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">”title_emphasis”</span></span></span><span class="hljs-tag">&gt;</span></span>Texto<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">annotation</span></span></span><span class="hljs-tag">&gt;</span></span> en Android: mejores prácticas<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Tirez la chaîne des ressources, trouvez les annotations avec la touche <em>«police»</em> et organisez les portées: </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//      SpannedString,     span' val titleText = getText(R.string.title) as SpannedString //    val annotations = titleText.getSpans(0, titleText.length, Annotation::class.java) //     SpannableString //      val spannableString = SpannableString(titleText) //     for (annotation in annotations) { //     "font" if (annotation.key == "font") { val fontName = annotation.value //   ,     if (fontName == "title_emphasis") { val typeface = getFontCompat(R.font.permanent_marker) //  span    ,    spannableString.setSpan( CustomTypefaceSpan(typeface), titleText.getSpanStart(annotation), titleText.getSpanEnd(annotation), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE ) } } } styledText.text = spannableString</span></span></code> </pre><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yq/62/mm/yq62mmgvajffkxkzk3qntsnxhw4.png" width="600"></div><br><p>  Il a été mentionné ci-dessus que les <code>Parcelable</code> extérieures au cadre Android ne peuvent pas implémenter <code>Parcelable</code> et sont transmises via Intent.  Mais cela ne s'applique pas aux annotations qui implémentent <code>Parcelable</code> .  Vous pouvez donc passer la chaîne annotée via Intent et analyser exactement de la même manière en organisant vos étendues. </p><br><h1 id="kak-tekst-raspolagaetsya-v-textview">  Comment le texte est placé dans un TextView </h1><br><p>  TextView peut afficher non seulement du texte, mais aussi des images.  Vous pouvez également définir différents retraits devant le texte.  Sous le capot, cela fonctionne pour que TextView crée une classe enfant, Layout, qui est directement responsable de l'affichage du texte.  Il s'agit d'une classe abstraite qui comporte trois implémentations; généralement, vous n'avez pas à travailler directement avec elles, sauf si vous écrivez votre propre contrôle: </p><br><ul><li>  <strong>BoringLayout est</strong> utilisé pour les textes simples, ne prend pas en charge les <strong>sauts de</strong> ligne, RTL et autres, mais il est le plus léger.  TextView l'utilise si le texte respecte toutes les restrictions. </li><li>  <strong>StaticLayout est</strong> utilisé dans TextView pour d'autres cas. </li><li>  <strong>DynamicLayout est</strong> utilisé pour le texte modifiable dans un EditText. </li></ul><br><p>  La mise en page a de nombreuses méthodes qui vous permettent de connaître les différents paramètres du texte affiché: les coordonnées des lignes, la ligne de base, les coordonnées du début et de la fin du texte dans la ligne, etc.  (plus de détails peuvent être trouvés dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> ) </p><br><p>  Ces méthodes peuvent être très utiles.  Par exemple, certains développeurs sont confrontés à la tâche d'extraire une partie du texte en rectangles arrondis et d'essayer de trouver sa solution à travers des étendues qui ne sont pas applicables pour résoudre ce problème. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8b/-2/df/8b-2df4-wo4ghk8tkwss6l48bfy.png" width="300"></div><br><p>  Mais les méthodes de la classe Layout peuvent venir à la rescousse.  Voici un exemple de solution: </p><br><p>  À l'aide d'annotations, nous sélectionnons les mots qui doivent être encerclés dans des rectangles. </p><br><p>  Créez ensuite 4 ressources dessinables pour tous les cas d'habillage de texte, qui doivent être entourées de rectangles: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/q4/ry/oj/q4ryojq_lsj3sdyyehvprallpl8.png" width="600"></div><br><p>  Ensuite, nous trouvons les annotations dont nous avons besoin dans le texte, comme décrit ci-dessus.  Nous avons maintenant les index du début et de la fin d'une telle annotation.  Grâce aux méthodes de mise en page, vous pouvez connaître le numéro de la ligne sur laquelle le texte annoté commence et se termine: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> startLine = layout.getLineForOffset(spanStartIndex) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> endLine = layout.getLineForOffset(spanEndIndex)</code> </pre> <br><p>  Ensuite, vous devez dessiner un ou plusieurs rectangles.  Prenons le cas simple où la partie annotée du texte est apparue sur une seule ligne, alors nous n'avons besoin que d'un rectangle avec quatre coins arrondis.  Définissez ses coordonnées et dessinez: </p><br><pre> <code class="kotlin hljs">... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (startLine == endLine) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lineTop = layout.getLineTop(startLine) <span class="hljs-comment"><span class="hljs-comment">//    val lineBottom = layout.getLineBottom(startLine) //    val startCoor = layout.getPrimaryHorizontal(spanStartIndex).toInt() //    val endCoor = layout.getPrimaryHorizontal(spanEndIndex).toInt() //    //   drawable.setBounds(startCoor, lineTop, endCoor, lineBottom) drawable.draw(canvas) ...</span></span></code> </pre><br><p>  Comme vous pouvez le voir dans cet exemple, Layout stocke de nombreuses informations utiles sur le texte affiché, ce qui peut aider à la mise en œuvre de diverses tâches non standard. </p><br><h1 id="proizvoditelnost-textview">  Performances de TextView </h1><br><p>  TextView, comme toute vue, passe par trois phases lorsqu'il est affiché: <code>onMeasure()</code> , <code>onLayout()</code> et <code>onDraw()</code> .  En même temps, <code>onMeasure()</code> prend le plus de temps, contrairement aux deux autres méthodes: à ce moment, la classe Layout est recréée et la taille du texte est calculée.  Changer la taille du texte (par exemple, changer la police) demande donc beaucoup de travail.  Changer la couleur du texte sera plus léger car il ne nécessite que d'appeler <code>onDraw()</code> .  Comme mentionné ci-dessus, le système dispose d'un cache de mots global avec des tailles calculées.  Si le mot est déjà dans le cache, appeler à nouveau <code>onMeasure()</code> pour cela prendra 11-16% du temps qui aurait été nécessaire pour un calcul complet. </p><br><h2 id="uskorenie-pokaza-teksta">  Accélération du texte </h2><br><p>  En 2015, les développeurs Instagram ont accéléré l'affichage des commentaires sur les photos en utilisant le cache global.  L'idée était de dessiner virtuellement le texte avant de l'afficher à l'écran, «réchauffant» ainsi le cache du système.  Lorsqu'il était temps d'afficher le texte, l'utilisateur le voyait beaucoup plus rapidement, car le texte était déjà mesuré et était dans le cache. </p><br><p>  À partir d' <strong>Android P (28)</strong> , les développeurs de Google ont ajouté à l'API la possibilité d'effectuer la phase de mesure de la taille du texte à l'avance dans le thread d'arrière-plan - <code>PrecomputedText</code> (et le backport pour l'API commençant par <strong>Android I (14)</strong> - <code>PrecomputedTextCompat</code> ).  En utilisant la nouvelle API, 90% du travail sera effectué dans le thread d'arrière-plan. </p><br><p>  Un exemple: </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// UI thread val params: PrecomputedText.Params = textView.getTextMetricsParams() val ref = WeakReference(textView) executor.execute { // background thread val text = PrecomputedText.create("Hello", params) val textView = ref.get() textView?.post { // UI thread val textView = ref.get() textView?.text = text } }</span></span></code> </pre> <br><h2 id="pokaz-bolshogo-teksta">  Afficher le texte en grand </h2><br><p>  Si vous devez afficher un texte volumineux, ne le transférez pas immédiatement vers un TextView.  Sinon, l'application peut cesser de fonctionner en douceur ou se figer complètement, car elle fera beaucoup de travail sur le thread principal pour afficher un texte énorme que l'utilisateur peut même ne pas faire défiler jusqu'à la fin.  La solution consiste à diviser le texte en parties (par exemple, des paragraphes) et à afficher les parties individuelles dans RecyclerView.  Pour une accélération encore plus grande, vous pouvez pré-calculer la taille des blocs de texte à l'aide de PrecomputedText. </p><br><p>  Pour faciliter l'incorporation de PrecomputedText dans RecyclerView, les développeurs Google ont créé des méthodes spéciales <code>PrecomputedTextCompat.getTextFuture()</code> et <code>AppCompatTextView.setTextFuture()</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBindViewHolder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vh: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ViewHolder</span></span></span></span><span class="hljs-function"><span class="hljs-params">, position: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> = getData(position) vh.textView.setTextSize(...) vh.textView.setFontVariationSettings(...) <span class="hljs-comment"><span class="hljs-comment">//    val future = PrecomputedTextCompat.getTextFuture( data.text, vh.textView.getTextMetricsParamsCompat(), myExecutor ) //  future  TextView,      onMeasure() vh.textView.setTextFuture(future) }</span></span></code> </pre> <br><p>   RecyclerView      ,     ,              ,     . </p><br><p>  ,     <code>getTextFuture()</code>     (,   ),     ,   ,    <code>getTextFuture()</code> ,     ,    TextView. </p><br><h2 id="chto-nuzhno-znat-kogda-ustanavlivaesh-tekst-v-textview">   ,     TextView </h2><br><p>    <code>TextView.setText()</code>       : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type == SPANNABLE || movementMethod != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { text = spannableFactory.newSpannable(spannable) <span class="hljs-comment"><span class="hljs-comment">//  } else { text = new SpannedString(spannable) //  }</span></span></code> </pre> <br><p>       span'  TextView,       <code>setText()</code> ,      . </p><br><p>    ,      .  TextView    ,  -,   .    ,      .    ,    ,     TextView   <code>spannableFactory</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MySpannableFactory</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Spannable.Factory</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newSpannable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(source: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">CharSequence</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Spannable { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> source <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? Spannable ?: <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.newSpannable(source) } } textView.spannableFactory = MySpannableFactory()</code> </pre> <br><p>         <code>textView.setText(spannable, BufferType.SPANNABLE)</code> ,      . </p><br><p>  Google         span'  RecyclerView,      . </p><br><p>      TextView,     span,        <code>setText()</code> .      TextView      span. TextView   spannable-    span',  : </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> spannable = textView.getText() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Spannable <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> span = CustomTypefaceSpan(span) spannable.setSpan(span, ...)</code> </pre> <br><p>      span,      TextView,         TextView .       ,   <code>invalidate()</code> ,    – <code>requestLayout()</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> spannable = textView.getText() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Spannable <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> span = CustomTypefaceSpan(span) spannable.setSpan(span, ...) span.setTypeface(anotherTypeface) textView.requestLayout() <span class="hljs-comment"><span class="hljs-comment">// re-measure and re-draw // or textView.invalidate() // re-draw</span></span></code> </pre> <br><h2 id="ispolzovanie-autolink">  autoLink </h2><br><p>  TextView     .         <code>autoLink</code> .   <code>autoLink=”web”</code> TextView          URL          <code>URLSpan</code> .   ,     SDK   <code>setText()</code> : </p><br><pre> <code class="java hljs">spannable = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpannableString(string); Matcher m = pattern.matcher(text); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (...) { <span class="hljs-comment"><span class="hljs-comment">//      String utl = … URLSpan span = new URLSpan(url); spannable.setSpan(span, ...); }</span></span></code> </pre> <br><p>      UI ,     <code>autoLink=”web”</code>   RecyclerView.          .        <code>LinkifyCompat</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,       background thread val spannable = SpannableString(string) LinkifyCompat.addLinks(spannable, Linkify.WEB_URLS) //   RecyclerView override fun onBindViewHolder(holder: ViewHolder, position: Int) { holder.textView.setText(spannable, BufferType.SPANNABLE) // ... }</span></span></code> </pre> <br><p>  <code>autoLink</code>      <code>map</code> –    (      <code>all</code> ).       .   ,        WebView,      !    SDK   <code>Linkify.gatherMapLinks()</code>    ,      : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((address = WebView.findAddress(string)) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { ... }</code> </pre> <br><p>   WebView  TODO   SDK: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAddress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String addr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Rewrite this in Java so it is not needed to start up chromium // Could also be deprecated return getFactory().getStatics().findAddress(addr); }</span></span></code> </pre> <br><p>     ?     Smart Linkify,       <strong>Android P (28)</strong> ,          ,      .    : </p><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// UI thread val text: Spannable = … val request = TextLinks.Request.Builder(text) val ref = WeakReference(textView) executor.execute { // background thread TextClassifier.generateLinks(request).apply(text) val textView = ref.get() textView?.post { // UI thread val textView = ref.get() textView?.text = text } }</span></span></code> </pre> <br><p>    Linkify,      .        toolbar   ,     Google . </p><br><p>  Smart Linkify    :  ,    . </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9t/nc/qb/9tncqbkanp8avsnmisd-ax0z7ae.gif" width="300"></div><br><h1 id="magnifier"> Magnifier </h1><br><p>   <strong>Android P (28)</strong> ,     – Magnifier,       .           . </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fi/nn/or/finnor2svtuttfn1v-lxwkblgwm.gif" width="400"></div><br><p>      TextView, EditText  WebView,            :  API <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> . </p><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p>          Android   ,   , : </p><br><ul><li>         </li><li>    </li><li>   ,   TextView (, EditText) </li></ul><br><p>  -     ,      Google I/O'19 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">“Best Practices for Using Text in Android”</a> . </p><br><a name="links"></a><br><h1 id="poleznye-ssylki">  Liens utiles </h1><br><h2 id="stati">  Les articles </h2><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Florina Muntenescu. "Spantastic text styling with Spans"</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Florina Muntenescu. "Underspanding spans"</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Florina Muntenescu. "Styling internationalized text in Android"</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Instagram Engineering. "Improving Comment Rendering on Android"</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Daniel Lee. "Text rendering on Android"</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mariusz Dąbrowski. "What is new in Android P — PrecomputedText"</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Chet Haase. "RecyclerView Prefetch"</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Chris Craik. "Prefetch Text Layout in RecyclerView"</a> </li></ul><br><h2 id="doklady">  Rapports </h2><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Best practices for text on Android (Google I/O '18)</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Use Android Text Like a Pro (Android Dev Summit '18)</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Best Practices for Using Text in Android (Google I/O'19)</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr461787/">https://habr.com/ru/post/fr461787/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr461773/index.html">Airtest IDE - une nouvelle façon de tester l'automatisation des jeux mobiles?</a></li>
<li><a href="../fr461775/index.html">3 cas pour utiliser Celery dans une application Django</a></li>
<li><a href="../fr461779/index.html">80% des données de votre entreprise ne vous sont pas accessibles. Que faire à ce sujet?</a></li>
<li><a href="../fr461781/index.html">"Ycombinator Startup School 2019." Vidéo des trois premières semaines</a></li>
<li><a href="../fr461785/index.html">Inconvénients de RISC-V</a></li>
<li><a href="../fr461793/index.html">Ivan Ponomarev à propos de l'API Kafka Streams lors de la réunion jug.msk.ru</a></li>
<li><a href="../fr461797/index.html">Contes de service. Un article frivole sur le travail sérieux</a></li>
<li><a href="../fr461801/index.html">DisplayPort-LVDS</a></li>
<li><a href="../fr461803/index.html">DVC (Data Version Control): versionnage des données et reproductibilité de l'expérience</a></li>
<li><a href="../fr461805/index.html">Application d'intégration Monte Carlo dans le rendu</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>