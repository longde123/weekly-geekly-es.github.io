<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙌🏾 😋 👩🏻‍🏭 Sekali lagi tentang GCD, algoritma Euclidean dan sedikit tentang sejarah algoritma secara umum. Tentu saja dengan contoh Swift 👩🏿‍💻 💐 🌡️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Algoritma adalah salah satu topik utama dalam pemrograman , mereka ada di mana-mana (terutama dalam wawancara, haha). 


 (Apakah mungkin dilakukan ta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sekali lagi tentang GCD, algoritma Euclidean dan sedikit tentang sejarah algoritma secara umum. Tentu saja dengan contoh Swift</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464949/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Algoritma</a> adalah salah satu topik utama dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pemrograman</a> , mereka ada di mana-mana (terutama dalam wawancara, haha). <br><br><img src="https://habrastorage.org/webt/_t/w8/av/_tw8avywasehzxdtkkheppkltuo.jpeg" alt="gambar"><br>  <i>(Apakah mungkin dilakukan tanpa akordeon tombol di pos seperti itu?)</i> <br><br>  Salah satu yang paling terkenal adalah yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">algoritma Euclidean</a> - mungkin cara paling umum untuk menemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pembagi umum terbesar (GCD) dari</a> dua bilangan bulat non-negatif.  Dia juga sering suka mulai belajar (dan belajar) bagian yang relevan dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">matematika</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ilmu komputer</a> . <a name="habracut"></a><br><br>  Dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Donald Knuth</a> , penulis terkenal risalah "The <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Art of Programming</a> " (dan tidak hanya), bahkan menganggap algoritma sebagai yang pertama dalam sejarah (setidaknya berkenaan dengan definisi modern).  Karena, terlepas dari kenyataan bahwa algoritma tersebut ditemukan dan digunakan sebelumnya, pada kenyataannya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Euclid</a> , yang hidup pada abad IV-III.  BC (sudah disebutkan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Aristoteles</a> , yang hidup seabad sebelumnya), Euclid menggambarkan prosesnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">secara iteratif</a> , yang konsisten dengan makna modern dari kata tersebut. <br><br>  Kata "algoritma" sendiri kembali ke nama ahli matematika Persia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Al-Khwarizmi</a> , yang hidup sekitar abad VIII-IX.  sudah AD.  Dan awal penggunaannya dalam arti dekat dengan yang modern dianggap hanya abad ke-20, lebih tepatnya - dekade pertama, kebangkitan teknologi informasi. <br><br><h2>  Algoritma Euclidean </h2><br>  Demi rasa ingin tahu, saya sarankan Anda membiasakan diri dengan deskripsi Euclidean tentang algoritma dalam pengeditan Knuth.  Itu cukup panjang, karena itu tersembunyi di bawah luka: <br><br><div class="spoiler">  <b class="spoiler_title">Deskripsi algoritma Euclidean dekat dengan aslinya</b> <div class="spoiler_text"><blockquote>  <b>Tawarkan.</b>  Untuk diberikan dua bilangan bulat positif, temukan pembagi umum terbesar mereka. <br><br>  Misalkan A dan C menjadi dua bilangan bulat positif;  Diperlukan untuk menemukan GCD mereka.  Jika angka A dapat dibagi dengan C, maka angka C adalah pembagi umum dari angka C dan A, karena ia membagi dirinya sendiri.  Dan jelas, itu akan menjadi pembagi terbesar, karena tidak ada angka lebih besar dari angka C yang membagi C. <br><br>  Tetapi jika C tidak membagi angka A, maka kita akan terus mengurangi jumlah yang lebih kecil dari angka A dan C dari yang lebih besar sampai kita mendapatkan angka yang benar-benar membagi yang sebelumnya dikurangkan.  Ini harus terjadi cepat atau lambat, karena jika perbedaannya sama dengan satu, maka unit akan membagi sebelumnya dikurangi. <br><br>  Sekarang anggaplah bahwa E adalah sisa positif dari membagi angka A dengan C;  biarkan F menjadi sisa positif dari membagi C dengan E dan biarkan F membagi E. Karena F membagi E dan E membagi C - F, F juga membagi C - F. Tetapi ia juga membagi dirinya sendiri, jadi F membagi C, dan C membagi A - E;  karena itu, F juga membagi A - E, tetapi juga membagi E;  oleh karena itu, F membagi A. Akibatnya, F adalah pembagi umum dari angka A dan C. <br><br>  Sekarang saya menegaskan bahwa itu juga GCD.  Memang, jika F bukan pembagi umum terbesar dari angka A dan C, maka ada angka yang lebih besar yang akan membagi kedua angka-angka ini.  Biarkan nomor tersebut menjadi G. <br><br>  Karena angka G membagi angka C, dan angka C membagi A - E, G juga membagi angka A - E. Angka G juga membagi seluruh angka A, sehingga ia membagi sisanya E. Tetapi E membagi C - F, jadi G juga membagi C - F. Dan angka G juga membagi seluruh angka C, karena ia membagi sisa F;  jadi, jumlah yang lebih besar membagi yang lebih kecil, dan ini tidak mungkin. <br><br>  Dengan demikian, tidak ada angka yang lebih besar dari F yang membagi A dan C;  oleh karena itu, angka F adalah GCD. <br><br>  <b>Konsekuensi</b>  Alasan ini membuat asumsi jelas bahwa setiap angka yang membagi dua angka membagi GCD mereka.  Rt </blockquote></div></div><br><br>  Deskripsi memberikan dua cara untuk menemukan GCD - dengan mengurangi dan membagi.  Sebenarnya, dua metode penerapan algoritma ini sudah dikenal luas saat ini. <br><br>  Berikut adalah contoh fungsi yang ditulis dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Swift</a> yang mengimplementasikan metode pertama: <br><br><pre><code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subtractionGCD</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> firstNumber: Int, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> secondNumber: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> simpleGCD = simpleCasesGCD(firstNumber, secondNumber) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> simpleGCD } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstNumber = firstNumber <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> secondNumber = secondNumber <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> firstNumber != <span class="hljs-number"><span class="hljs-number">0</span></span>, secondNumber != <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> firstNumber &gt; secondNumber { firstNumber = firstNumber - secondNumber } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { secondNumber = secondNumber - firstNumber } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> firstNumber + secondNumber <span class="hljs-comment"><span class="hljs-comment">// One of them is 0. }</span></span></code> </pre> <br>  Di sini, untuk digunakan kembali, demi saya, saya membawa kasus fungsi terpisah untuk mencari GCD, ketika diketahui segera, tanpa perlu mengikuti algoritma apa pun: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">simpleCasesGCD</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> firstNumber: Int, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> secondNumber: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> firstNumber == secondNumber { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> firstNumber <span class="hljs-comment"><span class="hljs-comment">// Any. } if firstNumber == 0 { return secondNumber } if secondNumber == 0 { return firstNumber } return nil }</span></span></code> </pre> <br>  (Jika dua angka sama, maka secara alami GCD mereka juga sama dengan mereka. Jika ada angka yang nol, maka GCD akan sama dengan angka kedua, karena nol dapat dibagi dengan angka apa pun (dengan hasil, tentu saja, juga nol) .) <br><br>  Hanya nilai-nilai non-negatif yang dapat digunakan sebagai input.  Dengan demikian, untuk yang negatif, Anda dapat menggunakan metode yang sama, tetapi mengambil nomor modulo.  (Ya, faktor umum juga bisa negatif, tetapi kami mencari secara khusus untuk GCD, dan angka positif jelas selalu lebih dari negatif.) <br><br>  Dan di sini mungkin terlihat seperti implementasi versi algoritma berdasarkan pembagian: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divisionGCD</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> firstNumber: Int, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> secondNumber: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> simpleGCD = simpleCasesGCD(firstNumber, secondNumber) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> simpleGCD } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstNumber = firstNumber <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> secondNumber = secondNumber <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> firstNumber != <span class="hljs-number"><span class="hljs-number">0</span></span>, secondNumber != <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> firstNumber &gt; secondNumber { firstNumber = firstNumber % secondNumber } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { secondNumber = secondNumber % firstNumber } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> firstNumber + secondNumber <span class="hljs-comment"><span class="hljs-comment">// One of them is 0. }</span></span></code> </pre> <br>  Versi kedua hari ini dianggap lebih disukai, karena mengandung, rata-rata, jumlah langkah yang jauh lebih kecil.  Namun, pada saat komputer besar dan lambat, operasi divisi bisa menjadi prosedur yang kompleks.  Dan kemudian versi pertama dari algoritma bisa lebih efektif. <br><br>  Untuk membandingkannya sedikit, saya melakukan beberapa pengukuran menggunakan metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>measure(_:)</code></a> dari kelas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>XCTestCase</code></a> saya dari kerangka kerja "asli" untuk menguji kode dalam proyek-proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Xcode-</a> proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>XCTest</code></a> . <br><br>  Sebagai input, saya menggunakan array pasangan angka acak.  Pengukuran dilakukan, tentu saja, menggunakan array yang sama untuk setiap metode.  Saya mengambil penyebaran angka untuk pasangan dari nol hingga 9999. Pengukuran dilakukan pada jumlah perhitungan (pasangan angka): satu, sepuluh, 100, 1000, 10.000, 100.000, 1.000.000 dan 10.000.000. Yang terakhir membuat saya mengharapkan hasilnya selama beberapa menit, jadi saya memutuskan untuk melakukannya untuk berhenti. <br><br>  Berikut ini adalah kode pembuatan input sederhana: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pairs = (<span class="hljs-number"><span class="hljs-number">0</span></span>..&lt;<span class="hljs-number"><span class="hljs-number">100</span></span>).<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { <span class="hljs-number"><span class="hljs-number">_</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-type"><span class="hljs-type">Int</span></span>.random(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>..&lt;<span class="hljs-number"><span class="hljs-number">10000</span></span>), <span class="hljs-type"><span class="hljs-type">Int</span></span>.random(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>..&lt;<span class="hljs-number"><span class="hljs-number">10000</span></span>)) } <span class="hljs-comment"><span class="hljs-comment">// Generates 100 pairs.</span></span></code> </pre> <br>  Pengukuran itu sendiri terlihat, misalnya, seperti ini: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testSubstractionGCDPerformance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { measure() { <span class="hljs-number"><span class="hljs-number">_</span></span> = pairs.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { substractionGCD($<span class="hljs-number"><span class="hljs-number">0</span></span>, $<span class="hljs-number"><span class="hljs-number">1</span></span>) } } }</code> </pre> <br>  Dan inilah hasil peluncurannya di komputer saya: <br><br><img src="https://habrastorage.org/webt/q0/ij/na/q0ijna2lnsd2kaw74y0xbvgjsqw.png" alt="gambar"><br>  <i>(Pengurangan - pengurangan, pembagian - pembagian.)</i> <br><br>  Secara umum, sangat jelas terlihat berapa banyak metode pengurangan yang hilang pada komputer modern. <br><br><h3>  "Peningkatan" versi algoritma Euclidean </h3><br>  Dalam literatur Anda dapat menemukan versi algoritma di mana salah satu angka di setiap langkah, bukannya sisa membagi dengan yang kedua, digantikan oleh perbedaan antara offset ini dan angka kedua, tetapi hanya jika sisa divisi lebih dari setengah angka kedua.  Implementasi versi ini mungkin terlihat seperti ini: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">improvedDivisionGCD</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> firstNumber: Int, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> secondNumber: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> simpleGCD = simpleCasesGCD(firstNumber, secondNumber) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> simpleGCD } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstNumber = firstNumber <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> secondNumber = secondNumber <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> firstNumber != <span class="hljs-number"><span class="hljs-number">0</span></span>, secondNumber != <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> firstNumber &gt; secondNumber { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> firstNumberClaim = firstNumber % secondNumber <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> firstNumberClaim &gt; secondNumber / <span class="hljs-number"><span class="hljs-number">2</span></span> { firstNumber = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(firstNumberClaim - secondNumber) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { firstNumber = firstNumberClaim } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> secondNumberClaim = secondNumber % firstNumber <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> secondNumberClaim &gt; firstNumber / <span class="hljs-number"><span class="hljs-number">2</span></span> { secondNumber = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(secondNumberClaim - firstNumber) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { secondNumber = secondNumberClaim } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> firstNumber + secondNumber <span class="hljs-comment"><span class="hljs-comment">// One of them is 0. }</span></span></code> </pre> <br>  Modifikasi seperti itu mengurangi jumlah langkah dalam algoritma, tetapi menilai dari hasil pengukuran pada komputer saya, perhitungan tambahan dan pemeriksaan pada setiap langkah akan menetralisir keunggulan ini dan bahkan lebih: <br><br><img src="https://habrastorage.org/webt/k-/dv/ef/k-dveffrc9dd-75z4evayxdohri.png" alt="gambar"><br>  <i>(Peningkatan adalah versi "perbaikan".)</i> <br><br><h3>  Sedikit lagi tentang pentingnya algoritma Euclidean </h3><br>  Algoritma ini juga memiliki versi geometris (untuk menemukan ukuran terbesar dari dua segmen). <br><br>  Algoritma itu, tentu saja, digeneralisasi untuk menemukan GCD dari sejumlah angka, bukan hanya dua.  Singkatnya, idenya adalah ini: jika kita menetapkan fungsi mencari GCD dari dua angka sebagai gcd (a, b), maka, katakanlah, GCD dari tiga angka gcd (a, b, c) sama dengan gcd (gcd (a, b), c).  Dan seterusnya, untuk sejumlah angka GCD ditemukan dengan secara berurutan menghitung GCD dari GCD dari pasangan angka sebelumnya dan angka berikutnya.  Meskipun, tentu saja, ini menyangkut pencarian GCD secara umum, dan bukan hanya algoritma Euclidean. <br><br>  Ada juga generalisasi dari algoritma untuk menemukan polinomial GCD.  Tapi ini sudah di luar lingkup tulisan sederhana ini, dan sampai batas tertentu, pengetahuan saya tentang matematika. <br><br><h3>  Kompleksitas Algoritma Euclidean </h3><br>  Kompleksitas temporal dari algoritma ini telah diselidiki untuk waktu yang lama, tidak dengan cepat dan oleh orang-orang yang lebih terpelajar daripada pelayan Anda yang rendah hati.  Namun, pertanyaannya telah lama ditutup dan jawaban telah diterima.  Sebenarnya, kembali pada pertengahan abad sebelum yang lalu.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gabriel Lame</a> . <br><br>  Singkatnya, jawabannya dirumuskan, pada kenyataannya, oleh teorema Lame terkait dengan algoritma ini.  Jumlah langkah dalam algoritma akan sama dengan nomor urut angka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fibonacci</a> terdekat yang lebih besar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">, yang</a> terkecil dari dua angka parameter input minus 2. Dengan menggunakan notasi matematika yang sedikit lebih tradisional, maka jika u&gt; v (dan v&gt; 1), maka jumlah lintasan algoritma akan n - 2 untuk v &lt;Fn (Fn adalah bilangan Fibonacci v terdekat, dan n adalah nomor urutnya). <br><br>  Angka-angka Fibonacci tumbuh secara eksponensial, masing-masing, kami memiliki fungsi logaritmik dari waktu eksekusi algoritma (dari yang lebih kecil dari dua angka input). <br><br>  Perhitungan yang sama menunjukkan bahwa data input terburuk untuk algoritma adalah dua angka Fibonacci berturut-turut. <br><br><h2>  Metode biner untuk menemukan NOD </h2><br>  Berbicara tentang pencarian GCD, ada baiknya menyebutkan algoritma yang diusulkan sudah di tahun 60-an abad terakhir oleh Joseph Stein tertentu tentang yang saya tidak menemukan informasi di Web sama sekali.  Ini (algoritma) berorientasi ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aritmatika biner</a> dan tidak mengandung operasi divisi.  Algoritma hanya beroperasi dengan parity check dan separuh, yang layak dengan kemampuan aritmatika biner saja. <br><br>  Algoritma ini didasarkan pada empat fakta: <br><br><ol><li>  Jika u dan v keduanya genap, maka gcd (u, v) = 2 * gcd (u / 2, v / 2); </li><li>  Jika Anda genap dan v tidak, gcd (u, v) = gcd (u / 2, v); </li><li>  gcd (u, v) = gcd (u - v, v) (ini mengikuti dari algoritma Euclidean); </li><li>  Jika u dan v keduanya aneh, maka u - v adalah genap dan | u - v |  &lt;maks (u, v) </li></ol><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Di Wikipedia</a> Anda dapat melihat versi algoritme rekursif (ditulis dalam beberapa baris dalam bahasa pemrograman modern), saya tidak menulis ulang di Swift.  Dan di sini saya memberikan implementasi berulang: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">binaryGCD</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> firstNumber: Int, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> secondNumber: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> simpleGCD = simpleCasesGCD(firstNumber, secondNumber) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> simpleGCD } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstNumber = firstNumber <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> secondNumber = secondNumber <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shift = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (firstNumber | secondNumber) &amp; <span class="hljs-number"><span class="hljs-number">1</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> { shift += <span class="hljs-number"><span class="hljs-number">1</span></span> firstNumber &gt;&gt;= <span class="hljs-number"><span class="hljs-number">1</span></span> secondNumber &gt;&gt;= <span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> firstNumber &amp; <span class="hljs-number"><span class="hljs-number">1</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> { firstNumber &gt;&gt;= <span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">repeat</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> secondNumber &amp; <span class="hljs-number"><span class="hljs-number">1</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> { secondNumber &gt;&gt;= <span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> firstNumber &gt; secondNumber { <span class="hljs-built_in"><span class="hljs-built_in">swap</span></span>(&amp;firstNumber, &amp;secondNumber) } secondNumber -= firstNumber } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> secondNumber != <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> firstNumber &lt;&lt; shift }</code> </pre> <br>  Setelah melakukan pengukuran pada data yang sama, sayangnya, algoritma canggih ini di komputer saya tidak memenuhi harapan yang ada di dalamnya.  Tentu saja, ia masih bekerja dua kali lebih cepat dari algoritma Euclidean dengan pengurangan, tetapi secara nyata lebih rendah daripada versi divisi klasiknya.  Tabel ringkasan lengkap: <br><br><img src="https://habrastorage.org/webt/to/na/vg/tonavg6ye_brn5roqmziys7z9ey.png" alt="gambar"><br>  <i>(Binary adalah algoritma biner.)</i> <br><br>  (Saya tidak mengesampingkan bahwa algoritma dapat ditulis lebih efisien daripada yang saya lakukan, dan ini akan mempengaruhi hasilnya, tetapi untuk apa kita memerlukan kompiler?! <br><br>  Omong-omong, algoritma ini, yang tidak diragukan lagi memperoleh ketenaran selama 15 menit di era teknologi informasi (di bagian yang lebih awal daripada yang sekarang), dikenal di Cina kuno.  Deskripsinya ditemukan dalam karya-karya yang berasal dari abad ke-1.  AD  Tentu saja, dalam istilah seperti "setengah pembagian" dan pengurangan.  Dan juga dalam konteks mengurangi pecahan. <br><br><h2>  Kesimpulan </h2><br>  Jujur, dengan "penelitian" sederhana ini saya tidak akan membuktikan apa pun dan tidak ingin membuat kesimpulan revolusioner (dan saya tidak melakukannya!).  Saya hanya ingin memuaskan rasa ingin tahu saya, melihat karya berbagai pendekatan untuk menyelesaikan masalah klasik, dan sedikit merentangkan jari saya.  Meskipun demikian, saya harap Anda juga penasaran untuk mengamati hasilnya! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id464949/">https://habr.com/ru/post/id464949/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id464933/index.html">Aplikasi untuk e-book di sistem operasi Android. Bagian 4. Game</a></li>
<li><a href="../id464935/index.html">DevOpsSec Nyaman: Nemesida WAF Gratis untuk NGINX dengan API dan akun pribadi</a></li>
<li><a href="../id464937/index.html">Intisari materi menarik untuk pengembang seluler # 312 (pada 19 - 25 Agustus)</a></li>
<li><a href="../id464939/index.html">Menguji @ NonNull / @ Nullable annotations</a></li>
<li><a href="../id464947/index.html">Acara digital di Moskow dari 25 Agustus hingga 1 September</a></li>
<li><a href="../id464951/index.html">Semakin sederhana tugasnya, semakin sering saya salah</a></li>
<li><a href="../id464955/index.html">Iron Mike Tyson dan proyek blockchain Fight to Fame</a></li>
<li><a href="../id464959/index.html">Mengurai kalimat bahasa Rusia</a></li>
<li><a href="../id464961/index.html">Buat komponen visual dalam Unity UI. Sistem partikel</a></li>
<li><a href="../id464963/index.html">Dengan cepat melokalkan masalah kinerja Microsoft SQL Server di Quest Foglight</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>