<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👲🏾 👃🏽 🕴🏾 مميزات العمل والجهاز الداخلي express.js 🛌🏿 🚠 🖇️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="إذا كنت تقوم بالتطوير من أجل node.js للنظام الأساسي ، فربما سمعت عن express.js . هذا هو واحد من أكثر أطر العمل خفيفة الوزن المستخدمة لإنشاء تطبيقات ال...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>مميزات العمل والجهاز الداخلي express.js</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/414079/" style=";text-align:right;direction:rtl"> إذا كنت تقوم بالتطوير من أجل node.js للنظام الأساسي ، فربما سمعت عن <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">express.js</a> .  هذا هو واحد من أكثر أطر العمل خفيفة الوزن المستخدمة لإنشاء تطبيقات الويب للعقدة. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><img src="https://habrastorage.org/webt/bs/np/1r/bsnp1rphnfiib_l1tjzaauvcs48.jpeg"></a> <br><br>  يعرض مؤلف المادة ، التي ننشر ترجمتها اليوم ، دراسة ميزات الهيكل الداخلي للإطار السريع من خلال تحليل شفرة المصدر الخاصة به والنظر في مثال على استخدامه.  وهو يعتقد أن دراسة الآليات التي تقوم عليها مكتبات المصادر المفتوحة الشعبية تساهم في فهم أعمق لها ، وتزيل ستار "الغموض" منها وتساعد على إنشاء تطبيقات أفضل بناءً عليها. <br><a name="habracut"></a><br>  قد تجد أنه من الملائم إبقاء كود المصدر السريع في متناول اليد أثناء قراءة هذه المادة.  يستخدم <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">هذا الإصدار</a> هنا.  يمكنك قراءة هذه المقالة دون فتح الرمز السريع ، حيث يتم هنا هنا ، حيثما كان ذلك مناسبًا ، تقديم أجزاء التعليمات البرمجية لهذه المكتبة.  في تلك الأماكن حيث يتم اختصار الرمز ، <code>// ...</code> تعليقات النموذج <code>// ...</code> <br><br><h2 style=";text-align:right;direction:rtl">  <font color="#3AC1EF">مثال أساسي لاستخدام صريح</font> </h2><br>  بادئ ذي بدء ، دعونا نلقي نظرة على "Hello World!" التقليدية في تطوير تقنيات الكمبيوتر الجديدة - مثال.  يمكن العثور عليه على الموقع الرسمي للإطار ، وسيكون بمثابة نقطة انطلاق في بحثنا. <br><br><pre style=";text-align:right;direction:rtl"> <code class="hljs coffeescript">const express = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'express'</span></span>) const app = express() app.get(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(req, res)</span></span></span><span class="hljs-function"> =&gt;</span></span> res.send(<span class="hljs-string"><span class="hljs-string">'Hello World!'</span></span>)) app.listen(<span class="hljs-number"><span class="hljs-number">3000</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Example app listening on port 3000!'</span></span>))</code> </pre> <br>  يبدأ هذا الرمز خادم HTTP جديدًا على المنفذ 3000 ويرسل <code>Hello World!</code>  للطلبات المستلمة على <code>GET /</code> الطريق.  إذا لم تدخل في التفاصيل ، فيمكننا التمييز بين أربع مراحل لما يحدث ، والتي يمكننا تحليلها: <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  إنشاء تطبيق صريح جديد. </li><li style=";text-align:right;direction:rtl">  إنشاء طريق جديد. </li><li style=";text-align:right;direction:rtl">  بدء خادم HTTP على رقم المنفذ المحدد. </li><li style=";text-align:right;direction:rtl">  معالجة الطلبات الواردة إلى الخادم. </li></ol><br><h2 style=";text-align:right;direction:rtl">  <font color="#3AC1EF">إنشاء تطبيق صريح جديد</font> </h2><br>  يتيح لك الأمر <code>var app = express()</code> إنشاء تطبيق صريح جديد.  إن دالة <code>createApplication</code> من <a href="">ملف lib / express.js</a> هي الوظيفة المصدرة الافتراضية ؛ فنحن الذين نصل إليها باستدعاء وظيفة <code>express()</code> .  إليك بعض الأشياء المهمة التي يجب الانتباه إليها: <br><br><pre style=";text-align:right;direction:rtl"> <code class="hljs powershell">// ... var mixin = require(<span class="hljs-string"><span class="hljs-string">'merge-descriptors'</span></span>); var proto = require(<span class="hljs-string"><span class="hljs-string">'./application'</span></span>); // ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createApplication</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { //    ,     . //     : `function(req, res, next)` var app = function(req, res, next) {   app.handle(req, res, next); }; // ... //  `mixin`    `proto`  `app` //     -  `get`,     . mixin(app, proto, false); // ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> app; }</code> </pre> <br>  يعد كائن <code>app</code> إرجاعه من هذه الوظيفة أحد الكائنات المستخدمة في رمز التطبيق الخاص بنا.  تمت <code>app.get</code> طريقة <code>app.get</code> باستخدام وظيفة <code>mixin</code> بمكتبة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">دمج الواصفات</a> ، وهي المسؤولة عن تعيين طرق <code>app</code> المعلن عنها في <code>proto</code> .  يتم استيراد الكائن <code>proto</code> نفسه من <a href="">lib / application.js</a> . <br><br><h2 style=";text-align:right;direction:rtl">  <font color="#3AC1EF">إنشاء طريق جديد</font> </h2><br>  الآن دعونا نلقي نظرة على <a href="">الكود</a> المسؤول عن إنشاء طريقة <code>app.get</code> من مثالنا. <br><br><pre style=";text-align:right;direction:rtl"> <code class="hljs powershell">var slice = Array.prototype.slice; // ... /** *   `.VERB(...)` `router.VERB(...)`. */ // `methods`    HTTP, (  [<span class="hljs-string"><span class="hljs-string">'get'</span></span>,<span class="hljs-string"><span class="hljs-string">'post'</span></span>,<span class="hljs-type"><span class="hljs-type">...</span></span>]) methods.forEach(function(method){ //    app.get app[<span class="hljs-type"><span class="hljs-type">method</span></span>] = function(path){   //     //          var route = this._router.route(path);   //        route[<span class="hljs-type"><span class="hljs-type">method</span></span>].apply(route, slice.call(arguments, <span class="hljs-number"><span class="hljs-number">1</span></span>));   //   `app`,          <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this; }; });</code> </pre> <br>  من المثير للاهتمام ملاحظة أنه بالإضافة إلى الميزات الدلالية ، يمكن اعتبار جميع الطرق التي تنفذ إجراءات HTTP ، مثل <code>app.get</code> و <code>app.post</code> و <code>app.put</code> وما شابه ، من حيث الوظائف ، كما هي.  إذا قمت بتبسيط الكود أعلاه ، واختزاله إلى تنفيذ طريقة <code>get</code> واحدة فقط ، فستحصل على شيء مثل ما يلي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="hljs sql">app.get = function(path, <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>){ // ... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> route = this._router.route(<span class="hljs-keyword"><span class="hljs-keyword">path</span></span>); route.get(<span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this }</code> </pre> <br>  على الرغم من أن الدالة أعلاه لها وسيطتان ، إلا أنها تشبه <code>app[method] = function(path){...}</code> الوظيفة <code>app[method] = function(path){...}</code> .  يتم الحصول على الوسيطة الثانية ، <code>handler</code> ، عن طريق استدعاء <code>slice.call(arguments, 1)</code> . <br><br>  باختصار ، <code>app.&lt;method&gt;</code> يحفظ فقط المسار في موجه التطبيق باستخدام طريقة التوجيه الخاصة به ، ثم يمرر <code>handler</code> إلى التوجيه <code>route.&lt;method&gt;</code> . <br><br>  تم تعريف طريقة جهاز التوجيه <code>route()</code> في <a href="">lib / router / index.js</a> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="hljs pgsql">// proto -     `_router` proto.route = <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> route(<span class="hljs-type"><span class="hljs-type">path</span></span>) { var route = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Route(<span class="hljs-type"><span class="hljs-type">path</span></span>); var layer = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Layer(<span class="hljs-type"><span class="hljs-type">path</span></span>, {   sensitive: this.caseSensitive,   <span class="hljs-keyword"><span class="hljs-keyword">strict</span></span>: this.<span class="hljs-keyword"><span class="hljs-keyword">strict</span></span>,   <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> }, route.dispatch.bind(route)); layer.route = route; this.stack.push(layer); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> route; };</code> </pre> <br>  ليس من المستغرب أن يكون الإعلان عن طريقة <code>route.get</code> في <a href="">lib / router / route.js</a> مشابهًا لإعلان <code>app.get</code> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="hljs powershell">methods.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(method)</span></span></span></span> { Route.prototype[<span class="hljs-type"><span class="hljs-type">method</span></span>] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {   // `flatten`   ,  [<span class="hljs-number"><span class="hljs-number">1</span></span>,[<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>]],      var handles = flatten(slice.call(arguments));   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; handles.length; i++) {     var handle = handles[<span class="hljs-type"><span class="hljs-type">i</span></span>];         // ...     //   ,  ,    Layer,     //            var layer = Layer(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, {}, handle);     // ...     this.stack.push(layer);   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this; }; });</code> </pre> <br>  يمكن أن يحتوي كل مسار على عدة معالجات ؛ على أساس كل معالج ، يتم إنشاء متغير من النوع <code>Layer</code> ، وهو عبارة عن طبقة معالجة بيانات ، والتي تدخل بعد ذلك في المكدس. <br><br><h2 style=";text-align:right;direction:rtl">  <font color="#3AC1EF">كائنات الطبقة</font> </h2><br>  <code>_router</code> كل من <code>_router</code> و <code>route</code> كائنات من النوع <code>Layer</code> .  من أجل فهم جوهر هذا الشيء ، دعنا ننظر إلى <a href="">مُنشئه</a> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Layer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(path, options, fn)</span></span></span></span> { // ... this.handle = fn; this.regexp = pathRegexp(path, this.keys = [], opts); // ... }</code> </pre> <br>  عند إنشاء كائنات من النوع <code>Layer</code> يتم إعطاؤها مسارًا ومعلمات معينة ودالة.  في حالة جهاز التوجيه الخاص بنا ، هذه الوظيفة هي <code>route.dispatch</code> (سنتحدث عنها أكثر أدناه ، بعبارات عامة ، تم تصميمها لإرسال طلب إلى مسار منفصل).  في حالة المسار نفسه ، هذه الوظيفة هي وظيفة معالج معلن عنها في رمز مثالنا. <br><br>  يحتوي كل كائن من النوع <code>Layer</code> على أسلوب <a href="">handle_request</a> ، وهو المسؤول عن تنفيذ الوظيفة التي تم تمريرها عند تهيئة الكائن. <br><br>  تذكر ما يحدث عند إنشاء مسار باستخدام طريقة <code>app.get</code> : <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  يتم إنشاء مسار في موجه التطبيق ( <code>this._router</code> ). </li><li style=";text-align:right;direction:rtl">  يتم تعيين طريقة توجيه <code>dispatch</code> كطريقة معالج لكائن <code>Layer</code> المقابلة ، ويتم دفع هذا الكائن إلى مكدس جهاز التوجيه. </li><li style=";text-align:right;direction:rtl">  يتم تمرير معالج الطلب إلى كائن <code>Layer</code> كطريقة معالج ، ويتم دفع هذا الكائن إلى رصة التوجيه. </li></ol><br>  ونتيجة لذلك ، يتم تخزين جميع المعالجات داخل مثيل <code>app</code> في شكل كائنات من نوع <code>Layer</code> الموجودة داخل مكدس التوجيه ، حيث يتم تعيين طرق <code>dispatch</code> الخاصة بكائنات <code>Layer</code> الموجودة في مكدس جهاز التوجيه: <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/4a9/e8c/5b0/4a9e8c5b056ef1e8ce1e36503ab8c0f0.png"></div><br>  <i><font color="#999999">كائنات طبقة على مكدس جهاز التوجيه ومكدس التوجيه</font></i> <br><br>  تتم معالجة طلبات HTTP الواردة وفقًا لهذا المنطق.  سنتحدث عنها أدناه. <br><br><h2 style=";text-align:right;direction:rtl">  <font color="#3AC1EF">بدء تشغيل خادم HTTP</font> </h2><br>  بعد تكوين المسارات ، تحتاج إلى بدء الخادم.  في مثالنا ، ننتقل إلى أسلوب <code>app.listen</code> ، <code>app.listen</code> برقم المنفذ ووظيفة رد الاتصال كوسيطة.  لفهم ميزات هذه الطريقة ، يمكننا الرجوع إلى ملف <a href="">lib / application.js</a> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="hljs pgsql">app.<span class="hljs-keyword"><span class="hljs-keyword">listen</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">listen</span></span>() { var <span class="hljs-keyword"><span class="hljs-keyword">server</span></span> = http.createServer(this); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">server</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">listen</span></span>.apply(<span class="hljs-keyword"><span class="hljs-keyword">server</span></span>, arguments); };</code> </pre> <br>  <code>app.listen</code> أن <code>app.listen</code> مجرد غلاف حول <code>http.createServer</code> .  وجهة النظر هذه منطقية ، لأنه إذا تذكرت ما تحدثنا عنه في البداية ، فإن <code>app</code> هو مجرد وظيفة ذات <code>function(req, res, next) {...}</code> توقيع <code>function(req, res, next) {...}</code> ، وهو متوافق مع الحجج اللازمة لـ <code>http.createServer</code> (توقيع هذه الطريقة هو <code>function (req, res) {...}</code> ). <br><br>  بعد إدراك أنه في النهاية ، كل شيء يمنحه لنا Express.js يمكن اختزاله إلى معالج وظائف ذكي للغاية ، لم يعد الإطار معقدًا وغامضًا كما كان من قبل. <br><br><h2 style=";text-align:right;direction:rtl">  <font color="#3AC1EF">معالجة طلب HTTP</font> </h2><br>  الآن بعد أن علمنا أن <code>app</code> مجرد معالج طلبات ، سنتبع المسار الذي يمر به طلب HTTP داخل تطبيق سريع.  يؤدي هذا المسار إلى المعالج المعلن عنه. <br><br>  أولاً ، ينتقل الطلب إلى دالة <code>createApplication</code> ( <a href="">lib / express.js</a> ): <br><br><pre style=";text-align:right;direction:rtl"> <code class="hljs matlab">var app = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(req, res, next)</span></span></span><span class="hljs-function"> {   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">app</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(req, res, next)</span></span></span><span class="hljs-function">; };</span></span></code> </pre> <br>  ثم ينتقل إلى طريقة <code>app.handle</code> ( <a href="">lib / application.js</a> ): <br><br><pre style=";text-align:right;direction:rtl"> <code class="hljs powershell">app.handle = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(req, res, callback)</span></span></span></span> { // `this._router` -  ,    ,  `app.get` var router = this._router; // ... //     `handle` router.handle(req, res, done); };</code> </pre> <br>  تم <code>router.handle</code> طريقة <code>router.handle</code> في <a href="">lib / router / index.js</a> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="hljs lua">proto.handle = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(req, res, out)</span></span></span></span> { var self = this; //... // self.stack -  ,      // Layer (  ) var stack = self.stack; // ... <span class="hljs-built_in"><span class="hljs-built_in">next</span></span>(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span></span> {   // ...   //        var <span class="hljs-built_in"><span class="hljs-built_in">path</span></span> = getPathname(req);   // ...   var layer;   var <span class="hljs-built_in"><span class="hljs-built_in">match</span></span>;   var route;   <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">match</span></span> !== <span class="hljs-literal"><span class="hljs-literal">true</span></span> &amp;&amp; idx &lt; stack.length) {     layer = stack[idx++];     <span class="hljs-built_in"><span class="hljs-built_in">match</span></span> = matchLayer(layer, <span class="hljs-built_in"><span class="hljs-built_in">path</span></span>);     route = layer.route;     // ...     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">match</span></span> !== <span class="hljs-literal"><span class="hljs-literal">true</span></span>) {       continue;     }     // ...      HTTP,       }  // ...      // process_params    ,          self.process_params(layer, paramcalled, req, res, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span></span> {     // ...     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (route) {       //       `layer.handle_request`       //         `<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>`       //  ,   `<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>`     ,              //  ,   `<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>`   ,            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> layer.handle_request(req, res, <span class="hljs-built_in"><span class="hljs-built_in">next</span></span>);     }     // ...   }); } };</code> </pre> <br>  إذا كنت تصف ما يحدث باختصار ، فإن وظيفة <code>router.handle</code> تمر عبر جميع الطبقات على المكدس حتى تعثر على <code>router.handle</code> التي تطابق المسار المحدد في الطلب.  بعد ذلك ، سيتم استدعاء طريقة طبقة <code>handle_request</code> ، والتي ستقوم بتنفيذ وظيفة المعالج المحددة مسبقًا.  وظيفة المعالج هذه هي طريقة توجيه <code>dispatch</code> ، والتي يتم الإعلان عنها في <a href="">lib / route / route.js</a> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="hljs powershell">Route.prototype.dispatch = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispatch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(req, res, done)</span></span></span></span> { var stack = this.stack; // ... next(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span></span> {   // ...   var layer = stack[<span class="hljs-type"><span class="hljs-type">idx</span></span>++];   // ...    layer.handle_request(req, res, next);   // ... } };</code> </pre> <br>  تمامًا كما هو الحال في جهاز التوجيه ، أثناء معالجة كل مسار ، يتم تعداد الطبقات التي يحتوي عليها هذا المسار <code>handle_request</code> الخاصة بـ <code>handle_request</code> التي تنفذ طرق معالج الطبقة.  في حالتنا ، هذا هو معالج الطلب ، الذي تم تعريفه في رمز التطبيق. <br><br>  هنا ، أخيرًا ، يقع طلب HTTP في منطقة التعليمات البرمجية لتطبيقنا. <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/afb/0d1/5fb/afb0d15fbe71236ed615f88fe61bf062.png"></div><br>  <i><font color="#999999">طلب المسار في التطبيق السريع</font></i> <br><br><h2 style=";text-align:right;direction:rtl">  <font color="#3AC1EF">الملخص</font> </h2><br>  قمنا هنا بفحص الآليات الأساسية لمكتبة express.js ، وهي تلك المسؤولة عن تشغيل خادم الويب ، ولكن هذه المكتبة لديها أيضًا العديد من الميزات الأخرى.  لم نتوقف عند الشيكات التي تمر بها الطلبات قبل وصولها إلى المعالجات ؛ ولم نتحدث عن الأساليب المساعدة المتاحة عند العمل مع متغيرات <code>res</code> <code>req</code> .  وأخيرًا ، لم نتطرق إلى واحدة من أقوى ميزات Express.  وهو يتألف من استخدام البرامج الوسيطة ، والتي يمكن أن تهدف إلى حل أي مشكلة تقريبًا - من طلبات التحليل إلى تطبيق نظام مصادقة كامل. <br><br>  نأمل أن تساعدك هذه المادة على فهم الميزات الرئيسية للجهاز السريع ، والآن ، إذا لزم الأمر ، يمكنك فهم كل شيء آخر من خلال تحليل أجزاء التعليمات البرمجية المصدر لهذه المكتبة التي تهمك بشكل مستقل. <br><br>  <b>أعزائي القراء!</b>  هل تستخدم express.js؟ <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar414079/">https://habr.com/ru/post/ar414079/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar414065/index.html">أفضل هاتف ذكي صيني "يصل إلى 10 آلاف روبل" مع AliExpress مقابل Xiaomi Redmi 5</a></li>
<li><a href="../ar414067/index.html">قم بتشغيل إعادة استهداف الأجهزة المحمولة مع الضبط: الإعدادات والتقارير والروابط</a></li>
<li><a href="../ar414069/index.html">قيود الطائرات بدون طيار خلال كأس العالم 2018 FIFA (FIFA 2018)</a></li>
<li><a href="../ar414071/index.html">من المراقبة إلى إدارة الحوادث. تقرير من DevOps Moscow Meetup</a></li>
<li><a href="../ar414073/index.html">الترحيل من jQuery إلى Vue.js</a></li>
<li><a href="../ar414081/index.html">تطوير Chatbot لـ Facebook Messenger على node.js</a></li>
<li><a href="../ar414083/index.html">الصيف mitap Apache Ignite في سان بطرسبرج</a></li>
<li><a href="../ar414085/index.html">كيفية إنشاء عينات للنظام البيومتري الموحد ولماذا يمكن أن يكون خطرًا</a></li>
<li><a href="../ar414087/index.html">أتمتة ذلك على الفور أو كيف يمكن للشركات العمل عبر الإنترنت اليوم</a></li>
<li><a href="../ar414089/index.html">حظر برقية أيد بقرار من محكمة مدينة موسكو</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>