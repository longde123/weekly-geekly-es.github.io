<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ÜòÔ∏è üìµ üàöÔ∏è Chat Distribu√≠do no Node.JS e Redis üë®‚Äçüè´ üöØ üèüÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Uma pequena pergunta / resposta: 


 Para quem √©? Pessoas que t√™m pouca ou nenhuma experi√™ncia com sistemas distribu√≠dos e que est√£o interessadas em v...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Chat Distribu√≠do no Node.JS e Redis</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440546/"><p><img src="https://cs4.pikabu.ru/post_img/2015/10/04/5/1443945163_2102700146.jpg" alt="O resultado √© uma imagem de piada para lavar &quot;correio de pombo&quot;"></p><br><p>  Uma pequena pergunta / resposta: </p><br><p> <em>Para quem √©?</em>  Pessoas que t√™m pouca ou nenhuma experi√™ncia com sistemas distribu√≠dos e que est√£o interessadas em ver como podem ser constru√≠das, quais padr√µes e solu√ß√µes existem. </p><br><p>  <em>Por que isso?</em>  Ele mesmo se interessou em qu√™ e como.  Recolhi informa√ß√µes de v√°rias fontes, decidi public√°-las de forma concentrada, porque uma vez eu mesmo gostaria de ver um trabalho semelhante.  De fato, esta √© uma declara√ß√£o textual de minhas jogadas e pensamentos pessoais.  Al√©m disso, certamente haver√° muitas corre√ß√µes nos coment√°rios de pessoas conhecedoras, e esse √© parcialmente o objetivo de escrever tudo isso na forma de um artigo. </p><br><h2 id="postanovka-zadachi">  Declara√ß√£o do problema </h2><br><p>  Como fazer um bate-papo?  Essa deve ser uma tarefa trivial, provavelmente todo segundo beckender viu sua pr√≥pria, assim como os desenvolvedores de jogos fazem suas tetris / cobras, etc. usu√°rios ativos e, em geral, foi incrivelmente legal.  A clara necessidade de uma arquitetura distribu√≠da vem disso, porque n√£o √© realista ter a capacidade atual para atender todo o n√∫mero imagin√°rio de clientes em uma m√°quina.  Em vez de apenas ficar esperando a apari√ß√£o de computadores qu√¢nticos, decidi decididamente a estudar o t√≥pico de sistemas distribu√≠dos. </p><br><p>  Vale a pena notar que uma resposta r√°pida √© muito importante, o not√≥rio em tempo real, √© um <strong>bate</strong> - <strong>papo</strong> !  n√£o entrega de correio de pombo. </p><br><p>  % <em>piada aleat√≥ria sobre o post russo</em> % </p><br><p>  Usaremos o Node.JS, √© ideal para prototipagem.  Para soquetes, use Socket.IO.  Escreva no TypeScript. </p><br><p>  E ent√£o o que queremos: </p><br><ol><li>  Para que os usu√°rios possam enviar mensagens uns aos outros </li><li>  Saiba quem est√° online / offline </li></ol><br><p>  Como queremos: </p><a name="habracut"></a><br><h2 id="singl-server">  Servidor √∫nico </h2><br><p>  N√£o h√° nada a dizer especialmente, direto ao c√≥digo.  Declare a interface da mensagem: </p><br><pre><code class="plaintext hljs">interface Message{ roomId: string,//    message: string,//    }</code> </pre> <br><p>  No servidor: </p><br><pre> <code class="plaintext hljs">io.on('connection', sock=&gt;{ //    sock.on('join', (roomId:number)=&gt; sock.join(roomId)) //    //         sock.on('message', (data:Message)=&gt; io.to(data.roomId).emit('message', data)) })</code> </pre> <br><p>  No cliente, algo como: </p><br><pre> <code class="plaintext hljs">sock.on('connect', ()=&gt; { const roomId = 'some room' //      sock.on('message', (data:Message)=&gt; console.log(`Message ${data.message} from ${data.roomId}`)) //   sock.emit('join', roomId) //    sock.emit('message', &lt;Message&gt;{roomId: roomId, message: 'Halo!'}) })</code> </pre> <br><p>  Voc√™ pode trabalhar com status online como este: </p><br><pre> <code class="plaintext hljs">io.on('connection', sock=&gt;{ //         // ,        - //      sock.on('auth', (uid:string)=&gt; sock.join(uid)) //,     , //          //   sock.on('isOnline', (uid:string, resp)=&gt; resp(io.sockets.clients(uid).length &gt; 0)) })</code> </pre> <br><p>  E no cliente: </p><br><pre> <code class="plaintext hljs">sock.on('connect', ()=&gt; { const uid = 'im uid, rly' //  sock.emit('auth', uid) //     sock.emit('isOnline', uid, (isOnline:boolean)=&gt; console.log(`User online status is ${isOnline}`)) })</code> </pre> <br><blockquote>  Nota: o c√≥digo n√£o foi executado, eu escrevo da mem√≥ria apenas por exemplo </blockquote><p>  Assim como a lenha, geramos autoriza√ß√£o real syudy, gerenciamento de sala (hist√≥rico de mensagens, adi√ß√£o / remo√ß√£o de participantes) e lucro. </p><br><p>  MAS!  Mas vamos conquistar a paz mundial, o que significa que n√£o √© hora de parar, estamos avan√ßando rapidamente: </p><br><h2 id="nodejs-klaster">  Cluster Node.JS </h2><br><p>  Exemplos de uso do Socket.IO em muitos n√≥s est√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no site oficial</a> .  Incluindo tamb√©m existe um cluster Node.JS nativo, que me pareceu inaplic√°vel √† minha tarefa: ele nos permite expandir nosso aplicativo em toda a m√°quina, mas n√£o al√©m de seu escopo, por isso definitivamente sentimos falta dele.  Precisamos finalmente ir al√©m dos limites de um peda√ßo de ferro! </p><br><h2 id="raspredelyay-i-velosiped">  Distribua e ande de bicicleta </h2><br><p>  Como fazer isso?  Obviamente, voc√™ precisa conectar de alguma forma nossas inst√¢ncias, lan√ßadas n√£o apenas em casa no por√£o, mas tamb√©m no por√£o vizinho.  O que primeiro vem √† mente: fazemos algum tipo de link intermedi√°rio que servir√° como um barramento entre todos os nossos n√≥s: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549140775997.png" alt="1549140775997"></p><br><p>  Quando um n√≥ deseja enviar outra mensagem, ele faz uma solicita√ß√£o ao Barramento e, por sua vez, o encaminha para onde √© necess√°rio, tudo √© simples.  Nossa rede est√° pronta! </p><br><p>  <strong>FIN.</strong> </p><br><p>  ... mas n√£o √© t√£o simples?) </p><br><p>  Com essa abordagem, encontramos o desempenho desse link intermedi√°rio e, na verdade, gostar√≠amos de entrar em contato diretamente com os n√≥s necess√°rios, porque o que pode ser mais r√°pido que a comunica√ß√£o direta?  Ent√£o, vamos seguir nessa dire√ß√£o! </p><br><p>  O que √© necess√°rio primeiro?  Na verdade, legitima uma inst√¢ncia para outra.  Mas como o primeiro aprende sobre a exist√™ncia do segundo?  Mas queremos ter um n√∫mero infinito deles, arbitrariamente aumentar / remover!  Precisamos de um servidor mestre cujo endere√ßo seja conhecido, todos se conectem a ele, devido ao qual conhecem todos os n√≥s existentes na rede e compartilhem essas informa√ß√µes com todos. </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549048945334.png" alt="1549048945334"></p><br><p>  O n√≥ sobe, informa o mestre sobre seu despertar, fornece uma lista de outros n√≥s ativos, n√≥s nos conectamos a eles e √© isso, a rede est√° pronta.  O mestre pode ser c√¥nsul ou algo assim, mas, como estamos pedalando, o mestre deve ser feito por si pr√≥prio. </p><br><p>  √ìtimo, agora temos o nosso pr√≥prio skynet!  Mas a implementa√ß√£o atual do bate-papo n√£o √© mais adequada.  Vamos realmente apresentar os requisitos: </p><br><ol><li>  Quando um usu√°rio envia uma mensagem, precisamos saber para quem ele a envia, ou seja, ter acesso aos participantes na sala. </li><li>  Quando recebemos os participantes, devemos entregar-lhes mensagens. </li><li>  Precisamos saber qual usu√°rio est√° online agora. </li><li>  Por conveni√™ncia - d√™ aos usu√°rios a oportunidade de assinar o status online de outros usu√°rios, para que, em tempo real, aprendam sobre sua mudan√ßa </li></ol><br><p>  Vamos lidar com os usu√°rios.  Por exemplo, voc√™ pode informar ao mestre qual n√≥ est√° conectado a qual n√≥.  A situa√ß√£o √© a seguinte: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549237952673.png" alt="1549237952673"></p><br><p>  Dois usu√°rios est√£o conectados a n√≥s diferentes.  O mestre sabe disso, os n√≥s sabem o que o mestre sabe.  Quando o Usu√°rioB efetua login, o N√≥2 notifica o Mestre, que "lembra" que o Usu√°rioB est√° conectado ao N√≥2.  Quando o Usu√°rioA deseja enviar uma mensagem do Usu√°rioB, voc√™ obt√©m a seguinte imagem: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549140491881.png" alt="1549140491881"></p><br><p>  Em princ√≠pio, tudo funciona, mas eu gostaria de evitar uma viagem extra na forma de interrogar o mestre; seria mais econ√¥mico entrar em contato imediatamente com o n√≥ certo diretamente, porque √© por isso que tudo foi iniciado.  Isso pode ser feito se eles disserem a todos em torno de quais usu√°rios est√£o conectados a eles, cada um deles se tornar√° um an√°logo auto-suficiente do assistente e o pr√≥prio assistente se tornar√° desnecess√°rio, porque a lista da propor√ß√£o "Usu√°rio =&gt; N√≥" √© duplicada para todos.  No in√≠cio de um n√≥, basta conectar-se a um j√° em execu√ß√£o, puxar sua lista para si mesmo e pronto, ele tamb√©m est√° pronto para a batalha. </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549139768940.png" alt="1549139768940"></p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549139882747.png" alt="1549139882747"></p><br><p>  Mas, como troca, obtemos uma duplica√ß√£o da lista, que, embora seja uma propor√ß√£o de "id do usu√°rio -&gt; [conex√µes de host]", mas com um n√∫mero suficiente de usu√°rios, ela se mostra bastante grande na mem√≥ria.  E, em geral, cortando voc√™ mesmo - isso claramente cheira √† ind√∫stria de bicicletas.  Quanto mais c√≥digo, mais erros potenciais.  Talvez congele esta op√ß√£o e d√™ uma olhada no que j√° est√° pronto: </p><br><h2 id="brokery-soobscheniy">  Corretores de mensagens </h2><br><p>  A entidade que implementa o mesmo "Barramento", o "link intermedi√°rio" mencionado acima.  Sua tarefa √© receber e entregar mensagens.  N√≥s, como usu√°rios, podemos assinar e enviar os nossos.  Tudo √© simples. </p><br><p>  Existem o RabbitMQ e o Kafka bem conhecidos: eles apenas fazem o que entregam mensagens - esse √© o objetivo deles, repleto de todas as funcionalidades necess√°rias para o pesco√ßo.  No mundo deles, uma mensagem deve ser entregue, n√£o importa o qu√™. </p><br><p>  Ao mesmo tempo, h√° Redis e seu pub / sub - o mesmo que os caras mencionados, mas mais duvidoso: ele recebe a mensagem estupidamente e a entrega ao assinante, sem filas e outras despesas gerais.  Ele absolutamente n√£o se importa com as mensagens, elas desaparecer√£o, se o assinante travar - ele a jogar√° fora e assumir√° uma nova, como se jogassem um p√¥quer em brasa nas m√£os das quais voc√™ deseja se livrar mais rapidamente.  Al√©m disso, se ele cair repentinamente - todas as mensagens tamb√©m afundar√£o junto com ele.  Em outras palavras, n√£o h√° d√∫vida de qualquer garantia de entrega. </p><br><p>  ... e √© isso que voc√™ precisa! </p><br><p>  Bem, na verdade, apenas conversamos.  N√£o √© algum tipo de servi√ßo cr√≠tico de dinheiro ou centro de controle de v√¥o espacial, mas ... apenas um bate-papo.  O risco de que Pete condicional uma vez por ano n√£o receba uma mensagem em mil - pode ser negligenciado se, em troca, obtivermos crescimento da produtividade e, com ele, o n√∫mero de usu√°rios nos mesmos dias, trocar em toda a sua gl√≥ria.  Al√©m disso, ao mesmo tempo, voc√™ pode manter um hist√≥rico de mensagens em algum tipo de reposit√≥rio persistente, o que significa que o Petya ainda ver√° a mensagem perdida recarregando a p√°gina / aplicativo.  √â por isso que vamos nos concentrar no pub / sub Redis, ou melhor: observe o adaptador existente para o SocketIO, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mencionado no artigo no escrit√≥rio.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">site</a> . </p><br><p>  Ent√£o o que √© isso? </p><br><h2 id="redis-adapter">  Adaptador Redis </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/socketio/socket.io-redis</a> </p><br><p>  Com sua ajuda, um aplicativo comum atrav√©s de algumas linhas e um n√∫mero m√≠nimo de gestos se transforma em um bate-papo distribu√≠do real!  Mas como  <a href="">Se voc√™ olhar para dentro</a> , verifica-se que h√° apenas um arquivo por meia centena de linhas. </p><br><p>  No caso em que emitimos uma mensagem </p><br><pre> <code class="plaintext hljs">io.emit("everyone", "hello")</code> </pre> <br><p>  √© empurrado para rabanetes, transmitido para todas as outras inst√¢ncias do nosso bate-papo, que por sua vez o emitem localmente nos soquetes </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549232309776.png" alt="1549232309776"></p><br><p>  A mensagem ser√° distribu√≠da por todos os n√≥s, mesmo se emitirmos para um usu√°rio espec√≠fico.  Ou seja, cada n√≥ aceita todas as mensagens e j√° entende se precisa delas. </p><br><p>  Al√©m disso, foi implementado um rpc simples (chamando procedimentos remotos), que permite n√£o apenas enviar, mas tamb√©m receber respostas.  Por exemplo, voc√™ pode controlar soquetes remotamente, como "quem est√° na sala especificada", "solicitar que o soquete entre na sala" etc. </p><br><p>  O que pode ser feito com isso?  Por exemplo, use o ID do usu√°rio como o nome da sala (ID do usu√°rio == ID da sala).  Ao autorizar, conectar o soquete a ele e quando queremos enviar uma mensagem ao usu√°rio - apenas um capacete nele.  Al√©m disso, podemos descobrir se o usu√°rio est√° online, simplesmente olhando se h√° soquetes na sala especificada. </p><br><p>  Em princ√≠pio, podemos parar por aqui, mas como sempre, n√£o √© suficiente para n√≥s: </p><br><ol><li>  Gargalo em uma √∫nica inst√¢ncia de rabanete </li><li>  Redund√¢ncia, gostaria que os n√≥s recebessem apenas as mensagens necess√°rias </li></ol><br><p>  √Ä custa do primeiro par√°grafo, observe algo como: </p><br><h2 id="redis-cluster">  Cluster Redis </h2><br><p>  Ele conecta v√°rias inst√¢ncias de rabanete, ap√≥s o que elas funcionam como um todo.  Mas como ele faz isso?  Sim, assim: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549233023980.png" alt="1549233023980"></p><br><p>  ... e vemos que a mensagem √© duplicada para todos os membros do cluster.  Ou seja, n√£o se destina a aumentar a produtividade, mas a aumentar a confiabilidade, o que √© certamente bom e necess√°rio, mas, no nosso caso, n√£o tem valor e n√£o salva a situa√ß√£o com um gargalo, al√©m de, em suma, ser ainda mais desperd√≠cio de recursos. </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549231953897.png" alt="1549231953897"></p><br><p>  Sou iniciante, n√£o sei muito, √†s vezes tenho que voltar ao pitchforking, o que faremos.  N√£o, vamos deixar o rabanete para que n√£o escorregue, mas voc√™ precisa pensar em algo com a arquitetura, porque a atual n√£o √© boa. </p><br><h2 id="povorot-ne-tuda">  Vire na dire√ß√£o errada </h2><br><p>  Do que precisamos?  Aumente a taxa de transfer√™ncia geral.  Por exemplo, vamos tentar estupidamente gerar outra inst√¢ncia.  Imagine que o socket.io-redis possa se conectar a v√°rios, ao enviar uma mensagem, ele seleciona aleatoriamente e assina tudo.  Acontece assim: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549239818663.png" alt="1549239818663"></p><br><p>  Voila!  Em geral, o problema est√° resolvido, rabanetes n√£o s√£o mais um gargalo, voc√™ pode gerar qualquer n√∫mero de c√≥pias!  Mas eles se tornaram n√≥s.  Sim, sim, nossas inst√¢ncias de bate-papo ainda digerem TODAS as mensagens, para as quais n√£o foram destinadas. </p><br><p>  Voc√™ pode vice-versa: assine um aleat√≥rio, o que reduzir√° a carga nos n√≥s e enviar√° tudo: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549239361416.png" alt="1549239361416"></p><br><p>  Vimos que isso se tornou o contr√°rio: os n√≥s parecem mais calmos, mas a carga na inst√¢ncia de rabanete aumentou.  Isso tamb√©m n√£o √© bom.  Voc√™ precisa andar de bicicleta um pouco. </p><br><p>  Para bombear nosso sistema, deixaremos o pacote socket.io-redis em paz, embora seja legal, precisamos de mais liberdade.  E assim, conectamos o rabanete: </p><br><pre> <code class="plaintext hljs">//  : const pub = new RedisClient({host: 'localhost', port: 6379})//  const sub = new RedisClient({host: 'localhost', port: 6379})//   //    interface Message{ roomId: string,//    message: string,//    }</code> </pre> <br><p>  Configure nosso sistema de mensagens: </p><br><pre> <code class="plaintext hljs">//     sub.on('message', (channel:string, dataRaw:string)=&gt; { const data = &lt;Message&gt;JSON.parse(dataRaw) io.to(data.roomId).emit('message', data)) }) //   sub.subscribe("messagesChannel") //    sock.on('join', (roomId:number)=&gt; sock.join(roomId)) //   sock.on('message', (data:Message)=&gt; { //   pub.publish("messagesChannel", JSON.stringify(data)) })</code> </pre> <br><p>  No momento, acontece como em socket.io-redis: ouvimos todas as mensagens.  Agora vamos consertar isso. </p><br><p>  Organizamos as assinaturas da seguinte forma: lembre-se do conceito com "user id == room id" e, quando o usu√°rio aparecer, inscreva-se no canal com o mesmo nome no rabanete.  Assim, nossos n√≥s receber√£o apenas mensagens destinadas a eles, e n√£o ouvir√£o a "transmiss√£o inteira". </p><br><pre> <code class="plaintext hljs">//     sub.on('message', (channel:string, message:string)=&gt; { io.to(channel).emit('message', message)) }) let UID:string|null = null; sock.on('auth', (uid:string)=&gt; { UID = uid //   -   //  UID  sub.subscribe(UID) //   sock.join(UID) }) sock.on('writeYourself', (message:string)=&gt; { //  ,        UID if (UID) pub.publish(UID, message) })</code> </pre> <br><p>  Impressionante, agora temos certeza de que os n√≥s recebem apenas mensagens destinadas a eles, nada mais!  Deve-se notar, no entanto, que as pr√≥prias assinaturas agora s√£o muito, muito maiores, o que significa que elas consumir√£o a mem√≥ria do yoy yoy, + mais opera√ß√µes de assinatura / cancelamento de assinatura, que s√£o relativamente caras.  Mas, de qualquer forma, isso nos d√° alguma flexibilidade, voc√™ pode at√© parar neste momento e revisar todas as op√ß√µes anteriores, j√° levando em conta nossa nova propriedade de n√≥s na forma de mensagens de recebimento mais seletivas e castas.  Por exemplo, os n√≥s podem se inscrever em uma das v√°rias inst√¢ncias de rabanete e, ao pressionar, enviar uma mensagem para todas as inst√¢ncias: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1550174595491.png" alt="1550174595491"></p><br><p>  ... mas, o que quer que se diga, eles ainda n√£o oferecem extensibilidade infinita com sobrecarga razo√°vel, voc√™ precisa dar a luz a outras op√ß√µes.  A certa altura, veio √† minha mente o seguinte esquema: e se as inst√¢ncias de rabanete forem divididas em grupos, digamos A e B, duas inst√¢ncias em cada uma.  Ao assinar, os n√≥s s√£o assinados por uma inst√¢ncia de cada grupo e, quando pressionados, eles enviam uma mensagem para todas as inst√¢ncias de um √∫nico grupo aleat√≥rio. </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1550174092066.png" alt="1550174092066"></p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1550174943313.png" alt="1550174943313"></p><br><p>  Assim, obtemos uma estrutura operacional com potencial infinito de capacidade de expans√£o em tempo real, a carga em um n√≥ individual a qualquer momento n√£o depende do tamanho do sistema, porque: </p><br><ol><li>  A largura de banda total √© dividida entre grupos, ou seja, com um aumento de usu√°rios / atividade, simplesmente comparamos grupos adicionais. </li><li>  O gerenciamento de usu√°rios (assinaturas) √© dividido nos pr√≥prios grupos, ou seja, ao aumentar usu√°rios / assinaturas, simplesmente aumentamos o n√∫mero de inst√¢ncias nos grupos. </li></ol><br><p>  ... e como sempre, h√° um "MAS": quanto mais tudo fica, mais recursos s√£o necess√°rios para o pr√≥ximo ganho, parece-me um exorbitante trade-off. </p><br><p>  Em geral, se voc√™ pensar sobre isso, os plugues mencionados acima n√£o saber√£o qual usu√°rio est√° em qual n√≥.  Bem, de fato, se tiv√©ssemos essas informa√ß√µes, poder√≠amos enviar as mensagens exatamente onde elas precisavam, sem duplica√ß√£o desnecess√°ria.  O que tentamos fazer esse tempo todo?  Eles tentaram tornar o sistema infinitamente escal√°vel, apesar de n√£o ter um mecanismo de endere√ßamento claro, que inevitavelmente chegava a um beco sem sa√≠da ou a redund√¢ncia injustificada.  Por exemplo, voc√™ pode recordar que o assistente atua como um "cat√°logo de endere√ßos": </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1550233610561.png" alt="1550233610561"></p><br><blockquote>  Algo semelhante diz a esse cara: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/6G22a5Iooqk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></blockquote><p>  Para obter a localiza√ß√£o do usu√°rio, fazemos uma viagem de ida e volta adicional, o que √©, em princ√≠pio, bom, mas n√£o no nosso caso.  Parece que estamos cavando na dire√ß√£o errada, precisamos de outra coisa ... </p><br><h2 id="sila-hesha">  For√ßa de hash </h2><br><p>  Existe um hash.  Tem algum intervalo finito de valores.  Voc√™ pode obt√™-lo a partir de qualquer dado.  Mas e se voc√™ dividir esse intervalo entre inst√¢ncias de rabanete?  Bem, pegamos o ID do usu√°rio, produzimos um hash e, dependendo do intervalo em que ele se inscreveu / envia para uma inst√¢ncia espec√≠fica.  Ou seja, n√£o sabemos com anteced√™ncia onde o usu√°rio existe, mas, depois de receb√™-lo, podemos dizer com seguran√ßa que ele est√° na inst√¢ncia n, inf 100. Agora, a mesma coisa, mas com o c√≥digo: </p><br><pre> <code class="plaintext hljs">function hash(val:string):number{/**/}// -,   const clients:RedisClient[] = []//   const uid = "some uid"//  //,            //      const selectedClient = clients[hash(uid) % clients.length]</code> </pre> <br><p>  Voila!  Agora n√£o somos dependentes do n√∫mero de inst√¢ncias da palavra em geral, podemos escalar o quanto quisermos sem despesas gerais!  Bem, s√©rio, essa √© uma op√ß√£o brilhante, cujo √∫nico ponto negativo √© a necessidade de reiniciar completamente o sistema ao atualizar o n√∫mero de inst√¢ncias de rabanete.  Existe um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">anel padr√£o e um anel de parti√ß√£o</a> que permitem superar isso, mas eles n√£o s√£o aplic√°veis ‚Äã‚Äãem um sistema de mensagens.  Bem, voc√™ pode criar a l√≥gica de migrar assinaturas entre inst√¢ncias, mas ainda custa um c√≥digo adicional de tamanho incompreens√≠vel e, como sabemos, quanto mais c√≥digo, mais erros, n√£o precisamos disso, obrigado.  E, no nosso caso, o tempo de inatividade √© uma compensa√ß√£o aceit√°vel. </p><br><p>  Voc√™ tamb√©m pode ver o RabbitMQ com seu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">plug-in</a> , que nos permite fazer o mesmo que fazemos, e + fornece a migra√ß√£o de assinaturas (como eu disse acima - ele est√° vinculado √† funcionalidade da cabe√ßa aos p√©s).  Em princ√≠pio, voc√™ pode peg√°-lo e dormir em paz, mas se algu√©m se atrapalhar na sintonia para trazer o modo para o tempo real, deixando apenas um recurso com um anel de hash. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Inundou o reposit√≥rio no github.</a> </p><br><p>  Ele implementa a vers√£o final para a qual chegamos.  Al√©m disso, h√° uma l√≥gica adicional para trabalhar com salas (caixas de di√°logo). </p><br><p>  Em geral, estou satisfeito e pode ser completado. </p><br><h2 id="itogo">  Total </h2><br><p>  Voc√™ pode fazer qualquer coisa, mas existem recursos, e eles s√£o finitos; portanto, voc√™ precisa se esquivar. </p><br><p>  Come√ßamos com total ignor√¢ncia de como os sistemas distribu√≠dos podem funcionar com padr√µes concretos mais ou menos tang√≠veis, e isso √© bom. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt440546/">https://habr.com/ru/post/pt440546/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt440534/index.html">Tradu√ß√£o do vocabul√°rio politicamente correto do ingl√™s para o russo</a></li>
<li><a href="../pt440536/index.html">Como o Facebook Project Infer ajuda a encontrar erros em aplicativos m√≥veis antes da implanta√ß√£o</a></li>
<li><a href="../pt440540/index.html">A capitaliza√ß√£o do Reddit alcan√ßou US $ 3 bilh√µes depois de atrair investimentos de US $ 300 milh√µes</a></li>
<li><a href="../pt440542/index.html">Vuex - uso excessivo de getters na aplica√ß√£o. Erro ao analisar</a></li>
<li><a href="../pt440544/index.html">Vers√£o experimental Blazor 0.8.0 j√° est√° dispon√≠vel</a></li>
<li><a href="../pt440548/index.html">"Voc√™ n√£o pode simplesmente pegar e paralelizar fontes de tens√£o"</a></li>
<li><a href="../pt440550/index.html">O tri√¢ngulo colorido n√£o possui dois, mas um canto</a></li>
<li><a href="../pt440552/index.html">Quebrar fechamentos e injetar inje√ß√£o de depend√™ncia em JavaScript</a></li>
<li><a href="../pt440554/index.html">BEM conveniente</a></li>
<li><a href="../pt440556/index.html">Aprendendo o design de diagramas de relacionamento com entidades</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>