<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßñüèº üë©üèº üè® Hyperledger Fabric Desarrollo y prueba de contratos inteligentes üì© üì® üéÅ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hyperledger Fabric (HLF) es una plataforma de c√≥digo abierto que utiliza tecnolog√≠a de libro mayor distribuido (DLT), dise√±ada para desarrollar aplica...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hyperledger Fabric Desarrollo y prueba de contratos inteligentes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426705/"><p>  Hyperledger Fabric (HLF) es una plataforma de c√≥digo abierto que utiliza tecnolog√≠a de libro mayor distribuido (DLT), dise√±ada para desarrollar aplicaciones que funcionan en un entorno de red empresarial creado y controlado por un consorcio de organizaciones que utilizan reglas de acceso (con permiso). </p><br><p>  La plataforma admite contratos inteligentes, en t√©rminos HLF: c√≥digos de cadena creados en lenguajes generales como Golang, JavaScript, Java, a diferencia de, por ejemplo, Ethereum, que utiliza un lenguaje de Solidez de funcionalidad limitada orientado a contratos. (LLL, Viper, etc.). </p><br><p><img src="https://habrastorage.org/webt/w4/em/ps/w4empss606_8k1h8tvkcmfim4c8.png"></p><br><p>  El desarrollo y la prueba de c√≥digos de cadena, debido a la necesidad de implementar un n√∫mero significativo de componentes de la red blockchain, puede ser un proceso bastante largo con un alto tiempo dedicado a probar los cambios.  Este art√≠culo analiza un enfoque para el r√°pido desarrollo y prueba de los contratos inteligentes de HLF Golang utilizando la biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CCKit</a> . </p><a name="habracut"></a><br><h2 id="prilozhenie-na-baze-hlf">  Aplicaci√≥n basada en HLF </h2><br><p>  Desde el punto de vista del desarrollador, la aplicaci√≥n blockchain consta de dos partes principales: </p><br><ul><li>  <strong>En cadena</strong> : contratos (programas) inteligentes que operan en un entorno aislado de la red blockchain que determina las reglas para la creaci√≥n y la composici√≥n de los atributos de la transacci√≥n.  En un contrato inteligente, las acciones principales son leer, actualizar y eliminar datos del estado de la red blockchain.  Se debe enfatizar que eliminar datos de un estado deja informaci√≥n de que estos datos estaban presentes. </li><li>  <strong>Off-chain</strong> es una aplicaci√≥n (por ejemplo, una API) que interact√∫a con el entorno blockchain a trav√©s del SDK.  La interacci√≥n se entiende como llamar a funciones de contratos inteligentes y monitorear eventos de contratos inteligentes: los eventos externos pueden causar cambios en los datos del contrato inteligente, mientras que los eventos en el contrato inteligente pueden desencadenar acciones en sistemas externos. </li></ul><br><p>  Por lo general, los datos se leen a trav√©s del nodo de red blockchain "hogar".  Para registrar datos, la aplicaci√≥n env√≠a solicitudes a los nodos de organizaciones que participan en la "pol√≠tica de aprobaci√≥n" de un contrato inteligente en particular. </p><br><p>  Para desarrollar c√≥digo fuera de la cadena (API, etc.), se utiliza un SDK especializado que encapsula la interacci√≥n con los nodos de la cadena de bloques, recolectando respuestas, etc.  Para HLF, hay implementaciones de SDK para Go ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2</a> ), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Node.Js</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Java</a> </p><br><h2 id="komponenty-hyperledger-fabric">  Componentes de tela Hyperledger </h2><br><h3 id="kanal">  Canal </h3><br><p>  Un canal es una subred separada de nodos que admite una cadena de bloques aislada (libro mayor), as√≠ como el estado actual (clave-valor) de la cadena de bloques ( <em>estado mundial</em> ) utilizado para operar contratos inteligentes.  Un host puede tener acceso a un n√∫mero arbitrario de canales. </p><br><h3 id="tranzakciya">  Transacci√≥n </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Una transacci√≥n en Hyperledger Fabric</a> es una actualizaci√≥n at√≥mica del estado de una cadena de bloques, el resultado de la ejecuci√≥n del m√©todo chaincode.  Una transacci√≥n consiste en una solicitud para llamar a un m√©todo chaincode con algunos argumentos (Propuesta de transacci√≥n) firmados por el nodo llamante, y un conjunto de respuestas (Respuesta de propuesta de transacci√≥n) de los nodos en los que la transacci√≥n fue "confirmada" (Endoso).  Las respuestas contienen informaci√≥n sobre los pares clave-valor cambiantes del estado de la cadena de bloques del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">conjunto de lectura-escritura</a> y la informaci√≥n de servicio (firmas y certificados de nodos que confirman la transacci√≥n).  Porque  Las cadenas de bloques de canales individuales est√°n f√≠sicamente separadas, una transacci√≥n solo se puede realizar en el contexto de un canal. </p><br><p>  Las plataformas de cadena de bloques "cl√°sicas", como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bitcoin</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ethereum</a> , utilizan el ciclo de transacci√≥n de Ejecuci√≥n de pedidos ejecutado por todos los nodos, lo que limita la escalabilidad de la red de cadena de bloques. </p><br><p><img src="https://habrastorage.org/webt/ad/-b/ud/ad-budtoazz80tcc2vcgmzyahve.png"></p><br><p>  Hyperledger Fabric utiliza una arquitectura de ejecuci√≥n y distribuci√≥n de transacciones que tiene 3 operaciones principales: </p><br><ul><li><p>  Ejecuci√≥n ( <strong>ejecuci√≥n</strong> ): creaci√≥n mediante un contrato inteligente que se ejecuta en uno o varios nodos de la red, transacciones: cambios at√≥micos en el estado de un registro distribuido ( <em>aprobaci√≥n</em> ) </p><br></li><li><p>  Pedidos: pedido y agrupaci√≥n de transacciones en bloques por parte del servicio de pedidos especializado mediante un algoritmo de consenso conectable. </p><br></li><li><p>  Validar: verificaci√≥n por parte de los nodos de la red de las transacciones que provienen del orden antes de colocar la informaci√≥n de ellos en su copia del registro distribuido </p><br></li></ul><br><p><img src="https://habrastorage.org/webt/xw/ss/xj/xwssxjcfyfmsydsfnyl4oey_coe.png"></p><br><p>  Este enfoque le permite llevar a cabo la fase de ejecuci√≥n de la transacci√≥n antes de que ingrese a la red blockchain, as√≠ como escalar horizontalmente el funcionamiento de los nodos de la red. </p><br><h3 id="cheynkod">  Chaincode </h3><br><p>  Un chaincode, que tambi√©n se puede llamar un contrato inteligente, es un programa escrito en Golang, JavaScript (HLF 1.1+) o Java (HLF 1.3+), que define las reglas para crear transacciones que cambian el estado de una cadena de bloques.  El programa se ejecuta simult√°neamente en varios nodos independientes de la red distribuida de nodos de blockchain, lo que crea un entorno neutral para la ejecuci√≥n de contratos inteligentes al conciliar los resultados del programa en todos los nodos necesarios para la "confirmaci√≥n" de la transacci√≥n. </p><br><p>  El c√≥digo debe implementar una interfaz que consta de m√©todos: </p><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Chaincode <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Init is called during Instantiate transaction Init(stub ChaincodeStubInterface) pb.Response // Invoke is called to update or query the ledger Invoke(stub ChaincodeStubInterface) pb.Response }</span></span></code> </pre> <br><ul><li>  El m√©todo <strong>Init</strong> se llama al crear instancias o actualizar el c√≥digo de c√≥digo.  Este m√©todo realiza la inicializaci√≥n necesaria del estado del c√≥digo de c√≥digo.  Es importante distinguir en el c√≥digo del m√©todo si la llamada es una instanciaci√≥n o una actualizaci√≥n, de modo que, por error, no inicialice (restablezca) los datos que ya han recibido un estado distinto de cero durante la operaci√≥n del c√≥digo de c√≥digo. </li><li>  Se llama al m√©todo <strong>Invoke</strong> cuando se accede a cualquier funci√≥n del c√≥digo de c√≥digo.  Este m√©todo funciona con el estado de los contratos inteligentes. </li></ul><br><p>  El chaincode se instala en los pares de la red blockchain.  En el nivel del sistema, cada instancia del c√≥digo corresponde a un contenedor acoplado separado conectado a un nodo de red espec√≠fico, que realiza llamadas de despacho a la ejecuci√≥n del c√≥digo. <br>  A diferencia de los contratos inteligentes de Ethereum, la l√≥gica de encadenamiento se puede actualizar, pero esto requiere que todos los nodos que alojan el c√≥digo de c√≥digo instalen una versi√≥n actualizada. </p><br><p>  En respuesta a una llamada a la funci√≥n chaincode desde el exterior a trav√©s del SDK, el chaincode crea un cambio en el estado de la cadena de bloques (conjunto de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lectura y escritura</a> ), as√≠ como eventos.  Un chaincode se refiere a un canal espec√≠fico y puede cambiar datos en un solo canal.  Al mismo tiempo, si el host en el que est√° instalado el c√≥digo tambi√©n tiene acceso a otros canales, en la l√≥gica del c√≥digo puede estar leyendo datos de estos canales. </p><br><p>  Los c√≥digos de cadena especiales para administrar varios aspectos de la operaci√≥n de una red blockchain se denominan c√≥digos de cadena del sistema. </p><br><h3 id="politika-odobreniya-endorsement-policy">  Pol√≠tica de respaldo </h3><br><p>  Una pol√≠tica de aprobaci√≥n define reglas de consenso a nivel de las transacciones generadas por un chaincode espec√≠fico.  La pol√≠tica establece las reglas que determinan qu√© nodos de canal deben crear una transacci√≥n.  Para hacer esto, cada uno de los nodos especificados en la pol√≠tica de aprobaci√≥n debe comenzar el m√©todo de encadenamiento (el paso "Ejecutar"), realizar una "simulaci√≥n", despu√©s de lo cual los resultados firmados ser√°n recopilados y verificados por el SDK que inici√≥ la transacci√≥n (todos los resultados de la simulaci√≥n deben ser id√©nticos, las firmas de todos los nodos requeridos por la pol√≠tica deben estar presentes).  A continuaci√≥n, el SDK env√≠a la transacci√≥n al orden, despu√©s de lo cual todos los nodos que tienen acceso al canal recibir√°n la transacci√≥n a trav√©s del orden y realizar√°n el paso "Validar".  Es importante enfatizar que no todos los nodos del canal deben participar en el paso "Ejecutar". </p><br><p>  La pol√≠tica de aprobaci√≥n se determina en el momento de la instancia o actualizaci√≥n del c√≥digo.  En la versi√≥n 1.3, fue posible establecer pol√≠ticas no solo a nivel de chaincode, sino tambi√©n a nivel de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">claves de respaldo</a> individuales <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">basadas en el estado</a> .  Ejemplos de pol√≠ticas de aprobaci√≥n: </p><br><ul><li>  Nodos A, B, C, D </li><li>  La mayor√≠a de los nodos del canal </li><li>  Al menos 3 nodos de A, B, C, D, E, F </li></ul><br><h3 id="sobytie">  El evento </h3><br><p>  Un evento es un conjunto de datos con nombre que le permite publicar un "feed de actualizaci√≥n" del estado de la cadena de blockchain.  El conjunto de atributos de evento define el chaincode. </p><br><h2 id="infrastruktura-seti">  Infraestructura de red </h2><br><h3 id="uzel-seti-peer">  Anfitri√≥n (par) </h3><br><p>  Un host est√° conectado a un n√∫mero arbitrario de canales para los cuales tiene derechos de acceso.  El host mantiene su versi√≥n de la cadena de bloques y el estado de la cadena de bloques, y tambi√©n proporciona un entorno para ejecutar c√≥digos de cadena.  Si el host no forma parte de la pol√≠tica de aprobaci√≥n, no tiene que configurarse con c√≥digos de cadena. </p><br><p>  En el nivel del software host, el estado actual de la cadena de bloques (estado mundial) se puede almacenar en LevelDB o en CouchDB.  La ventaja de CouchDB es su soporte para consultas enriquecidas usando la sintaxis MongoDB. </p><br><h3 id="orderer">  Orden </h3><br><p>  El servicio de gesti√≥n de transacciones acepta transacciones firmadas como entrada y garantiza que las transacciones se distribuyan entre los nodos de la red en el orden correcto. </p><br><p>  Orderer no ejecuta contratos inteligentes y no contiene cadenas de bloques ni estados de cadenas de bloques.  En este momento (1.3) hay dos implementaciones de <em>orderer</em> : un <em>solo de</em> desarrollo y una versi√≥n basada en Kafka que proporciona tolerancia a fallas de fallas.  Se espera una implementaci√≥n del <em>pedido que</em> respalde la resistencia al comportamiento incorrecto de una cierta fracci√≥n de participantes (tolerancia de falla bizantina) a fines de 2018. </p><br><h3 id="servis-identifikacii-membership-services">  Servicios de identidad </h3><br><p>  En una red de Hyperledger Fabric, todos los miembros tienen identidades conocidas por otros miembros (identidad).  Para la identificaci√≥n, se utiliza la infraestructura de clave p√∫blica (PKI), a trav√©s de la cual se crean certificados X.509 para organizaciones, elementos de infraestructura (nodo, orden), aplicaciones y usuarios finales.  Como resultado, el acceso para leer y modificar datos puede controlarse mediante reglas de acceso a nivel de red, en un solo canal o en la l√≥gica de un contrato inteligente.  En la misma red blockchain, varios servicios de identificaci√≥n de varios tipos pueden funcionar simult√°neamente. </p><br><h1 id="realizaciya-cheynkoda">  Implementaci√≥n del c√≥digo de c√≥digo </h1><br><p>  Chaincode puede considerarse como un objeto que tiene m√©todos que implementan una l√≥gica comercial espec√≠fica.  A diferencia de la OOP cl√°sica, un chaincode no puede tener campos de atributo.  Para trabajar con el estado, cuyo almacenamiento es proporcionado por la plataforma HLF blockchain, se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">usa la</a> capa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ChaincodeStubInterface</a> , que se pasa cuando se <em>invocan los</em> m√©todos <em>Init</em> e <em>Invoke</em> .  Proporciona la capacidad de recibir argumentos de llamada a funciones y realizar cambios en el estado de la cadena de bloques: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ChaincodeStubInterface <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { <span class="hljs-comment"><span class="hljs-comment">// GetArgs returns the arguments intended for the chaincode Init and Invoke GetArgs() [][]byte // InvokeChaincode locally calls the specified chaincode InvokeChaincode(chaincodeName string, args [][]byte, channel string) pb.Response // GetState returns the value of the specified `key` from the ledger. GetState(key string) ([]byte, error) // PutState puts the specified `key` and `value` into the transaction's writeset as a data-write proposal. PutState(key string, value []byte) error // DelState records the specified `key` to be deleted in the writeset of the transaction proposal. DelState(key string) error // GetStateByRange returns a range iterator over a set of keys in the ledger. GetStateByRange(startKey, endKey string) (StateQueryIteratorInterface, error) // CreateCompositeKey combines the given `attributes` to form a composite key. CreateCompositeKey(objectType string, attributes []string) (string, error) // GetCreator returns `SignatureHeader.Creator` (eg an identity of the agent (or user) submitting the transaction. GetCreator() ([]byte, error) // and many more methods }</span></span></code> </pre> <br><p>  En el contrato inteligente Ethereum desarrollado en Solidity, cada m√©todo tiene una funci√≥n p√∫blica.  En el chaincode de Hyperledger Fabric en los m√©todos <em>Init</em> e <em>Invoke</em> utilizando la funci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ChaincodeStubInterface</a> .  <em>GetArgs (),</em> puede obtener los argumentos de la llamada a la funci√≥n en forma de una matriz de matrices de bytes, mientras que el primer elemento de la matriz al llamar a <em>Invoke</em> contiene el nombre de la funci√≥n chaincode.  Porque  La invocaci√≥n de cualquier m√©todo chaincode pasa por el m√©todo Invoke; podemos decir que esta es una implementaci√≥n del patr√≥n del controlador frontal. </p><br><p>  Por ejemplo, si consideramos la implementaci√≥n de la interfaz est√°ndar Ethereum para el token <a href="">ERC-20</a> , el contrato inteligente debe implementar los m√©todos: </p><br><ul><li>  totalSupply () </li><li>  balanceOf (direcci√≥n _propietario) </li><li>  transferencia (direcci√≥n _to, uint256 _valor) </li></ul><br><p>  y otros. En el caso de la implementaci√≥n HLF, el <em>c√≥digo de</em> funci√≥n <em>Invoke</em> debe ser capaz de manejar casos donde el primer argumento para <em>invocar</em> llamadas contiene el nombre de los m√©todos esperados (por ejemplo, "totalSupply" o "balanceOf").  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aqu√≠</a> se puede ver un ejemplo de la implementaci√≥n del est√°ndar ERC-20. </p><br><h2 id="primery-cheynkodov">  Ejemplos de Chaincode </h2><br><p>  Adem√°s de la documentaci√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hyperledger Fabric</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hay</a> algunos ejemplos m√°s de c√≥digos de cadena: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aplicaci√≥n de seguro Blockchain (2018)</a> </li><li>  <a href="">Canicas</a> </li><li>  <a href="">Demostraci√≥n de arrendamiento de autom√≥viles (2017)</a> s </li></ul><br><p>  La implementaci√≥n de los c√≥digos de cadena en estos ejemplos es bastante detallada y contiene mucha l√≥gica repetitiva para seleccionar las funciones de enrutamiento llamadas), verificando el n√∫mero de argumentos, json marshalling / unmarshalling: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *SimpleChaincode)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(stub shim.ChaincodeStubInterface)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pb</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Response</span></span></span></span> { function, args := stub.GetFunctionAndParameters() fmt.Println(<span class="hljs-string"><span class="hljs-string">"invoke is running "</span></span> + function) <span class="hljs-comment"><span class="hljs-comment">// Handle different functions if function == "initMarble" { //create a new marble return t.initMarble(stub, args) } else if function == "transferMarble" { //change owner of a specific marble return t.transferMarble(stub, args) } else if function == "readMarble" { //read a marble return t.readMarble(stub, args) } else ...</span></span></code> </pre><br><p>  Dicha organizaci√≥n del c√≥digo conduce a un deterioro en la legibilidad del c√≥digo y posibles errores, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este</a> , cuando simplemente se olvid√≥ de ordenar los datos de entrada.  Las presentaciones sobre los planes de desarrollo HLF mencionan una revisi√≥n del enfoque para el desarrollo de c√≥digos de cadena, en particular la introducci√≥n de anotaciones en los c√≥digos de cadena de Java, etc., sin embargo, los planes se relacionan con la versi√≥n que se espera solo en 2019.  La experiencia de desarrollar contratos inteligentes ha llevado a la conclusi√≥n de que desarrollar y probar c√≥digos de cadena ser√° m√°s f√°cil si selecciona la funcionalidad b√°sica en una biblioteca separada. </p><br><h1 id="cckit---biblioteka-dlya-razrabotki-i-testirovaniya-cheynkodov">  CCKit: una biblioteca para desarrollar y probar c√≥digos de cadena </h1><br><p>  La biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CCKit</a> resume la pr√°ctica de desarrollar y probar c√≥digos de cadena.  Como parte del desarrollo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">extensiones</a> de chaincode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">,</a> se utiliz√≥ como ejemplo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la</a> biblioteca de extensiones OpenZeppelin para contratos inteligentes de Ethereum.  CCKit utiliza las siguientes soluciones arquitect√≥nicas: </p><br><h2 id="marshrutizaciya-routing-obrascheniy-k-funkciyam-smart-kontrakta">  Enrutamiento de llamadas a funciones de contrato inteligente </h2><br><p>  El enrutamiento se refiere al algoritmo por el cual la aplicaci√≥n responde a una solicitud del cliente.  Este enfoque se utiliza, por ejemplo, en casi todos los marcos http.  El enrutador utiliza ciertas reglas para vincular la solicitud y el controlador de solicitud.  En relaci√≥n con un chaincode, esto es asociar el nombre de la funci√≥n chaincode con la funci√≥n del controlador. </p><br><p>  En los √∫ltimos ejemplos de contratos inteligentes, por ejemplo, en la <a href="">aplicaci√≥n de seguros</a> , esto utiliza la asignaci√≥n entre el nombre de la funci√≥n chaincode y la funci√≥n en el c√≥digo Golang del formulario: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bcFunctions = <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(shim.ChaincodeStubInterface, []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pb</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Response</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Insurance Peer "contract_type_ls": listContractTypes, "contract_type_create": createContractType, ... "theft_claim_process": processTheftClaim, }</span></span></code> </pre> <br><p>  El enrutador CCKit utiliza un enfoque similar al enrutador http, as√≠ como la capacidad de usar el contexto de solicitud para la funci√≥n chaincode y las funciones de middleware </p><br><h2 id="kontekst-obrascheniya-k-funkcii-cheynkoda">  El contexto de la llamada a la funci√≥n del c√≥digo. </h2><br><p>  De manera similar al contexto de solicitud http, que generalmente tiene acceso a los par√°metros de solicitud http, el enrutador CCKit usa el contexto de la llamada a la funci√≥n de <a href="">contrato inteligente</a> , que es una abstracci√≥n sobre <em>shim.ChaincodeStubInterface</em> .  El contexto puede ser el √∫nico argumento para el manejador de la funci√≥n de encadenamiento; a trav√©s de √©l, el manejador puede recibir los argumentos de la llamada a la funci√≥n, as√≠ como el acceso a funcionalidades auxiliares para trabajar con el estado del contrato inteligente (Estado), creando respuestas (Respuesta), etc. </p><br><pre> <code class="go hljs">Context <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Stub() shim.ChaincodeStubInterface Client() (cid.ClientIdentity, error) Response() Response Logger() *shim.ChaincodeLogger Path() <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> State() State Time() (time.Time, error) Args() InterfaceMap Arg(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} ArgString(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> ArgBytes(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> SetArg(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) Get(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} Set(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) SetEvent(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) error }</code> </pre> <br><p>  Porque  El contexto es una interfaz, en ciertos c√≥digos de cadena se puede expandir. </p><br><h2 id="funkcii-promezhutochnoy-obrabotki-middleware">  Funciones de middleware </h2><br><p>  Las funciones de procesamiento intermedio (middleware) se invocan antes de la llamada del manejador del m√©todo del c√≥digo, tienen acceso al contexto de la llamada al m√©todo del c√≥digo y a la siguiente funci√≥n intermedia o directamente al manejador del m√©todo del siguiente (siguiente).  El middleware se puede usar para: </p><br><ul><li>  convertir datos de entrada (en el ejemplo a continuaci√≥n, <em>p.String</em> y <em>p.Struct</em> son middleware) </li><li>  restricciones de acceso a funciones (p <em>.</em> ej., <em>propietario</em> ) </li><li>  finalizaci√≥n del ciclo de procesamiento de solicitudes </li><li>  llamando a la siguiente funci√≥n de procesamiento intermedio desde la pila </li></ul><br><h2 id="konvertaciya-struktur-dannyh">  Conversi√≥n de estructura de datos </h2><br><p>  La interfaz chaincode supone que se proporciona una matriz de conjuntos de bytes a la entrada, cada uno de cuyos elementos es un atributo de la funci√≥n chaincode.  Para evitar el c√°lculo manual de datos de la matriz de bytes al tipo de datos golang (int, cadena, estructura, matriz) de los argumentos de llamada de funci√≥n en cada controlador de la funci√≥n de encadenamiento, los tipos de datos esperados se establecen al momento de crear la regla de enrutamiento en el enrutador CCKit y el tipo se convierte autom√°ticamente .  En el ejemplo que <em>sigue</em> , la funci√≥n <em>carGet</em> espera un argumento de tipo cadena y la funci√≥n <em>carRegister espera una</em> estructura <em>CarPayload</em> .  El argumento tambi√©n se denomina, lo que permite al controlador obtener su valor del contexto por su nombre.  Un ejemplo de un controlador se dar√° a continuaci√≥n.  Protobuf tambi√©n se puede usar para describir el esquema de datos de encadenamiento. </p><br><pre> <code class="go hljs">r.Group(<span class="hljs-string"><span class="hljs-string">`car`</span></span>). Query(<span class="hljs-string"><span class="hljs-string">`List`</span></span>, cars). <span class="hljs-comment"><span class="hljs-comment">// chain code method name is carList Query(`Get`, car, p.String(`id`)). // chain code method name is carGet, method has 1 string argument "id" Invoke(`Register`, carRegister, p.Struct(`car`, &amp;CarPayload{}), // 1 struct argument owner.Only) // allow access to method only for chaincode owner (authority)</span></span></code> </pre> <br><p>  Adem√°s, la conversi√≥n autom√°tica (c√°lculo de referencias) se utiliza al escribir datos en el estado de un contrato inteligente y al crear eventos (el tipo de golang se serializa en una matriz de bytes) </p><br><h2 id="sredstva-otladki-i-loggirovaniya-cheynkodov">  Herramientas para depurar y registrar c√≥digos de cadena </h2><br><p>  Para depurar el c√≥digo, puede usar la extensi√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">depuraci√≥n</a> , que implementa m√©todos de contrato inteligente que le permitir√°n inspeccionar la presencia de claves en el estado del contrato inteligente, as√≠ como tambi√©n leer / cambiar / eliminar directamente el valor por clave. </p><br><p>  Para iniciar sesi√≥n en el contexto de una llamada a una funci√≥n chaincode, se puede utilizar el m√©todo Log (), que devuelve una instancia del registrador utilizado en HLF. </p><br><h2 id="metody-upravleniya-dostupa-k-metodam-smart-kontrakta">  M√©todos de contrato inteligentes m√©todos de control de acceso </h2><br><p>  Como parte de la extensi√≥n del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">propietario</a> , se implementan primitivas b√°sicas para almacenar informaci√≥n sobre el propietario del c√≥digo de cadena instanciado y modificadores de acceso (middleware) para m√©todos de contrato inteligente. </p><br><h2 id="sredstva-testirovaniya-smart-kontraktov">  Herramientas de prueba de contrato inteligente </h2><br><p>  Implementar la red blockchain, instalar e inicializar c√≥digos de cadena es una configuraci√≥n bastante complicada y un procedimiento largo.  El tiempo para reinstalar / actualizar el c√≥digo del contrato inteligente se puede reducir utilizando el modo DEV del contrato inteligente, sin embargo, el proceso de actualizaci√≥n del c√≥digo seguir√° siendo lento. </p><br><p>  El paquete <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">shim</a> contiene una implementaci√≥n de <a href="">MockStub</a> , que envuelve las llamadas al c√≥digo para el c√≥digo, simulando su funcionamiento en el entorno de cadena de bloques HLF.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El uso de MockStub le</a> permite obtener resultados de pruebas casi instant√°neamente y le permite reducir el tiempo de desarrollo.  Si consideramos el esquema general de operaci√≥n del c√≥digo en HLF, MockStub esencialmente reemplaza el SDK, lo que le permite realizar llamadas a las funciones del c√≥digo y simula el entorno para iniciar el c√≥digo en el host. </p><br><p><img src="https://habrastorage.org/webt/3y/ed/z2/3yedz22nfldc41jmcnpjqyto3x0.png"></p><br><p>  El MockStub de la entrega HLF contiene la implementaci√≥n de casi todos los m√©todos de la interfaz <em>shim.ChaincodeStubInterface</em> , sin embargo, en la versi√≥n actual (1.3), carece de la implementaci√≥n de algunos m√©todos importantes, como GetCreator.  Porque  el c√≥digo de cadena puede usar este m√©todo para obtener un certificado de un creador de transacciones para el control de acceso, para una cobertura m√°xima en las pruebas, la capacidad de tener un trozo de este m√©todo es importante. </p><br><p>  La biblioteca CCKit contiene una versi√≥n extendida de <a href="">MockStub</a> , que contiene la implementaci√≥n de los m√©todos faltantes, as√≠ como los m√©todos para trabajar con canales de eventos, etc. </p><br><h2 id="primer-cheynkoda">  Ejemplo de Chaincode </h2><br><p>  Por ejemplo, creemos un chaincode simple para almacenar informaci√≥n sobre autom√≥viles registrados </p><br><h3 id="model-dannyh">  Modelo de datos </h3><br><p>  El estado del c√≥digo de c√≥digo es el almacenamiento de valores clave, en el que la clave es una cadena, el valor es una matriz de bytes.  La pr√°ctica b√°sica es almacenar instancias de estructuras de datos de golang jonalizadas como valores.  En consecuencia, para trabajar con datos en el chaincode, despu√©s de leer el estado, debe desarmar la matriz de bytes. </p><br><p>  Para grabar sobre el autom√≥vil, utilizaremos el siguiente conjunto de atributos: </p><br><ul><li>  Identificador (n√∫mero de carro) </li><li>  Modelo de coche </li><li>  Informaci√≥n del propietario del veh√≠culo </li><li>  Informaci√≥n de tiempo de cambio de datos </li></ul><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Car struct for chaincode state type Car struct { Id string Title string Owner string UpdatedAt time.Time // set by chaincode method }</span></span></code> </pre> <br><p>  Para transferir datos al chaincode, cree una estructura separada que contenga solo los campos que provienen del exterior del chaincode: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// CarPayload chaincode method argument type CarPayload struct { Id string Title string Owner string }</span></span></code> </pre> <br><h3 id="rabota-s-klyuchami">  Trabajar con llaves </h3><br><p>  Las claves de grabaci√≥n en un estado de contrato inteligente son una cadena.  Tambi√©n admite la capacidad de crear claves compuestas en las que partes de la clave est√°n separadas por un byte cero ( <em>U + 0000</em> ) </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCompositeKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(objectType </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, attributes []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span></code> </pre> <br><p>  En <em>CCKit, las</em> funciones de trabajar con el estado de un contrato inteligente pueden crear autom√°ticamente claves para registros si las estructuras transferidas admiten la interfaz <em>Keyer</em> </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Keyer interface for entity containing logic of its key creation type Keyer interface { Key() ([]string, error) }</span></span></code> </pre> <br><p>  Para grabar un autom√≥vil, la funci√≥n de generaci√≥n de claves ser√° la siguiente: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CarEntity = <span class="hljs-string"><span class="hljs-string">`CAR`</span></span> <span class="hljs-comment"><span class="hljs-comment">// Key for car entry in chaincode state func (c Car) Key() ([]string, error) { return []string{CarEntity, c.Id}, nil }</span></span></code> </pre> <br><h3 id="deklaraciya-funkciy-smart-kontrakta-marshrutizaciya">  Declaraci√≥n de funci√≥n de contrato inteligente (enrutamiento) </h3><br><p>  En el m√©todo constructor del chaincode, podemos definir las funciones del chaincode y sus argumentos.  Habr√° 3 funciones en el c√≥digo de registro del autom√≥vil </p><br><ul><li>  carList, devuelve una serie de estructuras de autom√≥viles </li><li>  carGet, acepta un identificador de autom√≥vil y devuelve una estructura de autom√≥vil </li><li>  carRegister, acepta una instancia serializada de la estructura CarPayload y devuelve el resultado del registro.  El acceso a este m√©todo solo es posible para el propietario del chaincode, que se guarda con el middleware del paquete del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">propietario</a> </li></ul><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">New</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">router</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Chaincode</span></span></span></span> { r := router.New(<span class="hljs-string"><span class="hljs-string">`cars`</span></span>) <span class="hljs-comment"><span class="hljs-comment">// also initialized logger with "cars" prefix r.Init(invokeInit) r.Group(`car`). Query(`List`, queryCars). // chain code method name is carList Query(`Get`, queryCar, p.String(`id`)). // chain code method name is carGet, method has 1 string argument "id" Invoke(`Register`, invokeCarRegister, p.Struct(`car`, &amp;CarPayload{}), // 1 struct argument owner.Only) // allow access to method only for chaincode owner (authority) return router.NewChaincode(r) }</span></span></code> </pre> <br><p>  El ejemplo anterior usa la estructura <a href="">Chaincode</a> en la cual el procesamiento de los m√©todos <em>Init</em> e <em>Invoke</em> se delega al enrutador: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> router <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"github.com/hyperledger/fabric/core/chaincode/shim"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/hyperledger/fabric/protos/peer"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// Chaincode default chaincode implementation with router type Chaincode struct { router *Group } // NewChaincode new default chaincode implementation func NewChaincode(r *Group) *Chaincode { return &amp;Chaincode{r} } //======== Base methods ==================================== // // Init initializes chain code - sets chaincode "owner" func (cc *Chaincode) Init(stub shim.ChaincodeStubInterface) peer.Response { // delegate handling to router return cc.router.HandleInit(stub) } // Invoke - entry point for chain code invocations func (cc *Chaincode) Invoke(stub shim.ChaincodeStubInterface) peer.Response { // delegate handling to router return cc.router.Handle(stub) }</span></span></code> </pre> <br><p>  El uso de un enrutador y la estructura b√°sica de Chaincode permite la reutilizaci√≥n de las funciones del controlador.  Por ejemplo, para implementar chaincode sin verificar el acceso a la funci√≥n <code>carRegister</code> , ser√° suficiente crear un nuevo <a href="">m√©todo de construcci√≥n</a> </p><br><h3 id="realizaciya-funkciy-smart-kontrakta">  Implementaci√≥n de funciones de contrato inteligente </h3><br><p>  Funciones de Golang: los controladores de funciones de contrato inteligente en el enrutador <strong>CCKit</strong> pueden ser de tres tipos: </p><br><ul><li>  <em>StubHandlerFunc</em> : la interfaz del controlador est√°ndar, acepta <em>shim.ChaincodeStubInterface</em> , devuelve el <em>par de</em> respuesta est√°ndar. Respuesta </li><li>  <em>ContextHandlerFunc</em> : toma un contexto y devuelve un <em>par. Respuesta</em> </li><li>  <em>HandlerFunc</em> : toma un contexto, devuelve una interfaz y un error.  Se puede devolver una matriz de bytes o cualquier tipo de golang que se convierta autom√°ticamente en una matriz de bytes en funci√≥n de qu√© <em>peer.Response</em> se crea.  El estado de la respuesta ser√° <em>shim.Ok</em> o <em>shim.Error</em> , dependiendo del error pasado. </li></ul><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// StubHandlerFunc acts as raw chaincode invoke method, accepts stub and returns peer.Response StubHandlerFunc func(shim.ChaincodeStubInterface) peer.Response // ContextHandlerFunc use stub context as input parameter ContextHandlerFunc func(Context) peer.Response // HandlerFunc returns result as interface and error, this is converted to peer.Response via response.Create HandlerFunc func(Context) (interface{}, error)</span></span></code> </pre> <br><p>   ,   ,           (   CarPayload) <br>    State ,                      (      ) </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// car get info chaincode method handler func car(c router.Context) (interface{}, error) { return c.State().Get( // get state entry Key(c.ArgString(`id`)), // by composite key using CarKeyPrefix and car.Id &amp;Car{}) // and unmarshal from []byte to Car struct } // cars car list chaincode method handler func cars(c router.Context) (interface{}, error) { return c.State().List( CarKeyPrefix, // get list of state entries of type CarKeyPrefix &amp;Car{}) // unmarshal from []byte and append to []Car slice } // carRegister car register chaincode method handler func carRegister(c router.Context) (interface{}, error) { // arg name defined in router method definition p := c.Arg(`car`).(CarPayload) t, _ := c.Time() // tx time car := &amp;Car{ // data for chaincode state Id: p.Id, Title: p.Title, Owner: p.Owner, UpdatedAt: t, } return car, // peer.Response payload will be json serialized car data c.State().Insert( //put json serialized data to state Key(car.Id), // create composite key using CarKeyPrefix and car.Id car) }</span></span></code> </pre> <br><h3 id="testy-smart-kontrakta">  - </h3><br><p>    -       ‚Äî        ,     .      BDD ‚Äì Behavior Driven Development,          . </p><br><p>  , , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">- Ethereum</a>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ganache-cli</a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">truffle</a> .   golang -  Mockstub. </p><br><h3 id="primer-testa">   </h3><br><p>    ,     .     <a href=""></a> . </p><br><p>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ginkgo</a> ,     Go,      <code>go test</code> .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">gomega</a>        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">expect</a> ,    ,     . </p><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"testing"</span></span> . <span class="hljs-string"><span class="hljs-string">"github.com/onsi/ginkgo"</span></span> . <span class="hljs-string"><span class="hljs-string">"github.com/onsi/gomega"</span></span> examplecert <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/examples/cert"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/extensions/owner"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/identity"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/state"</span></span> testcc <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/testing"</span></span> expectcc <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/testing/expect"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestCars</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { RegisterFailHandler(Fail) RunSpecs(t, <span class="hljs-string"><span class="hljs-string">"Cars Suite"</span></span>) }</code> </pre> <br><p>      ,   <em>CarPayload</em> : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Payloads = []*Car{{ Id: <span class="hljs-string"><span class="hljs-string">`A777MP77`</span></span>, Title: <span class="hljs-string"><span class="hljs-string">`VAZ`</span></span>, Owner: <span class="hljs-string"><span class="hljs-string">`victor`</span></span>, }, { Id: <span class="hljs-string"><span class="hljs-string">`O888OO77`</span></span>, Title: <span class="hljs-string"><span class="hljs-string">`YOMOBIL`</span></span>, Owner: <span class="hljs-string"><span class="hljs-string">`alexander`</span></span>, }, { Id: <span class="hljs-string"><span class="hljs-string">`O222OO177`</span></span>, Title: <span class="hljs-string"><span class="hljs-string">`Lambo`</span></span>, Owner: <span class="hljs-string"><span class="hljs-string">`hodl`</span></span>, }}</code> </pre> <br><p>     MockStub   Cars. </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//Create chaincode mock cc := testcc.NewMockStub(`cars`, New())</span></span></code> </pre> <br><p>  Porque   cars      ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> . </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// load actor certificates actors, err := identity.ActorsFromPemFile(`SOME_MSP`, map[string]string{ `authority`: `s7techlab.pem`, `someone`: `victor-nosov.pem`}, examplecert.Content)</span></span></code> </pre> <br><p>   <em>BeforeSuite</em>    <em>Car</em>      <em>authority</em>     <em>Init</em>    .  ,    <em>Cars</em>   Init       <em>Init</em> ,    . </p><br><pre> <code class="go hljs">BeforeSuite(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// init chaincode expectcc.ResponseOk(cc.From(actors[`authority`]).Init()) // init chaincode from authority })</span></span></code> </pre> <br><p>          . ,          <em>CarRegister</em> ,              . </p><br><pre> <code class="go hljs">It(<span class="hljs-string"><span class="hljs-string">"Allow authority to add information about car"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//invoke chaincode method from authority actor expectcc.ResponseOk(cc.From(actors[`authority`]).Invoke(`carRegister`, Payloads[0])) }) It("Disallow non authority to add information about car", func() { //invoke chaincode method from non authority actor expectcc.ResponseError( cc.From(actors[`someone`]).Invoke(`carRegister`, Payloads[0]), owner.ErrOwnerOnly) // expect "only owner" error })</span></span></code> </pre> <br><p>             : </p><br><pre> <code class="go hljs">It(<span class="hljs-string"><span class="hljs-string">"Disallow authority to add duplicate information about car"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { expectcc.ResponseError( cc.From(actors[<span class="hljs-string"><span class="hljs-string">`authority`</span></span>]).Invoke(<span class="hljs-string"><span class="hljs-string">`carRegister`</span></span>, Payloads[<span class="hljs-number"><span class="hljs-number">0</span></span>]), state.ErrKeyAlreadyExists) <span class="hljs-comment"><span class="hljs-comment">//expect car id already exists })</span></span></code> </pre> <br><h1 id="zaklyuchenie">  Conclusi√≥n </h1><br><p> - HLF        Go, Java, JavaScript, ,    , -  (Solidity)     /   -.      /       . </p><br><p>    HLF  ,  ,      (     .).  Hypeledger Fabric        , ..     . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es426705/">https://habr.com/ru/post/es426705/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es426695/index.html">C√°maras de visi√≥n artificial para entusiastas. ¬øC√≥mo usar la c√°mara para la navegaci√≥n fuera de l√≠nea?</a></li>
<li><a href="../es426697/index.html">Trabajar con dispositivos LibUsb desde Android</a></li>
<li><a href="../es426699/index.html">Prueba de Python con pytest. Simple, r√°pido, eficiente y escalable. Pr√≥logo e Introducci√≥n</a></li>
<li><a href="../es426701/index.html">Flutter: una nueva mirada al desarrollo multiplataforma</a></li>
<li><a href="../es426703/index.html">Lo que fue interesante en DataVizDay en Minsk</a></li>
<li><a href="../es426707/index.html">Sistema de aprobaci√≥n. Como inventamos la bicicleta</a></li>
<li><a href="../es426709/index.html">Temporizadores de JavaScript: todo lo que necesitas saber</a></li>
<li><a href="../es426713/index.html">Intel Xeon W-3175X: 28 n√∫cleos para el hogar</a></li>
<li><a href="../es426717/index.html">La ilusi√≥n del enga√±o: una ilusi√≥n √≥ptica visual basada en pron√≥sticos retro</a></li>
<li><a href="../es426719/index.html">Hackathon sobre Data Science en SIBUR: c√≥mo fue</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>