<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧖🏼 👩🏼 🏨 Hyperledger Fabric Desarrollo y prueba de contratos inteligentes 📩 📨 🎁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hyperledger Fabric (HLF) es una plataforma de código abierto que utiliza tecnología de libro mayor distribuido (DLT), diseñada para desarrollar aplica...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hyperledger Fabric Desarrollo y prueba de contratos inteligentes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426705/"><p>  Hyperledger Fabric (HLF) es una plataforma de código abierto que utiliza tecnología de libro mayor distribuido (DLT), diseñada para desarrollar aplicaciones que funcionan en un entorno de red empresarial creado y controlado por un consorcio de organizaciones que utilizan reglas de acceso (con permiso). </p><br><p>  La plataforma admite contratos inteligentes, en términos HLF: códigos de cadena creados en lenguajes generales como Golang, JavaScript, Java, a diferencia de, por ejemplo, Ethereum, que utiliza un lenguaje de Solidez de funcionalidad limitada orientado a contratos. (LLL, Viper, etc.). </p><br><p><img src="https://habrastorage.org/webt/w4/em/ps/w4empss606_8k1h8tvkcmfim4c8.png"></p><br><p>  El desarrollo y la prueba de códigos de cadena, debido a la necesidad de implementar un número significativo de componentes de la red blockchain, puede ser un proceso bastante largo con un alto tiempo dedicado a probar los cambios.  Este artículo analiza un enfoque para el rápido desarrollo y prueba de los contratos inteligentes de HLF Golang utilizando la biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CCKit</a> . </p><a name="habracut"></a><br><h2 id="prilozhenie-na-baze-hlf">  Aplicación basada en HLF </h2><br><p>  Desde el punto de vista del desarrollador, la aplicación blockchain consta de dos partes principales: </p><br><ul><li>  <strong>En cadena</strong> : contratos (programas) inteligentes que operan en un entorno aislado de la red blockchain que determina las reglas para la creación y la composición de los atributos de la transacción.  En un contrato inteligente, las acciones principales son leer, actualizar y eliminar datos del estado de la red blockchain.  Se debe enfatizar que eliminar datos de un estado deja información de que estos datos estaban presentes. </li><li>  <strong>Off-chain</strong> es una aplicación (por ejemplo, una API) que interactúa con el entorno blockchain a través del SDK.  La interacción se entiende como llamar a funciones de contratos inteligentes y monitorear eventos de contratos inteligentes: los eventos externos pueden causar cambios en los datos del contrato inteligente, mientras que los eventos en el contrato inteligente pueden desencadenar acciones en sistemas externos. </li></ul><br><p>  Por lo general, los datos se leen a través del nodo de red blockchain "hogar".  Para registrar datos, la aplicación envía solicitudes a los nodos de organizaciones que participan en la "política de aprobación" de un contrato inteligente en particular. </p><br><p>  Para desarrollar código fuera de la cadena (API, etc.), se utiliza un SDK especializado que encapsula la interacción con los nodos de la cadena de bloques, recolectando respuestas, etc.  Para HLF, hay implementaciones de SDK para Go ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2</a> ), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Node.Js</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Java</a> </p><br><h2 id="komponenty-hyperledger-fabric">  Componentes de tela Hyperledger </h2><br><h3 id="kanal">  Canal </h3><br><p>  Un canal es una subred separada de nodos que admite una cadena de bloques aislada (libro mayor), así como el estado actual (clave-valor) de la cadena de bloques ( <em>estado mundial</em> ) utilizado para operar contratos inteligentes.  Un host puede tener acceso a un número arbitrario de canales. </p><br><h3 id="tranzakciya">  Transacción </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Una transacción en Hyperledger Fabric</a> es una actualización atómica del estado de una cadena de bloques, el resultado de la ejecución del método chaincode.  Una transacción consiste en una solicitud para llamar a un método chaincode con algunos argumentos (Propuesta de transacción) firmados por el nodo llamante, y un conjunto de respuestas (Respuesta de propuesta de transacción) de los nodos en los que la transacción fue "confirmada" (Endoso).  Las respuestas contienen información sobre los pares clave-valor cambiantes del estado de la cadena de bloques del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">conjunto de lectura-escritura</a> y la información de servicio (firmas y certificados de nodos que confirman la transacción).  Porque  Las cadenas de bloques de canales individuales están físicamente separadas, una transacción solo se puede realizar en el contexto de un canal. </p><br><p>  Las plataformas de cadena de bloques "clásicas", como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bitcoin</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ethereum</a> , utilizan el ciclo de transacción de Ejecución de pedidos ejecutado por todos los nodos, lo que limita la escalabilidad de la red de cadena de bloques. </p><br><p><img src="https://habrastorage.org/webt/ad/-b/ud/ad-budtoazz80tcc2vcgmzyahve.png"></p><br><p>  Hyperledger Fabric utiliza una arquitectura de ejecución y distribución de transacciones que tiene 3 operaciones principales: </p><br><ul><li><p>  Ejecución ( <strong>ejecución</strong> ): creación mediante un contrato inteligente que se ejecuta en uno o varios nodos de la red, transacciones: cambios atómicos en el estado de un registro distribuido ( <em>aprobación</em> ) </p><br></li><li><p>  Pedidos: pedido y agrupación de transacciones en bloques por parte del servicio de pedidos especializado mediante un algoritmo de consenso conectable. </p><br></li><li><p>  Validar: verificación por parte de los nodos de la red de las transacciones que provienen del orden antes de colocar la información de ellos en su copia del registro distribuido </p><br></li></ul><br><p><img src="https://habrastorage.org/webt/xw/ss/xj/xwssxjcfyfmsydsfnyl4oey_coe.png"></p><br><p>  Este enfoque le permite llevar a cabo la fase de ejecución de la transacción antes de que ingrese a la red blockchain, así como escalar horizontalmente el funcionamiento de los nodos de la red. </p><br><h3 id="cheynkod">  Chaincode </h3><br><p>  Un chaincode, que también se puede llamar un contrato inteligente, es un programa escrito en Golang, JavaScript (HLF 1.1+) o Java (HLF 1.3+), que define las reglas para crear transacciones que cambian el estado de una cadena de bloques.  El programa se ejecuta simultáneamente en varios nodos independientes de la red distribuida de nodos de blockchain, lo que crea un entorno neutral para la ejecución de contratos inteligentes al conciliar los resultados del programa en todos los nodos necesarios para la "confirmación" de la transacción. </p><br><p>  El código debe implementar una interfaz que consta de métodos: </p><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Chaincode <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Init is called during Instantiate transaction Init(stub ChaincodeStubInterface) pb.Response // Invoke is called to update or query the ledger Invoke(stub ChaincodeStubInterface) pb.Response }</span></span></code> </pre> <br><ul><li>  El método <strong>Init</strong> se llama al crear instancias o actualizar el código de código.  Este método realiza la inicialización necesaria del estado del código de código.  Es importante distinguir en el código del método si la llamada es una instanciación o una actualización, de modo que, por error, no inicialice (restablezca) los datos que ya han recibido un estado distinto de cero durante la operación del código de código. </li><li>  Se llama al método <strong>Invoke</strong> cuando se accede a cualquier función del código de código.  Este método funciona con el estado de los contratos inteligentes. </li></ul><br><p>  El chaincode se instala en los pares de la red blockchain.  En el nivel del sistema, cada instancia del código corresponde a un contenedor acoplado separado conectado a un nodo de red específico, que realiza llamadas de despacho a la ejecución del código. <br>  A diferencia de los contratos inteligentes de Ethereum, la lógica de encadenamiento se puede actualizar, pero esto requiere que todos los nodos que alojan el código de código instalen una versión actualizada. </p><br><p>  En respuesta a una llamada a la función chaincode desde el exterior a través del SDK, el chaincode crea un cambio en el estado de la cadena de bloques (conjunto de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lectura y escritura</a> ), así como eventos.  Un chaincode se refiere a un canal específico y puede cambiar datos en un solo canal.  Al mismo tiempo, si el host en el que está instalado el código también tiene acceso a otros canales, en la lógica del código puede estar leyendo datos de estos canales. </p><br><p>  Los códigos de cadena especiales para administrar varios aspectos de la operación de una red blockchain se denominan códigos de cadena del sistema. </p><br><h3 id="politika-odobreniya-endorsement-policy">  Política de respaldo </h3><br><p>  Una política de aprobación define reglas de consenso a nivel de las transacciones generadas por un chaincode específico.  La política establece las reglas que determinan qué nodos de canal deben crear una transacción.  Para hacer esto, cada uno de los nodos especificados en la política de aprobación debe comenzar el método de encadenamiento (el paso "Ejecutar"), realizar una "simulación", después de lo cual los resultados firmados serán recopilados y verificados por el SDK que inició la transacción (todos los resultados de la simulación deben ser idénticos, las firmas de todos los nodos requeridos por la política deben estar presentes).  A continuación, el SDK envía la transacción al orden, después de lo cual todos los nodos que tienen acceso al canal recibirán la transacción a través del orden y realizarán el paso "Validar".  Es importante enfatizar que no todos los nodos del canal deben participar en el paso "Ejecutar". </p><br><p>  La política de aprobación se determina en el momento de la instancia o actualización del código.  En la versión 1.3, fue posible establecer políticas no solo a nivel de chaincode, sino también a nivel de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">claves de respaldo</a> individuales <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">basadas en el estado</a> .  Ejemplos de políticas de aprobación: </p><br><ul><li>  Nodos A, B, C, D </li><li>  La mayoría de los nodos del canal </li><li>  Al menos 3 nodos de A, B, C, D, E, F </li></ul><br><h3 id="sobytie">  El evento </h3><br><p>  Un evento es un conjunto de datos con nombre que le permite publicar un "feed de actualización" del estado de la cadena de blockchain.  El conjunto de atributos de evento define el chaincode. </p><br><h2 id="infrastruktura-seti">  Infraestructura de red </h2><br><h3 id="uzel-seti-peer">  Anfitrión (par) </h3><br><p>  Un host está conectado a un número arbitrario de canales para los cuales tiene derechos de acceso.  El host mantiene su versión de la cadena de bloques y el estado de la cadena de bloques, y también proporciona un entorno para ejecutar códigos de cadena.  Si el host no forma parte de la política de aprobación, no tiene que configurarse con códigos de cadena. </p><br><p>  En el nivel del software host, el estado actual de la cadena de bloques (estado mundial) se puede almacenar en LevelDB o en CouchDB.  La ventaja de CouchDB es su soporte para consultas enriquecidas usando la sintaxis MongoDB. </p><br><h3 id="orderer">  Orden </h3><br><p>  El servicio de gestión de transacciones acepta transacciones firmadas como entrada y garantiza que las transacciones se distribuyan entre los nodos de la red en el orden correcto. </p><br><p>  Orderer no ejecuta contratos inteligentes y no contiene cadenas de bloques ni estados de cadenas de bloques.  En este momento (1.3) hay dos implementaciones de <em>orderer</em> : un <em>solo de</em> desarrollo y una versión basada en Kafka que proporciona tolerancia a fallas de fallas.  Se espera una implementación del <em>pedido que</em> respalde la resistencia al comportamiento incorrecto de una cierta fracción de participantes (tolerancia de falla bizantina) a fines de 2018. </p><br><h3 id="servis-identifikacii-membership-services">  Servicios de identidad </h3><br><p>  En una red de Hyperledger Fabric, todos los miembros tienen identidades conocidas por otros miembros (identidad).  Para la identificación, se utiliza la infraestructura de clave pública (PKI), a través de la cual se crean certificados X.509 para organizaciones, elementos de infraestructura (nodo, orden), aplicaciones y usuarios finales.  Como resultado, el acceso para leer y modificar datos puede controlarse mediante reglas de acceso a nivel de red, en un solo canal o en la lógica de un contrato inteligente.  En la misma red blockchain, varios servicios de identificación de varios tipos pueden funcionar simultáneamente. </p><br><h1 id="realizaciya-cheynkoda">  Implementación del código de código </h1><br><p>  Chaincode puede considerarse como un objeto que tiene métodos que implementan una lógica comercial específica.  A diferencia de la OOP clásica, un chaincode no puede tener campos de atributo.  Para trabajar con el estado, cuyo almacenamiento es proporcionado por la plataforma HLF blockchain, se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">usa la</a> capa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ChaincodeStubInterface</a> , que se pasa cuando se <em>invocan los</em> métodos <em>Init</em> e <em>Invoke</em> .  Proporciona la capacidad de recibir argumentos de llamada a funciones y realizar cambios en el estado de la cadena de bloques: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ChaincodeStubInterface <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { <span class="hljs-comment"><span class="hljs-comment">// GetArgs returns the arguments intended for the chaincode Init and Invoke GetArgs() [][]byte // InvokeChaincode locally calls the specified chaincode InvokeChaincode(chaincodeName string, args [][]byte, channel string) pb.Response // GetState returns the value of the specified `key` from the ledger. GetState(key string) ([]byte, error) // PutState puts the specified `key` and `value` into the transaction's writeset as a data-write proposal. PutState(key string, value []byte) error // DelState records the specified `key` to be deleted in the writeset of the transaction proposal. DelState(key string) error // GetStateByRange returns a range iterator over a set of keys in the ledger. GetStateByRange(startKey, endKey string) (StateQueryIteratorInterface, error) // CreateCompositeKey combines the given `attributes` to form a composite key. CreateCompositeKey(objectType string, attributes []string) (string, error) // GetCreator returns `SignatureHeader.Creator` (eg an identity of the agent (or user) submitting the transaction. GetCreator() ([]byte, error) // and many more methods }</span></span></code> </pre> <br><p>  En el contrato inteligente Ethereum desarrollado en Solidity, cada método tiene una función pública.  En el chaincode de Hyperledger Fabric en los métodos <em>Init</em> e <em>Invoke</em> utilizando la función <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ChaincodeStubInterface</a> .  <em>GetArgs (),</em> puede obtener los argumentos de la llamada a la función en forma de una matriz de matrices de bytes, mientras que el primer elemento de la matriz al llamar a <em>Invoke</em> contiene el nombre de la función chaincode.  Porque  La invocación de cualquier método chaincode pasa por el método Invoke; podemos decir que esta es una implementación del patrón del controlador frontal. </p><br><p>  Por ejemplo, si consideramos la implementación de la interfaz estándar Ethereum para el token <a href="">ERC-20</a> , el contrato inteligente debe implementar los métodos: </p><br><ul><li>  totalSupply () </li><li>  balanceOf (dirección _propietario) </li><li>  transferencia (dirección _to, uint256 _valor) </li></ul><br><p>  y otros. En el caso de la implementación HLF, el <em>código de</em> función <em>Invoke</em> debe ser capaz de manejar casos donde el primer argumento para <em>invocar</em> llamadas contiene el nombre de los métodos esperados (por ejemplo, "totalSupply" o "balanceOf").  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aquí</a> se puede ver un ejemplo de la implementación del estándar ERC-20. </p><br><h2 id="primery-cheynkodov">  Ejemplos de Chaincode </h2><br><p>  Además de la documentación de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hyperledger Fabric</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hay</a> algunos ejemplos más de códigos de cadena: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aplicación de seguro Blockchain (2018)</a> </li><li>  <a href="">Canicas</a> </li><li>  <a href="">Demostración de arrendamiento de automóviles (2017)</a> s </li></ul><br><p>  La implementación de los códigos de cadena en estos ejemplos es bastante detallada y contiene mucha lógica repetitiva para seleccionar las funciones de enrutamiento llamadas), verificando el número de argumentos, json marshalling / unmarshalling: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *SimpleChaincode)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(stub shim.ChaincodeStubInterface)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pb</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Response</span></span></span></span> { function, args := stub.GetFunctionAndParameters() fmt.Println(<span class="hljs-string"><span class="hljs-string">"invoke is running "</span></span> + function) <span class="hljs-comment"><span class="hljs-comment">// Handle different functions if function == "initMarble" { //create a new marble return t.initMarble(stub, args) } else if function == "transferMarble" { //change owner of a specific marble return t.transferMarble(stub, args) } else if function == "readMarble" { //read a marble return t.readMarble(stub, args) } else ...</span></span></code> </pre><br><p>  Dicha organización del código conduce a un deterioro en la legibilidad del código y posibles errores, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este</a> , cuando simplemente se olvidó de ordenar los datos de entrada.  Las presentaciones sobre los planes de desarrollo HLF mencionan una revisión del enfoque para el desarrollo de códigos de cadena, en particular la introducción de anotaciones en los códigos de cadena de Java, etc., sin embargo, los planes se relacionan con la versión que se espera solo en 2019.  La experiencia de desarrollar contratos inteligentes ha llevado a la conclusión de que desarrollar y probar códigos de cadena será más fácil si selecciona la funcionalidad básica en una biblioteca separada. </p><br><h1 id="cckit---biblioteka-dlya-razrabotki-i-testirovaniya-cheynkodov">  CCKit: una biblioteca para desarrollar y probar códigos de cadena </h1><br><p>  La biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CCKit</a> resume la práctica de desarrollar y probar códigos de cadena.  Como parte del desarrollo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">extensiones</a> de chaincode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">,</a> se utilizó como ejemplo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la</a> biblioteca de extensiones OpenZeppelin para contratos inteligentes de Ethereum.  CCKit utiliza las siguientes soluciones arquitectónicas: </p><br><h2 id="marshrutizaciya-routing-obrascheniy-k-funkciyam-smart-kontrakta">  Enrutamiento de llamadas a funciones de contrato inteligente </h2><br><p>  El enrutamiento se refiere al algoritmo por el cual la aplicación responde a una solicitud del cliente.  Este enfoque se utiliza, por ejemplo, en casi todos los marcos http.  El enrutador utiliza ciertas reglas para vincular la solicitud y el controlador de solicitud.  En relación con un chaincode, esto es asociar el nombre de la función chaincode con la función del controlador. </p><br><p>  En los últimos ejemplos de contratos inteligentes, por ejemplo, en la <a href="">aplicación de seguros</a> , esto utiliza la asignación entre el nombre de la función chaincode y la función en el código Golang del formulario: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bcFunctions = <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(shim.ChaincodeStubInterface, []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pb</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Response</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Insurance Peer "contract_type_ls": listContractTypes, "contract_type_create": createContractType, ... "theft_claim_process": processTheftClaim, }</span></span></code> </pre> <br><p>  El enrutador CCKit utiliza un enfoque similar al enrutador http, así como la capacidad de usar el contexto de solicitud para la función chaincode y las funciones de middleware </p><br><h2 id="kontekst-obrascheniya-k-funkcii-cheynkoda">  El contexto de la llamada a la función del código. </h2><br><p>  De manera similar al contexto de solicitud http, que generalmente tiene acceso a los parámetros de solicitud http, el enrutador CCKit usa el contexto de la llamada a la función de <a href="">contrato inteligente</a> , que es una abstracción sobre <em>shim.ChaincodeStubInterface</em> .  El contexto puede ser el único argumento para el manejador de la función de encadenamiento; a través de él, el manejador puede recibir los argumentos de la llamada a la función, así como el acceso a funcionalidades auxiliares para trabajar con el estado del contrato inteligente (Estado), creando respuestas (Respuesta), etc. </p><br><pre> <code class="go hljs">Context <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Stub() shim.ChaincodeStubInterface Client() (cid.ClientIdentity, error) Response() Response Logger() *shim.ChaincodeLogger Path() <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> State() State Time() (time.Time, error) Args() InterfaceMap Arg(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} ArgString(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> ArgBytes(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> SetArg(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) Get(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} Set(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) SetEvent(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) error }</code> </pre> <br><p>  Porque  El contexto es una interfaz, en ciertos códigos de cadena se puede expandir. </p><br><h2 id="funkcii-promezhutochnoy-obrabotki-middleware">  Funciones de middleware </h2><br><p>  Las funciones de procesamiento intermedio (middleware) se invocan antes de la llamada del manejador del método del código, tienen acceso al contexto de la llamada al método del código y a la siguiente función intermedia o directamente al manejador del método del siguiente (siguiente).  El middleware se puede usar para: </p><br><ul><li>  convertir datos de entrada (en el ejemplo a continuación, <em>p.String</em> y <em>p.Struct</em> son middleware) </li><li>  restricciones de acceso a funciones (p <em>.</em> ej., <em>propietario</em> ) </li><li>  finalización del ciclo de procesamiento de solicitudes </li><li>  llamando a la siguiente función de procesamiento intermedio desde la pila </li></ul><br><h2 id="konvertaciya-struktur-dannyh">  Conversión de estructura de datos </h2><br><p>  La interfaz chaincode supone que se proporciona una matriz de conjuntos de bytes a la entrada, cada uno de cuyos elementos es un atributo de la función chaincode.  Para evitar el cálculo manual de datos de la matriz de bytes al tipo de datos golang (int, cadena, estructura, matriz) de los argumentos de llamada de función en cada controlador de la función de encadenamiento, los tipos de datos esperados se establecen al momento de crear la regla de enrutamiento en el enrutador CCKit y el tipo se convierte automáticamente .  En el ejemplo que <em>sigue</em> , la función <em>carGet</em> espera un argumento de tipo cadena y la función <em>carRegister espera una</em> estructura <em>CarPayload</em> .  El argumento también se denomina, lo que permite al controlador obtener su valor del contexto por su nombre.  Un ejemplo de un controlador se dará a continuación.  Protobuf también se puede usar para describir el esquema de datos de encadenamiento. </p><br><pre> <code class="go hljs">r.Group(<span class="hljs-string"><span class="hljs-string">`car`</span></span>). Query(<span class="hljs-string"><span class="hljs-string">`List`</span></span>, cars). <span class="hljs-comment"><span class="hljs-comment">// chain code method name is carList Query(`Get`, car, p.String(`id`)). // chain code method name is carGet, method has 1 string argument "id" Invoke(`Register`, carRegister, p.Struct(`car`, &amp;CarPayload{}), // 1 struct argument owner.Only) // allow access to method only for chaincode owner (authority)</span></span></code> </pre> <br><p>  Además, la conversión automática (cálculo de referencias) se utiliza al escribir datos en el estado de un contrato inteligente y al crear eventos (el tipo de golang se serializa en una matriz de bytes) </p><br><h2 id="sredstva-otladki-i-loggirovaniya-cheynkodov">  Herramientas para depurar y registrar códigos de cadena </h2><br><p>  Para depurar el código, puede usar la extensión de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">depuración</a> , que implementa métodos de contrato inteligente que le permitirán inspeccionar la presencia de claves en el estado del contrato inteligente, así como también leer / cambiar / eliminar directamente el valor por clave. </p><br><p>  Para iniciar sesión en el contexto de una llamada a una función chaincode, se puede utilizar el método Log (), que devuelve una instancia del registrador utilizado en HLF. </p><br><h2 id="metody-upravleniya-dostupa-k-metodam-smart-kontrakta">  Métodos de contrato inteligentes métodos de control de acceso </h2><br><p>  Como parte de la extensión del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">propietario</a> , se implementan primitivas básicas para almacenar información sobre el propietario del código de cadena instanciado y modificadores de acceso (middleware) para métodos de contrato inteligente. </p><br><h2 id="sredstva-testirovaniya-smart-kontraktov">  Herramientas de prueba de contrato inteligente </h2><br><p>  Implementar la red blockchain, instalar e inicializar códigos de cadena es una configuración bastante complicada y un procedimiento largo.  El tiempo para reinstalar / actualizar el código del contrato inteligente se puede reducir utilizando el modo DEV del contrato inteligente, sin embargo, el proceso de actualización del código seguirá siendo lento. </p><br><p>  El paquete <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">shim</a> contiene una implementación de <a href="">MockStub</a> , que envuelve las llamadas al código para el código, simulando su funcionamiento en el entorno de cadena de bloques HLF.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El uso de MockStub le</a> permite obtener resultados de pruebas casi instantáneamente y le permite reducir el tiempo de desarrollo.  Si consideramos el esquema general de operación del código en HLF, MockStub esencialmente reemplaza el SDK, lo que le permite realizar llamadas a las funciones del código y simula el entorno para iniciar el código en el host. </p><br><p><img src="https://habrastorage.org/webt/3y/ed/z2/3yedz22nfldc41jmcnpjqyto3x0.png"></p><br><p>  El MockStub de la entrega HLF contiene la implementación de casi todos los métodos de la interfaz <em>shim.ChaincodeStubInterface</em> , sin embargo, en la versión actual (1.3), carece de la implementación de algunos métodos importantes, como GetCreator.  Porque  el código de cadena puede usar este método para obtener un certificado de un creador de transacciones para el control de acceso, para una cobertura máxima en las pruebas, la capacidad de tener un trozo de este método es importante. </p><br><p>  La biblioteca CCKit contiene una versión extendida de <a href="">MockStub</a> , que contiene la implementación de los métodos faltantes, así como los métodos para trabajar con canales de eventos, etc. </p><br><h2 id="primer-cheynkoda">  Ejemplo de Chaincode </h2><br><p>  Por ejemplo, creemos un chaincode simple para almacenar información sobre automóviles registrados </p><br><h3 id="model-dannyh">  Modelo de datos </h3><br><p>  El estado del código de código es el almacenamiento de valores clave, en el que la clave es una cadena, el valor es una matriz de bytes.  La práctica básica es almacenar instancias de estructuras de datos de golang jonalizadas como valores.  En consecuencia, para trabajar con datos en el chaincode, después de leer el estado, debe desarmar la matriz de bytes. </p><br><p>  Para grabar sobre el automóvil, utilizaremos el siguiente conjunto de atributos: </p><br><ul><li>  Identificador (número de carro) </li><li>  Modelo de coche </li><li>  Información del propietario del vehículo </li><li>  Información de tiempo de cambio de datos </li></ul><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Car struct for chaincode state type Car struct { Id string Title string Owner string UpdatedAt time.Time // set by chaincode method }</span></span></code> </pre> <br><p>  Para transferir datos al chaincode, cree una estructura separada que contenga solo los campos que provienen del exterior del chaincode: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// CarPayload chaincode method argument type CarPayload struct { Id string Title string Owner string }</span></span></code> </pre> <br><h3 id="rabota-s-klyuchami">  Trabajar con llaves </h3><br><p>  Las claves de grabación en un estado de contrato inteligente son una cadena.  También admite la capacidad de crear claves compuestas en las que partes de la clave están separadas por un byte cero ( <em>U + 0000</em> ) </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCompositeKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(objectType </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, attributes []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span></code> </pre> <br><p>  En <em>CCKit, las</em> funciones de trabajar con el estado de un contrato inteligente pueden crear automáticamente claves para registros si las estructuras transferidas admiten la interfaz <em>Keyer</em> </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Keyer interface for entity containing logic of its key creation type Keyer interface { Key() ([]string, error) }</span></span></code> </pre> <br><p>  Para grabar un automóvil, la función de generación de claves será la siguiente: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CarEntity = <span class="hljs-string"><span class="hljs-string">`CAR`</span></span> <span class="hljs-comment"><span class="hljs-comment">// Key for car entry in chaincode state func (c Car) Key() ([]string, error) { return []string{CarEntity, c.Id}, nil }</span></span></code> </pre> <br><h3 id="deklaraciya-funkciy-smart-kontrakta-marshrutizaciya">  Declaración de función de contrato inteligente (enrutamiento) </h3><br><p>  En el método constructor del chaincode, podemos definir las funciones del chaincode y sus argumentos.  Habrá 3 funciones en el código de registro del automóvil </p><br><ul><li>  carList, devuelve una serie de estructuras de automóviles </li><li>  carGet, acepta un identificador de automóvil y devuelve una estructura de automóvil </li><li>  carRegister, acepta una instancia serializada de la estructura CarPayload y devuelve el resultado del registro.  El acceso a este método solo es posible para el propietario del chaincode, que se guarda con el middleware del paquete del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">propietario</a> </li></ul><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">New</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">router</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Chaincode</span></span></span></span> { r := router.New(<span class="hljs-string"><span class="hljs-string">`cars`</span></span>) <span class="hljs-comment"><span class="hljs-comment">// also initialized logger with "cars" prefix r.Init(invokeInit) r.Group(`car`). Query(`List`, queryCars). // chain code method name is carList Query(`Get`, queryCar, p.String(`id`)). // chain code method name is carGet, method has 1 string argument "id" Invoke(`Register`, invokeCarRegister, p.Struct(`car`, &amp;CarPayload{}), // 1 struct argument owner.Only) // allow access to method only for chaincode owner (authority) return router.NewChaincode(r) }</span></span></code> </pre> <br><p>  El ejemplo anterior usa la estructura <a href="">Chaincode</a> en la cual el procesamiento de los métodos <em>Init</em> e <em>Invoke</em> se delega al enrutador: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> router <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"github.com/hyperledger/fabric/core/chaincode/shim"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/hyperledger/fabric/protos/peer"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// Chaincode default chaincode implementation with router type Chaincode struct { router *Group } // NewChaincode new default chaincode implementation func NewChaincode(r *Group) *Chaincode { return &amp;Chaincode{r} } //======== Base methods ==================================== // // Init initializes chain code - sets chaincode "owner" func (cc *Chaincode) Init(stub shim.ChaincodeStubInterface) peer.Response { // delegate handling to router return cc.router.HandleInit(stub) } // Invoke - entry point for chain code invocations func (cc *Chaincode) Invoke(stub shim.ChaincodeStubInterface) peer.Response { // delegate handling to router return cc.router.Handle(stub) }</span></span></code> </pre> <br><p>  El uso de un enrutador y la estructura básica de Chaincode permite la reutilización de las funciones del controlador.  Por ejemplo, para implementar chaincode sin verificar el acceso a la función <code>carRegister</code> , será suficiente crear un nuevo <a href="">método de construcción</a> </p><br><h3 id="realizaciya-funkciy-smart-kontrakta">  Implementación de funciones de contrato inteligente </h3><br><p>  Funciones de Golang: los controladores de funciones de contrato inteligente en el enrutador <strong>CCKit</strong> pueden ser de tres tipos: </p><br><ul><li>  <em>StubHandlerFunc</em> : la interfaz del controlador estándar, acepta <em>shim.ChaincodeStubInterface</em> , devuelve el <em>par de</em> respuesta estándar. Respuesta </li><li>  <em>ContextHandlerFunc</em> : toma un contexto y devuelve un <em>par. Respuesta</em> </li><li>  <em>HandlerFunc</em> : toma un contexto, devuelve una interfaz y un error.  Se puede devolver una matriz de bytes o cualquier tipo de golang que se convierta automáticamente en una matriz de bytes en función de qué <em>peer.Response</em> se crea.  El estado de la respuesta será <em>shim.Ok</em> o <em>shim.Error</em> , dependiendo del error pasado. </li></ul><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// StubHandlerFunc acts as raw chaincode invoke method, accepts stub and returns peer.Response StubHandlerFunc func(shim.ChaincodeStubInterface) peer.Response // ContextHandlerFunc use stub context as input parameter ContextHandlerFunc func(Context) peer.Response // HandlerFunc returns result as interface and error, this is converted to peer.Response via response.Create HandlerFunc func(Context) (interface{}, error)</span></span></code> </pre> <br><p>   ,   ,           (   CarPayload) <br>    State ,                      (      ) </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// car get info chaincode method handler func car(c router.Context) (interface{}, error) { return c.State().Get( // get state entry Key(c.ArgString(`id`)), // by composite key using CarKeyPrefix and car.Id &amp;Car{}) // and unmarshal from []byte to Car struct } // cars car list chaincode method handler func cars(c router.Context) (interface{}, error) { return c.State().List( CarKeyPrefix, // get list of state entries of type CarKeyPrefix &amp;Car{}) // unmarshal from []byte and append to []Car slice } // carRegister car register chaincode method handler func carRegister(c router.Context) (interface{}, error) { // arg name defined in router method definition p := c.Arg(`car`).(CarPayload) t, _ := c.Time() // tx time car := &amp;Car{ // data for chaincode state Id: p.Id, Title: p.Title, Owner: p.Owner, UpdatedAt: t, } return car, // peer.Response payload will be json serialized car data c.State().Insert( //put json serialized data to state Key(car.Id), // create composite key using CarKeyPrefix and car.Id car) }</span></span></code> </pre> <br><h3 id="testy-smart-kontrakta">  - </h3><br><p>    -       —        ,     .      BDD – Behavior Driven Development,          . </p><br><p>  , , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">- Ethereum</a>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ganache-cli</a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">truffle</a> .   golang -  Mockstub. </p><br><h3 id="primer-testa">   </h3><br><p>    ,     .     <a href=""></a> . </p><br><p>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ginkgo</a> ,     Go,      <code>go test</code> .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">gomega</a>        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">expect</a> ,    ,     . </p><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"testing"</span></span> . <span class="hljs-string"><span class="hljs-string">"github.com/onsi/ginkgo"</span></span> . <span class="hljs-string"><span class="hljs-string">"github.com/onsi/gomega"</span></span> examplecert <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/examples/cert"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/extensions/owner"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/identity"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/state"</span></span> testcc <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/testing"</span></span> expectcc <span class="hljs-string"><span class="hljs-string">"github.com/s7techlab/cckit/testing/expect"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestCars</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { RegisterFailHandler(Fail) RunSpecs(t, <span class="hljs-string"><span class="hljs-string">"Cars Suite"</span></span>) }</code> </pre> <br><p>      ,   <em>CarPayload</em> : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Payloads = []*Car{{ Id: <span class="hljs-string"><span class="hljs-string">`A777MP77`</span></span>, Title: <span class="hljs-string"><span class="hljs-string">`VAZ`</span></span>, Owner: <span class="hljs-string"><span class="hljs-string">`victor`</span></span>, }, { Id: <span class="hljs-string"><span class="hljs-string">`O888OO77`</span></span>, Title: <span class="hljs-string"><span class="hljs-string">`YOMOBIL`</span></span>, Owner: <span class="hljs-string"><span class="hljs-string">`alexander`</span></span>, }, { Id: <span class="hljs-string"><span class="hljs-string">`O222OO177`</span></span>, Title: <span class="hljs-string"><span class="hljs-string">`Lambo`</span></span>, Owner: <span class="hljs-string"><span class="hljs-string">`hodl`</span></span>, }}</code> </pre> <br><p>     MockStub   Cars. </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//Create chaincode mock cc := testcc.NewMockStub(`cars`, New())</span></span></code> </pre> <br><p>  Porque   cars      ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> . </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// load actor certificates actors, err := identity.ActorsFromPemFile(`SOME_MSP`, map[string]string{ `authority`: `s7techlab.pem`, `someone`: `victor-nosov.pem`}, examplecert.Content)</span></span></code> </pre> <br><p>   <em>BeforeSuite</em>    <em>Car</em>      <em>authority</em>     <em>Init</em>    .  ,    <em>Cars</em>   Init       <em>Init</em> ,    . </p><br><pre> <code class="go hljs">BeforeSuite(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// init chaincode expectcc.ResponseOk(cc.From(actors[`authority`]).Init()) // init chaincode from authority })</span></span></code> </pre> <br><p>          . ,          <em>CarRegister</em> ,              . </p><br><pre> <code class="go hljs">It(<span class="hljs-string"><span class="hljs-string">"Allow authority to add information about car"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//invoke chaincode method from authority actor expectcc.ResponseOk(cc.From(actors[`authority`]).Invoke(`carRegister`, Payloads[0])) }) It("Disallow non authority to add information about car", func() { //invoke chaincode method from non authority actor expectcc.ResponseError( cc.From(actors[`someone`]).Invoke(`carRegister`, Payloads[0]), owner.ErrOwnerOnly) // expect "only owner" error })</span></span></code> </pre> <br><p>             : </p><br><pre> <code class="go hljs">It(<span class="hljs-string"><span class="hljs-string">"Disallow authority to add duplicate information about car"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { expectcc.ResponseError( cc.From(actors[<span class="hljs-string"><span class="hljs-string">`authority`</span></span>]).Invoke(<span class="hljs-string"><span class="hljs-string">`carRegister`</span></span>, Payloads[<span class="hljs-number"><span class="hljs-number">0</span></span>]), state.ErrKeyAlreadyExists) <span class="hljs-comment"><span class="hljs-comment">//expect car id already exists })</span></span></code> </pre> <br><h1 id="zaklyuchenie">  Conclusión </h1><br><p> - HLF        Go, Java, JavaScript, ,    , -  (Solidity)     /   -.      /       . </p><br><p>    HLF  ,  ,      (     .).  Hypeledger Fabric        , ..     . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es426705/">https://habr.com/ru/post/es426705/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es426695/index.html">Cámaras de visión artificial para entusiastas. ¿Cómo usar la cámara para la navegación fuera de línea?</a></li>
<li><a href="../es426697/index.html">Trabajar con dispositivos LibUsb desde Android</a></li>
<li><a href="../es426699/index.html">Prueba de Python con pytest. Simple, rápido, eficiente y escalable. Prólogo e Introducción</a></li>
<li><a href="../es426701/index.html">Flutter: una nueva mirada al desarrollo multiplataforma</a></li>
<li><a href="../es426703/index.html">Lo que fue interesante en DataVizDay en Minsk</a></li>
<li><a href="../es426707/index.html">Sistema de aprobación. Como inventamos la bicicleta</a></li>
<li><a href="../es426709/index.html">Temporizadores de JavaScript: todo lo que necesitas saber</a></li>
<li><a href="../es426713/index.html">Intel Xeon W-3175X: 28 núcleos para el hogar</a></li>
<li><a href="../es426717/index.html">La ilusión del engaño: una ilusión óptica visual basada en pronósticos retro</a></li>
<li><a href="../es426719/index.html">Hackathon sobre Data Science en SIBUR: cómo fue</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>