<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤴🏿 🍛 🌴 如何制作键盘-矩阵 🚍 👷 🥔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="发表者：Komar akaMichałTrybus；英语-俄语翻译： firerock 
 原文：blog.komar.be/how-to-make-a-keyboard-the-matrix
 
 这是键盘系列文章中的第一篇；我希望他不会成为最后一个。我想从头开始完成键盘制造课程。今天，我将讨论数...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>如何制作键盘-矩阵</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/394585/"><sub><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发表者</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komar</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> akaMichałTrybus；</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">英语-俄语翻译</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：   </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">firerock </font></font></a></sub><br>
<sup><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">原文</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blog.komar.be/how-to-make-a-keyboard-the-matrix</font></font></a></sup><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
这是键盘系列文章中的第一篇；</font><font style="vertical-align: inherit;">我希望他不会成为最后一个。</font><font style="vertical-align: inherit;">我想从头开始完成键盘制造课程。</font><font style="vertical-align: inherit;">今天，我将讨论数字输入输出和键盘矩阵。</font><font style="vertical-align: inherit;">用电子领域的基础知识武装自己-开始吧。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么是矩阵？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将如何制作矩阵？最重要的是-为什么根本需要它？好吧，这主要是由于构建键盘的微控制器的物理限制。事实是，随着微控制器和可编程逻辑电路输出数量的增加，它们的尺寸也随之增加，这反过来又增加了能耗，功能，但最重要的是价格。因此，您可以选择性能低但很适合但输入和输出数量少的便宜芯片，也可以选择性能却大大超出您要求的功能更强大的芯片。但是只有这种功能强大的芯片才会有足够的输出来连接键盘上的每个按钮。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
几十年来，在各种技巧的帮助下，电子技术的发展已人为地扩展了处理器和控制器的内置通信功能。</font><font style="vertical-align: inherit;">矩阵的创建是一种非常适合机械触点（按钮）的方法。</font><font style="vertical-align: inherit;">要了解其工作原理，需要一些基本知识。</font><font style="vertical-align: inherit;">在继续之前，请刷新</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">欧姆定律</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一点理论</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要了解数字电子的工作原理，您需要学习两个基本原理。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">原理一</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">说，电路内的通信过程与发送或接收信号无关。为了确保两个设备之间的通信，您只需使用导电材料将它们的发现相互连接即可。此后，假设两端的材料状态（电压和电流）相同。当然，实际上并不是这样，但是对于通讯速度较慢和导体短的情况，我们的假设很好。事实证明，发送和接收信息实际上是其共享。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从发射器的侧面，您只需更改导体的电气状态（通过向导体注入直流电，改变其电势），希望接收器能够检测到这种变化并正确理解它。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从这个原理还可以得出结论，通信方向和电流方向之间没有关系。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">许多人错误地假设了相反的说法，这使他们无法理解电子设备的工作原理。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果要发送逻辑电平``0''，则通常为此将发送器输出端的电压降至0 V，并且电流开始从接收器流向发送器，以便接收器可以确定逻辑电平对应于``0''。 （而电流的反向意味着电路中某处存在负电位-通常，在数字电子产品中不会发生这种情况。）另一方面，施加等于电源电压的电压来传输逻辑电平“ 1”，而且由于这通常是电路中的最高电压，因此除了从发射器流向接收器的电流外，别无其他电流。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">原则二</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在于以下事实：在不改变导体状态的情况下不可能确定导体的状态。</font><font style="vertical-align: inherit;">无论您要测量电压还是电流都无所谓-在任何情况下，都必须使电子流过测量设备。</font><font style="vertical-align: inherit;">电子的流动-这是电流，由于它流动，这意味着在您要连接进行测量的节点中，电流和电压已经改变（请参阅</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基尔霍夫定律</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">因此，如果您需要通过更改电连接到另一个输出的输出的状态来“传输”信息，则需要保持此状态，这意味着您必须遵守接收器施加的所有要求。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">纽扣</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
机械按钮（在此上下文中，“机械”一词未与短语“机械键盘”连接）仅是一对金属触点，它们通过触点电连接两个端子。当然，还有其他类型的开关在结构上更复杂并且具有更多的输出，但是它们对我们来说并不有趣，因为它们未在键盘中使用。</font></font><br>
<br>
<img src="https://habrastorage.org/files/910/b1e/9b7/910b1e9b776543e0a3cf502aca657473.jpg"><br>
<sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cherry MX按钮。图片来源：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deskthority Wiki</font></font></a></sub><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好了，我们如何将按钮连接到微控制器的输入？从根本上讲，任何输入都可以使用两个可能的逻辑电平进行操作：“ 0”和“ 1”。通常的做法是将接近0 V的电压视为逻辑零，并将接近电源电压（通常为5 V或3.3 V）的电压视为逻辑单元。但是问题在于，仅机械按钮无法控制电压。它控制电流-也就是说，如果我们通过按钮连接两个具有不同电势的节点，则只有当按下按钮时，这些节点之间的电流才会流动。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，如果添加一个电阻器，则可以非常容易地将电流转换为电压。</font></font><br>
<br>
<img src="https://habrastorage.org/files/2df/7ff/d4e/2df7ffd4e1584d38a170b8028fd06021.png"><br>
<sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上拉电阻器按钮</font></font></sub><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
看一下这个图。当未按下按钮（电路断开）时，电流不会流过，因此节点“ A”上的电压将接近电源电压VCC（实际上，比VCC小，电阻两端的压降等于R•I）。当按下按钮（电路闭合）时，电流流过电阻器接地。假设闭合按钮的电阻很小（数百毫安量级），则节点“ A”处的电压将接近“ 0”。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这种配置中，电阻器被称为上拉电阻，因为它“将电压上拉”至VCC电平。而且，如果不通过电阻器连接到电源，则节点“ A”将根本没有电压（在这种情况下，微电路的输出称为“悬空”或处于高阻抗状态）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
应当指出，在大多数现代微控制器内部，已经存在可以使用该程序快速连接或断开的上拉电阻。</font><font style="vertical-align: inherit;">因此，将按钮连接到微控制器的主要方法如下：按钮的一个引脚连接到微控制器的输入，另一引脚连接到地。</font><font style="vertical-align: inherit;">在这种情况下，如果未按下按钮，则将“ 1”发送到微控制器，如果按下，则将“ 0”发送给微控制器。</font><font style="vertical-align: inherit;">也许这与直觉相矛盾，但是这种连接方法是最流行的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请注意，如果我们将按钮的一个引脚悬空悬空，也就是说，如果我们不在任何地方连接它，则此按钮将根本无法工作：如果您不按该按钮，则不会影响微控制器输出的电气状态。</font><font style="vertical-align: inherit;">组成矩阵时，我们仍将使用此属性。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">矩阵原理</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
键盘矩阵的基本原理是能够将多个按钮连接到微控制器的一个输入。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用晶体管或正确配置的</font><font style="vertical-align: inherit;">微控制器</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">输出，</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以使按钮一次接地，而其余的则悬空。</font><font style="vertical-align: inherit;">每个按钮的其余结论组合到一个节点中并连接到</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">输入</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">微控制器。我降低了上拉电阻，因为我们知道它在输入阶段已经存在于微控制器内部。我们轮流“打开”每个按钮，通过微控制器的相应输出将其输出编号1连接到地面，此后，通过从其输出编号2移除电压，我们可以读取输入处按钮的状态。连接到相同输入的其他按钮不会影响在他的情况下，因为他们的第一结论目前悬而未决。下图说明了这种想法。</font></font><br>
<br>
<img src="https://habrastorage.org/files/e7e/2db/cca/e7e2dbccac834fef95bb30b1bdb134d3.png"><br>
<sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">许多按钮，一个输入（节点“ A”）</font></font></sub><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
“ A”是微控制器的唯一输入，“ C1” ..“ Cn”是其输出。在其中一个输出上设置逻辑“ 0”，也就是说，该触点在微电路内部以某种方式接地，因此，电流将始终流到该触点（根据第一个基本原理）。现在，当按下连接到该输出的按钮时，通过它，输入“ A”将立即“按下”到地面，并将其设置为“ 0”。按下其他按钮不会有任何改变，因为目前它们的接地输出未连接到任何地方。当需要轮询下一个按钮时，我们从当前输出中删除逻辑“ 0”并将此电平设置为下一个输出，以便在任何时候都将仅激活微控制器的一个输出。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这种配置（当输出接地或完全禁用时）被称为开漏（OS）输出（历史上带有集电极开路（OK））。在这里，我做了一些简化-实际上，除非将其物理断开，否则无法将其与电路完全断开。但是对于简单的数字I / O，这种简化是非常合适的。大多数微控制器都能够以编程方式配置其输出触点以在OS模式下工作。但是，如果我们没有这样的机会呢？还有另一种配置-推挽模式；如今，此选项是最受欢迎的选项之一。此配置的工作方式略有不同。在“ 0”状态下，输出仍被推至地，但在“ 1”状态下，其被拉至VCC电源电压，这样空气中的输出不再悬挂，现在它本身就可以成为电流的来源。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
矩阵设计将发生什么变化？</font><font style="vertical-align: inherit;">如果我们不打算同时按下多个按钮，则没有一个。</font><font style="vertical-align: inherit;">但是，如果要这样做，请看一下图并想象一秒钟会发生什么。</font><font style="vertical-align: inherit;">通过单击两个按钮，我们将两个较低的输出连接到一个闭环中。</font><font style="vertical-align: inherit;">如果其中一个同时处于状态“ 0”，而另一个处于状态“ 1”，则电流将从设置为“ 1”的输出流向设置为“ 0”的输出。</font><font style="vertical-align: inherit;">而且，由于该电流不受任何限制（没有电阻器），因此电路不仅会变得不稳定，而且还会飞出芯片。</font><font style="vertical-align: inherit;">好吧，当然，通常不可能考虑逻辑状态。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">添加行</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以将前面的示例视为由一行组成的矩阵。现在，通过添加额外的行来增加它。实际上，如果我们可以在一个输入上悬挂一整行，那为什么不能在一个输出上悬挂一整列按钮呢？的确，有一个前提条件-列中的每个按钮必须连接到微控制器的单独输入。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果我们以规则矩阵的形式排列按钮，则此条件将自动满足。下图显示了由</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">列和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行</font><font style="vertical-align: inherit;">组成的按钮矩阵的外观</font><font style="vertical-align: inherit;">（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尚未注意绿色数字</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br>
<img src="https://habrastorage.org/files/8f8/989/832/8f89898324d64a3ead1d3b63fa8ecaa1.png"><br>
<sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">简单的键盘矩阵</font></font></sub><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
读取此矩阵非常简单。我们一次轮询一列。通过将输出“ C1” ..“ Cn”之一接地将选择读取列（OS模式下的输出转换为“ 0”）。现在，交替轮询“ R1” ..“ Rm”行，我们可以确定所选列的每个按钮的状态。即使按下其他列中的按钮，也不会影响任何东西，因为此刻它们的接地线悬在空中（或者，正如电子设备中所说的那样，它们处于Hi-Z状态）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在对整个列进行轮询之后，我们转到下一列，放开当前输出，然后将下一列推为零。当轮询所有列时，认为矩阵扫描已完成。如果一切操作都足够快，那么最快的排字机将不会注意到列轮询之间的间隔。即使使用16 MHz的微控制器，我们也可以轻松地每秒扫描整个矩阵一千次，而在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hi-games.net上</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">测试中最快的排字机</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">则</font></a><font style="vertical-align: inherit;">达到了每分钟203个单词（wpm）的速度-也就是说，在单击时的点击次数少于17次第二。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用矩阵设计键盘时，我们减少了连接所有键所需的引脚数。但是为了将结论的数量减少到最小，我们需要组成一个矩阵，以使列数尽可能接近行数。在理想情况下，如果按钮的数量为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n²</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，那么矩阵可以实现的最佳效果是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">繁忙的微控制器引脚。但是，今天，在编译矩阵时，很少有人试图将所涉及的分支数量减到最少，因为现代微控制器通常具有足够的自由结论。另外，矩阵的最大优化随后可能会带来不便-电路板的布线或最终设备中的导线分布会更加复杂。因此，值得采用更方便的方法：编译矩阵时，请尝试遵循按钮的物理排列。在这种情况下，对于标准的计算机键盘，取决于所需的布局，最简单的矩阵将仅具有6行和一定数量的列。当然，从涉及的结论数量的角度来看，该解决方案不是最佳的，但是在将来，至少将简化布线。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，如果我们没有开漏输出呢？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可能会问：如果所选的微控制器仍然没有OS模式，我们该怎么办？</font><font style="vertical-align: inherit;">好吧，我们已经弄清楚了会发生什么问题，将输出拉到VCC（即将它们“连接”到电源）并不是一个好主意。</font><font style="vertical-align: inherit;">解决这个问题有很多方法。</font><font style="vertical-align: inherit;">其中不仅有特殊的OS输出缓冲区，甚至还有带有OS输出的移位寄存器-进一步减少了所涉及的支路数量。</font><font style="vertical-align: inherit;">但是还有另一种非常流行的技术，该技术通常用于计算机键盘的设计中（实际上，它在过去已被广泛使用）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当将位于同一行上的两个按钮同时按下时，就会出现连接到推挽输出的列的问题，并且同时按下按钮会轮询其中一个按钮所在的列。</font></font><br>
<br>
<img src="https://habrastorage.org/files/46e/3a8/4b1/46e3a84b1b774e1097d07503e3911c65.png"><br>
<sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">推挽输出的问题</font></font></sub><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
从输出拉至“ 1”（并且未在Hi-Z状态下挂起）后，电流开始流动。它先经过最接近的关闭按钮，然后再经过查询列中的关闭按钮，最后直接流入设置为“ 0”的输出。这可能导致任何事情-从无法可靠读取键盘状态到微控制器本身发生故障。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，由于我们被迫以某种方式处理此问题，因此我们可以应用一个绝妙的技巧：将推挽输出变成一种漏极开路输出。我经常在旧键盘的设计中遇到这种解决方案。鉴于电流仅应流入输出（连接到列），而决不流出，我们可以使用二极管限制电流方向。二极管是一种简单的设备，仅允许电流沿一个方向流动。在电路上二极管的图像中，三角形代表指示该方向的箭头。如果在微控制器的每个输出和矩阵的相应列的导体之间放置一个二极管，那么我们将实现我们的目标-现在电流只能流入输出，因为这些导体到达其列的每个按钮。原来如果将输出设置为“ 1”，则电流将不会流向任何地方，这几乎将其变成漏极开路输出。当然，他没有达到真正的操作系统，但是它解决了我们键盘矩阵中的闭合电流电路的问题。回到矩阵的倒数第二张图片，但这一次</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">考虑绿色二极管</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以了解此技巧的工作原理。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自然，减少二极管的数量是有意义的。</font><font style="vertical-align: inherit;">为此，您可以通过增加行数来减少列数。</font><font style="vertical-align: inherit;">而且，如果所得结果与键盘的实际布局不太吻合，则可以将矩阵“旋转” 90°（将行与列交换）。</font><font style="vertical-align: inherit;">可能性是无限的。</font><font style="vertical-align: inherit;">但是如今，出现了大量易于使用且便于爱好的微控制器，因此今天所描述的技术实际上已不在本地键盘项目中使用。</font><font style="vertical-align: inherit;">还好</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">幻像点击（重影）</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您对Clavs感兴趣，那么您必须已经满足了这个条件。不幸的是，在键盘世界中，它常常被错误地解释。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当同时按下位于同一行上的几个按钮会干扰矩阵的正常读取时，我们已经很熟悉这种情况。可以说，我们已经解决了这个问题。现在，让我们看看如果您单击同一行和同一列中的多个按钮会发生什么。</font></font><br>
<br>
<img src="https://habrastorage.org/files/c1c/830/afd/c1c830afdd614656a91cd6c3ba061cf5.png"><br>
<sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">幻像按下的示例</font></font></sub><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
在图中，同时按下三个按钮。其中两个位于“ C2”列中，两个位于“ Rm”行中。这意味着按下的一个按钮与另一个按下的按钮共享行，而按下的第三个按钮共享列。在这种情况下会发生</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">幻影按压</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。想象一下，我们当前正在查询“ C1”列（即，它被压在地面上-处于状态“ 0”）。被按下按钮的这种特征性和弦导致以下结果：即使未按下左上按钮，行“ R2”仍处于状态“ 0”，因为它被列“ C1”（位于“ 0”中）向下压到地面按下三个按钮。结果，键盘控制器将左上按钮读为“按下”，而不管它实际上是否被按下。所描述的情况称为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">幻像按下</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重影</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），因为同时按下的按钮的某些组合会引起其他按钮（幻像按键）的幻像响应，尽管实际上这些其他按钮并未被按下。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然，有一些方法可以保护打字员和游戏玩家免受幻像的影响，并且这些方法已广泛用于现代计算机键盘中。您可以捕获幻影按下的瞬间并将其阻止。普通人无法同时完美地按下或释放两个键。因此，足够快地扫描矩阵，我们可以假设两次通过矩阵之间，只有一个按钮可以改变其状态。在这种情况下，控制器接受单次按下并监视在矩阵遍之间按下两个或更多按钮时的情况发生。假设矩阵扫描的发生速度极不可能发生此类情况的常规发生，我们可以得出结论，刚刚按下的按钮之一是幻像。因此，控制器必须忽略所有这些单击。此外，更安全的是不要立即通知计算机有关键盘状态的更改-首先，有必要等到所有这些操作消失后再说。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
还有另一种方法。您可以确定触发“第三”按钮时的情况，并阻止此按和所有后续按。在幻像响应消失并且情况再次恢复正常之前，请勿释放锁定。要实现此方法，程序必须记住当前按下的按钮（通常会以这种方式记住），以拒绝后续的按钮操作，在已记录同时单击的行和列中。如果您明智地编写程序，将仅阻止有问题的响应，并且所有后续响应将照常接受-再次违反规则的响应除外。一旦控制器拒绝按下行和列中已经同时进行操作的每个按钮，就会发现，取决于某些按钮的状态，其他可能根本没有注册。这种情况通常称为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阻塞</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">干扰</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。也就是说，阻止其他按钮同时操作的按钮，原来是“阻塞”了键盘的一部分。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从用户的角度来看，可以同时按下一列中的所有按钮（而没有按下另一列中的按钮），但是仅当列中每个按钮的操作不超过一个时，才同时按下一行中的所有按钮。单列中的按钮也是如此-仅当按钮位于“不忙”行中时，才会记录其他触发器。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
人们经常将“ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">幻像触发</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”和“ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阻止触发</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”（“ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重影</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”和“</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">干扰</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”），这对我个人而言是个谜-我认为这些术语非常直观。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在使用我们刚刚检查过的矩阵的键盘中，无法避免幻像响应或阻塞。</font><font style="vertical-align: inherit;">由于日常工作中的幻影响应是不可接受的，因此要与之抗衡，几乎所有橡胶圆顶键盘制造商都会使用各种技巧，并且阻塞开始起作用。</font><font style="vertical-align: inherit;">问题：如何以尽可能少发生阻塞而不是由普通键盘组合引起的方式构成矩阵？</font><font style="vertical-align: inherit;">实际上，这是整本书的一个好话题。</font><font style="vertical-align: inherit;">这就是为什么消费类电子琴矩阵如此混乱并总是阻止好心情（如双关语）的原因。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所有按钮的二极管-基本解决方案</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您再次查看有关幻像点击的图片，您会注意到应该指责右下按钮。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是此按钮是在这种情况下电流“向上”流动的唯一按钮。因此，如果我们不希望电流“上升”电流阻止我们正常读取矩阵，那么我们就引入二极管，使电流可以严格地从上至下流经各列，并流入微控制器的输出。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不幸的是，这里无法保存-您必须在每个按钮上放置一个二极管。如果我们谈论极性，那么您应该已经弄清楚，在这种特殊情况下，二极管必须“从上到下”通过电流，也就是说，它们的阴极（“箭头”）必须查看微控制器的输出（列），而阳极应该寻址到输入（行）。</font></font><br>
<br>
<img src="https://habrastorage.org/files/5b6/8bf/f0f/5b68bff0fcf043eaac33246af5320dd1.png"><br>
<sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">摘要矩阵</font></font></sub><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
二极管位于按钮的哪一侧无关紧要。主要是要注意正确的极性。请记住，在这种情况下，电流将始终从输入流向输出。顺便说一句，如果将输入上拉电源，并且输出处于OS模式，则将始终发生这种情况。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过这种方法，结果证明电流将始终“右下”流动，这消除了同时按下多个按钮时出现的闭合电流环路的现象。</font><font style="vertical-align: inherit;">此外，这种设计是唯一可以为键盘提供完整NKRO的设计。</font><font style="vertical-align: inherit;">另外，值得一提的是（尽管这似乎很明显），微控制器输出不具有OS模式的问题现在可以自动解决。</font><font style="vertical-align: inherit;">按每个按钮顺序安装的二极管可以节省电路的输出，但不会比以前考虑的选项差，因为该选项应该在每列上另外放置一个二极管。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">滚存</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
是的，我知道文字已经太长了。</font><font style="vertical-align: inherit;">但是我仍然要添加最后一章，因为我认为如果没有它，本文将是不完整的。</font><font style="vertical-align: inherit;">因此，翻转是键盘同时进行多次轻击的能力。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">克罗</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
KRO是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">密钥翻转</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">键侧翻</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），并且通常此缩写是由一些数题为。例如，2KRO表示两键过渡。</font><font style="vertical-align: inherit;">而且，仅当</font><font style="vertical-align: inherit;">键盘</font><font style="vertical-align: inherit;">能够注册</font><i><font style="vertical-align: inherit;">x个</font></i><font style="vertical-align: inherit;">同时击键时，</font><font style="vertical-align: inherit;">键盘才具有</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">键翻转</font><font style="vertical-align: inherit;">，无论使用了哪个按钮和顺序。大多数现代橡胶快球键盘都有2KRO。但是，这并不意味着这些键盘上允许的击键次数始终限于</font><i><font style="vertical-align: inherit;">x</font></i><font style="vertical-align: inherit;">。实际上，这意味着可以</font><font style="vertical-align: inherit;">完全保证</font><i><font style="vertical-align: inherit;">x-</font></i><font style="vertical-align: inherit;"> click </font><font style="vertical-align: inherit;">支持</font><font style="vertical-align: inherit;">。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
根据矩阵的设计和控制器的类型，来自不同制造商的两个2KRO键盘的行为可能会非常不同。</font><font style="vertical-align: inherit;">一个总是只能接受两次同时单击，而另一个可以轻松消化更多。</font><font style="vertical-align: inherit;">似乎最后一个键盘是2KRO宣布的，因为某些组合键（很可能不太可能）仍会导致其阻止按下其他按钮。</font><font style="vertical-align: inherit;">由于这意味着在使用此键盘时，三个键及更多键的某些组合将无法使用，因此该公司宣布将其命名为2KRO。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">恩克罗</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
术语NKRO表示</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N键翻转</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它用于表示支持所有同时按下的键的组合的键盘。</font><font style="vertical-align: inherit;">但是请记住，NKRO矩阵和NKRO键盘是两个很大的不同。</font><font style="vertical-align: inherit;">例如，如果我们在本文中介绍的矩阵的最终实现支持NKRO（考虑到正确编写的固件），那么这完全不能说明使用该矩阵的键盘也将支持NKRO。</font><font style="vertical-align: inherit;">这可能是由于键盘所连接的通信端口所施加的限制所致。</font><font style="vertical-align: inherit;">另一个原因可能是制造商的节俭，他们总是在这里和那里省钱。</font><font style="vertical-align: inherit;">在以下部分中，我将尝试解释连接到PS / 2和USB时NKRO的问题。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">总结</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然，工作表很好，但概念并不是那么简单-尤其是对于不是电子工程师的读者。</font><font style="vertical-align: inherit;">我希望我能解释一切。</font><font style="vertical-align: inherit;">尽我所能，我试图写得尽可能清晰。</font><font style="vertical-align: inherit;">因此，对于某些人来说，这篇文章似乎很无聊。</font><font style="vertical-align: inherit;">好吧，如果您迷恋电子产品，那么您很可能根本不应该阅读它；）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
无论如何，请</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我知道</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本文是否对您有用，以及是否值得写续集。</font><font style="vertical-align: inherit;">如果是这样，那么我将坐下来进行下一个“系列”。</font></font><br>
<br>
<sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MichałTrybus </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2013年9月2日</font></font></sub></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN394585/">https://habr.com/ru/post/zh-CN394585/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN394573/index.html">第一个3D打印办公室在迪拜开业</a></li>
<li><a href="../zh-CN394575/index.html">Itseez团队再次在英特尔工作</a></li>
<li><a href="../zh-CN394577/index.html">Kronos项目和来自新西伯利亚学术园区Kronos研究小组（KRG）的鲜为人知的俄罗斯团队</a></li>
<li><a href="../zh-CN394579/index.html">仿生手：历史，未来和现实</a></li>
<li><a href="../zh-CN394583/index.html">我们如何在照明方面实现节能，并通过测光表产生更多的能量</a></li>
<li><a href="../zh-CN394589/index.html">最小的众筹（第1部分）</a></li>
<li><a href="../zh-CN394591/index.html">基于片段的导航快速入门指南</a></li>
<li><a href="../zh-CN394595/index.html">ISS BEAM模块上的宇航员如何喘气：延时视频</a></li>
<li><a href="../zh-CN394599/index.html">具有动画支持的Krita 3.0稳定版</a></li>
<li><a href="../zh-CN394601/index.html">超高铁列车将产生振动</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>