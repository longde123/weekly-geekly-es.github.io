<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎅🏾 📴 👆🏾 Swift 5.0. Was gibt's Neues? 👶🏻 🤾🏾 👣</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Swift 5 - die lang erwartete Veröffentlichung, die mehrere Dutzend Verbesserungen und Korrekturen enthält. Das Hauptziel der Veröffentlichung von Swif...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Swift 5.0. Was gibt's Neues?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/avito/blog/444862/"><p>  Swift 5 - die lang erwartete Veröffentlichung, die mehrere Dutzend Verbesserungen und Korrekturen enthält.  Das Hauptziel der Veröffentlichung von Swift 5.0 war jedoch die Erreichung der ABI-Stabilität.  In diesem Artikel erfahren Sie, was ABI ist und welche stabile ABI iOS / MacOS-Entwicklern bietet.  Wir werden auch einige neue Funktionen von Swift 5 analysieren. </p><br><p><img src="https://habrastorage.org/webt/-p/8s/zk/-p8szkb7m3mn49xjavc3_nvkjyk.png"></p><a name="habracut"></a><br><h1 id="abi-stability">  ABI-Stabilität </h1><br><p>  ABI ist eine binäre Anwendungsschnittstelle.  Ein ABI kann als eine Reihe von Regeln betrachtet werden, die es einem Linker ermöglichen, kompilierte Komponentenmodule zu kombinieren. </p><br><p>  Dementsprechend wird das Folgende in ABI beschrieben. </p><br><ol><li>  Der Wegcode wird von verschiedenen Modulen aufgerufen, einschließlich Systemmodulen. </li><li>  Das Format zum Übergeben von Argumenten und zum Abrufen des Rückgabewerts von Funktionen. </li><li>  RAM-Datenlayout-Algorithmen. </li><li>  Speicherverwaltung, ARC. </li><li>  Typ System, Generika. </li></ol><br><p>  Swift 5 bietet zusammen mit stabilem ABI Binärkompatibilität für Anwendungen.  Binäre Kompatibilität für iOS / macOS-Anwendungen bedeutet, dass kompilierte Anwendungen zur Laufzeit mit Systembibliotheken kompatibel sind, die von früheren oder späteren Versionen der Sprache kompiliert wurden.  Beispielsweise ist eine mit Swift 5.0 kompilierte Anwendung mit Standardbibliotheken kompatibel, die mit Swift 5.1 oder Swift 6.0 kompiliert wurden. </p><br><p>  Ab iOS 12.2 und macOS 10.14.4 enthalten die Betriebssysteme von Apple alles, was Sie zum Ausführen schneller Anwendungen benötigen.  Dies bedeutet, dass in Swift 5 und höher geschriebene Anwendungen keine Laufzeit und keine Standard-Sprachbibliothek enthalten.  Daher wiegen in Swift 5 geschriebene Anwendungen etwa 3-10 Megabyte weniger. </p><br><p>  Es ist wichtig zu beachten, dass neben der ABI-Stabilität auch die Modulstabilität besteht.  Wenn die ABI-Stabilität das Kombinieren verschiedener Versionen einer schnellen Laufzeit ermöglicht, ist die Modulstabilität dafür verantwortlich, wie in verschiedenen Versionen der Sprache geschriebene binäre Frameworks kompiliert werden.  Die Modulstabilität wird in Swift 5.1 angezeigt.  Und dann können Entwickler ihre Frameworks nicht nur Open Source, sondern auch in kompilierter Form verteilen. </p><br><p>  <strong>Vorteile der ABI-Stabilität.</strong> </p><br><ol><li>  Anwendungen wiegen weniger. </li><li>  Beschleunigung der Start- und Anwendungsleistung. </li><li>  Theoretisch könnte Apple neue Frameworks vollständig auf Swift schreiben. </li></ol><br><p>  <strong>Nachteile ABI-Stabilität.</strong> </p><br><p> Entwickler müssen das Fehlen neuer Funktionen in älteren Versionen der Standardbibliothek berücksichtigen.  Wenn beispielsweise Swift 5.1 mit neuen Klassen / Funktionen in der Standardbibliothek in iOS 13 erstellt wurde, können Entwickler diese mit der Unterstützung in der iOS 12.2-Anwendung nicht verwenden.  (Sie müssen #available (...) Checks genauso einfügen wie jetzt für Foundation, UIKit und andere Plattformbibliotheken.) </p><br><h1 id="tip-result-v-standartnoy-biblioteke">  Ergebnistyp in der Standardbibliothek </h1><br><p>  In der Standardbibliothek wurde eine Standardmethode zum Übertragen und Behandeln von Fehlern in der asynchronen API angezeigt.  Sie können diesen Typ auch verwenden, wenn aus irgendeinem Grund die Standardfehlerbehandlung durch try / catch nicht zu uns passt. </p><br><p>  Der Ergebnistyp wird durch Aufzählung mit zwei Fällen implementiert: Erfolg und Misserfolg: </p><br><pre><code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Result</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Success</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Failure</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">where</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Failure</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Error</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> success(<span class="hljs-type"><span class="hljs-type">Success</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> failure(<span class="hljs-type"><span class="hljs-type">Failure</span></span>) ... }</code> </pre> <br><p>  Tatsächlich ist dieser Ansatz für Swift-Entwickler nicht neu.  Seit der ersten Version von Swift haben viele Entwickler einen ähnlichen Ansatz verwendet.  Wenn das Ergebnis nun in der Standardbibliothek angezeigt wird, vereinfacht dies die Interaktion mit Code aus externen Bibliotheken. </p><br><p>  Ein Beispiel für die Verwendung des Artikel-Download-Dienstes: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Article</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> title: <span class="hljs-type"><span class="hljs-type">String</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArticleService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetchArticle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: Int64, completion: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(Result&lt;Article, Error&gt;)</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//    // ... completion(.success(Article(title: "Swift 5.0.  ?"))) } }</span></span></code> </pre> <br><p>  Und hier ist ein Beispiel für die Verarbeitung des Ergebnisses.  Da das Ergebnis nur eine Aufzählung ist, können wir alle seine Zustände mit einem Schalter verarbeiten: </p><br><pre> <code class="swift hljs">articleService.fetchArticle(id: <span class="hljs-number"><span class="hljs-number">42</span></span>) { result <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> result { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .success(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> article): <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Success: \(article)"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .failure(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> error): <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Failure: \(error)"</span></span>) } }</code> </pre> <br><h1 id="raw-strings">  Rohe Saiten </h1><br><p>  In Swift 5 haben sie die sogenannten Raw-Strings hinzugefügt, in denen Anführungszeichen und Backslash genau als Zeichen interpretiert werden. Um sie in einem Literal zu verwenden, müssen Sie kein Escape-Zeichen verwenden.  Um ein Literal für eine solche Zeichenfolge zu schreiben, müssen Sie das Zeichen # in doppelte Anführungszeichen an den Rändern einfügen. </p><br><p>  Ein Beispiel für die Verwendung von Anführungszeichen: </p><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">// swift 4.2 print("    \"\"   .") print("     ,    \\n") // swift 5 print(#" ""      "#) print(#"     ,    \n"#)</span></span></code> </pre> <br><p>  Diese Funktion ist besonders nützlich, wenn Sie reguläre Ausdrücke schreiben: </p><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">// swift 4.2 let regex = "^\\(*\\d{3}\\)*( |-)*\\d{3}( |-)*\\d{4}$" // swift 5 let regex = #"^\(*\d{3}\)*( |-)*\d{3}( |-)*\d{4}$"#</span></span></code> </pre> <br><p>  Fügen Sie das Zeichen # hinzu, um Zeilen nach dem Backslash zu interpolieren: </p><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">// swift 4.2 let string = "   \(variable)" // swift 5 let string = #"   \#(variable)"#</span></span></code> </pre> <br><p>  Sie können mehr <a href="">in diesem Satz</a> lesen. </p><br><h1 id="obnovlennaya-interpolyaciya-strok">  Aktualisierte Zeileninterpolation </h1><br><p>  Mithilfe der Zeichenfolgeninterpolation können wir den Wert einer Variablen oder das Ergebnis eines Ausdrucks zu einem Zeichenfolgenliteral hinzufügen.  Ab der 5. Version der Sprache wurde es möglich, die Art und Weise zu erweitern, in der unsere Ausdrücke zur letzten Zeile hinzugefügt werden. <br>  Schreiben Sie im Allgemeinen einfach eine Erweiterung in die DefaultStringInterpolation-Struktur und fügen Sie eine Methode namens appendInterpolation hinzu.  Wenn wir beispielsweise einer Zeichenfolge einen Preis in formatierter Form hinzufügen möchten: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DefaultStringInterpolation</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">appendInterpolation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(price: Decimal)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> formatter = <span class="hljs-type"><span class="hljs-type">NumberFormatter</span></span>() formatter.numberStyle = .currency <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> string = formatter.string(from: price <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-type"><span class="hljs-type">NSDecimalNumber</span></span>) { appendLiteral(string) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { appendLiteral(price.description) } } } <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Price of item: \(price: 9.99)"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// Price of item: $9.99</span></span></code> </pre> <br><p>  Es ist wichtig zu beachten, dass die Konstruktion (Preis: 9,99) in der Zeichenfolge unter Verwendung des Compilers tatsächlich in einen Aufruf der Methode appendInterpolation (Preis: Dezimal) umgewandelt wurde. <br>  Auch in den appendInterpolation-Methoden können wir eine unbegrenzte Anzahl von benannten und unbenannten Argumenten mit oder ohne Standardwerte hinzufügen. </p><br><p>  Sie können mehr <a href="">in diesem Satz</a> lesen. </p><br><h1 id="proverka-kratnosti-chisel">  Überprüfen der Vielzahl von Zahlen </h1><br><p>  Die Methode zum Überprüfen der Multiplizität isMultiple (of :) wurde zu den numerischen Typen in der Standardbibliothek hinzugefügt.  Ja, wir können den Operator weiterhin verwenden, um den Rest der Division% zu übernehmen.  Aber es scheint, dass isMultiple (of :) visueller aussieht. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> interger = <span class="hljs-number"><span class="hljs-number">42</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> interger.isMultiple(of: <span class="hljs-number"><span class="hljs-number">3</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">" "</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"  "</span></span>) }</code> </pre> <br><h1 id="metod-compactmapvalues-v-dictionary">  CompactMapValues-Methode im Wörterbuch </h1><br><p>  Mit der Methode compactMapValues ​​können Sie Wörterbuchwerte konvertieren und filtern, wenn die Konvertierung selbst null zurückgibt. </p><br><p>  Beispiel: Zuordnen von Zeichenfolgenschlüsseln zu einem URL-Typ: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dict = [ <span class="hljs-string"><span class="hljs-string">"site"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://www.site.ru/path/to/web/site/page"</span></span>, <span class="hljs-string"><span class="hljs-string">"other site"</span></span>: <span class="hljs-string"><span class="hljs-string">"invalid url"</span></span> ] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mappedDict: [<span class="hljs-type"><span class="hljs-type">String</span></span>: <span class="hljs-type"><span class="hljs-type">URL</span></span>] = dict.compactMapValues { <span class="hljs-type"><span class="hljs-type">URL</span></span>(string: $<span class="hljs-number"><span class="hljs-number">0</span></span>) } <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(mappedDict) <span class="hljs-comment"><span class="hljs-comment">// ["site": https://www.site.ru/path/to/web/site/page]</span></span></code> </pre> <br><p>  Das zweite Schlüssel / Wert-Paar wurde nach der Zuordnung gelöscht, da die Zeichenfolge keine gültige URL ist. </p><br><h1 id="izmenenie-povedeniya-try">  Versuchen Sie, das Verhalten zu ändern? </h1><br><p>  In Swift 4.2 mit dem try-Konstrukt?  Sie können problemlos einen optionalen Typ mit mehreren Verschachtelungsebenen erhalten.  In den meisten Fällen ist dies nicht das, was der Entwickler erwartet.  Aus diesem Grund in Swift 5 versuchen?  Verhalten ähnlich wie bei optionaler Verkettung.  Das heißt, mit einer Kombination von Versuch?  Bei optionaler Verkettung oder optionalem Casting ist das Ergebnis des Ausdrucks optional mit einer Verschachtelungsebene. </p><br><p>  Beispiel versuchen?  zusammen mit als?: </p><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">// Swift 4.2 let jsonDict = try? JSONSerialization.jsonObject(with: data, options: []) as? [String: Any] //  jsonDict - [String: Any]?? // Swift 5 let jsonDict = try? JSONSerialization.jsonObject(with: data, options: []) as? [String: Any] //  jsonDict - [String: Any]?</span></span></code> </pre> <br><p>  Beispiel versuchen?  zusammen mit der optionalen Objektmethode: </p><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">// Swift 4.2 let article = try? storage?.getArticle() //  article - Article?? //  if let first = article, let second = first { first //  Article? second //  Article } //   if case let value?? = article { value //  Article } // Swift 5 let article = try? storage?.getArticle() //  article - Article? //  if let value = article { value //  Article }</span></span></code> </pre> <br><p>  Sie können mehr <a href="">in diesem Satz</a> lesen. </p><br><h1 id="atribut-dynamiccallable">  @ DynamicCallable-Attribut </h1><br><p>  Mit dem neuen Attribut @dynamicCallable können Sie den Typ als "aufrufbar" markieren.  Dies bedeutet, dass wir den Typ als normale Methode aufrufen können. <br>  Wenn wir den Typ als @dynamicCallable markieren, müssen wir eine (oder beide) der folgenden Methoden implementieren: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dynamicallyCall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(withArguments: &lt;#Arguments#&gt;)</span></span></span></span> -&gt; &lt;#<span class="hljs-type"><span class="hljs-type">R1</span></span>#&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dynamicallyCall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(withKeywordArguments: &lt;#KeywordArguments#&gt;)</span></span></span></span> -&gt; &lt;#<span class="hljs-type"><span class="hljs-type">R2</span></span>#&gt;</code> </pre> <br><p>  Der Argumenttyp muss das ExpressibleByArrayLiteral-Protokoll unterstützen, der KeywordArguments-Typ muss das ExpressibleByDictionaryLiteral-Protokoll unterstützen und R1 und R2 können beliebige Typen sein. </p><br><p>  Zum Beispiel die Struktur von Sum.  Wenn Sie es anrufen, können Sie eine beliebige Anzahl von Nummern übertragen und deren Summe erhalten: </p><br><pre> <code class="swift hljs">@dynamicCallable <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sum</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dynamicallyCall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(withArguments args: [Int])</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> args.<span class="hljs-built_in"><span class="hljs-built_in">reduce</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, +) } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = <span class="hljs-type"><span class="hljs-type">Sum</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = sum(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(result) <span class="hljs-comment"><span class="hljs-comment">// 10</span></span></code> </pre> <br><p>  Tatsächlich konvertiert der Compiler die Summe (1, 2, 3, 4) in einen Aufruf von sum.dynamicallyCall (withArguments: [1, 2, 3, 4]).  Ähnliches gilt für die Methode dynamicCall (withKeywordArguments :). </p><br><p>  Mit dieser Funktion können Sie die Interaktion von Swift-Code mit verschiedenen dynamischen Programmiersprachen wie Python oder JavaScript hinzufügen. </p><br><p>  Sie können mehr <a href="">in diesem Satz</a> lesen. </p><br><h1 id="podderzhka-operatora-menshe-v-direktivah-proverki-versii-kompilyatora-i-yazyka">  Weniger Operatorunterstützung in Compiler-Versions- und Sprachprüfungsanweisungen </h1><br><p>  Ab der 5. Version von Swift können Sie den Operator "less" verwenden, wenn Sie die Compilerversion im Code überprüfen: </p><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">// Swift 4.2 #if !swift(&gt;=5) //        4.2   #endif // Swift 5 #if swift(&lt;5) //        4.2   #endif</span></span></code> </pre> <br><h1 id="zaklyuchenie">  Fazit </h1><br><p>  Dies sind nicht alle Funktionen und Verbesserungen, die in Swift 5 veröffentlicht wurden. Insgesamt wurden 28 Vorschläge aus der Community angenommen, darunter auch die Verbesserung der Leitungsleistung, die Verbesserung des Swift Package Managers und der Standardbibliothek.  Eine vollständige Liste der Änderungen und Verbesserungen finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in den Versionshinweisen</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de444862/">https://habr.com/ru/post/de444862/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de444850/index.html">Quantenmechanik: Das Ende des Interpretationskrieges</a></li>
<li><a href="../de444852/index.html">Smart Home - Umdenken</a></li>
<li><a href="../de444854/index.html">Programmgesteuertes Erstellen von Schnittstellenelementen mit PureLayout (Teil 1)</a></li>
<li><a href="../de444858/index.html">Auf der Suche nach dem besten Mittel</a></li>
<li><a href="../de444860/index.html">OFFZONE 2.0</a></li>
<li><a href="../de444864/index.html">USB-Schreibmaschine</a></li>
<li><a href="../de444866/index.html">Mein Weg von Python zu Go - Tipps und Ressourcen teilen</a></li>
<li><a href="../de444868/index.html">So erstellen Sie eine für alle angenehme Palette</a></li>
<li><a href="../de444870/index.html">Unternehmensstruktur 2019</a></li>
<li><a href="../de444872/index.html">Wie war die Eröffnung von Zabbix in Russland?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>