<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ–¨ï¸ â™ ï¸ ğŸ‘ˆğŸ½ Bagaimana cara memuat OpenStreetMap di Hive? #âƒ£ ğŸ•·ï¸ ğŸ¤¸ğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam artikel sebelumnya, saya memeriksa geocoding terbalik menggunakan Spark. Sekarang bayangkan kita menghadapi tantangan geocoding langsung alamat ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana cara memuat OpenStreetMap di Hive?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438374/">  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel sebelumnya,</a> saya memeriksa geocoding terbalik menggunakan Spark.  Sekarang bayangkan kita menghadapi tantangan geocoding langsung alamat email.  Artinya, menerima alamat yang direkam oleh teks dari beberapa koordinat geografis. <br><br>  Alamat untuk definiteness adalah Rusia, dan yang paling penting - mereka sering ditulis miring, yaitu, dengan kesalahan, ambiguitas dan kesenangan lainnya.  Dan alamat ini ada di database Hive, di cluster Hadoop. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vc/8n/_s/vc8n_sp2pkut9qvilbnt6u2whqs.png"></div><br>  Sepertinya, - kami mengambil Google Maps Geocoding API (atau, jika Anda adalah pendukung substitusi impor, maka Yandex Maps API), dan kami bekerja.  Tapi di sini kita, juga dengan geocoding terbalik, sedang menunggu penyergapan kecil. <br><a name="habracut"></a><br>  Atau besar, itu seperti tampilan.  Faktanya adalah bahwa saat ini kita perlu memproses sekitar 5 juta alamat.  Dan mungkin 50 - itu tidak segera jelas.  Seperti yang Anda tahu, Google akan mencekal IP Anda setelah sekitar 10 ribu alamat, Yandex akan melakukan hal yang sama dengan Anda, meskipun mungkin beberapa saat kemudian (25 ribu permintaan sehari, misalnya).  Dan selain itu, kedua API adalah REST, yang berarti relatif lambat.  Dan bahkan jika Anda membeli langganan berbayar, kecepatan dari ini tidak akan meningkat satu sen pun. <br><br>  Namun - kami kehabisan amunisi (an) anekdot. <br><br>  Saya lupa hal yang paling penting - cluster Hadoop kami terletak di intranet, dan Google Maps, untuk perusahaan dengan Yandex Maps, dan semua orang lain, pada umumnya tidak dapat diakses oleh kami dari cluster.  Artinya, kami membutuhkan solusi otonom. <br><br>  Saya akan mengatakan segera - Anda tidak akan menemukan solusi yang sudah jadi di sini.  Saya hanya akan menjelaskan pendekatan yang kami rencanakan untuk diterapkan, dan sedikit lebih detail - salah satu langkah menuju solusi. <br><br>  Tentu saja, kami memiliki sesuatu sebagai cadangan.  Ada server ArcGIS internal yang telah saya sebutkan.  Kami tidak diizinkan untuk menyetir mereka, tetapi diizinkan untuk menggunakan layanan REST-nya. <br><br>  Hal pertama yang kami lakukan adalah mengacaukannya.  Dia tidak melarang kami, tetapi kadang-kadang dimatikan untuk pemeliharaan.  Dan bagusnya - memiliki mode batch geocoding, ketika Anda mengirimkan paket alamat ke input (setelah mengonfigurasi server, kami memiliki ukuran paket 1000 buah, secara default sepertinya ada urutan besarnya atau dua lebih kecil).  Semua ini juga tidak mudah, dan kami, serta dukungan ArcGIS, terlibat dalam pergulatan sumo dengan server untuk waktu yang lama, tetapi ini adalah cerita lain. <br><br>  Setelah semua trik dan tikungan, kami dapat memproses lima juta kami dalam waktu sekitar satu hari.  Itu perlu untuk bergerak, dan mencoba untuk mempercepat. <br><br>  Pada saat yang sama, menjadi jelas bahwa geocoder dengan REST kemungkinan besar tidak cocok untuk kita.  Selain itu, kami melihat Nominatim, dan Pelias, dan pada Photon, dan gisgraphy, dan secara umum tidak puas dengan apa pun.  Kualitas dan kinerja (atau keduanya) jauh dari ideal. <br><br>  Misalnya, tidak ada yang tahu cara membuat geocode paket (dan ini sangat dipercepat dengan ArcGIS). <br><br>  Atau kualitas - buka server demo gisgraphy.com dan coba temukan Moskow.  Anda akan mendapatkan beberapa lusin jawaban, termasuk: Moskow (sebuah kota di Federasi Rusia), Kota Kansas (sebuah kota di AS), Khimki, Kaluga, Vykhino-Zhulebino, dan banyak objek lain yang tidak ingin saya lihat dalam jawaban geocoder ketika cari Moskow. <br><br>  Nah, masalah terakhir (tetapi tidak penting bagi kami) adalah jauh dari semua geocoder, API dipikirkan dengan baik, misalnya, Google Maps.  Katakanlah API ArcGIS sudah jauh lebih tidak nyaman, dan sisanya sebagian besar bahkan lebih buruk.  Jika Anda melakukan geocode alamat untuk UI, maka sebagai aturan seseorang terlibat dalam memilih opsi terbaik.  Dan dia melakukannya lebih baik daripada programnya.  Dan dalam kasus geocoding massal, seperti yang kita miliki, menilai kualitas hasil untuk alamat tertentu adalah salah satu komponen penting dari kesuksesan. <br><br>  Akibatnya, opsi seperti "Perluas Nominatim Anda sendiri", misalnya, juga telah hilang. <br><br><h2>  Apa yang harus dilakukan </h2><br>  Solusi yang agak jelas adalah ini: karena alamat tidak diambil dari mana saja dan tidak menghilang, rumah-rumah tidak dibangun setiap hari, dan jalan-jalan tidak dibangun, Anda hanya perlu menambahkan database alamat yang ada secara resmi ke proses kami.  Lebih baik segera dengan koordinat, dan jika ini tidak terjadi, maka geocode sekali.  Dalam hal ini, cukup bagi kami untuk memperbarui basis kami dengan frekuensi yang sama dengan rumah atau jalan baru yang muncul, yaitu, tidak sering. <br><br>  Kandidat pertama dan utama untuk basis alamat yang ada adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FIAS</a> .  Tunggu sebentar, katamu, tetapi FIAS hanya memiliki beberapa juta alamat - dan Anda memiliki sebanyak 50 juta?  Ya, sebenarnya hanya ada beberapa juta <b>rumah</b> .  Dan 50 kami adalah 50 juta alamat pengguna kami, yaitu, ini adalah alamat orang, dan mereka tiba-tiba memiliki apartemen di alamat itu.  Lima juta rumah dari 1-100 apartemen, beberapa orang tinggal di setiap apartemen ... well, Anda mengerti segalanya.  Dan pilihan kedua adalah alamat kantor, di mana juga satu pusat kantor memiliki hingga ratusan tempat, yang terkadang disewakan. <br><br>  Pada saat yang sama, kami jelas tidak perlu alamat dengan nomor apartemen (atau kantor) - pertama, ini adalah data pribadi dengan semua konsekuensinya, dan kedua, kami masih tidak tertarik pada bagaimana apartemen berada di rumah tertentu, dan berapa koordinatnya. .  Hanya rumah yang dibutuhkan.  Untuk kantor, ini tidak sepenuhnya benar, tetapi lokasi kantor di gedung berdasarkan lantai masih belum ditentukan oleh koordinat. <br><br>  Pada akhirnya, dengan memiliki basis, katakanlah, 5 juta rumah (secara kondisional) yang ada, kita dapat menyelesaikan masalah geocoding dari 50 atau 100 juta alamat hanya dengan membuang apartemen atau kantor dari alamat dan mencocokkannya dengan basis. <br><br>  Dan di mana bisa mendapatkan koordinat rumah?  Hanya ada satu open source yang jelas - OpenStreetMap, ada rumah di sana, dengan geometri, dan segala macam atribut lainnya seperti jumlah lantai atau bahkan warna atap. <br><br>  Setelah semua diskusi, kami punya rencana Napoleon.  Ini satu: <br><br><ul><li>  memuat data peta dari OSM ke Hadoop </li><li>  unggah data FIAS dengan alamat </li><li>  buat daftar alamat lengkap unik dengan nomor rumah </li><li>  kami melakukan geocode dengan mencari alamat di OSM, dan apa yang tidak kami temukan adalah melalui ArcGIS </li></ul><br><br>  Kami mendapatkan basis rumah dengan lintang dan bujur.  Selamat menikmati.  Menuai manfaatnya.  Minuman bonus (lelucon). <br><br>  Dalam artikel ini saya akan memberi tahu Anda bagaimana kami menerapkan poin pertama dari rencana ini. <br><br><h2>  Apa itu OpenStreetMap </h2><br>  Jika Anda melihat OSM dari sudut pandang data, maka kartu dapat dibayangkan dalam bentuk tiga tabel: <br><br><ul><li>  poin </li><li>  garis (cara) </li><li>  hubungan </li></ul><br><br>  Skema nyata dari data ini akan diberikan di bawah ini. <br><br>  Hanya titik yang memiliki koordinat (lintang dan bujur, dalam derajat).  Garis adalah urutan titik yang dipesan.  Hubungan adalah seperangkat titik dan garis, yang masing-masing memiliki <i>peran</i> . <br><br>  Yang lainnya adalah tag yang disebut.  Yaitu, misalnya, ATM, atau toko, atau pintu masuk ke metro - itu bisa berupa titik yang dilengkapi dengan tag amenity = atm, atau toko = menjual sesuatu, atau sesuatu yang lain.  Ada direktori tag yang direkomendasikan secara resmi (untuk setiap bahasa dan negara yang berlaku, mereka dapat sebagian milik mereka sendiri), dan praktik menciptakan yang tidak standar. <br><br>  Selain tag, setiap elemen peta memiliki id numerik yang unik, serta beberapa atribut yang terkait dengan riwayat - yang mengedit kapan, mengedit nomor, dll. <br><br>  Basis data dengan kartu hadir dalam beberapa format: <br>  - pbf adalah Google Protobuf, format serialisasi data portabel. <br>  - xml jelas XML.  Volume lebih banyak. <br><br>  Anda perlu memahami bahwa basis data diperbarui setiap hari.  Oleh karena itu, pembongkaran lengkap dan bertahap. <br><br>  Kami memilih PBF karena lebih ringkas. <br><br>  Untuk membacanya di Hadoop, ada Java API yang khusus dibuat untuk OSM yang disebut proyek osmosis ini.  Pada prinsipnya, bekerja dengannya sederhana - Anda mengunggah file dan menggilir elemen peta.  Tambahkan titik di satu tempat, garis di tempat lain, hubungan di tempat ketiga.  Pada prinsipnya, osmosis dan misalnya Spark sudah cukup untuk mengunduh semua data. <br><br>  Untungnya, dalam proses penerapan sepeda saya, entah bagaimana terpikir oleh saya untuk mencari di Internet untuk mengubah OSM ke dalam format yang diterima di Hadoop - Parket (parket) dan Avro.  Dalam arti, keduanya adalah analog PBF, jadi ada peluang untuk menemukan konverter.  Dan dia ditemukan, tetapi tidak satu pun. <br><br><h2>  Temui OSM Parquetizer </h2><br>  Lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">apa yang saya temukan!</a> <br><br>  Untuk orang-orang malas - tepat di readme proyek di baris pertama dikatakan: Telenav menerbitkan unduhan mingguan planet ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ke alamatnya</a> . <br><br>  Untuk orang-orang yang sangat malas: bersiap-siap untuk mengirim sekitar 700 gigabytes;) Nah, jika Anda tentu membutuhkan sebuah planet.  Anda biasanya dapat bertahan dengan, katakanlah, Eropa. <br><br>  Jika Anda tidak ingin memuat, prosesnya terlihat seperti ini: unduh peta dalam format PBF, misalnya dari <a href="">geofactory</a> .  Ini adalah 2,5 gigabytes jika Anda membutuhkan Rusia, dan 19 jika Eropa.  Juga tidak sedikit, tetapi Anda dapat menemukan sampel cincang lebih halus.  Selanjutnya, letakkan file di disk, dan jalankan program: <br><br><pre><code class="plaintext hljs">java -jar ./osm-parquetizer.jar russia-latest.osm.pbf</code> </pre> <br>  Setelah beberapa menit atau bahkan detik, tergantung pada kinerja mesin Anda, Anda mendapatkan tiga file dalam format parket.  Inilah yang terlihat seperti penulis (dia dari Rumania): <br><br><pre> <code class="plaintext hljs">-rw-r--r-- 1 adrianbona adrianbona 145M Apr 3 19:57 romania-latest.osm.pbf -rw-r--r-- 1 adrianbona adrianbona 372M Apr 3 19:58 romania-latest.osm.pbf.node.parquet -rw-r--r-- 1 adrianbona adrianbona 1.1M Apr 3 19:58 romania-latest.osm.pbf.relation.parquet -rw-r--r-- 1 adrianbona adrianbona 123M Apr 3 19:58 romania-latest.osm.pbf.way.parquet</code> </pre> <br>  Skema file .parquet yang diterima: <br><br> <code>node <br> |-- id: long <br> |-- version: integer <br> |-- timestamp: long <br> |-- changeset: long <br> |-- uid: integer <br> |-- user_sid: string <br> |-- tags: array <br> | |-- element: struct <br> | | |-- key: string <br> | | |-- value: string <br> |-- latitude: double <br> |-- longitude: double <br> <br> way <br> |-- id: long <br> |-- version: integer <br> |-- timestamp: long <br> |-- changeset: long <br> |-- uid: integer <br> |-- user_sid: string <br> |-- tags: array <br> | |-- element: struct <br> | | |-- key: string <br> | | |-- value: string <br> |-- nodes: array <br> | |-- element: struct <br> | | |-- index: integer <br> | | |-- nodeId: long <br> <br> relation <br> |-- id: long <br> |-- version: integer <br> |-- timestamp: long <br> |-- changeset: long <br> |-- uid: integer <br> |-- user_sid: string <br> |-- tags: array <br> | |-- element: struct <br> | | |-- key: string <br> | | |-- value: string <br> |-- members: array <br> | |-- element: struct <br> | | |-- id: long <br> | | |-- role: string <br> | | |-- type: string <br></code> <br><br>  Seperti yang Anda lihat, semuanya sederhana di sini.  Kemudian kita lakukan hal berikut: <br><br><ul><li>  kita meletakkan file pada cluster Hadoop dengan perintah hdfs dfs -put </li><li>  katakanlah dalam Hue dan buat skema / basis, dan tiga tabel untuknya, berdasarkan data di atas </li><li>  jalankan pilih * dari osm.nodes, dan nikmati hasilnya. </li></ul><br>  Nuansa kecil: dalam versi Hive kami (dan mungkin juga milik Anda), ia tidak dapat membuat tabel berdasarkan skema dari Parket.  Anda harus mengonversi di atas menjadi CREATE TABLE (yang, secara umum, tidak sulit, dan saya akan meninggalkan ini sebagai latihan rumahan untuk pembaca), atau untuk melakukan sedikit lebih rumit: Spark dapat membaca diagram dan data dari lantai, dan membuat tabel sementara berdasarkan pada mereka .  Jadi kita bisa membaca data di Spark Shell seperti ini: <br><br><pre> <code class="plaintext hljs">val nodeDF = sqlContext.read.parquet("file:/tmp/osm/romania-latest.osm.pbf.node.parquet") nodeDF.createOrReplaceTempView("nodes")</code> </pre><br>  Maka Anda sudah bisa membuat tabel di Hive menggunakan simpul LIKE. <br><br>  Komentar lain untuk orang yang malas: penulis memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh yang</a> sangat bagus, yang secara umum semuanya menjadi jelas (baik, jika Anda memiliki Spark).  Ini tentu saja bukan Spark Shell, tetapi Databricks Notebook, tetapi butuh sekitar 15 menit untuk mengetuk satu keyboard untuk menerjemahkan satu ke yang lain.  Dan dalam 30-40 menit dimungkinkan untuk mengonversikan semuanya menjadi kueri untuk Hive menggunakan beberapa analog yang sedikit berbeda dari percikan. <br><br><h3>  Contoh Permintaan Nyata </h3><br>  Apa yang bisa kita dapatkan dari database ini dalam bentuk saat ini?  Secara umum, cukup banyak.  Jika Anda memiliki Hive atau Spark, Kerangka Spasial, API Geometri, atau salah satu alternatifnya, yaitu GeoSpark atau GeoMesa, misalnya, Anda dapat memecahkan banyak masalah berbeda berdasarkan ini. <br><br>  Mari kita lihat sebuah contoh.  Cara termudah untuk bekerja dengan poin.  Misalnya, permintaan untuk mendapatkan daftar ATM dengan koordinatnya terlihat seperti ini: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> nodes <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tags[<span class="hljs-string"><span class="hljs-string">'amenity'</span></span>]=<span class="hljs-string"><span class="hljs-string">'atm'</span></span></code> </pre><br>  Cara membuat kueri seperti itu, Anda bisa menebak dengan membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">halaman di wiki</a> .  Di sana Anda akan menemukan apa itu tag lain, dan beberapa di antaranya dapat dimasukkan dalam permintaan Anda alih-alih *, dalam bentuk tag ['operator'], misalnya, untuk menunjukkan nama bank. <br><br>  Dari halaman yang sama berikut bahwa markup ATM dimungkinkan dalam bentuk tag amenity = bank dan atm = ya.  Sayangnya, ambiguitas seperti itu ada di mana-mana dalam OSM. <br><br>  Jika Anda seorang pemula, dan hanya berkenalan dengan OSM, saya sangat merekomendasikan menguasai (dengan contoh yang baik di wiki) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">overpass-turbo</a> .  Ini adalah alat yang memungkinkan Anda untuk melakukan berbagai jenis pencarian pada data peta, baik dengan kondisi geometris dan dengan kondisi untuk tag. <br><br><h3>  Dan di mana alamatnya? </h3><br>  Pertanyaan yang bagus  Alamat dalam OSM adalah elemen peta yang dilengkapi dengan addr: * tag, mis.  dimulai dengan addr.  Keterangan akan Anda temukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Pada prinsipnya, mengetahui semua yang telah saya nyatakan di atas, Anda sudah dapat menulis beberapa permintaan kerja: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> nodes <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tags[<span class="hljs-string"><span class="hljs-string">'addr:housenumber'</span></span>]!=<span class="hljs-literal"><span class="hljs-literal">null</span></span></code> </pre><br>  Masalah apa yang menunggu kita di sini?  Pertama, alamat ditempatkan pada titik (misalnya, pintu masuk gedung), dan pada poligon, yaitu  di jalan.  Jadi setidaknya kita harus menduplikasi permintaan.  Dan kedua, pada halaman yang disebutkan di atas, wiki ditulis dalam teks biasa sehingga tidak disarankan untuk menempatkan tag yang menunjukkan kota, wilayah, wilayah dan negara, tetapi ini harus dihitung secara geometris.  Bagaimana cara melakukannya?  Secara umum, ini praktis tugas membalik geocoding, dengan modifikasi ringan, dan itu dijelaskan dalam posting sebelumnya. <br><br>  Artinya, secara umum, Anda perlu menemukan batas administrasi, dan untuk semua alamat yang ada di dalamnya, tambahkan alamat ke area dan semua yang di atas.  Bagaimana batas-batas entitas administratif diatur dijelaskan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Secara umum, tugas ini tidak terlalu sederhana, tetapi cukup dapat dipecahkan, dan tidak diselesaikan dengan geocoding, tetapi dengan mengunduh pembaruan OSM ke database kami, dalam suasana yang santai. <br><br><h3>  Apa yang berguna untuk dilakukan selanjutnya </h3><br>  Pada prinsipnya, Anda sudah dapat bekerja dengan node, cara, dan tabel relasi yang kami miliki, tetapi lebih baik untuk mengubah skema sedikit, membuatnya lebih cocok untuk Hive dan Spark.  Faktanya adalah bahwa skema OSM sepenuhnya dinormalisasi, cara dan hubungan tidak mengandung koordinat sama sekali.  Untuk membangun poligon, Anda harus bergabung dengan node.  Saya akan merekomendasikan melakukan operasi ini segera, menyimpan poligon baik sebagai array struktur (Hive dapat bekerja dengan array tipe komposit, peta dan struct), atau segera sebagai representasi serial, katakanlah, kelas Geometri.  Cara melakukan ini adalah dalam contoh parket penulis. <br><br>  Anda dapat mengulangi operasi serupa di tingkat hubungan, jika Anda mau, tetapi tidak sepadan.  Pertama, Anda tidak akan selalu membutuhkan semua elemen hubungan, dan kedua, hubungan itu sendiri dalam OSM jauh lebih kecil. <br><br><h2>  Konverter ke Avro </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Berikut</a> ini adalah konverter lain, kali ini ke format Avro.  Dan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> dijelaskan di mana mendapatkan file yang selesai.  Saya tidak mengukur ukuran, tapi saya pikir sekitar 15-20 file per planet harus sebanding dengan PBF.  Artinya, ini adalah gigabyte, dan banyak. <br><br><h2>  Beberapa kesimpulan </h2><br>  Dan di mana geocoding, Anda bertanya?  Ya, mengunduh peta dan mengekstraksi alamat hanyalah bagian dari keseluruhan tugas.  Saya harap ini yang terjadi. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id438374/">https://habr.com/ru/post/id438374/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id438364/index.html">Replikasi pengacak suara digital pertama di dunia</a></li>
<li><a href="../id438366/index.html">Namun ulasan lain tentang fitur token perangkat keras OATH di Azure Cloud MFA</a></li>
<li><a href="../id438368/index.html">Bola lampu pintar yang dibuang ke tempat sampah adalah sumber informasi pribadi yang berharga.</a></li>
<li><a href="../id438370/index.html">Cybercrime sebagai layanan: layanan dan harga</a></li>
<li><a href="../id438372/index.html">NASA Terus Berusaha untuk Menghubungi Peluang</a></li>
<li><a href="../id438376/index.html">Rekayasa terbalik. Ceritanya Milik saya</a></li>
<li><a href="../id438380/index.html">Pria, jeda pada pengecualian yang tertangkap</a></li>
<li><a href="../id438382/index.html">Organisasi pencarian di halaman web dalam JavaScript (tanpa jQuery)</a></li>
<li><a href="../id438384/index.html">Pelajaran kimia: cara mengekspos kristal microchip untuk fotografi</a></li>
<li><a href="../id438386/index.html">Dalam perjalanan ke prinsip fisik evolusi biologis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>