<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôÅ üíÜüèæ üèóÔ∏è Toda la verdad sobre RTOS. Art√≠culo # 28. Temporizadores de software üïäÔ∏è ‚ùé ‚öúÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La idea de los temporizadores de software se introdujo en un art√≠culo anterior . Son objetos del n√∫cleo que proporcionan tareas con una forma simple d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Toda la verdad sobre RTOS. Art√≠culo # 28. Temporizadores de software</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455072/">  La idea de los temporizadores de software se introdujo en un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo anterior</a> .  Son objetos del n√∫cleo que proporcionan tareas con una forma simple de desencadenar eventos a tiempo o, m√°s a menudo, una forma de realizar acciones de forma regular.  Todos los detalles de la funcionalidad relacionada con el tiempo (precisi√≥n, manejo de interrupciones, etc.) en Nucleus SE se discutieron en un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo anterior</a> . <br><br><img src="https://habrastorage.org/webt/xu/5v/_s/xu5v_sdm50mq9i1ywof_lgsvqkw.jpeg"><br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Art√≠culos anteriores de la serie:</b> <div class="spoiler_text"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 27.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hora del sistema</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 26.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Canales: servicios auxiliares y estructuras de datos.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 25.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Canales de datos: introducci√≥n y servicios b√°sicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 24.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Colas: servicios auxiliares y estructuras de datos.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo 23.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Colas: introducci√≥n y servicios b√°sicos.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 22.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Buzones: servicios auxiliares y estructuras de datos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 21.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Buzones: Introducci√≥n y servicios b√°sicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 20.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sem√°foros: servicios auxiliares y estructuras de datos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 19.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sem√°foros: introducci√≥n y servicios b√°sicos.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 18.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Grupos de banderas de eventos: servicios auxiliares y estructuras de datos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 17.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Grupos de banderas de eventos: Introducci√≥n y servicios b√°sicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 16.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Se√±ales</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Particiones de memoria: servicios y estructuras de datos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Secciones de memoria: introducci√≥n y servicios b√°sicos.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Estructuras de datos de tareas y llamadas de API no compatibles</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Servicios para trabajar con tareas.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tareas: configuraci√≥n e introducci√≥n a la API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Programador: funciones avanzadas y preservaci√≥n del contexto</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Programador: implementaci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Nucleus SE: dise√±o interno y despliegue</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">N√∫cleo SE: Introducci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Otros servicios RTOS</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Interacci√≥n de tareas y sincronizaci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tareas, cambio de contexto e interrupciones</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tareas y planificaci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RTOS: estructura y modo en tiempo real</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo # 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RTOS: introducci√≥n.</a> <br></div></div><br><h2>  Usando temporizadores </h2><br>  Los temporizadores del programa se pueden configurar para que se activen una vez, es decir, comienzan y luego, despu√©s de un per√≠odo de tiempo espec√≠fico, simplemente finalizan el ciclo.  O el temporizador se puede configurar para reiniciar: despu√©s de que se complete el conteo, el temporizador se reinicia autom√°ticamente.  El tiempo de funcionamiento despu√©s de un reinicio puede diferir del tiempo de funcionamiento inicial.  Adem√°s, el temporizador puede configurarse opcionalmente para realizar una funci√≥n de terminaci√≥n especial, que se ejecuta cuando (o cada vez) el temporizador completa el ciclo de trabajo. <br><br><h2>  Configuraciones de temporizador </h2><br><h3>  N√∫mero de temporizadores </h3><br>  Como con la mayor√≠a de los aspectos de Nucleus SE, la configuraci√≥n del temporizador est√° controlada por las directivas <b>#define</b> en <b>nuse_config.h</b> .  El par√°metro principal es <b>NUSE_TIMER_NUMBER</b> , que define los temporizadores configurados en la aplicaci√≥n.  De forma predeterminada, este valor es cero (es decir, los temporizadores no se usan en la aplicaci√≥n) y puede tomar valores de hasta 16. Un valor incorrecto generar√° un error de compilaci√≥n, que se generar√° al registrar el archivo <b>nuse_config_check.h</b> (este archivo se incluye en <b>nuse_config.c</b> y compila junto con √©l), que activar√° la directiva <b>#error</b> . <br><br>  Seleccionar un valor distinto de cero es el activador del temporizador principal.  Este par√°metro se utiliza al definir estructuras de datos y su tama√±o depende de su valor.  Adem√°s, un valor distinto de cero activa la configuraci√≥n de la API. <br><br><h3>  Activaci√≥n de la funci√≥n de finalizaci√≥n. </h3><br>  En Nucleus SE, trat√© de encontrar la oportunidad de hacer que la funcionalidad sea opcional, donde ahorrar√° memoria.  Un buen ejemplo es el soporte para las funciones de finalizaci√≥n del temporizador.  Adem√°s del hecho de que esta caracter√≠stica es opcional para cada temporizador, el mecanismo se puede activar (o no) para toda la aplicaci√≥n utilizando el par√°metro <b>NUSE_TIMER_EXPIRATION_ROUTINE_SUPPORT</b> en <b>nuse_config.h</b> .  Establecer este par√°metro en <b>FALSE</b> bloquea la definici√≥n de dos estructuras de datos en la ROM, que se describir√° en detalle en este art√≠culo. <br><br><h3>  Activaci√≥n API </h3><br>  Cada funci√≥n API (llamada de utilidad) en Nucleus SE tiene una directiva activadora #define en nuse_config.h.  Para los temporizadores, estos s√≠mbolos incluyen: <br>  <b>NUSE_TIMER_CONTROL</b> <b><br></b>  <b>NUSE_TIMER_GET_REMAINING</b> <b><br></b>  <b>NUSE_TIMER_RESET</b> <b><br></b>  <b>NUSE_TIMER_INFORMATION</b> <b><br></b>  <b>NUSE_TIMER_COUNT</b> <br><br>  De manera predeterminada, todos los activadores est√°n configurados en <b>FALSO</b> , por lo que todas las llamadas de servicio est√°n deshabilitadas, lo que bloquea la inclusi√≥n de c√≥digo que las implementa.  Para configurar temporizadores en la aplicaci√≥n, debe seleccionar las llamadas de servicio API necesarias y configurarlas en <b>VERDADERO</b> . <br><br>  El siguiente es un fragmento de c√≥digo del archivo predeterminado <b>nuse_config.h</b> . <br><br><pre><code class="plaintext hljs">#define NUSE_TIMER_NUMBER 0/*      0-16 */ /*    */ #define NUSE_TIMER_CONTROL FALSE #define NUSE_TIMER_GET_REMAINING FALSE #define NUSE_TIMER_RESET FALSE #define NUSE_TIMER_INFORMATION FALSE #define NUSE_TIMER_COUNT FALSE</code> </pre> <br>  Si la funci√≥n API relacionada con el temporizador est√° activada y no hay temporizadores configurados en la aplicaci√≥n (a excepci√≥n de la funci√≥n <b>NUSE_Timer_Count ()</b> , que siempre est√° habilitada), se producir√° un error de compilaci√≥n.  Si su c√≥digo usa una llamada API que no ha sido activada, se producir√° un error de dise√±o porque el c√≥digo de implementaci√≥n no se incluy√≥ en la aplicaci√≥n. <br><br><h2>  Timer Service Calls </h2><br>  Nucleus RTOS admite ocho llamadas de utilidad relacionadas con el temporizador que proporcionan la siguiente funcionalidad: <br><br><ul><li>  Gesti√≥n (inicio / parada) temporizador.  Nucleus SE se implementa en la funci√≥n <b>NUSE_Timer_Control ()</b> . </li><li>  Recuperando el tiempo restante del temporizador.  En Nucleus SE, implementado en <b>NUSE_Timer_Get_Remaining ()</b> . </li><li>  Restaurar el temporizador a su estado original (restablecer).  Nucleus SE implementado en <b>NUSE_Timer_Reset ()</b> . </li><li>  Proporcionar informaci√≥n sobre un temporizador espec√≠fico.  Nucleus SE se implementa en <b>NUSE_Timer_Information ()</b> . </li><li>  Devuelve el n√∫mero de temporizadores configurados (actualmente) en la aplicaci√≥n.  Nucleus SE se implementa en <b>NUSE_Timer_Count ()</b> . </li><li>  Agregar un nuevo temporizador a la aplicaci√≥n (creaci√≥n).  Nucleus SE no est√° implementado. </li><li>  Eliminar un temporizador de la aplicaci√≥n.  Nucleus SE no est√° implementado. </li><li>  Devolver punteros a todos los temporizadores de la aplicaci√≥n.  Nucleus SE no est√° implementado. </li></ul><br>  La implementaci√≥n de cada llamada de servicio se discutir√° en detalle a continuaci√≥n. <br><br><h2>  Servicios de temporizador </h2><br>  Las operaciones fundamentales que se pueden realizar con un temporizador son el control (inicio y parada) y la lectura del valor actual.  Nucleus RTOS y Nucleus SE proporcionan dos llamadas de utilidad API b√°sicas para estas operaciones. <br><br><h3>  Control del temporizador </h3><br>  Una llamada de utilidad a la API Nucleus RTOS para controlar el temporizador le permite activar y desactivar el temporizador (iniciar y detener).  Nucleus SE ofrece una funcionalidad similar. <br><br>  <b><i>Desaf√≠o de control del temporizador en Nucleus RTOS</i></b> <br>  Prototipo de llamada de servicio: <br><br>  <b>ESTADO NU_Control_Timer (NU_TIMER * timer, OPTION enable);</b> <br><br>  Par√°metros: <br>  <b>timer</b> - puntero al bloque de control del timer provisto por el usuario; <br>  <b>enable</b> es la funci√≥n requerida; puede tomar los valores <b>NU_ENABLE_TIMER</b> o <b>NU_DISABLE_TIMER</b> . <br><br>  Valor de retorno: <br>  <b>NU_SUCCESS</b> : la llamada se complet√≥ correctamente; <br>  <b>NU_INAVLID_TIMER</b> : puntero de temporizador no v√°lido; <br>  <b>NU_INAVLID_ENABLE</b> : funci√≥n no v√°lida. <br><br>  <b><i>Desaf√≠o de control del temporizador en Nucleus SE</i></b> <br>  Esta llamada a la API admite la funcionalidad completa de la API Nucleus RTOS. <br><br>  Prototipo de llamada de servicio: <br>  <b>ESTADO NUSE_Timer_Control (NUSE_TIMER timer, OPTION enable);</b> <br><br>  Par√°metros: <br>  <b>timer</b> - √≠ndice (ID) del temporizador utilizado; <br>  <b>enable</b> es la funci√≥n requerida; puede tomar los valores <b>NUSE_ENABLE_TIMER</b> o <b>NUSE_DISABLE_TIMER</b> . <br><br>  Valor de retorno: <br>  <b>NUSE_SUCCESS</b> : la llamada se complet√≥ correctamente; <br>  <b>NUSE_INCALID_TIMER</b> : √≠ndice de temporizador no v√°lido; <br>  <b>NUSE_INVALID_ENABLE</b> es una funci√≥n no v√°lida. <br><br>  <b><i>Implementar la gesti√≥n del temporizador en Nucleus SE</i></b> <br>  El c√≥digo de funci√≥n API <b>NUSE_Timer_Control ()</b> (despu√©s de verificar los par√°metros) es bastante simple: <br><br><pre> <code class="plaintext hljs">NUSE_CS_Enter(); if (enable == NUSE_ENABLE_TIMER) { NUSE_Timer_Status[timer] = TRUE; if (NUSE_Timer_Expirations_Counter[timer] == 0) { NUSE_Timer_Value[timer] = NUSE_Timer_Initial_Time[timer]; } else { NUSE_Timer_Value[timer] = NUSE_Timer_Reschedule_Time[timer]; } } else /* enable == NUSE_DISABLE_TIMER */ { NUSE_Timer_Status[timer] = FALSE; } NUSE_CS_Exit();</code> </pre><br>  Si se especific√≥ la funci√≥n <b>NUSE_DISABLE_TIMER</b> , el estado del temporizador (par√°metro <b>NUSE_Timer_Status []</b> ) se establece en <b>FALSE</b> , que ignora el temporizador mediante el controlador de interrupciones. <br><br>  Al seleccionar la funci√≥n <b>NUSE_ENABLE_TIMER,</b> el contador del temporizador ( <b>NUSE_Timer_Value []</b> ) se establece en <b>NUSE_Timer_initial_Time []</b> , siempre que el temporizador nunca se haya detenido desde el √∫ltimo reinicio.  De lo contrario, se le asigna el valor <b>NUSE_Timer_Reschedule_Time []</b> .  Luego, el estado del temporizador (par√°metro <b>NUSE_Timer_Status []</b> ) se establece en <b>TRUE</b> , lo que hace que el controlador de interrupciones procese el temporizador. <br><br><h3>  Lectura del temporizador </h3><br>  Para obtener el tiempo restante del temporizador, la llamada de servicio API Nucleus RTOS devuelve el n√∫mero de medidas hasta que caduque.  Nucleus SE ofrece una funcionalidad similar. <br><br>  <b><i>Llame para obtener el tiempo restante en Nucleus RTOS</i></b> <br><br>  Prototipo de llamada de servicio: <br>  <b>ESTADO NU_Get_Remaining_Time (NU_TIMER * timer, UNSIGNED * restantes_time);</b> <br><br>  Par√°metros: <br>  <b>timer</b> - puntero al bloque de control del timer provisto por el usuario; <br>  <b>restantes_tiempo</b> : un puntero al almacenamiento del valor de tiempo restante, que es una variable de tipo <b>SIN FIRMAR</b> . <br><br>  Valor de retorno <br>  <b>NU_SUCCESS</b> : la llamada se complet√≥ correctamente; <br>  <b>NU_INVALID_TIMER</b> : puntero del temporizador no v√°lido. <br><br>  <b><i>Llame para obtener el tiempo restante en Nucleus SE</i></b> <br>  Esta llamada a la API admite la funcionalidad completa de la API Nucleus RTOS. <br><br>  Prototipo de llamada de servicio: <br>  <b>ESTADO NUSE_Timer_Get_Remaining (NUSE_TIMER timer, U16 * restante_tiempo);</b> <br><br>  Par√°metros: <br>  <b>timer</b> - √≠ndice (ID) del temporizador utilizado; <br>  <b>restantes_tiempo</b> : un puntero al almacenamiento del valor de tiempo restante, que es una variable de tipo <b>U16</b> . <br><br>  Valor de retorno: <br>  <b>NUSE_SUCCESS</b> : la llamada se complet√≥ correctamente; <br>  <b>NUSE_INVALID_TIMER</b> : √≠ndice de temporizador no v√°lido; <br>  <b>NUSE_INVALID_POINTER</b> : puntero nulo al tiempo restante ( <b>NULL</b> ). <br><br>  <b><i>Implementaci√≥n de una lectura de temporizador en Nucleus SE</i></b> <br>  La variante del c√≥digo de funci√≥n API <b>NUSE_Timer_Get_Remaining ()</b> (despu√©s de verificar los par√°metros) es trivialmente simple.  Se <b>obtiene el</b> valor <b>NUSE_Timer_Value []</b> y luego se devuelve en la secci√≥n cr√≠tica. <br><br><h2>  Servicios de temporizador auxiliar </h2><br>  Nucleus RTOS tiene cuatro llamadas API que proporcionan funciones auxiliares relacionadas con los temporizadores: restablecer un temporizador, obtener informaci√≥n del temporizador, obtener el n√∫mero de temporizadores en una aplicaci√≥n y obtener punteros para todos los temporizadores en una aplicaci√≥n.  Las primeras tres funciones se implementan en Nucleus SE. <br><br><h3>  Reinicio del temporizador </h3><br>  Esta llamada a la API restablece el temporizador a su estado original no utilizado.  El temporizador se puede activar o desactivar despu√©s del final de esta llamada.  Solo se puede usar despu√©s de que el temporizador se haya deshabilitado (usando <b>NUSE_Timer_Control ()</b> ).  La pr√≥xima vez que se active el temporizador, se inicializar√° con el par√°metro <b>NUSE_Timer_Initial_Time []</b> .  Nucleus RTOS le permite proporcionar un nuevo estado inicial y reprogramar el tiempo, as√≠ como especificar la funci√≥n de finalizaci√≥n cuando se reinicia el temporizador.  En Nucleus SE, estos valores se establecen durante la configuraci√≥n y no se pueden cambiar ya que est√°n almacenados en la ROM. <br><br>  <b><i>Llame para restablecer un temporizador en Nucleus RTOS</i></b> <br><br>  Prototipo de llamada de servicio: <br>  <b>ESTADO NU_Reset_Timer (NU_TIMER * timer, VOID (* expiration_routine) (UNSIGNED), UNSIGNED initial_time, UNSIGNED reschedule_time, OPTION enable);</b> <br><br>  Par√°metros: <br>  <b>temporizador</b> : un puntero a un temporizador reiniciable; <br>  <b>expiration_routine</b> : indica la funci√≥n que se ejecutar√° cuando finalice el ciclo; <br>  <b>initial_time</b> : el n√∫mero inicial de temporizadores hasta que finalice el ciclo; <br>  <b>reschedule_time</b> : el n√∫mero de <b>tics</b> del temporizador hasta que se completen el segundo ciclo y los posteriores; <br>  <b>enable</b> : el estado requerido del temporizador despu√©s de un reinicio puede tomar los valores <b>NU_ENABLE_TIMER</b> o <b>NU_DISABLE_TIMER</b> . <br><br>  Valor de retorno: <br>  <b>NU_SUCCESS</b> : la llamada se complet√≥ correctamente; <br>  <b>NU_INVALID_TIMER</b> : puntero no v√°lido a la unidad de control del temporizador; <br>  <b>NU_INVALID_FUNCTION</b> : puntero nulo a la funci√≥n de finalizaci√≥n ( <b>NULL</b> ); <br>  <b>NU_INVALID_ENABLE</b> : el estado especificado es incorrecto; <br>  <b>NU_NOT_DISABLED</b> : el temporizador ya se est√° ejecutando (debe detenerse antes de llamar a esta funci√≥n). <br><br>  <b><i>Llame para restablecer el temporizador en Nucleus SE</i></b> <br>  Esta llamada de servicio API admite una versi√≥n simplificada de la funcionalidad principal de la API Nucleus RTOS. <br><br>  Prototipo de llamada de servicio: <br>  <b>ESTADO NUSE_Timer_Reset (NUSE_TIMER timer, OPTION enable);</b> <br><br>  Par√°metros: <br>  <b>timer</b> - √≠ndice (ID) del temporizador de reinicio; <br>  <b>enable</b> : el estado requerido despu√©s del restablecimiento puede tomar los valores <b>NUSE_ENABLE_TIMER</b> o <b>NUSE_DISABLE_TIMER</b> . <br><br>  Valor de retorno: <br>  <b>NUSE_SUCCESS</b> : la llamada se complet√≥ correctamente; <br>  <b>NUSE_INVALID_TIMER</b> : √≠ndice de temporizador no v√°lido; <br>  <b>NUSE_INVALID_ENABLE</b> : el estado especificado es incorrecto; <br>  <b>NUSE_NOT_DISABLED</b> : el temporizador ya se est√° ejecutando (debe detenerse antes de llamar a esta funci√≥n). <br><br>  <b><i>Implementaci√≥n de un reinicio del temporizador en Nucleus SE</i></b> <br>  La versi√≥n del c√≥digo de funci√≥n API <b>NUSE_Timer_Reset ()</b> (despu√©s de verificar los par√°metros y el estado actual) es bastante simple: <br><br><pre> <code class="plaintext hljs">NUSE_CS_Enter(); NUSE_Init_Timer(timer); if (enable == NUSE_ENABLE_TIMER) { NUSE_Timer_Status[timer] = TRUE; } /*  enable == NUSE_DISABLE_TIMER    FALSE */ NUSE_CS_Exit();</code> </pre><br>  Una llamada a <b>NUSE_Init_Timer ()</b> inicializa el valor del tiempo y borra el contador de finalizaci√≥n.  Despu√©s de eso, si es necesario, se verifica el valor del estado requerido y si el temporizador est√° activado. <br><br><h3>  Informaci√≥n del temporizador </h3><br>  Esta llamada de servicio le permite obtener un conjunto de informaci√≥n del temporizador.  La implementaci√≥n de Nucleus SE difiere de Nucleus RTOS en que devuelve menos informaci√≥n ya que no se admite la denominaci√≥n de objetos. <br><br>  <b><i>Llame para obtener informaci√≥n del temporizador en Nucleus RTOS</i></b> <br><br>  Prototipo de llamada de servicio: <br>  <b>ESTADO NU_Timer_Information (NU_TIMER * timer, CHAR * name, OPTION * enable, UNSIGNED * expirations, UNSIGNED * id, UNSIGNED * initial_time, UNSIGNED * reschedule_time);</b> <br><br>  Par√°metros: <br>  <b>temporizador</b> : un puntero a un temporizador sobre el que se solicita informaci√≥n; <br>  <b>nombre</b> : puntero a la regi√≥n de 8 caracteres para el nombre del temporizador; <br>  <b>enable</b> : <b>apunta</b> a una variable que toma el estado actual del activador del temporizador: <b>NU_ENABLE_TIMER</b> o <b>NU_DISABLE_TIMER</b> ; <br>  <b>vencimientos</b> : un puntero a una variable que toma un contador del n√∫mero de finalizaciones del ciclo del temporizador desde su √∫ltimo reinicio; <br>  <b>id</b> : puntero a una variable que toma el valor del par√°metro pasado a la funci√≥n de finalizaci√≥n del ciclo del temporizador; <br>  <b>initial_time</b> : un puntero a una variable que toma un valor en el que se inicializar√° el temporizador despu√©s de un reinicio; <br>  <b>reschedule_time</b> : un puntero a una variable que toma un valor en el que se inicializar√° el temporizador una vez completado. <br><br>  Valor de retorno: <br>  <b>NU_SUCCESS</b> : la llamada se complet√≥ correctamente; <br>  <b>NU_INVALID_TIMER</b> : puntero del temporizador no v√°lido. <br><br>  <b><i>Llame para obtener informaci√≥n del temporizador en Nucleus SE</i></b> <br>  Esta llamada a la API admite la funcionalidad principal de la API Nucleus RTOS. <br><br>  Prototipo de llamada de servicio: <br>  <b>ESTADO NUSE_Timer_Information (NUSE_TIMER timer, OPTION * enable, U8 * expirations, U8 * id, U16 * initial_time, U16 * reschedule_time);</b> <br><br>  Par√°metros: <br>  <b>timer</b> - √≠ndice del temporizador sobre el que se solicita informaci√≥n; <br>  <b>enable</b> : un puntero a una variable que toma el valor <b>VERDADERO</b> o <b>FALSO</b> , dependiendo de si el temporizador est√° activado o no; <br>  <b>vencimientos</b> : un puntero a una variable de tipo <b>U8</b> que toma el valor del n√∫mero de finalizaciones del temporizador desde su √∫ltimo reinicio; <br>  <b>id</b> : apunta a una variable de tipo <b>U8</b> que toma el valor del par√°metro pasado a la funci√≥n de finalizaci√≥n del temporizador (devolver√° un valor vac√≠o si las funciones de finalizaci√≥n est√°n desactivadas); <br>  <b>initial_time</b> : un puntero a una variable de tipo <b>U16</b> que toma un valor por el cual el temporizador se inicializar√° despu√©s de un reinicio; <br>  <b>reschedule_time</b> : un puntero a una variable de tipo <b>U16</b> , que toma el valor por el cual el temporizador se inicializar√° una vez completado. <br><br>  Valor de retorno: <br>  <b>NUSE_SUCCESS</b> : la llamada se complet√≥ correctamente; <br>  <b>NUSE_INVALID_TIMER</b> : √≠ndice de temporizador no v√°lido; <br>  <b>NUSE_INVALID_POINTER</b> : uno o m√°s par√°metros de puntero son incorrectos. <br><br>  <b><i>Implementaci√≥n de informaci√≥n del temporizador en Nucleus SE</i></b> <br>  Implementar esta llamada a la API es bastante simple: <br><br><pre> <code class="plaintext hljs">NUSE_CS_Enter(); if (NUSE_Timer_Status[timer]) { *enable = NUSE_ENABLE_TIMER; } else { *enable = NUSE_DISABLE_TIMER; } *expirations = NUSE_Timer_Expirations_Counter[timer]; #if NUSE_TIMER_EXPIRATION_ROUTINE_SUPPORT *id = NUSE_Timer_Expiration_Routine_Parameter[timer]; #endif *initial_time = NUSE_Timer_Initial_Time[timer]; *reschedule_time = NUSE_Timer_Reschedule_Time[timer]; NUSE_CS_Exit();</code> </pre><br>  La funci√≥n devuelve el estado del temporizador.  El valor del par√°metro de la funci√≥n de terminaci√≥n se devuelve solo si su soporte se ha activado en la aplicaci√≥n. <br><br><h3>  Obtener el n√∫mero de temporizadores </h3><br>  Esta llamada de utilidad devuelve el n√∫mero de temporizadores configurados en la aplicaci√≥n.  En Nucleus RTOS, este valor puede cambiar con el tiempo y el valor de retorno mostrar√° el n√∫mero actual de temporizadores.  En Nucleus SE, el valor de retorno se establece durante la fase de ensamblaje y no se puede cambiar. <br><br>  <b><i>Llame para obtener un contador de temporizador en Nucleus RTOS</i></b> <br><br>  Prototipo de llamada de servicio: <br>  <b>SIN FIRMAR NU_Establecido_Timers (ANULADO);</b> <br><br>  Par√°metros: ninguno <br><br>  Valor de retorno: el n√∫mero de temporizadores creados en el sistema. <br><br>  <b><i>Llamar al contador del temporizador en Nucleus SE</i></b> <br>  Esta llamada a la API admite la funcionalidad principal de la API Nucleus RTOS. <br><br>  Prototipo de llamada de servicio: <br>  <b>U8 NUSE_Timer_Count (nulo);</b> <br><br>  Par√°metros: ninguno <br><br>  Valor de retorno: <br>  la cantidad de temporizadores configurados en la aplicaci√≥n <br><br><h3>  Implementaci√≥n de contador de temporizador </h3><br>  La implementaci√≥n de esta llamada a la API es bastante simple: se <b>devuelve</b> el valor del s√≠mbolo #define <b>NUSE_TIMER_NUMBER</b> . <br><br><h2>  Estructuras de datos </h2><br>  Los temporizadores usan cinco o siete estructuras de datos (ubicadas en RAM o ROM) que (como otros objetos de Nucleus SE) son un conjunto de tablas cuyo tama√±o y n√∫mero corresponde al n√∫mero de temporizadores configurados y par√°metros seleccionados. <br><br>  Recomiendo encarecidamente que el c√≥digo de la aplicaci√≥n no utilice el acceso directo a estas estructuras de datos, sino que se refiera a ellas a trav√©s de las funciones API proporcionadas.  Esto evitar√° la incompatibilidad con futuras versiones de Nucleus SE y los efectos secundarios no deseados, adem√°s de simplificar la transferencia de aplicaciones a Nucleus RTOS.  La siguiente es una descripci√≥n detallada de las estructuras para simplificar la comprensi√≥n de la llamada de servicio y el c√≥digo de depuraci√≥n. <br><br><h3>  Datos de RAM </h3><br>  Estos datos tienen la siguiente estructura: <br>  <b>NUSE_Timer_Status []</b> es una matriz de tipo <b>U8</b> que tiene una entrada para cada temporizador configurado y almacena el estado del temporizador (en ejecuci√≥n o detenido: <b>VERDADERO</b> o <b>FALSO</b> ). <br>  <b>NUSE_Timer_Value []</b> es una matriz de tipo <b>U16</b> que tiene una entrada para cada temporizador configurado y almacena el valor actual del contador del temporizador. <br>  <b>NUSE_Timer_Expirations_Counter []</b> : una matriz de tipo <b>U8</b> , que contiene un contador del n√∫mero de casos en que los temporizadores llegaron al final del ciclo desde su √∫ltimo reinicio. <br><br>  Todas estas estructuras de datos se inicializan mediante la funci√≥n <b>NUSE_Init_Timer ()</b> cuando se inicia Nucleus SE.  Uno de los siguientes art√≠culos contendr√° una descripci√≥n completa de los procedimientos de inicio de Nucleus SE. <br><br>  Las siguientes son las definiciones de estas estructuras de datos en el archivo <b>nuse_init.c</b> : <br>  <b>RAM U8 Timer_Status [NUSE_TIMER_NUMBER];</b> <b><br></b>  <b>RAM U16 NUSE_Timer_Value [NUSE_TIMER_NUMBER];</b> <b><br></b>  <b>RAM U8 NUSE_Timer_Expirations_Counter [NUSE_TIMER_NUMBER];</b> <br><br><h3>  Datos ROM </h3><br>  La estructura de estos datos: <br>  <b>NUSE_Timer_Initial_Time []</b> es una matriz de tipo <b>U16</b> que tiene una entrada para cada temporizador configurado y almacena el valor de cada temporizador. <br>  <b>NUSE_Timer_Reschedule_Time []</b> : una matriz de tipo <b>U16</b> que tiene una entrada para cada temporizador configurado y almacena el valor en el que se configurar√° el temporizador despu√©s de la finalizaci√≥n.  Un valor de cero indica que el temporizador es "√∫nico" y no debe reiniciarse autom√°ticamente. <br>  <b>NUSE_Timer_Expiration_Routine_Address []</b> : una matriz de tipo <b>ADDR que</b> contiene la direcci√≥n de los procedimientos de caducidad del temporizador.  Esta matriz solo existe si se ha activado el soporte para el procedimiento de caducidad del temporizador. <br>  <b>NUSE_Timer_Expiration_Routine_Parameter []</b> : una matriz de tipo <b>U8 que</b> contiene los valores del par√°metro que se pasa a la funci√≥n de finalizaci√≥n del temporizador.  Esta matriz existe solo si se ha activado el soporte para funciones de finalizaci√≥n. <br><br>  Estas estructuras de datos se declaran e inicializan (est√°ticamente) en el archivo <b>nuse_config.c</b> , por lo tanto: <br><br><pre> <code class="plaintext hljs">ROM U16 NUSE_Timer_Initial_Time[NUSE_TIMER_NUMBER] = { /*   ------ */ }; ROM U16 NUSE_Timer_Reschedule_Time[NUSE_TIMER_NUMBER] = { /*      ------ */ }; #if NUSE_TIMER_EXPIRATION_ROUTINE_SUPPORT || NUSE_INCLUDE_EVERYTHING /*    */ ROM ADDR NUSE_Timer_Expiration_Routine_Address[NUSE_TIMER_NUMBER] = { /*     ------ */ /*   NULL */ }; ROM U8 NUSE_Timer_Expiration_Routine_Parameter[NUSE_TIMER_NUMBER] = { /*     ------ */ }; #endif</code> </pre><br><h3>  La cantidad de memoria para el temporizador. </h3><br>  Como todos los dem√°s objetos de Nucleus SE, la cantidad de datos necesarios para los temporizadores es predecible. <br><br>  La cantidad de datos en RAM (en bytes) para todos los temporizadores de la aplicaci√≥n se puede calcular de la siguiente manera: <br>  <b>NUSE_TIMER_NUMBER * 4</b> <br><br>  La cantidad de datos en ROM (en bytes) para todos los temporizadores de la aplicaci√≥n, si el soporte para las funciones de finalizaci√≥n est√° deshabilitado, se puede calcular de la siguiente manera: <br>  <b>NUSE_TIMER_NUMBER * 4</b> <br><br>  De lo contrario, es igual a: <br>  <b>NUSE_TIMER_NUMBER * (tama√±o de (ADDR) + 5)</b> <br><br><h2>  Llamadas API no realizadas </h2><br>  Nucleus SE no implementa las tres llamadas API que se pueden encontrar en RTOS. <br><br><h3>  Creaci√≥n de temporizador </h3><br>  Esta llamada a la API crea un temporizador.  Nucleus SE no lo necesita, ya que los temporizadores se crean de forma est√°tica. <br><br>  Prototipo de llamada de servicio: <br>  <b>ESTADO NU_Create_Timer (NU_TIMER * timer, CHAR * name, VOID (* expiration_routine) (UNSIGNED), UNSIGNED id, UNSIGNED initial_time, UNSIGNED reschedule_time, OPTION enable);</b> <br><br>  Par√°metros: <br>  <b>timer</b> - puntero al bloque de control del timer provisto por el usuario;  se usar√° para controlar temporizadores en otras llamadas API; <br>  <b>nombre</b> : puntero al nombre de 7 caracteres del temporizador con un cero final; <br>  <b>expiration_routine</b> : indica la funci√≥n que debe ejecutarse despu√©s de que finalice el temporizador; <br>  <b>id</b> : un elemento de datos de tipo <b>UNSIGNED que se</b> pasa a la funci√≥n de terminaci√≥n: este par√°metro se puede usar para identificar temporizadores con la misma funci√≥n de terminaci√≥n; <br>  <b>initial_time</b> : indica el n√∫mero inicial de tics del temporizador antes de que finalice el temporizador; <br>  <b>reschedule_time</b> : indica el n√∫mero de <b>tics</b> del temporizador hasta que se completen el segundo ciclo y los posteriores;  si este par√°metro es igual a cero, el temporizador se detiene solo una vez; <br>  <b>enable</b> : este par√°metro puede tomar los valores <b>NU_ENABLE_TIMER</b> y <b>NU_DISABLE_TIMER</b> ;  <b>NU_ENABLE_TIMER</b> activa un temporizador despu√©s de que se crea;  <b>NU_DISABLE_TIMER</b> deja el temporizador deshabilitado;  los temporizadores creados con el par√°metro <b>NU_DISABLE_TIMER</b> deben activarse llamando a <b>NU_Control_Timer</b> . <br><br>  Valor de retorno: <br>  <b>NU_SUCCESS</b> : la llamada se complet√≥ correctamente; <br>  <b>NU_INVALID_TIMER</b> : un puntero nulo a una unidad de control del temporizador ( <b>NULL</b> ), o la unidad de control ya est√° en uso; <br>  <b>NU_INVALID_FUNCTION</b> : puntero nulo al programa de finalizaci√≥n ( <b>NULL</b> ); <br>  <b>NU_INVALID_ENABLE</b> : par√°metro de <b>habilitaci√≥n</b> no v√°lido; <br>  <b>NU_INVALID_OPERATION</b> : el par√°metro <b>initial_time</b> era cero. <br><br><h3>  Eliminar temporizador </h3><br>  Esta llamada a la API elimina un temporizador creado previamente.  Nucleus SE no lo necesita, porque los temporizadores se crean de forma est√°tica y no se pueden eliminar. <br><br>  Prototipo de llamada de servicio: <br>  <b>ESTADO NU_Delete_Timer (NU_TIMER * timer);</b> <br><br>  Par√°metros: <br>  <b>timer</b> - puntero al bloque de control del temporizador. <br><br>  Valor de retorno: <br>  <b>NU_SUCCESS</b> : la llamada se complet√≥ correctamente; <br>  <b>NU_INVALID_TIMER</b> : puntero de temporizador no v√°lido; <br>  <b>NU_NOT_DISABLED</b> : el temporizador especificado no est√° deshabilitado. <br><br><h3>  Punteros de temporizador </h3><br>  Esta llamada a la API forma una lista secuencial de punteros a todos los temporizadores del sistema.  Nucleus SE no lo necesita, ya que los temporizadores est√°n determinados por un √≠ndice simple, no por un puntero. <br><br>  Prototipo de llamada de servicio: <br>  <b>NU_Timer_Pointers SIN FIRMAR (NU_TIMER ** pointer_list, UNSIGNED maximum_pointers);</b> <br><br>  Par√°metros: <br>  <b>pointer_list</b> : puntero a una matriz de punteros <b>NU_TIMER</b> ;  se llenar√° de punteros a temporizadores configurados en el sistema; <br>  <b>maximum_pointers</b> : el n√∫mero m√°ximo de punteros en la matriz. <br><br>  Valor de retorno: <br>  El n√∫mero de punteros <b>NU_TIMER</b> colocados en la matriz. <br><br><h2>  Nucleus RTOS Compatible </h2><br>  Al igual que con todos los dem√°s objetos de Nucleus SE, mi objetivo era maximizar la compatibilidad del c√≥digo de la aplicaci√≥n con Nucleus RTOS.  Los temporizadores no son una excepci√≥n y, desde el punto de vista del usuario, se implementan de la misma manera que en Nucleus RTOS.    ,    ,   ,                .  ,  API Nucleus RTOS       Nucleus SE. <br><br><h3>   </h3><br>  Nucleus RTOS,      ‚Äî  ,     .        .  ,   Nucleus SE       :         / .         .    ‚Äì    .  ,   <b>NUSE_TIMER</b>    <b>U8</b> ,  (  )     .      ,     Nucleus SE  Nucleus RTOS  .        ,    . <br> Nucleus RTOS     .      .     Nucleus SE,   . <br><br><h3>   </h3><br>  Nucleus RTOS     32- .       16   Nucleus SE.           . Nucleus SE   ,       . <br><br><h3>   </h3><br> Nucleus SE      Nucleus RTOS ,       (   ),     .    ,   . <br><br><h3>   API </h3><br> Nucleus RTOS        .       Nucleus SE.    ,           ,   ¬´  API¬ª. <br><br>      . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/455072/">https://habr.com/ru/post/455072/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../455060/index.html">Homer o el primer Open Source. parte 1</a></li>
<li><a href="../455062/index.html">Casos de experimentos exitosos (y no tan) de Yandex.Navigator</a></li>
<li><a href="../455064/index.html">Talento vs. Suerte: el papel del azar en el √©xito y el fracaso</a></li>
<li><a href="../455066/index.html">An√°lisis del sistema MeetUp UPD2 Broadcast y presentaciones</a></li>
<li><a href="../455070/index.html">¬øPor qu√© las entrevistas son tan frecuentes sobre las listas vinculadas?</a></li>
<li><a href="../455076/index.html">GameDev TDD o Rabbit Hell</a></li>
<li><a href="../455078/index.html">D√≥nde hablar sobre Apache Ignite y los sistemas distribuidos en verano</a></li>
<li><a href="../455082/index.html">Estudiamos MITRE ATT & CK. Matrices m√≥viles: acceso a dispositivos. Parte 4</a></li>
<li><a href="../455088/index.html">¬øQu√© prueban las entrevistas y los elementos de prueba?</a></li>
<li><a href="../455094/index.html">C√≥mo proteger 5G en una ciudad inteligente: aplique una nueva arquitectura de seguridad</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>