<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ“ ğŸ‘©â€âš–ï¸ ğŸ‘©ğŸ½â€ğŸ« Pointer itu kompleks, atau apa yang disimpan dalam byte? ğŸ˜µ ğŸ•ºğŸ½ ğŸŒ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Saya mempersembahkan kepada Anda terjemahan artikel "Pointers Are Complicated, atau: Apa yang ada dalam Byte?" kepenulisan Ralf Jung. 


 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pointer itu kompleks, atau apa yang disimpan dalam byte?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460953/"><p>  Halo, Habr!  Saya mempersembahkan kepada Anda terjemahan artikel "Pointers Are Complicated, atau: Apa yang ada dalam Byte?"  kepenulisan Ralf Jung. </p><br><p>  Musim panas ini saya sedang mengerjakan Rust penuh waktu lagi, dan saya akan lagi (antara lain) mengerjakan "model memori" untuk Rust / MIR.  Namun, sebelum saya berbicara tentang ide-ide saya, saya akhirnya harus menghilangkan mitos bahwa "petunjuk itu sederhana: mereka hanya angka."  Kedua bagian dari pernyataan ini salah, setidaknya dalam bahasa dengan fitur yang tidak aman, seperti Rust atau C: pointer tidak bisa disebut nomor prima atau (biasa). </p><br><p>  Saya juga ingin membahas bagian dari model memori yang perlu ditangani sebelum kita dapat berbicara tentang bagian yang lebih kompleks: dalam <em>bentuk apa</em> data disimpan dalam memori?  Memori terdiri dari byte, unit minimum yang dapat dialamatkan dan elemen terkecil yang dapat diakses (setidaknya pada sebagian besar platform), tetapi apa nilai byte yang mungkin?  Sekali lagi, ternyata "itu hanya angka 8-bit" tidak cocok sebagai jawaban. <a name="habracut"></a></p><br><p>  Saya harap setelah membaca posting ini, Anda akan setuju dengan saya mengenai kedua pernyataan tersebut. </p><br><h1 id="ukazateli-slozhny">  Pointer rumit </h1><br><p>  Apa masalah dengan "pointer adalah angka reguler"?  Mari kita lihat contoh berikut: (Saya menggunakan C ++ di sini, karena menulis kode yang tidak aman di C ++ lebih mudah daripada menulis di Rust, dan kode yang tidak aman hanyalah tempat di mana masalah muncul. Insecure Rust dan C memiliki semua masalah yang sama yang dan C ++). </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> y = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">8</span></span>]; y[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-comment"><span class="hljs-comment">/* -     */</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x_ptr = &amp;x[i]; *x_ptr = <span class="hljs-number"><span class="hljs-number">23</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> y[<span class="hljs-number"><span class="hljs-number">0</span></span>]; }</code> </pre> <br><p>  Mengoptimalkan pembacaan terakhir y [0] dengan pengembalian 42 selalu sangat bermanfaat.  Alasan untuk optimasi ini adalah bahwa mengubah x_ptr yang menunjuk ke x tidak dapat mengubah y. </p><br><p>  Namun, ketika berhadapan dengan bahasa tingkat rendah seperti C ++, kita dapat melanggar asumsi ini dengan menetapkan nilai yx.  Karena &amp; x [i] sama dengan x + i, kita menulis 23 di &amp; y [0]. </p><br><p>  Tentu saja, ini tidak mencegah kompiler C ++ melakukan optimasi seperti itu.  Untuk mengatasi ini, standar mengatakan bahwa kode kami memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">UB</a> . </p><br><p>  Pertama, itu tidak diperbolehkan untuk melakukan operasi aritmatika pada pointer (seperti dalam kasus &amp; x [i]), jika dalam kasus ini pointer <a href="">melampaui salah satu batas array</a> .  Program kami melanggar aturan ini: x [i] melampaui x, jadi itu adalah UB.  Dengan kata lain, bahkan <em>menghitung</em> nilai x_ptr adalah UB, jadi kami bahkan tidak sampai ke tempat di mana kami ingin <em>menggunakan</em> pointer ini. </p><br><p>  (Ternyata i = yx juga UB, karena <a href="">hanya pointer yang menunjuk ke alokasi memori yang sama</a> yang <a href="">boleh dikurangi</a> . Namun, kita bisa menulis i = ((size_t) y - (size_t) x - / sizeof (int) untuk memotong ini adalah batasan.) </p><br><p>  Tetapi kita belum selesai: aturan ini memiliki satu-satunya pengecualian yang dapat kita gunakan untuk keuntungan kita.  Jika operasi aritmatika menghitung nilai pointer ke alamat <em>tepat setelah</em> akhir array, maka semuanya dalam urutan.  (Pengecualian ini diperlukan untuk menghitung vec.end () untuk loop paling umum di C ++ 98.) </p><br><p>  Mari kita ubah sedikit contoh: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> y = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">8</span></span>]; y[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x_ptr = x+<span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    if (x_ptr == &amp;y[0]) *x_ptr = 23; return y[0]; }</span></span></code> </pre> <br><p>  Sekarang bayangkan x dan y dialokasikan <em>satu demi satu</em> , dengan y memiliki alamat yang lebih besar.  Kemudian x_ptr menunjuk <em>ke awal</em> y!  Maka kondisinya benar dan tugas terjadi.  Pada saat yang sama, tidak ada UB karena keluarnya pointer di luar negeri. </p><br><p>  Tampaknya ini tidak akan memungkinkan pengoptimalan.  Namun, standar C ++ memiliki kartu as lainnya untuk membantu pembuat kompiler: nyatanya, ia tidak memungkinkan kami untuk menggunakan x_ptr.  Menurut apa yang dikatakan standar tentang <a href="">menambahkan angka ke pointer</a> , x_ptr menunjuk ke alamat setelah elemen terakhir dari array.  Itu <em>tidak</em> menunjuk ke elemen tertentu dari objek lain, <em>bahkan jika mereka memiliki alamat yang sama</em> .  (Setidaknya ini adalah interpretasi umum dari standar berdasarkan yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LLVM mengoptimalkan kode ini</a> .) </p><br><p>  Dan meskipun x_ptr dan &amp; y [0] menunjuk ke <em>alamat yang</em> sama, ini tidak menjadikan mereka <em>penunjuk yang sama</em> , yaitu, mereka tidak dapat digunakan secara bergantian: &amp; y [0] menunjuk ke elemen pertama y;  x_ptr menunjuk ke alamat setelah x.  Jika kita mengganti * x_ptr = 23 dengan string * &amp; y [0] = 0, kita akan mengubah nilai program, meskipun kedua pointer diperiksa untuk kesetaraan. </p><br><p>  Ini layak diulangi: </p><br><blockquote>  Hanya karena dua petunjuk menunjuk ke alamat yang sama tidak berarti bahwa mereka sama dan dapat digunakan secara bergantian. </blockquote><p>  Ya, perbedaan ini sulit dipahami.  Bahkan, ini masih menyebabkan perbedaan dalam program yang dikompilasi dengan LLVM dan GCC. </p><br><p>  Perhatikan juga bahwa aturan satu-kali bukan satu-satunya tempat di C / C ++ di mana kita dapat mengamati efek seperti itu.  Contoh lain adalah pembatasan kata kunci dalam C, yang dapat digunakan untuk menyatakan bahwa pointer tidak tumpang tindih (tidak sama): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">restrict</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">restrict</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>{ *x = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x == y) { *y = <span class="hljs-number"><span class="hljs-number">23</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *x; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> foo(&amp;x, &amp;x); }</code> </pre> <br><p>  Panggilan tes () memanggil UB, karena dua akses memori di foo seharusnya tidak terjadi pada alamat yang sama.  Mengganti * y dengan * x di foo, kami akan mengubah nilai program, dan tidak akan lagi memanggil UB.  Sekali lagi: walaupun x dan y memiliki alamat yang sama, mereka tidak dapat digunakan secara bergantian. </p><br><p>  Pointer jelas bukan hanya angka. </p><br><h1 id="prostaya-model-ukazateley">  Model penunjuk sederhana </h1><br><p>  Jadi apa itu pointer?  Saya tidak tahu jawaban lengkapnya.  Bahkan, ini adalah area terbuka untuk penelitian. </p><br><p>  Satu poin penting: di sini kita melihat <em>model</em> pointer <em>abstrak</em> .  Tentu saja, di komputer sungguhan, pointer adalah angka.  Tetapi komputer sungguhan tidak melakukan optimisasi yang dilakukan oleh kompiler C ++ modern.  Jika kita menulis program-program di atas dalam assembler, maka tidak akan ada UB, tidak ada optimasi.  C ++ dan Rust mengambil pendekatan yang lebih "tingkat tinggi" untuk memori dan pointer, membatasi programmer ke kompiler.  Ketika perlu untuk menggambarkan secara formal apa yang bisa dan tidak bisa dilakukan oleh seorang programmer dalam bahasa-bahasa ini, model pointer sebagai angka dihancurkan, jadi kita perlu menemukan sesuatu yang lain.  Ini adalah contoh lain dari menggunakan "mesin virtual" yang berbeda dari komputer nyata untuk keperluan spesifikasi - sebuah ide yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">saya tulis sebelumnya</a> . </p><br><p>  Berikut ini adalah kalimat sederhana (pada kenyataannya, model pointer ini digunakan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CompCert</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pekerjaan saya oleh RustBelt</a> , serta cara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penerjemah miri</a> mengimplementasikan <a href="">pointer</a> ): pointer adalah sepasang ID yang secara unik mengidentifikasi area memori (alokasi), dan offset relatif terhadap daerah ini.  Jika Anda menulis ini di Rust: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pointer</span></span></span></span> { alloc_id: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, offset: <span class="hljs-built_in"><span class="hljs-built_in">isize</span></span>, }</code> </pre> <br><p>  Operasi penambahan (pengurangan) angka ke penunjuk (dari penunjuk) hanya memengaruhi offset, dan karena itu penunjuk tidak pernah dapat meninggalkan area memori.  Mengurangi pointer hanya mungkin jika mereka termasuk dalam area memori yang sama (sesuai dengan <a href="">C ++</a> ). </p><br><p>  (Seperti yang dapat kita lihat, standar C ++ menerapkan aturan-aturan ini ke array, bukan area memori. Namun, LLVM menerapkannya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tingkat area</a> .) </p><br><p>  Ternyata (dan miri menunjukkan hal yang sama) bahwa model ini dapat melayani kita dengan baik.  Kami selalu mengingat wilayah memori yang menjadi tempat penunjuk, sehingga kami dapat membedakan penunjuk satu-setelah dari satu wilayah memori dari penunjuk ke awal wilayah lain.  Dengan demikian miri dapat menemukan bahwa contoh kedua kami (dengan &amp; x [8]) memiliki UB. </p><br><h1 id="nasha-model-razvalivaetsya-na-kuski">  Model kami berantakan </h1><br><p>  Dalam model kami, pointer, meskipun bukan angka, setidaknya sederhana.  Namun, model ini akan mulai berantakan di depan mata kita, segera setelah Anda mengingat konversi pointer ke angka.  Dalam miri, casting pointer ke angka sebenarnya tidak melakukan apa-apa, kita hanya mendapatkan variabel numerik (mis., Tipenya mengatakan itu angka) yang <em>nilainya</em> pointer (mis., Sepasang area memori dan offset).  Namun, mengalikan angka ini dengan 2 menyebabkan kesalahan, karena sama sekali tidak jelas apa artinya "mengalikan pointer abstrak dengan 2". </p><br><p>  Saya harus mengklarifikasi: ini <em>bukan</em> solusi yang baik untuk mendefinisikan semantik bahasa.  Namun, ini bekerja dengan baik untuk penerjemah.  Ini adalah pendekatan yang paling sederhana, dan kami memilihnya karena tidak jelas bagaimana hal itu dapat dilakukan sebaliknya (kecuali untuk tidak mendukung pengurangan seperti itu sama sekali - tetapi dengan dukungan mereka miri dapat menjalankan lebih banyak program): di mesin abstrak kami tidak ada "ruang alamat" tunggal, di mana semua area memori yang dialokasikan akan ditempatkan, dan semua pointer dipetakan ke nomor yang berbeda.  Setiap area memori diidentifikasi oleh ID (tersembunyi).  Sekarang kita dapat mulai menambahkan data tambahan ke model kita, seperti alamat pangkalan untuk setiap area memori, dan entah bagaimana menggunakannya untuk membawa nomor kembali ke pointer ... dan pada titik ini prosesnya menjadi sangat sangat rumit, dan, bagaimanapun, diskusi tentang ini Model bukan tujuan menulis posting.  Tujuannya adalah untuk membahas perlunya model seperti itu.  Jika Anda tertarik, saya sarankan Anda membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumen ini</a> , yang lebih dekat melihat gagasan di atas untuk menambahkan alamat basis. </p><br><p>  Singkatnya, gips dari pointer dan angka satu sama lain membingungkan dan sulit untuk ditentukan secara formal, mengingat optimisasi yang dibahas di atas.  Ada konflik antara pendekatan tingkat tinggi yang diperlukan untuk optimasi dan pendekatan tingkat rendah yang diperlukan untuk menggambarkan penunjuk penunjuk ke angka dan sebaliknya.  Untuk sebagian besar, kita cukup mengabaikan masalah ini dalam miri dan, jika memungkinkan, cobalah untuk melakukan sebanyak mungkin menggunakan model sederhana yang bekerja dengan kita.  Definisi bahasa yang lengkap seperti C ++ atau Rust, tentu saja, tidak bisa begitu sederhana, itu harus menjelaskan apa yang sebenarnya terjadi.  Sejauh yang saya tahu, tidak ada solusi yang cocok, tetapi penelitian akademis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mendekati kebenaran</a> . </p><br><p>  Itu sebabnya pointer juga tidak sederhana. </p><br><h1 id="ot-ukazateley-k-baytam">  Dari pointer ke byte </h1><br><p>  Saya harap saya telah membuat argumen yang meyakinkan bahwa angka bukan satu-satunya tipe data yang perlu dipertimbangkan jika kita ingin secara formal menggambarkan bahasa tingkat rendah seperti C ++ atau bagian (tidak aman) dari Rust.  Namun, ini berarti bahwa operasi sederhana seperti membaca byte dari memori tidak bisa hanya mengembalikan u8.  Bayangkan kita <a href="">menerapkan memcpy</a> dengan membaca setiap byte dari sumber itu pada gilirannya menjadi beberapa variabel lokal v, dan kemudian menyimpan nilai ini di lokasi target.  Tetapi bagaimana jika byte ini adalah bagian dari sebuah pointer?  Jika pointer adalah sepasang ID area memori dan offset, lalu apa yang akan menjadi byte pertama?  Kita perlu mengatakan apa nilai v sama dengan, jadi kita harus entah bagaimana menjawab pertanyaan ini.  (Dan ini adalah masalah yang sama sekali berbeda dari masalah dengan perkalian, yang ada di bagian sebelumnya. Kami hanya berasumsi bahwa ada beberapa jenis abstrak Ponter.) </p><br><p>  Kami tidak dapat merepresentasikan byte dari pointer sebagai nilai rentang 0..256 (catatan: selanjutnya 0 dihidupkan, 256 tidak).  Secara umum, jika kita menggunakan model representasi memori yang naif, bagian "tersembunyi" tambahan dari pointer (yang membuatnya lebih dari sekadar angka) akan hilang ketika pointer ditulis ke memori dan dibaca kembali dari itu.  Kami harus memperbaiki ini, dan untuk ini kami harus memperluas konsep "byte" kami untuk mewakili keadaan tambahan ini.  Jadi, byte sekarang adalah nilai kisaran 0..256 ("bit mentah"), <em>atau</em> byte ke-n dari beberapa pointer abstrak.  Jika kami harus menerapkan model memori kami di Rust, itu bisa terlihat seperti ini: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ByteV1</span></span></span></span> { Bits(<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>), PtrFragment(Pointer, <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>), }</code> </pre> <br><p>  Misalnya, PtrFragment (ptr, 0) mewakili byte pertama dari pointer ptr.  Dengan demikian, memcpy dapat "memecah" pointer menjadi byte terpisah yang mewakili pointer ini dalam memori, dan menyalinnya satu per satu.  Pada arsitektur 32-bit, representasi ptr penuh akan berisi 4 byte: </p><br><pre> <code class="rust hljs">[PtrFragment(ptr, <span class="hljs-number"><span class="hljs-number">0</span></span>), PtrFragment(ptr, <span class="hljs-number"><span class="hljs-number">1</span></span>), PtrFragment(ptr, <span class="hljs-number"><span class="hljs-number">2</span></span>), PtrFragment(ptr, <span class="hljs-number"><span class="hljs-number">3</span></span>)]</code> </pre> <br><p>  Representasi ini mendukung semua operasi pemindahan data melalui pointer pada level byte, yang cukup untuk memcry.  Operasi aritmatika atau bit tidak sepenuhnya didukung;  seperti disebutkan di atas, ini akan membutuhkan representasi pointer yang lebih kompleks. </p><br><h1 id="neinicializirovannaya-pamyat">  Memori tidak diinisialisasi </h1><br><p>  Namun, kami belum selesai dengan definisi "byte" kami.  Untuk sepenuhnya menggambarkan perilaku program, kita perlu mempertimbangkan opsi lain: satu byte dalam memori dapat <em>diinisialisasi</em> .  Definisi byte terakhir akan terlihat seperti ini (misalkan kita memiliki tipe Pointer untuk pointer): </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Byte</span></span></span></span> { Bits(<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>), PtrFragment(Pointer, <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>), Uninit, }</code> </pre> <br><p>  Kami menggunakan nilai Uninit untuk semua byte di memori yang dialokasikan di mana kami belum menulis nilai apa pun.  Dimungkinkan untuk membaca memori yang tidak diinisialisasi tanpa masalah, tetapi <em>tindakan</em> lain dengan byte ini (misalnya, aritmatika numerik) mengarah ke UB. </p><br><p>  Ini sangat mirip dengan aturan LLVM sehubungan dengan nilai racun khusus.  Perhatikan bahwa LLVM <em>juga</em> memiliki nilai undef, yang digunakan untuk memori yang tidak diinisialisasi dan bekerja sedikit berbeda.  Namun, mengkompilasi Uninit kami ke undef benar (undef dalam beberapa hal â€œlebih lemahâ€), dan ada saran <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuk menghapus undef dari LLVM dan menggunakan racun sebagai gantinya</a> . </p><br><p>  Anda mungkin bertanya-tanya mengapa kami memiliki nilai Uninit khusus sama sekali.  Mengapa tidak memilih sembarang b: u8 untuk setiap byte baru, dan kemudian gunakan Bit (b) sebagai nilai awal?  Ini benar-benar satu opsi.  Namun, pertama-tama, semua penyusun datang ke pendekatan menggunakan nilai khusus untuk memori yang tidak diinisialisasi.  Tidak mengikuti pendekatan ini berarti tidak hanya menyebabkan masalah kompilasi melalui LLVM, tetapi juga meninjau semua optimisasi dan memastikan bahwa mereka bekerja dengan benar dengan model yang dimodifikasi ini.  Poin kunci di sini: Anda selalu dapat dengan aman mengganti Uninit dengan nilai lain: operasi apa pun yang menerima nilai ini akan mengarah ke UB. </p><br><p>  Misalnya, kode C ini lebih mudah dioptimalkan dengan Uninit: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (condA()) x = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     ,       ,  condA() //  ,      x. use(x); //  x = 1. }</span></span></code> </pre> <br><p>  Dengan Uninit, kita dapat dengan mudah mengatakan bahwa x memiliki nilai Uninit atau nilai 1, dan karena menggantikan Uninit dengan 1 karya, optimasi mudah dijelaskan.  Tanpa Uninit, x adalah "semacam pola bit arbitrer" atau 1, dan optimasi yang sama lebih sulit untuk dijelaskan. </p><br><p>  (Kita dapat berargumen bahwa kita dapat menukar operasi ketika kita membuat pilihan yang tidak deterministik, tetapi kemudian kita perlu membuktikan bahwa kode yang sulit dianalisis tidak menggunakan x dengan cara apa pun. Uninit menghindari masalah ini dengan bukti yang tidak perlu.) </p><br><p>  Akhirnya, Uninit adalah pilihan terbaik untuk penerjemah seperti miri.  Penerjemah tersebut memiliki masalah dengan operasi seperti "cukup pilih salah satu dari nilai-nilai ini" (yaitu, operasi non-deterministik), karena mereka cenderung melalui semua jalur yang mungkin dari pelaksanaan program, yang berarti bahwa mereka perlu mencoba semua nilai yang mungkin.  Menggunakan Uninit sebagai ganti pola bit arbitrer berarti bahwa miri dapat memberi tahu Anda setelah satu program dijalankan apakah program Anda menggunakan nilai yang tidak diinisialisasi dengan salah. </p><br><h1 id="zaklyuchenie">  Kesimpulan </h1><br><p>  Kami melihat bahwa dalam bahasa seperti C ++ dan Rust (tidak seperti komputer nyata) pointer dapat berbeda bahkan jika mereka menunjuk ke alamat yang sama, dan bahwa byte lebih dari sekedar angka dalam kisaran 0..256.  Karena itu, jika pada tahun 1978 bahasa C bisa menjadi "assembler portabel", sekarang ini adalah pernyataan yang sangat keliru. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id460953/">https://habr.com/ru/post/id460953/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id460943/index.html">Cara memilih kunci yang menjanjikan untuk SEO berdasarkan perkiraan skenario di Google Data Studio (+ templat)</a></li>
<li><a href="../id460945/index.html">Pengalaman dalam menggunakan saluran telegram untuk meningkatkan pengakuan dan pertumbuhan pendapatan sebuah studio game</a></li>
<li><a href="../id460947/index.html">WASM Meet Up 1/08</a></li>
<li><a href="../id460949/index.html">"Dan yang tidak mungkin adalah mungkin": kita mengubah kotak hitam menjadi putih menggunakan analisis biner</a></li>
<li><a href="../id460951/index.html">Buat Wallpaper Animasi Android</a></li>
<li><a href="../id460955/index.html">Program pendidikan untuk melewatkan parameter berdasarkan nilai ke konstruktor dan setter (C ++ modern, contoh)</a></li>
<li><a href="../id460959/index.html">Teknologi baru Microsoft memungkinkan salinan 3D orang sungguhan untuk berbicara bahasa apa pun</a></li>
<li><a href="../id460961/index.html">Menyiapkan tes Unit dalam proyek Swift + Objective-C campuran</a></li>
<li><a href="../id460965/index.html">Split Controller tanpa ini storyboard Anda</a></li>
<li><a href="../id460967/index.html">Troy Hunt: 10 pelajaran keuangan pribadi untuk profesional teknologi informasi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>