<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☝🏽 🏯 🤸🏽 PostgreSQL中的索引-6（SP-GiST） 👨🏻‍🚒 👨🏾‍🎓 ✌🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我们已经讨论了PostgreSQL 索引引擎 ， 访问方法的接口以及三种方法： 哈希索引 ， B树和GiST 。 在本文中，我们将描述SP-GiST。 

 SP-GiST 
 首先，关于这个名字的几句话。 “ GiST”部分暗示了与同名访问方法的相似之处。 确实存在相似之处：两者都是通用的搜索树，...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PostgreSQL中的索引-6（SP-GiST）</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/446624/"> 我们已经讨论了PostgreSQL <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">索引引擎</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">访问方法的接口</a>以及三种方法： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">哈希索引</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">B树</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GiST</a> 。 在本文中，我们将描述SP-GiST。 <br><br><h1>  SP-GiST </h1><br> 首先，关于这个名字的几句话。  “ GiST”部分暗示了与同名访问方法的相似之处。 确实存在相似之处：两者都是通用的搜索树，它们提供了用于构建各种访问方法的框架。 <br><br>  “ SP”代表空间分区。 这里的空间通常就是我们用来称呼空间的东西，例如二维平面。 但是我们会看到，任何搜索空间都是指，实际上是任何值域。 <br><br>  SP-GiST适用于可以将空间递归划分<em>为非相交</em>区域的结构。 此类包括四叉树，k维树（kD树）和基数树。 <br><a name="habracut"></a><br><h2> 结构形式 </h2><br> 因此，SP-GiST访问方法的思想是将值域拆分<em>为非重叠的</em>子域，每个子域又可以拆分。 像这样的分区会引起<em>不平衡的</em>树（不像B树和常规的GiST）。 <br><br> 不相交的特性简化了插入和搜索过程中的决策。 另一方面，通常，诱导的树木是低分支的。 例如，四叉树的一个节点通常具有四个子节点（与B树不同，后者的节点数为数百），并且深度更大。 像这样的树很适合RAM中的工作，但是索引存储在磁盘上，因此，为了减少I / O操作的数量，必须将节点打包到页面中，而有效地做到这一点并不容易。 此外，由于分支深度的差异，在索引中找到不同值所花费的时间可能会有所不同。 <br><br> 此访问方法与GiST一样，可处理低级任务（同时访问和锁定，日志记录和纯搜索算法），并提供专门的简化接口，以增加对新数据类型和新分区算法的支持。 <br><br>  SP-GiST树的内部节点存储对子节点的引用； 可以为每个参考定义<em>标签</em> 。 此外，内部节点可以存储一个称为<em>prefix</em>的值。 实际上，该值不是必须的前缀； 它可以被视为所有子节点都满足的任意谓词。 <br><br>  SP-GiST的叶节点包含索引类型的值和对表行（TID）的引用。 索引数据本身（搜索关键字）可以用作值，但不是强制性的：可以存储缩短的值。 <br><br> 此外，叶节点可以分组为列表。 因此，内部节点不仅可以引用一个值，而且可以引用整个列表。 <br><br> 请注意，叶节点中的前缀，标签和值具有各自独立的数据类型。 <br><br> 与GiST中相同，定义搜索的主要功能是<em>一致性功能</em> 。 该函数针对树节点进行调用，并返回其值与搜索谓词“一致”的一组子节点（通常，形式为“ <em>索引字段运算符表达式</em> ”）。 对于叶节点，一致性函数确定该节点中的索引值是否满足搜索谓词。 <br><br> 搜索从根节点开始。 一致性功能允许找出有意义的子节点。 对找到的每个节点重复该算法。 搜索是深度优先的。 <br><br> 在物理级别，从I / O操作的角度来看，索引节点被打包到页面中以使节点高效工作。 请注意，一个页面可以包含内部或叶节点，但不能同时包含两者。 <br><br><h2> 示例：四叉树 </h2><br> 四叉树用于索引平面中的点。 一个想法是相对于<em>中心点将</em>区域递归地分为四个部分（象限）。 这样一棵树的分支深度可以变化，并取决于适当象限中点的密度。 <br><br> 这是图中所示的样子，例如通过示例<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">数据库</a>的示例，该<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">示例数据库</a>由来自<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">openflights.org</a>站点的机场<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">扩充</a> 。 顺便说一下，最近我们发布了该数据库的新版本，在其余版本中，我们用一个“点”类型的字段替换了经度和纬度。 <br><br><img src="https://habrastorage.org/web/8ab/6f6/4e7/8ab6f64e7bb5484bbfc798327798ce69.png"><br>  <em>首先，我们将飞机分为四个象限...</em> <br><br><img src="https://habrastorage.org/web/6b5/ce5/3e1/6b5ce53e1b57499cad2a61a86a451835.png"><br>  <em>然后我们分割每个象限...</em> <br><br><img src="https://habrastorage.org/web/ba5/e5d/10a/ba5e5d10a47844a2bc95e5505641e798.png"><br>  <em>依此类推，直到获得最终分区。</em> <br><br> 让我们提供一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">有关GiST相关文章中</a>已经考虑过的简单示例的更多详细信息。 查看这种情况下的分区外观： <br><br><img src="https://habrastorage.org/web/a98/6f1/065/a986f106505b4b0fa0b03005a2c657f3.png"><br><br> 象限的编号如第一个图所示。 为了确定起见，让我们从左到右完全按照相同的顺序放置子节点。 下图显示了这种情况下可能的索引结构。 每个内部节点最多引用四个子节点。 如图所示，每个参考都可以用象限编号标记。 但是在实现中没有标签，因为存储四个引用的固定数组比较方便，其中一些引用可以为空。 <br><br><img src="https://habrastorage.org/web/24c/3cf/97f/24c3cf97f59b4f99acb2aa992d1825d6.png"><br><br> 边界上的点与数量较小的象限有关。 <br><br><pre><code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> points(p <span class="hljs-type"><span class="hljs-type">point</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> points(p) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(1,1)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(3,2)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(6,3)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(5,5)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(7,8)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(8,6)'</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> points_quad_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> spgist(p);</code> </pre> <br> 在这种情况下，默认情况下使用“ quad_point_ops”运算符类，其中包含以下运算符： <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname = <span class="hljs-string"><span class="hljs-string">'quad_point_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'spgist'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> amopopr | amopstrategy -----------------+-------------- &lt;&lt;(point,point) | 1 strictly left &gt;&gt;(point,point) | 5 strictly right ~=(point,point) | 6 coincides &lt;^(point,point) | 10 strictly below &gt;^(point,point) | 11 strictly above &lt;@(point,box) | 8 contained in rectangle (6 rows)</code> </pre><br> 例如，让我们看一下查询如何<code>select * from points where p &gt;^ point '(2,7)'</code>将执行<code>select * from points where p &gt;^ point '(2,7)'</code> （查找位于给定点上方的所有点）。 <br><br><img src="https://habrastorage.org/web/5f3/194/855/5f3194855fe74166b56c1703f4bb9b07.png"><br><br> 我们从根节点开始，并使用一致性功能选择要下降到的子节点。 对于运算符<code>&gt;^</code> ，此函数将点（2,7）与节点（4,4）的中心点进行比较，并选择可能包含所寻找点的象限，在这种情况下为第一象限和第四象限。 <br><br> 在与第一象限相对应的节点中，我们再次使用一致性函数确定子节点。 中心点是（6,6），我们再次需要浏览第一和第四象限。 <br><br><img src="https://habrastorage.org/web/8ac/99b/d9e/8ac99bd9e7b94f8d9683307b98ad1875.png"><br><br> 叶节点（8.6）和（7.8）的列表对应于第一象限，其中只有点（7.8）满足查询条件。 对第四象限的引用为空。 <br><br> 在内部节点（4.4）中，对第四象限的引用也为空，从而完成了搜索。 <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> enable_seqscan = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p &gt;^ <span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(2,7)'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------ Index Only Scan using points_quad_idx on points Index Cond: (p &gt;^ '(2,7)'::point) (2 rows)</code> </pre><br><h3> 内部构造 </h3><br> 我们可以使用前面提到的“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">gevel</a> ”扩展名来探索SP-GiST索引的内部结构。 坏消息是，由于存在错误，此扩展程序无法在现代PostgreSQL版本中正常工作。 好消息是，我们计划通过“ gevel”（ <a href="">讨论</a> ）功能增强“ pageinspect”。 该错误已在“ pageinspect”中修复。 <br><blockquote> 再次，坏消息是该补丁没有进展。 <br></blockquote><br> 例如，让我们使用扩展的演示数据库，该数据库用于用世界地图绘制图片。 <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> airports_coordinates_quad_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> airports_ml <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> spgist(coordinates);</code> </pre><br> 首先，我们可以获得索引的一些统计信息： <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> spgist_stats(<span class="hljs-string"><span class="hljs-string">'airports_coordinates_quad_idx'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> spgist_stats ---------------------------------- totalPages: 33 + deletedPages: 0 + innerPages: 3 + leafPages: 30 + emptyPages: 2 + usedSpace: 201.53 kbytes+ usedInnerSpace: 2.17 kbytes + usedLeafSpace: 199.36 kbytes+ freeSpace: 61.44 kbytes + fillRatio: 76.64% + leafTuples: 5993 + innerTuples: 37 + innerAllTheSame: 0 + leafPlaceholders: 725 + innerPlaceholders: 0 + leafRedirects: 0 + innerRedirects: 0 (1 row)</code> </pre><br> 其次，我们可以输出索引树本身： <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> tid, n, <span class="hljs-keyword"><span class="hljs-keyword">level</span></span>, tid_ptr, prefix, leaf_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> spgist_print(<span class="hljs-string"><span class="hljs-string">'airports_coordinates_quad_idx'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> t( tid tid, allthesame <span class="hljs-type"><span class="hljs-type">bool</span></span>, n <span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>, tid_ptr tid, prefix <span class="hljs-type"><span class="hljs-type">point</span></span>, <span class="hljs-comment"><span class="hljs-comment">-- prefix type node_label int, -- label type (unused here) leaf_value point -- list value type ) order by tid, n;</span></span></code> </pre><pre> <code class="plaintext hljs"> tid | n | level | tid_ptr | prefix | leaf_value ---------+---+-------+---------+------------------+------------------ (1,1) | 0 | 1 | (5,3) | (-10.220,53.588) | (1,1) | 1 | 1 | (5,2) | (-10.220,53.588) | (1,1) | 2 | 1 | (5,1) | (-10.220,53.588) | (1,1) | 3 | 1 | (5,14) | (-10.220,53.588) | (3,68) | | 3 | | | (86.107,55.270) (3,70) | | 3 | | | (129.771,62.093) (3,85) | | 4 | | | (57.684,-20.430) (3,122) | | 4 | | | (107.438,51.808) (3,154) | | 3 | | | (-51.678,64.191) (5,1) | 0 | 2 | (24,27) | (-88.680,48.638) | (5,1) | 1 | 2 | (5,7) | (-88.680,48.638) | ...</code> </pre><br> 但是请记住，“ spgist_print”不输出所有叶值，而是仅输出列表中的第一个叶值，因此显示的是索引的结构，而不是其全部内容。 <br><br><h2> 示例：k维树 </h2><br> 对于平面中的相同点，我们还可以建议另一种划分空间的方法。 <br><br> 让我们通过被索引的第一个点画<em>一条水平线</em> 。 它将平面分为两部分：上部和下部。 要索引的第二点属于这些部分之一。 至此，让我们画<em>一条垂直线</em> ，将这部分分为两部分：右和左。 我们再次通过下一个点绘制一条水平线，并通过下一个点绘制一条垂直线，依此类推。 <br><br> 以这种方式构建的树的所有内部节点将只有两个子节点。 这两个引用中的每一个都可以指向层次结构中下一个内部节点或叶节点列表。 <br><br> 这种方法可以很容易地推广到k维空间，因此，这些树在文献中也称为k维（kD树）。 <br><br> 通过机场示例说明方法： <br><br><img src="https://habrastorage.org/web/a97/130/4d6/a971304d68c8442b86a10c0e52c3e78c.png"><br>  <em>首先，我们将飞机分为上下两部分...</em> <br><br><img src="https://habrastorage.org/web/035/660/8fe/0356608fea41422eb7fab9cbb2b67669.png"><br>  <em>然后我们将每个部分分成左右两部分...</em> <br><br><img src="https://habrastorage.org/web/bb1/26e/8db/bb126e8db6714d7bb5122f9213e5f658.png"><br>  <em>依此类推，直到获得最终分区。</em> <br><br> 要像这样使用分区，我们需要在创建索引时明确指定运算符类<strong>“ kd_point_ops”</strong> 。 <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> points_kd_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> spgist(p kd_point_ops);</code> </pre><br> 该类包含与“默认”类“ quad_point_ops”完全相同的运算符。 <br><br><h3> 内部构造 </h3><br> 在浏览树结构时，我们需要考虑到在这种情况下，前缀只是一个坐标而不是一个点： <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> tid, n, <span class="hljs-keyword"><span class="hljs-keyword">level</span></span>, tid_ptr, prefix, leaf_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> spgist_print(<span class="hljs-string"><span class="hljs-string">'airports_coordinates_kd_idx'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> t( tid tid, allthesame <span class="hljs-type"><span class="hljs-type">bool</span></span>, n <span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>, tid_ptr tid, prefix <span class="hljs-type"><span class="hljs-type">float</span></span>, <span class="hljs-comment"><span class="hljs-comment">-- prefix type node_label int, -- label type (unused here) leaf_value point -- list node type ) order by tid, n;</span></span></code> </pre><pre> <code class="plaintext hljs"> tid | n | level | tid_ptr | prefix | leaf_value ---------+---+-------+---------+------------+------------------ (1,1) | 0 | 1 | (5,1) | 53.740 | (1,1) | 1 | 1 | (5,4) | 53.740 | (3,113) | | 6 | | | (-7.277,62.064) (3,114) | | 6 | | | (-85.033,73.006) (5,1) | 0 | 2 | (5,12) | -65.449 | (5,1) | 1 | 2 | (5,2) | -65.449 | (5,2) | 0 | 3 | (5,6) | 35.624 | (5,2) | 1 | 3 | (5,3) | 35.624 | ...</code> </pre><br><h2> 示例：基数树 </h2><br> 我们还可以使用SP-GiST为字符串实现基数树。 基数树的想法是要索引的字符串没有完全存储在叶节点中，而是通过将存储在该节点上方的节点中的值连接到根来获得的。 <br><br> 假设，我们需要索引站点URL：“ postgrespro.ru”，“ postgrespro.com”，“ postgresql.org”和“ planet.postgresql.org”。 <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> sites(url <span class="hljs-type"><span class="hljs-type">text</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> sites <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'postgrespro.ru'</span></span>),(<span class="hljs-string"><span class="hljs-string">'postgrespro.com'</span></span>),(<span class="hljs-string"><span class="hljs-string">'postgresql.org'</span></span>),(<span class="hljs-string"><span class="hljs-string">'planet.postgresql.org'</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> sites <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> spgist(url);</code> </pre><br> 该树将如下所示： <br><br><img src="https://habrastorage.org/web/6dd/626/8d2/6dd6268d2c304e98a78609a6bad997e1.png"><br><br> 树的内部节点存储所有子节点共有的前缀。 例如，在“ stgres”的子节点中，值以“ p” +“ o” +“ stgres”开头。 <br><br> 与四叉树不同，指向子节点的每个指针都另外用一个字符标记（更确切地说，用两个字节标记，但这并不重要）。 <br><br>  “ Text_ops”运算符类支持B树形运算符：“ equal”，“ greater”和“ less”： <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname = <span class="hljs-string"><span class="hljs-string">'text_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'spgist'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> amopopr | amopstrategy -----------------+-------------- ~&lt;~(text,text) | 1 ~&lt;=~(text,text) | 2 =(text,text) | 3 ~&gt;=~(text,text) | 4 ~&gt;~(text,text) | 5 &lt;(text,text) | 11 &lt;=(text,text) | 12 &gt;=(text,text) | 14 &gt;(text,text) | 15 (9 rows)</code> </pre><br> 带波浪号的运算符的区别在于，它们操作<em>字节</em>而不是<em>字符</em> 。 <br><br> 有时，以基数树的形式表示的结果可能会比B树要紧凑得多，因为这些值没有完全存储，而是随着在树中下降时的需要而重建的。 <br><br> 考虑一个查询： <code>select * from sites where url like 'postgresp%ru'</code> 。 可以使用索引执行： <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sites <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> url <span class="hljs-keyword"><span class="hljs-keyword">like</span></span> <span class="hljs-string"><span class="hljs-string">'postgresp%ru'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------------------------ Index Only Scan using sites_url_idx on sites Index Cond: ((url ~&gt;=~ 'postgresp'::text) AND (url ~&lt;~ 'postgresq'::text)) Filter: (url ~~ 'postgresp%ru'::text) (3 rows)</code> </pre><br> 实际上，索引用于查找大于或等于“ postgresp”但小于“ postgresq”的值（索引条件），然后从结果中选择匹配的值（过滤器）。 <br><br> 首先，一致性函数必须确定我们需要下降到“ p”根的哪些子节点。 有两个选项：“ p” +“ l”（无需下降，即使不深入潜水也很清楚）和“ p” +“ o” +“ stgres”（继续下降）。 <br><br> 对于“ stgres”节点，再次需要调用一致性函数以​​检查“ postgres” +“ p” +“ ro”。  （继续下降）和“ postgres” +“ q”（无需下降）。 <br><br> 为“ ro”。 节点及其所有子叶节点，一致性函数将响应“是”，因此index方法将返回两个值：“ postgrespro.com”和“ postgrespro.ru”。 在过滤阶段将选择一个匹配值。 <br><br><img src="https://habrastorage.org/web/cec/aec/23c/cecaec23c932448098cdd360e60d3c5c.png"><br><br><h3> 内部构造 </h3><br> 在浏览树结构时，我们需要考虑数据类型： <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> spgist_print(<span class="hljs-string"><span class="hljs-string">'sites_url_idx'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> t( tid tid, allthesame <span class="hljs-type"><span class="hljs-type">bool</span></span>, n <span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>, tid_ptr tid, prefix <span class="hljs-type"><span class="hljs-type">text</span></span>, <span class="hljs-comment"><span class="hljs-comment">-- prefix type node_label smallint, -- label type leaf_value text -- leaf node type ) order by tid, n;</span></span></code> </pre><br><h2> 物产 </h2><br> 让我们看一下SP-GiST访问方法的属性（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">先前提供了</a>查询）： <br><br><pre> <code class="plaintext hljs"> amname | name | pg_indexam_has_property --------+---------------+------------------------- spgist | can_order | f spgist | can_unique | f spgist | can_multi_col | f spgist | can_exclude | t</code> </pre><br>  SP-GiST索引不能用于排序和支持唯一性约束。 此外，不能在几列上创建类似这样的索引（与GiST不同）。 但是允许使用此类索引来支持排除约束。 <br><br> 以下索引层属性可用： <br><br><pre> <code class="plaintext hljs"> name | pg_index_has_property ---------------+----------------------- clusterable | f index_scan | t bitmap_scan | t backward_scan | f</code> </pre><br> 与GiST的区别在于，不可能进行聚类。 <br><br> 最终，以下是列层属性： <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ asc | f desc | f nulls_first | f nulls_last | f orderable | f distance_orderable | f returnable | t search_array | f search_nulls | t</code> </pre><br> 不支持排序，这是可以预测的。 到目前为止，SP-GiST中不提供用于搜索最近邻居的距离运算符。 很有可能将来会支持此功能。 <br><blockquote>  Nikita Glukhov将在即将发布的PostgreSQL 12中对它进行支持。 <br></blockquote><br>  SP-GiST可用于仅索引扫描，至少用于所讨论的操作符类。 如我们所见，在某些情况下，索引值显式存储在叶节点中，而在另一些情况下，索引值在树下降过程中被部分地重建。 <br><br><h3> 空值 </h3><br> 为了使图片复杂化，到目前为止，我们还没有提到NULL。 从索引属性可以明显看出，它支持NULL。 真的： <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sites <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> url <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------- Index Only Scan using sites_url_idx on sites Index Cond: (url IS NULL) (2 rows)</code> </pre><br> 但是，对于SP-GiST，NULL是陌生的。  “ spgist”运算符类中的所有运算符都必须严格：每当运算符的任何参数为NULL时，运算符都必须返回NULL。 该方法本身确保了这一点：NULL仅不传递给运算符。 <br><br> 但是要将访问方法用于仅索引扫描，无论如何都必须将NULL存储在索引中。 它们被存储，但是存储在具有其自身根的单独树中。 <br><br><h2> 其他数据类型 </h2><br> 除了字符串的点和基数树以外，还基于PostgreSQL实现了其他基于SP-GiST的方法： <br><br><ul><li>  Box_ops运算符类为矩形提供四叉树。 <br> 每个<em>矩形</em>都由<em>一个四维空间中的一个点</em>表示，因此，象限数等于16。当矩形的交点很多时，这样的索引在性能上可以击败GiST：在GiST中，无法绘制边界从而使相交的对象彼此分离，而点（甚至是四维）不存在此类问题。 <br></li><li>  “ Range_ops”运算符类提供间隔的四叉树。 <br>  <em>间隔</em>由<em>二维点表示</em> ：下边界为横坐标，上边界为纵坐标。 <br></li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">继续阅读</a> 。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN446624/">https://habr.com/ru/post/zh-CN446624/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN446612/index.html">我们开始相信创新的那一刻</a></li>
<li><a href="../zh-CN446614/index.html">Linux虚拟文件系统：为什么需要它们，以及它们如何工作？ 第一部分</a></li>
<li><a href="../zh-CN446616/index.html">我们如何在Kubernetes中制作云FaaS并在Tinkoff Hackathon上获胜</a></li>
<li><a href="../zh-CN446620/index.html">DataGrip 2019.1：支持新数据库，初始化脚本，新检查等</a></li>
<li><a href="../zh-CN446622/index.html">11时新闻</a></li>
<li><a href="../zh-CN446626/index.html">卡巴斯基手机技术讲座1。 多重模块化</a></li>
<li><a href="../zh-CN446628/index.html">提供更多HighLoad ++：从星期一开始在圣彼得堡</a></li>
<li><a href="../zh-CN446630/index.html">如何选择3D打印机，或者为什么需要加热台和封闭的相机</a></li>
<li><a href="../zh-CN446632/index.html">从法律到大数据开发</a></li>
<li><a href="../zh-CN446634/index.html">SDN文摘-六个开源仿真器</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>