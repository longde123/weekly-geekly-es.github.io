<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ•¢ ğŸ™‡ğŸ½ ğŸ‘¨ğŸ»â€ğŸ­ Istio Circuit Breaker: Putuskan Kontainer Rusak ğŸˆ ğŸ¥… ğŸ‘©ğŸ½â€ğŸ³</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Liburan telah berakhir dan kami kembali dengan pos kedua kami di seri Istio Service Mesh. 



 Topik hari ini adalah Circuit Breaker, yang, yang diter...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Istio Circuit Breaker: Putuskan Kontainer Rusak</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/483262/">  Liburan telah berakhir dan kami kembali dengan pos kedua kami di seri Istio Service Mesh. <br><br><img src="https://habrastorage.org/webt/vb/9o/rl/vb9orlnb9lwiilx0aknfy1ikqs0.png" width="100%"><br><br>  Topik hari ini adalah Circuit Breaker, yang, yang diterjemahkan ke dalam bahasa Rusia sebagai electrotechnical, berarti "circuit breaker", bahasa sehari-hari - "circuit breaker".  Hanya di Istio mesin ini tidak memutus sirkuit yang korsleting atau kelebihan beban, tetapi kontainer yang rusak. <br><a name="habracut"></a><br><h3>  Bagaimana cara kerjanya idealnya </h3><br>  Ketika layanan microsoft dikelola oleh Kubernetes, misalnya, sebagai bagian dari platform OpenShift, mereka secara otomatis naik turun tergantung pada beban.  Karena layanan microser berfungsi dalam pod, mungkin ada beberapa layanan microser kemas di satu titik akhir, dan Kubernetes akan merutekan permintaan dan menyeimbangkan beban di antara mereka.  Dan - idealnya - semua ini harus bekerja dengan sempurna. <br><br>  Kami ingat bahwa layanan microser kecil dan fana.  Ephemerality, yang di sini berarti kesederhanaan dari kemunculan dan penghilangan, sering diremehkan.  Kelahiran dan kematian instance microservice berikutnya dalam pod cukup diharapkan, OpenShift dan Kubernetes melakukannya dengan baik, dan semuanya bekerja dengan baik - tetapi sekali lagi secara teori. <br><br><h3>  Bagaimana cara kerjanya? </h3><br>  Sekarang bayangkan bahwa contoh khusus dari layanan-mikro, yaitu wadah, telah menjadi tidak dapat digunakan: ia tidak merespons (kesalahan 503) atau, yang lebih tidak menyenangkan, bereaksi, tetapi terlalu lambat.  Dengan kata lain, ini membisukan atau tidak menanggapi permintaan, tetapi tidak secara otomatis menghapusnya dari kumpulan.  Apa yang harus dilakukan dalam kasus ini?  Coba lagi?  Hapus dari skema perutean?  Dan apa artinya "terlalu lambat" - berapa jumlahnya, dan siapa yang menentukannya?  Mungkin hanya memberinya istirahat dan coba lagi nanti?  Jika demikian, berapa lama kemudian? <br><br><h3>  Apa itu Pool Ejection di Istio </h3><br>  Dan di sini Istio datang untuk menyelamatkan dengan pemutus sirkuit Pemutus Sirkuitnya, yang untuk sementara menghapus wadah yang rusak dari kumpulan sumber daya perutean dan penyeimbangan muatan, menerapkan prosedur Ejeksi Pool. <br><br>  Menggunakan strategi deteksi outlier, Istio mendeteksi kurva pod yang terlempar dari baris umum dan menghapusnya dari kumpulan sumber daya untuk waktu tertentu, yang disebut "jendela tidur". <br><br>  Untuk menunjukkan bagaimana ini bekerja di Kubernetes pada platform OpenShift, kita mulai dengan tangkapan layar dari layanan microser yang biasanya berfungsi dari contoh di repositori <a href="https://github.com/redhat-developer-demos/istio-tutorial">Red Hat Developer Demos</a> .  Di sini kita memiliki dua pod, v1 dan v2, di mana masing-masing satu wadah berfungsi.  Ketika aturan perutean Istio tidak digunakan, Kubernetes secara default menerapkan perutean round-robin yang seimbang: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bh/b0/dr/bhb0drqlbvo9j0ataogejcgpwue.png"></div><br><h3>  Bersiap untuk kecelakaan </h3><br>  Sebelum melakukan Pool Ejection, Anda harus membuat aturan perutean Istio.  Misalkan kita ingin mendistribusikan permintaan antar pod sehubungan dengan 50/50.  Selain itu, kami akan menambah jumlah wadah v2 dari satu menjadi dua, seperti ini: <br><br><pre><code class="plaintext hljs">oc scale deployment recommendation-v2 --replicas=2 -n tutorial</code> </pre> <br>  Sekarang kami menetapkan aturan perutean sehingga lalu lintas didistribusikan di antara pod dalam rasio 50/50. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/w2/51/pz/w251pzvoaokm49bpul5ehfwsewm.png"></div><br>  Dan ini adalah hasil dari aturan ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wy/22/ww/wy22wwbkg2vync-id4jbhv22ftk.png"></div><br>  Mungkin mengeluh bahwa pada layar ini bukan 50/50, tetapi 14: 9, tetapi seiring waktu situasinya akan membaik. <br><br><h3>  Kami mengatur kegagalan </h3><br>  Dan sekarang kita akan menonaktifkan salah satu dari dua wadah v2 sehingga kita memiliki satu wadah sehat v1, satu wadah sehat v2 dan satu wadah gagal v2: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/or/0x/w1/or0xw1jvinlrjkmz3lnttvdh0zo.png"></div><br><h3>  Perbaiki kecelakaan itu </h3><br>  Jadi, kami memiliki wadah yang salah, dan sekarang saatnya untuk Pool Ejection.  Menggunakan konfigurasi yang sangat sederhana, kami akan mengecualikan wadah yang gagal ini dari skema perutean apa pun selama 15 detik dengan harapan akan kembali ke kondisi sehat (apakah akan memulai ulang, atau akan mengembalikan kinerja).  Inilah konfigurasi ini dan hasil dari kerjanya: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xz/6u/7e/xz6u7emeucpeqn6ozq7rnsibtxy.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yk/m6/3t/ykm63tdppq-qphkyhikilfcwkai.png"></div><br>  Seperti yang Anda lihat, wadah yang gagal v2 tidak lagi digunakan saat merutekan permintaan, karena telah dihapus dari kumpulan.  Tetapi setelah 15 detik itu akan secara otomatis kembali ke kolam.  Sebenarnya, kami hanya menunjukkan cara kerja Pool Ejection. <br><br><h3>  Mulai membangun arsitektur </h3><br>  Pool Ejection, dikombinasikan dengan kemampuan pemantauan Istio, memungkinkan Anda untuk mulai membangun kerangka kerja untuk mengganti wadah yang rusak secara otomatis untuk mengurangi, atau bahkan menghilangkan downtime dan crash. <br><br>  NASA memiliki satu moto profil tinggi - Kegagalan Bukan Opsi, yang ditulis oleh direktur penerbangan <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D1%2580%25D0%25B0%25D0%25BD%25D1%2586,_%25D0%2594%25D0%25B6%25D0%25B8%25D0%25BD">Gene Krantz</a> .  Ini dapat diterjemahkan ke dalam bahasa Rusia sebagai "Kekalahan bukanlah suatu pilihan", dan intinya di sini adalah bahwa semuanya dapat dibuat untuk bekerja dengan kemauan yang cukup.  Namun, dalam kehidupan nyata, kegagalan tidak hanya terjadi, mereka tidak bisa dihindari, di mana-mana dan dalam segala hal.  Dan bagaimana cara mengatasinya dalam kasus layanan mikro?  Menurut pendapat kami, lebih baik untuk tidak mengandalkan tekad, tetapi pada kemampuan kontainer, <a href="https://developers.redhat.com/topics/kubernetes/">Kubernetes</a> , <a href="https://developers.redhat.com/products/openshift/overview/">Red Hat OpenShift</a> , dan <a href="https://developers.redhat.com/topics/service-mesh/">Istio</a> . <br><br>  Istio, seperti yang kami tulis di atas, mengimplementasikan konsep pemutus sirkuit, yang telah membuktikan dirinya di dunia fisik.  Dan seperti halnya mesin otomatis memutuskan bagian masalah dari suatu rangkaian, perangkat lunak Circuit Breaker di Istio memutus koneksi antara aliran permintaan dan wadah masalah ketika ada sesuatu yang salah dengan titik akhir, misalnya, ketika server crash atau mulai melambat. <br><br>  Selain itu, dalam kasus kedua hanya ada lebih banyak masalah, karena rem satu kontainer tidak hanya menyebabkan kaskade keterlambatan dalam layanan mengaksesnya dan, sebagai hasilnya, mengurangi kinerja sistem secara keseluruhan, tetapi juga menghasilkan permintaan berulang untuk layanan yang sudah berjalan lambat, yang hanya memperburuk situasi . <br><br><h3>  Pemutus sirkuit secara teori </h3><br>  Circuit Breaker adalah proksi yang mengontrol aliran permintaan ke titik akhir.  Ketika titik ini berhenti bekerja atau, tergantung pada pengaturannya, ia mulai melambat, proxy terputus dari wadah.  Lalu lintas dialihkan ke kontainer lain, well, hanya karena penyeimbangan muatan.  Sambungan tetap terbuka (terbuka) untuk jendela tidur yang diberikan, katakanlah, dua menit, dan kemudian dianggap setengah terbuka (setengah terbuka).  Mencoba mengirim permintaan berikutnya menentukan keadaan komunikasi selanjutnya.  Jika semuanya baik-baik saja dengan layanan, koneksi kembali ke keadaan operasional dan kembali menjadi tertutup.  Jika masih ada yang salah dengan layanan, koneksi terbuka dan jendela tidur diaktifkan kembali.  Berikut tampilan diagram keadaan Pemutus Sirkuit yang disederhanakan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qg/0g/z4/qg0gz47wjymiayq4bgshfsrceyy.png"></div><br>  Penting untuk dicatat di sini bahwa semua ini terjadi pada tingkat arsitektur sistem.  Oleh karena itu, pada titik tertentu Anda harus mengajarkan aplikasi Anda untuk bekerja dengan Circuit Breaker, misalnya, memberikan nilai default sebagai respons atau, jika mungkin, mengabaikan keberadaan layanan.  Pola sekat digunakan untuk ini, tetapi di luar cakupan artikel ini. <br><br><h3>  Circuit Breaker dalam praktek </h3><br>  Sebagai contoh, kami akan meluncurkan pada OpenShift dua versi dari microservice rekomendasi kami.  Versi 1 akan berfungsi dengan baik, tetapi dalam v2 kita akan membangun penundaan untuk mensimulasikan rem di server.  Untuk melihat hasilnya, gunakan alat <a href="https://github.com/JoeDog/siege">pengepungan</a> : <br><br><pre> <code class="plaintext hljs">siege -r 2 -c 20 -v customer-tutorial.$(minishift ip).nip.io</code> </pre><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kn/qa/e_/knqae_n13cpibc7tc9lk7fc5lqq.png"></div><br>  Segalanya tampak bekerja, tetapi berapa biayanya?  Sekilas, kami memiliki ketersediaan 100%, tetapi perhatikan lebih dekat - durasi transaksi maksimum adalah 12 detik.  Ini jelas merupakan hambatan dan perlu disulam. <br><br>  Untuk melakukan ini, kami akan menggunakan Istio untuk menghilangkan akses ke wadah lambat.  Inilah yang terlihat seperti konfigurasi yang sesuai dengan menggunakan Circuit Breaker: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/eh/ld/f4/ehldf4gh5qxkwqckn3naufhfs2a.png"></div><br>  Baris terakhir dengan parameter httpMaxRequestsPerConnection memberi sinyal bahwa koneksi harus terbuka ketika mencoba membuat satu lagi - koneksi kedua - selain yang sudah ada.  Karena wadah kami meniru layanan pengereman, situasi seperti itu akan terjadi secara berkala, dan kemudian Istio akan mengembalikan kesalahan 503, dan inilah yang akan ditampilkan pengepungan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vv/9h/g5/vv9hg56bzoliqjb6tay19as6mn0.png"></div><br><h3>  OK, kita punya Circuit Breaker, apa selanjutnya? </h3><br>  Jadi, kami menerapkan shutdown otomatis, tanpa menyentuh kode sumber layanan itu sendiri.  Menggunakan prosedur Circuit Breaker dan Pool Ejection yang dijelaskan di atas, kita dapat menghapus wadah rem dari sumber daya sampai mereka kembali normal, dan memeriksa statusnya pada frekuensi yang diberikan - dalam contoh kita, ini adalah dua menit (parameter sleepWindow). <br><br>  Harap dicatat bahwa kemampuan aplikasi untuk merespons kesalahan 503 masih ditetapkan pada level kode sumbernya.  Ada banyak strategi untuk bekerja dengan Circuit Breaker, yang diterapkan tergantung pada situasinya. <br><br>  <b>Dalam posting selanjutnya: kita</b> akan berbicara tentang penelusuran dan pemantauan, yang sudah ada atau ditambahkan dengan mudah ke Istio, serta cara memasukkan kesalahan ke dalam sistem dengan sengaja. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id483262/">https://habr.com/ru/post/id483262/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id483252/index.html">Maximalisme muda dan semangat kontradiksi pada remaja dari sudut pandang neurologi</a></li>
<li><a href="../id483254/index.html">Di Balik Layar Kehidupan Moderator Stack Overflow</a></li>
<li><a href="../id483256/index.html">Kompilasi fakta statistik yang menghibur # 3</a></li>
<li><a href="../id483258/index.html">Platform kode rendah: obat mujarab atau taruhan berisiko?</a></li>
<li><a href="../id483260/index.html">Cara membuat keputusan dan memprioritaskan tugas saat membuat produk</a></li>
<li><a href="../id483264/index.html">Dijkstra: Kemenangan terbesar Barat dalam Perang Dingin atas Uni Soviet adalah transisi ke IBM - mitos pecah</a></li>
<li><a href="../id483266/index.html">Kemandirian finansial. Apa yang telah berubah sepanjang tahun</a></li>
<li><a href="../id483268/index.html">Buku "Mode, Iman, Fantasi, dan Fisika Baru Semesta"</a></li>
<li><a href="../id483270/index.html">Evolusi aplikasi HighLoad pada contoh portal regional layanan publik</a></li>
<li><a href="../id483272/index.html">Jalannya dari bisnis restoran ke perusahaan IT</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>