<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∑üèª üë¶üèΩ üê™ Pr√°ctica de decodificaci√≥n de hardware FFmpeg DXVA2 üßëüèø‚Äçü§ù‚ÄçüßëüèΩ ü§∑üèª üòÖ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Este art√≠culo es una continuaci√≥n de mi art√≠culo de FFmpeg que comienza con Visual Studio. Aqu√≠ llegamos a la decodificaci√≥n de hardware de la tr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pr√°ctica de decodificaci√≥n de hardware FFmpeg DXVA2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461735/">  Hola  Este art√≠culo es una continuaci√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mi art√≠culo de FFmpeg que comienza con Visual Studio.</a>  Aqu√≠ llegamos a la decodificaci√≥n de hardware de la transmisi√≥n FULL HD RTSP.  Dir√© de antemano que incluso el Intel ATOM Z8350 puede hacer frente f√°cilmente a esta tarea. <br><br>  <b>Tarea:</b> decodificaci√≥n de hardware y grabaci√≥n de hasta 4 cuadros en RAM para el procesamiento paralelo posterior (cuatro n√∫cleos de procesador) desde una c√°mara RTSP h.264 IP.  Muestro los marcos procesados ‚Äã‚Äãusando las funciones WinAPI.  Como resultado, obtenemos un sistema de alta velocidad para el procesamiento por computadora del flujo RTSP en modo paralelo.  A continuaci√≥n, puede conectar los algoritmos de <b>visi√≥n</b> por <b>computadora</b> para procesar marcos en <b>tiempo real</b> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wd/bc/j2/wdbcj2te4ze6ezmd1_ap8lhxtv4.png" alt="imagen"></div><br><h4>  Entrada </h4><br>  ¬øPor qu√© necesito decodificaci√≥n de hardware?  Desea decodificar video en tiempo real con un procesador d√©bil y barato o desea descargar el procesador tanto como sea posible, entonces es hora de familiarizarse con la decodificaci√≥n de hardware. <br><br>  <b>DirectX Video Acceleration</b> (DXVA) es una API para usar la aceleraci√≥n de hardware para acelerar el procesamiento de video con GPU.  DXVA 2.0 le permite redirigir m√°s operaciones a la GPU, incluidas las operaciones de captura y procesamiento de video. <br><a name="habracut"></a><br>  Despu√©s de escribir el art√≠culo anterior, me hicieron algunas preguntas: "¬øpor qu√© se usa FFmpeg?"  Comenzar√© con los problemas.  La principal dificultad de la decodificaci√≥n de hardware es escribir el marco decodificado en la RAM.  Para Full HD, esto es 1920 x 1080 x 3 = 6.220.800 bytes.  Incluso teniendo en cuenta el hecho de que la trama se almacena en el formato NV12, esto tambi√©n es mucho de 1920 x 1080 x 1.5 = 3110400 bytes.  Sobrescribir 75 MB por segundo es una tarea seria para cualquier procesador.  Para resolver este problema, Intel ha agregado comandos SSE 4, que le permiten reescribir datos sin un procesador.  Desafortunadamente, no todas las bibliotecas tienen esto implementado.  He probado las siguientes bibliotecas: <br><br><ol><li>  Ffmpeg </li><li>  VLC </li><li>  OpenCV </li></ol><br>  <b>VLC</b> : funciona con c√°maras IP a trav√©s de la decodificaci√≥n de hardware (carga de procesador muy baja), se puede construir un reproductor de flujo RTSP primitivo en solo 10 l√≠neas de c√≥digo, pero recibir marcos decodificados en RAM requiere demasiado tiempo de procesador. <br><br>  <b>OpenCV</b> - RTSP usa FFmpeg para trabajar con la transmisi√≥n, por lo que se decidi√≥ trabajar sin intermediarios, es decir  usa la biblioteca FFmpeg.  Adem√°s, FFmpeg, que se instala por defecto, est√° integrado en OpenCV sin decodificaci√≥n de hardware. <br><br>  <b>FFmpeg</b> - mostr√≥ buenos resultados, en mi opini√≥n, funciona de manera estable.  El √∫nico inconveniente no se implementa al trabajar con c√°maras WEB para la versi√≥n X86 (X64 parece permitirle trabajar) en Windows. <br><br><h2>  La decodificaci√≥n de video por hardware es f√°cil </h2><br>  De hecho, la decodificaci√≥n de hardware utilizando la biblioteca FFmpeg no es m√°s complicada que el software.  La configuraci√≥n del proyecto es la misma que para la implementaci√≥n del software, el diagrama de bloques se mantuvo sin cambios. <br><br>  Puede mostrar una lista de m√©todos de decodificaci√≥n de hardware compatibles con FFmpeg. <br><br><pre><code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">" %s"</span></span>, av_hwdevice_get_type_name(type));</code> </pre> <br>  Lo primero que debemos hacer es decirle a FFmpeg con qu√© decodificador de hardware desea decodificar el video.  En mi caso, Windows10 + Intel Atom Z8350 solo deja DXVA2: <br><br><pre> <code class="cpp hljs">type = av_hwdevice_find_type_by_name(<span class="hljs-string"><span class="hljs-string">"dxva2"</span></span>);</code> </pre> <br>  Puede elegir CUDA, D3D11VA, QSV o VAAPI (solo Linux) como decodificador de hardware.  En consecuencia, debe tener esta soluci√≥n de hardware y FFmpeg debe construirse con su soporte. <br><cut></cut><br>  Abre la transmisi√≥n de video: <br><br><pre> <code class="cpp hljs">avformat_open_input(&amp;input_ctx, filename, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>;</code> </pre> <br>  Obtenemos informaci√≥n sobre la transmisi√≥n de video: <br><br><pre> <code class="cpp hljs">av_find_best_stream(input_ctx, AVMEDIA_TYPE_VIDEO, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, &amp;decoder, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Asignar memoria: <br><br><pre> <code class="cpp hljs">frame = av_frame_alloc(); <span class="hljs-comment"><span class="hljs-comment">//       sw_frame = av_frame_alloc(); //       </span></span></code> </pre> <br>  Esta funci√≥n sobrescribe el archivo decodificado en RAM: <br><br><pre> <code class="cpp hljs">av_hwframe_transfer_data(sw_frame, frame, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><h3>  Un poco sobre el formato NV12 </h3><br>  Entonces, tenemos un marco en la estructura sw_frame.  El marco recibido se almacena en formato NV12.  Este formato fue inventado por Microsoft.  Le permite almacenar informaci√≥n de p√≠xeles en 12 bits.  Donde 8 bits es la intensidad y 4 bits describen el color (o m√°s bien, el color se describe inmediatamente para 4 p√≠xeles adyacentes de 2x2).  Adem√°s, sw_frame.data [0]: la intensidad se almacena y en sw_frame.data [1] se almacena el color.  Para convertir de NV-12 a RGB, puede usar la siguiente funci√≥n: <br><cut></cut><br><div class="spoiler">  <b class="spoiler_title">Traducci√≥n de C ++ de NV12 a RGB</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SaveFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * f1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * f2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> iFrame)</span></span></span><span class="hljs-function"> </span></span>{ FILE *pFile; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> szFilename[<span class="hljs-number"><span class="hljs-number">32</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, i, j; <span class="hljs-comment"><span class="hljs-comment">// char buff[1920 * 1080 * 3]; uint8_t *buff = new uint8_t(1920*3*2); int u=0, v=0, y=0; // Open file sprintf(szFilename, "frame%d.ppm", iFrame); pFile = fopen(szFilename, "wb"); if (pFile == NULL) return; //    fprintf(pFile, "P6\n%d %d\n255\n", 1920, 1080); for (j = 0; j &lt; 1080 / 2; j++) { for (i = 0; i &lt; 1920; i +=2) { // 1  rgb y = *(f1 + j * 1920 * 2 + i); v = *(f2 + j * 1920 + i) - 128; u = *(f2 + j * 1920 + i + 1) - 128; x = round(y + 1.370705 * v); if (x &lt; 0) x = 0; if (x &gt; 255) x = 255; // if (j &gt; 34) printf("%i, ",(j * 1920 * 2 + i) * 3); buff[i * 3 + 2] = x; x = round(y - 0.698001 * v - 0.337633 * u); if (x &lt; 0) x = 0; if (x &gt; 255) x = 255; buff[i * 3 + 1] = x; x = round(y + 1.732446 * u); if (x &lt; 0) x = 0; if (x &gt; 255) x = 255; buff[i * 3] = x; // 2  rgb y = *(f1 + j * 1920 * 2 + i + 1); x = y + 1.370705 * v; if (x &lt; 0) x = 0; if (x &gt; 255) x = 255; buff[i * 3 + 5] = x; x = y - 0.698001 * v - 0.337633 * u; if (x &lt; 0) x = 0; if (x &gt; 255) x = 255; buff[i * 3 + 4] = x; x = y + 1.732446 * u; if (x &lt; 0) x = 0; if (x &gt; 255) x = 255; buff[i * 3 + 3] = x; // 3  rgb y = *(f1 + j * 1920 * 2 + 1920 + i); x = y + 1.370705 * v; if (x &lt; 0) x = 0; if (x &gt; 255) x = 255; buff[(1920 + i) * 3 + 2] = x; x = y - 0.698001 * v - 0.337633 * u; if (x &lt; 0) x = 0; if (x &gt; 255) x = 255; buff[(1920 + i) * 3 + 1] = x; x = y + 1.732446 * u; if (x &lt; 0) x = 0; if (x &gt; 255) x = 255; buff[(1920 + i) * 3 + 0] = x; // 4  rgb y = *(f1 + j * 1920 * 2 + 1920 + i + 1); x = y + 1.370705 * v; if (x &lt; 0) x = 0; if (x &gt; 255) x = 255; buff[(1920 + i) * 3 + 5] = x; x = y - 0.698001 * v - 0.337633 * u; if (x &lt; 0) x = 0; if (x &gt; 255) x = 255; buff[(1920 + i) * 3 + 4] = x; x = y + 1.732446 * u; if (x &lt; 0) x = 0; if (x &gt; 255) x = 255; buff[(1920 + i) * 3 + 3] = x; // printf("%i, ", i); } // for i fwrite(buff, 1, 1920 * 3 * 2, pFile); printf("\n %i\n", j); } // for j // printf("Save4\n"); // Write pixel data // fwrite(buff, 1, 1920*1080*3, pFile); // Close file printf("close\n"); fclose(pFile); printf("exit\n"); delete buff; // return; }</span></span></code> </pre><br></div></div><br>  Aunque trabajar con NV12 le permite acelerar la implementaci√≥n de procedimientos como el desenfoque, Retinex y la obtenci√≥n de im√°genes en escala de grises (simplemente descartando el color).  En mis tareas, no traduzco el formato NV12 a RGB, ya que esto lleva m√°s tiempo. <br><br>  Y as√≠ aprendimos a decodificar archivos de video en hardware y mostrarlos en una ventana.  Nos reunimos en formato NV12 y c√≥mo convertirlo a RGB familiar. <br><br><h3>  Dll decodificaci√≥n de hardware </h3><br>  FFmpeg emite cuadros despu√©s de 40 ms (a 25 cuadros por segundo).  Como regla general, el procesamiento de un cuadro Full HD lleva mucho m√°s tiempo.  Esto requiere subprocesos m√∫ltiples para maximizar la carga de los 4 n√∫cleos de procesador.  En la pr√°ctica, comienzo 6 hilos una vez y ya no los elimino, lo que simplifica enormemente el trabajo y aumenta la fiabilidad del programa.  El esquema de operaci√≥n se muestra en la Fig.  1 <br><br><img src="https://habrastorage.org/webt/zy/pd/27/zypd27dsdmasmsc6g2yeyy3u8iu.png" alt="imagen"><br>  <i>Fig. 1 Esquema de construcci√≥n de un programa multiproceso con FFmpeg</i> <br><br>  Escrib√≠ mi decodificador como <b>* .dll</b> (FFmpegD.DLL) para incluirlo en mis proyectos.  Esto le permite reducir el c√≥digo del proyecto, lo que aumenta la comprensi√≥n del c√≥digo e incluirlo en cualquier lenguaje de programaci√≥n, hasta Assembler (verificado :)).  Utiliz√°ndolo, escribiremos nuestro reproductor de transmisi√≥n RTSP desde la c√°mara IP. <br><br>  Para comenzar a trabajar con una DLL, debe pasar un puntero a una matriz int [13], una MANIJA de un nuevo evento de llegada de cuadros, una MANIJA para comenzar a procesar un nuevo paquete de datos desde la c√°mara y un car√°cter de matriz de la c√°mara. <br><br>  La estructura de la matriz se da en la tabla 1. <br><br><img src="https://habrastorage.org/webt/ds/g7/mq/dsg7mqh4ioarsp5mi9uio98k-yi.png" alt="imagen"><br><br>  Antes de llamar, debe restablecer los n√∫meros de trama 1-4. <br><br>  La DLL tomar√° todos los pasos necesarios para inicializar FFmpeg y registrar√° punteros y n√∫meros de cuadros.  Despu√©s establece el evento "Nueva llegada de trama".  Solo es necesario procesar las tramas entrantes y escribir 0 en lugar del n√∫mero de trama (esto significa que la trama se ha procesado y ya no se usa). <br><br>  A continuaci√≥n encontrar√° un reproductor de ejemplo con c√≥digo fuente.  El ejemplo es ShowDib3 Charles Petzold. <br><br>  ‚Üí <a href="">Archivo con el proyecto</a> <br>  ‚Üí <a href="">Archivo FFmpegD.dll</a> <br><br>  <b>RESULTADOS: el</b> detector de movimiento de hardware FFmpeg incluso en Intel Atom Z8350 decodifica h264 Full HD en tiempo real con hasta un 20% de carga del procesador con detector de movimiento conectado. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/2I1hL9g8LqY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Ejemplo de funcionamiento del detector de movimiento en Intel ATOM Z8350.</i>  <i>Los primeros 30 segundos son el c√°lculo del fondo.</i>  <i>Despu√©s de eso, el detector de movimiento funciona por el m√©todo de restar el fondo.</i> <br><br>  <b>PD: ¬°</b> Tambi√©n puedes decodificar archivos de video (comprimido h.264)! <br><br>  Referencias <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Informaci√≥n √∫til diversa sobre FFmpeg</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Informaci√≥n sobre el uso de las diversas bibliotecas proporcionadas por FFmpeg</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Informaci√≥n sobre formatos y conversi√≥n a RGB</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/461735/">https://habr.com/ru/post/461735/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../461725/index.html">DataGrip 2019.2: gesti√≥n de conexiones, b√∫squeda de datos, filtrado en navegaci√≥n</a></li>
<li><a href="../461727/index.html">Soluciones Cisco Small Business: una buena red no es necesariamente costosa</a></li>
<li><a href="../461729/index.html">Uso de jailbreak para extraer datos: riesgos y consecuencias</a></li>
<li><a href="../461731/index.html">DPKI: abordando las desventajas de la PKI centralizada mediante blockchain</a></li>
<li><a href="../461733/index.html">Aprendiendo ingl√©s: 9 modismos de estilo americano</a></li>
<li><a href="../461737/index.html">Recopilamos el entorno para TDD moderno en c√≥digo JavaScript + VS</a></li>
<li><a href="../461739/index.html">Backend United 4: Okroshka. Incidentes</a></li>
<li><a href="../461741/index.html">Agrupaci√≥n jer√°rquica de datos categ√≥ricos en R</a></li>
<li><a href="../461743/index.html">Semana de la seguridad 31: vulnerabilidad VLC y tel√©fono roto</a></li>
<li><a href="../461745/index.html">DeviceLock DLP: precios del mercado negro ruso por romper datos personales (m√°s una respuesta a la respuesta de Tinkoff Bank)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>