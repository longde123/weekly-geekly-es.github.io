<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🤝‍👨🏾 👨🏻‍🔬 🏻 Programmation fonctionnelle du point de vue d'EcmaScript. Récursivité et ses types 👰🏿 🧕🏿 🔞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! 

 Aujourd'hui, nous poursuivons nos recherches sur la programmation fonctionnelle dans le contexte d'EcmaScript, dont la spécification...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Programmation fonctionnelle du point de vue d'EcmaScript. Récursivité et ses types</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480520/">  Bonjour, Habr! <br><br>  Aujourd'hui, nous poursuivons nos recherches sur la programmation fonctionnelle dans le contexte d'EcmaScript, dont la spécification est basée sur JavaScript.  Dans les articles précédents du cycle, les sujets suivants ont été examinés: <br><br><ol><li>  <a href="https://habr.com/ru/post/474702/">Fonctions pures, lambdas, immunité</a> </li><li>  <a href="https://habr.com/ru/post/475324/">Composition, curry, application partielle</a> </li></ol><a name="habracut"></a><br><h2>  Récursivité </h2><br>  Comme toujours, Wikipedia nous aide à trouver une définition: <br><blockquote>  Récursivité - la définition, la description, l'image d'un objet ou d'un processus à l'intérieur de cet objet ou processus lui-même, c'est-à-dire la situation où l'objet fait partie de lui-même.  Le terme «récursivité» est utilisé dans divers domaines particuliers de la connaissance - de la linguistique à la logique, mais trouve la plus grande application en mathématiques et en informatique. </blockquote>  Pour la programmation, la récursivité se réfère aux <b>processus qui s'invoquent dans leur corps</b> .  Une fonction récursive a plusieurs composants obligatoires: <br><br><ul><li>  <b>Condition terminale</b> - condition de terminaison </li><li>  La règle qui <b>pénètre profondément dans la</b> récursivité </li></ul><br>  Prenons l'exemple le plus populaire de calcul récursif-factoriel. <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> factorial = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n === <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n * factorial(n - <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br>  Nous distinguons les composants caractéristiques d'une fonction récursive.  État des bornes <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n === <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br>  et règle de récursivité <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n * factorial(n - <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br>  Il est important de réaliser que la récursivité n'est pas une caractéristique spécifique de JS, mais une technique très courante en programmation. <br><br><h4>  Processus récursifs et itératifs </h4><br>  La récursivité peut être organisée de deux manières: par un processus récursif ou par un processus itératif. <br><br>  Nous avons déjà vu le processus récursif: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> factorial = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n === <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n * factorial(n - <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre><br>  Une solution itérative au problème factoriel ressemblerait à ceci: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> factorial = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> iter = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">counter, acc</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (counter === <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> acc; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iter(counter - <span class="hljs-number"><span class="hljs-number">1</span></span>, counter * acc); }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iter(n, <span class="hljs-number"><span class="hljs-number">1</span></span>); };</code> </pre><br>  Ces deux options sont récursives.  Les deux solutions ont des caractéristiques caractéristiques de la récursivité: la condition terminale et la règle de mouvement le long de la récursivité.  Regardons leurs différences. <br><br>  Le processus récursif à chaque étape se souvient de l'action.  qui doit être fait.  Ayant atteint les conditions thermiques, il effectue toutes les actions mémorisées dans l'ordre inverse.  Illustrons par un exemple.  Lorsque le processus récursif considère le factoriel 6, il doit se souvenir de 5 nombres afin de les compter à la toute fin, lorsque vous ne pouvez aller nulle part et que vous ne pouvez plus aller plus loin dans les profondeurs.  Lorsque nous sommes dans le prochain appel de fonction, quelque part en dehors de cet appel, ces numéros mémorisés sont stockés en mémoire. <br><br>  Cela ressemble à ceci: <br><br><pre> <code class="javascript hljs">factorial(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 6  ,    3 3 * factorial(2); 3 * 2 * factorial(1); 3 * 2 * 1; 3 * 2; 6;</span></span></code> </pre><br>  Comme vous pouvez le voir, l'idée de base d'un processus récursif est de reporter le calcul à la fin. <br>  Un tel processus génère <b>un état variant dans le temps</b> qui est stocké «quelque part» en dehors de l'appel de fonction en cours. <br><br>  Je pense que vous vous souvenez que dans le premier article de la série sur la <a href="https://habr.com/ru/post/474702/">programmation fonctionnelle,</a> nous avons parlé de l'importance de l'immunité et du manque d'état.  Avoir une condition pose de nombreux problèmes qui ne sont pas toujours faciles à gérer. <br><br>  <b>Un processus itératif</b> diffère d'un <b>processus</b> <b>récursif dans un</b> nombre fixe d'états.  À chaque étape, le processus itératif considère tout ce qu'il peut calculer, de sorte que chaque étape de la récursivité existe indépendamment de la précédente. <br><br>  Cela ressemble à ceci: <br><br><pre> <code class="javascript hljs">iter(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// iter(3 - 1, 1 * 3); // ,      6, iter(2, 3); // iter(2 - 1, 2 * 3);//   ,      3 iter(1, 6); // counter === 1, return 6 6;</span></span></code> </pre><br>  Je pense qu'il est évident qu'un processus itératif consomme moins de mémoire.  Par conséquent, vous devez toujours l'utiliser lors de la création d'une récursivité.  La seule exception: si nous ne pouvons pas calculer la valeur jusqu'à ce que la condition thermique soit atteinte. <br><br><h3>  Récursivité des arbres </h3><br>  Beaucoup de gens pensent que les arbres et travailler avec eux sont quelque chose de très abstrus, complexe et incompréhensible pour les simples mortels.  Ce n'est en fait pas le cas.  Toute structure hiérarchique peut être représentée sous la forme d'un arbre.  Même la pensée humaine est comme un arbre. <br><br>  Pour mieux comprendre la récursivité des arbres, examinons un exemple simple et populaire - les nombres de Fibonacci. <br><br><blockquote>  Nombres de Fibonacci - éléments d'une séquence numérique 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, ... (séquence A000045 dans OEIS), dans laquelle les deux premiers nombres sont soit 1 et 1, soit 0 et 1, et chaque nombre suivant est égal à la somme des deux nombres précédents.  Nommé d'après le mathématicien médiéval Leonardo de Pise (connu sous le nom de Fibonacci). </blockquote><br>  Mathématiquement, il est assez simple de formuler une description (et la programmation déclarative est la description) de cette séquence: <br><br><pre> <code class="plaintext hljs">fib(n) = [  0  n = 0,//(1)  1  n = 1,//(2) fib(n-1) + fib(n-2)     ]</code> </pre><br>  Passons maintenant des mathématiques au raisonnement logique (après tout, nous devons écrire la logique du programme).  Pour calculer fib (5), nous devons calculer fib (4) et fib (3).  Pour calculer fib (4), nous devons calculer fib (3) et fib (2).  Pour calculer fib (3), nous devons calculer fib (2) et ainsi de suite jusqu'à ce que nous arrivions aux valeurs connues (1) et (2) dans notre modèle mathématique. <br><br>  À quelles pensées notre raisonnement devrait-il nous conduire?  Évidemment, nous devons utiliser la récursivité.  La condition thermique peut être formulée comme n &lt;= 1. Cependant, au lieu d'une branche de récursivité (comme dans les exemples précédents), nous aurons deux branches: fib (n-1), fib (n-2). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fib = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">) =&gt;</span></span> (n &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> ? n : fib(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) + fib(n - <span class="hljs-number"><span class="hljs-number">2</span></span>));</code> </pre><br>  Cette solution a un inconvénient important!  Il considère le résultat de la même valeur de n plusieurs fois dans différentes branches.  Pour résoudre ce problème, il existe une technique de programmation fonctionnelle appelée <b>mémorisation</b> , dont nous parlerons dans l'un des articles suivants. <br><br><h3>  Conclusion </h3><br>  La récursivité est un outil de programmation très puissant.  Permettez-moi de vous rappeler qu'en règle générale, nous utilisons un processus itératif.  Cela vaut la peine d’utiliser un processus récursif uniquement si nous ne pouvons pas calculer le résultat intermédiaire à chaque étape de la récursivité. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr480520/">https://habr.com/ru/post/fr480520/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr480506/index.html">4. Analyse des programmes malveillants à l'aide de Check Point forensics. CloudGuard SaaS</a></li>
<li><a href="../fr480508/index.html">AI Journey: rapports et résultats des concours</a></li>
<li><a href="../fr480510/index.html">Chronique de la confrontation entre Rambler et Nginx (mise à jour le 23 décembre à 12h00)</a></li>
<li><a href="../fr480512/index.html">Chronique du groupe Rambler et confrontation avec Nginx (mise à jour le 23 décembre, 12 h)</a></li>
<li><a href="../fr480518/index.html">Tuteur de programmation: pourquoi vous devriez le devenir et comment le faire</a></li>
<li><a href="../fr480526/index.html">Les processeurs Intel crachent une clé privée, si vous jouez avec la tension</a></li>
<li><a href="../fr480528/index.html">Pourquoi Facebook vous permettra de transférer des données utilisateur vers d'autres services</a></li>
<li><a href="../fr480530/index.html">L'IoT n'est pas un jouet pour les enfants. Comment les attaques de pirates sur Internet des objets font peur non seulement aux grandes entreprises, mais aussi aux familles ordinaires</a></li>
<li><a href="../fr480532/index.html">EDA sous un angle différent</a></li>
<li><a href="../fr480534/index.html">16 conseils de développement pour Android dans Kotlin. 2e partie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>