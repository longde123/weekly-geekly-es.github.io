<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔖 🙉 🐐 Auswirkungen von SVG-Filtern. Teil 2. Gliederungstext mit feMorphology ◽️ 🛵 👩🏽‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die vorgeschlagene Artikelserie " SVG Filtering Effects " von Sara Soueidan, freiberufliche UI / UX-Schnittstellenentwicklerin und Autorin vieler im L...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Auswirkungen von SVG-Filtern. Teil 2. Gliederungstext mit feMorphology</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439722/"><p>  Die vorgeschlagene Artikelserie " <strong>SVG Filtering Effects</strong> " von Sara Soueidan, freiberufliche UI / UX-Schnittstellenentwicklerin und Autorin vieler im Libanon ansässiger technischer Artikel, konzentriert sich auf die Arbeit von SVG-Filtern und besteht aus folgenden Artikeln: </p><br><h1 id="effekty-filtracii-svg">  SVG-Filtereffekte </h1><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SVG-Filtereffekte.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1. SVG-Filter 101</a> . </li><li>  SVG-Filtereffekte.  Teil 2. Gliederungstext mit feMorphology </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SVG-Filtereffekte.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3. Der Effekt der Bildposterisierung mit feComponentTransfer</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SVG-Filtereffekte.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 4. Zweifarbige Bilder mit <strong>feComponentTransfer</strong></a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SVG-Filtereffekte.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 5. Text mit <strong>feDisplacementMap</strong> an die Oberflächentextur <strong>anpassen</strong></a> </li></ol><br><hr><br><p>  Im zweiten Teil der Serie über SVG-Filter stellt <strong>Sara Soueidan</strong> uns den <strong>feMorphology-</strong> Filter vor und gibt einige Beispiele für seine Verwendung zur Erzeugung interessanter Effekte. </p><br><p><img src="https://habrastorage.org/webt/pt/1l/yq/pt1lyq3deuk69mcyf2ax_yt9_tc.png"></p><a name="habracut"></a><br><p>  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>ersten Teil dieser Serie</strong></a> zu SVG-Filtereffekten haben wir die Grundlagen von SVG-Filtern vorgestellt - wie man sie erstellt und wie man sie verwendet.  Wir haben auch einige der am häufigsten verwendeten Filteroperationen untersucht, d.h.  Grundelemente filtern.  Weil  Wir werden diese Informationen wiederverwenden. Ich empfehle dann, diesen Artikel anzuhalten und zu lesen, bevor Sie mit diesem fortfahren. </p><br><p>  <strong>&lt;feMorphology&gt;</strong> ist eine meiner bevorzugten SVG- <strong>Filteroperationen</strong> .  Es ist auch eine der einfachsten Operationen, und die Ergebnisse seiner Anwendung auf verschiedene Elemente sind immer vorhersehbar. </p><br><h2 id="chto-takoe-morfing">  Was ist Morphing? </h2><br><p>  Morphing bedeutet, die Form oder das Erscheinungsbild eines Objekts zu transformieren oder zu ändern. </p><br><p>  Der morphologische Filter wirkt auf die Form des Objekts ein.  Es stellt zwei vordefinierte Formtransformationen bereit: Erosion (d. H. Ausdünnen oder Schrumpfen) und Ausdehnung (d. H. A. Verdicken oder Ausdehnen).  Mit anderen Worten kann das <strong>Grundelement feMorphology</strong> verwendet werden, um ein Element zu komprimieren oder zu erweitern. </p><br><p>  Technisch gesehen arbeiten beide Operationen auf Pixelebene, erweitern das Pixel auf benachbarte Pixel ( <strong>erweitern</strong> ) oder zerstören benachbarte Pixel an den Rändern des gesteuerten Pixels ( <strong>erodieren</strong> ), während der Umriss am Rand dieses Pixels beibehalten wird.  Der Wert, um den sich das Pixel ausdehnt, oder die Anzahl benachbarter Pixel, die zum "Strecken" oder "Erweitern" des Pixels verwendet werden, wird durch den <strong>Radiusparameter</strong> bestimmt. </p><br><pre><code class="plaintext hljs">&lt;feMorphology in=".." result=".." operator="dilate || erode" radius=""&gt; &lt;/feMorphology&gt;</code> </pre> <br><p>  Der Morphing-Radius kann als Radius eines Kreises oder einer Ellipse dargestellt werden.  Alle benachbarten Pixel, die ausgehend vom Eingabepixel in einem Kreis dieses Radius eingeschlossen sind, werden als eine einzelne Pixelgemeinschaft betrachtet und für den Effekt der Expansion oder Erosion verwendet. </p><br><p>  Tatsächlich kennzeichnet der Radius jedoch tatsächlich die Größe des Kerns, der als Strukturierungselement bezeichnet wird und eher einer Matrix ähnelt.  Im Moment reicht es aus, es als kleines Rechteck darzustellen, dessen Breite und Höhe durch die im Radiusattribut angegebenen Pixel angegeben werden. <br><img src="https://habrastorage.org/webt/hn/vy/ch/hnvychycyjlugtdv4rebde8gcro.png"></p><br><p>  Um einen Filter zu verwenden, müssen wir nicht auf die mühsamen kleinen Dinge eingehen, die das Morphing auf Pixelebene macht.  Es reicht zu wissen, dass Sie in <strong>feMorphology</strong> einen oder zwei <strong>Radiuswerte angeben können</strong> , die den Betrag bestimmen, um den das Element komprimiert oder erweitert wird.  Wenn im <strong>Radiusattribut</strong> zwei Zahlen angegeben sind, entspricht die erste dem x-Radius und die zweite dem y-Radius. </p><br><h2 id="morfing-izobrazheniy">  Bild Morph </h2><br><p>  Wenn die Operation <strong>feMorphology</strong> auf Bilder angewendet wird, folgen in der Regel zwei vorhersehbare Ergebnisse: </p><br><ul><li>  Die Bildgröße nimmt ab, wenn der <strong>Erodieroperator verwendet wird</strong> , oder nimmt zu, wenn der <strong>Dilatationsoperator verwendet wird</strong> . </li><li>  Bei jedem Bediener sieht das Bild so aus, als wäre es mit einem großen Pinsel mit einer kleinen Menge kleiner Details gemalt worden. </li></ul><br><p>  Um den Morphing-Effekt auf das Bild anzuwenden, sollte unser Code ungefähr so ​​aussehen: </p><br><pre> <code class="plaintext hljs">&lt;svg width="450" height="300" viewBox="0 0 450 300"&gt; &lt;filter id="erode"&gt; &lt;feMorphology operator="erode" radius="3"&gt;&lt;/feMorphology&gt; &lt;/filter&gt; &lt;image xlink:href="..." width="90%" height="90%" x="10" y="10" filter="url(#erode)"&gt;&lt;/image&gt; &lt;/svg&gt;</code> </pre> <br><p>  In diesem Fragment verwischen (komprimieren) wir das Bild (in Pixel) um 3 Pixel.  Die folgende Abbildung zeigt das Ergebnis dieses Codes.  Beachten Sie, dass die Bildgröße rechts etwas kleiner ist: </p><br><p><img src="https://habrastorage.org/webt/o6/_z/zo/o6_zzo1nl1ppmugvmhevox8afxi.png" alt="Rechts das Ergebnis der Anwendung des Unschärfeeffekts des Morphings auf das Bild links"><br>  Abb_2.  Rechts das Ergebnis der Anwendung des Unschärfeeffekts des Morphings auf das Bild links. </p><br><p>  Wenn wir nun den gleichen Morphing-Radius beibehalten und den Operator von <strong>Erodieren</strong> zu <strong>Dilatieren</strong> ändern, ist der Effekt ähnlich, aber auch deutlich unterschiedlich: </p><br><p><img src="https://habrastorage.org/webt/lf/ia/uv/lfiauvdmlzkld2fqfuzrm81pvpa.png"><br>  Abb_3.  Rechts das Ergebnis der Anwendung der <strong>Dilate-Morph-</strong> Operation auf das Bild links. </p><br><p>  In beiden Fällen sieht das Bild wie eine abstrakt gemalte Version von sich selbst aus, und seine Gesamtgröße ändert sich, wenn sich die Pixel ausdehnen oder zusammenziehen. </p><br><p>  Zusätzlich zu diesen Ergebnissen bemerken Sie wahrscheinlich als erstes den Farbunterschied, der sich aus jedem dieser beiden Effekte ergibt: Durch <strong>Erodieren</strong> wird ein Bild mit vielen dunklen Pixeln erstellt, während durch <strong>Erweitern</strong> das Ergebnis aufgehellt wird.  Dies liegt an der Tatsache, dass: </p><br><ul><li>  <strong>Erodieren</strong> (dieser Wert wird standardmäßig verwendet) legt für jedes Pixel die niedrigste Helligkeit bzw. die höchste Opazität seiner Community für jeden der Kanäle R, G, B und A fest. </li><li>  <strong>dilate</strong> setzt für jeden Kanal jedes Pixels die Werte, die dem hellsten oder am wenigsten transparenten Wert seiner Community entsprechen. </li></ul><br><p>  Abgesehen von technischen Details führt das Anwenden von <strong>feMorphology</strong> auf Bilder fast immer zum gleichen Ergebnis: Komprimieren oder Strecken kleiner Teile eines Bildes als Kopie eines Bildes mit einem dunklen oder hellen Hauptumriss. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/SaraSoueidan/embed/preview/eyyMea" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <strong>Wenn</strong> Sie jedoch <strong>feMorphology</strong> auf monochrome Elemente wie Text anwenden, wird es nur komprimiert oder gedehnt, ohne dass sich die Pixelfarbe merklich ändert, da wir immer noch nur eine Farbe haben, mit der wir arbeiten können ... </p><br><h2 id="dobavlenie-cvetnogo-kontura-k-tekstu-s-pomoschyu-femorphology">  Hinzufügen eines Farbumrisses zu Text mit feMorphology </h2><br><p>  Jetzt können wir dem Text in der SVG mithilfe des <strong>Strichattributs</strong> für diesen Text eine Gliederung hinzufügen. </p><br><pre> <code class="plaintext hljs">&lt;!-- Adding an outline to SVG text using strokes --&gt; &lt;text font-size="80px" dx="100" dy="200" font-weight="700" stroke="deepPink" stroke-width="3px"&gt;Stroked Text&lt;/text&gt;</code> </pre> <br><p>  Durch Hinzufügen eines Pfads, der normalerweise um die Kanten des Texts zentriert ist, sodass die Hälfte seiner Dicke vom Text selbst überlappt wird, wird der Text dünner, auch wenn er nicht beabsichtigt war.  Stattdessen können wir den Text mithilfe von <strong>feMorphology</strong> auf die Dicke des Umrisses oder Strichs <strong>erweitern</strong> . </p><br><p>  Sofern nicht anders angegeben, hat der Text normalerweise eine Farbe.  <strong>Wenn Sie also</strong> auf den Text <strong>angewendet werden,</strong> können <strong>Sie</strong> mit <strong>feMorphology</strong> die Dicke des Textes verringern oder erhöhen.  Sobald der Text mit <strong>feMorphology</strong> erweitert wurde, kann er als Eingabe für andere Filterprimitive verwendet werden, um eine <strong>Textkontur</strong> zu erstellen, die wir benötigen. </p><br><p>  Bevor wir uns damit befassen, werfen Sie einen Blick auf die Grafik, die den Unterschied zwischen dem Text mit dem eingekreisten Umriss und dem mit <strong>feMorphology</strong> hinzugefügten Umriss <strong>zeigt</strong> . </p><br><p><img src="https://habrastorage.org/webt/cu/rd/-d/curd-dnppif0tvvgoyb4sxrccn0.png" alt="Vergleichen des Quelltextes mit dem Text mit einem Strich und der mit ** feMorphology ** erstellten Gliederung"><br>  Abb_4.  Vergleich des Quelltextes mit dem Text mit einem Strich und der mit <strong>feMorphology</strong> erstellten <strong>Gliederung</strong> . </p><br><p>  Bitte beachten Sie, dass der Quelltext in der zweiten Zeile nach dem Hinzufügen eines glatten Umrisses dünner geworden ist als der Text der dritten Zeile, der mit <strong>feMorphology</strong> erweitert wurde. </p><br><p>  Lassen Sie uns also Schritt für Schritt ein farbiges Textfragment mit einem Umriss erstellen.  Hier ist das Ergebnis, das wir anstreben werden: </p><br><p><img src="https://habrastorage.org/webt/9o/ox/dc/9ooxdcthwek445glxn3u9kobgsy.png" alt="Endergebnis"><br>  Abb_5.  Das Endergebnis. </p><br><p>  Also werden wir eine SVG erstellen, die unseren Text und einen Filter enthält, der eine einfache Erweiterungsoperation startet.  Die Größe der Texterweiterung hängt von der Dicke der Kontur ab, die wir erhalten möchten. </p><br><pre> <code class="plaintext hljs">&lt;svg width="900" height="200" viewBox="100 0 900 200"&gt; &lt;filter id="outline"&gt; &lt;feMorphology in="SourceAlpha" result="DILATED" operator="dilate" radius="4"&gt;&lt;/feMorphology&gt; &lt;/filter&gt; &lt;!-- DILATED TEXT --&gt; &lt;text font-size="85px" dx="125" dy="130" font-weight="700" filter="url(#outline)"&gt;upgrade yourself&lt;/text&gt; &lt;/svg&gt;</code> </pre> <br><p>  Der obige Code erhält den Alphakanal des Textes, bei dem es sich nur um eine schwarze Version des Textes handelt, und erhöht die Schriftstärke um 4 Pixel.  Das Ergebnis des Codes in dieser Phase ist wie folgt: </p><br><p><img src="https://habrastorage.org/webt/th/ap/aj/thapajsoryyxflgrf1ky85t28wg.png" alt="Text nach dem Eindicken"><br>  Abb_6.  Text nach dem Eindicken. </p><br><p>  ... im Vergleich zum Quelltext, der eine dunkelblaue Füllfarbe hat: </p><br><p><img src="https://habrastorage.org/webt/lo/g6/e0/log6e0ykecbusfnf0lf8auxrcfc.png" alt="Quelltext"><br>  Abb_7.  Quelltext. </p><br><p>  Um einen Kontureffekt zu erzielen, überlagern wir den Quelltext mit dem erweiterten Text, wobei nur die Ränder des erweiterten Texts (unsere zusätzlichen 4 Pixel) um den Quelltext sichtbar bleiben und sie wie ein Pfad aussehen.  Die Textüberlagerung über dem Umriss (erweiterter Text) erfolgt mit <strong>feMerge</strong> .  Wie dies gemacht wird, haben wir in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">früheren Artikel untersucht</a> . </p><br><p>  Bevor wir den Umriss um den Text platzieren, müssen wir den Umriss selbst einfärben.  Füllen Sie wie im vorherigen Artikel den Filterbereich mit der gewünschten Farbe und fügen Sie dann die Farbebene mit der bereits erweiterten Textebene hinzu, d. H.  unsere Schaltung mit dem <strong>in-</strong> Operator.  Infolgedessen werden nur die Teile der Farbfüllung angezeigt, die sich mit dem erweiterten Text überschneiden, wodurch dieser gefärbt wird.  Anschließend kombinieren wir den resultierenden Farbumriss mit dem Quelltext, um das gewünschte Ergebnis zu erzielen. </p><br><p>  Jetzt sieht unser Code so aus: </p><br><pre> <code class="plaintext hljs">&lt;svg width="900" height="200" viewBox="100 0 900 200"&gt; &lt;filter id="outline"&gt; &lt;feMorphology in="SourceAlpha" result="DILATED" operator="dilate" radius="4"&gt;&lt;/feMorphology&gt; &lt;feFlood flood-color="#32DFEC" flood-opacity="1" result="PINK"&gt;&lt;/feFlood&gt; &lt;feComposite in="PINK" in2="DILATED" operator="in" result="OUTLINE"&gt;&lt;/feComposite&gt; &lt;feMerge&gt; &lt;feMergeNode in="OUTLINE" /&gt; &lt;feMergeNode in="SourceGraphic" /&gt; &lt;/feMerge&gt; &lt;/filter&gt; &lt;!-- DILATED TEXT --&gt; &lt;text font-size="85px" dx="125" dy="130" font-weight="700" filter="url(#outline)"&gt;upgrade yourself&lt;/text&gt; &lt;/svg&gt;</code> </pre> <br><p>  Der Prozess zum Erstellen von Filtereffekten in SVG besteht darin, das Endergebnis in Form kleiner sequentieller Operationen darzustellen, wobei das Ergebnis einer Operation als Eingabe für eine andere verwendet wird und schließlich alle von ihnen erstellten Ebenen kombiniert werden, um das Endergebnis zu erzielen. </p><br><p>  Und hier ist die Demo des obigen Codes: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/SaraSoueidan/embed/preview/QzxQqK" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Die Füllfarbe des Textes kann entweder in Ihrem CSS oder im <strong>Textelement</strong> mithilfe des <strong>Füllattributs angegeben</strong> werden.  Die <strong>Umrissfarbe</strong> kann im <strong>Flood-Color-</strong> Attribut des <strong>feFlood-Grundelements festgelegt werden</strong> . </p><br><p>  Großartig!  Und wenn Sie die Farbe der Kontur ändern möchten?  Sie müssen das <strong>Grundelement feFlood erneut verwenden</strong> und die <strong>Farbfüllung</strong> mit dem Umriss kombinieren.  Und jedes Mal, wenn Sie die Farbe der Kontur ändern möchten, müssen Sie immer wieder dasselbe tun.  Das ist zugegebenermaßen zu anstrengend.  Zum Glück gibt es einen einfacheren Weg. </p><br><h2 id="vybivanie-teksta">  Text ausschalten </h2><br><p>  Zusätzlich zum Hinzufügen einer Kontur zum Text können wir auch eine Kontur erstellen, d. H.  Geprägter Text, was bedeutet, dass die Innenseite des Textes „ausgeschnitten“ wird, sodass Sie den Hintergrund dahinter durch den Umriss sehen können.  Ein Beispiel für diesen Effekt sieht möglicherweise aus wie der Text im nächsten GIF, der die Änderung der Hintergrundfarbe zeigt und wie dieser Hintergrund in unserem Text sichtbar ist.  Hier ist die Demo, die wir in diesem Abschnitt erstellen werden: </p><br><p><img src="https://habrastorage.org/webt/go/bq/ew/gobqewey5txr4yvz2mgvmiirnfa.gif" alt="Beispiel für geprägten Text"><br>  Abb_8.  Ein Beispiel für geprägten Text. </p><br><p>  Dieser Effekt ist einfacher zu erstellen und der zur Ausführung erforderliche Code ist deutlich kürzer.  Der Hauptunterschied besteht darin, dass wir den Quelltext nicht über den erweiterten Text legen, sondern denselben Quelltext verwenden, um die inneren Teile des erweiterten Textes auszuschneiden.  Dies bedeutet, dass nur die hinzugefügte Dicke des erweiterten Textes übrig bleibt und der innere Teil gelöscht wird, wodurch nur der Umriss übrig bleibt. </p><br><p>  Wenn Sie anstelle des Alpha-Kanals des Texts (der standardmäßig schwarz ist) den Quelltext selbst (der eine beliebige Füllfarbe haben kann!) Erfassen und erweitern, ihn erweitern und dann den Text erneut verwenden, um das Innere des erweiterten Textes auszuschneiden, erhalten Sie eine Gliederung. das kommt aus dem Quellcode selbst.  Dies bedeutet, dass die Farbe dieses Pfads immer mit der Farbe des Quelltextes übereinstimmt.  Und da wir die Füllfarbe des Quelltextes in CSS bestimmen können, bedeutet dies, dass Sie eine Textkontur haben, die von den Stilen getrennt ist.  (Hurra Trennung der Sorgen!) Dann können Sie diesen Filter auf jeden Text anwenden und die Farbe dieses Textes in CSS jederzeit ändern, ohne den Filtercode konfigurieren zu müssen.  Unser verbesserter Code sieht jetzt so aus: </p><br><pre> <code class="plaintext hljs">&lt;svg width="900" height="450" viewBox="0 0 900 450"&gt; &lt;filter id="outliner"&gt; &lt;!-- Start by grabbing the alpha channel of the text and dilating it--&gt; &lt;feMorphology operator="dilate" radius="8" in="SourceAlpha" result="THICKNESS" /&gt; &lt;!-- Next, grab the original text (SourceGraphic) and use it to cut out the inside of the dilated text --&gt; &lt;feComposite operator="out" in="THICKNESS" in2="SourceGraphic"&gt;&lt;/feComposite&gt; &lt;/filter&gt; &lt;text dx="100" dy="300" filter="url(#outliner)" letter-spacing="10px"&gt;SVG Rocks&lt;/text&gt; &lt;/svg&gt;</code> </pre> <br><p>  Mit einer guten Schrift sieht unsere Demo jetzt folgendermaßen aus: </p><br><p><img src="https://habrastorage.org/webt/ck/vc/5d/ckvc5dlnx9qb8ufj89lg21kj_wi.png"><br>  Abb_9.  Das Ergebnis unserer Arbeit. </p><br><p>  In unserem Stylesheet können wir sowohl die Umrissfarbe als auch die Hintergrundfarbe der SVG auswählen.  Sie können das Bild auch innerhalb der SVG-Datei nach Text auswählen.  Im folgenden Code verwende ich CSS-Animationen ohne Grund, um die Hintergrundfarbe zu ändern, außer dass sie schön ist. </p><br><pre> <code class="plaintext hljs">svg text { font-family: 'Bangers', cursive; font-size: 150px; letter-spacing: 13px; fill: #000; /* This fill color determines the color of the outline */ } svg { background-color: gold; animation: colorsssss 2s linear infinite; animation-delay: 3s; } @keyframes colorsssss { 50% { background-color: deepPink; } }</code> </pre> <br><p>  Der obige SVG-Filter kann wie HTML über SVG wiederverwendet werden.  Wenn Sie es auf ein HTML-Element anwenden möchten, können Sie dies mithilfe der <strong>Filtereigenschaft</strong> tun.  Setzen Sie den Filter einfach in HTML ein und rufen Sie ihn in CSS auf: </p><br><pre> <code class="plaintext hljs">h2 { filter: url(#outliner); /* You can change the color of the outline here by changing the color of the heading */ color: deepPink; }</code> </pre> <br><p>  Und unsere fertige Demo, die einen HTML-Header mit einem darauf angewendeten Filter enthält: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/SaraSoueidan/embed/preview/EoEZwr" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Meine Lieblingssache an diesem Filterrezept ist, dass es als visuelle Verbesserung verwendet werden kann.  Wenn der Browser keine SVG-Filter oder CSS-Filter unterstützt oder keine SVG-Filter auf HTML-Elemente anwendet, erhält der Benutzer den Quelltext ohne Umrisse und den darauf angewendeten durchscheinenden Effekt.  Oh, und die Kirsche auf dem Kuchen oben drauf?  Sowohl SVG- als auch HTML-Text können vollständig durchsucht und bearbeitet werden.  Hurra progressive Verbesserung!  Es lebe die SVG! </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Mit nur zwei Filtervorgängen in SVG können Sie den Effekt des ausgewählten Texts auf den Textinhalt von SVG oder HTML anwenden.  Fügen Sie diesen Filter in HTML ein und verwenden Sie ihn bei Bedarf. </p><br><p>  Im nächsten Artikel dieser Reihe werden wir uns <strong>feComponentTransfer</strong> , eines meiner Lieblingsfilterprimitive, ansehen und sehen, wie es funktioniert und welche Effekte wir damit erzeugen können.  Bleib bei uns. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de439722/">https://habr.com/ru/post/de439722/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de439712/index.html">Öffentliches Beschaffungswesen: das Gleichgewicht zwischen dem italienischen Streik und dem russischen Verbrecher</a></li>
<li><a href="../de439714/index.html">Russen bei Apple: Wie wir einen Vertrag über Millionen mit Beatles und „einigen Jerry“ -Liedern bekommen haben</a></li>
<li><a href="../de439716/index.html">Tails OS oder wie Sie sich online schützen können</a></li>
<li><a href="../de439718/index.html">Anwendungsentwicklung auf Elixir / Phoenix mit Docker</a></li>
<li><a href="../de439720/index.html">Einführung in die Programmierung: Ein einfacher 3D-Shooter von Grund auf über das Wochenende, Teil 2</a></li>
<li><a href="../de439724/index.html">Überblick über AI & ML-Lösungen im Jahr 2018 und Prognosen für 2019: Teil 2 - Tools und Bibliotheken, AutoML, RL, Ethik in AI</a></li>
<li><a href="../de439726/index.html">Lock-in: wahr oder fiktiv?</a></li>
<li><a href="../de439728/index.html">Konfigurieren Sie die vollständige und separate Sicherung und Wiederherstellung von Zimbra OSE ohne Verwendung von Zextras</a></li>
<li><a href="../de439730/index.html">Organisation des Reduzierers durch eine Standardklasse</a></li>
<li><a href="../de439732/index.html">Lazarus - einfache Animation mit der TImageFragment-Komponente</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>