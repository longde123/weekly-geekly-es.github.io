<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîñ üôâ üêê Auswirkungen von SVG-Filtern. Teil 2. Gliederungstext mit feMorphology ‚óΩÔ∏è üõµ üë©üèΩ‚Äçüåæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die vorgeschlagene Artikelserie " SVG Filtering Effects " von Sara Soueidan, freiberufliche UI / UX-Schnittstellenentwicklerin und Autorin vieler im L...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Auswirkungen von SVG-Filtern. Teil 2. Gliederungstext mit feMorphology</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439722/"><p>  Die vorgeschlagene Artikelserie " <strong>SVG Filtering Effects</strong> " von Sara Soueidan, freiberufliche UI / UX-Schnittstellenentwicklerin und Autorin vieler im Libanon ans√§ssiger technischer Artikel, konzentriert sich auf die Arbeit von SVG-Filtern und besteht aus folgenden Artikeln: </p><br><h1 id="effekty-filtracii-svg">  SVG-Filtereffekte </h1><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SVG-Filtereffekte.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1. SVG-Filter 101</a> . </li><li>  SVG-Filtereffekte.  Teil 2. Gliederungstext mit feMorphology </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SVG-Filtereffekte.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3. Der Effekt der Bildposterisierung mit feComponentTransfer</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SVG-Filtereffekte.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 4. Zweifarbige Bilder mit <strong>feComponentTransfer</strong></a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SVG-Filtereffekte.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 5. Text mit <strong>feDisplacementMap</strong> an die Oberfl√§chentextur <strong>anpassen</strong></a> </li></ol><br><hr><br><p>  Im zweiten Teil der Serie √ºber SVG-Filter stellt <strong>Sara Soueidan</strong> uns den <strong>feMorphology-</strong> Filter vor und gibt einige Beispiele f√ºr seine Verwendung zur Erzeugung interessanter Effekte. </p><br><p><img src="https://habrastorage.org/webt/pt/1l/yq/pt1lyq3deuk69mcyf2ax_yt9_tc.png"></p><a name="habracut"></a><br><p>  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>ersten Teil dieser Serie</strong></a> zu SVG-Filtereffekten haben wir die Grundlagen von SVG-Filtern vorgestellt - wie man sie erstellt und wie man sie verwendet.  Wir haben auch einige der am h√§ufigsten verwendeten Filteroperationen untersucht, d.h.  Grundelemente filtern.  Weil  Wir werden diese Informationen wiederverwenden. Ich empfehle dann, diesen Artikel anzuhalten und zu lesen, bevor Sie mit diesem fortfahren. </p><br><p>  <strong>&lt;feMorphology&gt;</strong> ist eine meiner bevorzugten SVG- <strong>Filteroperationen</strong> .  Es ist auch eine der einfachsten Operationen, und die Ergebnisse seiner Anwendung auf verschiedene Elemente sind immer vorhersehbar. </p><br><h2 id="chto-takoe-morfing">  Was ist Morphing? </h2><br><p>  Morphing bedeutet, die Form oder das Erscheinungsbild eines Objekts zu transformieren oder zu √§ndern. </p><br><p>  Der morphologische Filter wirkt auf die Form des Objekts ein.  Es stellt zwei vordefinierte Formtransformationen bereit: Erosion (d. H. Ausd√ºnnen oder Schrumpfen) und Ausdehnung (d. H. A. Verdicken oder Ausdehnen).  Mit anderen Worten kann das <strong>Grundelement feMorphology</strong> verwendet werden, um ein Element zu komprimieren oder zu erweitern. </p><br><p>  Technisch gesehen arbeiten beide Operationen auf Pixelebene, erweitern das Pixel auf benachbarte Pixel ( <strong>erweitern</strong> ) oder zerst√∂ren benachbarte Pixel an den R√§ndern des gesteuerten Pixels ( <strong>erodieren</strong> ), w√§hrend der Umriss am Rand dieses Pixels beibehalten wird.  Der Wert, um den sich das Pixel ausdehnt, oder die Anzahl benachbarter Pixel, die zum "Strecken" oder "Erweitern" des Pixels verwendet werden, wird durch den <strong>Radiusparameter</strong> bestimmt. </p><br><pre><code class="plaintext hljs">&lt;feMorphology in=".." result=".." operator="dilate || erode" radius=""&gt; &lt;/feMorphology&gt;</code> </pre> <br><p>  Der Morphing-Radius kann als Radius eines Kreises oder einer Ellipse dargestellt werden.  Alle benachbarten Pixel, die ausgehend vom Eingabepixel in einem Kreis dieses Radius eingeschlossen sind, werden als eine einzelne Pixelgemeinschaft betrachtet und f√ºr den Effekt der Expansion oder Erosion verwendet. </p><br><p>  Tats√§chlich kennzeichnet der Radius jedoch tats√§chlich die Gr√∂√üe des Kerns, der als Strukturierungselement bezeichnet wird und eher einer Matrix √§hnelt.  Im Moment reicht es aus, es als kleines Rechteck darzustellen, dessen Breite und H√∂he durch die im Radiusattribut angegebenen Pixel angegeben werden. <br><img src="https://habrastorage.org/webt/hn/vy/ch/hnvychycyjlugtdv4rebde8gcro.png"></p><br><p>  Um einen Filter zu verwenden, m√ºssen wir nicht auf die m√ºhsamen kleinen Dinge eingehen, die das Morphing auf Pixelebene macht.  Es reicht zu wissen, dass Sie in <strong>feMorphology</strong> einen oder zwei <strong>Radiuswerte angeben k√∂nnen</strong> , die den Betrag bestimmen, um den das Element komprimiert oder erweitert wird.  Wenn im <strong>Radiusattribut</strong> zwei Zahlen angegeben sind, entspricht die erste dem x-Radius und die zweite dem y-Radius. </p><br><h2 id="morfing-izobrazheniy">  Bild Morph </h2><br><p>  Wenn die Operation <strong>feMorphology</strong> auf Bilder angewendet wird, folgen in der Regel zwei vorhersehbare Ergebnisse: </p><br><ul><li>  Die Bildgr√∂√üe nimmt ab, wenn der <strong>Erodieroperator verwendet wird</strong> , oder nimmt zu, wenn der <strong>Dilatationsoperator verwendet wird</strong> . </li><li>  Bei jedem Bediener sieht das Bild so aus, als w√§re es mit einem gro√üen Pinsel mit einer kleinen Menge kleiner Details gemalt worden. </li></ul><br><p>  Um den Morphing-Effekt auf das Bild anzuwenden, sollte unser Code ungef√§hr so ‚Äã‚Äãaussehen: </p><br><pre> <code class="plaintext hljs">&lt;svg width="450" height="300" viewBox="0 0 450 300"&gt; &lt;filter id="erode"&gt; &lt;feMorphology operator="erode" radius="3"&gt;&lt;/feMorphology&gt; &lt;/filter&gt; &lt;image xlink:href="..." width="90%" height="90%" x="10" y="10" filter="url(#erode)"&gt;&lt;/image&gt; &lt;/svg&gt;</code> </pre> <br><p>  In diesem Fragment verwischen (komprimieren) wir das Bild (in Pixel) um 3 Pixel.  Die folgende Abbildung zeigt das Ergebnis dieses Codes.  Beachten Sie, dass die Bildgr√∂√üe rechts etwas kleiner ist: </p><br><p><img src="https://habrastorage.org/webt/o6/_z/zo/o6_zzo1nl1ppmugvmhevox8afxi.png" alt="Rechts das Ergebnis der Anwendung des Unsch√§rfeeffekts des Morphings auf das Bild links"><br>  Abb_2.  Rechts das Ergebnis der Anwendung des Unsch√§rfeeffekts des Morphings auf das Bild links. </p><br><p>  Wenn wir nun den gleichen Morphing-Radius beibehalten und den Operator von <strong>Erodieren</strong> zu <strong>Dilatieren</strong> √§ndern, ist der Effekt √§hnlich, aber auch deutlich unterschiedlich: </p><br><p><img src="https://habrastorage.org/webt/lf/ia/uv/lfiauvdmlzkld2fqfuzrm81pvpa.png"><br>  Abb_3.  Rechts das Ergebnis der Anwendung der <strong>Dilate-Morph-</strong> Operation auf das Bild links. </p><br><p>  In beiden F√§llen sieht das Bild wie eine abstrakt gemalte Version von sich selbst aus, und seine Gesamtgr√∂√üe √§ndert sich, wenn sich die Pixel ausdehnen oder zusammenziehen. </p><br><p>  Zus√§tzlich zu diesen Ergebnissen bemerken Sie wahrscheinlich als erstes den Farbunterschied, der sich aus jedem dieser beiden Effekte ergibt: Durch <strong>Erodieren</strong> wird ein Bild mit vielen dunklen Pixeln erstellt, w√§hrend durch <strong>Erweitern</strong> das Ergebnis aufgehellt wird.  Dies liegt an der Tatsache, dass: </p><br><ul><li>  <strong>Erodieren</strong> (dieser Wert wird standardm√§√üig verwendet) legt f√ºr jedes Pixel die niedrigste Helligkeit bzw. die h√∂chste Opazit√§t seiner Community f√ºr jeden der Kan√§le R, G, B und A fest. </li><li>  <strong>dilate</strong> setzt f√ºr jeden Kanal jedes Pixels die Werte, die dem hellsten oder am wenigsten transparenten Wert seiner Community entsprechen. </li></ul><br><p>  Abgesehen von technischen Details f√ºhrt das Anwenden von <strong>feMorphology</strong> auf Bilder fast immer zum gleichen Ergebnis: Komprimieren oder Strecken kleiner Teile eines Bildes als Kopie eines Bildes mit einem dunklen oder hellen Hauptumriss. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/SaraSoueidan/embed/preview/eyyMea" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <strong>Wenn</strong> Sie jedoch <strong>feMorphology</strong> auf monochrome Elemente wie Text anwenden, wird es nur komprimiert oder gedehnt, ohne dass sich die Pixelfarbe merklich √§ndert, da wir immer noch nur eine Farbe haben, mit der wir arbeiten k√∂nnen ... </p><br><h2 id="dobavlenie-cvetnogo-kontura-k-tekstu-s-pomoschyu-femorphology">  Hinzuf√ºgen eines Farbumrisses zu Text mit feMorphology </h2><br><p>  Jetzt k√∂nnen wir dem Text in der SVG mithilfe des <strong>Strichattributs</strong> f√ºr diesen Text eine Gliederung hinzuf√ºgen. </p><br><pre> <code class="plaintext hljs">&lt;!-- Adding an outline to SVG text using strokes --&gt; &lt;text font-size="80px" dx="100" dy="200" font-weight="700" stroke="deepPink" stroke-width="3px"&gt;Stroked Text&lt;/text&gt;</code> </pre> <br><p>  Durch Hinzuf√ºgen eines Pfads, der normalerweise um die Kanten des Texts zentriert ist, sodass die H√§lfte seiner Dicke vom Text selbst √ºberlappt wird, wird der Text d√ºnner, auch wenn er nicht beabsichtigt war.  Stattdessen k√∂nnen wir den Text mithilfe von <strong>feMorphology</strong> auf die Dicke des Umrisses oder Strichs <strong>erweitern</strong> . </p><br><p>  Sofern nicht anders angegeben, hat der Text normalerweise eine Farbe.  <strong>Wenn Sie also</strong> auf den Text <strong>angewendet werden,</strong> k√∂nnen <strong>Sie</strong> mit <strong>feMorphology</strong> die Dicke des Textes verringern oder erh√∂hen.  Sobald der Text mit <strong>feMorphology</strong> erweitert wurde, kann er als Eingabe f√ºr andere Filterprimitive verwendet werden, um eine <strong>Textkontur</strong> zu erstellen, die wir ben√∂tigen. </p><br><p>  Bevor wir uns damit befassen, werfen Sie einen Blick auf die Grafik, die den Unterschied zwischen dem Text mit dem eingekreisten Umriss und dem mit <strong>feMorphology</strong> hinzugef√ºgten Umriss <strong>zeigt</strong> . </p><br><p><img src="https://habrastorage.org/webt/cu/rd/-d/curd-dnppif0tvvgoyb4sxrccn0.png" alt="Vergleichen des Quelltextes mit dem Text mit einem Strich und der mit ** feMorphology ** erstellten Gliederung"><br>  Abb_4.  Vergleich des Quelltextes mit dem Text mit einem Strich und der mit <strong>feMorphology</strong> erstellten <strong>Gliederung</strong> . </p><br><p>  Bitte beachten Sie, dass der Quelltext in der zweiten Zeile nach dem Hinzuf√ºgen eines glatten Umrisses d√ºnner geworden ist als der Text der dritten Zeile, der mit <strong>feMorphology</strong> erweitert wurde. </p><br><p>  Lassen Sie uns also Schritt f√ºr Schritt ein farbiges Textfragment mit einem Umriss erstellen.  Hier ist das Ergebnis, das wir anstreben werden: </p><br><p><img src="https://habrastorage.org/webt/9o/ox/dc/9ooxdcthwek445glxn3u9kobgsy.png" alt="Endergebnis"><br>  Abb_5.  Das Endergebnis. </p><br><p>  Also werden wir eine SVG erstellen, die unseren Text und einen Filter enth√§lt, der eine einfache Erweiterungsoperation startet.  Die Gr√∂√üe der Texterweiterung h√§ngt von der Dicke der Kontur ab, die wir erhalten m√∂chten. </p><br><pre> <code class="plaintext hljs">&lt;svg width="900" height="200" viewBox="100 0 900 200"&gt; &lt;filter id="outline"&gt; &lt;feMorphology in="SourceAlpha" result="DILATED" operator="dilate" radius="4"&gt;&lt;/feMorphology&gt; &lt;/filter&gt; &lt;!-- DILATED TEXT --&gt; &lt;text font-size="85px" dx="125" dy="130" font-weight="700" filter="url(#outline)"&gt;upgrade yourself&lt;/text&gt; &lt;/svg&gt;</code> </pre> <br><p>  Der obige Code erh√§lt den Alphakanal des Textes, bei dem es sich nur um eine schwarze Version des Textes handelt, und erh√∂ht die Schriftst√§rke um 4 Pixel.  Das Ergebnis des Codes in dieser Phase ist wie folgt: </p><br><p><img src="https://habrastorage.org/webt/th/ap/aj/thapajsoryyxflgrf1ky85t28wg.png" alt="Text nach dem Eindicken"><br>  Abb_6.  Text nach dem Eindicken. </p><br><p>  ... im Vergleich zum Quelltext, der eine dunkelblaue F√ºllfarbe hat: </p><br><p><img src="https://habrastorage.org/webt/lo/g6/e0/log6e0ykecbusfnf0lf8auxrcfc.png" alt="Quelltext"><br>  Abb_7.  Quelltext. </p><br><p>  Um einen Kontureffekt zu erzielen, √ºberlagern wir den Quelltext mit dem erweiterten Text, wobei nur die R√§nder des erweiterten Texts (unsere zus√§tzlichen 4 Pixel) um den Quelltext sichtbar bleiben und sie wie ein Pfad aussehen.  Die Text√ºberlagerung √ºber dem Umriss (erweiterter Text) erfolgt mit <strong>feMerge</strong> .  Wie dies gemacht wird, haben wir in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fr√ºheren Artikel untersucht</a> . </p><br><p>  Bevor wir den Umriss um den Text platzieren, m√ºssen wir den Umriss selbst einf√§rben.  F√ºllen Sie wie im vorherigen Artikel den Filterbereich mit der gew√ºnschten Farbe und f√ºgen Sie dann die Farbebene mit der bereits erweiterten Textebene hinzu, d. H.  unsere Schaltung mit dem <strong>in-</strong> Operator.  Infolgedessen werden nur die Teile der Farbf√ºllung angezeigt, die sich mit dem erweiterten Text √ºberschneiden, wodurch dieser gef√§rbt wird.  Anschlie√üend kombinieren wir den resultierenden Farbumriss mit dem Quelltext, um das gew√ºnschte Ergebnis zu erzielen. </p><br><p>  Jetzt sieht unser Code so aus: </p><br><pre> <code class="plaintext hljs">&lt;svg width="900" height="200" viewBox="100 0 900 200"&gt; &lt;filter id="outline"&gt; &lt;feMorphology in="SourceAlpha" result="DILATED" operator="dilate" radius="4"&gt;&lt;/feMorphology&gt; &lt;feFlood flood-color="#32DFEC" flood-opacity="1" result="PINK"&gt;&lt;/feFlood&gt; &lt;feComposite in="PINK" in2="DILATED" operator="in" result="OUTLINE"&gt;&lt;/feComposite&gt; &lt;feMerge&gt; &lt;feMergeNode in="OUTLINE" /&gt; &lt;feMergeNode in="SourceGraphic" /&gt; &lt;/feMerge&gt; &lt;/filter&gt; &lt;!-- DILATED TEXT --&gt; &lt;text font-size="85px" dx="125" dy="130" font-weight="700" filter="url(#outline)"&gt;upgrade yourself&lt;/text&gt; &lt;/svg&gt;</code> </pre> <br><p>  Der Prozess zum Erstellen von Filtereffekten in SVG besteht darin, das Endergebnis in Form kleiner sequentieller Operationen darzustellen, wobei das Ergebnis einer Operation als Eingabe f√ºr eine andere verwendet wird und schlie√ülich alle von ihnen erstellten Ebenen kombiniert werden, um das Endergebnis zu erzielen. </p><br><p>  Und hier ist die Demo des obigen Codes: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/SaraSoueidan/embed/preview/QzxQqK" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Die F√ºllfarbe des Textes kann entweder in Ihrem CSS oder im <strong>Textelement</strong> mithilfe des <strong>F√ºllattributs angegeben</strong> werden.  Die <strong>Umrissfarbe</strong> kann im <strong>Flood-Color-</strong> Attribut des <strong>feFlood-Grundelements festgelegt werden</strong> . </p><br><p>  Gro√üartig!  Und wenn Sie die Farbe der Kontur √§ndern m√∂chten?  Sie m√ºssen das <strong>Grundelement feFlood erneut verwenden</strong> und die <strong>Farbf√ºllung</strong> mit dem Umriss kombinieren.  Und jedes Mal, wenn Sie die Farbe der Kontur √§ndern m√∂chten, m√ºssen Sie immer wieder dasselbe tun.  Das ist zugegebenerma√üen zu anstrengend.  Zum Gl√ºck gibt es einen einfacheren Weg. </p><br><h2 id="vybivanie-teksta">  Text ausschalten </h2><br><p>  Zus√§tzlich zum Hinzuf√ºgen einer Kontur zum Text k√∂nnen wir auch eine Kontur erstellen, d. H.  Gepr√§gter Text, was bedeutet, dass die Innenseite des Textes ‚Äûausgeschnitten‚Äú wird, sodass Sie den Hintergrund dahinter durch den Umriss sehen k√∂nnen.  Ein Beispiel f√ºr diesen Effekt sieht m√∂glicherweise aus wie der Text im n√§chsten GIF, der die √Ñnderung der Hintergrundfarbe zeigt und wie dieser Hintergrund in unserem Text sichtbar ist.  Hier ist die Demo, die wir in diesem Abschnitt erstellen werden: </p><br><p><img src="https://habrastorage.org/webt/go/bq/ew/gobqewey5txr4yvz2mgvmiirnfa.gif" alt="Beispiel f√ºr gepr√§gten Text"><br>  Abb_8.  Ein Beispiel f√ºr gepr√§gten Text. </p><br><p>  Dieser Effekt ist einfacher zu erstellen und der zur Ausf√ºhrung erforderliche Code ist deutlich k√ºrzer.  Der Hauptunterschied besteht darin, dass wir den Quelltext nicht √ºber den erweiterten Text legen, sondern denselben Quelltext verwenden, um die inneren Teile des erweiterten Textes auszuschneiden.  Dies bedeutet, dass nur die hinzugef√ºgte Dicke des erweiterten Textes √ºbrig bleibt und der innere Teil gel√∂scht wird, wodurch nur der Umriss √ºbrig bleibt. </p><br><p>  Wenn Sie anstelle des Alpha-Kanals des Texts (der standardm√§√üig schwarz ist) den Quelltext selbst (der eine beliebige F√ºllfarbe haben kann!) Erfassen und erweitern, ihn erweitern und dann den Text erneut verwenden, um das Innere des erweiterten Textes auszuschneiden, erhalten Sie eine Gliederung. das kommt aus dem Quellcode selbst.  Dies bedeutet, dass die Farbe dieses Pfads immer mit der Farbe des Quelltextes √ºbereinstimmt.  Und da wir die F√ºllfarbe des Quelltextes in CSS bestimmen k√∂nnen, bedeutet dies, dass Sie eine Textkontur haben, die von den Stilen getrennt ist.  (Hurra Trennung der Sorgen!) Dann k√∂nnen Sie diesen Filter auf jeden Text anwenden und die Farbe dieses Textes in CSS jederzeit √§ndern, ohne den Filtercode konfigurieren zu m√ºssen.  Unser verbesserter Code sieht jetzt so aus: </p><br><pre> <code class="plaintext hljs">&lt;svg width="900" height="450" viewBox="0 0 900 450"&gt; &lt;filter id="outliner"&gt; &lt;!-- Start by grabbing the alpha channel of the text and dilating it--&gt; &lt;feMorphology operator="dilate" radius="8" in="SourceAlpha" result="THICKNESS" /&gt; &lt;!-- Next, grab the original text (SourceGraphic) and use it to cut out the inside of the dilated text --&gt; &lt;feComposite operator="out" in="THICKNESS" in2="SourceGraphic"&gt;&lt;/feComposite&gt; &lt;/filter&gt; &lt;text dx="100" dy="300" filter="url(#outliner)" letter-spacing="10px"&gt;SVG Rocks&lt;/text&gt; &lt;/svg&gt;</code> </pre> <br><p>  Mit einer guten Schrift sieht unsere Demo jetzt folgenderma√üen aus: </p><br><p><img src="https://habrastorage.org/webt/ck/vc/5d/ckvc5dlnx9qb8ufj89lg21kj_wi.png"><br>  Abb_9.  Das Ergebnis unserer Arbeit. </p><br><p>  In unserem Stylesheet k√∂nnen wir sowohl die Umrissfarbe als auch die Hintergrundfarbe der SVG ausw√§hlen.  Sie k√∂nnen das Bild auch innerhalb der SVG-Datei nach Text ausw√§hlen.  Im folgenden Code verwende ich CSS-Animationen ohne Grund, um die Hintergrundfarbe zu √§ndern, au√üer dass sie sch√∂n ist. </p><br><pre> <code class="plaintext hljs">svg text { font-family: 'Bangers', cursive; font-size: 150px; letter-spacing: 13px; fill: #000; /* This fill color determines the color of the outline */ } svg { background-color: gold; animation: colorsssss 2s linear infinite; animation-delay: 3s; } @keyframes colorsssss { 50% { background-color: deepPink; } }</code> </pre> <br><p>  Der obige SVG-Filter kann wie HTML √ºber SVG wiederverwendet werden.  Wenn Sie es auf ein HTML-Element anwenden m√∂chten, k√∂nnen Sie dies mithilfe der <strong>Filtereigenschaft</strong> tun.  Setzen Sie den Filter einfach in HTML ein und rufen Sie ihn in CSS auf: </p><br><pre> <code class="plaintext hljs">h2 { filter: url(#outliner); /* You can change the color of the outline here by changing the color of the heading */ color: deepPink; }</code> </pre> <br><p>  Und unsere fertige Demo, die einen HTML-Header mit einem darauf angewendeten Filter enth√§lt: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://codepen.io/SaraSoueidan/embed/preview/EoEZwr" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Meine Lieblingssache an diesem Filterrezept ist, dass es als visuelle Verbesserung verwendet werden kann.  Wenn der Browser keine SVG-Filter oder CSS-Filter unterst√ºtzt oder keine SVG-Filter auf HTML-Elemente anwendet, erh√§lt der Benutzer den Quelltext ohne Umrisse und den darauf angewendeten durchscheinenden Effekt.  Oh, und die Kirsche auf dem Kuchen oben drauf?  Sowohl SVG- als auch HTML-Text k√∂nnen vollst√§ndig durchsucht und bearbeitet werden.  Hurra progressive Verbesserung!  Es lebe die SVG! </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Mit nur zwei Filtervorg√§ngen in SVG k√∂nnen Sie den Effekt des ausgew√§hlten Texts auf den Textinhalt von SVG oder HTML anwenden.  F√ºgen Sie diesen Filter in HTML ein und verwenden Sie ihn bei Bedarf. </p><br><p>  Im n√§chsten Artikel dieser Reihe werden wir uns <strong>feComponentTransfer</strong> , eines meiner Lieblingsfilterprimitive, ansehen und sehen, wie es funktioniert und welche Effekte wir damit erzeugen k√∂nnen.  Bleib bei uns. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de439722/">https://habr.com/ru/post/de439722/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de439712/index.html">√ñffentliches Beschaffungswesen: das Gleichgewicht zwischen dem italienischen Streik und dem russischen Verbrecher</a></li>
<li><a href="../de439714/index.html">Russen bei Apple: Wie wir einen Vertrag √ºber Millionen mit Beatles und ‚Äûeinigen Jerry‚Äú -Liedern bekommen haben</a></li>
<li><a href="../de439716/index.html">Tails OS oder wie Sie sich online sch√ºtzen k√∂nnen</a></li>
<li><a href="../de439718/index.html">Anwendungsentwicklung auf Elixir / Phoenix mit Docker</a></li>
<li><a href="../de439720/index.html">Einf√ºhrung in die Programmierung: Ein einfacher 3D-Shooter von Grund auf √ºber das Wochenende, Teil 2</a></li>
<li><a href="../de439724/index.html">√úberblick √ºber AI & ML-L√∂sungen im Jahr 2018 und Prognosen f√ºr 2019: Teil 2 - Tools und Bibliotheken, AutoML, RL, Ethik in AI</a></li>
<li><a href="../de439726/index.html">Lock-in: wahr oder fiktiv?</a></li>
<li><a href="../de439728/index.html">Konfigurieren Sie die vollst√§ndige und separate Sicherung und Wiederherstellung von Zimbra OSE ohne Verwendung von Zextras</a></li>
<li><a href="../de439730/index.html">Organisation des Reduzierers durch eine Standardklasse</a></li>
<li><a href="../de439732/index.html">Lazarus - einfache Animation mit der TImageFragment-Komponente</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>