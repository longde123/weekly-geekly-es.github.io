<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🚒 🧕🏽 😢 在网上银行系统中使用RxJs库的功能 💡 🧒 ⏭️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="引言 
 设计现代的在线银行系统是一项相当复杂的任务。 同时，用于开发应用程序客户端部分的许多任务与处理大量同时来自多个信息源的数据的过程相关。 来自远程银行系统（RBS），即时消息服务，各种信息服务的数据应在此处和现在进行实时接收和处理。 为了解决这种问题，当今广泛使用了反应式编程方法。 

 广...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在网上银行系统中使用RxJs库的功能</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/simbirsoft/blog/425897/"><h3> 引言 </h3><br> 设计现代的在线银行系统是一项相当复杂的任务。 同时，用于开发应用程序客户端部分的许多任务与处理大量同时来自多个信息源的数据的过程相关。 来自远程银行系统（RBS），即时消息服务，各种信息服务的数据应在此处和现在进行实时接收和处理。 为了解决这种问题，当今广泛使用了反应式编程方法。 <br><a name="habracut"></a><br> 广义上的术语“反应式编程”是指应用程序的这种组织，其中，由于处理数据流的状态而在系统中传播更改。 此方法的重要问题是呈现信息流的简便性和响应呈现结果异步处理期间发生的错误的可能性。 <br><br> 从狭义上讲，响应式Web UI编程可能意味着使用现成的开发人员工具，例如RxJs库。 该库使用Observable对象提供数据序列的离散表示形式，该对象充当以一定间隔进入应用程序的信息源。 <br><br> 在为小型企业设计在线银行的Web界面示例中考虑使用库的功能。 开发UI时，我们将Google Angular 6平台与内置的RxJs库版本6配合使用。 <br><br><h3> 响应式UI设计任务 </h3><br> 对于用户而言，Internet Bank中的大多数操作通常分为三个阶段： <br><br><ul><li> 从列表中选择必要的操作，例如偿还贷款或补充帐户； </li><li> 相应表格的部分填写（付款明细由组织名称或用户输入的收款人姓名自动填写）； </li><li> 使用SMS消息或电子签名自动确认操作。 </li></ul><br> 从开发人员的角度来看，这些阶段的实现包括以下任务的解决方案： <br><br><ul><li> 检查苏格兰皇家银行系统的状况，确保数据与清单中各项业务的相关性； </li><li> 填写表单时，对数据流进行异步处理，包括用户输入并从信息消息服务（例如，银行的名称，TIN和BIC）接收的数据； </li><li> 确认填写的表格； </li><li> 自动保存表格中的数据。 </li></ul><br><h3> 检查RBS系统的状态 </h3><br> 从RB系统获取相关数据的过程（例如，有关信贷额度或付款订单状态的信息）包括两个阶段： <br><br><ul><li> 检查数据可用性状态； </li><li> 接收更新的数据。 </li></ul><br> 要检查数据的当前状态，请在一定时间段内向系统的API发出请求，直到收到有关数据就绪的响应为止 <br><br>  RB系统有几种可能的答案： <br><br><ul><li>  {empty：true}-数据尚未准备好； </li><li> 客户端可以接收更新的数据； </li></ul><br><pre><code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">empty</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-comment"><span class="hljs-comment">// -   }</span></span></code> </pre> <br><ul><li> 一个错误。 </li></ul><br> 结果，获得相关数据的形式为： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MIN_TIME = <span class="hljs-number"><span class="hljs-number">2000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MAX_TIME = <span class="hljs-number"><span class="hljs-number">60000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> EXP_BASE = <span class="hljs-number"><span class="hljs-number">1.4</span></span>; request() <span class="hljs-comment"><span class="hljs-comment">//     .pipe( expand((response, index) =&gt; { const delayTime = Math.min(MIN_TIME * Math.pow(EXP_BASE, index), MAX_TIME); return response.empty ? request().pipe(delay(delayTime)) : EMPTY; }), last() ) .subscribe((response) =&gt; { /** -  */ });</span></span></code> </pre><br><br> 让我们逐步分析： <br><br><ol><li> 我们发送一个请求。 要求（） </li><li> 答案就扩大了。  Expand是一个RxJS语句，它为内部和外部Observable的每个下一个警报递归地在其块中重复代码，直到线程宣布成功完成为止。 因此，为了完成流程，有必要返回这样一个Observable，以便没有单个next-EMPTY。 </li><li> 如果响应为{empty：true}，那么我们会在一定的时间延迟（delayTime）之后发出第二个请求。 为了不使服务器超载请求，我们为每个新请求增加了ping的时间间隔。 </li><li> 如果在下一个请求期间有其他响应，请停止ping（返回EMPTY）并将最后一个请求的结果返回给订户（last（）运算符）。 </li><li> 收到答案后，我们将得到结果并进行处理。 表单的对象将进入subscribe： </li></ol><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">empty</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-comment"><span class="hljs-comment">// -   }</span></span></code> </pre><br><br><h3> 反应形式 </h3><br> 考虑使用来自Angular框架的ReactiveForms库设计付款文档的反应式Web表单的任务。 <br><br> 库FormControl，FormGroup和FormArray的三个基类允许您使用对表单字段的声明性描述，设置字段的初始值以及为每个字段设置验证规则： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.myForm = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FormGroup({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FormControl(<span class="hljs-string"><span class="hljs-string">''</span></span>, Validators.required), <span class="hljs-comment"><span class="hljs-comment">//          surname: new FormControl('') });</span></span></code> </pre><br><br> 对于具有大量字段的表单，习惯上使用FormBuilder服务，该服务允许您使用更紧凑的代码来创建它们 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.myForm = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fb.group({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: [<span class="hljs-string"><span class="hljs-string">''</span></span>, Validators.required], <span class="hljs-attr"><span class="hljs-attr">surname</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> });</code> </pre><br><br> 在付款订单页面的模板中创建表单后，只需指定指向myForm表单的链接，以及其字段名称和姓氏的名称 <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">form</span></span></span><span class="hljs-tag"> [</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">formGroup</span></span></span><span class="hljs-tag">]=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"myForm"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">label</span></span></span><span class="hljs-tag">&gt;</span></span>Name: <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">formControlName</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"name"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">label</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">label</span></span></span><span class="hljs-tag">&gt;</span></span>Surname: <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">formControlName</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"surname"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">label</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">form</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br> 最终的设计使您可以根据用户输入并基于应用程序的业务逻辑来生成和跟踪通过表单字段传递的任何信息流。 为此，只需订阅由ValueChanges表单的异步观察器生成的事件 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.myForm.valueChanges .subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> { … <span class="hljs-comment"><span class="hljs-comment">//     })</span></span></code> </pre><br><br> 假设业务逻辑定义了当用户输入收件人的TIN或组织名称时自动填写付款目的地详细信息的要求。 用户在组织的TIN /名称中输入的数据处理代码如下所示： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.payForm.valueChanges .pipe( mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getRequisites(value)) <span class="hljs-comment"><span class="hljs-comment">//       ) .subscribe(requisites =&gt; { this.patchFormByRequisites(requisites) //        })</span></span></code> </pre><br><br><h3> 验证方式 </h3><br> 验证器有两种形式： <br><br><ul><li> 同步 </li><li> 异步的。 </li></ul><br> 我们经常遇到同步验证器-这些功能在处理字段时会检查输入的数据。 就反应形式而言： <br>  “同步验证器是一种采用控制形式的函数，如果有错误，则返回真实值，否则返回虚假值。” <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">customValidator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">control</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> isInvalid(control.value) ? { <span class="hljs-attr"><span class="hljs-attr">code</span></span>: <span class="hljs-string"><span class="hljs-string">"mistake"</span></span>, <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-string"><span class="hljs-string">"smth wents wrong"</span></span> } : <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre><br><br> 我们将实现一个验证器，该验证器将检查用户是否以一系列文件的形式指示了护照（如果护照先前已被用作身份证明文件的类型）： <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requredSeria</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">control</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> docType = control.parent.get(<span class="hljs-string"><span class="hljs-string">"docType"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> error = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (docType &amp;&amp; docType.value === <span class="hljs-string"><span class="hljs-string">"passport"</span></span> &amp;&amp; !control.value) { error = { <span class="hljs-attr"><span class="hljs-attr">code</span></span>: <span class="hljs-string"><span class="hljs-string">"wrongSeria"</span></span>, <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-string"><span class="hljs-string">"  "</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> error; }</code> </pre><br><br> 在这里，我们还引用父表单，并使用它来获取另一个字段的值。 可以返回true作为错误，但是在这种情况下，它决定执行其他操作。 您可以在控件或窗体的错误字段中捕获这些错误消息。 如果该字段具有多个验证器，则可以确切指定哪些验证器未能显示所需的错误消息或调整其他字段的验证。 <br><br> 验证器将添加到表单中，如下所示： <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.documentForm = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fb.group({ <span class="hljs-attr"><span class="hljs-attr">docType</span></span>: [<span class="hljs-string"><span class="hljs-string">''</span></span>, Validators.required], <span class="hljs-attr"><span class="hljs-attr">seria</span></span>: [<span class="hljs-string"><span class="hljs-string">''</span></span>, requredSeria], <span class="hljs-attr"><span class="hljs-attr">number</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> });</code> </pre><br><br> 开箱即用，也可以使用几个常见的验证器。 它们全部由Validators类的静态方法表示。 也有一些组成验证器的方法。 <br> 一个字段的不正确会立即导致整个表单的无效。 如果表单中至少有一个无效字段，则需要停用某个“确定”按钮时可以使用此方法。 然后全部归结为检查一个条件“ myform.invalid”，如果表单无效，则返回true。 <br><br> 异步验证器有一个区别-返回值​​的类型。 真实值或虚假值必须在承诺或可观察值中传递。 <br><br> 每个控件或每个窗体都有一个状态（mySuperForm.status），可以是“ VALID”，“ INVALID”，“ DISABLED”。 由于使用异步验证器时可能不清楚表单当前处于何种状态，因此存在特殊状态“ PENDING”。 由于这种情况（mySuperForm.status ===“ PENDING”），您可以显示预加载器或进行任何其他表单样式设置。 <br><br><h3> 自动保存 </h3><br> 银行软件（软件）的开发涉及使用各种标准文档。 例如，这些是申请表或调查表，可以包含数十个必填字段。 在处理大量文档时，需要自动保存支持才能为用户带来更多便利，因此，如果您失去Internet连接或其他技术问题，则用户先前输入的数据将保留在服务器上的草稿版本中。 <br><br> 这是客户端-服务器体系结构的自动保存过程的主要方面： <br><br><ol><li> 服务器必须按照更改的顺序处理保存请求。 如果您立即向每个更改发送请求，则不能保证之前的请求不会再出现并且不会覆盖新的更改。 </li><li> 在用户完成输入之前，没有必要向服务器发送大量请求，这足以通过计时来完成。 </li><li> 如果已经进行了一些较大延迟的更改，并且尚未返回对第一个更改的请求，则无需在第一个请求返回时立即为每个后续更改发送请求。 您只能使用后者，以免发送无关的数据。 </li></ol><br> 第一种情况可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">concatMap</a>运算符轻松处理。 使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">debounceTime</a>可以解决第二种情况，而不会出现任何问题。 第三种逻辑可描述为： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> lastRequest$ = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BehaviorSubject(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   queue$.subscribe(lastRequest$); queue$ .pipe( debounceTime(1000), exaustMap(request$ =&gt; request$.pipe( //  ,     map(response =&gt; ({request$, response})), //       catchError(() =&gt; of(null) //   ) ) .subscribe(({request$, response}) =&gt; { if (lastRequest$.value !== request$) { queue$.next(lastRequest$.value); //     } });</span></span></code> </pre><br><br> 它保留在saveQueue $中以发送请求。 请注意，存在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">exaustMap</a>运算符而不是concatMap。 该操作员必须忽略外部Observable的所有通知，直到内部Observable完成其观察（“已编译”）为止。 但是在我们的情况下，如果在请求期间将有新的通知队列，我们​​必须采用最后一个通知，并丢弃其余的通知。  exaustMap将删除所有内容，包括最后一个。 因此，我们将最后一个通知保存在BehaviorSubject中，并在预订中，如果当前已完成的请求与最后一个请求不同，则将最后一个请求再次放入队列。 <br><br> 还值得注意的是，忽略了使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">catchError语句</a>实现的查询过程中的错误。 您可以编写更复杂的错误处理，并向用户发送保存时发生错误的通知。 但是其实质是，当流中发生错误时，不应关闭流，就像发生错误和完整通知时一样。 <br><br><h3> 结论 </h3><br> 使用RxJS库的当今响应式编程技术的开发水平，使您可以为在线银行系统创建完整的客户端应用程序，而无需花费额外的人力来组织与远程银行系统的高负载接口的交互。 <br><br> 初次接触RxJS甚至可以吓an那些面临实现设计模式“观察者”的库“复杂性”的经验丰富的开发人员。 但是，也许克服了这些困难，将来，RxJS将成为实时解决异构数据流异步处理问题中必不可少的工具。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN425897/">https://habr.com/ru/post/zh-CN425897/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN425883/index.html">全职</a></li>
<li><a href="../zh-CN425887/index.html">这是第九代英特尔酷睿</a></li>
<li><a href="../zh-CN425889/index.html">十月IT活动摘要（第二部分）</a></li>
<li><a href="../zh-CN425891/index.html">3D总线-一种有前途的计算系统架构</a></li>
<li><a href="../zh-CN425893/index.html">“ Flutter开始吸引社区，但尚未吸引客户”：Paulina Szklarska访谈</a></li>
<li><a href="../zh-CN425899/index.html">蚂蚁山还是堡垒？ 我要以公寓价格建造房屋。 1部分</a></li>
<li><a href="../zh-CN425901/index.html">Arduino上的气象站，从A到Z。第1部分</a></li>
<li><a href="../zh-CN425903/index.html">假期来了：SCRF将868 MHz的ISM频段提高了一倍</a></li>
<li><a href="../zh-CN425905/index.html">如何用重叠的指令编写汇编代码（另一种混淆字节码的技术）</a></li>
<li><a href="../zh-CN425907/index.html">我们正在用Python做一个机器学习项目。 第二部分</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>