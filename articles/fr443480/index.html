<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèª üçó üßëüèΩ‚Äçü§ù‚Äçüßëüèº Jetons cryptographiques PKCS # 11: affichage et exportation de certificats, v√©rification de leur validit√© ‚èÆÔ∏è üïü üê©</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans les commentaires de l'article ¬´Un utilitaire multiplateforme anglophone pour visualiser les certificats x509 qualifi√©s russes¬ª, un utilisateur de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jetons cryptographiques PKCS # 11: affichage et exportation de certificats, v√©rification de leur validit√©</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443480/"><img src="https://habrastorage.org/webt/jg/xr/s2/jgxrs2y4nfsgsn6ljt8l0wpevgy.png" align="left" alt="image">  Dans les commentaires de l'article ¬´Un utilitaire multiplateforme anglophone pour visualiser les certificats x509 qualifi√©s russes¬ª, un utilisateur de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Pas</a> souhaitait non seulement ¬´l'analyse syntaxique des certificats¬ª, mais √©galement recevoir des ¬´cha√Ænes de certificats racine et effectuer une validation PKI, au moins pour les certificats avec des jetons avec une cl√© extractible ".  L'obtention d'une cha√Æne de certificats a √©t√© d√©crite dans l'un des articles pr√©c√©dents.  Certes, il s'agissait de certificats stock√©s dans des fichiers, mais nous avons promis d'ajouter des m√©canismes pour travailler avec des certificats stock√©s sur des jetons PKCS # 11.  Et c'est ce qui s'est finalement produit. <a name="habracut"></a><br><br><img src="https://habrastorage.org/webt/cg/vd/fw/cgvdfwfqdxc1tbvkkpcec_vzye8.png"><br><br>  L'utilitaire d'analyse et de visualisation est √©crit en Tcl / Tk, et pour y ajouter des jetons / cartes √† puce PKCS # 11, afficher les certificats ainsi que v√©rifier la validit√© des certificats, il √©tait n√©cessaire de r√©soudre plusieurs probl√®mes: <br><br><ul><li>  d√©terminer le m√©canisme d'obtention des certificats √† partir du jeton / de la carte √† puce; </li><li>  v√©rifier le certificat par rapport √† la liste des certificats CRL r√©voqu√©s; </li><li>  v√©rifier le certificat de validit√© par le m√©canisme OCSP. </li></ul><br><h3>  <font color="#0000ff">Acc√®s au jeton PKCS # 11</font> </h3><br>  Pour acc√©der au jeton et aux certificats qui y sont stock√©s, nous utiliserons le package <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">TclPKCS11</a> .  Le package est distribu√© √† la fois en binaires et en codes sources.  Les codes sources seront utiles plus tard lorsque nous ajouterons la prise en charge des jetons avec la cryptographie russe au package.  Il existe deux fa√ßons de t√©l√©charger le package TclPKCS11 ou d'utiliser la commande tcl du formulaire: <br><br><pre><code class="plaintext hljs">load &lt; tclpkcs11&gt; Tclpkcs11</code> </pre> <br>  Ou t√©l√©chargez-le simplement en tant que package pki :: pkcs11, apr√®s avoir plac√© la biblioth√®que tclpkcs11 et le fichier pkgIndex.tcl dans un r√©pertoire qui vous convient (dans notre cas, c'est le sous-r√©pertoire pkcs11 du r√©pertoire actuel) et en l'ajoutant au chemin auto_path: <br><br><pre> <code class="plaintext hljs">#lappend auto_path [file dirname [info scrypt]] lappend auto_path pkcs11 package require pki package require pki::pkcs11</code> </pre> <br>  Puisque nous sommes int√©ress√©s par les jetons principalement avec le support de la cryptographie russe, √† partir du package TclPKCS11, nous utiliserons les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fonctions</a> suivantes: <br><blockquote><pre> <code class="plaintext hljs">::pki::pkcs11::loadmodule &lt;filename&gt; -&gt; handle ::pki::pkcs11::unloadmodule &lt;handle&gt; -&gt; true/false ::pki::pkcs11::listslots &lt;handle&gt; -&gt; list: slotId label flags ::pki::pkcs11::listcerts &lt;handle&gt; &lt;slotId&gt; -&gt; list: keylist ::pki::pkcs11::login &lt;handle&gt; &lt;slotId&gt; &lt;password&gt; -&gt; true/false ::pki::pkcs11::logout &lt;handle&gt; &lt;slotId&gt; -&gt; true/false</code> </pre> </blockquote>  R√©servez imm√©diatement que les fonctions de connexion et de d√©connexion ne seront pas prises en compte ici.  Cela est d√ª au fait que dans cet article, nous ne traiterons que des certificats, et ce sont des objets √† jeton public.  Pour acc√©der aux objets publics, il n'est pas n√©cessaire de se connecter via le code PIN sur le token. <br><br>  La premi√®re fonction :: pki :: pkcs11 :: loadmodule consiste √† charger la biblioth√®que PKCS # 11, qui prend en charge le jeton / la carte √† puce sur laquelle se trouvent les certificats.  Une biblioth√®que peut √™tre obtenue soit en achetant un jeton, soit t√©l√©charg√©e sur Internet, soit pr√©install√©e sur un ordinateur.  Dans tous les cas, vous devez savoir quelle biblioth√®que prend en charge votre jeton.  La fonction loadmodule renvoie un handle vers la biblioth√®que charg√©e: <br><br><pre> <code class="plaintext hljs">set filelib "/usr/local/lib64/librtpkcs11ecp_2.0.so" set handle [::pki::pkcs11::loadmodule $filelib]</code> </pre> <br>  En cons√©quence, il existe une fonction pour d√©charger une biblioth√®que charg√©e: <br><br><pre> <code class="plaintext hljs">::pki::pkcs11::unloadmodule $handle</code> </pre> <br>  Une fois que la biblioth√®que a √©t√© charg√©e et que nous avons sa poign√©e, vous pouvez obtenir une liste des emplacements pris en charge par cette biblioth√®que: <br><br><pre> <code class="plaintext hljs">::pki::pkcs11::listslots $handle {0 {ruToken ECP } {TOKEN_PRESENT RNG LOGIN_REQUIRED USER_PIN_INITIALIZED TOKEN_INITIALIZED REMOVABLE_DEVICE HW_SLOT}} {1 { } {REMOVABLE_DEVICE HW_SLOT}} . . . {14 { } {REMOVABLE_D EVICE HW_SLOT}}</code> </pre> <br>  Dans cet exemple, la liste contient 15 (quinze de 0 √† 14) √©l√©ments.  C'est le nombre d'emplacements que la famille de jetons RuToken peut prendre en charge.  √Ä son tour, chaque √©l√©ment de la liste elle-m√™me est une liste de trois √©l√©ments: <br><br><pre> <code class="plaintext hljs">{{ } { } {   }}</code> </pre> <br>  Le premier √©l√©ment de la liste est le num√©ro d'emplacement.  Le deuxi√®me √©l√©ment de la liste est l'√©tiquette situ√©e dans l'emplacement de jeton (32 octets).  Si l'emplacement est vide, le deuxi√®me √©l√©ment contient 32 espaces.  Et le dernier, troisi√®me √©l√©ment de la liste contient des drapeaux.  Nous ne consid√©rerons pas l'ensemble des drapeaux.  Ce qui nous int√©resse dans ces drapeaux, c'est la pr√©sence du drapeau TOKEN_PRESENT.  C'est ce drapeau qui indique que le jeton est dans la fente, et les certificats qui nous int√©ressent peuvent √™tre sur le jeton.  Les drapeaux sont tr√®s utiles, ils d√©crivent l'√©tat du jeton, l'√©tat des codes PIN, etc.  En fonction de la valeur des indicateurs, les jetons PKCS # 11 sont g√©r√©s: <br><br><img src="https://habrastorage.org/webt/yq/7x/n1/yq7xn1qbusjtjirrudo1ebhjzhc.png"><br><br>  Maintenant, rien ne vous emp√™che d'√©crire la proc√©dure slots_with_token, qui renverra une liste d'emplacements avec les √©tiquettes des jetons: <br><br><pre> <code class="plaintext hljs">#!/usr/bin/tclsh lappend auto_path pkcs11 package require pki package require pki::pkcs11 #    proc ::slots_with_token {handle} { set slots [pki::pkcs11::listslots $handle] # puts "Slots: $slots" array set listtok [] foreach slotinfo $slots { set slotid [lindex $slotinfo 0] set slotlabel [lindex $slotinfo 1] set slotflags [lindex $slotinfo 2] if {[lsearch -exact $slotflags TOKEN_PRESENT] != -1} { set listtok($slotid) $slotlabel } } #     parray listtok return [array get listtok] } set filelib "/usr/local/lib64/librtpkcs11ecp_2.0.so" if {[catch {set handle [::pki::pkcs11::loadmodule $filelib]} res]} { puts "Cannot load library $filelib : $res" exit } #   set listslots {} set listslots [::slots_with_token $handle] #        while {[llength $listslots] == 0} { puts " " after 3000 set listslots [::slots_with_token $handle] } #        foreach {slotid labeltok} $listslots { puts "Number slot: $slotid" puts "Label token: $labeltok" }</code> </pre> <br>  Si vous ex√©cutez ce script, apr√®s l'avoir enregistr√© dans le fichier slots_with_token.tcl, alors nous obtenons: <br><br><pre> <code class="bash hljs">$ ./slots_with_token.tcl listtok(0) = ruToken ECP listtok(1) = RuTokenECP20 Number slot: 0 Label token: RuTokenECP20 Number slot: 1 Label token: ruToken ECP $</code> </pre> <br>  Sur les 15 emplacements disponibles pour cette biblioth√®que, seuls deux sont impliqu√©s, z√©ro et le premier. <br>  Maintenant, rien n'emp√™che d'obtenir une liste de certificats situ√©s sur un jeton particulier: <br><br><pre> <code class="plaintext hljs">set listcerts [::pki::pkcs11::listcerts $handle $slotid]</code> </pre> <br>  Chaque √©l√©ment de la liste contient des informations sur un certificat.  Pour obtenir des informations du certificat, la fonction :: pki :: pkcs11 :: listcerts utilise la fonction :: pki :: x509 :: parse_cert du package pki.  Mais la fonction :: pki :: pkcs11 :: listcerts compl√®te cette liste avec des donn√©es inh√©rentes au protocole PKCS # 11, √† savoir: <br><br><ul><li>  √©l√©ment d'√©tiquette pkcs11_ (dans la terminologie de l'attribut PKCS # 11 CKA_LABEL); </li><li>  √©l√©ment pkcs11_id (dans la terminologie de l'attribut PKCS # 11 CKA_ID); </li><li>  √©l√©ment pkcs11_handle contenant une indication de la biblioth√®que PKCS # 11 charg√©e; </li><li>  √©l√©ment pkcs11_slotid contenant le num√©ro de l'emplacement avec le jeton sur lequel se trouve ce certificat; </li><li>  un √©l√©ment type qui contient la valeur pkcs11 pour le certificat qui se trouve sur le jeton. </li></ul><br>  Rappelons que les √©l√©ments restants sont principalement d√©termin√©s par la fonction pki :: parse_cert. <br>  Voici la proc√©dure pour obtenir une liste d'√©tiquettes (listCert) de certificats (CKA_LABEL, pkcs11_label) et un tableau d'identificateurs analys√©s (:: certs_p11).  La cl√© pour acc√©der √† l'√©l√©ment du tableau de certificats est l'√©tiquette de certificat (CKA_LABEL, pkcs11_label): <br><br><pre> <code class="plaintext hljs">#  proc listcerttok {handle token_slotlabel token_slotid} { #     set listCer {} #   array set ::arrayCer [] set ::certs_p11 [pki::pkcs11::listcerts $handle $token_slotid] if {[llength $::certs_p11] == 0} { puts {Certificates are not on the token:$tokenslotlabel} return $listCer } foreach certinfo_list $::certs_p11 { unset -nocomplain certinfo array set certinfo $certinfo_list set certinfo(pubkeyinfo) [::pki::x509::parse_cert_pubkeyinfo $certinfo(cert)] set ::arrayCer($certinfo(pkcs11_label)) $certinfo(cert) lappend listCer $certinfo(pkcs11_label) } return $listCer }</code> </pre> <br>  Et maintenant que nous avons analys√© les certificats, nous affichons tranquillement une liste de leurs √©tiquettes dans la zone de liste d√©roulante: <br><br><img src="https://habrastorage.org/webt/wd/7_/si/wd7_siithrzlh1gfwa5tm78rpbg.png"><br><br>  Comment analyser les cl√©s publiques GOST que nous avons examin√©es dans l'article pr√©c√©dent. <br><br>  Deux mots sur l'exportation de certificats.  Les certificats sont export√©s √† la fois en encodage PEM et en encodage DER (boutons DER, format PEM).  Le paquet pki a une fonction pratique pki :: _ encode_pem pour la conversion au format PEM: <br><br><pre> <code class="plaintext hljs">set bufpem [::pki::_encode_pem &lt;der-buffer&gt; &lt;Headline&gt; &lt;Lastline&gt;]</code> </pre> <br>  par exemple: <br><br><pre> <code class="plaintext hljs">set certpem [::pki::encode_pen $cert_der "-----BEGIN CERTIFICATE-----" "-----END CERTIFICATE-----"]</code> </pre> <br>  En s√©lectionnant l'√©tiquette du certificat septique dans la combobox, nous avons acc√®s au corps du certificat: <br><br><pre> <code class="plaintext hljs">#    set nick [.saveCert.labExp.listCert get] #        foreach certinfo_list $::certs_p11 { unset -nocomplain cert_parse array set cert_parse $certinfo_list if {$cert_parse(pkcs11_label) == $nick} { #   set cert_parse(pubkeyinfo) [::pki::x509::parse_cert_pubkeyinfo $cert_parse(cert)] break } } #   file|pkcs11 set ::tekcert "pkcs11"</code> </pre> <br>  Un autre m√©canisme pour analyser le certificat et l'afficher a d√©j√† √©t√© discut√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><h3>  <font color="#0000ff">Validation du certificat</font> </h3><br>  Lors de l'analyse du certificat, les variables :: notbefore et :: notafter stockent la date √† partir de laquelle le certificat peut √™tre utilis√© dans les op√©rations cryptographiques (signer, chiffrer, etc.) et la date d'expiration du certificat.  La proc√©dure de v√©rification de la p√©riode de validit√© d'un certificat est la suivante: <br><br><pre> <code class="plaintext hljs">proc cert_valid_date {} { #       #    set startdate $::notbefore #    set enddate $::notafter #      set now [clock seconds] set isvalid 1 set reason "Certificate is valid" if {$startdate &gt; $now} { set isvalid 0 #      set reason "Certificate is not yet valid" } elseif {$now &gt; $enddate} { set isvalid 0 #    set reason "Certificate has expired" } return [list $isvalid $reason] }</code> </pre> <br>  La liste renvoy√©e contient deux √©l√©ments.  Le premier √©l√©ment peut contenir 0 (z√©ro) ou 1 (un).  Une valeur de ¬´1¬ª indique que le certificat est valide et 0 indique que le certificat n'est pas valide.  La raison pour laquelle le certificat n'est pas valide est indiqu√©e dans le deuxi√®me √©l√©ment.  Cet √©l√©ment peut contenir l'une des trois valeurs: <br><br><ul><li>  certificat valide (le premier √©l√©ment de la liste est 1): </li><li>  le certificat n'est pas encore valide (le certificat n'a pas encore expir√©) </li><li>  le certificat a expir√©. </li></ul><br>  La validit√© du certificat est d√©termin√©e non seulement par sa p√©riode de validit√©.  Le certificat peut √™tre suspendu ou r√©sili√© par le centre de certification, √† la fois de sa propre initiative et √† la demande du titulaire du certificat, par exemple, en cas de perte du support avec la cl√© priv√©e.  Dans ce cas, le certificat est inclus par l'autorit√© de certification dans la liste des certificats COS / CRL r√©voqu√©s qui sont distribu√©s par l'AC.  En r√®gle g√©n√©rale, le point de distribution CRL est inclus dans le certificat.  C'est √† partir de la liste des certificats r√©voqu√©s que la validit√© du certificat est v√©rifi√©e. <br><br><h3>  <font color="#0000ff">Validation de la validit√© du certificat par SOS / CRL</font> </h3><br>  La premi√®re √©tape consiste √† obtenir le SOS, puis √† l'analyser et √† v√©rifier le certificat pour cela. <br>  La liste des points d'√©mission COC / CRL se trouve dans l'extension de certificat avec l'oid 2.5.29.31 (id-ce-cRLDistributionPoints): <br><br><pre> <code class="plaintext hljs">array set extcert $cert_parse(extensions) set ::crlfile "" if {[info exists extcert(2.5.29.31)]} { set ::crlfile [crlpoints [lindex $extcert(2.5.29.31) 1]] } else { puts "cannot load CRL" }</code> </pre> <br>  En fait, le chargement du fichier avec SOS / CRL est le suivant: <br><br><pre> <code class="plaintext hljs">set filecrl "" set pointcrl "" foreach pointcrl $::crlfile { set filecrl [readca $pointcrl $dir] if {$filecrl != ""} { set f [file join $dir [file tail $pointcrl]] set fd [open $fw] chan configure $fd -translation binary puts -nonewline $fd $filecrl close $fd set filecrl $f break } # CRL  .     CRL } if {$filecrl == ""} { puts "Cannot load CRL" }</code> </pre> <br>  En fait, la proc√©dure readca est utilis√©e pour charger le COC / CRL: <br><br><pre> <code class="plaintext hljs">proc readca {url dir} { set cer "" #   if { "https://" == [string range $url 0 7]} { #    tls http::register https 443 ::tls::socket } #     if {[catch {set token [http::geturl $url -binary 1] #    set ere [http::status $token] if {$ere == "ok"} { #        set code [http::ncode $token] if {$code == 200} { #      set cer [http::data $token] } elseif {$code == 301 || $code == 302} { #    ,   set newURL [dict get [http::meta $token] Location] #     set cer [readca $newURL $dir] } else { #    set cer "" } } } error]} { #   ,     set cer "" } return $cer }</code> </pre><br>  La variable dir stocke le chemin d'acc√®s au r√©pertoire dans lequel le COS / CRL sera enregistr√©, et la variable url contient la liste des points de distribution CRL pr√©c√©demment re√ßue. <br><br>  Lors de la r√©ception de SOS / CRL, j'ai soudainement d√ª faire face au fait que pour certains certificats, cette liste devait √™tre re√ßue via le protocole https (tls) en mode anonyme.  Honn√™tement, cela est surprenant: la liste CRL est un document public et son int√©grit√© est prot√©g√©e par une signature √©lectronique et j'y ai acc√®s via https anonyme √† mon avis.  Mais il n'y a rien √† faire, vous devez connecter le paquet tls - le paquet n√©cessite tls. <br><br>  Si SOS / CRL n'a pas pu √™tre t√©l√©charg√©, le certificat ne peut pas √™tre v√©rifi√© si le point d'acc√®s avec le service OCSP n'est pas sp√©cifi√© dans le certificat.  Mais cela sera discut√© dans l'un des articles suivants. <br><br>  Donc, il y a un certificat de v√©rification, il y a une liste de SOS / CRL, il reste √† v√©rifier le certificat.  Malheureusement, il n'y a pas de fonctions correspondantes dans le package pki.  J'ai donc d√ª √©crire une proc√©dure pour v√©rifier la validit√© du certificat (sa non-r√©vocation) √† partir de la liste des certificats r√©voqu√©s <br><br><div class="spoiler">  <b class="spoiler_title">validaty_cert_from_crl:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">proc validaty_cert_from_crl {crl sernum issuer} { array set ret [list] if { [string range $crl 0 9 ] == "-----BEGIN" } { array set parsed_crl [::pki::_parse_pem $crl "-----BEGIN X509 CRL-----" "-----END X509 CRL-----"] set crl $parsed_crl(data) } ::asn::asnGetSequence crl crl_seq ::asn::asnGetSequence crl_seq crl_base ::asn::asnPeekByte crl_base peek_tag if {$peek_tag == 0x02} { #   .CRL ::asn::asnGetInteger crl_base ret(version) incr ret(version) } else { set ret(version) 1 } ::asn::asnGetSequence crl_base crl_full ::asn::asnGetObjectIdentifier crl_full ret(signtype) ::::asn::asnGetSequence crl_base crl_issue set ret(issue) [::pki::x509::_dn_to_string $crl_issue] #     /CRL if {$ret(issue) != $issuer } { #/CRL    set ret(error) "Bad Issuer" return [array get ret] } binary scan $crl_issue H* ret(issue_hex) #  ::asn::asnGetUTCTime crl_base ret(publishDate) #   ::asn::asnGetUTCTime crl_base ret(nextDate) #   ::asn::asnPeekByte crl_base peek_tag if {$peek_tag != 0x30} { #    return [array get ret] } ::asn::asnGetSequence crl_base lcert # binary scan $lcert H* ret(lcert) while {$lcert != ""} { ::asn::asnGetSequence lcert lcerti #    ::asn::asnGetBigInteger lcerti ret(sernumrev) set ret(sernumrev) [::math::bignum::tostr $ret(sernumrev)] #      CRL if {$ret(sernumrev) != $sernum} { continue } # .    ::asn::asnGetUTCTime lcerti ret(revokeDate) if {$lcerti != ""} { #   ::asn::asnGetSequence lcerti lcertir ::asn::asnGetSequence lcertir reasone ::asn::asnGetObjectIdentifier reasone ret(reasone) ::asn::asnGetOctetString reasone reasone2 ::asn::asnGetEnumeration reasone2 ret(reasoneData) } break; } return [array get ret] }</code> </pre></div></div><br>  Les param√®tres de cette fonction sont la liste de r√©vocation de certificats (crl), le num√©ro de s√©rie du certificat en cours de v√©rification (sernum) et son √©diteur (√©metteur). <br><br>  La liste de r√©vocation de certificats (crl) est charg√©e comme suit: <br><br><pre> <code class="plaintext hljs">set f [open $filecrl r] chan configure $f -translation binary set crl [read $f] close $f</code> </pre> <br>  Le num√©ro de s√©rie du certificat v√©rifi√© (sernum) et de son √©diteur (√©metteur) sont extraits du certificat analys√© et stock√©s dans les variables :: sncert et :: issuercert. <br><br>  Toutes les proc√©dures se trouvent dans le code source.  Le code source de l'utilitaire et ses distributions pour Linux, OS X (macOS) et MS Windows peuvent √™tre trouv√©s ici. <br><br><div class="spoiler">  <b class="spoiler_title">ici</b> <div class="spoiler_text"><ul><li>  <a href="">code source</a> </li><li>  <a href="">Linux32</a> </li><li>  <a href="">Linux64</a> </li><li>  <a href="">OS X</a> </li><li>  <a href="">WIN32</a> </li><li>  <a href="">WIN64</a> </li></ul><br></div></div><br>  L'utilitaire conserve √©galement la possibilit√© d'afficher et de v√©rifier les certificats stock√©s dans un fichier: <br><br><img src="https://habrastorage.org/webt/ja/tv/nl/jatvnlolqcsggytw3nn8x51zpls.png"><br><br>  Soit dit en passant, les certificats affich√©s √† partir de fichiers peuvent √©galement √™tre export√©s, ainsi que stock√©s sur un jeton.  Cela facilite la conversion des fichiers de certificat du format DER en PEM et vice versa. <br><br>  Nous avons maintenant une visionneuse unique pour les certificats stock√©s √† la fois dans des fichiers et sur des jetons / cartes √† puce PKCS # 11. <br><br>  Oui, j'ai rat√© le point: pour v√©rifier la validit√© du certificat, cliquez sur le bouton ¬´Additionnel¬ª et s√©lectionnez l'√©l√©ment de menu ¬´Validaty by CRL¬ª ou appuyez sur le bouton droit de la souris et lorsque le curseur est sur les informations principales et s√©lectionnez √©galement l'√©l√©ment de menu ¬´Validaty by CRL¬ª: <br><br><img src="https://habrastorage.org/webt/ig/ph/rm/igphrmcbunw9b8jtkdiepfjaqpm.png"><br><br>  Cette capture d'√©cran montre la navigation et la validation des certificats dans un jeton cloud. <br><br>  En conclusion, nous notons ce qui suit.  Dans ses commentaires sur l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> , l'utilisateur de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Pas a</a> tr√®s correctement not√© √† propos des jetons PKCS # 11 qu'ils ¬´peuvent tout compter eux-m√™mes¬ª.  Oui, les jetons sont en fait des ordinateurs cryptographiques.  Et dans les articles suivants, nous parlerons non seulement de la fa√ßon dont les certificats sont v√©rifi√©s √† l'aide du protocole OCSP, mais √©galement de la fa√ßon d'utiliser les m√©canismes cryptographiques (nous parlons, bien s√ªr, la cryptographie GOST) de jetons / smarts pour calculer le hachage (GOST R 34-10- 94/2012), la formation et la v√©rification des signatures, etc. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr443480/">https://habr.com/ru/post/fr443480/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr443468/index.html">Quels outils de surveillance de r√©seau sont devenus des leaders dans la version de Gartner</a></li>
<li><a href="../fr443470/index.html">L'histoire de la frappe sur l'exemple d'un grand projet</a></li>
<li><a href="../fr443472/index.html">Vous avez un probl√®me pour acc√©der au cloud? 7 conseils pour ne pas g√¢cher</a></li>
<li><a href="../fr443476/index.html">Comment SimCity a inspir√© toute une g√©n√©ration d'urbanistes</a></li>
<li><a href="../fr443478/index.html">Donn√©es de test synth√©tiques vs r√©elles: avantages, inconv√©nients, pi√®ges</a></li>
<li><a href="../fr443482/index.html">AIOps en pratique - que peut Huawei FabricInsight</a></li>
<li><a href="../fr443484/index.html">6 hommes inattendus de Julia</a></li>
<li><a href="../fr443486/index.html">ReLEx SMILE: Comment ne pas se tromper de pr√©visions</a></li>
<li><a href="../fr443490/index.html">Pourquoi suis-je en train de r√©duire mon travail sur Debian</a></li>
<li><a href="../fr443492/index.html">Un jeu pour les amoureux et les experts sur Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>