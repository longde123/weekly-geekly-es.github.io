<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëêüèº üì¢ üôèüèº Unduh konfigurasi ke FPGA melalui USB atau bongkar FTDI MPSSE ü§∏üèª ü§±üèæ üìº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam kehidupan setiap laci, ada saatnya ketika Anda ingin menulis loader Anda sendiri dari file konfigurasi di FPGA. Saya harus berpartisipasi dalam ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unduh konfigurasi ke FPGA melalui USB atau bongkar FTDI MPSSE</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426131/"><img src="https://habrastorage.org/webt/dx/i7/px/dxi7pxs820_gc9p_q_1m6zoaakm.jpeg"><br><br>  Dalam kehidupan setiap laci, ada saatnya ketika Anda ingin menulis loader Anda sendiri dari file konfigurasi di FPGA.  Saya harus berpartisipasi dalam pengembangan stan pelatihan untuk departemen universitas teknis.  Dudukan dirancang untuk mempelajari pemrosesan sinyal digital, meskipun ini tidak terlalu penting dalam rangka artikel ini.  Dan yang penting adalah bahwa FPGA (Altera Cyclone IV) adalah jantung dari stan, di mana siswa mengumpulkan semua jenis skema DSP, seperti yang dikandung oleh penulis stan.  Dudukan terhubung ke komputer melalui USB.  Anda perlu mengunduh FPGA dari komputer melalui USB. <br><p>  Keputusan dibuat untuk terhubung ke PC menggunakan FTDI dalam inkarnasi dual-channel - FT2232H.  Satu saluran akan digunakan untuk konfigurasi FPGA, yang lain dapat digunakan untuk pertukaran FIFO kecepatan tinggi. </p><a name="habracut"></a><br><p>  FTDI memiliki papan debug <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MORPH-IC-II</a> , di mana FPGA Cyclone II di- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">flash</a> melalui USB.  Konsep dalam domain publik.  Kode sumber bootloader sebagian terbuka: bootloader itu sendiri tersedia, namun, semua logika bekerja dengan FTDI dipindahkan ke perpustakaan pribadi dan tidak dapat dimodifikasi.  Sebenarnya, saya awalnya berencana untuk menggunakan bootloader ini di proyek saya, atau, dalam kasus ekstrim, membuat shell saya berdasarkan dll.  Firmware dimuat ke dalam FPGA dalam mode serial pasif (pasif serial - PS), FTDI beroperasi dalam mode MPSSE.  Di papan tempat memotong roti, kinerja solusi MORPH-IC-II sepenuhnya dikonfirmasi, tetapi masalahnya, seperti yang sering terjadi, tidak datang dari mana.  Ternyata selama pengoperasian dll MORPH-IC-II, semua perangkat FTDI yang terhubung diblokir, dan sebagai bagian dari kompleks pelatihan ada dua perangkat lagi dengan konverter yang sama: generator dan penganalisa sinyal.  Bekerja serentak dengan mereka tidak mungkin.  Sangat aneh dan menyebalkan. </p><br><p>  Kasus serupa diimplementasikan oleh orang-orang dari penjelajah Mars: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">programmer USB JTAG MBFTDI</a> .  FTDI juga digunakan di sana dalam mode MPSSE, tetapi tidak seperti MORPH-IC-II, operasi FPGA dilakukan dalam mode JTAG.  Sumber tersedia secara bebas, tetapi saya tidak menemukan indikasi yang jelas tentang status mereka (lisensi).  Karena itu, untuk menggunakannya dalam proyek komersial, tangan saya tidak naik. </p><br><p>  Saya akan memperbaiki kesalahan semacam itu, semua yang akan disajikan dalam kerangka artikel ini diposting di repositori terbuka di bawah lisensi BSD. </p><br><h2 id="zagruzka-fayla-konfiguracii-v-mikroshemu-plis">  Unduh file konfigurasi ke chip FPGA </h2><br><p>  Pertama-tama, Anda harus berurusan dengan mode boot FPGA.  Bagi mereka yang baru mulai berkenalan dengan topik, saya akan memberikan perjalanan kecil.  Meskipun Altera (Intel) FPGA dari keluarga Cyclone IV E dipasang di papan saya, metode pemuatan serupa untuk seluruh grup FPGA Cyclone, dan ada kecurigaan bahwa dalam satu atau lain bentuk mereka cocok untuk banyak keluarga lainnya. </p><br><p>  Jenis FPGA ini menggunakan SRAM yang mudah menguap untuk menyimpan data konfigurasi.  Data konfigurasi ini menentukan fungsionalitas perangkat yang dihasilkan.  Dalam jargon profesional, data ini sering disebut "firmware."  Dengan demikian, firmware disimpan dalam RAM khusus dan setiap kali perangkat dihidupkan, harus dimuat ke dalam chip FPGA.  Ada beberapa cara (skema konfigurasi) dimana firmware dapat dimuat ke SRAM (daftar ini relevan untuk Cyclone IV E): </p><br><ol><li>  Serial aktif (AS). </li><li>  Paralel aktif (AP) </li><li>  Serial pasif (PS) </li><li>  Paralel cepat pasif (FPP). </li><li>  JTAG. </li></ol><br><p>  Pilihan mode boot tertentu dilakukan menggunakan terminal eksternal FPGA (grup MSEL).  Mode JTAG selalu tersedia.  Mode aktif menyiratkan bahwa ketika daya diterapkan, FPGA secara mandiri membaca data dari memori eksternal (serial atau paralel).  Dalam mode pasif, FPGA menunggu media eksternal untuk secara proaktif mentransfer data konfigurasi ke dalamnya.  Skema ini sangat cocok dengan konsep master (master) - slave (Slave).  Dalam mode aktif, FPGA bertindak sebagai master, dan dalam mode pasif sebagai budak. </p><br><p>  Dalam masalah ini, ini bukan FPGA, tetapi pengguna harus memutuskan kapan firmware harus diperbarui, sehingga mode boot harus pasif.  Dan untuk menghemat kaki chip, kami memilih antarmuka serial.  Mode Passive Serial (PS) dan JTAG cocok di sini.  Logika JTAG agak lebih rumit, jadi mari kita fokus pada opsi pertama. <br>  Gambar di bawah ini menunjukkan skema koneksi FPGA ke pengontrol eksternal untuk mengunduh dalam mode PS. </p><br><img width="400" src="https://habrastorage.org/webt/q-/rj/pe/q-rjpeqe5y8ojlu8ywedoejklxq.png"><br><p>  Untuk memulai konfigurasi, master eksternal harus menghasilkan transisi rendah ke tinggi pada baris <em>nCONFIG</em> .  Segera setelah FPGA siap menerima data, FPGA itu akan membentuk level tinggi di jalur <em>nSTATUS</em> .  Setelah itu, master dapat mulai mentransmisikan data pada garis <em>DATA [0]</em> , dan clock yang sesuai berdenyut pada jalur <em>DCLK</em> .  Data harus ditransmisikan ke perangkat target hingga level tinggi ditetapkan pada garis <em>CONF_DONE</em> (atau data tidak berakhir), dan FPGA beralih ke status inisialisasi.  Perlu dicatat bahwa setelah <em>CONF_DONE</em> diatur ke satu, dua pulsa clock harus diterapkan sehingga inisialisasi FPGA dimulai. </p><br><p>  Data ditransmisikan oleh bit paling signifikan ( <abbr title="Sedikit tidak signifikan">LSB</abbr> ) ke depan, yaitu, jika file konfigurasi berisi urutan 02 1B EE 01 FA (ambil contoh seperti dari Buku Pegangan), urutan harus dibentuk pada baris data: </p><br><pre><code class="hljs powershell"><span class="hljs-number"><span class="hljs-number">0100</span></span><span class="hljs-literal"><span class="hljs-literal">-0000</span></span> <span class="hljs-number"><span class="hljs-number">1101</span></span><span class="hljs-literal"><span class="hljs-literal">-1000</span></span> <span class="hljs-number"><span class="hljs-number">0111</span></span><span class="hljs-literal"><span class="hljs-literal">-0111</span></span> <span class="hljs-number"><span class="hljs-number">1000</span></span><span class="hljs-literal"><span class="hljs-literal">-0000</span></span> <span class="hljs-number"><span class="hljs-number">0101</span></span><span class="hljs-literal"><span class="hljs-literal">-1111</span></span></code> </pre> <br><p>  Dengan demikian, hanya lima jalur yang digunakan: jalur <em>DATA [0]</em> dan <em>DCLK</em> untuk transmisi serial, <em>nCONFIG</em> , <em>nSTATUS</em> , <em>jalur</em> <em>CONF_DONE</em> untuk kontrol. <br>  Pada intinya, mode PS tidak lebih dari SPI dengan manipulasi flag tambahan. <br>  Kecepatan transfer data harus lebih rendah daripada frekuensi maksimum yang ditunjukkan dalam dokumentasi, untuk seri Cyclone IV E yang digunakan dalam proyek, itu adalah 66 MHz. </p><br><p>  Frekuensi transmisi minimum tidak ada, secara teori dimungkinkan untuk menangguhkan konfigurasi untuk waktu yang tidak terbatas.  Ini memberikan peluang bagus untuk debugging langkah demi langkah dengan partisipasi osiloskop, yang tentunya akan kita gunakan. </p><br><p>  Gambar di bawah ini menunjukkan diagram waktu antarmuka dengan timing yang paling signifikan. </p><br><img width="720" src="https://habrastorage.org/webt/54/et/uy/54etuy0yva1est_qtdqp9yopqj8.png"><br><h2 id="hitryy-zver-mpsse">  Sly Beast MPSSE </h2><br><p>  Pertimbangkan pengoperasian FTDI dalam mode MPSSE.  Mode MPSSE (Multi-Protocol Synchronous Serial Engine), menurut pendapat saya, adalah upaya yang kurang lebih berhasil untuk membuat desainer antarmuka serial tertentu, untuk memberikan pengembang kesempatan untuk mengimplementasikan protokol transfer data yang tersebar luas, seperti SPI, I2C, JTAG, 1-kawat dan banyak yang lain berdasarkan pada mereka. </p><br><p>  Saat ini, mode tersedia untuk sirkuit mikro: FT232H, FT2232D, FT2232H, FT4232H.  Dalam proyek saya, saya menggunakan FT2232H, jadi sebagian besar kita membicarakannya.  Untuk mode MPSSE, 16 kaki dialokasikan, dibagi menjadi dua byte: L lebih rendah dan H. tertinggi. Setiap byte dapat dibaca atau diatur.  Empat kaki bagian bawah byte L memiliki fungsi khusus - transmisi data serial dapat terjadi melalui mereka.  Setiap leg dapat dikonfigurasi sebagai input atau output, nilai default dapat diatur untuk output.  Untuk transmisi berurutan, urutan bit ( <abbr title="Paling signifikan">MSB</abbr> / <abbr title="Sedikit tidak signifikan">LSB</abbr> ), panjang kata yang ditransmisikan, frekuensi pulsa clock, front-depan sinkronisasi (Naik) atau belakang (Jatuh), Anda dapat memilih untuk mengirimkan pulsa clock saja tanpa data, atau memilih clocking 3 fase (relevan untuk I2C) dan banyak lagi. </p><br><p>  Pindah ke pemrograman dengan mulus.  Ada dua cara alternatif interaksi perangkat lunak dengan chip FTDI: yang pertama, sebut saja klasik, dalam hal ini, ketika terhubung ke port USB, chip dalam sistem didefinisikan sebagai port serial virtual (COM), sistem operasi menggunakan driver VCP (Virtual COM Port).  Semua pemrograman lebih lanjut tidak berbeda dari pemrograman port COM klasik: dibuka - dikirim / dihitung - ditutup.  Dan ini berlaku untuk berbagai sistem operasi, termasuk Linux dan Mac OS.  Namun, dengan pendekatan ini, tidak mungkin untuk mewujudkan semua fitur pengontrol FTDI - chip tersebut akan berfungsi sebagai adaptor USB-UART.  Metode kedua disediakan oleh perpustakaan eksklusif FTD2XX, antarmuka ini menyediakan fungsi-fungsi khusus yang tidak tersedia di API port COM standar, khususnya, dimungkinkan untuk mengkonfigurasi dan menggunakan mode operasi khusus, seperti MPSSE, 245 FIFO, Bit-bang.  Pustaka FTD2XX API didokumentasikan dengan baik oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panduan Pengembangan Aplikasi Perangkat Lunak D2XX Programmer</a> , dikenal luas untuk waktu yang lama dalam lingkaran sempit.  Dan ya, FTD2XX juga tersedia untuk berbagai sistem operasi. </p><br><p>  Pengembang FTDI dihadapkan dengan tugas mengintegrasikan MPSSE yang relatif baru ke dalam model interaksi perangkat lunak D2XX yang ada.  Dan mereka berhasil, untuk bekerja dalam mode MPSSE serangkaian fungsi yang sama digunakan untuk mode "klasik" lainnya, library yang sama API FTD2XX digunakan. </p><br><p>  Singkatnya, algoritma untuk beroperasi dalam mode MPSSE dapat dijelaskan sebagai berikut: </p><br><ol><li>  Temukan perangkat di sistem dan buka. </li><li>  Inisialisasi chip dan masukkan ke mode MPSSE. </li><li>  Atur mode operasi MPSEE. </li><li>  Bekerja langsung dengan data: mengirim, menerima, mengelola GPIO - kami menerapkan protokol pertukaran target. </li><li>  Tutup perangkat. </li></ol><br><h2 id="pishem-zagruzchik">  Menulis bootloader </h2><br><p>  Mari kita turun ke bagian praktis.  Dalam percobaan saya, saya akan menggunakan versi Eclipse dari Oxygen.3a Release (4.7.3a) sebagai IDE, dan mingw32-gcc (6.3.0) sebagai kompiler.  Sistem operasi Win7. </p><br><p>  Dari situs web <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FTDI</a> kami mengunduh versi terbaru driver untuk sistem operasi kami.  Dalam arsip kami menemukan file header ftd2xx.h dengan deskripsi semua fungsi API.  API itu sendiri diimplementasikan sebagai ftd2xx.dll, tetapi kami akan meninggalkan impor dinamis untuk nanti, dan menggunakan tautan statis: kita memerlukan file library ftd2xx.lib.  Untuk kasus saya, ftd2xx.lib ada di direktori i386. </p><br><p>  Di Eclipse, buat proyek C baru.  Membuat <em>makefile</em> dapat dipercaya dengan IDE.  Dalam pengaturan tautan, tentukan jalur dan nama perpustakaan ftd2xx (saya mentransfer file yang diperlukan ke direktori proyek di folder ftdi).  Saya tidak akan fokus pada fitur pengaturan proyek untuk Eclipse, karena saya menduga sebagian besar dari mereka menggunakan lingkungan dan kompiler lain untuk pemrograman Win. </p><br><h3 id="punkt-pervyy-nayti-devays-i-otkryt-ego">  Poin satu.  Temukan perangkat dan buka </h3><br><p>  API FTD2XX memungkinkan Anda untuk membuka chip menggunakan satu atau beberapa informasi yang diketahui tentangnya.  Ini mungkin nomor seri dalam sistem: chip FTDI pertama yang terhubung akan mengambil angka 0, 1 berikutnya dan seterusnya.  Jumlah dalam sistem ditentukan oleh urutan di mana sirkuit mikro terhubung, dengan kata lain, ini tidak selalu nyaman.  Untuk membuka chip dengan nomor, fungsi <code>FT_Open</code> .  Anda dapat membuka chip dengan nomor seri ( <code>FT_OPEN_BY_SERIAL_NUMBER</code> ), deskripsi ( <code>FT_OPEN_BY_DESCRIPTION</code> ) atau dengan lokasi ( <code>FT_OPEN_BY_LOCATION</code> ), untuk ini, fungsi <code>FT_OpenEx</code> .  Nomor seri dan deskripsi disimpan dalam memori internal chip dan dapat direkam di sana selama pembuatan perangkat dengan FTDI diinstal.  Deskripsi, sebagai suatu peraturan, mencirikan jenis perangkat atau keluarga, dan nomor seri harus unik untuk setiap produk.  Oleh karena itu, cara paling mudah untuk mengidentifikasi perangkat yang didukung oleh program yang sedang dikembangkan adalah deskripsinya.  Kami akan membuka chip FTDI sesuai dengan deskripsi (deskriptor).  Faktanya, jika kami awalnya mengetahui string deskriptor chip, maka kami tidak perlu mencari perangkat di sistem, namun, sebagai percobaan, kami akan menampilkan semua perangkat yang terhubung ke komputer dengan FTDI.  Menggunakan fungsi <code>FT_CreateDeviceInfoList</code> , <code>FT_CreateDeviceInfoList</code> akan membuat daftar terperinci dari chip yang terhubung, dan menggunakan fungsi <code>FT_GetDeviceInfoList</code> , <code>FT_GetDeviceInfoList</code> mempertimbangkannya. </p><br><div class="spoiler">  <b class="spoiler_title">Daftar perangkat yang terhubung.</b>  <b class="spoiler_title">Daftar:</b> <div class="spoiler_text"><pre> <code class="cpp hljs">ftStatus = FT_CreateDeviceInfoList(&amp;numDevs); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ftStatus == FT_OK) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Number of devices is %d\n"</span></span>,numDevs); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numDevs == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// allocate storage for list based on numDevs devInfo = (FT_DEVICE_LIST_INFO_NODE*)malloc(sizeof(FT_DEVICE_LIST_INFO_NODE)*numDevs); ftStatus = FT_GetDeviceInfoList(devInfo,&amp;numDevs); if (ftStatus == FT_OK) for (int i = 0; i &lt; numDevs; i++) { printf("Dev %d:\n",i); printf(" Flags=0x%x\n",devInfo[i].Flags); printf(" Type=0x%x\n",devInfo[i].Type); printf(" ID=0x%x\n",devInfo[i].ID); printf(" LocId=0x%x\n",devInfo[i].LocId); printf(" SerialNumber=%s\n",devInfo[i].SerialNumber); printf(" Description=%s\n",devInfo[i].Description); }</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Selamat datang di kebun binatang saya</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">D:\workspace\ftdi-mpsse-ps\<span class="hljs-keyword"><span class="hljs-keyword">Debug</span></span>&gt;ftdi-mpsse-ps.exe Number <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> devices <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> Dev <span class="hljs-number"><span class="hljs-number">0</span></span>: Flags = <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> = <span class="hljs-number"><span class="hljs-number">0x5</span></span> ID = <span class="hljs-number"><span class="hljs-number">0x4036001</span></span> LocId = <span class="hljs-number"><span class="hljs-number">0x214</span></span> SerialNumber = AI043NNV Description = FT232R USB UART Dev <span class="hljs-number"><span class="hljs-number">1</span></span>: Flags = <span class="hljs-number"><span class="hljs-number">0x2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> = <span class="hljs-number"><span class="hljs-number">0x6</span></span> ID = <span class="hljs-number"><span class="hljs-number">0x4036010</span></span> LocId = <span class="hljs-number"><span class="hljs-number">0x2121</span></span> SerialNumber = L731T70OA Description = LESO7 A Dev <span class="hljs-number"><span class="hljs-number">2</span></span>: Flags = <span class="hljs-number"><span class="hljs-number">0x2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> = <span class="hljs-number"><span class="hljs-number">0x6</span></span> ID = <span class="hljs-number"><span class="hljs-number">0x4036010</span></span> LocId = <span class="hljs-number"><span class="hljs-number">0x2122</span></span> SerialNumber = L731T70OB Description = LESO7 B Dev <span class="hljs-number"><span class="hljs-number">3</span></span>: Flags = <span class="hljs-number"><span class="hljs-number">0x2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> = <span class="hljs-number"><span class="hljs-number">0x8</span></span> ID = <span class="hljs-number"><span class="hljs-number">0x4036014</span></span> LocId = <span class="hljs-number"><span class="hljs-number">0x213</span></span> SerialNumber = FTYZ92L6 Description = LESO4<span class="hljs-number"><span class="hljs-number">.1</span></span>_ER</code> </pre> </div></div><br><p>  Tiga perangkat dengan chip FTDI terhubung ke PC saya: FT232RL (tipe 0x5), FT2232H (tipe 0x6) dan FT232H (tepe 0x8).  Chip FT2232H dalam sistem ditampilkan sebagai dua perangkat independen (Dev 1 dan Dev 2).  Antarmuka FPGA PS terhubung ke Dev 2, deskriptornya adalah "LESO7 B".  Buka itu: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Open a device with device description "LESO7 B" ftStatus = FT_OpenEx("LESO7 B", FT_OPEN_BY_DESCRIPTION, &amp;ftHandle); if (ftStatus != FT_OK) { printf ("pen failure\r\n"); return -1; }</span></span></code> </pre> <br><p>  Sebagian besar fungsi API mengembalikan status panggilan jenisnya <code>FT_STATUS</code> , semua nilai yang mungkin dideskripsikan sebagai enum dalam file header.  Ada banyak dari mereka, tetapi cukup untuk mengetahui bahwa nilai <code>FT_OK</code> adalah tidak adanya kesalahan, semua nilai lainnya adalah kode kesalahan.  Gaya pemrograman yang baik adalah memeriksa nilai status setelah setiap panggilan ke fungsi API. </p><br><p>  Jika perangkat berhasil dibuka, maka dalam variabel <code>ftHandle</code> muncul beberapa nilai selain nol, beberapa deskriptor file yang setara, yang digunakan saat bekerja dengan file.  Pegangan yang dihasilkan membuat koneksi dengan antarmuka perangkat keras dan harus digunakan saat memanggil semua fungsi pustaka yang memerlukan akses ke chip. <br>  Untuk mengkonfirmasi dalam prakteknya pengoperasian sistem untuk tahap saat ini, kita harus segera melanjutkan ke langkah lima dari algoritma kami. </p><br><p>  Setelah Anda selesai bekerja dengan chip, Anda harus menutupnya.  Untuk melakukan ini, gunakan fungsi <code>FT_Close</code> : </p><br><pre> <code class="cpp hljs">FT_Close(ftHandle);</code> </pre> <br><h3 id="punkt-2-inicializiruem-chip-i-vklyuchaem-mpsse">  Poin 2. Inisialisasi chip dan nyalakan MPSSE </h3><br><p>  Pengaturan ini khas untuk sebagian besar mode dan dijelaskan dengan baik dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi AN_135 FTDI MPSSE Basics</a> . </p><br><ol><li>  Kami melakukan reset (rezet) chip.  Fungsi <code>FT_ResetDevice</code> . </li><li>  Jika ada sampah di buffer terima, kami membersihkannya.  Fungsi <code>FT_Purge</code> . </li><li>  Sesuaikan ukuran buffer untuk membaca dan menulis.  Fungsi <code>FT_SetUSBParameters</code> . </li><li>  Matikan paritas.  <code>FT_SetChars</code> . </li><li>  Kami menetapkan batas waktu untuk membaca dan menulis.  Secara default, batas waktu dinonaktifkan, aktifkan batas waktu transmisi.  <code>FT_SetTimeouts</code> . </li><li>  Kami mengonfigurasi waktu tunggu untuk mengirim paket dari chip ke host.  Secara default, 16 ms, akselerasi ke 1 ms.  <code>FT_SetLatencyTimer</code> . </li><li>  Aktifkan kontrol aliran untuk menyinkronkan permintaan yang masuk.  <code>FT_SetFlowControl</code> . </li><li>  Semuanya siap untuk mengaktifkan mode MPSSE.  Setel ulang pengontrol MPSSE.  Kami menggunakan fungsi <code>FT_SetBitMode</code> , mengatur mode ke 0 (mode = 0, mask = 0). </li><li>  Aktifkan mode MPSSE.  Fungsi <code>FT_SetBitMode</code> - mode = 2, mask = 0. </li></ol><br><p>  Kami menyatukan dan mengkonfigurasi chip dalam fungsi <code>MPSSE_open</code> , sebagai parameter kami melewati garis dengan pegangan perangkat yang akan dibuka: </p><br><div class="spoiler">  <b class="spoiler_title">Cantumkan MPSSE_open</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FT_STATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MPSSE_open</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *description)</span></span></span><span class="hljs-function"> </span></span>{ FT_STATUS ftStatus; ftStatus = FT_OpenEx(description, FT_OPEN_BY_DESCRIPTION, &amp;ftHandle); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ftStatus != FT_OK) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"open failure\r\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FT_DEVICE_NOT_OPENED; } <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"open OK, %d\r\n"</span></span>, ftHandle); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"\nConfiguring port for MPSSE use...\n"</span></span>); ftStatus |= FT_ResetDevice(ftHandle); <span class="hljs-comment"><span class="hljs-comment">//Purge USB receive buffer first by reading out all old data from FT2232H receive buff: ftStatus |= FT_Purge(ftHandle, FT_PURGE_RX); //Set USB request transfer sizes to 64K: ftStatus |= FT_SetUSBParameters(ftHandle, 65536, 65536); //Disable event and error characters: ftStatus |= FT_SetChars(ftHandle, 0, 0, 0, 0); //Sets the read and write timeouts in milliseconds: ftStatus |= FT_SetTimeouts(ftHandle, 0, 5000); //Set the latency timer to 1mS (default is 16mS): ftStatus |= FT_SetLatencyTimer(ftHandle, 1); //Turn on flow control to synchronize IN requests: ftStatus |= FT_SetFlowControl(ftHandle, FT_FLOW_RTS_CTS, 0x00, 0x00); //Reset controller: ftStatus |= FT_SetBitMode(ftHandle, 0x0, FT_BITMODE_RESET); //Enable MPSSE mode: ftStatus |= FT_SetBitMode(ftHandle, 0x0, FT_BITMODE_MPSSE); if (ftStatus != FT_OK) { printf("Error in initializing the MPSSE %d\n", ftStatus); return FT_OTHER_ERROR; } Sleep(50); // Wait for all the USB stuff to complete and work return FT_OK; }</span></span></code> </pre> </div></div><br><h3 id="punkt-3-nastroim-rezhim-raboty-mpsee">  Butir 3. Mengkonfigurasi mode operasi MPSEE </h3><br><p>  Sebenarnya, pada tahap ini prosesor MPSSE diaktifkan dan siap menerima perintah.  Perintah adalah urutan byte, byte pertama di antaranya adalah "op-code", diikuti oleh parameter perintah.  Perintah ini mungkin tidak memiliki parameter dan terdiri dari satu "op-code".  Perintah ditransmisikan menggunakan fungsi <code>FT_Write</code> , respons dari prosesor MPSSE dapat diperoleh dengan menggunakan fungsi <code>FT_Read</code> . </p><br><p>  Setelah setiap pengiriman perintah, akan bermanfaat untuk membaca respons prosesor, karena jika ada perintah yang salah, respons tersebut mungkin berisi pesan kesalahan - karakter 0xFA.  Mekanisme "perintah buruk - respons 0xFA" dapat digunakan untuk menyinkronkan program aplikasi dengan prosesor MPSSE.  Jika semuanya OK, maka chip akan mengembalikan karakter 0xFA pada perintah yang sengaja salah.  Kode-op dijelaskan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Command Processor untuk Mode Emulasi Bus Host MPSSE dan MCU</a> . <br>  Mengkonfigurasi MPSSE dilakukan untuk menetapkan kecepatan data, arah, dan status awal dari garis I / O. <br>  Pertimbangkan untuk mengatur kecepatan data prosesor MPSSE.  Pengaturan untuk chip dengan dukungan untuk hanya mode kecepatan penuh (FT2232 <strong>D</strong> ) dan chip dengan kecepatan tinggi (FT2232 <strong>H</strong> , FT232H, FT4232H) agak berbeda.  FT2232D lama menggunakan jam 12MHz, sedangkan yang modern menggunakan 60MHz.  Maka rumus untuk menghitung laju transfer data: </p><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>K</mi><mi>e</mi><mi>c</mi><mi>e</mi><mi>p</mi><mi>a</mi><mi>t</mi><mi>a</mi><mi>n</mi><mi>D</mi><mi>a</mi><mi>t</mi><mi>a</mi><mo>=</mo><mtext>&amp;#xA0;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><msub><mi>f</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>c</mi><mi>o</mi><mi>r</mi><mi>e</mi></mrow></msub></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mo>+</mo><mi>P</mi><mi>e</mi><mi>m</mi><mi>b</mi><mi>a</mi><mi>g</mi><mi>i</mi><mo stretchy=&quot;false&quot;>)</mo><mtext>&amp;#xA0;</mtext><mi>c</mi><mi>d</mi><mi>o</mi><mi>t</mi><mn>2</mn></mrow></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="49.718ex" height="2.66ex" viewBox="0 -832 21406.5 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhMUNuZi1e7O4s--takcPuIYOmYVg#MJMATHI-4B" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhMUNuZi1e7O4s--takcPuIYOmYVg#MJMATHI-65" x="889" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhMUNuZi1e7O4s--takcPuIYOmYVg#MJMATHI-63" x="1356" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhMUNuZi1e7O4s--takcPuIYOmYVg#MJMATHI-65" x="1789" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhMUNuZi1e7O4s--takcPuIYOmYVg#MJMATHI-70" x="2256" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhMUNuZi1e7O4s--takcPuIYOmYVg#MJMATHI-61" x="2759" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhMUNuZi1e7O4s--takcPuIYOmYVg#MJMATHI-74" x="3289" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhMUNuZi1e7O4s--takcPuIYOmYVg#MJMATHI-61" x="3650" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhMUNuZi1e7O4s--takcPuIYOmYVg#MJMATHI-6E" x="4180" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhMUNuZi1e7O4s--takcPuIYOmYVg#MJMATHI-44" x="4780" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhMUNuZi1e7O4s--takcPuIYOmYVg#MJMATHI-61" x="5609" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhMUNuZi1e7O4s--takcPuIYOmYVg#MJMATHI-74" x="6138" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhMUNuZi1e7O4s--takcPuIYOmYVg#MJMATHI-61" x="6500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhMUNuZi1e7O4s--takcPuIYOmYVg#MJMAIN-3D" x="7307" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhMUNuZi1e7O4s--takcPuIYOmYVg#MJMATHI-66" x="8613" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhMUNuZi1e7O4s--takcPuIYOmYVg#MJMATHI-72" x="9164" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhMUNuZi1e7O4s--takcPuIYOmYVg#MJMATHI-61" x="9615" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhMUNuZi1e7O4s--takcPuIYOmYVg#MJMATHI-63" x="10145" y="0"></use><g transform="translate(10578,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhMUNuZi1e7O4s--takcPuIYOmYVg#MJMATHI-66" x="0" y="0"></use><g transform="translate(490,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhMUNuZi1e7O4s--takcPuIYOmYVg#MJMATHI-63" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhMUNuZi1e7O4s--takcPuIYOmYVg#MJMATHI-6F" x="433" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhMUNuZi1e7O4s--takcPuIYOmYVg#MJMATHI-72" x="919" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhMUNuZi1e7O4s--takcPuIYOmYVg#MJMATHI-65" x="1370" y="0"></use></g></g><g transform="translate(12468,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhMUNuZi1e7O4s--takcPuIYOmYVg#MJMAIN-28" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhMUNuZi1e7O4s--takcPuIYOmYVg#MJMAIN-31" x="389" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhMUNuZi1e7O4s--takcPuIYOmYVg#MJMAIN-2B" x="1112" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhMUNuZi1e7O4s--takcPuIYOmYVg#MJMATHI-50" x="2112" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhMUNuZi1e7O4s--takcPuIYOmYVg#MJMATHI-65" x="2864" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhMUNuZi1e7O4s--takcPuIYOmYVg#MJMATHI-6D" x="3330" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhMUNuZi1e7O4s--takcPuIYOmYVg#MJMATHI-62" x="4209" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhMUNuZi1e7O4s--takcPuIYOmYVg#MJMATHI-61" x="4638" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhMUNuZi1e7O4s--takcPuIYOmYVg#MJMATHI-67" x="5168" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhMUNuZi1e7O4s--takcPuIYOmYVg#MJMATHI-69" x="5648" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhMUNuZi1e7O4s--takcPuIYOmYVg#MJMAIN-29" x="5994" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhMUNuZi1e7O4s--takcPuIYOmYVg#MJMATHI-63" x="6633" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhMUNuZi1e7O4s--takcPuIYOmYVg#MJMATHI-64" x="7067" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhMUNuZi1e7O4s--takcPuIYOmYVg#MJMATHI-6F" x="7590" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhMUNuZi1e7O4s--takcPuIYOmYVg#MJMATHI-74" x="8076" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhhMUNuZi1e7O4s--takcPuIYOmYVg#MJMAIN-32" x="8437" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>K</mi><mi>e</mi><mi>c</mi><mi>e</mi><mi>p</mi><mi>a</mi><mi>t</mi><mi>a</mi><mi>n</mi><mi>D</mi><mi>a</mi><mi>t</mi><mi>a</mi><mo>=</mo><mtext>&nbsp;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class="MJX-TeXAtom-ORD"><msub><mi>f</mi><mrow class="MJX-TeXAtom-ORD"><mi>c</mi><mi>o</mi><mi>r</mi><mi>e</mi></mrow></msub></mrow><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>P</mi><mi>e</mi><mi>m</mi><mi>b</mi><mi>a</mi><mi>g</mi><mi>i</mi><mo stretchy="false">)</mo><mtext>&nbsp;</mtext><mi>c</mi><mi>d</mi><mi>o</mi><mi>t</mi><mn>2</mn></mrow></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> Kecepatan Data = \ frac {f_ {core}} {(1 + Pembagi) \ cdot 2} </script></p><br><p>  di mana <em>f <sub>core</sub></em> adalah frekuensi <em><sub>inti</sub></em> FTDI, <em>Divisor</em> adalah pembagi dua byte, yang, pada kenyataannya, mengatur frekuensi jam data. <br>  Akibatnya, jika pembagi sama dengan nol, maka kecepatan transfer data maksimum adalah 30 Mbps, dan kecepatan transfer data minimum adalah pada pembagi 65535 - 458 bit / s. <br>  Kami akan mempercayakan perhitungan pembagi ke preprosesor.  Makro mengembalikan pembagi: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FCORE 60000000ul #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MPSSE_DATA_SPEED_DIV(data_speed) ((FCORE/(2*data_speed)) -1)</span></span></code> </pre> <br><p>  Dan kedua makro ini mengembalikan byte tinggi dan rendah dari pembagi, masing-masing: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MPSSE_DATA_SPEED_DIV_H(data_speed) ((MPSSE_DATA_SPEED_DIV(data_speed)) &gt;&gt; 8) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MPSSE_DATA_SPEED_DIV_L(data_speed) \ (MPSSE_DATA_SPEED_DIV(data_speed) - (MPSSE_DATA_SPEED_DIV_H(data_speed)&lt;&lt; 8))</span></span></code> </pre> <br><p>  Selain itu, perlu dicatat bahwa dalam chip modern untuk kompatibilitas dengan FT2232D lama ada tambahan 5 pembagi, yang mengubah 60 MHz menjadi 12 MHz.  Pembagi ini diaktifkan secara default, dalam kasus kami pembagi ini harus dimatikan. <br>  Kami menemukan kode-op yang sesuai (0x8A) dan perintah helm ke prosesor: </p><br><div class="spoiler">  <b class="spoiler_title">Daftar pengiriman tim</b> <div class="spoiler_text"><pre> <code class="cpp hljs">BYTE byOutputBuffer[<span class="hljs-number"><span class="hljs-number">8</span></span>], byInputBuffer[<span class="hljs-number"><span class="hljs-number">8</span></span>]; DWORD dwNumBytesToRead, dwNumBytesSent = <span class="hljs-number"><span class="hljs-number">0</span></span>, dwNumBytesRead = <span class="hljs-number"><span class="hljs-number">0</span></span>; byOutputBuffer[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0x8A</span></span>; ftStatus = FT_Write(ftHandle, byOutputBuffer, <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;dwNumBytesSent); Sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Wait for data to be transmitted and status ftStatus = FT_GetQueueStatus(ftHandle, &amp;dwNumBytesToRead); ftStatus |= FT_Read(ftHandle, byInputBuffer, dwNumBytesToRead, &amp;dwNumBytesRead); if (ftStatus != FT_OK) { printf("Error\r\n"); return FT_OTHER_ERROR; } else if (dwNumBytesToRead &gt; 0) { printf("dwNumBytesToRead = %d:", dwNumBytesToRead); for ( int i = 0; i &lt; dwNumBytesToRead; i++) printf (" %02Xh", byInputBuffer[i]); printf("\r\n"); return FT_INVALID_PARAMETER; } return FT_OK;</span></span></code> </pre> </div></div><br><p>  Sebagai percobaan, alih-alih perintah 0x8A yang sebenarnya, kami akan mengirimkan nilai 0xFE, yang tidak sesuai dengan kode op apa pun, keluaran konsol: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">dwNumBytesToRead</span></span> = <span class="hljs-number"><span class="hljs-number">2</span></span>: FAh FEh</code> </pre> <br><p>  Prosesor mengembalikan dua byte, byte perintah buruk adalah 0xFA dan nilai perintah buruk ini.  Jadi, dengan mengirim beberapa perintah sekaligus, kita tidak hanya bisa melacak fakta kesalahan itu sendiri, tetapi juga memahami tim mana kesalahan ini terjadi. <br>  Agar tidak berurusan dengan "angka ajaib" di masa mendatang, kami akan memformat semua kode-op dalam bentuk konstanta dan menempatkannya dalam file header yang terpisah. <br>  Untuk sepenuhnya mengkonfigurasi mode, Anda perlu menentukan arah garis I / O dan nilai defaultnya.  Mari kita beralih ke diagram koneksi.  Agar tidak mengacaukan artikel yang sudah membengkak, saya telah menggambar sebuah fragmen menarik dari skema ini: </p><br><img width="500" src="https://habrastorage.org/webt/sc/6g/no/sc6gnoqy5_eyc5lsjpmlqbnl2-m.png"><br><p>  Baris <em>DCLK</em> , <em>DATA [0]</em> , <em>nCONFIG</em> harus dikonfigurasi sebagai output, baris <em>nSTATUS</em> , <em>CONF_DONE</em> sebagai input.  Dengan menggunakan diagram, kami menentukan status awal yang harus dimiliki garis.  Untuk kejelasan, pinout dari rangkaian dirangkum dalam tabel: </p><br><table><thead><tr><th>  Pin FPGA </th><th>  Nama pin </th><th>  Pin </th><th>  MPSSE </th><th>  Arahan </th><th>  standar </th></tr></thead><tbody><tr><td>  DCLK </td><td>  BDBUS0 </td><td>  38 </td><td>  TCK / SK </td><td>  Keluar </td><td>  0 </td></tr><tr><td>  DATA [0] </td><td>  BDBUS1 </td><td>  39 </td><td>  TDI / DO </td><td>  Keluar </td><td>  1 </td></tr><tr><td>  nCONFIG </td><td>  BDBUS2 </td><td>  40 </td><td>  TDO / DI </td><td>  Keluar </td><td>  1 </td></tr><tr><td>  nSTATUS </td><td>  BDBUS3 </td><td>  41 </td><td>  TMS / CS </td><td>  Masuk </td><td>  1 </td></tr><tr><td>  CONF_DONE </td><td>  BDBUS4 </td><td>  43 </td><td>  GPIOL0 </td><td>  Masuk </td><td>  1 </td></tr></tbody></table><br><p>  Semua baris yang digunakan terletak pada byte rendah port MPSSE.  Untuk mengatur nilainya, gunakan op-code 0x80.  Perintah ini mengasumsikan dua argumen: byte pertama yang mengikuti op-code adalah nilai bit-by-bit, dan yang kedua adalah arah (satu adalah port output, nol adalah port input). <br>  Sebagai bagian dari pertarungan melawan "angka ajaib", semua nomor baris seri dan nilai defaultnya akan diformat sebagai konstanta: </p><br><div class="spoiler">  <b class="spoiler_title">Tentukan port</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_DIRECTION (0x07) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DCLK (0) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DATA0 (1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> N_CONFIG (2) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> N_STATUS (3) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONF_DONE (4) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// initial states of the MPSSE interface #define DCLK_DEF (1) #define DATA0_DEF (0) #define N_CONFIG_DEF (1) #define N_STATUS_DEF (1) #define CONF_DONE_DEF (1)</span></span></span></span></code> </pre> </div></div><br><p>  Tetap hanya untuk memastikan bahwa loop TDI - TDO dinonaktifkan (dapat diaktifkan untuk pengujian) dan memasukkannya ke dalam fungsi terpisah: </p><br><div class="spoiler">  <b class="spoiler_title">Mendaftarkan Fungsi MPSSE_setup</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FT_STATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MPSSE_setup</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ DWORD dwNumBytesToSend, dwNumBytesSent, dwNumBytesToRead, dwNumBytesRead; BYTE byOutputBuffer[<span class="hljs-number"><span class="hljs-number">8</span></span>], byInputBuffer[<span class="hljs-number"><span class="hljs-number">8</span></span>]; FT_STATUS ftStatus; <span class="hljs-comment"><span class="hljs-comment">// Multple commands can be sent to the MPSSE with one FT_Write dwNumBytesToSend = 0; // Start with a fresh index byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_DISABLE_DIVIDER_5; byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_DISABLE_ADAPTIVE_CLK; byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_DISABLE_3PHASE_CLOCKING; ftStatus = FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); dwNumBytesToSend = 0; // Reset output buffer pointer // Set TCK frequency // Command to set clock divisor: byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_SET_TCK_DIVISION; // Set ValueL of clock divisor: byOutputBuffer[dwNumBytesToSend++] = MPSSE_DATA_SPEED_DIV_L(DATA_SPEED); // Set 0xValueH of clock divisor: byOutputBuffer[dwNumBytesToSend++] = MPSSE_DATA_SPEED_DIV_H(DATA_SPEED); ftStatus |= FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); dwNumBytesToSend = 0; // Reset output buffer pointer // Set initial states of the MPSSE interface // - low byte, both pin directions and output values /* | FPGA pin | Pin Name | Pin | MPSSE | Dir | def | | --------- | -------- | --- | ------ | --- | --- | | DCLK | BDBUS0 | 38 | TCK/SK | Out | 0 | | DATA[0] | BDBUS1 | 39 | TDI/DO | Out | 1 | | nCONFIG | BDBUS2 | 40 | TDO/DI | Out | 1 | | nSTATUS | BDBUS3 | 41 | TMS/CS | In | 1 | | CONF_DONE | BDBUS4 | 43 | GPIOL0 | In | 1 | */ // Configure data bits low-byte of MPSSE port: byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_SET_DATA_BITS_LOWBYTE; // Initial state config above: byOutputBuffer[dwNumBytesToSend++] = (DCLK_DEF &lt;&lt; DCLK) | (DATA0_DEF &lt;&lt; DATA0) | (N_CONFIG_DEF &lt;&lt; N_CONFIG) | (N_STATUS_DEF &lt;&lt; N_STATUS) | (CONF_DONE_DEF &lt;&lt; CONF_DONE); // Direction config above: byOutputBuffer[dwNumBytesToSend++] = PORT_DIRECTION; ftStatus |= FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); // Send off the low GPIO config commands dwNumBytesToSend = 0; // Reset output buffer pointer // Set initial states of the MPSSE interface // - high byte, all input, Initial State -- 0. // Send off the high GPIO config commands: byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_SET_DATA_BITS_HIGHBYTE; byOutputBuffer[dwNumBytesToSend++] = 0x00; byOutputBuffer[dwNumBytesToSend++] = 0x00; ftStatus |= FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); // Disable loopback: byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_DISABLE_LOOP_TDI_TDO; ftStatus |= FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); Sleep(2); // Wait for data to be transmitted and status ftStatus = FT_GetQueueStatus(ftHandle, &amp;dwNumBytesToRead); ftStatus |= FT_Read(ftHandle, byInputBuffer, dwNumBytesToRead, &amp;dwNumBytesRead); if (ftStatus != FT_OK) { printf("Unknown error in initializing the MPSSE\r\n"); return FT_OTHER_ERROR; } else if (dwNumBytesToRead &gt; 0) { printf("Error in initializing the MPSSE, bad code:\r\n"); for ( int i = 0; i &lt; dwNumBytesToRead; i++) printf (" %02Xh", byInputBuffer[i]); printf("\r\n"); return FT_INVALID_PARAMETER; } return FT_OK; }</span></span></code> </pre> </div></div><br><h3 id="punkt-4-realizuem-protokol-zagruzki">  Poin 4. Kami menerapkan protokol pemuatan </h3><br><p>  Segalanya tampak siap untuk eksperimen praktis.  Pertama, periksa apakah inisialisasi dilakukan dengan benar, di bagian utama program, panggil <code>MPSSE_open()</code> dan <code>MPSSE_setup()</code> , dan sebelum menutup perangkat ( <code>FT_Close</code> ), kami meletakkan <code>getchar()</code> kosong <code>getchar()</code> .  Jalankan program dan gunakan osiloskop untuk memastikan bahwa semua saluran PS diatur ke level default.  Mengubah nilai level-level ini dalam inisialisasi (tidak ada hal buruk yang akan terjadi dengan FPGA), kami memastikan bahwa prosesor MPSSE memberikan hasil yang diinginkan valid - semuanya bekerja dengan baik dan Anda dapat melanjutkan untuk mentransfer data. <br>  Pengiriman dan penerimaan data secara berurutan dilakukan dalam mode perintah menggunakan op-code yang sama.  Byte pertama dari perintah ini adalah op-code, yang menentukan jenis operasi, diikuti oleh panjang urutan yang dikirim atau diterima dan, jika itu adalah transmisi, data aktual.  Prosesor MPSSE dapat mengirim dan menerima data, juga melakukannya secara bersamaan.  Transmisi dapat berupa bit forward paling tidak signifikan (LSB) atau yang paling signifikan (MSB).  Transmisi data dapat terjadi di tepi pulsa clock yang memimpin atau tertinggal.  Setiap kombinasi opsi memiliki op-code sendiri, masing-masing bit op-code menjelaskan mode operasi: </p><br><table><thead><tr><th>  Sedikit </th><th>  Fungsi </th></tr></thead><tbody><tr><td>  0 </td><td>  Sinkronisasi penulisan-depan: 0 - positif, 1 - negatif </td></tr><tr><td>  1 </td><td>  1 - bekerja dengan byte, 0 - bekerja dengan bit </td></tr><tr><td>  2 </td><td>  Tepi depan untuk membaca: 0 - positif, 1 - negatif </td></tr><tr><td>  3 </td><td>  Mode Transmisi: 1 - LSB, 0 - MSB terlebih dahulu </td></tr><tr><td>  4 </td><td>  Pengiriman data TDI </td></tr><tr><td>  5 </td><td>  Membaca Data dari Garis TDO </td></tr><tr><td>  6 </td><td>  Transmisi data TMS </td></tr><tr><td>  7 </td><td>  Harus 0, kalau tidak, ini adalah kelompok perintah lain </td></tr></tbody></table><br><p>  Ketika mengkonfigurasi FPGA sesuai dengan skema PS, data ditransmisikan pada keunggulan dalam mode LSB.     ,   ,    op-code   0001_1000b  0x18   .       ( ,   ),    .    :     .  ,      ,     0,    65536,     65535. ,     .        <code>MPSSE_send</code> . </p><br><div class="spoiler"> <b class="spoiler_title">  MPSSE_send</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> BYTE byBuffer[<span class="hljs-number"><span class="hljs-number">65536</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FT_STATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MPSSE_send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BYTE * buff, DWORD dwBytesToWrite)</span></span></span><span class="hljs-function"> </span></span>{ DWORD dwNumBytesToSend = <span class="hljs-number"><span class="hljs-number">0</span></span>, dwNumBytesSent, bytes; FT_STATUS ftStatus; <span class="hljs-comment"><span class="hljs-comment">// Output on rising clock, no input // MSB first, clock a number of bytes out byBuffer[dwNumBytesToSend++] = MPSSE_CMD_LSB_DATA_OUT_BYTES_POS_EDGE; // 0x18 bytes = dwBytesToWrite -1; byBuffer[dwNumBytesToSend++] = (bytes) &amp; 0xFF; // Length L byBuffer[dwNumBytesToSend++] = (bytes &gt;&gt; 8) &amp; 0xFF; // Length H memcpy(&amp;byBuffer[dwNumBytesToSend], buff, dwBytesToWrite); dwNumBytesToSend += dwBytesToWrite; ftStatus = FT_Write(ftHandle, byBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); if (ftStatus != FT_OK ) { printf ("ERROR send data\r\n"); return ftStatus; } else if (dwNumBytesSent != dwNumBytesToSend) { printf ("ERROR send data, %d %d\r\n", dwNumBytesSent, dwNumBytesToSend); } return FT_OK; }</span></span></code> </pre> </div></div><br><p>        ‚Äî      65 ,   - ,        op-code   .   <code>byBuffer</code> ,             <code>buff</code> ,  ,      op-code  .    ,     ,         . <br>    ,        ""  ,       25 , ,  ,     1  ( ,     <code>#define DATA_SPEED 1000000ul</code> ).   : </p><br><pre> <code class="hljs objectivec">BYTE byOutputBuffer[] = {<span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-number"><span class="hljs-number">0x1B</span></span>, <span class="hljs-number"><span class="hljs-number">0xEE</span></span>, <span class="hljs-number"><span class="hljs-number">0x01</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">MPSSE_send</span></span>(byOutputBuffer, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(byOutputBuffer));</code> </pre> <br><p>    ( ): <br> <a href=""><img src="https://habrastorage.org/webt/bp/gp/es/bpgpesvsoradzqfecft07bdjk-u.png"></a> </p><br><p>   ‚Äî    <em>DATA[0]</em> ,   ‚Äî <em>DCLK</em> .             .  ,  ,   . </p><br><p>      ,     SPI  ( ).  ,     PS,     .   <em>nCONFIG</em> , <em>nSTATUS</em> , <em>CONF_DONE</em> .   ‚Äî  ,      ,   ‚Äî ,     . </p><br><p>  <code>MPSSE_get_lbyte</code>    ,  ,         . </p><br><div class="spoiler"> <b class="spoiler_title">  MPSSE_get_lbyte</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FT_STATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MPSSE_get_lbyte</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BYTE *lbyte)</span></span></span><span class="hljs-function"> </span></span>{ DWORD dwNumBytesToSend, dwNumBytesSent, dwNumBytesToRead, dwNumBytesRead; BYTE byOutputBuffer[<span class="hljs-number"><span class="hljs-number">8</span></span>]; FT_STATUS ftStatus; dwNumBytesToSend = <span class="hljs-number"><span class="hljs-number">0</span></span>; byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_GET_DATA_BITS_LOWBYTE; ftStatus = FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); Sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Wait for data to be transmitted and status ftStatus = FT_GetQueueStatus(ftHandle, &amp;dwNumBytesToRead); ftStatus |= FT_Read(ftHandle, lbyte, dwNumBytesToRead, &amp;dwNumBytesRead); if ((ftStatus != FT_OK) &amp; (dwNumBytesToRead != 1)) { printf("Error read Lbyte\r\n"); return FT_OTHER_ERROR; // Exit with error } return FT_OK; }</span></span></code> </pre> </div></div><br><p>  ,  op-code  ,         . ,     -     ,    ,          .    ,   .     <code>MPSSE_set_lbyte</code> : </p><br><div class="spoiler"> <b class="spoiler_title">  MPSSE_set_lbyte</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FT_STATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MPSSE_set_lbyte</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BYTE lb, BYTE mask)</span></span></span><span class="hljs-function"> </span></span>{ DWORD dwNumBytesToSend, dwNumBytesSent; BYTE byOutputBuffer[<span class="hljs-number"><span class="hljs-number">8</span></span>], lbyte; FT_STATUS ftStatus; ftStatus = MPSSE_get_lbyte(&amp;lbyte); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( ftStatus != FT_OK) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ftStatus; <span class="hljs-comment"><span class="hljs-comment">// Set to zero the bits selected by the mask: lbyte &amp;= ~mask; // Setting zero is not selected by the mask bits: lb &amp;= mask; lbyte |= lb; dwNumBytesToSend = 0; // Set data bits low-byte of MPSSE port: byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_SET_DATA_BITS_LOWBYTE; byOutputBuffer[dwNumBytesToSend++] = lbyte; byOutputBuffer[dwNumBytesToSend++] = PORT_DIRECTION; ftStatus = FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); if ((ftStatus != FT_OK) &amp; (dwNumBytesSent != 1)) { printf("Error set Lbyte\r\n"); return FT_OTHER_ERROR; } return FT_OK; }</span></span></code> </pre> </div></div><br><p>   ,     .   :  FTDI;    MPSSE;  rbf-  ,    <em>nCONFIG</em>  ,      <em>N_STATUS</em> ;    rbf-    ;  ,    ,      <em>CONF_DONE</em> .     ,     MPSSE   FTDI       .   ,  <em>nCONFIG</em>      ""  ,     ,        ,     . </p><br><div class="spoiler"> <b class="spoiler_title">  main</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[])</span></span></span><span class="hljs-function"> </span></span>{ FT_STATUS ftStatus; BYTE lowByte; DWORD numDevs; <span class="hljs-comment"><span class="hljs-comment">// create the device information list if ( argv[1] == NULL) { printf ("NO file\r\n"); return -1; } frbf = fopen(argv[1],"rb"); if (frbf == NULL) { printf ("Error open rbf\r\n"); return -1; } ftStatus = FT_CreateDeviceInfoList(&amp;numDevs); if ((numDevs == 0) || (ftStatus != FT_OK)) { printf("Error. FTDI devices not found in the system\r\n"); return -1; } ftStatus = MPSSE_open ("LESO7 B"); if (ftStatus != FT_OK) { printf("Error in MPSSE_open %d\n", ftStatus); EXIT(-1); } MPSSE_setup(); if (ftStatus != FT_OK) { printf("Error in MPSSE_setup %d\n", ftStatus); EXIT(-1); } printf ("nConfig -&gt; 0\r\n"); MPSSE_set_lbyte(0, 1 &lt;&lt; N_CONFIG); printf ("nConfig -&gt; 1\r\n"); MPSSE_set_lbyte(1 &lt;&lt; N_CONFIG, 1 &lt;&lt; N_CONFIG); if (MPSSE_get_lbyte(&amp;lowByte) != FT_OK) { EXIT(-1); } if (((lowByte &gt;&gt; N_STATUS) &amp; 1) == 0) { printf("Error. FPGA is not responding\r\n"); EXIT(-1); } int i = 0; size_t readBytes = 0; // Send the configuration file: do { readBytes = fread(buff, 1, MPSSE_PCK_SEND_SIZE, frbf); if (MPSSE_send(buff, readBytes) != FT_OK) EXIT(-1); putchar('*'); if (!((++i)%16)) printf("\r\n"); } while (readBytes == MPSSE_PCK_SEND_SIZE); printf("\r\n"); memset(buff, 0x00, sizeof(buff)); MPSSE_send(buff, 1); //        ? printf("Load complete\r\n"); // wait CONF_DONE set // A low-to-high transition on the CONF_DONE pin indicates that the configuration is // complete and initialization of the device can begin. i = 0; do { if (MPSSE_get_lbyte(&amp;lowByte) != FT_OK) { printf ("Error read CONF_DONE\r\n"); EXIT(-1); } if (i++ &gt; TIMEOUT_CONF_DONE) { printf ("Error CONF_DONE\r\n"); EXIT(-1); } Sleep(2); } while (((lowByte &gt;&gt; CONF_DONE) &amp; 1) == 0); printf("Configuration complete\r\n"); FT_Close(ftHandle); fclose(frbf); }</span></span></code> </pre> <br><p>   : </p><br><pre> <code class="hljs pgsql">pen "LESO7 B" OK nConfig -&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> nConfig -&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> ** <span class="hljs-keyword"><span class="hljs-keyword">Load</span></span> complete <span class="hljs-keyword"><span class="hljs-keyword">Configuration</span></span> complete</code> </pre> </div></div><br><p>    rbf-  .    .       30 /     . <br>      ,        -  JTAG. </p><br><h3 id="materialy-po-teme">    </h3><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FTDI-MPSSE-Altera PS</a> .   . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   </a> .   .       . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Software Application Development D2XX Programmer's Guide</a> .        FTDI.   API D2XX. </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FTDI MPSSE Basics. Application Note AN_135</a> .    .  FTDI MPSSE.      . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Command Processor untuk Mode Emulasi Bus Host MPSSE dan MCU. </font><font style="vertical-align: inherit;">Catatan Aplikasi AN_108</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Referensi untuk kode-op. </font><font style="vertical-align: inherit;">Tidak mungkin tanpanya.</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Driver D2XX</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Pengemudi FTDI.</font></font></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id426131/">https://habr.com/ru/post/id426131/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id426117/index.html">Ombudsman mengusulkan untuk memblokir iklan dengan produk bayi yang berpotensi berbahaya</a></li>
<li><a href="../id426119/index.html">Barang Antik: Cryptonomicon Iron</a></li>
<li><a href="../id426121/index.html">MC.exe (Kompiler pesan), rc.exe, link.exe untuk menghasilkan .dll untuk EventMessageFile</a></li>
<li><a href="../id426123/index.html">Pelajari OpenGL. Pelajaran 6.1. PBR atau Rendering yang Tepat Secara Fisik. Teori</a></li>
<li><a href="../id426125/index.html">Steroid karier. Elevator</a></li>
<li><a href="../id426133/index.html">Memperkenalkan Versi Alpha dari Snapshots Volume di Kubernetes</a></li>
<li><a href="../id426135/index.html">Cloud Pribadi untuk Internet of Things</a></li>
<li><a href="../id426137/index.html">Zaman Kejujuran</a></li>
<li><a href="../id426141/index.html">Red Hat ganti Docker dengan Podman</a></li>
<li><a href="../id426143/index.html">Animasi 3D - video atau interaktif?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>