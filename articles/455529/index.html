<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👸🏼 😁 👰🏿 Invertir y piratear el HDD externo de autocifrado de Aigo. Parte 2: Dumping con Cypress PSoC 🤞🏻 💈 🏎️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Esta es la segunda y última parte del artículo sobre la piratería de unidades de autocifrado externas. Les recuerdo que un colega me trajo recientemen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Invertir y piratear el HDD externo de autocifrado de Aigo. Parte 2: Dumping con Cypress PSoC</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455529/"><p>  Esta es la segunda y última parte del artículo sobre la piratería de unidades de autocifrado externas.  Les recuerdo que un colega me trajo recientemente un disco duro Patriot (Aigo) SK8671, y decidí revertirlo, y ahora estoy compartiendo lo que salió de él.  Antes de seguir leyendo, asegúrese de leer la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primera parte del</a> artículo. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4. Comenzamos a eliminar el volcado de la unidad flash interna PSoC</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">5. Protocolo ISSP</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">- 5.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¿Qué es un ISSP?</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">- 5.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Desmitificación de vectores</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">- 5.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Chatea con PSoC</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">- 5.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Identificación de registros intra-chip.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">- 5.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Brocas protectoras</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">6. Primer ataque (fallido): ROMX</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">7. Segundo ataque: seguimiento con reinicio en frío</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">- 7.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Implementación</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">- 7.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Lee el resultado</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">- 7.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Reconstrucción del binario flash.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">- 7.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Encuentra la dirección de almacenamiento de código PIN</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">- 7.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Eliminamos el basurero del bloque No. 126</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">- 7.6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Recuperación de código PIN</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">8. ¿Qué sigue?</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">9. Conclusión</a> </p><br><p><img src="https://habrastorage.org/webt/wx/nm/gk/wxnmgkeurrmiurx87rujoynxrsq.jpeg"></p><a name="habracut"></a><br><a name="a4"></a><br><h1 id="4-nachinaem-snimat-damp-s-vnutrenney-fleshki-psoc">  4. Comenzamos a eliminar el volcado de la unidad flash interna PSoC </h1><br><p>  Entonces, todo indica (como establecimos en [la primera parte] ()) que el código PIN está almacenado en los intestinos flash de PSoC.  Por lo tanto, necesitamos leer estos intestinos rápidos.  Frente de trabajo necesario: </p><br><ul><li>  tomar el control de la "comunicación" con el microcontrolador; </li><li>  encuentre una manera de verificar si esta "comunicación" está protegida contra la lectura desde el exterior; </li><li>  encuentra una forma de evitar la seguridad. </li></ul><br><p>  Hay dos lugares donde tiene sentido buscar un código PIN válido: </p><br><ul><li>  memoria flash interna; </li><li>  SRAM, donde se puede almacenar el código PIN para compararlo con el código PIN que ingresa el usuario. </li></ul><br><p>  Mirando hacia el futuro, noto que aún logré eliminar el volcado de la unidad flash interna PSoC, evitando su sistema de protección, utilizando el "seguimiento de restablecimiento en frío" del ataque de hardware después de revertir las características no documentadas del protocolo ISSP.  Esto me permitió volcar directamente el código PIN actual. </p><br><pre><code class="plaintext hljs">$ ./psoc.py syncing: KO OK [...] PIN: 1 2 3 4 5 6 7 8 9</code> </pre> <br><p>  El código del programa resultante: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Código Arduino para HSSP</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Controlador Python y desensamblador ISSP</a> . </li></ul><br><a name="a5"></a><br><h1 id="5-issp-protokol">  5. Protocolo ISSP </h1><br><a name="a51"></a><br><h2 id="51-chto-takoe-issp">  5.1.  ¿Qué es un ISSP? </h2><br><p>  La "comunicación" con el microcontrolador puede significar diferentes cosas: de "vendedor a vendedor", a la interacción mediante un protocolo en serie (por ejemplo, ICSP para PIC de Microchip). </p><br><p>  Cypress tiene su propio protocolo patentado para esto, llamado ISSP (protocolo de programación en serie del sistema), que se describe parcialmente en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">especificación técnica</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El documento US7185162</a> también proporciona información.  También hay un análogo de OpenSource llamado HSSP (lo usaremos un poco más adelante).  ISSP funciona de la siguiente manera: </p><br><ul><li>  reiniciar PSoC; </li><li>  traiga el número mágico al segmento de datos en serie de este PSoC;  para ingresar al modo de programación externa; </li><li>  enviar comandos que son cadenas de bits largas llamadas "vectores". </li></ul><br><p>  En la documentación del ISSP, estos vectores se definen solo para un pequeño puñado de comandos: </p><br><ul><li>  Initialialize-1 </li><li>  Initialize-2 </li><li>  Initialize-3 (opciones de 3V y 5V) </li><li>  CONFIGURACIÓN DE IDENTIFICACIÓN </li><li>  LEER-ID-PALABRA </li><li>  SET-BLOCK-NUM: 10011111010dddddddd111, donde dddddddd = block # </li><li>  BORRAR A GRANEL </li><li>  PROGRAMA-BLOQUE </li><li>  VERIFICAR-CONFIGURACIÓN </li><li>  READ-BYTE: 10110aaaaaaZDDDDDDDDDZ1, donde DDDDDDDDD = salida de datos, aaaaaa = dirección (6 bits) </li><li>  WRITE-BYTE: 10010aaaaaadddddddd111, donde dddddddd = datos, aaaaaa = dirección (6 bits) </li><li>  Seguro </li><li>  CONFIGURACIÓN DE CHECKSUM </li><li>  READ-CHECKSUM: 10111111001ZDDDDDDDDDZ110111111000ZDDDDDDDDZ1, donde DDDDDDDDDDDDDDDD = salida de datos: suma de comprobación del dispositivo </li><li>  BORRAR BLOQUEO </li></ul><br><p>  Por ejemplo, el vector para Initialize-2: </p><br><pre> <code class="plaintext hljs">1101111011100000000111 1101111011000000000111 1001111100000111010111 1001111100100000011111 1101111010100000000111 1101111010000000011111 1001111101110000000111 1101111100100110000111 1101111101001000000111 1001111101000000001111 1101111000000000110111 1101111100000000000111 1101111111100010010111</code> </pre> <br><p>  Todos los vectores tienen la misma longitud: 22 bits.  La documentación del HSSP tiene información adicional sobre los ISSP: "Un vector ISSP no es más que una secuencia de bits que representa un conjunto de instrucciones". </p><br><a name="a52"></a><br><h2 id="52-demistifikaciya-vektorov">  5.2.  Desmitificación de vectores </h2><br><p>  Veamos qué pasa aquí.  Inicialmente, asumí que estos mismos vectores son variantes en bruto de las instrucciones M8C, sin embargo, después de probar esta hipótesis, descubrí que los códigos de operación no coinciden. </p><br><p>  Luego busqué en Google el vector anterior y me topé con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este</a> estudio, donde el autor, aunque no entra en detalles, da algunas pistas prácticas: "Cada instrucción comienza con tres bits que corresponden a una de las cuatro mnemotecnias (leer de RAM, escribir en RAM , lea el registro, escriba el registro).  Luego viene la dirección de 8 bits, seguida de 8 bits de datos (ya sea leídos o escritos) y finalmente tres bits de parada ". </p><br><p>  Luego pude reunir información muy útil de la sección ROM de supervisión (SROM) del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">manual técnico</a> .  SROM es una ROM codificada en PSoC que proporciona funciones de servicio (similares a Syscall) para el código de software que se ejecuta en el espacio del usuario: </p><br><ul><li>  00h: SWBootReset </li><li>  01h: ReadBlock </li><li>  02h: WriteBlock </li><li>  03h: EraseBlock </li><li>  06h: TableRead </li><li>  07h: CheckSum </li><li>  08h: Calibrar0 </li><li>  09h: Calibrar1 </li></ul><br><p>  Comparando nombres de vectores con funciones SROM, podemos mapear las diversas operaciones soportadas por este protocolo a los parámetros esperados de SROM.  Gracias a esto, podemos decodificar los primeros tres bits de vectores ISSP: </p><br><ul><li>  100 =&gt; "wrmem" </li><li>  101 =&gt; "rdmem" </li><li>  110 =&gt; "wrreg" </li><li>  111 =&gt; "rdreg" </li></ul><br><p>  Sin embargo, solo se puede obtener una comprensión completa de los procesos dentro del chip a través de la comunicación directa con PSoC. </p><br><a name="a53"></a><br><h2 id="53-obschenie-s-psoc">  5.3.  Chatea con PSoC </h2><br><p>  Como Dirk Petrautsky ya ha <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">portado el</a> código HSSP de Cypress a Arduino, utilicé Arduino Uno para conectar la placa del teclado al conector ISSP. </p><br><p>  Tenga en cuenta que durante mi investigación, cambié bastante el código Dirk.  Puede encontrar mi modificación en GitHub: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí está el</a> script Python correspondiente para comunicarse con Arduino, en mi repositorio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cypress_psoc_tools</a> . </p><br><p>  Entonces, usando Arduino, al principio solo usé vectores "oficiales" para la "comunicación".  Traté de leer la ROM interna usando el comando VERIFY.  Como era de esperar, no pude hacer esto.  Probablemente debido al hecho de que los bits de protección de lectura se activan dentro de la unidad flash. </p><br><p>  Luego creé algunos de mis vectores simples para escribir y leer memorias / registros.  Tenga en cuenta que podemos leer todo el SROM, ¡aunque la unidad flash esté protegida! </p><br><a name="a54"></a><br><h2 id="54-identifikaciya-vnutrichipovyh-registrov">  5.4.  Identificación de registros intra-chip. </h2><br><p>  Al observar los vectores "desensamblados", descubrí que el dispositivo utiliza registros no documentados (0xF8-0xFA) para indicar códigos de operación M8C que se ejecutan directamente, sin pasar por la protección.  Esto me permitió ejecutar varios códigos de operación como "ADD", "MOV A, X", "PUSH" o "JMP".  Gracias a ellos (observando los efectos secundarios que tienen en los registros), pude determinar cuáles de los registros indocumentados son en realidad registros regulares (A, X, SP y PC). </p><br><p>  Como resultado, el código "desensamblado" generado por la herramienta HSSP_disas.rb se ve así (para mayor claridad, agregué comentarios): </p><br><pre> <code class="plaintext hljs">--== init2 ==-- [DE E0 1C] wrreg CPU_F (f7), 0x00 #   [DE C0 1C] wrreg SP (f6), 0x00 #  SP [9F 07 5C] wrmem KEY1, 0x3A #    SSC [9F 20 7C] wrmem KEY2, 0x03 #  [DE A0 1C] wrreg PCh (f5), 0x00 #  PC (MSB) ... [DE 80 7C] wrreg PCl (f4), 0x03 # (LSB) ...  3 ?? [9F 70 1C] wrmem POINTER, 0x80 # RAM-    [DF 26 1C] wrreg opc1 (f9), 0x30 #  1 =&gt; "HALT" [DF 48 1C] wrreg opc2 (fa), 0x40 #  2 =&gt; "NOP" [9F 40 3C] wrmem BLOCKID, 0x01 # BLOCK ID   SSC [DE 00 DC] wrreg A (f0), 0x06 #  "Syscall" : TableRead [DF 00 1C] wrreg opc0 (f8), 0x00 #   SSC, "Supervisory SROM Call" [DF E2 5C] wrreg CPU_SCR0 (ff), 0x12 #  :   </code> </pre> <br><a name="a55"></a><br><h2 id="55-zaschitnye-bity">  5.5.  Brocas protectoras </h2><br><p>  En esta etapa, ya puedo comunicarme con PSoC, pero todavía no tengo información confiable sobre los bits de protección de la unidad flash.  Me sorprendió mucho el hecho de que Cypress no le da al usuario del dispositivo ningún medio para verificar si la protección está activada.  Entré profundamente en Google para finalmente entender que el código HSSP proporcionado por Cypress se actualizó después de que Dirk lanzó su modificación.  Y ahí tienes!  Aquí hay un nuevo vector como este: </p><br><pre> <code class="plaintext hljs">[DE E0 1C] wrreg CPU_F (f7), 0x00 [DE C0 1C] wrreg SP (f6), 0x00 [9F 07 5C] wrmem KEY1, 0x3A [9F 20 7C] wrmem KEY2, 0x03 [9F A0 1C] wrmem 0xFD, 0x00 #   [9F E0 1C] wrmem 0xFF, 0x00 #  [DE A0 1C] wrreg PCh (f5), 0x00 [DE 80 7C] wrreg PCl (f4), 0x03 [9F 70 1C] wrmem POINTER, 0x80 [DF 26 1C] wrreg opc1 (f9), 0x30 [DF 48 1C] wrreg opc2 (fa), 0x40 [DE 02 1C] wrreg A (f0), 0x10 #  syscall ! [DF 00 1C] wrreg opc0 (f8), 0x00 [DF E2 5C] wrreg CPU_SCR0 (ff), 0x12</code> </pre> <br><p>  Usando este vector (ver read_security_data en psoc.py), obtenemos todos los bits de protección en SRAM a 0x80, donde cada bit está protegido con dos bits. </p><br><p>  El resultado es deprimente: todo está protegido en el modo "desactivar lectura y escritura externa".  Por lo tanto, no solo podemos leer cualquier cosa de la unidad flash USB, sino también escribirla (por ejemplo, para introducir un volcador de ROM allí).  Y la única forma de desactivar la protección es borrar completamente el chip completo.  :-( </p><br><a name="a6"></a><br><h1 id="6-pervaya-neudavshayasya-ataka-romx">  6. Primer ataque (fallido): ROMX </h1><br><p>  Sin embargo, podemos probar el siguiente truco: dado que tenemos la capacidad de ejecutar códigos de operación arbitrarios, ¿por qué no ejecutar ROMX, que se usa para leer la memoria flash?  Este enfoque tiene buenas posibilidades de éxito.  Debido a que la función ReadBlock, que lee datos de SROM (que usan los vectores), verifica si se llama desde ISSP.  Sin embargo, el código de operación ROMX, presumiblemente, puede no tener tal verificación.  Entonces, aquí está el código Python (después de agregar algunas clases auxiliares al código Arduino C): </p><br><pre> <code class="plaintext hljs">for i in range(0, 8192): write_reg(0xF0, i&gt;&gt;8) # A = 0 write_reg(0xF3, i&amp;0xFF) # X = 0 exec_opcodes("\x28\x30\x40") # ROMX, HALT, NOP byte = read_reg(0xF0) # ROMX reads ROM[A|X] into A print "%02x" % ord(byte[0]) # print ROM byte</code> </pre> <br><p>  Lamentablemente, este código no funciona.  :-( Más bien, funciona, pero en la salida obtenemos nuestros propios códigos de operación (0x28 0x30 0x40). No creo que la funcionalidad correspondiente del dispositivo sea un elemento de protección contra lectura. Esto es más como un truco de ingeniería: cuando se ejecutan códigos de operación externos, el bus ROM se redirige a un búfer temporal. </p><br><a name="a7"></a><br><h1 id="7-vtoraya-ataka-trassirovka-s-holodnoy-perezagruzkoy">  7. Segundo ataque: seguimiento con reinicio en frío </h1><br><p>  Como el truco de ROMX no funcionó, comencé a pensar en otra variación de este truco, descrita en la publicación <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Arrojando demasiada luz sobre la protección del firmware de un microcontrolador"</a> . </p><br><a name="a71"></a><br><h2 id="71-realizaciya">  7.1.  Implementación </h2><br><p>  El siguiente vector para CHECKSUM-SETUP aparece en la documentación del ISSP: </p><br><pre> <code class="plaintext hljs">[DE E0 1C] wrreg CPU_F (f7), 0x00 [DE C0 1C] wrreg SP (f6), 0x00 [9F 07 5C] wrmem KEY1, 0x3A [9F 20 7C] wrmem KEY2, 0x03 [DE A0 1C] wrreg PCh (f5), 0x00 [DE 80 7C] wrreg PCl (f4), 0x03 [9F 70 1C] wrmem POINTER, 0x80 [DF 26 1C] wrreg opc1 (f9), 0x30 [DF 48 1C] wrreg opc2 (fa), 0x40 [9F 40 1C] wrmem BLOCKID, 0x00 [DE 00 FC] wrreg A (f0), 0x07 [DF 00 1C] wrreg opc0 (f8), 0x00 [DF E2 5C] wrreg CPU_SCR0 (ff), 0x12</code> </pre> <br><p>  Aquí, en esencia, se llama a la función SROM 0x07, como se presenta en la documentación (cursiva mía): </p><br><blockquote>  Esta función suma de comprobación suma de comprobación.  Calcula una suma de verificación de 16 bits del número de bloques establecidos por el usuario en un banco flash, contando desde cero.  El parámetro BLOCKID se usa para transferir el número de bloques que se usarán al calcular la suma de verificación.  Un valor de "1" calculará la suma de verificación para el bloque cero solamente;  mientras que <em>"0" llevará al hecho de que se calculará la suma de verificación total de los 256 bloques del banco flash.</em>  <em>Se devuelve una suma de comprobación de 16 bits a través de KEY1 y KEY2.</em>  En el parámetro KEY1, los 8 bits bajos de la suma de comprobación son fijos, y en KEY2, se registran los 8 bits altos.  Para dispositivos con múltiples bancos de flash, se llama a la función de suma de comprobación para cada uno individualmente.  El número de banco con el que funcionará lo establece el registro FLS_PR1 (al establecer un bit correspondiente al banco flash de destino). </blockquote><p>  Tenga en cuenta que esta es la suma de comprobación más simple: los bytes simplemente se suman uno por uno;  sin caprichos sofisticados de CRC.  Además, sabiendo que el conjunto de registros en el núcleo M8C es muy pequeño, supuse que al calcular la suma de verificación, los valores intermedios se fijarán en las mismas variables que eventualmente irán a la salida: KEY1 (0xF8) / KEY2 (0xF9). </p><br><p>  Entonces, en teoría, mi ataque se ve así: </p><br><ol><li>  Conéctese a través de ISSP. </li><li>  Comenzamos el cálculo de la suma de verificación utilizando el vector CHECKSUM-SETUP. </li><li>  Reiniciamos el procesador después del tiempo especificado T. </li><li>  Lea la RAM para obtener la suma de comprobación actual C. </li><li>  Repita los pasos 3 y 4, aumentando cada vez T. </li><li>  Recuperamos los datos de la unidad flash restando la suma de verificación C anterior de la actual. </li></ol><br><p>  Sin embargo, surgió un problema: el vector Initialize-1, que debemos enviar después del reinicio, sobrescribe KEY1 y KEY2: </p><br><pre> <code class="plaintext hljs">1100101000000000000000 # ,  PSoC    nop nop nop nop nop [DE E0 1C] wrreg CPU_F (f7), 0x00 [DE C0 1C] wrreg SP (f6), 0x00 [9F 07 5C] wrmem KEY1, 0x3A #     [9F 20 7C] wrmem KEY2, 0x03 #   [DE A0 1C] wrreg PCh (f5), 0x00 [DE 80 7C] wrreg PCl (f4), 0x03 [9F 70 1C] wrmem POINTER, 0x80 [DF 26 1C] wrreg opc1 (f9), 0x30 [DF 48 1C] wrreg opc2 (fa), 0x40 [DE 01 3C] wrreg A (f0), 0x09 # SROM- 9 [DF 00 1C] wrreg opc0 (f8), 0x00 # SSC [DF E2 5C] wrreg CPU_SCR0 (ff), 0x12</code> </pre> <br><p>  Este código sobrescribe nuestra preciosa suma de comprobación llamando a Calibrate1 (función SROM 9) ... ¿Tal vez podamos ingresar al modo de programación enviando el número mágico (desde el principio del código anterior) y luego leer SRAM?  ¡Y sí, funciona!  El código Arduino que implementa este ataque es bastante simple: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Cmnd_STK_START_CSUM: checksum_delay = ((<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)getch())&lt;&lt;<span class="hljs-number"><span class="hljs-number">24</span></span>; checksum_delay |= ((<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)getch())&lt;&lt;<span class="hljs-number"><span class="hljs-number">16</span></span>; checksum_delay |= ((<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)getch())&lt;&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>; checksum_delay |= getch(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(checksum_delay &gt; <span class="hljs-number"><span class="hljs-number">10000</span></span>) { ms_delay = checksum_delay/<span class="hljs-number"><span class="hljs-number">1000</span></span>; checksum_delay = checksum_delay%<span class="hljs-number"><span class="hljs-number">1000</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ms_delay = <span class="hljs-number"><span class="hljs-number">0</span></span>; } send_checksum_v(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(checksum_delay) delayMicroseconds(checksum_delay); delay(ms_delay); start_pmode();</code> </pre> <br><ol><li>  Lea checkum_delay. </li><li>  Ejecute el cálculo de suma de verificación (send_checksum_v). </li><li>  Espera un período de tiempo determinado;  dados los siguientes escollos: <br><ul><li>  Maté mucho tiempo hasta que descubrí que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">delayMicroseconds</a> funcionaba correctamente solo con demoras que no superaban los 16383mks; </li><li>  y luego nuevamente mató la misma cantidad de tiempo hasta que descubrió que delayMicroseconds, si pasaba 0 a su entrada, ¡funcionaba completamente mal! </li></ul></li><li>  Vuelva a cargar PSoC en modo de programación (solo envíe el número mágico, sin enviar vectores de inicialización). </li></ol><br><p>  El código Python resultante: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> delay <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">150000</span></span>): <span class="hljs-comment"><span class="hljs-comment">#    for i in range(0, 10): #      try: reset_psoc(quiet=True) #       send_vectors() #    ser.write("\x85"+struct.pack("&gt;I", delay)) #    +    res = ser.read(1) #  arduino ACK except Exception as e: print e ser.close() os.system("timeout -s KILL 1s picocom -b 115200 /dev/ttyACM0 2&gt;&amp;1 &gt; /dev/null") ser = serial.Serial('/dev/ttyACM0', 115200, timeout=0.5) #    continue print "%05d %02X %02X %02X" % (delay, #  RAM- read_regb(0xf1), read_ramb(0xf8), read_ramb(0xf9))</span></span></code> </pre> <br><p>  En pocas palabras, lo que hace este código: </p><br><ol><li>  Vuelve a cargar el PSoC (y le envía un número mágico). </li><li>  Envía vectores de inicialización completos. </li><li>  Llama a la función Arduino Cmnd_STK_START_CSUM (0x85), donde el retraso en microsegundos se pasa como parámetro. </li><li>  Lee la suma de comprobación (0xF8 y 0xF9) y el registro no documentado 0xF1. </li></ol><br><p>  Este código se ejecuta 10 veces en 1 microsegundo.  Aquí se incluye 0xF1 porque fue el único registro que cambió al calcular la suma de verificación.  Quizás este es algún tipo de variable temporal utilizada por el dispositivo de lógica aritmética.  Preste atención al truco feo que reinicio Arduino usando picocom cuando el Arduino deja de dar signos de vida (no tengo idea de por qué). </p><br><a name="a72"></a><br><h2 id="72-schityvaem-rezultat">  7.2.  Lee el resultado </h2><br><p>  El resultado del script Python se ve así (simplificado para facilitar la lectura): </p><br><pre> <code class="plaintext hljs">DELAY F1 F8 F9 # F1 –    # F8     # F9     00000 03 E1 19 [...] 00016 F9 00 03 00016 F9 00 00 00016 F9 00 03 00016 F9 00 03 00016 F9 00 03 00016 F9 00 00 #     0 00017 FB 00 00 [...] 00023 F8 00 00 00024 80 80 00 # 1- : 0x0080-0x0000 = 0x80 00024 80 80 00 00024 80 80 00 [...] 00057 CC E7 00 # 2- : 0xE7-0x80: 0x67 00057 CC E7 00 00057 01 17 01 #   ,    00057 01 17 01 00057 01 17 01 00058 D0 17 01 00058 D0 17 01 00058 D0 17 01 00058 D0 17 01 00058 F8 E7 00 #  E7? 00058 D0 17 01 [...] 00059 E7 E7 00 00060 17 17 00 #  [...] 00062 00 17 00 00062 00 17 00 00063 01 17 01 # , !        00063 01 17 01 [...] 00075 CC 17 01 # , 0x117-0xE7: 0x30</code> </pre> <br><p>  Al mismo tiempo, tenemos un problema: dado que operamos en la suma de verificación real, un byte cero no cambia el valor de lectura.  Sin embargo, dado que todo el procedimiento de cálculo (8192 bytes) toma 0.1478 segundos (con ligeras desviaciones en cada inicio), que corresponde aproximadamente a 18.04 μs por byte, podemos usar este tiempo para verificar el valor de la suma de verificación en los momentos adecuados.  Para las primeras ejecuciones, todo se lee con bastante facilidad, ya que la duración del procedimiento computacional es casi la misma.  Sin embargo, el final de este volcado es menos preciso, porque las "desviaciones insignificantes en el tiempo" con cada ejecución se resumen y se vuelven significativas: </p><br><pre> <code class="plaintext hljs">134023 D0 02 DD 134023 CC D2 DC 134023 CC D2 DC 134023 CC D2 DC 134023 FB D2 DC 134023 3F D2 DC 134023 CC D2 DC 134024 02 02 DC 134024 CC D2 DC 134024 F9 02 DC 134024 03 02 DD 134024 21 02 DD 134024 02 D2 DC 134024 02 02 DC 134024 02 02 DC 134024 F8 D2 DC 134024 F8 D2 DC 134025 CC D2 DC 134025 EF D2 DC 134025 21 02 DD 134025 F8 D2 DC 134025 21 02 DD 134025 CC D2 DC 134025 04 D2 DC 134025 FB D2 DC 134025 CC D2 DC 134025 FB 02 DD 134026 03 02 DD 134026 21 02 DD</code> </pre> <br><p>  Estos son 10 volcados por cada retraso de microsegundos.  El tiempo operativo total para descargar todos los 8192 bytes de una unidad flash es de aproximadamente 48 horas. </p><br><a name="a73"></a><br><h2 id="73-rekonstrukciya-flesh-binarnika">  7.3.  Reconstrucción del binario flash. </h2><br><p>  Todavía no he terminado de escribir un código que reconstruya completamente el código del programa de la unidad flash, teniendo en cuenta todas las desviaciones en el tiempo.  Sin embargo, ya he restaurado el comienzo de este código.  Para asegurarme de que lo hice correctamente, lo desarme usando m8cdis: </p><br><pre> <code class="plaintext hljs">0000: 80 67 jmp 0068h ; Reset vector [...] 0068: 71 10 or F,010h 006a: 62 e3 87 mov reg[VLT_CR],087h 006d: 70 ef and F,0efh 006f: 41 fe fb and reg[CPU_SCR1],0fbh 0072: 50 80 mov A,080h 0074: 4e swap A,SP 0075: 55 fa 01 mov [0fah],001h 0078: 4f mov X,SP 0079: 5b mov A,X 007a: 01 03 add A,003h 007c: 53 f9 mov [0f9h],A 007e: 55 f8 3a mov [0f8h],03ah 0081: 50 06 mov A,006h 0083: 00 ssc [...] 0122: 18 pop A 0123: 71 10 or F,010h 0125: 43 e3 10 or reg[VLT_CR],010h 0128: 70 00 and F,000h ; Paging mode changed from 3 to 0 012a: ef 62 jacc 008dh 012c: e0 00 jacc 012dh 012e: 71 10 or F,010h 0130: 62 e0 02 mov reg[OSC_CR0],002h 0133: 70 ef and F,0efh 0135: 62 e2 00 mov reg[INT_VC],000h 0138: 7c 19 30 lcall 1930h 013b: 8f ff jmp 013bh 013d: 50 08 mov A,008h 013f: 7f ret</code> </pre> <br><p>  ¡Parece bastante creíble! </p><br><a name="a74"></a><br><h2 id="74-nahodim-adres-hraneniya-pinkoda">  7.4.  Encuentra la dirección de almacenamiento de código PIN </h2><br><p>  Ahora que podemos leer la suma de verificación en el momento que necesitamos, podemos verificar fácilmente cómo y dónde cambia cuando: </p><br><ul><li>  ingrese el código PIN incorrecto; </li><li>  cambia el código PIN. </li></ul><br><p>  Primero, para encontrar la dirección de almacenamiento aproximada, realicé un volcado de suma de comprobación en incrementos de 10 ms después de un reinicio.  Luego ingresé el código PIN incorrecto e hice lo mismo. </p><br><p>  El resultado no fue muy agradable, ya que hubo muchos cambios.  Pero al final, pude establecer que la suma de verificación cambió en algún punto del intervalo entre 120,000 μs y 140,000 μs de retraso.  Pero el "código PIN" que obtuve allí estaba completamente equivocado, debido al artefacto del procedimiento delayMicroseconds, que hace cosas extrañas cuando obtiene 0. </p><br><p>  Luego, después de pasar casi 3 horas, recordé que la llamada al sistema CheckSum SROM en la entrada recibe un argumento que especifica el número de bloques para la suma de verificación.  T.O.  podemos localizar fácilmente la dirección de almacenamiento del código PIN y el contador de "intentos incorrectos", exactos al bloque de 64 bytes. </p><br><p>  Mis ejecuciones iniciales dieron el siguiente resultado: </p><br><p><img src="https://habrastorage.org/webt/0n/ol/xc/0nolxcgp8espvfdubrhrmvmbgrg.png"></p><br><p>  Luego cambié el código PIN de "123456" a "1234567" y recibí: </p><br><p><img src="https://habrastorage.org/webt/0r/zp/s2/0rzps2e2mwldmhtot1tswiv7mdq.png"></p><br><p>  Por lo tanto, el código PIN y el contador de intentos incorrectos parecen estar almacenados en el bloque No. 126. </p><br><a name="a75"></a><br><h2 id="75-snimaem-damp-bloka-126">  7.5.  Eliminamos el basurero del bloque No. 126 </h2><br><p>  El bloque No. 126 debe ubicarse en algún lugar en la región de 125x64x18 = 144000mks, desde el comienzo del cálculo de la suma de verificación, en mi volcado completo, y parece bastante creíble.  Luego, después de seleccionar manualmente numerosos volcados inválidos (debido a la acumulación de "ligeras desviaciones en el tiempo"), finalmente obtuve estos bytes (con un retraso de 145527 μs): </p><br><p><img src="https://habrastorage.org/webt/ji/31/ye/ji31yewphovunymnjxp0fcpwrdw.png"></p><br><p>  ¡Está claro que el código PIN se almacena sin cifrar!  Estos valores, por supuesto, no están escritos en códigos ASCII, pero como resultado, reflejan las lecturas tomadas del teclado capacitivo. </p><br><p>  Finalmente, realicé algunas pruebas más para encontrar dónde se almacena el contador de intentos incorrectos.  Aquí está el resultado: </p><br><p><img src="https://habrastorage.org/webt/dc/r5/tf/dcr5tf0yevdxcg5lyrbcr9srowu.png"></p><br><p>  0xFF - significa "15 intentos", y disminuye con cada intento incorrecto. </p><br><a name="a76"></a><br><h2 id="76-vosstanovlenie-pinkoda">  7.6.  Recuperación de código PIN </h2><br><p>  Aquí está mi código feo que reúne todo lo anterior: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dump_pin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> pin_map = {<span class="hljs-number"><span class="hljs-number">0x24</span></span>: <span class="hljs-string"><span class="hljs-string">"0"</span></span>, <span class="hljs-number"><span class="hljs-number">0x25</span></span>: <span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-number"><span class="hljs-number">0x26</span></span>: <span class="hljs-string"><span class="hljs-string">"2"</span></span>, <span class="hljs-number"><span class="hljs-number">0x27</span></span>:<span class="hljs-string"><span class="hljs-string">"3"</span></span>, <span class="hljs-number"><span class="hljs-number">0x20</span></span>: <span class="hljs-string"><span class="hljs-string">"4"</span></span>, <span class="hljs-number"><span class="hljs-number">0x21</span></span>: <span class="hljs-string"><span class="hljs-string">"5"</span></span>, <span class="hljs-number"><span class="hljs-number">0x22</span></span>: <span class="hljs-string"><span class="hljs-string">"6"</span></span>, <span class="hljs-number"><span class="hljs-number">0x23</span></span>: <span class="hljs-string"><span class="hljs-string">"7"</span></span>, <span class="hljs-number"><span class="hljs-number">0x2c</span></span>: <span class="hljs-string"><span class="hljs-string">"8"</span></span>, <span class="hljs-number"><span class="hljs-number">0x2d</span></span>: <span class="hljs-string"><span class="hljs-string">"9"</span></span>} last_csum = <span class="hljs-number"><span class="hljs-number">0</span></span> pin_bytes = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> delay <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">145495</span></span>, <span class="hljs-number"><span class="hljs-number">145719</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>): csum = csum_at(delay, <span class="hljs-number"><span class="hljs-number">1</span></span>) byte = (csum-last_csum)&amp;<span class="hljs-number"><span class="hljs-number">0xFF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"%05d %04x (%04x) =&gt; %02x"</span></span> % (delay, csum, last_csum, byte) pin_bytes.append(byte) last_csum = csum <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"PIN: "</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, len(pin_bytes)): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pin_bytes[i] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> pin_map: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> pin_map[pin_bytes[i]], <span class="hljs-keyword"><span class="hljs-keyword">print</span></span></code> </pre> <br><p>  Aquí está el resultado de su ejecución: </p><br><pre> <code class="plaintext hljs">$ ./psoc.py syncing: KO OK Resetting PSoC: KO Resetting PSoC: KO Resetting PSoC: OK 145495 53e2 (0000) =&gt; e2 145511 5407 (53e2) =&gt; 25 145527 542d (5407) =&gt; 26 145543 5454 (542d) =&gt; 27 145559 5474 (5454) =&gt; 20 145575 5495 (5474) =&gt; 21 145591 54b7 (5495) =&gt; 22 145607 54da (54b7) =&gt; 23 145623 5506 (54da) =&gt; 2c 145639 5506 (5506) =&gt; 00 145655 5533 (5506) =&gt; 2d 145671 554c (5533) =&gt; 19 145687 554e (554c) =&gt; 02 145703 554e (554e) =&gt; 00 PIN: 1 2 3 4 5 6 7 8 9</code> </pre> <br><p>  ¡Hurra!  Funciona! </p><br><p>  Tenga en cuenta que los valores de retraso utilizados por mí probablemente sean relevantes para un PSoC específico: el que usé. </p><br><a name="a8"></a><br><h1 id="8-chto-dalshe">  8. ¿Qué sigue? </h1><br><p> ,     PSoC,     Aigo: </p><br><ul><li>    SRAM,      ; </li><li>      ,   «   »,    . </li></ul><br><p>   ,       – -   .       : </p><br><ul><li>       ,      «   »; </li><li>  FPGA-       (    Arduino); </li><li>    :    ,     RAM,   ,       RAM,  .   Arduino    - ,    Arduino  5 ,            3,3 . </li></ul><br><p>   ,      –   ,     .     ,         , –  ,          . </p><br><p>  SROM,        ReadBlock,       ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>     –     ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">«REcon Brussels 2017»</a> . </p><br><p>    ,      –    :    SRAM,      . </p><br><a name="a9"></a><br><h1 id="9-zaklyuchenie"> 9.  </h1><br><p> ,      ,         ( «») …      (),         ! </p><br><p>     Aigo?  -   HDD-,   2015   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>  SyScan,        HDD-,   ,       .  :-) </p><br><p>          .     40 .     (   )    ( ).    40   ,       .    . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/455529/">https://habr.com/ru/post/455529/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../455517/index.html">Graduado del curso de Netología “Data Science” sobre su trabajo en el sector bancario.</a></li>
<li><a href="../455519/index.html">Cómo implementamos la incorporación de nuevos desarrolladores</a></li>
<li><a href="../455523/index.html">Implementación de la interfaz de usuario de OpenStack LBaaS</a></li>
<li><a href="../455525/index.html">Zimbra y Mail Bomb Defense</a></li>
<li><a href="../455527/index.html">¿Qué está escrito en esto? Detrás de escena de objetos JavaScript</a></li>
<li><a href="../455533/index.html">Bubble Physics: A Search for Foam Destruction Mechanism</a></li>
<li><a href="../455535/index.html">Administrar certificados SSL / TLS en las nubes y contenedores, no trabajo humano</a></li>
<li><a href="../455537/index.html">Amplia optimización de búsqueda: cómo procesar un gráfico con 10 mil millones de estados</a></li>
<li><a href="../455539/index.html">Psíquicos móviles: 10 datos nuevos sobre cómo los dispositivos portátiles lo están mirando</a></li>
<li><a href="../455543/index.html">¿Es fácil y conveniente preparar Kubernetes Cluster? Anunciar operador de complemento</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>