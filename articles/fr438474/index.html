<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôåüèº ü•É üë∏üèΩ Courier: Migration de Dropbox vers gRPC ‚¨õÔ∏è üê† üïõ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Note du traducteur 
 La plupart des logiciels modernes ne sont pas monolithiques, mais se composent de nombreuses parties qui interagissent les unes a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Courier: Migration de Dropbox vers gRPC</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/438474/"><img src="https://habrastorage.org/webt/eu/p8/y-/eup8y-m8hpxc9w2qhvo1qofrmog.jpeg"><br><br><h1>  Note du traducteur </h1><br>  La plupart des logiciels modernes ne sont pas monolithiques, mais se composent de nombreuses parties qui interagissent les unes avec les autres.  Dans cette situation, il est n√©cessaire que la communication des parties interactives du syst√®me ait lieu dans un seul langage (malgr√© le fait que ces parties elles-m√™mes peuvent √™tre √©crites dans diff√©rents langages de programmation et s'ex√©cuter sur diff√©rentes machines).  Pour simplifier la solution √† ce probl√®me, aide gRPC - open-source-framework de Google, publi√© en 2015.  Il r√©sout imm√©diatement un certain nombre de probl√®mes, permettant: <br><br><ul><li>  utiliser le langage Protocol Buffers pour d√©crire l'interaction des services; <br></li><li>  g√©n√©rer un code de programme bas√© sur le protocole d√©crit pour 11 langues diff√©rentes √† la fois pour la partie client et la partie serveur; <br></li><li>  mettre en ≈ìuvre l'autorisation entre les composants en interaction; <br></li><li>  utiliser √† la fois une interaction synchrone et asynchrone. <br></li></ul><br>  gRPC me semblait √™tre un cadre assez int√©ressant, et j'√©tais int√©ress√© √† en savoir plus sur la v√©ritable exp√©rience de Dropbox dans la construction d'un syst√®me bas√© sur celui-ci.  L'article contient de nombreux d√©tails li√©s √† l'utilisation du chiffrement, √† la construction d'un syst√®me fiable, observable et productif, au processus de migration de l'ancienne solution RPC vers la nouvelle. <br><br><div class="spoiler">  <b class="spoiler_title">Clause de non-responsabilit√©</b> <div class="spoiler_text">  L'article d'origine ne contient pas de description de gRPC et certains points peuvent ne pas vous sembler clairs.  Si vous n'√™tes pas familier avec gRPC ou d'autres cadres similaires (par exemple, Apache Thrift), je vous recommande de vous familiariser d'abord avec les id√©es principales (il suffira de lire deux petits articles sur le site officiel: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Qu'est-ce que gRPC?"</a> Et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Concepts gRPC"</a> ). <br><br>  Merci √† Aleksey Ivanov alias <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">SaveTheRbtz</a> pour avoir √©crit l'article original et aid√© √† traduire les endroits difficiles. <br></div></div><a name="habracut"></a><br>  Dropbox g√®re de nombreux services √©crits dans diff√©rentes langues et traitant des millions de demandes par seconde.  Au c≈ìur de notre architecture orient√©e services se trouve Courier, une infrastructure RPC bas√©e sur gPC.  Au cours de son d√©veloppement, nous avons beaucoup appris sur l'extensibilit√© de gRPC, l'optimisation des performances et la transition du syst√®me RPC pr√©c√©dent. <br><br>  <i>Remarque: la publication contient des extraits de code pour Python et Go.</i>  <i>Nous utilisons √©galement Rust et Java.</i> <br><br><h1>  Route vers gRPC </h1><br>  Courier n'est pas le premier framework Dropbox RPC.  Avant m√™me de commencer √† diviser le syst√®me Python monolithique en services s√©par√©s, nous avions besoin d'une base fiable pour √©changer des donn√©es entre services - d'autant plus que le choix d'un cadre aurait des cons√©quences √† long terme. <br><br>  Avant cela, Dropbox a exp√©riment√© diff√©rents cadres RPC.  Tout d'abord, nous avions un protocole individuel pour la s√©rialisation et la d√©s√©rialisation manuelles.  Certains services, tels que la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">journalisation bas√©e sur Scribe</a> , utilisaient <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Apache Thrift</a> .  En m√™me temps, notre infrastructure RPC principale √©tait un protocole HTTP / 1.1 avec des messages s√©rialis√©s en utilisant Protobuf. <br><br>  Cr√©ation d'un cadre, nous avons choisi parmi plusieurs options.  Nous pourrions introduire Swagger (maintenant connu sous le nom d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OpenAPI</a> ) dans l'ancien framework RPC, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">introduire un nouveau standard</a> ou construire un framework bas√© sur Thrift ou gRPC.  Le principal argument en faveur de gRPC √©tait la possibilit√© d'utiliser des protobufs pr√©existants.  De plus, le multiplexage HTTP / 2 et le transfert de donn√©es bidirectionnel ont √©t√© utiles pour nos t√¢ches. <br><br>  <i>Remarque: si fbthrift existait √† ce moment, nous examinerions probablement de plus pr√®s les solutions Thrift.</i> <br><br><h1>  Ce que Courier apporte √† gRPC </h1><br>  Courier n'est pas un protocole RPC;  c'est un moyen d'int√©grer gRPC dans une infrastructure existante.  Le cadre √©tait cens√© √™tre compatible avec nos outils d'authentification, d'autorisation et de d√©couverte de services, ainsi que la collecte, la journalisation et le suivi des statistiques.  Nous avons donc cr√©√© Courier. <br><br>  <i>Bien que dans certains cas, nous utilisons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bandaid</a> comme proxy gRPC, la plupart de nos services communiquent directement entre eux pour minimiser l'impact du RPC sur la latence.</i> <br><br>  Il √©tait important pour nous de r√©duire la quantit√© de code de routine qui doit √™tre √©crit.  √âtant donn√© que Courier sert de cadre g√©n√©ral pour le d√©veloppement de services, il contient des fonctionnalit√©s dont tout le monde a besoin.  La plupart d'entre eux sont activ√©s par d√©faut et peuvent √™tre contr√¥l√©s par des arguments de ligne de commande, et certains sont coch√©s avec une case √† cocher. <br><br><h2>  S√©curit√©: identit√© de service et authentification mutuelle TLS </h2><br>  Courier met en ≈ìuvre notre m√©canisme d'identification de service standard.  Chaque serveur et client se voit attribuer un certificat TLS individuel d√©livr√© par notre propre autorit√© de certification.  L'identifiant personnel cod√© par certificat, qui est utilis√© pour l'authentification mutuelle - le serveur v√©rifie le client, le client v√©rifie le serveur. <br><br>  Dans TLS, o√π nous contr√¥lons les deux c√¥t√©s de la connexion, nous avons introduit des restrictions strictes.  Tous les RPC internes n√©cessitent un cryptage <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PFS</a> .  La version requise de TLS est 1.2 et sup√©rieure.  Nous avons √©galement limit√© le nombre d'algorithmes sym√©triques et asym√©triques, pr√©f√©rant <i>ECDHE-ECDSA-AES128-GCM-SHA256</i> . <br><br>  Apr√®s avoir travers√© l'identification et le d√©chiffrement de la demande, le serveur v√©rifie si le client dispose des autorisations n√©cessaires.  Les listes de contr√¥le d'acc√®s (ACL) et les limites de vitesse peuvent √™tre configur√©es √† la fois pour les services en g√©n√©ral et pour les m√©thodes individuelles.  Leurs param√®tres peuvent √©galement √™tre modifi√©s via notre syst√®me de fichiers distribu√© (AFS).  Gr√¢ce √† cela, les propri√©taires de services peuvent r√©duire la charge en quelques secondes, sans m√™me red√©marrer les processus.  Courier se chargera de s'abonner aux notifications et de mettre √† jour la configuration. <br><br>  <i>Le service d'identit√© est un identifiant global pour les listes de contr√¥le d'acc√®s, les limites de vitesse, les statistiques, etc. De plus, il est cryptographiquement s√©curis√©.</i> <br><br>  Voici un exemple de configuration ACL et de limite de vitesse utilis√©e dans notre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">service de reconnaissance optique de formes</a> : <br><br><pre><code class="plaintext hljs">limits:  dropbox_engine_ocr:    # All RPC methods.    default:      max_concurrency: 32      queue_timeout_ms: 1000      rate_acls:        # OCR clients are unlimited.        ocr: -1        # Nobody else gets to talk to us.        authenticated: 0        unauthenticated: 0</code> </pre> <br><img src="https://habrastorage.org/webt/ll/as/l_/llasl_0osxrxbboxrbjqaalb8ti.png"><br><br>  <i>Nous envisageons la possibilit√© de passer au format SVID (document <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SPIFFE</a> v√©rifi√© cryptographiquement), ce qui permettra de combiner notre framework avec de nombreux projets open source.</i> <br><br><h2>  Observabilit√©: statistiques et suivi </h2><br>  Avec un seul identifiant, vous pouvez facilement trouver des journaux, des statistiques, des fichiers de trace et d'autres donn√©es sur Courier. <br><br><img src="https://habrastorage.org/webt/t_/25/3o/t_253ogfq1bizretdswvdrb_7g0.png"><br><br>  Lors de la g√©n√©ration de code, une collecte de statistiques est ajout√©e pour chaque service et chaque m√©thode √† la fois c√¥t√© client et c√¥t√© serveur.  Les statistiques c√¥t√© serveur sont divis√©es par ID client.  Dans la configuration standard, vous recevrez des donn√©es d√©taill√©es sur la charge, les erreurs et le temps de retard pour chaque service utilisant Courier. <br><br><img src="https://habrastorage.org/webt/g1/6g/_1/g16g_1z72oxaxwwvasrjhznfltk.png"><br><br>  Les statistiques Courier incluent des donn√©es sur la disponibilit√© et la latence c√¥t√© client, ainsi que sur le nombre de demandes et la taille de la file d'attente c√¥t√© serveur.  Il existe d'autres graphiques utiles, en particulier des histogrammes du temps de r√©ponse pour chaque m√©thode et le temps des prises de contact TLS pour chaque client. <br><br>  <i>L'un des avantages de notre g√©n√©ration de code est la possibilit√© d'initialisation statique des structures de donn√©es, telles que les histogrammes et les graphiques de trace.</i>  <i>Cela minimise l'impact sur les performances.</i> <br><br><img src="https://habrastorage.org/webt/p7/6-/fv/p76-fvobtszsgtu2g2tlmwfwlyk.png"><br><br>  L'ancien syst√®me RPC distribuait uniquement <i>request_id</i> sur l'API.  Cela a permis de combiner les donn√©es des journaux de diff√©rents services.  Chez Courier, nous avons introduit une API bas√©e sur un sous-ensemble des sp√©cifications <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OpenTracing</a> .  Nous avons √©crit nos propres biblioth√®ques c√¥t√© client, et c√¥t√© serveur nous avons impl√©ment√© une solution bas√©e sur Cassandra et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Jaeger</a> . <br><br><img src="https://habrastorage.org/webt/dk/hv/iq/dkhviqgdiem3itipi7x87tri_i8.png"><br><br>  Le tra√ßage nous permet de g√©n√©rer des diagrammes de d√©pendance d'un service lors de l'ex√©cution.  Cela aide les ing√©nieurs √† voir toutes les d√©pendances transitives d'un service particulier.  De plus, la fonction est utile pour suivre les d√©pendances ind√©sirables apr√®s le d√©ploiement. <br><br><h2>  Fiabilit√©: d√©lais et d√©connexion </h2><br>  Courier fournit un emplacement central pour impl√©menter les fonctions client courantes (par exemple, les d√©lais d'attente) dans diff√©rentes langues.  Nous avons progressivement ajout√© diverses fonctionnalit√©s, souvent bas√©es sur les r√©sultats d'une analyse ¬´posthume¬ª des probl√®mes √©mergents. <br><br><h3>  D√©lais </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Chaque demande gRPC a un d√©lai</a> indiquant le d√©lai d'expiration du client.  Comme les talons Courier distribuent automatiquement les m√©tadonn√©es connues, le d√©lai de demande est m√™me transf√©r√© en dehors de l'API.  Dans le processus, les d√©lais re√ßoivent un affichage natif.  Par exemple, dans Go, ils sont repr√©sent√©s par le r√©sultat de <i>context.Context de la</i> m√©thode <i>WithDeadline</i> . <br><br>  En fait, nous avons pu r√©soudre des classes enti√®res de probl√®mes de fiabilit√© en obligeant les ing√©nieurs √† fixer des d√©lais pour d√©finir les services appropri√©s. <br><br>  Cette approche va m√™me au-del√† du RPC.  Par exemple, notre ORM MySQL s√©rialise un contexte RPC avec une √©ch√©ance dans un commentaire de requ√™te SQL.  Notre proxy SQL peut analyser les commentaires et ¬´tuer¬ª les requ√™tes lorsque la date limite se produit.  Et en prime lors du d√©bogage des appels de base de donn√©es, nous avons une requ√™te SQL li√©e √† une requ√™te RPC sp√©cifique. <br><br><h3>  D√©connecter </h3><br>  Un autre probl√®me courant rencontr√© par les clients du syst√®me RPC pr√©c√©dent √©tait la mise en ≈ìuvre de l'algorithme du retard exponentiel individuel et des fluctuations sur demande r√©p√©t√©e. <br><br>  Nous avons essay√© de trouver une solution intelligente au probl√®me de d√©connexion dans Courier, en commen√ßant par l'impl√©mentation du tampon LIFO (dernier entr√©, premier sorti) entre le service et le pool de t√¢ches. <br><br><img src="https://habrastorage.org/webt/th/sr/t0/thsrt0kbgxgnexrr9figp9ymg_a.png"><br><br>  En cas de surcharge, LIFO se d√©connecte automatiquement.  La file d'attente, qui est importante, est limit√©e non seulement par la taille, mais aussi <b>par le temps</b> (la demande ne peut passer dans la file d'attente qu'un certain temps). <br><br>  <i>Moins LIFO - modification de l'ordre de traitement des demandes.</i>  <i>Si vous souhaitez conserver la commande d'origine, utilisez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CoDel</a> .</i>  <i>L√† aussi, il y a la possibilit√© de se d√©connecter, et l'ordre de traitement des demandes restera le m√™me.</i> <br><br><img src="https://habrastorage.org/webt/7g/w_/ud/7gw_udkbrsesseak2xrxaucw7fi.png"><br><br><h2>  Introspection: d√©bogage des points de terminaison </h2><br>  Bien que les points de terminaison de d√©bogage ne fassent pas directement partie de Courier, ils sont largement utilis√©s dans Dropbox et sont trop utiles pour ne pas √™tre mentionn√©s. <br><br>  <i>Pour des raisons de s√©curit√©, vous pouvez les ouvrir sur un port s√©par√© ou sur un socket Unix (pour contr√¥ler l'acc√®s √† l'aide des autorisations de fichier).</i>  <i>Vous devez √©galement envisager l'authentification TLS mutuelle, avec laquelle les d√©veloppeurs devront fournir leurs certificats pour acc√©der aux points de terminaison (principalement non seulement en lecture seule).</i> <br><br><h3>  Ex√©cution </h3><br>  La possibilit√© d'analyser l'√©tat d'un service pendant son fonctionnement est tr√®s utile pour le d√©bogage.  Par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://golang.org/pkg/net/">la m√©moire dynamique et les profils CPU sont accessibles via des points de terminaison HTTP ou gRPC</a> . <br><br>  <i>Nous pr√©voyons d'utiliser cette opportunit√© dans la proc√©dure de v√©rification canarienne - pour automatiser la recherche de la diff√©rence entre les anciennes et les nouvelles versions du code.</i> <br><br>  Les noeuds finaux permettent de modifier l'√©tat d'un service lors de l'ex√©cution.  En particulier, les services bas√©s sur Golang peuvent configurer dynamiquement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GCPercent</a> . <br><br><h3>  La biblioth√®que </h3><br>  L'exportation automatique de donn√©es sp√©cifiques √† la biblioth√®que en tant que point de terminaison RPC peut √™tre utile pour les d√©veloppeurs de biblioth√®que.  Par exemple, la biblioth√®que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">malloc peut transf√©rer des statistiques internes dans un vidage</a> .  Autre exemple: un point de terminaison de d√©bogage peut modifier le niveau de journalisation du service √† la vol√©e. <br><br><h3>  Rpc </h3><br>  Bien s√ªr, le d√©pannage dans les protocoles crypt√©s et cod√©s n'est pas facile.  Par cons√©quent, introduire autant d'outils que possible au niveau RPC est une bonne id√©e.  Un exemple d'une telle API introspective <a href="">est la solution Channelz</a> . <br><br><h3>  Niveau d'application </h3><br>  La possibilit√© d'apprendre les options au niveau de l'application peut √©galement √™tre utile.  Un bon exemple est un point de terminaison avec des informations g√©n√©rales sur l'application (avec un hachage de fichiers source ou d'assembly, une ligne de commande, etc.).  Il peut √™tre utilis√© par un syst√®me d'orchestration pour v√©rifier l'int√©grit√© lors du d√©ploiement d'un service. <br><br><h1>  Optimisation des performances </h1><br>  En √©tendant notre infrastructure gRPC √† l'√©chelle requise, nous avons trouv√© plusieurs goulots d'√©tranglement sp√©cifiques √† Dropbox. <br><br><h3>  Consommation de ressources des poign√©es de main TLS </h3><br>  Dans les services qui servent de nombreuses relations, √† la suite des n√©gociations TLS, la charge CPU combin√©e peut √™tre assez grave (en particulier lors du red√©marrage d'un service populaire). <br><br>  Afin d'am√©liorer les performances lors de la signature, nous avons remplac√© les paires de cl√©s RSA-2048 par l'ECDSA P-256.  Voici des exemples de leurs performances (remarque: avec RSA, la v√©rification de signature est plus rapide). <br><br>  <b>RSA:</b> <br><br><pre> <code class="plaintext hljs">~/c0d3/boringssl bazel run -- //:bssl speed -filter 'RSA 2048' Did ... RSA 2048 signing operations in ..............  (1527.9 ops/sec) Did ... RSA 2048 verify (same key) operations in .... (37066.4 ops/sec) Did ... RSA 2048 verify (fresh key) operations in ... (25887.6 ops/sec)</code> </pre> <br>  <b>ECDSA:</b> <br><br><pre> <code class="plaintext hljs">~/c0d3/boringssl bazel run -- //:bssl speed -filter 'ECDSA P-256' Did ... ECDSA P-256 signing operations in ... (40410.9 ops/sec) Did ... ECDSA P-256 verify operations in .... (17037.5 ops/sec)</code> </pre><br>  √âtant donn√© que la v√©rification avec RSA-2048 est environ trois fois plus rapide qu'avec ECDSA P-256, vous pouvez choisir RSA pour les certificats racine et de fin afin d'augmenter la vitesse de fonctionnement.  Mais du point de vue de la s√©curit√©, tout n'est pas aussi simple: vous construirez des cha√Ænes de diff√©rentes primitives cryptographiques, et donc, le niveau des param√®tres de s√©curit√© r√©sultants sera le plus bas.  Et si vous souhaitez am√©liorer les performances, nous vous d√©conseillons d'utiliser des certificats de la version RSA-4096 (et sup√©rieure) en tant que certificats racine et de fin. <br><br>  Nous avons √©galement constat√© que le choix d'une biblioth√®que TLS (et d'indicateurs de compilation) a un impact significatif sur les performances et la s√©curit√©.  Comparez, par exemple, la version LibreSSL sur macOS X Mojave avec OpenSSL auto-√©crit sur le m√™me mat√©riel. <br><br>  <b>LibreSSL 2.6.4:</b> <br><br><pre> <code class="plaintext hljs">~ openssl speed rsa2048 LibreSSL 2.6.4 ...                 sign verify sign/s verify/s rsa 2048 bits 0.032491s 0.001505s     30.8 664.3</code> </pre> <br>  <b>OpenSSL 1.1.1a:</b> <br><br><pre> <code class="plaintext hljs"> ~ openssl speed rsa2048 OpenSSL 1.1.1a  20 Nov 2018 ...                 sign verify sign/s verify/s rsa 2048 bits 0.000992s 0.000029s   1208.0 34454.8</code> </pre> <br>  Cependant, le moyen le plus rapide de cr√©er une n√©gociation TLS est de ne pas la cr√©er du tout!  Nous avons inclus la prise en charge de la reprise de session dans gRPC-core et gRPC-python, r√©duisant ainsi la charge sur le processeur pendant le d√©ploiement. <br><br><h3>  Le chiffrement est peu co√ªteux </h3><br>  Beaucoup pensent √† tort que le chiffrement co√ªte cher.  En fait, m√™me les ordinateurs modernes les plus simples effectuent un chiffrement sym√©trique presque instantan√©ment.  Un processeur standard est capable de crypter et d'authentifier les donn√©es √† une vitesse de 40 Gb / s par c≈ìur: <br><br><pre> <code class="plaintext hljs">~/c0d3/boringssl bazel run -- //:bssl speed -filter 'AES' Did ... AES-128-GCM (8192 bytes) seal operations in ... 4534.4 MB/s</code> </pre> <br>  N√©anmoins, nous devions encore configurer gRPC pour nos blocs de m√©moire, fonctionnant √† une vitesse de 50 Gb / s.  Nous avons constat√© que si la vitesse de chiffrement est approximativement √©gale √† la vitesse de copie, il est important de minimiser le nombre d'op√©rations de <i>m√©mcpy.</i>  De plus, nous avons apport√© quelques modifications au gRPC lui-m√™me. <br><br>  <i>Les protocoles authentifi√©s et chiffr√©s ont √©vit√© de nombreux probl√®mes d√©sagr√©ables (par exemple, la corruption de donn√©es par le processeur, DMA ou sur le r√©seau).</i>  <i>M√™me si vous n'utilisez pas gRPC, nous vous recommandons d'utiliser TLS pour les contacts internes.</i> <br><br><h2>  Canaux de donn√©es √† haute latence (BDP) </h2><br>  Note du traducteur: le sous-titre original utilisait le terme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">produit retardateur de bande passante</a> , qui n'a pas de traduction √©tablie en russe. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le r√©seau f√©d√©rateur Dropbox comprend de nombreux centres de donn√©es</a> .  Parfois, les n≈ìuds situ√©s dans diff√©rentes r√©gions doivent communiquer via RPC, par exemple, pour la r√©plication.  Lors de l'utilisation de TCP, le noyau du syst√®me est responsable de limiter la quantit√© de donn√©es transmises dans une connexion particuli√®re (dans / <i>proc / sys / net / ipv4 / tcp_ {r, w} mem</i> ), bien que gRPC bas√© sur HTTP / 2 ait son propre outil contr√¥le du d√©bit.  La limite sup√©rieure de BDP <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans grpc-go est strictement limit√©e √† 16 Mo</a> , ce qui peut d√©clencher un goulot d'√©tranglement. <br><br><h2>  net.Server Golang ou grpc.Server </h2><br>  Initialement, dans notre code Go, nous prenions en charge HTTP / 1.1 et gRPC avec un seul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://golang.org/pkg/net/">net.Server</a> .  La solution avait un sens en termes de maintien du code du programme, mais cela ne fonctionnait pas du tout parfaitement.  La distribution de HTTP / 1.1 et gRPC sur les serveurs et la migration de gRPC vers grpc.Server ont consid√©rablement am√©lior√© la bande passante Courier et l'utilisation de la m√©moire. <br><br><h2>  golang / protobuf ou gogo / protobuf </h2><br>  Le passage √† gRPC peut augmenter le co√ªt du marshaling et du d√©marshaling.  Pour le code Go, nous avons pu r√©duire consid√©rablement la charge CPU sur les serveurs Courier en passant √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">gogo / protobuf</a> . <br><br>  <i>Comme toujours, la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">transition vers gogo / protobuf s'est accompagn√©e de quelques inqui√©tudes</a> , mais si vous limitez raisonnablement la fonctionnalit√©, il ne devrait y avoir aucun probl√®me.</i> <br><br><h1>  D√©tails d'impl√©mentation </h1><br>  Dans cette section, nous allons approfondir le dispositif Courier, examiner les sch√©mas de protobuf et des exemples de talons de diff√©rentes langues.  Tous les exemples sont tir√©s du service Test, que nous avons utilis√© lors des tests d'int√©gration de Courier. <br><br><h2>  Description du service </h2><br>  Jetez un ≈ìil √† un extrait de la d√©finition du service de test: <br><br><pre> <code class="plaintext hljs">service Test {   option (rpc_core.service_default_deadline_ms) = 1000;   rpc UnaryUnary(TestRequest) returns (TestResponse) {       option (rpc_core.method_default_deadline_ms) = 5000;   }   rpc UnaryStream(TestRequest) returns (stream TestResponse) {       option (rpc_core.method_no_deadline) = true;   }   ... }</code> </pre> <br>  Comme indiqu√© ci-dessus, un d√©lai est requis pour toutes les m√©thodes de messagerie.  En utilisant l'option suivante, vous pouvez d√©finir la date limite pour l'ensemble du service: <br><br><pre> <code class="plaintext hljs">option (rpc_core.service_default_deadline_ms) = 1000;</code> </pre> <br>  Dans le m√™me temps, chaque m√©thode peut √™tre d√©finie √† sa propre √©ch√©ance, annulant l'√©ch√©ance de l'ensemble du service (le cas √©ch√©ant): <br><br><pre> <code class="plaintext hljs">option (rpc_core.method_default_deadline_ms) = 5000;</code> </pre> <br>  Dans de rares cas o√π la date limite n'a pas de sens (par exemple, lors du suivi d'une ressource), le d√©veloppeur peut la d√©sactiver: <br><br><pre> <code class="plaintext hljs">option (rpc_core.method_no_deadline) = true;</code> </pre> <br>  En plus de cela, la description du service doit contenir une documentation API d√©taill√©e, √©ventuellement avec des exemples d'utilisation. <br><br><h2>  G√©n√©ration de talon </h2><br>  Pour offrir une plus grande flexibilit√©, Courier g√©n√®re ses propres stubs sans compter sur la fonctionnalit√© d'intercepteur fournie par gRPC (√† l'exception de Java, dans lequel l'API d'intercepteur a une puissance suffisante).  Comparons nos talons avec les talons Golang standard. <br><br>  Voici √† quoi ressemblent les stubs de serveur gRPC par d√©faut: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test_UnaryUnary_Handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(srv </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, ctx context.Context, dec </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interceptor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">grpc</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnaryServerInterceptor</span></span></span><span class="hljs-function">) </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> {       in := <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(TestRequest)       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := dec(in); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> {               <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err       }       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> interceptor == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> {               <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> srv.(TestServer).UnaryUnary(ctx, in)       }       info := &amp;grpc.UnaryServerInfo{               Server: srv,               FullMethod: <span class="hljs-string"><span class="hljs-string">"/test.Test/UnaryUnary"</span></span>,       }       handler := <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, req </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> {               <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> srv.(TestServer).UnaryUnary(ctx, req.(*TestRequest))       }       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> interceptor(ctx, in, info, handler) }</code> </pre> <br>  Tout le traitement se d√©roule √† l'int√©rieur: d√©codage du protobuf, lancement des intercepteurs (voir la variable <code>interceptor</code> dans le code), lancement du gestionnaire UnaryUnary. <br><br>  Jetez maintenant un ≈ìil aux talons Courier: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test_UnaryUnary_dbxHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(       srv </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{},       ctx context.Context,       dec </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-function">,       </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interceptor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">grpc</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnaryServerInterceptor</span></span></span><span class="hljs-function">) </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(       </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{},       error)</span></span></span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> processor.PanicHandler()       impl := srv.(*dbxTestServerImpl)       metadata := impl.testUnaryUnaryMetadata       ctx = metadata.SetupContext(ctx)       clientId = client_info.ClientId(ctx)       stats := metadata.StatsMap.GetOrCreatePerClientStats(clientId)       stats.TotalCount.Inc()       req := &amp;processor.UnaryUnaryRequest{               Srv: srv,               Ctx: ctx,               Dec: dec,               Interceptor: interceptor,               RpcStats: stats,               Metadata: metadata,               FullMethodPath: <span class="hljs-string"><span class="hljs-string">"/test.Test/UnaryUnary"</span></span>,               Req: &amp;test.TestRequest{},               Handler: impl._UnaryUnary_internalHandler,               ClientId: clientId,               EnqueueTime: time.Now(),       }       metadata.WorkPool.Process(req).Wait()       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> req.Resp, req.Err }</code> </pre> <br>  Il y a pas mal de code ici, alors analysons-le. <br><br>  Tout d'abord, nous reportons l'appel au gestionnaire de panique, qui est responsable de la collecte automatique des erreurs.  Cela nous permettra de collecter toutes les exceptions non intercept√©es dans le r√©f√©rentiel central pour l'agr√©gation et les rapports ult√©rieurs: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> processor.PanicHandler()</code> </pre><br>  Une autre raison pour laquelle nous ex√©cutons notre propre gestionnaire de panique est de s'assurer que l'application se bloque en cas d'erreur.  Dans ce cas, le gestionnaire HTTP golang / net standard ignorera le probl√®me et continuera √† traiter les nouvelles demandes (m√™me endommag√©es et incoh√©rentes). <br><br>  Ensuite, nous transmettons le contexte, red√©finissant les valeurs en fonction des m√©tadonn√©es de la demande entrante: <br><br><pre> <code class="go hljs">ctx = metadata.SetupContext(ctx) clientId = client_info.ClientId(ctx)</code> </pre> <br>  Nous cr√©ons √©galement (et cache pour plus d'efficacit√©) des statistiques client c√¥t√© serveur pour une agr√©gation plus d√©taill√©e: <br><br><pre> <code class="go hljs">stats := metadata.StatsMap.GetOrCreatePerClientStats(clientId)</code> </pre><br>  Cette ligne cr√©e des statistiques pour chaque client (c'est-√†-dire un identifiant TLS) pendant l'ex√©cution.  Nous avons √©galement des statistiques sur toutes les m√©thodes pour chaque service.  Puisque le g√©n√©rateur de stub a acc√®s √† toutes les m√©thodes pendant la g√©n√©ration de code, nous pouvons les cr√©er statiquement √† l'avance, √©vitant ainsi de ralentir le programme. <br><br>  Apr√®s cela, nous cr√©ons une structure de demande, la transf√©rons dans le pool de t√¢ches et attendons l'ex√©cution: <br><br><pre> <code class="go hljs">req := &amp;processor.UnaryUnaryRequest{       Srv:        srv,       Ctx:        ctx,       Dec:        dec,       Interceptor:    interceptor,       RpcStats:       stats,       Metadata:       metadata,       ... } metadata.WorkPool.Process(req).Wait()</code> </pre> <br>  Veuillez noter qu'√† ce stade, nous n'avons pas d√©cod√© le protobuf, ni lanc√© l'intercepteur.  Avant cela, le pool d'acc√®s, la priorisation et la limitation du nombre de requ√™tes ex√©cut√©es doivent passer par le pool de t√¢ches. <br><br>  <i>Notez que la biblioth√®que gRPC prend en charge l'interface TAP, ce qui vous permet d'intercepter les demandes √† une vitesse incroyable.</i>  <i>L'interface fournit l'infrastructure pour la construction de limiteurs de vitesse efficaces avec une consommation de ressources minimale.</i> <br><br><h2>  Codes d'erreur sp√©cifiques pour diff√©rentes applications </h2><br>  Notre g√©n√©rateur de stub permet √©galement aux d√©veloppeurs d'attribuer des codes d'erreur sp√©cifiques √† l'application √† l'aide d'options sp√©ciales: <br><br><pre> <code class="plaintext hljs">enum ErrorCode { option (rpc_core.rpc_error) = true; UNKNOWN = 0; NOT_FOUND = 1 [(rpc_core.grpc_code)="NOT_FOUND"]; ALREADY_EXISTS = 2 [(rpc_core.grpc_code)="ALREADY_EXISTS"]; ... STALE_READ = 7 [(rpc_core.grpc_code)="UNAVAILABLE"]; SHUTTING_DOWN = 8 [(rpc_core.grpc_code)="CANCELLED"]; }</code> </pre> <br>  Les erreurs gRPC et d'application se propagent au sein du service, et √† la fronti√®re de l'API, toutes les erreurs sont remplac√©es par UNKNOWN.  Gr√¢ce √† cela, nous pouvons √©viter de transf√©rer le probl√®me vers d'autres services, ce qui peut entra√Æner un changement dans leur s√©mantique. <br><br><h2>  Modifications de Python </h2><br>  Les stubs Python ajoutent un param√®tre de contexte explicite √† tous les gestionnaires Courier: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dropbox.context <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Context <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dropbox.proto.test.service_pb2 <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> (       TestRequest,       TestResponse, ) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> typing_extensions <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Protocol <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestCourierClient</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Protocol)</span></span></span><span class="hljs-class">:</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnaryUnary</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(           self,           ctx, # type: Context           request, # type: TestRequest           )</span></span></span><span class="hljs-function">:</span></span>       <span class="hljs-comment"><span class="hljs-comment"># type: (...) -&gt; TestResponse       ...</span></span></code> </pre> <br>  Au d√©but, cela avait l'air bizarre, mais au fil du temps, les d√©veloppeurs se sont habitu√©s au <i>ctx</i> explicite comme ils le faisaient auparavant. <br><br>  Veuillez noter que nos talons sont enti√®rement tap√©s pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mypy</a> , qui est compens√© lors d'une refactorisation majeure.  De plus, l'int√©gration avec certains IDE (par exemple PyCharm) est simplifi√©e. <br><br>  En continuant √† suivre la tendance du typage statique, nous ajoutons des annotations mypy aux protocoles eux-m√™mes: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestMessage</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Message)</span></span></span><span class="hljs-class">:</span></span>   field: int   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self,       field : Optional[int] = ...,       )</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> ...   @staticmethod   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FromString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s: bytes)</span></span></span><span class="hljs-function"> -&gt; TestMessage:</span></span> ...</code> </pre> <br>  Ces annotations √©viteront de nombreux bogues courants, tels que l'attribution d'une valeur de <i>None √† un</i> champ de type <i>cha√Æne</i> , par exemple <i>.</i> <br><br>  Ce code <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">est disponible ici</a> . <br><br><h1>  Processus de migration </h1><br>  La cr√©ation d'une nouvelle pile RPC n'est pas une t√¢che facile, mais elle ne se situe m√™me pas √† c√¥t√© du processus de transition compl√®te vers celle-ci, si vous regardez du point de vue de la complexit√© de fonctionnement.  Par cons√©quent, nous avons essay√© de rendre aussi facile que possible pour les d√©veloppeurs de passer de l'ancien RPC √† Courier.  La migration √©tant souvent accompagn√©e d'erreurs, nous avons d√©cid√© de l'impl√©menter par √©tapes. <br><br><h2>  √âtape 0: geler l'ancien RPC </h2><br>  Tout d'abord, nous avons fig√© l'ancien RPC pour ne pas tirer sur une cible en mouvement.  Cela a √©galement incit√© les gens √† passer √† Courier, car toutes les nouvelles fonctionnalit√©s telles que le tra√ßage n'√©taient disponibles que dans les services sur Courier. <br><br><h2>  √âtape 1: interface commune pour les anciens RPC et Courier </h2><br>  Nous avons commenc√© par d√©finir une interface commune pour les anciens RPC et Courier.  Notre g√©n√©ration de code √©tait cens√©e garantir que les deux versions des stubs correspondaient √† cette interface: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TestServer <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> {  UnaryUnary(     ctx context.Context,     req *test.TestRequest) (     *test.TestResponse,     error)  ... }</code> </pre><br><h2>  √âtape 2: migrer vers la nouvelle interface </h2><br>  Apr√®s cela, nous avons commenc√© √† basculer chaque service vers une nouvelle interface, tout en continuant √† utiliser l'ancien RPC.  Souvent, les changements de code √©taient une √©norme diff√©rence, affectant toutes les m√©thodes du service et ses clients.  Cette √©tape √©tant la plus probl√©matique, nous avons voulu √©liminer compl√®tement le risque en ne changeant qu'une chose √† la fois. <br><br>  <i>Des services simples avec un petit nombre de m√©thodes et le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">droit de faire des erreurs</a> peuvent √™tre migr√©s simultan√©ment, sans pr√™ter attention √† nos avertissements.</i> <br><br><h2>  √âtape 3: migrer les clients vers RPC Courier </h2><br>  Au cours du processus de migration, nous avons commenc√© √† lancer simultan√©ment des serveurs anciens et nouveaux sur diff√©rents ports de la m√™me machine.  La commutation de l'impl√©mentation RPC c√¥t√© client a √©t√© effectu√©e en changeant une ligne: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClient</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> -   self.client = LegacyRPCClient(<span class="hljs-string"><span class="hljs-string">'myservice'</span></span>) +   self.client = CourierRPCClient(<span class="hljs-string"><span class="hljs-string">'myservice'</span></span>)</code> </pre> <br>  Veuillez noter qu'avec ce mod√®le, vous pouvez transf√©rer un client √† la fois, en commen√ßant par ceux qui ont un niveau de SLA inf√©rieur. <br><br><h2>  √âtape 4: nettoyage </h2><br>       ,   ,   RPC    (               ).       ‚Äî   . <br><br><h1>  Conclusions </h1><br> , Courier ‚Äî  RPC-,   ,      Dropbox. <br><br>     ,    Courier: <br><br><ol><li>  ‚Äî  .           . <br></li><li>      ‚Äî    ,     . <br></li><li>     ,  .     Codegen. <br></li><li>    . ,    ,   .  , :       . <br></li><li>  RPC-       ‚Äî  ,     . .           . <br></li></ol><br><h1>   </h1><br> Courier,   gRPC  ,    ,      ,      . <br><br>         gRPC  Python   ,     C++  Python  Rust          .         ALTS   TLS-    (,     ). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr438474/">https://habr.com/ru/post/fr438474/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr438464/index.html">SciPy, algorithmes graphiques</a></li>
<li><a href="../fr438466/index.html">B√©quille pour un laser chinois</a></li>
<li><a href="../fr438468/index.html">Colonie. Chapitre 23: Essai routier</a></li>
<li><a href="../fr438470/index.html">Ventes mondiales en d√©cembre et 2018: 2 millions de v√©hicules √©lectriques rechargeables vendus</a></li>
<li><a href="../fr438472/index.html">Environnement architectural modulaire sophistiqu√© dans UE4</a></li>
<li><a href="../fr438476/index.html">A la question des tampons (ring)</a></li>
<li><a href="../fr438478/index.html">GitLab 11.7 publi√© avec des versions, des √©pop√©es imbriqu√©es √† plusieurs niveaux et le registre des packages NPM</a></li>
<li><a href="../fr438480/index.html">Placez-le correctement: 7 endroits id√©aux pour placer du contenu vid√©o</a></li>
<li><a href="../fr438482/index.html">R√©putation, travail et √©migration: comment utiliser les outils de promotion de l'entreprise pour r√©soudre des probl√®mes personnels</a></li>
<li><a href="../fr438486/index.html">Carte m√©moire imp√©n√©trable - noie, g√®le et met le feu au Kingston microSD High Endurance</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>