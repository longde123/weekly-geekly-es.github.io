<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👰🏽 🛸 🔩 Nous accélérons le traitement distribué de grands graphiques en utilisant des structures de données probabilistes et pas seulement 🤾🏼 🤪 🏴󠁧󠁢󠁷󠁬󠁳󠁿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'une des ressources les plus précieuses de tout réseau social est le «graphique des amitiés» - les informations sont diffusées via les connexions dan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous accélérons le traitement distribué de grands graphiques en utilisant des structures de données probabilistes et pas seulement</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/odnoklassniki/blog/465985/"><p><img src="https://habrastorage.org/webt/u1/y0/hk/u1y0hkslkriigc-z1_wkrilk2bm.jpeg"></p><br><p>  L'une des ressources les plus précieuses de tout réseau social est le «graphique des amitiés» - les informations sont diffusées via les connexions dans cette colonne, du contenu intéressant est envoyé aux utilisateurs et des commentaires constructifs sont envoyés aux auteurs de contenu.  Dans le même temps, le graphique est également une source importante d'informations qui vous permet de mieux comprendre l'utilisateur et d'améliorer continuellement le service.  Cependant, dans les cas où le graphique grandit, il est techniquement de plus en plus difficile d'en extraire des informations.  Dans cet article, nous parlerons de quelques astuces utilisées pour traiter de grands graphiques dans OK.ru. </p><a name="habracut"></a><br><p>  Pour commencer, considérez une tâche simple du monde réel: déterminer l'âge de l'utilisateur.  La connaissance de l'âge permet au réseau social de sélectionner des contenus plus pertinents et de mieux s'adapter à la personne.  Il semblerait que l'âge soit déjà indiqué lors de la création d'une page sur les réseaux sociaux, mais en fait, bien souvent, les utilisateurs sont rusés et indiquent un âge différent du réel.  Un graphique social peut aider à rectifier la situation :). </p><br><p>  Prenez, par exemple, Bob (tous les personnages de l'article sont fictifs, toute coïncidence avec la réalité est le résultat de la créativité d'une maison aléatoire): </p><br><p><img src="https://habrastorage.org/webt/wq/ht/tp/wqhttpoxzxunnad14b4csy9owhe.png"></p><br><p>  D'une part, la moitié des amis de Bob sont des adolescents, ce qui suggère que Bob est aussi un adolescent.  Mais il a aussi des amis plus âgés, donc la confiance dans la réponse est faible.  Des informations supplémentaires provenant du graphique social peuvent aider à clarifier la réponse: </p><br><p><img src="https://habrastorage.org/webt/w5/ef/ku/w5efku89o5lqu0hrv0kbrl9nte8.png"></p><br><p>  En tenant compte non seulement des arcs dans lesquels Bob est directement impliqué, mais aussi des arcs entre ses amis, nous pouvons voir que Bob fait partie d'une communauté dense d'adolescents, ce qui nous permet de tirer une conclusion sur son âge avec un plus grand degré de confiance. </p><br><p>  Une telle structure de données est connue sous le nom de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">réseau ego</a> ou sous-graphe ego; elle est utilisée depuis longtemps et a été utilisée avec succès pour résoudre de nombreux problèmes: recherche de communautés, identification de robots et de spam, recommandation d'amis et de contenu, etc.  Cependant, le calcul de l'ego d'un sous-graphique pour <strong>tous les</strong> utilisateurs dans un graphique avec des centaines de millions de nœuds et des dizaines de milliards d'arcs se heurte à un certain nombre de "petites difficultés techniques" :). </p><br><p>  Le problème principal est que lorsque l'on considère les informations sur la "deuxième étape" dans le graphique, une explosion quadratique du nombre de connexions se produit.  Par exemple, pour un utilisateur avec 150 liens directs d'ego, un sous-graphique peut inclure jusqu'à <math></math><img src="https://habrastorage.org/getpro/habr/formulas/967/d1b/e1a/967d1be1a07e4f2bbb381ce9dbfc55f8.svg" alt="150 $ + 150 * 149/2 = 11 325 $" data-tex="inline">  liens, et pour un utilisateur actif avec 5 000 amis, le sous-graphique ego peut atteindre plus de 12 000 000 de liens. </p><br><p>  Une complication supplémentaire est le fait que le graphique est stocké dans un environnement distribué, et aucun nœud n'a une image complète du graphique en mémoire.  Le travail sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partitionnement équilibré des graphiques est</a> effectué à la fois dans l'académie et dans l'industrie, mais même les meilleurs résultats lors de la collecte du sous-graphique de l'ego conduisent à une communication "tout le monde": pour obtenir des informations sur les amis des amis de l'utilisateur, vous devrez vous rendre dans toutes les "partitions" dans la plupart des cas. </p><br><p>  L'une des alternatives de travail dans ce cas sera la duplication forcée des données (par exemple, l'algorithme 3 dans un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article de Google</a> ), mais cette duplication n'est pas non plus gratuite.  Essayons de comprendre ce qui peut être amélioré dans ce processus. </p><br><h3 id="naivnyy-algoritm">  Algorithme naïf </h3><br><p>  Pour commencer, considérons l'algorithme «naïf» pour générer un sous-graphique de l'ego: </p><br><p><img src="https://habrastorage.org/webt/1o/zn/qz/1oznqzgjwr2iadbhoko7vgvp7hm.png"></p><br><p>  L'algorithme suppose que le graphique d'origine est stocké sous forme de liste d'adjacence, c'est-à-dire  Les informations sur tous les amis de l'utilisateur sont stockées dans un seul enregistrement avec l'ID utilisateur dans la clé et la liste des amis ID dans la valeur.  Afin de prendre la deuxième étape et d'obtenir des informations sur les amis dont vous avez besoin: </p><br><ol><li>  Convertissez un graphique en liste d'arêtes, où chaque arête est une entrée distincte. </li><li>  Rassemblez la liste des arêtes sur elle-même, ce qui donnera tous les chemins dans un graphique de longueur 2. </li><li>  Regroupez par début de chemin. </li></ol><br><p>  En sortie pour chaque utilisateur, nous obtenons des listes de chemins de longueur 2 pour chaque utilisateur.  Il convient de noter ici que la structure résultante est en fait un <strong>voisinage en deux étapes de l'utilisateur</strong> , tandis que le sous-graphique ego est son sous-ensemble.  Par conséquent, pour terminer le processus, nous devons filtrer tous les arcs qui sortent des amis immédiats. </p><br><p>  Cet algorithme est bon car il est implémenté en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">deux lignes sur Scala</a> sous <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Apache Spark</a> .  Mais les avantages s'arrêtent là: pour un graphique de taille industrielle, le volume de communication réseau est au-delà de la limite et la durée de fonctionnement est mesurée en jours.  La principale difficulté est créée par deux opérations de mélange qui se produisent lorsque nous nous joignons et que nous nous regroupons.  Est-il possible de réduire la quantité de données envoyées? </p><br><h3 id="ego-podgraf-v-odin-shuffle">  Sous-graphique de l'ego en un seul mélange </h3><br><p>  Étant donné que notre graphique des amitiés est symétrique, vous pouvez utiliser les optimisations proposées par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tomas Schank</a> : </p><br><ol><li>  Vous pouvez obtenir tous les chemins de longueur 2 sans rejoindre - si Bob a des amis Alice et Harry, il existe des chemins Alice-Bob-Harry et Harry-Bob-Alice. </li><li>  Lors du regroupement, deux chemins à l'entrée correspondent au même nouveau bord.  Le chemin Bob-Alice-Dave et Bob-Dave-Alice contient les mêmes informations pour Bob, ce qui signifie que vous ne pouvez envoyer qu'un seul chemin sur deux, en triant les utilisateurs par leur ID. </li></ol><br><p>  Après avoir appliqué les optimisations, le schéma de travail ressemblera à ceci: </p><br><p><img src="https://habrastorage.org/webt/zp/jx/da/zpjxdat-xtd9tqukfqt9tta8n0i.png"></p><br><ol><li>  Au premier stade de la génération, nous obtenons une liste de chemins de longueur 2 avec un filtre d'ordre ID. </li><li>  Le deuxième, nous nous regroupons par le premier utilisateur sur le chemin. </li></ol><br><p>  Dans ce paramètre, l'algorithme exécute une opération de lecture aléatoire et la taille des données transmises sur le réseau est divisée par deux.  :) </p><br><h3 id="raskladyvaem-ego-podgraf-v-pamyati">  Disposez le sous-graphique de l'ego en mémoire </h3><br><p>  Une question importante que nous n'avons pas encore examinée est de savoir comment décomposer les données dans l'ego d'un sous-graphique en mémoire.  Pour stocker le graphique dans son ensemble, nous avons utilisé une liste d'adjacence.  Cette structure est pratique pour les tâches où il est nécessaire de parcourir le graphique fini dans son ensemble, mais elle est coûteuse si nous voulons construire un graphique à partir de morceaux et faire des analyses plus subtiles.  La structure idéale pour notre tâche doit effectuer efficacement les opérations suivantes: </p><br><ol><li>  L'union de deux graphiques obtenus à partir de partitions différentes. </li><li>  Obtenir tous les amis humains. </li><li>  Vérifier si deux personnes sont connectées. </li><li>  Stockage en mémoire sans surcharge de boxe. </li></ol><br><p>  L'un des formats les plus adaptés à ces exigences est l'analogue d'une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">matrice CSR clairsemée</a> : </p><br><p><img src="https://habrastorage.org/webt/nm/rl/ch/nmrlchko5kxd5cslkvu2kh37vkq.png"></p><br><p>  Dans ce cas, le graphique est stocké sous la forme de trois tableaux: </p><br><ol><li>  utilisateurs - un tableau trié avec l'ID de tous les utilisateurs participant au graphique. </li><li>  index - un tableau de la même taille que les utilisateurs, où pour chaque utilisateur est stocké un pointeur d'index au début des informations sur les relations des utilisateurs dans le troisième tableau. </li><li>  friends - un tableau de taille égale au nombre d'arêtes dans le graphique, où les ID des utilisateurs liés sont affichés séquentiellement pour les ID correspondants des utilisateurs.  Le tableau est trié pour la vitesse de traitement dans les informations sur les liens d'un seul utilisateur. </li></ol><br><p>  Dans ce format, l'opération de fusion de deux graphes est effectuée en temps linéaire, et l'opération d'obtention d'informations sur un utilisateur spécifique ou sur une paire d'utilisateurs par logarithme du nombre de sommets.  Dans ce cas, la surcharge en mémoire ne dépend pas de la taille du graphique, car un nombre fixe de tableaux est utilisé.  En ajoutant un quatrième tableau de données de taille égale à la taille des amis, vous pouvez enregistrer des informations supplémentaires associées aux relations dans le graphique. </p><br><p>  En utilisant la propriété de symétrie du graphe, seule la moitié des arcs «triangulaires supérieurs» peut être stockée (lorsque les arcs sont stockés uniquement à partir d'un ID plus petit vers un ID plus grand), mais dans ce cas, la reconstruction de toutes les connexions d'un utilisateur individuel prendra un temps linéaire.  Un bon compromis dans ce cas peut être une approche qui utilise un codage "triangulaire supérieur" pour le stockage et le transfert entre les nœuds, et un codage symétrique lors du chargement de l'ego du sous-graphique en mémoire pour l'analyse. </p><br><h3 id="umenshaem-shuffle">  Réduisez le shuffle </h3><br><p>  Cependant, même après avoir implémenté toutes les optimisations mentionnées ci-dessus, la tâche de construction de tous les sous-graphiques de l'ego fonctionne toujours trop longtemps.  Dans notre cas, environ 6 heures avec une utilisation élevée du cluster.  Un examen plus approfondi montre que la principale source de complexité est toujours l'opération de lecture aléatoire, tandis qu'une partie importante des données impliquées dans la lecture aléatoire est rejetée dans les étapes suivantes.  Le fait est que l'approche décrite crée un voisinage complet en deux étapes pour chaque utilisateur, tandis que le sous-graphique ego n'est qu'un sous-ensemble relativement petit de ce voisinage ne contenant que <em>des</em> arcs <em>internes</em> . </p><br><p>  Par exemple, si, en traitant les voisins directs de Bob - Harry et Frank - nous savions qu'ils n'étaient pas amis l'un de l'autre, alors dès la première étape, nous pourrions filtrer ces chemins externes.  Mais pour savoir pour tous Gary et Frenkov s'ils sont amis, vous devrez faire glisser le graphe d'amitié en mémoire à tous les nœuds de calcul ou effectuer des appels à distance tout en traitant chaque enregistrement, ce qui, selon les conditions de la tâche, est impossible. </p><br><p>  Néanmoins, il existe une solution si nous nous permettons, dans un petit pourcentage de cas, de commettre des erreurs lorsque nous trouvons l'amitié là où elle n'existe pas.  Il existe toute une famille de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">structures de données probabilistes</a> qui permettent de réduire la consommation de mémoire lors du stockage de données par ordre de grandeur, tout en permettant une certaine quantité d'erreur.  La structure la plus célèbre de ce type est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le filtre Bloom</a> , qui depuis de nombreuses années a été utilisé avec succès dans les bases de données industrielles pour compenser les échecs dans le cache "à longue queue". </p><br><p>  La tâche principale du filtre Bloom est de répondre à la question "cet élément est-il inclus dans les nombreux éléments déjà vus?"  De plus, si le filtre répond «non», alors l'élément n'est probablement pas inclus dans l'ensemble, mais s'il répond «oui» - il y a une faible probabilité que l'élément ne soit toujours pas là. </p><br><p>  Dans notre cas, "l'élément" sera une paire d'utilisateurs, et "l'ensemble" sera tous les bords du graphique.  Ensuite, le filtre Bloom peut être appliqué avec succès pour réduire la taille du shuffle: </p><br><p><img src="https://habrastorage.org/webt/eo/_e/ua/eo_eua9cf1wxdkxttwevejawbje.png"></p><br><p>  Après avoir préparé le filtre Bloom à l'avance avec des informations sur le graphique, nous pouvons parcourir les amis de Harry pour découvrir que Bob et Ilona ne sont pas amis, ce qui signifie que nous n'avons pas besoin d'envoyer à Bob des informations sur la connexion entre Gary et Ilona.  Cependant, les informations selon lesquelles Harry et Bob sont amis seuls devront toujours être envoyées afin que Bob puisse restaurer complètement son graphique d'amitié après le regroupement. </p><br><h3 id="ubiraem-shuffle">  Supprimer le shuffle </h3><br><p>  Après avoir appliqué le filtre, la quantité de données envoyées est réduite d'environ 80% et la tâche se termine en 1 heure avec une charge de cluster modérée, vous permettant d'effectuer librement d'autres tâches en parallèle.  Dans ce mode, il peut déjà être mis en service et mis en service au quotidien, mais il y a encore un potentiel d'optimisation. </p><br><p>  Aussi paradoxal que cela puisse paraître, le problème peut être résolu sans recourir à la lecture aléatoire, si vous vous permettez un certain pourcentage d'erreurs.  Et le filtre Bloom peut nous aider avec ceci: </p><br><p><img src="https://habrastorage.org/webt/el/zv/ya/elzvyazgijeu9ew7yt8te-xvmm8.png"></p><br><p>  Si vous parcourez la liste d'amis de Bob à l'aide d'un filtre, nous découvrons qu'Alice et Charlie sont <em>presque certainement</em> amis, nous pouvons immédiatement ajouter l'arc correspondant au sous-graphique de l'ego de Bob.  Dans ce cas, l'ensemble du processus prendra moins de 15 minutes et ne nécessitera pas de transfert de données sur le réseau, cependant, un certain pourcentage d'arcs, en fonction des paramètres de filtre, peut être absent dans la réalité. </p><br><p>  Les arcs supplémentaires ajoutés par le filtre n'introduisent pas de distorsions significatives pour certaines tâches: par exemple, lors du comptage de triangles, nous pouvons facilement corriger le résultat, et lors de la préparation des attributs pour les algorithmes d'apprentissage automatique, la correction ML elle-même peut être apprise à l'étape suivante. </p><br><p>  Mais dans certaines tâches, des arcs supplémentaires entraînent une détérioration fatale de la qualité du résultat: par exemple, lors de la recherche <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">de composants connectés</a> dans le sous-graphique de l'ego avec un ego distant (sans le sommet de l'utilisateur), la probabilité d'un «pont fantôme» entre les composants augmente de façon quadratique par rapport à leur taille, ce qui conduit à que presque partout nous obtenons un gros composant. </p><br><p>  Il existe également une zone intermédiaire où l'effet négatif des arcs supplémentaires doit être évalué expérimentalement: par exemple, certains algorithmes de recherche de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">communauté</a> peuvent assez bien gérer un peu de bruit, renvoyant une structure de communauté presque identique. </p><br><h3 id="vmesto-zaklyucheniya">  Au lieu d'une conclusion </h3><br><p>  Les sous-graphiques des utilisateurs d'Ego sont une source importante d'informations activement utilisée dans OK pour améliorer la qualité des recommandations, affiner les données démographiques et lutter contre le spam, mais leur calcul est semé d'embûches. </p><br><p>  Dans l'article, nous avons examiné l'évolution de l'approche de la tâche de construction de sous-graphiques de l'ego pour tous les utilisateurs d'un réseau social et avons pu améliorer le temps de travail des 20 heures initiales à 1 heure, et dans le cas d'un petit pourcentage d'erreurs, jusqu'à 10-15 minutes. </p><br><p>  Les trois «piliers» sur lesquels repose la décision finale sont: </p><br><ol><li>  Utilisation de la propriété de symétrie du graphe et des algorithmes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tomas Schank</a> . </li><li>  Stockez efficacement les sous-graphiques de l'ego à l'aide d'une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">matrice CSR clairsemée</a> . </li><li>  Utilisez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un filtre Bloom</a> pour réduire le transfert de données sur le réseau. </li></ol><br><p>  Des exemples de l'évolution du code de l'algorithme peuvent être trouvés dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cahier Zeppelin</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr465985/">https://habr.com/ru/post/fr465985/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr465975/index.html">Guide SQL: comment mieux écrire des requêtes (partie 2)</a></li>
<li><a href="../fr465977/index.html">Formation Cisco 200-125 CCNA v3.0. Jour 31. CDP, Syslog et NTP</a></li>
<li><a href="../fr465979/index.html">N'oubliez pas que tout ^ W est exactement ce dont vous avez besoin. Expérience avec Anki. Partie 1 (introduction, avant-dernière)</a></li>
<li><a href="../fr465981/index.html">Mon expérience d'administration IBM DB2 Express-C lorsqu'il est utilisé avec 1C: Enterprise</a></li>
<li><a href="../fr465983/index.html">Intel Comet Lake: un petit 14 nm à la dixième génération</a></li>
<li><a href="../fr465987/index.html">Le perroquet a atterri. L'annonce du livre "Généralisation du deep learning"</a></li>
<li><a href="../fr465989/index.html">Stratégie produit et stratégie d'organisation en termes d'ingénierie système</a></li>
<li><a href="../fr465991/index.html">Travailleurs de l'architecture propre et rapide</a></li>
<li><a href="../fr465993/index.html">Pas besoin d'économiser sur la sécurité numérique</a></li>
<li><a href="../fr465995/index.html">LDC - Excursion</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>