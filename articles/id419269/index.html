<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ†– â˜‘ï¸ ğŸ‘€ Rebus dalam kode, dan cara mendekripsi mereka. Kekuatan Rahasia Pengidentifikasi ğŸ¤¹ğŸ½ ğŸ›©ï¸ ğŸ‘ƒğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kode murni dibaca seperti prosa yang ditulis dengan baik. 
 Grady Butch dalam Clean Code 
 Rebus sebagai kode 


 Apa itu rebus? Ini adalah pesan tere...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rebus dalam kode, dan cara mendekripsi mereka. Kekuatan Rahasia Pengidentifikasi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419269/"><blockquote>  Kode murni dibaca seperti prosa yang ditulis dengan baik. <br>  <i>Grady Butch dalam Clean Code</i> <br></blockquote><h2>  Rebus sebagai kode </h2><br><img src="https://habrastorage.org/webt/7x/kw/pl/7xkwplb_gdofblahdmwqiqvz4f0.jpeg"><br><br>  Apa itu rebus?  Ini adalah pesan terenkripsi.  Penulis rebus mengambil teks manusia biasa dan mengkodekannya menggunakan gambar, angka, dan huruf.  Dan kami melihat enkripsi seperti itu dan mencoba membaca teks sumber. <br><br>  Rebus memiliki dua bentuk.  Di satu sisi, rebus adalah teks asli yang tidak dienkripsi, dan di sisi lain, gambar sandi.  Teks adalah "apa" dari rebus, artinya, pesan.  Gambar adalah "bagaimana": <i>bagaimana</i> tepatnya pesan dienkripsi, dengan cara <i>apa</i> .  Menebak rebus, kami menerjemahkan "bagaimana" menjadi "apa". <br><a name="habracut"></a><br>  Gambar adalah bahasa rebus, gudang persenjataan ekspresifnya.  Rebusnik, seolah-olah, berbicara kepada kita dengan bantuan gambar-gambar ini, mengkomunikasikan sesuatu.  Dia tidak diizinkan menggunakan kata-kata manusia normal. <br><br>  Begini cara teka-teki membaca: <br><br><img src="https://habrastorage.org/webt/ot/yj/pe/otyjpegfyy8v5-7gk8vji8s9ddc.jpeg"><br><br><h2>  Kode itu seperti rebus </h2><br>  Kode program memiliki sesuatu yang sama dengan rebus: ia juga memiliki "apa" dan "bagaimana".  Dan terkadang juga harus didekripsi. <br><br>  "Apa" kode adalah tujuan, makna, efeknya, dan hasil akhir yang kita harapkan darinya.  <i>Apa yang</i> sebenarnya dia <i>lakukan</i> . <br><br>  â€œBagaimanaâ€ dari kode - dengan cara konkret apa akan memenuhi â€œapaâ€, dengan penugasan, penggandaan, dan perbandingan khusus apa;  implementasi algoritma, instruksi ke prosesor.  Ini adalah bahasa kode yang diizinkan, gudang persenjataan ekspresifnya. <br><br>  Martin Fowler membicarakannya dengan cara ini ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Function Length"</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">original</a> ): <br><blockquote>  Smalltalk pada tahun-tahun itu bekerja pada mesin hitam dan putih.  Jika Anda perlu menyorot teks atau gambar, Anda harus membalikkan video.  Kelas di Smalltalk, yang bertanggung jawab atas jadwal, berisi metode 'highlight', dan dalam implementasinya hanya ada satu baris - panggilan ke metode 'terbalik'.  Nama metode itu lebih panjang daripada implementasi, tetapi itu tidak masalah, karena ada jarak yang besar antara niat dan implementasi kode ini. <br></blockquote>  Sorot di sini adalah "apa".  Dalam terminologi Martin - <i>niat</i> : "sorot bagian gambar."  Nama ini mengungkapkan apa fungsi ini.  Reverse adalah bagaimana, <i>implementasi</i> .  <i>Bagaimana</i> tepatnya penyorotan dilakukan (menggunakan inversi gambar).  Itulah perbedaan antara "apa" dan "bagaimana." <br><br>  Terlepas dari kenyataan bahwa nama metode lebih panjang daripada implementasinya, keberadaan metode seperti itu masuk akal karena alasan yang sangat sederhana.  Ketika kita melihat panggilan balik dalam kode, kita harus memahami atau mengingat bahwa inversi gambar digunakan untuk membuat gambar ini lebih terlihat.  Saat kami melihat highlight, kami hanya membaca: "buat fragmen ini lebih terlihat."  Dalam kasus pertama, kami menghabiskan sedikit upaya mental untuk memahami misi yang diberikan pada kode, di yang kedua - tidak.  Dalam kasus pertama, kita melihat rebus di depan kita, membutuhkan dekripsi, di yang kedua - sebuah cerita dalam bahasa yang bisa dimengerti. <br><br>  Seorang programmer, ketika dia menulis sebuah program, seperti rebus.  Programmer mengenkripsi deskripsi manusia dari algoritma menggunakan alat bahasa pemrograman yang tersedia (lebih primitif daripada bahasa manusia).  Mengenkripsi â€œapaâ€ dengan â€œbagaimanaâ€.  Dan kemudian, ia atau koleganya membaca kode, menguraikan <s>rebus ini</s> deskripsi awal algoritma.  <b>Jika dalam proses membaca kode kita tidak dapat segera memahami apa hasil pelaksanaan setiap fragmen akan mengarah, yaitu, apa tujuan, makna kode, maka kode ini adalah rebus, dan perlu ditulis ulang dalam bahasa yang jelas.</b> <br><br>  Masalah dengan teka-teki dalam kode adalah bahwa mereka <i>selalu</i> membutuhkan upaya mental.  Sekalipun kita tidak melaksanakan serangkaian operasi dekripsi dalam pikiran kita, tetapi hanya dengan bodohnya mengingat arti dari beberapa rebus, itu akan tetap menciptakan beban: pertama, untuk mengingat maknanya, dan kedua, pada saat merekam transformasi rebus dalam nilai ini. <br><br>  Menguraikan rebus ketika Anda membaca kode adalah transformasi mental yang dibicarakan Tim Ottinger dalam buku Clean Code.  Benar, di sana ia membahasnya dalam konteks pemberian nama yang dapat dipahami ke variabel, tetapi masalahnya dipengaruhi oleh hal yang persis sama.  Kata untuk tim: <br><blockquote>  Sebagai aturan, programmer sangat cerdas.  Dan orang-orang pintar kadang-kadang suka menunjukkan kekuatan kecerdasan, menunjukkan kemampuan mereka untuk menyulap mental.  Pada akhirnya, jika Anda ingat bahwa variabel r berisi URL dengan host jarak jauh dan skema yang dikonversi ke huruf kecil, ini jelas menunjukkan pikiran Anda. <br>  Salah satu perbedaan antara programmer yang cerdas dan profesional adalah bahwa seorang profesional mengerti: kejelasan adalah yang terpenting.  Profesional menggunakan kekuatan mereka untuk kebaikan dan menulis kode yang dapat dimengerti oleh orang lain. </blockquote>  Bahkan beban kecil dari setiap rebus dapat berubah menjadi masalah jika ada banyak rebus semacam itu.  Anda mungkin menemukan kode yang bacaannya sangat melelahkan.  <b>Ketahui: rebuses dalam kode harus disalahkan atas kelelahan Anda.</b>  Rebus memperburuk kelelahan bahkan penulis sendiri secara langsung dalam proses penulisan kode.  Lagi pula, saat menulis kode, programmer juga terus membaca ulang apa yang ditulis.  Terlepas dari kenyataan bahwa penulis tidak mendekripsi teka-teki sendiri, tetapi hanya ingat, mereka masih membuat beban.  Perangkapnya adalah bahwa <b>penulis tidak melihat teka-teki dalam kode sendiri</b> !  Coba bayangkan berapa banyak upaya mental yang bisa Anda hemat di malam hari, jika Anda mulai menyingkirkan teka-teki dalam kode Anda di pagi hari! <br><br>  Jadi, untuk mengurangi kelelahan dari menulis dan membaca kode, Anda harus menghindari teka-teki.  Tetapi bagaimana cara melakukannya? <br><br><h2>  Bahasa kode.  Kekuatan Identifier </h2><br>  Saya setuju dengan pernyataan Grady Butch bahwa kode bersih dibaca seperti prosa yang bagus.  Ini adalah kondisi yang diperlukan, meskipun tidak mencukupi.  Sebagian besar dari kita akan secara intuitif memahami apa yang dipertaruhkan, tetapi saya ingin mendapatkan setidaknya beberapa definisi: apa itu - prosa yang bagus. <br><br>  Saya bertanya kepada sesama penulis: bagaimana prosa yang baik berbeda dari prosa yang buruk?  Semua orang menjawab secara berbeda, tetapi entah bagaimana menekankan pentingnya bahasa: itu harus kaya, itu harus membuat gambar yang jelas dalam pikiran dan jiwa pembaca.  Ketika pembaca dengan mudah memiliki gambaran yang jelas bahwa penulis ingin menggambar untuknya, kita berhadapan dengan prosa yang baik. <br><br>  Kode memberi tahu prosesor apa yang harus dilakukan.  Kode yang baik pada saat yang sama memberi tahu programmer - dan, lebih lagi, sangat jujur!  - apa yang dia lakukan di sini.  Artinya, ia menetapkan algoritme sedekat mungkin dengan bagaimana penulis sendiri akan melakukannya dalam bahasa alami.  Kode kita harus melakukan ini dengan sangat baik, jika tidak, seorang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">maniak yang</a> tidak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terkendali dengan gergaji atau senapan</a> dapat datang ke rumah kita.  Kode tidak boleh berupa rebus. <br><br>  Alat apa yang dimiliki kode agar tidak menjadi rebus? <br><br>  Sebuah cerita atas nama kode akan mudah dipahami oleh seseorang jika kode itu sendiri berbicara dalam bahasa manusia.  Ini dapat dicapai hanya dengan bantuan pengidentifikasi: nama fungsi, kelas, variabel dan konstanta - karena <b>hanya dalam pengidentifikasi kita dapat menggunakan kata-kata dari bahasa manusia yang kita butuhkan</b> . <br><br>  Tentu saja, kata kunci dari bahasa pemrograman juga kata-kata manusia, tetapi kosakata mereka terlalu buruk.  Sesuatu seperti bahasa Ellochka the Ogre - Anda tidak dapat menulis prosa yang bagus tentangnya. <br><br>  Oleh karena itu, sangat penting bahwa kode program berisi sebanyak mungkin pengidentifikasi yang dipilih dengan benar.  Sehingga keseluruhan mereka membentuk prosa yang ditulis dengan sangat baik. <br><br>  Lihat betapa mudahnya membaca baris kode ketika nama variabel dan metode dipilih dengan baik: <br><br><pre><code class="ruby hljs">pageData.hasAttribute(<span class="hljs-string"><span class="hljs-string">"Test"</span></span>) dom_tree.to_html() emails_str.split(<span class="hljs-string"><span class="hljs-string">','</span></span>)</code> </pre> <br>  Melihat frasa singkat ini, mudah untuk memahami apa yang mereka bicarakan.  Kami tahu hasil apa yang kami dapatkan, karena pengidentifikasi memberi tahu kami tentang hal itu.  Sekarang bayangkan bahwa di tempat setiap panggilan tersebut adalah implementasinya - berapa banyak kecepatan membaca kode "terenkripsi" tersebut berkurang? <br><br>  Banyak teknik refactoring paling sederhana: konstanta bernama, memilih metode, mengganti variabel dengan pemanggilan metode, variabel penjelas, memecah variabel sementara, dll. Semua tentang <b>bagaimana membuat kode berbicara bahasa manusia, dengan kata lain, bagaimana menghindari teka-teki</b> . <br><br><h2>  Metode rebus </h2><br>  Ketika saya membaca Pure Code, saya secara berkala dikunjungi oleh pikiran: "Apa-apaan!". <br><br>  Dari puncak 40 tahun pengalamannya, Robert Martin memberi kami tips tentang cara membuat kode lebih baik.  Sebagai contoh: <br><blockquote>  Aturan pertama: fungsi harus kompak.  Aturan kedua: fungsi harus lebih kompak. </blockquote>  Dan kemudian dia mengakui bahwa dia tidak dapat membuktikan klaimnya secara ilmiah.  Jujur, tidak ilmiah, dia juga melakukan yang buruk.  Persyaratan untuk kekompakan fungsi sudah mulai terlihat seperti dogma - itu sebabnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perdebatan</a> tentang panjang fungsi belum mereda selama beberapa dekade. <br><br>  Dan Bob juga menawarkan untuk menulis setiap fungsi sehingga hanya melakukan satu operasi.  Selain itu, apa operasi yang satu ini - juga tidak terlalu jelas.  Kita harus meminta bantuan prinsip tingkat abstraksi tunggal, yang selanjutnya membingungkan situasi.  Semua ini terlalu berkabut. <br><br>  Martin Fowler lebih pragmatis. <br><br><blockquote>  Tampak bagi saya bahwa argumen tentang pemisahan niat dan realisasi memiliki lebih banyak makna.  Jika, melihat sebuah fragmen kode, Anda perlu berusaha memahami <i>apa</i> yang dilakukannya, maka Anda perlu memasukkannya ke dalam suatu fungsi dan memberinya nama sesuai dengan "apa" ini.  Maka pada saat tujuan fungsi akan segera jelas, dan dalam kebanyakan kasus Anda tidak akan peduli tentang bagaimana fungsi melakukan tugasnya. <br><br><div class="spoiler">  <b class="spoiler_title">Asli</b> <div class="spoiler_text">  Namun, argumen yang paling masuk akal bagi saya adalah pemisahan antara niat dan implementasi.  Jika Anda harus berusaha keras untuk melihat fragmen kode untuk mencari tahu <i>apa</i> yang dilakukannya, maka Anda harus mengekstraknya menjadi fungsi dan beri nama fungsi setelah itu "apa".  Dengan begitu ketika Anda membacanya lagi, tujuan fungsi melompat keluar pada Anda, dan sebagian besar waktu Anda tidak perlu peduli tentang bagaimana fungsi memenuhi tujuannya - yang merupakan tubuh fungsi. <br></div></div></blockquote>  Sudah lebih baik.  Anda lihat sekarang apa yang ingin dikatakan Martin dalam bagian ini?  Maksudnya: mari kita hilangkan teka-teki.  Biarkan kode itu sendiri memberi tahu kami apa hasilnya, dan bagaimana - biarkan disembunyikan di suatu tempat lebih jauh, dalam definisi fungsi.  Biarkan semua teka-teki didekripsi.  Tidak ada teka-teki - tidak ada usaha. <br><br>  Dalam hal apa pun Anda tidak boleh secara buta menerapkan metode refactoring.  Ini sangat jelas, tetapi bagaimana memahami kapan refactoring benar-benar dibutuhkan, dan kapan tidak?  <b>Metode rebus mengatakan: jika setelah refactoring, rebus tidak hilang, maka refactoring tidak diperlukan</b> . <br><br>  <b>Jika Anda tidak dapat menemukan nama untuk fungsi baru yang akan dengan jelas menjelaskan apa yang terjadi di dalamnya, itu adalah lonceng bahwa Anda melakukan sesuatu yang salah di sini.</b>  <b>Cobalah untuk memilih fragmen kode yang sedikit berbeda ke dalam fungsi - yang Anda dapat dengan cepat menemukan nama yang dapat dimengerti dan pendek.</b> <br><br><h2>  Contoh decoding puzzle dalam kode (tidak terlalu berhasil) </h2><br>  Karena itu, saya akan mengutip sebuah fragmen dari buku "Kode Bersih" yang saya sukai.  Sebelum refactoring, kami melihat kode penuh teka-teki.  Refactoring dilakukan oleh penulis buku sesuai dengan aturan kode yang baik yang dipromosikan olehnya, dan - hanya kebetulan - kode refactored persis seperti kode di mana rebus didekripsi. <br><br>  Penulis refactoring sepenuhnya menerapkan pengenal yang dapat dibaca manusia (nama kelas, metode, dan variabel) untuk menunjukkan apa yang sebenarnya dilakukan kode.  Sangat disayangkan bahwa tidak di mana-mana ternyata berhasil, dan di beberapa tempat teka-teki baru muncul bukan teka-teki sebelumnya. <br><br>  Misalnya, metode sertakan yang paling umum digunakan dalam bagian ini <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">include</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String pageName, String arg)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ WikiPage inheritedPage = findInheritedPage(pageName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inheritedPage != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { String pagePathName = getPathNameForPage(inheritedPage); buildIncludeDirective(pagePathName, arg); } }</code> </pre> <br>  Nama itu sama sekali tidak mencerminkan apa yang terjadi dalam implementasi.  Termasuk apa dan dimana? <br><br>  Melihat panggilan ke metode ini: <br><br><pre> <code class="java hljs">include(<span class="hljs-string"><span class="hljs-string">"TearDown"</span></span>, <span class="hljs-string"><span class="hljs-string">"-teardown"</span></span>);</code> </pre> <br>  tidak mungkin untuk mengatakan hasil apa yang akan dicapai oleh pembuat kode di sini. <br><br>  Berikutnya: apa yang dilakukan buildIncludeDirective?  Dilihat dari namanya, ia harus menyusun semacam arahan inklusi, dan jadi apa?  Bawa dia kembali?  Tapi tidak.  Dia segera menambahkannya ke hasil keseluruhan. <br><br>  Dan berikut ini adalah updatePageContent.  Apa yang dikatakan updatePageContent tentang hasil apa yang kita dapatkan setelah memanggil metode?  Tidak ada  Beberapa konten halaman di sana akan diganti oleh tidak ada yang tahu apa.  Mengapa refactoring yang disebut metode ekstraksi dilakukan di sini?  Apakah dia membantu menyingkirkan rebus?  Itu tidak membantu, tetapi hanya lebih membingungkan kodenya.  Di sini kita memiliki kasus di mana tubuh metode lebih disukai.  Konstruksi <br><br><pre> <code class="java hljs">pageData.setContent(newPageContent.toString());</code> </pre> <br>  jauh lebih jelas daripada updatePageContent (). <br><br>  Sebagai hiburan, saya sarankan pembaca untuk mencari tempat buruk lain yang ada dalam <a href="">kode refactored</a> . <br><br>  Untuk membenarkan Bob, saya dapat mengatakan bahwa kode ini tidak lagi dalam versi FitNesse saat ini.  Rupanya, pada gilirannya, dia juga pernah di refactored. <br><br><h2>  Kesimpulan </h2><br>  Panjang fungsi adalah kriteria yang terlalu kabur untuk menentukan kualitas fungsi.  "Fungsi pendek" tidak sama dengan "fungsi yang baik".  Panjang fungsi bukan kriteria, lupakan semuanya. <br><br>  Kode yang baik harus memberikan jawaban untuk pertanyaan programmer - mengapa dia (kode) di sini, apa yang <s>dia lakukan di</s> sini, <s>dia</s> mencapai hasil.  Jawaban ini hanya dapat diberikan menggunakan pengidentifikasi. <br><br>  Sebagai contoh jawaban seperti apa yang tidak boleh diberikan oleh kode, saya ingin memberikan kutipan dari satu buku yang menyenangkan. <br><blockquote>  "Aku Ronan, Victor of Evil," katanya perlahan.  - Dan ini Tarl.  Kami menginginkanmu <br>  ajukan pertanyaan.  Jika kamu berbohong, kamu mati.  Mengerti <br>  "Aku, paman, selamanya," desahnya.  - Tolong.  Saya akan mengatakan itu semua. <br>  "Itu bagus," Ronan melanjutkan.  - Nama? <br>  - Ronan, Pemenang Kejahatan. <br>  - Ya, bukan milikku, bodoh! <br>  "Ah, ya, lalu Tarle," jawab orc dengan nada meminta maaf. <br>  - Dan bukan milikku!  Tarle bergumam.  - Nama Anda, klub!  Nama depan! <br>  "Nama itu nama yang aku gunakan untuk membedakan diriku dari orang lain," gumam orc. <br>  - Nah, beri nama ini di sini!  Teriak Tarle. <br>  Orka tiba-tiba sadar. <br>  - Ah!  Jerawat! <br>  "Jadi, Jerawat, apa yang kamu lakukan di sini?" <br>  "Aku menaruhnya di celanaku," datang jawaban yang jujur. <br>  Ronan mengerutkan hidungnya dengan jijik. <br>  "Tidak, aku bertanya apa yang dilakukan geng Orc-mu di sini!" <br>  Mata Pimple dengan cepat berbalik, memandang sekeliling tempat kejadian. <br>  "Kebanyakan orang tanpa kepala di sini," gumamnya. <br>  Tarle menyentuh bahu Ronan. <br>  "Biarkan aku mencoba," katanya dengan percaya diri dan berbalik ke orc yang ketakutan.  - Katakan padaku, <br>  Jerawat, "lanjutnya," mengapa kamu ada di sini? " <br>  - Oh, paman, dan jangan tanya.  Filosofi eksistensial bagi saya hanyalah hutan yang gelap. <br>  "Dengar, kau sendawa naga," geramnya pelan.  - Geng orcmu punya spesial <br>  alasan untuk datang ke sini.  Apa itu, di hutan? <br>  - Ada banyak pohon. <br>  Mata Ronan melotot, dan Tarle berbalik.  Jerawat, merasa bahwa itu tidak memberikan jawaban yang diharapkan, mulai bergumam lebih lanjut. <br>  - Dan jika Anda ingin tahu alasannya, dan bukan tentang hutan, itu semua karena orang di pub itu <br>  membayar kami untuk datang ke sini dan membunuhmu. <br>  <i>James Bibby, Ronan si Barbar</i> </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id419269/">https://habr.com/ru/post/id419269/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id419257/index.html">India Memperkenalkan RUU Perlindungan PD Baru - Analog ke GDPR lainnya?</a></li>
<li><a href="../id419259/index.html">Rust 1.28 Rilis</a></li>
<li><a href="../id419261/index.html">Tindakan di Google: menulis aplikasi sederhana untuk Google Assistant di Dialogflow dan Cloud Functions for Firebase</a></li>
<li><a href="../id419265/index.html">Menggunakan jaringan saraf multi-layer untuk menghindari rintangan dalam game</a></li>
<li><a href="../id419267/index.html">SOK Coworking Tour</a></li>
<li><a href="../id419271/index.html">Analog dengan Python dan JavaScript. Bagian empat</a></li>
<li><a href="../id419273/index.html">Menulis modul kernel Linux: GPIO dengan dukungan IRQ</a></li>
<li><a href="../id419277/index.html">Kaset termal dengan kelas perlindungan IP68. Cocok untuk penerangan di pemandian</a></li>
<li><a href="../id419279/index.html">Intisari materi menarik untuk pengembang seluler # 264 (30 Juli - 5 Agustus)</a></li>
<li><a href="../id419281/index.html">rcm - rc-file manager: tuning dan gunakan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>