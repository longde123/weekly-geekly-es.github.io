<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💇🏻 🛫 😥 Pelatihan Cisco 200-125 CCNA v3.0. Hari 12. Advanced VLAN 🤹🏾 👨‍👧‍👧 🦁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pelajaran hari ini akan didedikasikan untuk pembelajaran VLAN tingkat lanjut. Sebelum memulai, saya mengingatkan Anda lagi agar Anda tidak lupa untuk ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pelatihan Cisco 200-125 CCNA v3.0. Hari 12. Advanced VLAN</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/458560/"> Pelajaran hari ini akan didedikasikan untuk pembelajaran VLAN tingkat lanjut.  Sebelum memulai, saya mengingatkan Anda lagi agar Anda tidak lupa untuk membagikan video ini dengan teman dan menyukai saluran dan grup YouTube kami di Facebook.  Hari ini kita akan mengeksplorasi tiga topik: NLAN VLAN, VTP (VLAN Trunk Protocol) dan VTP Pruning.  Pertama, ingat apa trunking itu, dan sentuh topik dari dua tutorial video terakhir. <br><br><img src="https://habrastorage.org/webt/kg/o5/3x/kgo53x61an6gnpo3ymcxbwpszzk.jpeg"><br><br>  Jadi, trunk adalah koneksi yang kita gunakan untuk menghubungkan satu switch dengan switch lainnya.  VLAN adalah teknologi yang hanya berlaku untuk sakelar, tetapi perangkat apa pun yang berbicara bahasa enkapsulasi dan dikaitkan dengan sakelar menggunakan protokol .1Q memahami segala sesuatu tentang VLAN.  Komputer tidak tahu apa-apa tentang teknologi ini. <a name="habracut"></a><br><br>  Pada gambar di atas, PC1, PC2, dan PC4 adalah bagian dari VLAN biru, seperti yang Anda ingat dari pelajaran sebelumnya, ini adalah VLAN10.  Jalur itu sendiri, ditunjukkan dengan warna biru, tidak ada hubungannya dengan VLAN, karena VLAN hanya menyentuh port switch.  Dengan demikian, kedua port switch kiri milik VLAN10 dan lalu lintas masuk atau keluar hanya terkait dengan jaringan ini.  Switch tahu bahwa lalu lintas pada port biru ini tidak ada hubungannya dengan port merah, karena ini adalah dua jalur virtual yang berbeda. <br><br>  VLAN adalah konsep untuk switch, sehingga setiap switch mendukung pembuatan dan penyimpanan database jaringan virtual.  Ini adalah tabel yang menunjukkan port mana yang sesuai dengan VLAN tertentu.  Jadi, jika saklar menerima lalu lintas untuk PC1, ia akan memeriksa apakah lalu lintas ini merupakan bagian dari VLAN10 dan meneruskannya ke komputer.  Jika lalu lintas dari PC1 adalah untuk PC4, switch akan merutekannya melalui trunk SW1-SW2.  Begitu lalu lintas memasuki port trunk dari sakelar pertama, ia memasok bingkai dengan header VLAN TAG, yang berisi ID VLAN, dalam kasus kami adalah 10. Setelah menerima lalu lintas ini, sakelar kedua membaca informasi bingkai, melihat bahwa itu adalah lalu lintas VLAN10, dan merutekannya ke port biru untuk PC4. <br><br>  Jadi, trunking adalah proses pemindahan lalu lintas antara dua sakelar, dan VLAN TAG adalah bingkai tajuk yang mengidentifikasi jaringan virtual tertentu dan menunjukkan ke jaringan mana lalu lintas ini harus diarahkan.  Jika secara tidak sengaja lalu lintas biru sampai ke komputer melalui garis merah, ia bahkan tidak akan tahu cara membacanya.  Seolah-olah seseorang berbicara bahasa asing dengan seseorang yang tidak tahu bahasa ini.  Jadi, komputer benar-benar tidak mampu mengenali tag VLAN.  Komputer PC3 terhubung ke sakelar melalui port akses, dan lalu lintas yang kami sebutkan hanya dapat dikirim melalui port trunk. <br><br>  Semua ini adalah fitur level 2 dari model OSI yang dimiliki oleh switch.  Untuk lebih memahami esensi VLAN dan tag, kita harus berpikir seperti saklar.  Misalkan saklar adalah ruangan dengan 5 orang di dalamnya, dan Anda adalah pemilik ruangan ini.  Tiga orang di bawah angka 1,2 dan 4 milik kelompok yang sama, dan dua orang di bawah angka 3 dan 5 milik yang lain, dan tugas Anda adalah memastikan bahwa hanya orang yang termasuk dalam kelompok yang sama yang dapat saling berbicara. <br><br>  Kami melanjutkan diskusi tentang konsep VLAN asli.  Seperti telah disebutkan, setiap port switch dikaitkan dengan VLAN tertentu. <br><br><img src="https://habrastorage.org/webt/ut/ps/hz/utpshzz42fb-mfvubxejjl2l-r4.jpeg"><br><br>  Sebagai contoh, dua port switch pertama terhubung ke VLAN10, port akses ketiga adalah dengan VLAN20, dan port keempat adalah port trunk.  Dengan cara yang sama, SW2 terhubung ke PC4 melalui port VLAN10, ke PC5 melalui port akses VLAN20 dan ke hub melalui port trunk.  Namun, kami memiliki satu masalah - sakelar mahal, sehingga skema sering digunakan di mana dua sakelar terhubung satu sama lain melalui hub.  Dua sakelar terhubung ke hub menggunakan batang, tetapi hub itu sendiri tidak tahu apa-apa tentang konsep VLAN, itu hanya menyalin sinyal.  Seperti yang telah kami katakan, jika lalu lintas VLAN dikirim langsung ke komputer, itu akan menjatuhkannya, karena tidak mengerti apa itu.  Bagaimana cara kita berurusan dengan komputer PC6 yang terhubung langsung ke hub jika ingin membuat koneksi dengan komputer PC4? <br><br>  PC6 mengirimkan lalu lintas yang beralih ke SW2.  Setelah menerima lalu lintas ini, sakelar melihat bahwa frame tidak memiliki tag VLAN dan tidak tahu ke jaringan mana untuk mengirimkannya - VLAN10 atau VLAN20.  Untuk kasus ini, Cisco telah menciptakan teknologi yang disebut Native VLAN, dan secara default VLAN1 adalah Native VLAN. <br><br>  Misalkan kita memiliki komputer lain, saya akan menggambarnya di atas saklar SW2, dan PC ini terhubung ke saklar melalui port VLAN1.  Komputer yang sama terletak di atas SW1 dan juga terhubung melalui VLAN1.  Saya akan menggambar komputer lain di bawah saklar kanan. <br><br><img src="https://habrastorage.org/webt/vv/_y/es/vv_yes5jue8wqlrk_0u-n_l0s_m.jpeg"><br><br>  Dua komputer yang terhubung untuk beralih SW2 melalui VLAN1 dapat berkomunikasi satu sama lain, tetapi tidak dapat berkomunikasi dengan komputer lain.  Ketika sebuah saklar menerima lalu lintas tanpa tanda melalui trunk, itu menganggap bahwa lalu lintas ini ditujukan ke VLAN1, atau Native VLAN, dan meneruskannya ke komputer yang terhubung ke port VLAN1.  Demikian pula, ketika sebuah saklar menerima lalu lintas PC6 tanpa tanda, itu alamat jaringan VLAN1-nya. <br><br>  Apa yang terjadi jika kita memiliki telepon IP Cisco pada garis merah VLAN20 yang terhubung ke PC5 dan beralih SW2?  Ini adalah tata letak khas dari peralatan jaringan kantor.  Dalam hal ini, konsep NLAN VLAN juga digunakan.  Seperti yang saya katakan, komputer tidak tahu apa itu VLAN, dan telepon tahu.  Pertanyaannya adalah apakah kita dapat mengirim data dan suara melalui VLAN yang sama.  Ini adalah situasi yang sangat berbahaya, karena jika komputer berada pada jalur komunikasi yang sama dengan telepon IP, peretas dapat dengan mudah terhubung ke saluran komunikasi tersebut dan menggunakan Wireshark untuk mencegat paket suara.  Kemudian ia dapat mengubah paket suara ini menjadi file audio dan menguping pembicaraan telepon apa pun.  Oleh karena itu, dalam praktiknya, lalu lintas suara dan data tidak pernah dikirim melalui VLAN yang sama.  Bagaimana ini bisa diatur? <br><br>  Kami mengubah port tempat telepon IP terhubung ke port trunk, dan kami percaya bahwa lalu lintas yang melewati port ini adalah lalu lintas suara VLAN30.  Setiap telepon IP Cisco menggunakan protokol enkapsulasi 802.1q, yang biasa disebut .1Q atau Dot 1Q.  Dengan demikian, ketika lalu lintas dari telepon jatuh ke port yang sesuai, saklar mengerti bahwa ini adalah lalu lintas suara VLAN30.  Kita harus memiliki telepon lain yang terhubung ke sakelar SW, yang juga merupakan bagian dari VLAN30. <br><br>  Apa yang terjadi dalam kasus ini dengan komputer PC4 yang terhubung ke sakelar melalui port akses?  Lagi pula, semua lalu lintas yang ditukar komputer ini dengan sakelar adalah milik VLAN10 biru.  Namun, PC5 terhubung ke sakelar melalui trunk, dan untuk trunk kami tidak mengonfigurasi VLAN!  Dalam hal ini, port beroperasi dalam mode trunk, bukan mode akses, jadi kami tidak dapat menggunakan perintah VLAN # akses switchport.  Ia menggunakan konsep yang sama seperti dalam kasus PC6 - jika saklar menerima lalu lintas tanpa tanda, itu akan mengarahkannya ke port VLAN asli, secara default adalah VLAN1. <br><br>  Pertanyaannya adalah apakah VLAN asli dapat diubah.  Jawabannya adalah ya, Anda dapat melakukan ini, misalnya, dalam kasus garis merah, Anda dapat mengubah VLAN asli ke VLAN20, dan kemudian saklar akan mengarahkan lalu lintas dari PC5 ke jaringan VLAN20.  Karena kedua sakelar terhubung oleh trunk, sakelar SW2, setelah menerima lalu lintas VLAN20, akan menganggapnya sebagai lalu lintas VLAN asli dan akan mengirim sakelar SW1 sebagai tidak bertanda. <br><br>  Setelah menerima lalu lintas ini, alihkan SW1 mengenalinya sebagai lalu lintas asli yang tidak ditandai, dan karena VLAN aslinya adalah VLAN1, itu akan mengirimkan lalu lintas ini ke jaringan ini.  Jika kita mengubah VLAN asli, kita harus melakukan ini dengan hati-hati untuk memastikan bahwa semua VLAN asli di semua switch telah berubah dengan benar, jika tidak, ini dapat menyebabkan banyak masalah. <br><br>  Ini adalah gambaran singkat dari VLAN asli, dan sekarang kita akan beralih ke VTP Trunking Protocol (VLAN).  Pertama-tama, Anda harus ingat bahwa, terlepas dari namanya, VTP bukan protokol trunking. <br><br><img src="https://habrastorage.org/webt/th/5y/_9/th5y_9li1saouyjvg2p-baq-2os.jpeg"><br><br>  Dari pelajaran sebelumnya, kita tahu bahwa hanya ada 2 protokol trunking: protokol Cisco eksklusif yang disebut ISL dan protokol 802.1q yang diterima secara umum. <br><br>  VTP juga merupakan protokol milik Cisco, tetapi tidak melakukan trunking dalam arti menciptakan koneksi trunk.  Misalkan kita membuat VLAN10 pada port switch pertama yang terhubung dengan komputer.  Selanjutnya kami memiliki trunk SW1-SW2 dan trunk SW2-SW3.  Ketika port trunk SW1 menerima traffic komputer, ia tahu bahwa itu adalah traffic VLAN10 dan meneruskannya ke switch kedua.  Namun, saklar kedua tidak tahu apa itu VLAN10, karena tidak ada kecuali trunk yang terhubung dengannya, oleh karena itu, untuk menerima lalu lintas ini dan mengirimkannya lebih lanjut, ia menciptakan VLAN10 pada port-portnya.  Switch 3 akan melakukan hal yang sama - setelah menerima lalu lintas di bagasi, itu akan membuat VLAN10. <br><br>  Anda dapat membuat dua port akses di SW3, dan keduanya adalah VLAN10.  Misalkan pada semua 3 switch saya ingin membuat jaringan lain - VLAN20.  Ini hanya akan mungkin setelah port untuk VLAN20 dibuat.  Semakin banyak perangkat, komputer, dan sakelar yang ditambahkan ke jaringan Anda, semakin sulit membuat VLAN baru, itulah sebabnya Cisco mengotomatiskan proses ini dengan membuat VTP. <br><br>  Jika kita membuat VLAN baru, sebut saja VLAN30, di salah satu switch, lalu di semua switch lain yang terhubung oleh trunk, jaringan VLAN30 yang sama secara otomatis dibuat. <br><br><img src="https://habrastorage.org/webt/4q/kr/ca/4qkrcacmrk-mmru_9axdxzxqyhw.jpeg"><br><br>  Basis data VLAN yang diperbarui diperbarui hanya dikirim ke semua switch, setelah itu Anda hanya perlu membuat port akses untuk komputer.  Tanpa protokol ini, Anda harus mengkonfigurasi ulang semua sakelar secara manual.  Kerugian dari VTP adalah bahwa jika Anda membuat perubahan pada basis data VLAN, itu mengubah nomor revisi - nomor revisi.  Biasanya, ketika Anda menggunakan switch langsung dari kotak, semua pengaturan memiliki angka revisi nol.  Ketika Anda menambahkan VLAN baru, seperti kesepuluh, basis data SW1 mendapat nomor revisi # 1.  Dalam kasus ini, saklar kedua mengatakan: "ok, Anda memiliki revisi 1, dan saya memiliki revisi 0, jadi saya harus mengubah nomor revisi saya menjadi 1 dan menyalin semua data dari tabel VLAN Anda ke meja saya."  Saklar ketiga melakukan hal yang sama. <br><br>  Misalkan sekarang 2 switch menambahkan VLAN20 dan mengubah angka revisi menjadi 2, maka switch pertama dan ketiga harus melakukan hal yang sama.  Setiap kali Anda mengubah nomor revisi, protokol memeriksa siapa yang memiliki nomor ini lebih tinggi dan mengubah semua nomor revisi lainnya ke nomor ini, sambil memperbarui tabel VLAN-nya.  Selain itu, VTP tanpa syarat mempercayai sakelar dengan angka revisi tertinggi. <br><br>  Bayangkan situasi ini.  Seorang karyawan baru datang ke perusahaan dan menemukan suatu tempat di sudut saklar yang digunakan untuk melatih staf.  Dia tidak tahu apa-apa tentang ini, melihat bahwa saklar ini terlihat lebih baru, dan memutuskan untuk menghubungkannya ke jaringan bersama.  Dia mengkonfigurasi switch ini, menghubungkannya, misalnya, ke switch SW2 dan membuat trunk.  Dan segera setelah dinyalakan, seluruh jaringan Anda jatuh!  Semuanya berhenti berfungsi, karena koneksi antara komputer dan sakelar sepenuhnya hilang. <br><br><img src="https://habrastorage.org/webt/db/e4/4c/dbe44cdnw1roto-4hchr6ouyr98.jpeg"><br><br>  Mengapa ini terjadi?  Jumlah revisi maksimum dari perusahaan switch adalah 50, karena perusahaan hanya memiliki 5 VLAN - 10,20,30,40,50.  Switch baru digunakan untuk pelatihan, lebih banyak jaringan yang terhubung dengannya, banyak perubahan dilakukan pada pengaturan, sehingga jumlah revisi meningkat menjadi 100. Pada saat yang sama, ia hanya memiliki satu jaringan pada nomor 105 dalam database VLAN. <br><br>  Setelah Pelatihan SW terhubung ke SW2 melalui trunk, saklar kedua melihat bahwa pemula memiliki nomor revisi yang lebih tinggi, dan memutuskan untuk mengubah nomornya ke yang lebih tinggi.  Pada saat yang sama, ia menyalin sendiri tabel VLAN dari switch baru, secara otomatis menghapus semua jaringan VLAN10,20,30 yang ada ...., menggantinya dengan satu VLAN105, yang belum pernah ada dalam jaringan yang ada sebelumnya.  Switch pertama dan ketiga melakukan hal yang sama, mengubah angka revisi dari 50 menjadi 100 dan menghapus jaringan lama dari database, karena mereka tidak terkandung dalam tabel VLAN dari saklar Pelatihan SW. <br>  Beralih SW1 membuat port akses untuk jaringan VLAN10, tetapi setelah memperbarui revisi, jaringan ini menghilang.  Sakelar diatur sedemikian rupa sehingga jika port akses dikonfigurasi untuk bekerja dengan jaringan yang tidak ada dalam basis data VLAN, port ini dinonaktifkan secara terprogram.  Hal yang sama terjadi dengan jaringan VLAN20 dan VLAN30 - sakelar tidak menemukannya di basis data jaringan virtual yang diperbarui dan hanya menonaktifkan port akses yang sesuai, setelah itu jaringan lokal perusahaan yang ada gagal. <br><br><img src="https://habrastorage.org/webt/rp/qd/wu/rpqdwuvxjkyd3j9ybnqxuep2tnu.jpeg"><br><br>  Saya yakinkan Anda bahwa ini sering terjadi dalam praktik.  Secara pribadi, saya telah dua kali menyaksikan suatu peristiwa ketika jaringan berhenti bekerja karena fakta bahwa seseorang menghubungkan saklar baru.  Jadi berhati-hatilah, karena VTP adalah hal yang sangat kuat.  Cisco percaya bahwa karena potensi masalah jenis ini, sebaiknya VTP dihindari. <br><br>  Ada mekanisme untuk mencegah kegagalan jaringan yang disebabkan oleh kesalahan penggunaan VTP.  Ini adalah mekanisme domain VTP, bekerja dengan cara ini: jika domain salah satu sakelar di jaringan berbeda dari domain sakelar lain yang menjalankan protokol VTP, sakelar ini tidak akan direplikasi dalam basis data VLAN.  Namun, terlepas dari mekanisme ini, Cisco tidak merekomendasikan menggunakan protokol ini tanpa kebutuhan khusus. <br><br>  Namun, jika Anda yakin bahwa VTP akan membantu Anda saat membuat jaringan dan bahwa Anda dapat secara bertanggung jawab mendekati konfigurasi switch, Anda dapat mencoba menggunakannya.  VTP memiliki 3 mode: Server, Klien dan Transparan. <br><br>  Mode VTP Server memungkinkan Anda membuat perubahan pada jaringan, yaitu, membuat, menghapus, dan memodifikasi VLAN dari baris perintah sakelar.  Secara default, mode ini diatur di semua sakelar Cisco. <br>  Saya menggambar tiga switch, yang pertama dalam mode Server, dan dua lainnya dalam mode Klien.  Anda dapat membuat VLAN baru hanya pada sakelar pertama, setelah itu basis data akan direplikasi pada sakelar kedua dan ketiga.  Jika Anda mencoba melakukan ini dengan saklar kedua, Anda akan mendapatkan jawabannya: "Saya bukan server, jadi Anda tidak dapat membuat perubahan seperti itu di pengaturan saya."  Ini adalah mekanisme yang mencegah perubahan.  Dengan demikian, Anda dapat memilih salah satu switch oleh server, membuat perubahan pada pengaturannya, dan mereka akan diulang pada switch - klien.  Namun, bagaimana jika Anda tidak bermaksud menggunakan VTP? <br><br>  Untuk sepenuhnya mengabaikan penggunaan protokol ini, Anda harus meletakkan sakelar dalam mode Transparan.  Pada saat yang sama, Anda tidak mematikan mode VTP, hanya saklar tidak lagi menghasilkan iklan VTP, tidak memperbarui database VLAN, dan selalu menggunakan nomor revisi konfigurasi 0. <br><br>  Katakanlah kita menggunakan mode Transparan untuk sakelar kedua.  Setelah menerima informasi VTP, ia akan melihat bahwa protokol ini tidak berlaku untuknya, dan hanya mentransfer informasi ini ke sakelar berikutnya, yang berada dalam mode Klien, tanpa memperbarui apa pun dalam pengaturannya sendiri.  Dengan demikian, mode Transparan berarti menolak untuk menggunakan VTP dengan saklar tertentu. <br><br><img src="https://habrastorage.org/webt/s0/g4/s2/s0g4s23n-tdkt5_5rw0ddeinkt4.jpeg"><br><br>  Jadi ingat bahwa mode Server memungkinkan Anda untuk membuat perubahan, mode Klien memungkinkan Anda untuk menerima perubahan ini, dan mode Transparan mencegah perubahan diterapkan melalui protokol VTP, mentransfernya lebih jauh melalui jaringan. <br><br>  Sekarang mari kita bicara tentang konsep yang disebut Pemangkasan VTP.  Asumsikan bahwa pada switch SW1 ada dua jaringan VLAN30, jaringan VLAN20 merah dan dua jaringan VLAN10 biru. <br><br><img src="https://habrastorage.org/webt/k6/5m/mx/k65mmx0xgcwva-kgosqbfgv17hs.jpeg"><br><br>  Beralih SW2 tidak memiliki port untuk VLAN30.  Namun, secara default, SW1 mentransmisikan VLAN10,20 dan 30 lalu lintas yang ditandai pada trunk.  Sebagai administrator jaringan, Anda tahu bahwa switch SW2 tidak memiliki VLAN30, namun, Anda harus memastikan transfer lalu lintas yang benar.  Untuk melakukan ini, Anda menggunakan informasi tambahan untuk lalu lintas yang berasal dari SW1 menggunakan VTP Pruning.  Anda mengonfigurasi sakelar pertama sedemikian rupa sehingga hanya dapat mentransmisikan lalu lintas jaringan VLAN10 dan VLAN20 melalui trunk, tidak termasuk kemungkinan mentransmisikan lalu lintas jaringan VLAN30 melalui trunk.  Inilah konsep tentang Pemangkasan VTP.  Dalam tutorial video berikutnya, kita akan melihat cara membuat pengaturan yang saya bicarakan hari ini. <br><br>  Jadi, kami membahas tiga konsep: NLAN VLAN, VTP dan VTP Pruning.  Saya harap Anda mengerti segalanya dari apa yang Anda dengar.  Jika tidak, tinjau pelajaran sebanyak yang Anda inginkan, dan jangan ragu untuk bertanya kepada saya melalui email atau di komentar di video ini. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/VqAernKC1BY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Terima kasih telah tinggal bersama kami.  Apakah Anda suka artikel kami?  Ingin melihat materi yang lebih menarik?  Dukung kami dengan melakukan pemesanan atau merekomendasikannya kepada teman-teman Anda, <b>diskon 30% untuk pengguna Habr pada analog unik dari server entry-level yang kami temukan untuk Anda:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Seluruh kebenaran tentang VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps dari $ 20 atau bagaimana membagi server?</a>  (opsi tersedia dengan RAID1 dan RAID10, hingga 24 core dan hingga 40GB DDR4). <br><br>  <b>Dell R730xd 2 kali lebih murah?</b>  Hanya kami yang memiliki <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2 x Intel TetraDeca-Core Xeon 2x E5-2697v3 2.6GHz 14C 64GB DDR4 4x960GB SSD 1Gbps 100 TV dari $ 199</a> di Belanda!</b>  <b><b>Dell R420 - 2x E5-2430 2.2Ghz 6C 128GB DDR3 2x960GB SSD 1Gbps 100TB - mulai dari $ 99!</b></b>  Baca tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara Membangun Infrastruktur Bldg.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kelas menggunakan server Dell R730xd E5-2650 v4 seharga 9.000 euro untuk satu sen?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id458560/">https://habr.com/ru/post/id458560/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id458548/index.html">Buat pustaka gaya Spring Data Repository Anda sendiri dengan Dynamic Proxy dan Spring IoC</a></li>
<li><a href="../id458550/index.html">Simbol GOST Library untuk DipTrace</a></li>
<li><a href="../id458552/index.html">Tentang membandingkan format penyimpanan di Hadoop: mari kita mulai dengan ORC</a></li>
<li><a href="../id458556/index.html">Kembangkan Ekstensi Chrome dengan Angular CLI</a></li>
<li><a href="../id458558/index.html">Presentasi dengan Magento Meetup Kharkiv - Video dan Presentasi</a></li>
<li><a href="../id458564/index.html">Lubang-lubang dalam perjalanan untuk menjadi seorang programmer</a></li>
<li><a href="../id458566/index.html">Bagaimana kami menangkap desainer UX dengan umpan langsung?</a></li>
<li><a href="../id458568/index.html">Bagaimana kami mendapatkan gambar 3D pertama dari gereja Kristen tertua di Rusia</a></li>
<li><a href="../id458572/index.html">Anatoly Slyusar: "Masa komputer Uni Eropa memungkinkan kami untuk melatih sistem dan pemrogram yang diterapkan"</a></li>
<li><a href="../id458574/index.html">Bagaimana tumbuh dari pengembang menjadi pemimpin tim dan hidup dengannya lebih jauh</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>