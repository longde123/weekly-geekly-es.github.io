<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📃 👨🏻‍🎤 🌋 操作系统：三个简单的部分。 第5部分：规划：多级反馈队列（翻译） ☝🏽 🤞🏾 🆒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="操作系统介绍 
 哈Ha！ 我想提请您注意我认为是OSTEP的一系列有趣文献的翻译文章。 本文相当深入地讨论了类Unix操作系统的工作，即处理组成现代OS的进程，各种调度程序，内存和其他类似组件。 您可以在这里看到所有材料的原始材料。 请注意，翻译是非专业地进行的（相当自由），但是我希望我保留了一般...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>操作系统：三个简单的部分。 第5部分：规划：多级反馈队列（翻译）</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450116/"><h1> 操作系统介绍 </h1><br> 哈Ha！ 我想提请您注意我认为是OSTEP的一系列有趣文献的翻译文章。 本文相当深入地讨论了类Unix操作系统的工作，即处理组成现代OS的进程，各种调度程序，内存和其他类似组件。 您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里</a>看到所有材料的原始材料。 请注意，翻译是非专业地进行的（相当自由），但是我希望我保留了一般的含义。 <br><br> 有关此主题的实验室工作可以在这里找到： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">原始的</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">原始的</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我的个人适应</a> </li></ul><br> 其他部分： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第1部分：简介</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第2部分：抽象：过程</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第3部分：Process API简介</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第4部分：计划程序简介</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第5部分：MLFQ调度程序</a> </li></ul><br> 您可以通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">电报</a>查看我的频道=） <br><a name="habracut"></a><br><h2> 规划：多级反馈队列 </h2><br> 在本讲座中，我们将讨论开发最著名的方法之一的问题。 <br> 规划称为<b>多级反馈队列</b> （MLFQ）。  MLFQ调度程序最早是由Fernando J.Corbató于1962年在称为兼容时间共享系统（CTSS）的系统中描述的。 这些作品（包括后来在Multics上的作品）随后被授予图灵奖。 随后对调度程序进行了改进，并获得了某些现代系统中已经可以找到的外观。 <br><br>  MLFQ算法尝试解决2个基本的交叉问题。 <br>  <b>首先</b> ，他尝试优化周转时间，正如我们在上一讲中所讨论的那样，它是通过从最短任务队列的开头开始进行优化的。 但是，操作系统不知道该过程将持续多长时间，这是SJF，STCF算法的操作所必需的知识。  <b>其次</b> ，MLFQ尝试使系统响应用户（例如，在等待任务完成时坐在屏幕上凝视的用户），从而使响应时间最小化。 不幸的是，像RR这样的算法会减少响应时间，但是它们对周转时间指标的影响非常大。 因此，我们要解决的问题是：如何设计一个既可以满足我们的要求又同时又不了解流程本质的调度程序？ 调度程序如何才能了解所启动任务的特征，从而做出更好的计划决策？ <br><br>  <u>问题的实质：在没有完善知识的情况下如何计划任务制定？</u>  <u>如何开发一种调度程序，同时使交互式任务的响应时间最小化，同时又使周转时间最小化，而又不知道完成任务的时间？</u> <br><br> 注意：从以前的事件中学习 <br><br>  MLFQ阵容是一个可以从过去的事件中学习以预测未来的系统的很好的例子。 在OS（以及计算机科学的许多其他分支，包括硬件预测分支和缓存算法）中经常发现类似的方法。 当任务具有行为阶段并可以预测时，类似的行程就起作用。 <br><br> 但是，应谨慎使用这种技术，因为预测很容易被证明是错误的，并导致系统做出比根本没有知识的情况更糟糕的决策。 <br><br><h3>  MLFQ：基本规则 </h3><br> 考虑MLFQ算法的基本规则。 尽管此算法有多种实现方式，但基本方法相似。 <br><br> 在我们将考虑的实现中，在MLFQ中将有几个单独的队列，每个队列将具有不同的优先级。 任何时候，准备执行的任务都在一个队列中。  MLFQ使用优先级来确定要运行的任务，即 优先级较高的任务（队列中优先级较高的任务）将首先启动。 <br><br> 毫无疑问，一个特定的队列中可以有多个任务，因此它们将具有相同的优先级。 在这种情况下，将使用RR引擎来安排这些任务之间的启动。 <br><br> 因此，我们得出了MLFQ的两个基本规则： <br><br><ul><li> 规则1：如果优先级（A）&gt;优先级（B），任务A将启动（B将不启动） </li><li> 规则2：如果优先级（A）=优先级（B），则使用RR启动A＆B </li></ul><br> 基于以上所述，MLFQ规划的关键要素是优先级。  MLFQ不会为每个任务设置固定的优先级，而是根据观察到的行为更改其优先级。 <br><br> 例如，如果在等待键盘输入时某个任务不断退出CPU上的工作，则MLFQ将在较高级别上保持该进程的优先级，因为这是交互式进程应如何工作。 相反，如果任务长时间长时间不间断地大量使用CPU，则MLFQ将降低其优先级。 因此，MLFQ将在进程运行时研究其行为并使用该行为。 <br><br> 让我们举一个例子，说明队列在某个时间点的外观，然后我们得到如下信息： <br><br><img src="https://habrastorage.org/webt/4x/ad/rr/4xadrrwfmrtn3mg-se6wgith9gm.png" alt="图片"><br><br> 在此方案中，2个进程A和B在队列中具有最高优先级。 进程C在中间的某个地方，进程D在队列的尽头。 根据上面对MLFQ算法的描述，调度程序将根据RR仅执行具有最高优先级的任务，并且任务C，D将不工作。 <br><br> 自然地，静态快照不会提供有关MLFQ工作原理的完整信息。 <br> 准确了解图片随时间的变化非常重要。 <br><br><h4> 尝试1：如何更改优先级 </h4><br> 此时，您需要确定MLFQ在其生命周期中将如何更改任务的优先级（从而改变任务在队列中的位置）。 为此，您需要牢记工作流程：运行时间短（因此频繁释放CPU）的许多交互式任务以及在其所有工作时间都使用CPU的多个长任务，而此类任务的响应时间并不重要。 因此，您可以尝试使用以下规则来实现MLFQ算法： <br><br><ul><li> 规则3：当任务进入系统时，它以最高 </li><li> 优先级。 </li><li>  Rule4a：如果任务使用分配给它的整个时间窗口，则其任务 </li><li> 优先级下降。 </li><li>  Rule4b：如果任务在其时间窗口到期之前释放了CPU，则它将 </li><li> 仍然具有相同的优先级。 </li></ul><br>  <b>示例1：一个长期运行的任务</b> <br><br> 如本例所示，准入任务的优先级最高。 在10毫秒的时间窗口后，调度程序会降低进程的优先级。 在下一个时间窗口之后，任务最终会下降到系统中的最低优先级，并保留在那里。 <br><br><img src="https://habrastorage.org/webt/jl/wi/fg/jlwifg8osgxds9bpyftx2aoa9pa.png"><br><br>  <b>示例2：他们提出了一个简短的任务</b> <br><br> 现在，让我们看一个有关MLFQ如何尝试更接近SJF的示例。 在此示例中，有两个任务：A，这是一个长期运行的任务，不断占用CPU； B，这是一个简短的交互式任务。 假设在任务B到达时A已经工作了一段时间。 <br><br><img src="https://habrastorage.org/webt/hq/dp/ou/hqdpouigzrlqbjbhwnvgv9e8mxc.png"><br><br> 在此图中，脚本的结果可见。 像使用CPU的任何任务一样，任务A位于最底部。 任务B将到达T = 100，并将被放在优先级最高的队列中。 由于她的工作时间很短，因此它将在到达最后阶段之前结束。 <br><br> 从此示例中，应该理解该算法的主要目标：由于该算法不知道长任务或短任务，因此首先假定任务是短任务并赋予其最高优先级。 如果这是一个很短的任务，那么它将很快完成；否则，如果它是一个长任务，它将优先缓慢地向下移动，并很快证明这是一个很长的任务，不需要响应。 <br><br>  <b>示例3：I / O呢？</b> <br><br> 现在看一下I / O示例。 如规则4b所述，如果某个进程在没有充分利用处理器时间的情况下释放了处理器，则该进程将保持相同的优先级。 该规则的意图非常简单-如果交互式任务执行许多I / O操作，例如，等待用户按下键或鼠标，则此类任务将在分配的窗口之前释放处理器。 我们不想优先忽略此类任务，因此它将保持在同一水平。 <br><br><img src="https://habrastorage.org/webt/md/oa/f_/mdoaf_yf81n7xvy-j_bdo6hvbmm.png"><br><br> 此示例说明算法如何在此类进程中工作-交互式任务B（执行I / O进程仅需要1ms的CPU）和较长的任务A（其始终使用CPU）。 <br><br>  MLFQ始终保持进程B的最高优先级。 <br> 释放CPU。 如果B是一个交互式任务，则该算法便达到了快速启动交互式任务的目标。 <br><br>  <b>当前的MLFQ算法存在问题</b> <br><br> 在前面的示例中，我们构建了MLFQ的基本版本。 而且，他似乎很好地完成了工作，在长任务之间诚实地分配了处理器时间，并允许短任务或密集访问I / O的任务迅速解决。 不幸的是，这种方法包含几个严重的问题。 <br><br>  <b>首先</b>是饥饿的问题：如果系统中有很多交互式任务，那么它们将消耗所有处理器时间，因此将无法执行单个长任务（它们正在挨饿）。 <br><br>  <b>其次</b> ，聪明的用户可以编写他们的程序，以便 <br> 欺骗计划者。 诀窍是做点什么 <br> 调度程序可以使进程拥有更多的处理器时间。 的算法 <br> 上面描述的很容易受到此类攻击：在时间窗口实际上之前 <br> 结束后，您需要执行I / O操作（对于某些文件，无论是哪个文件） <br> 从而释放CPU。 此行为将使您保持原样 <br> 队列本身，并再次获得更大比例的CPU时间。 如果完成 <br> 这是正确的（例如，释放CPU之前有99％的窗口时间） <br> 这样的任务可以简单地垄断处理器。 <br><br> 最后，程序可以随时间改变其行为。 那些任务 <br> 使用CPU的用户可以进行交互。 在我们的示例中，类似 <br> 任务不会像其他任务一样受到调度程序的适当处理 <br>  （初始）交互式任务。 <br><br>  <u>向听众提问：在现代世界中，可以对计划者进行哪些攻击？</u> <u><br></u> <br><h4> 尝试2：提高优先级 </h4><br><br> 让我们尝试更改规则，看看是否可以避免出现问题 <br> 空腹。 我们该怎么做才能确保相关 <br>  CPU任务将获得时间（即使时间不长）。 <br> 作为解决问题的简单方法，您可以定期提供 <br> 增加系统中所有此类任务的优先级。 有很多方法。 <br> 为此，让我们尝试以简单的示例为例： <br> 所有任务同时具有最高优先级，因此新规则为： <br><ul><li>  <b>规则5</b> ：经过一定的S时间后，将系统中的所有任务转移到最高优先级。 </li></ul><br> 我们的新规则可以立即解决两个问题。 一，流程 <br> 保证不饿死：优先级最高的任务将共享 <br> 根据RR算法的处理器时间，因此所有进程都将收到 <br> 处理器时间。 其次，如果以前使用过某些流程 <br> 只有处理器变得交互式，然后它将与更高的处理器保持一致 <br> 优先级一次之后，将优先级提高到最高。 <br> 考虑一个例子。 在这种情况下，请考虑使用 <br><img src="https://habrastorage.org/webt/cx/te/ll/cxtellydeep0hkgrqfiypt-zqq4.png"><br><br>  CPU和两个交互的，简短的过程。 在图的左侧，该图显示了不增加优先级的行为，因此，当两个交互式任务到达系统后，长任务开始挨饿。 在右图中，每50ms优先级增加一次，因此保证所有进程都将接收处理器时间，并将定期启动。 以这种情况下的50ms为例，实际上这个数字有些大。 <br> 显然，增加S周期性增加的时间会导致 <br> 逻辑问题：应设置什么值？ 荣幸之一 <br> 系统工程师John Ousterhout在voo-doo之类的系统中称相似的数量 <br> 恒定，因为他们以某种方式要求黑魔法正确 <br> 展示。 并且，不幸的是，S具有这种香气。 如果您也设定值 <br> 大-漫长的任务将开始挨饿。 如果将值设置得太低， <br> 交互式任务将不会获得适当的处理器时间。 <br><br><h4> 尝试3：最佳会计 </h4><br><br> 现在我们还有一个问题需要解决：怎么不 <br> 让我们欺骗我们的计划者？ 犯了这个机会是 <br> 规则4a，4b，它允许任务保持优先级，从而释放处理器 <br> 在分配的时间到期之前。 如何应对呢？ <br> 在这种情况下，该解决方案可以认为是对每个CPU时间的最佳考虑 <br>  MLFQ级别。 而不是忘记程序使用的时间 <br> 处理器在指定的时间段内，您应该考虑并保存它。 之后 <br> 该过程已经花费了分配的时间，应该减少到下一个 <br> 优先级。 现在，无论流程如何使用时间- <br> 不断在处理器上进行计算或进行多次调用。 这样 <br> 规则4应改写如下： <br><br><ul><li>  <b>规则4</b> ：任务用完当前队列中分配给它的时间后（无论它释放了CPU多少次），该任务的优先级就会降低（它会向下移动到队列中）。 </li></ul><br> 让我们看一个例子： <br><img src="https://habrastorage.org/webt/je/rs/kw/jerskwy36cewrg6auapm-dal7iu.png">  ” <br><br> 该图显示了如果您尝试欺骗调度程序会发生什么，如何 <br> 如果符合先前的规则4a，4b，则结果在左侧。 快乐新 <br> 规则是右边的结果。 在保护之前，任何进程都可以调用I / O，直到完成和 <br> 因此，启用保护后，无论行为如何，都可以主导CPU <br>  I / O，它仍然会掉线，因此不会不诚实 <br> 占用CPU资源。 <br><br><h4> 改善MLFQ和其他问题 </h4><br> 通过以上改进，出现了新问题：主要问题之一 <br> 问题-如何参数化这样的调度程序？ 即 应该多少 <br> 阵阵？ 队列中程序窗口的大小应为多少？ 怎么 <br> 应经常增加计划的优先级，以避免饥饿和 <br> 考虑到程序行为的变化？ 对于这些问题，绝非易事 <br> 响应，仅在负载和后续配置下进行实验 <br> 规划器可能会导致一些令人满意的平衡。 <br><br> 例如，大多数MLFQ实现都允许您分配不同的 <br> 时间间隔到不同的队列。 高优先级队列通常 <br> 分配短间隔。 这些队列由交互式任务组成， <br> 两者之间的切换非常敏感，应花费10或更少 <br> 毫秒 相反，低优先级队列由使用 <br> 中央处理器 在这种情况下，很长的时间间隔非常适合（100ms）。 <br><img src="https://habrastorage.org/webt/p4/1j/-d/p41j-d9spzwfok9w7xmkcewqgrq.png"><br><br> 在此示例中，有2个任务在高优先级队列20中工作 <br>  ms，被Windows中断10ms。 中等队列中的时间为40毫秒（窗口为20毫秒），低优先级 <br> 队列时间窗口变为40毫秒，任务完成了工作。 <br><br>  Solaris OS MLFQ实现是一类分时调度程序。 <br> 调度程序提供了一组表，这些表确定了应如何精确确定 <br> 改变流程在生命周期中的优先级，大小应该是多少 <br> 选定的窗口以及您需要多长时间提高一次任务的优先级。 管理员 <br> 系统可以与此表进行交互并使调度程序运行 <br> 以不同的方式。 默认情况下，此表中有60个增量队列。 <br> 窗口大小从20毫秒（高优先级）到几百毫秒（最低优先级），以及 <br> 还每秒提升一次所有任务。 <br><br> 其他MLFQ计划人员不使用表格或任何特定的 <br> 相反，他们使用以下方法计算优先级： <br> 数学公式。 因此，例如，FreeBSD中的调度程序将公式用于 <br> 根据流程的多少来计算任务的当前优先级 <br> 使用过的CPU。 此外，CPU的使用会随着时间的流逝而衰减，因此 <br> 因此，优先级增加与上述情况有所不同。 是这样 <br> 称为衰减算法。 从7.1版开始，FreeBSD使用ULE调度程序。 <br><br> 最后，许多计划者还具有其他功能。 例如，一些 <br> 规划人员为操作系统保留了最高级别，因此 <br> 这样，任何用户进程都无法获得最高优先级 <br> 系统。 一些系统允许您提供帮助的技巧。 <br> 调度程序以正确设置优先级。 例如，使用<b>nice</b>命令 <br> 您可以增加或减少任务的优先级，从而增加或 <br> 减少程序占用处理器时间的机会。 <br><h3>  MLFQ：摘要 </h3><br> 我们描述了一种称为MLFQ的计划方法。 他的名字 <br>     —         <br>    . <br>     : <br><ul><li> <b>Rule1</b> :  () &gt; (),     (  ) </li><li> <b>Rule2</b> :  () = (),     RR </li><li> <b>Rule3</b> :     ,       . </li><li> <b>Rule4</b> :            (       CPU)     (   ). </li><li> <b>Rule5</b> :     S        . </li></ul><br> MLFQ     —       <br>   ,        <br>  .          —      (SJF, STCF)    , <br>  CPU .   ,  BSD   , <br> Solaris, Windows, Mac        <br> MLFQ    . <br><h4>  : </h4><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">manpages.debian.org/stretch/manpages/sched.7.en.html</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">en.wikipedia.org/wiki/Scheduling_</a> (computing) </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">pages.lip6.fr/Julia.Lawall/atc18-bouron.pdf</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">www.usenix.org/legacy/event/bsdcon03/tech/full_papers/roberson/roberson.pdf</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">chebykin.org/freebsd-process-scheduling</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN450116/">https://habr.com/ru/post/zh-CN450116/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN450104/index.html">非常困难，也很有趣：TechTrain上的IT社区</a></li>
<li><a href="../zh-CN450106/index.html">SPDS施工现场狭小条件下的施工改造组织项目</a></li>
<li><a href="../zh-CN450110/index.html">设计专利：第二部分（来自Microsoft，Snapchat，三星，Netflix，Airbnb，Tinder的示例）</a></li>
<li><a href="../zh-CN450112/index.html">嗯，箱子怎么了？！ 以儿童滑板车ZINC为例</a></li>
<li><a href="../zh-CN450114/index.html">关于您在EWM中实施的建议</a></li>
<li><a href="../zh-CN450118/index.html">通过网络将屏幕流式传输到多个设备</a></li>
<li><a href="../zh-CN450120/index.html">搜索相似的图像，解析一个算法</a></li>
<li><a href="../zh-CN450122/index.html">创业文摘：遗传学（2019年1月至3月）</a></li>
<li><a href="../zh-CN450124/index.html">配置Strava热图图层的OsmAnd地图</a></li>
<li><a href="../zh-CN450126/index.html">使用Yandex.Direct分发后门和Buhtrap加密器</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>