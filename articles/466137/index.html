<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ô üë≤üèΩ üå∂Ô∏è System.IO. Pipelines: una herramienta poco conocida para los amantes del alto rendimiento üë®üèª üõµ üÜö</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola lector Ha pasado mucho tiempo desde el lanzamiento de .NET Core 2.1. Y las innovaciones tan geniales como Span y Memory ya son ampliamente conoci...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>System.IO. Pipelines: una herramienta poco conocida para los amantes del alto rendimiento</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466137/">  Hola lector  Ha pasado mucho tiempo desde el lanzamiento de .NET Core 2.1.  Y las innovaciones tan geniales como Span y Memory ya son ampliamente conocidas, puedes leer, ver y escuchar mucho sobre ellas.  Sin embargo, desafortunadamente, la biblioteca llamada System.IO. Pipeslines no recibi√≥ la misma atenci√≥n.  Casi todo lo que hay sobre este tema es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la √∫nica publicaci√≥n</a> que se ha traducido y copiado en muchos recursos.  Deber√≠a haber m√°s informaci√≥n sobre esa tecnolog√≠a para verla desde diferentes √°ngulos. <br><br><img src="https://habrastorage.org/webt/fe/ff/_q/feff_q0xj_lqisaxmeji-eomyne.jpeg"><br><a name="habracut"></a><br><h2>  Introduccion </h2><br>  Entonces, esta biblioteca tiene como objetivo acelerar el procesamiento de la transmisi√≥n de datos.  Originalmente fue creado y utilizado por el equipo de desarrollo de Kestrel (un servidor web multiplataforma para ASP.NET Core), pero actualmente est√° disponible para los mortales a trav√©s de un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">paquete nuget</a> . <br><br>  Antes de profundizar en el tema, podemos imaginar el mecanismo de la biblioteca como un an√°logo mejorado de MemoryStream.  El problema con el MemoryStream original es un n√∫mero excesivo de copias, lo cual es obvio si recuerda que se utiliza una matriz de bytes privada dentro de MemoryStream como un b√∫fer.  Por ejemplo, en los m√©todos de <a href="">lectura</a> y <a href="">escritura</a> puede ver claramente la copia de datos.  Por lo tanto, para el objeto que queremos escribir en la secuencia, se crear√° una copia en el b√∫fer interno y, durante la lectura, se devolver√° una copia de la copia interna al consumidor.  Parece que no es el uso m√°s racional de la memoria. <br><br>  System.IO.Pipelines no tiene como objetivo reemplazar todas las transmisiones, es una herramienta adicional en el arsenal de un desarrollador que escribe c√≥digo de alto rendimiento.  Le sugiero que se familiarice con los m√©todos y clases b√°sicos, vea los detalles de su implementaci√≥n y analice ejemplos b√°sicos. <br><br>  Comencemos con los detalles internos y de implementaci√≥n, al mismo tiempo mirando fragmentos de c√≥digo simples.  Despu√©s de eso, quedar√° claro c√≥mo funciona y c√≥mo debe usarse.  Al trabajar con System.IO.Pipelines, vale la pena recordar que el concepto b√°sico es que todas las operaciones de lectura-escritura deben realizarse sin asignaciones adicionales.  Pero algunos m√©todos que son atractivos a primera vista contradicen esta regla.  En consecuencia, el c√≥digo que intenta acelerar tan r√°pidamente comienza a asignar memoria para datos nuevos y nuevos, cargando el recolector de basura. <br><br>  Los componentes internos de la biblioteca utilizan las posibilidades m√°s amplias de las √∫ltimas versiones del lenguaje y el tiempo de ejecuci√≥n: Span, Memoria, agrupaciones de objetos, ValueTask, etc.  Vale la pena buscar all√≠, al menos, un gran ejemplo del uso de estas caracter√≠sticas en la producci√≥n. <br><br>  Hubo un tiempo en que algunos desarrolladores no estaban satisfechos con la implementaci√≥n de secuencias en C #, porque una clase se usaba tanto para leer como para escribir.  Pero como dicen, no puedes tirar m√©todos fuera de una clase.  Incluso si la transmisi√≥n no admite lectura / escritura / b√∫squeda, se utilizan las propiedades CanRead, CanWrite y CanSeek.  Parece una peque√±a muleta.  Pero ahora las cosas se vuelven diferentes. <br><br>  Para trabajar con tuber√≠as, se utilizan 2 clases: <a href="">PipeWriter</a> y <a href="">PipeReader</a> .  Estas clases contienen aproximadamente 50 l√≠neas de c√≥digo y son pseudo-fachadas (no la m√°s cl√°sica de sus encarnaciones, ya que ocultan una sola clase, no muchas) para la clase <a href="">Pipe</a> , que contiene toda la l√≥gica b√°sica para trabajar con datos.  Esta clase contiene 5 miembros p√∫blicos: 2 constructores, 2 propiedades de solo obtenci√≥n: Reader y Writer, el m√©todo Reset (), que restablece los campos internos a su estado inicial para que la clase pueda reutilizarse.  Los m√©todos restantes para el trabajo son internos y se llaman utilizando pseudo-fachadas. <br><br><h2>  Comencemos con la clase de tuber√≠a </h2><br>  La instancia de clase ocupa 320 bytes, que es bastante (casi un tercio de kilobyte, 2 de esos objetos no cab√≠an en la memoria de Manchester Mark I).  Entonces, la asignaci√≥n de una gran cantidad de sus instancias es una mala idea.  Adem√°s, el objeto est√° destinado a un uso a largo plazo.  El uso de grupos tambi√©n hace un argumento para esta declaraci√≥n.  Los objetos utilizados en el grupo vivir√°n para siempre (para la implementaci√≥n predeterminada del grupo). <br>  Tenga en cuenta que la clase est√° marcada como sellada y que es segura para subprocesos: muchas secciones del c√≥digo son una secci√≥n cr√≠tica y est√°n envueltas en bloqueos. <br><br>  Para comenzar a usar esta clase, debe crear una instancia de la clase Pipe y obtener los objetos PipeReader y PipeWriter utilizando las propiedades mencionadas. <br><br><div class="spoiler">  <b class="spoiler_title">Inicializaci√≥n simple</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pipe = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pipe(); PipeWriter pipeWriter = pipe.Writer; PipeReader pipeReader = pipe.Reader;</code> </pre> <br></div></div><br>  Considere los m√©todos para trabajar con tuber√≠as: <br>  Escribir con PipeWriter: WriteAsync, GetMemory / GetSpan, Advance, FlushAsync, Complete, CancelPendingFlush, OnReaderCompleted. <br><br>  Lectura con PipeReader: AdvanceTo, ReadAsync, TryRead, Complete, CancelPendingRead, OnWriterCompleted. <br><br>  Como se indic√≥ en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">publicaci√≥n mencionada</a> , la clase utiliza una lista de b√∫feres vinculada individualmente.  Pero, obviamente, no se transfieren entre PipeReader y PipeWriter: toda la l√≥gica est√° en una clase.  Esta lista se usa tanto para leer como para escribir.  Adem√°s, los datos devueltos se almacenan en esta lista (por lo que no se realiza ninguna copia). <br><br>  Adem√°s, hay objetos que indican el comienzo de los datos para leer (ReadHead e index), el final de los datos para leer (ReadTail e index) y el comienzo del espacio para escribir (WriteHead y el n√∫mero de bytes almacenados en b√∫fer escritos).  Aqu√≠ ReadHead, ReadTail y WriteHead son miembros espec√≠ficos (segmentos) de la lista interna de segmentos, y el √≠ndice indica una posici√≥n espec√≠fica dentro del segmento.  Por lo tanto, la grabaci√≥n puede comenzar desde el medio de un segmento, capturar un segmento siguiente completo y terminar en el medio del tercero.  Estos punteros se mueven en varios m√©todos. <br><br><h2>  Comenzando con los m√©todos PipeWriter </h2><br><h3>  # 1 <a href="">ValueTask &lt;FlushResult&gt; WriteAsync (fuente ReadOnlyMemory &lt;byte&gt;, CancellationToken cancellationToken)</a> </h3><br>  Eso se menciona atractivo a primera vista m√©todo.  Tiene una firma muy adecuada y de moda: acepta ReadOnlyMemory, as√≠ncrono.  Y muchos pueden sentirse tentados, especialmente recordando que Span y Memory son tan r√°pidos y geniales.  Pero no te hagas ilusiones.  Todo lo que hace este m√©todo es copiar el ReadOnlyMemory pasado a la lista interna.  Y por "copiar" se entiende una llamada al m√©todo CopyTo (), y no copiar solo el objeto en s√≠.  Todos los datos que queremos grabar se copiar√°n, cargando as√≠ la memoria.  Este m√©todo debe mencionarse solo para asegurarse de que es mejor no usarlo.  Bueno, y tal vez para algunas situaciones raras, este comportamiento es apropiado. <br>  El cuerpo del m√©todo es una secci√≥n cr√≠tica, el acceso al mismo se sincroniza a trav√©s de un monitor. <br><br>  Entonces puede surgir la pregunta, c√≥mo escribir algo, si no es a trav√©s del m√©todo m√°s obvio y √∫nico adecuado <br><br><h3>  # 2 <a href="">Memoria &lt;byte&gt; GetMemory (int sizeHint)</a> </h3><br>  El m√©todo toma un par√°metro de un tipo entero.  En √©l, debemos indicar cu√°ntos bytes queremos escribir en la tuber√≠a (qu√© tama√±o del b√∫fer queremos).  Este m√©todo verifica si hay suficiente espacio para escribir en el fragmento de memoria actual almacenado en _writingHeadMemory.  Si es suficiente, _writingHeadMemory se devuelve como la Memoria.  De lo contrario, para los datos escritos en el b√∫fer, pero para los cuales no se llam√≥ al m√©todo FlushAsync, se llama y se asigna otro BufferSegment, que est√° conectado al anterior (aqu√≠ est√° nuestra lista interna).  Si _writingHeadMemory es nulo, se inicializa con un nuevo BufferSegment.  Y la asignaci√≥n del b√∫fer es una secci√≥n cr√≠tica y se realiza bajo el candado. <br><br>  Sugiero mirar este ejemplo.  A primera vista, puede parecer que el compilador (o tiempo de ejecuci√≥n) ha enga√±ado al demonio. <br><br><div class="spoiler">  <b class="spoiler_title">Diablo</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pipeNoOptions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pipe(); Memory&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; memoryOne = pipeNoOptions.Writer.GetMemory(<span class="hljs-number"><span class="hljs-number">2</span></span>); Console.WriteLine(memoryOne.Length); <span class="hljs-comment"><span class="hljs-comment">//2048 or 4096 var pipeWithOptions = new Pipe(new PipeOptions(minimumSegmentSize: 5)); Memory&lt;byte&gt; memoryTwo = pipeWithOptions.Writer.GetMemory(2); Console.WriteLine(memoryTwo.Length); //16</span></span></code> </pre><br></div></div><br>  Pero todo en este ejemplo es comprensible y simple. <br>  Al crear una instancia de Pipe, podemos pasarle el objeto <a href="">PipeOptions</a> en el constructor con opciones para crear. <br><br>  PipeOptions tiene un campo de tama√±o m√≠nimo de segmento predeterminado.  No hace mucho tiempo, era 2048, pero <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esta confirmaci√≥n</a> ha actualizado este valor a 4096. Al momento de escribir este art√≠culo, la versi√≥n 4096 estaba en prelanzamiento nuget-package, la √∫ltima versi√≥n de lanzamiento ten√≠a un valor de 2048. Esto explica el comportamiento del primer ejemplo.  Si es cr√≠tico con el uso de un tama√±o m√°s peque√±o para el b√∫fer predeterminado, puede especificarlo en una instancia del tipo PipeOptions. <br><br>  Pero en el segundo ejemplo, donde se especifica el tama√±o m√≠nimo, la longitud no coincide de todos modos.  Y esto est√° sucediendo porque la creaci√≥n de un nuevo BufferSegment se produce mediante grupos.  Una de las opciones en PipeOptions es el grupo de memoria.  Despu√©s de eso, el grupo especificado se usar√° para crear un nuevo segmento.  Si no especific√≥ el grupo de memoria, se utilizar√° el ArrayPool predeterminado, que, como ya sabe, tiene varios dep√≥sitos para diferentes tama√±os de matrices (cada uno es 2 veces m√°s grande que el anterior) y cuando se solicita para un determinado tama√±o, busca un cubo con matrices de tama√±o adecuado (es decir, el m√°s grande o igual m√°s cercano).  En consecuencia, el nuevo b√∫fer seguramente ser√° m√°s grande de lo que solicit√≥.  El tama√±o m√≠nimo de matriz en el ArrayPool predeterminado (System.Buffers.TlsOverPerCoreLockedStacksArrayPool) es 16. Pero no se preocupe, este es un grupo de matrices.  En consecuencia, en la gran mayor√≠a de los casos, la matriz no ejerce presi√≥n sobre el recolector de basura y se reutilizar√° m√°s tarde. <br><br><h3>  # 2.5 <a href="">Span &lt;byte&gt; GetSpan (int sizeHint)</a> </h3><br>  Funciona de manera similar, dando Span from Memory. <br><br>  Por lo tanto, GetMemory () o GetSpan () son los principales m√©todos para escribir.  Nos dan un objeto en el que podemos escribir.  Para hacer esto, no necesitamos asignar memoria para nuevas matrices de valores, podemos escribir directamente en la tuber√≠a.  Cu√°l usar depender√° principalmente de la API que est√© utilizando y del m√©todo asincr√≥nico.  Sin embargo, en vista de lo anterior, surge una pregunta.  ¬øC√≥mo sabr√° el lector cu√°nto escribimos?  Si siempre usamos una implementaci√≥n espec√≠fica del grupo, que proporciona una matriz del mismo tama√±o que el solicitado, el lector podr√≠a leer todo el b√∫fer de una vez.  Sin embargo, como ya hemos dicho, se nos asigna un b√∫fer con una alta probabilidad de un tama√±o mayor.  Esto lleva al siguiente m√©todo requerido para la operaci√≥n. <br><br><h3>  # 3 <a href="">void Advance (int bytes)</a> </h3><br>  Un m√©todo terriblemente simple.  Toma el n√∫mero de bytes escritos como argumento.  Incrementan los contadores internos: _unflushedBytes y _writingHeadBytesBuffered, cuyos nombres hablan por s√≠ mismos.  Tambi√©n trunca (rebanadas) _writingHeadMemory exactamente a la cantidad de bytes escritos (usando el m√©todo Slice).  Por lo tanto, despu√©s de llamar a este m√©todo, debe solicitar un nuevo bloque de memoria en forma de Memoria o Span, no puede escribir en el anterior.  Y todo el cuerpo del m√©todo es una secci√≥n cr√≠tica y se ejecuta bajo un candado. <br><br>  Parece que despu√©s de esto el lector puede recibir datos.  Pero se necesita un paso m√°s. <br><br><h3>  # 4 <a href="">ValueTask &lt;FlushResult&gt; FlushAsync (CancellationToken cancellationToken)</a> </h3><br>  Se llama al m√©todo despu√©s de que escribimos los datos necesarios en la Memoria recibida (GetMemory) e indicamos cu√°nto escribimos all√≠ (Avance).  El m√©todo devuelve ValueTask, sin embargo, no es as√≠ncrono (a diferencia de su descendiente StreamPipeWriter).  ValueTask es un tipo especial (estructura de solo lectura) que se usa en el caso en que la mayor√≠a de las llamadas no ser√°n as√≠ncronas, es decir, todos los datos necesarios estar√°n disponibles en el momento de su llamada y el m√©todo finalizar√° sincr√≥nicamente.  Dentro de s√≠ mismo contiene datos o Tarea (en caso de que no funcion√≥ sincr√≥nicamente).  Depende de la propiedad _writerAwaitable.IsCompleted.  Si buscamos qu√© cambios cambia el estado de este _writerAwaitable, veremos que esto sucede si la cantidad de datos no consumidos (esto no es exactamente lo mismo que los datos no examinados se explicar√°n m√°s adelante) excede un cierto umbral (_pauseWriterThreshold).  El valor predeterminado es 16 tama√±os de segmento.  Si lo desea, el valor se puede cambiar en PipeOptions.  Adem√°s, este m√©todo inicia la continuaci√≥n del m√©todo ReadAsync, si uno fue bloqueado. <br><br>  Devuelve un FlushResult que contiene 2 propiedades: IsCanceled e IsCompleted.  IsCanceled indica si se ha cancelado Flush (llamada CancelPendingFlush ()).  IsCompleted indica si PipeReader se ha completado (llamando a los m√©todos Complete () o CompleteAsync ()). <br>  La parte principal del m√©todo se realiza bajo el candado. <br><br>  Otros m√©todos de PipeWriter no son interesantes desde el punto de vista de la implementaci√≥n y se usan con mucha menos frecuencia, por lo tanto, solo se dar√° una breve descripci√≥n. <br><br><h3>  # 5 void Complete (excepci√≥n de excepci√≥n = nulo) o ValueTask CompleteAsync (excepci√≥n de excepci√≥n = nulo) </h3><br>  Tubo de marcas cerrado para escritura.  Se generar√° una excepci√≥n al intentar utilizar los m√©todos de escritura despu√©s de la finalizaci√≥n.  Si PipeReader ya se ha completado, tambi√©n se completar√° toda la instancia de Pipe.  La mayor parte del trabajo se realiza bajo la cerradura. <br><br><h3>  # 6 nulo CancelPendingFlush () </h3><br>  Como su nombre lo indica, cancela la operaci√≥n actual de FlushAsync ().  Hay una cerradura <br><br><h3>  # 7 void OnReaderCompleted (acci√≥n &lt;excepci√≥n, objeto&gt; devoluci√≥n de llamada, estado del objeto) </h3><br>  Ejecuta el delegado pasado cuando el lector completa.  Tambi√©n hay una cerradura. <br>  En la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n</a> actualmente se escribe que este m√©todo no se puede invocar en algunas implementaciones de PipeWriter y se eliminar√° en el futuro.  Por lo tanto, no debe vincular la l√≥gica a estos m√©todos. <br><br><h2>  Es hora de PipeReader </h2><br><h3>  # 1 <a href="">ValueTask &lt;ReadResult&gt; ReadAsync (token CancellationToken)</a> </h3><br>  Aqu√≠, como en FlushAsync (), se devuelve ValueTask, lo que sugiere que el m√©todo es principalmente sincr√≥nico, pero no siempre.  Depende del estado de _readerAwaitable.  Al igual que con FlushAsync, debe encontrar cu√°ndo _readerAwaitable est√° configurado como incompleto.  Esto sucede cuando PipeReader ha le√≠do todo de la lista interna (o contiene datos que se marcaron como examinados y necesita m√°s datos para continuar).  Lo cual, de hecho, es obvio.  En consecuencia, podemos concluir que es deseable ajustar Pipe a su trabajo, establecer todas sus opciones cuidadosamente, en base a estad√≠sticas identificadas emp√≠ricamente.  La configuraci√≥n adecuada reducir√° la posibilidad de una rama de ejecuci√≥n asincr√≥nica y permitir√° un procesamiento de datos m√°s eficiente.  Casi todo el c√≥digo en todo el m√©todo est√° rodeado por un candado. <br><br>  Devuelve un misterioso <a href="">ReadResult</a> .  De hecho, es solo un b√∫fer + indicadores que muestran el estado de la operaci√≥n (IsCanceled: si ReadAsync se cancel√≥ e IsCompleted indicando si PipeWriter estaba cerrado).  IsCompleted es un valor que indica si se llam√≥ a los m√©todos PipeWriter Complete () o CompleteAsync ().  Si se llam√≥ a estos m√©todos con una excepci√≥n aprobada, se lanzar√° al intentar leer. <br><br>  Y nuevamente, el b√∫fer tiene un tipo misterioso: <a href="">ReadOnlySequence</a> .  Esto, a su vez, es el objeto del contenido de los segmentos <a href="">(ReadOnlySequenceSegment)</a> del principio y los √≠ndices final + inicio y final dentro de los segmentos correspondientes.  Que en realidad se asemeja a la estructura de la propia clase Pipe.  Por cierto, BufferSegment se hereda de ReadOnlySequenceSegment, lo que sugiere que BufferSegment se usa en esta secuencia.  Gracias a esto, puede deshacerse de las asignaciones de memoria innecesarias para la transferencia de datos del escritor al lector. <br>  ReadOnlySpan se puede obtener del b√∫fer para su posterior procesamiento.  Para completar la imagen, puede verificar si el b√∫fer contiene un solo ReadOnlySpan.  Si contiene, no necesitamos iterar sobre la colecci√≥n de un elemento y podemos obtenerla usando la propiedad First.  De lo contrario, es necesario revisar todos los segmentos en el b√∫fer y procesar ReadOnlySpan de cada uno. <br><br>  Tema de discusi√≥n: en la clase ReadOnlySequence, los tipos de referencia anulables se usan activamente y hay goto (no para anidaci√≥n de bucle profundo y no en el c√≥digo generado), en particular, <a href="">aqu√≠</a> . <br><br>  Despu√©s del procesamiento, debe indicar a la instancia de Pipe que leemos los datos. <br><br><h3>  # 2 <a href="">bool TryRead (resultado de ReadResult)</a> </h3><br>  Versi√≥n sincr√≥nica.  Le permite obtener el resultado si existe.  De lo contrario, a diferencia de ReadAsync, no bloquea y devuelve falso.  Tambi√©n el c√≥digo de este m√©todo est√° en la cerradura. <br><br><h3>  # 3 <a href="">void AdvanceTo (SequencePosition consumido, SequencePosition examinado)</a> </h3><br>  En este m√©todo, puede especificar cu√°ntos bytes examinamos y consumimos.  Los datos que han sido examinados pero no consumidos se devolver√°n la pr√≥xima vez que se lean.  Esta caracter√≠stica puede parecer extra√±a a primera vista, pero cuando se procesa una secuencia de bytes, rara vez es necesario procesar cada byte individualmente.  Por lo general, los datos se intercambian mediante mensajes.  Puede surgir una situaci√≥n en la que el lector, al leer, recibi√≥ un mensaje completo y parte del segundo.  El todo debe ser procesado, y parte del segundo debe dejarse para el futuro, de modo que venga junto con la parte restante.  El m√©todo AdvanceTo toma una SequencePosition, que en realidad es un segmento + √≠ndice.  Al procesar todo lo que ReadAsync ha le√≠do, puede especificar el b√∫fer. Fin.  De lo contrario, debe crear expl√≠citamente una posici√≥n, indicando el segmento y el √≠ndice en el que se detuvo el procesamiento.  La cerradura est√° debajo del cap√≥. <br>  Adem√°s, si la cantidad de informaci√≥n no consumida es inferior al umbral especificado (_resumeWriterThreshold), se inicia la continuaci√≥n de PipeWriter si se bloque√≥.  Por defecto, este umbral es de 8 vol√∫menes de segmento (la mitad del umbral de bloqueo). <br><br><h3>  # 4 vac√≠o completo (excepci√≥n de excepci√≥n = nulo) </h3><br>  Completa el PipeReader.  Si PipeWriter se completa en este punto, se completa toda la instancia de Pipe.  Bloquear adentro. <br><br><h3>  # 5 nulo CancelPendingRead () </h3><br>  Le permite cancelar la lectura que est√° actualmente en estado pendiente.  Cerradura <br><br><h3>  # 6 void OnWriterCompleted (Acci√≥n &lt;Excepci√≥n, objeto&gt; devoluci√≥n de llamada, estado del objeto) </h3><br>  Le permite especificar el delegado que se ejecutar√° al completar PipeWriter. <br>  Al igual que el m√©todo similar de PipeWriter, en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n</a> hay la misma etiqueta que se eliminar√°.  La cerradura est√° debajo del cap√≥. <br><br><h2>  Ejemplo </h2><br>  El listado a continuaci√≥n muestra un ejemplo de trabajo con tuber√≠as. <br>  Desde la introducci√≥n de .NET Core Span y Memory, muchas clases para trabajar con datos se han complementado con sobrecargas que utilizan estos tipos.  Entonces, el esquema general de interacci√≥n ser√° aproximadamente el mismo.  En mi ejemplo, us√© tuber√≠as para trabajar con tuber√≠as (me gustan las palabras similares): objetos del sistema operativo para la comunicaci√≥n entre procesos.  La API de canalizaciones se ha ampliado en consecuencia para leer datos en Span y Memory.  La versi√≥n asincr√≥nica usa memoria, ya que el m√©todo asincr√≥nico se convertir√° en un m√©todo de plantilla usando una m√°quina de estados finitos autogenerada, en la que se almacenan todas las variables locales y los par√°metros del m√©todo, y dado que Span es una estructura de solo lectura, no se puede colocar en el mont√≥n, respectivamente, usando Span en un m√©todo asincr√≥nico es imposible.  Pero tambi√©n hay una versi√≥n sincr√≥nica del m√©todo que le permite utilizar Span.  En mi ejemplo, prob√© ambos y result√≥ que la versi√≥n s√≠ncrona en esta situaci√≥n se muestra mejor.  Al usarlo, se produce menos recolecci√≥n de basura y el procesamiento de datos es m√°s r√°pido.  Pero esto fue solo porque hab√≠a una gran cantidad de datos en la tuber√≠a (los datos siempre estaban disponibles).  En la situaci√≥n en la que es bastante probable que no haya datos al momento de solicitar el pr√≥ximo lote, debe usar la versi√≥n asincr√≥nica para no forzar el procesador inactivo. <br>  El ejemplo tiene comentarios que explican algunos puntos.  Le llamo la atenci√≥n sobre el hecho de que, a pesar de que los fragmentos del programa responsable de la lectura desde la tuber√≠a y el procesamiento est√°n separados, al escribir en un archivo, los datos se leen exactamente desde el lugar donde se escriben al leer desde el tubo <br><br><div class="spoiler">  <b class="spoiler_title">A√±os de evoluci√≥n por el bien de una caracter√≠stica poderosa - principal as√≠ncrono</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pipe = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pipe(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataWriter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PipeDataWriter(pipe.Writer, <span class="hljs-string"><span class="hljs-string">"testpipe"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataProcessor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DataProcessor(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConsoleBytesProcessor(), pipe.Reader); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cts = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CancellationTokenSource(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.WhenAll(dataWriter.ReadFromPipeAsync(cts.Token), dataProcessor.StartProcessingDataAsync(cts.Token)); } }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Pipepatawriter</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PipeDataWriter</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> NamedPipeClientStream _namedPipe; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> PipeWriter _pipeWriter; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Servername = <span class="hljs-string"><span class="hljs-string">"."</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PipeDataWriter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PipeWriter pipeWriter, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pipeName</span></span></span><span class="hljs-function">)</span></span> { _pipeWriter = pipeWriter ?? <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(pipeWriter)); _namedPipe = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NamedPipeClientStream(Servername, pipeName, PipeDirection.In); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadFromPipeAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CancellationToken token</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> _namedPipe.ConnectAsync(token); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { token.ThrowIfCancellationRequested(); <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">/ when working with the asynchronous method, use Memory </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T&gt;</span></span></span><span class="hljs-comment"> //Memory</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;byte&gt;</span></span></span><span class="hljs-comment"> buffer = _pipeWriter.GetMemory(); </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">/ asynchronous reading from a named pipe in Memory </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">/ there can be any operation to obtain data - from reading from a file to random generation. //int readBytes = await _namedPipe.ReadAsync(buffer, token); // synchronous reading from the named pipe to the requested from PipeWriter Span // there can be any operation to obtain data - from reading from a file to random generation. int readBytes = _namedPipe.Read(_pipeWriter.GetSpan()); // if there was nothing in the channel, release the thread for half a second and try again // in other cases we can break the loop, it's just example if (readBytes == 0) { await Task.Delay(500, token); continue; } // specify the amount of bytes read from the pipe _pipeWriter.Advance(readBytes); // flush data to make them available PipeReader FlushResult result = await _pipeWriter.FlushAsync(token); // if PipeReader has been completed, it no longer needs to write data // PS this behavior was chosen by me as an example, it depends on business logic if (result.IsCompleted) { break; } } // complete _pipeWriter to complete the entire instance of pipe _pipeWriter.Complete(); } }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Procesador de datos</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DataProcessor</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> IBytesProcessor _bytesProcessor; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> PipeReader _pipeReader; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DataProcessor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IBytesProcessor bytesProcessor, PipeReader pipeReader</span></span></span><span class="hljs-function">)</span></span> { _bytesProcessor = bytesProcessor ?? <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(bytesProcessor)); _pipeReader = pipeReader ?? <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(pipeReader)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartProcessingDataAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CancellationToken token</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { token.ThrowIfCancellationRequested(); <span class="hljs-comment"><span class="hljs-comment">// reading data from a pipe instance ReadResult result = await _pipeReader.ReadAsync(token); ReadOnlySequence&lt;byte&gt; buffer = result.Buffer; // We perform calculations with the data obtained. await _bytesProcessor.ProcessBytesAsync(buffer, token); // indicate to which position the data was processed. In this case, everything is written to the file. // in situations where not all data has been processed, you need to create a position manually using the buffer and index // in this situation, IBytesProcessor.ProcessBytesAsync can be supplemented by returning this position _pipeReader.AdvanceTo(buffer.End); // if PipeWriter has been completed, reading is no longer necessary // this behavior was chosen by me as an example, it depends on business logic if (result.IsCompleted) { break; } } // complete _pipeReader to complete the entire instance of pipe _pipeReader.Complete(); } }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Procesador de bytes</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IBytesProcessor</span></span> { <span class="hljs-function"><span class="hljs-function">Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessBytesAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReadOnlySequence&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; bytesSequence, CancellationToken token</span></span></span><span class="hljs-function">)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ConsoleBytesProcessor</span></span> : <span class="hljs-title"><span class="hljs-title">IBytesProcessor</span></span> { <span class="hljs-comment"><span class="hljs-comment">//Let's imagine that in this class there is a normal constructor and IDisposable readonly FileStream _fileStream = new FileStream("buffer", FileMode.Create); public Task ProcessBytesAsync(ReadOnlySequence&lt;byte&gt; bytesSequence, CancellationToken token) { if (bytesSequence.IsSingleSegment) { ProcessSingle(bytesSequence.First.Span); } else { foreach (var segment in bytesSequence) { ProcessSingle(segment.Span); } } return Task.CompletedTask; } private void ProcessSingle(ReadOnlySpan&lt;byte&gt; span) { _fileStream.Write(span); } }</span></span></code> </pre><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/466137/">https://habr.com/ru/post/466137/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../466121/index.html">Generaci√≥n de sonido en microcontroladores AVR por el m√©todo de tablas de ondas con soporte de polifon√≠a.</a></li>
<li><a href="../466123/index.html">Crecimiento. Peso. Tres vecinos</a></li>
<li><a href="../466127/index.html">Central nuclear de Kola o de pie en el reactor</a></li>
<li><a href="../466129/index.html">Eficiencia del transporte de gasolina, bater√≠as e hidr√≥geno.</a></li>
<li><a href="../466135/index.html">Megapack: c√≥mo los desarrolladores de Factorio lograron resolver el problema con el modo multijugador de 200 jugadores</a></li>
<li><a href="../466139/index.html">Tecnolog√≠a aplicada en las ruinas de la fiebre blockchain o los beneficios pr√°cticos de la asignaci√≥n de recursos.</a></li>
<li><a href="../466143/index.html">¬øC√≥mo hicimos el c√≥digo de cart√≥n o la versi√≥n Scratch del juego de mesa Golem Battle</a></li>
<li><a href="../466147/index.html">Administrador de visualizaci√≥n de datos reactivos. Introduccion</a></li>
<li><a href="../466149/index.html">Crear un s√≠mbolo de conector con texto "din√°mico" en OrCAD</a></li>
<li><a href="../466151/index.html">Investigaci√≥n: programas extra√±os en el registro de software dom√©stico</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>