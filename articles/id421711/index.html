<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍾 ☎️ 🕉️ Analisis permintaan layanan menggunakan pembelajaran mesin 🚶🏻 🤴🏼 💦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sebagai bagian dari dukungan produk, kami terus melayani permintaan pengguna. Ini adalah proses standar. Dan seperti proses apa pun, itu perlu dievalu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analisis permintaan layanan menggunakan pembelajaran mesin</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421711/"><p>  Sebagai bagian dari dukungan produk, kami terus melayani permintaan pengguna.  Ini adalah proses standar.  Dan seperti proses apa pun, itu perlu dievaluasi dan ditingkatkan secara kritis. </p><br><p>  Kami tahu tentang beberapa masalah sistematis yang sebaiknya diselesaikan dan, jika mungkin, tanpa menarik sumber daya tambahan: </p><br><ul><li>  Kesalahan dalam mengirimkan aplikasi: kami mendapatkan sesuatu yang "asing", tim lain terkadang mendapatkan sesuatu "milik kami". </li><li>  sulit untuk menilai "kompleksitas" aplikasi  Jika aplikasi ini kompleks, dapat diteruskan ke analis yang kuat, dan dengan yang sederhana, pemula akan mengatasinya. </li></ul><br><p>  Solusi untuk semua masalah ini akan secara positif mempengaruhi kecepatan pemrosesan aplikasi. </p><br><p>  Aplikasi pembelajaran mesin, sebagaimana diterapkan pada analisis konten aplikasi, terlihat seperti peluang nyata untuk meningkatkan proses pengiriman. </p><br><p>  Dalam kasus kami, masalahnya dapat dirumuskan dengan masalah klasifikasi berikut: </p><br><ol><li>  Pastikan bahwa permintaan tersebut ditetapkan dengan benar ke: <br><ul><li>  unit konfigurasi (salah satu dari 5 dalam aplikasi atau "orang lain") </li><li>  kategori layanan (insiden, permintaan informasi, permintaan layanan) </li></ul></li><li>  Perkirakan waktu yang diharapkan untuk menutup permintaan (sebagai indikator "kompleksitas" tingkat tinggi). <a name="habracut"></a></li></ol><br><h2 id="s-chem-i-kak-budem-rabotat">  Apa dan bagaimana kita akan bekerja </h2><br><p>  Untuk membuat algoritma, kita akan menggunakan "set standar": Python dengan pustaka scikit-learn. </p><br><p>  Untuk aplikasi nyata, 2 skenario akan diterapkan: <br>  Pelatihan: </p><br><ul><li>  mendapatkan data "pelatihan" dari pelacak aplikasi </li><li>  menjalankan algoritme untuk melatih model, menyimpan model </li></ul><br><p>  Penggunaan: </p><br><ul><li>  menerima data dari pelacak aplikasi untuk klasifikasi </li><li>  pemuatan model, klasifikasi aplikasi, hasil penghematan </li><li>  memperbarui aplikasi dalam pelacak berdasarkan klasifikasi </li></ul><br><p>  Segala sesuatu yang terkait dengan pipa (interaksi dengan pelacak) dapat diimplementasikan pada apa saja.  Dalam hal ini, skrip PowerShell ditulis, meskipun dimungkinkan untuk melanjutkan dengan python. </p><br><p>  Algoritma pembelajaran mesin akan menerima data klasifikasi / pelatihan dalam bentuk file .csv.  Hasil yang diproses juga akan menjadi output ke file .csv. </p><br><h3 id="vhodnye-dannye">  Masukkan data </h3><br><p>  Untuk membuat algoritma se independen mungkin dari pendapat tim layanan, kami hanya akan mempertimbangkan data yang diterima dari pencipta aplikasi sebagai parameter input dari model: </p><br><ol><li>  Deskripsi / judul pendek (teks) </li><li>  Penjelasan rinci tentang masalah, jika ada (teks).  Ini adalah pesan pertama dalam alur komunikasi aplikasi. </li><li>  Nama pelanggan (karyawan, kategori) </li><li>  Nama karyawan lain yang termasuk dalam daftar pantauan berdasarkan permintaan (daftar karyawan) </li><li>  Waktu pengajuan aplikasi (tanggal / waktu). </li></ol><br><h3 id="nabor-dannyh-dlya-obucheniya">  Dataset pelatihan </h3><br><p>  Untuk pelatihan algoritma, data panggilan tertutup selama 3 tahun terakhir digunakan - ~ 3.500 catatan. <br>  Selain itu, untuk mengajarkan pengklasifikasi tentang pengenalan unit konfigurasi "lainnya", aplikasi tertutup yang diproses oleh departemen lain untuk unit konfigurasi lainnya ditambahkan ke set pelatihan.  Total catatan tambahan - sekitar 17.000. <br>  Untuk semua permintaan tambahan seperti itu, unit konfigurasi akan diatur ke "lain" </p><br><h2 id="predobrabotka">  Pretreatment </h2><br><h3 id="tekst">  Teks </h3><br><p>  Pra-pemrosesan teks sangat sederhana: </p><br><ol><li>  Kami menerjemahkan semuanya menjadi huruf kecil </li><li>  Hanya menyisakan angka dan huruf - ganti sisanya dengan spasi </li></ol><br><h3 id="spisok-uvedomleniy-watchlist">  Daftar Pemberitahuan (daftar pantauan) </h3><br><p>  Daftar ini tersedia untuk analisis dalam bentuk string di mana nama-nama disajikan dalam bentuk Nama Belakang, Nama Depan, dan dipisahkan oleh tanda titik koma.  Untuk analisis, kami akan mengubahnya menjadi daftar string. <br>  Dengan menggabungkan daftar kami mendapatkan satu set nama unik berdasarkan semua aplikasi dari set pelatihan.  Daftar umum ini akan membentuk vektor nama. </p><br><h3 id="dlitelnost-obrabotki-zayavki">  Durasi Pemrosesan Aplikasi </h3><br><p>  Untuk tujuan kami (manajemen prioritas, perencanaan rilis), cukup untuk menghubungkan aplikasi ke kelas tertentu dengan durasi layanan.  Ini juga memungkinkan Anda untuk memindahkan tugas dari regresi ke klasifikasi dengan sejumlah kecil kelas. </p><br><h2 id="formiruem-priznaki">  Kami membentuk tanda </h2><br><h3 id="tekst-1">  Teks </h3><br><ol><li>  Gabungkan "judul" dan "deskripsi masalah." </li><li>  Teruskan ke TfidfVectoriser untuk membentuk vektor kata </li></ol><br><h3 id="imya-sostavitelya-zayavki">  Nama pemohon </h3><br><p>  Karena diharapkan orang yang membuat aplikasi akan menjadi atribut penting dari klasifikasi lebih lanjut - kami akan menerjemahkannya ke dalam salah satu pengkodean secara individual menggunakan DictionaryVectorisor </p><br><h3 id="imena-lyudey-vklyuchennyh-v-spisok-uvedomleniy">  Nama orang yang termasuk dalam daftar notifikasi </h3><br><p>  Daftar orang yang termasuk dalam aplikasi daftar pantauan akan dikonversi menjadi vektor berdasarkan semua nama yang disiapkan sebelumnya: jika orang tersebut ada dalam daftar, komponen yang sesuai akan ditetapkan ke 1, jika tidak - ke 0. Satu aplikasi dapat memiliki beberapa orang dalam daftar pantauan - masing-masing, beberapa komponen akan memiliki nilai tunggal. </p><br><h3 id="data-sozdaniya">  Tanggal pembuatan </h3><br><p>  Tanggal pembuatan akan disajikan sebagai satu set atribut numerik - tahun, bulan, hari dalam sebulan, hari dalam seminggu. </p><br><p>  Ini dilakukan dengan asumsi bahwa: </p><br><ul><li>  Kecepatan pemrosesan aplikasi bervariasi dari waktu ke waktu </li><li>  Kecepatan pemrosesan memiliki faktor musiman </li><li>  Hari dalam seminggu (terutama aplikasi akhir pekan) dapat membantu mengidentifikasi unit konfigurasi dan kategori layanan </li></ul><br><h2 id="obuchaem-model">  Model pelatihan </h2><br><h3 id="algoritm-klassifikacii">  Algoritma klasifikasi </h3><br><p>  Untuk ketiga tugas klasifikasi, regresi logistik digunakan.  Ini mendukung klasifikasi multiclass (dalam model One-vs-All), belajar cukup cepat. </p><br><p>  Untuk melatih model yang menentukan kategori layanan dan durasi pemrosesan aplikasi, kami hanya akan menggunakan aplikasi yang jelas milik unit konfigurasi kami. </p><br><h3 id="rezultaty-obucheniya">  Hasil belajar </h3><br><p>  <strong>Menentukan Unit Konfigurasi</strong> <br>  Model ini menunjukkan indikator kelengkapan dan akurasi yang tinggi ketika menetapkan aplikasi ke unit konfigurasi.  Selain itu, model juga mendefinisikan peristiwa ketika aplikasi merujuk ke unit konfigurasi asing. </p><br><p><img src="https://habrastorage.org/webt/lj/f9/yj/ljf9yjx7om-gsyclnpg9zl3md6s.png"></p><br><p>  Kelengkapan yang relatif rendah untuk kelas CI-2 sebagian karena kesalahan klasifikasi nyata dalam data.  Selain itu, CI-2 menghadirkan aplikasi "teknis" yang dieksekusi untuk CI lainnya.  Jadi, dalam hal deskripsi dan pengguna yang terlibat, aplikasi semacam itu mungkin mirip dengan aplikasi kelas lain. </p><br><p>  Atribut paling signifikan untuk mengklasifikasikan aplikasi sebagai CI-?  diharapkan adalah nama-nama pelanggan aplikasi dan orang-orang yang termasuk dalam lembar peringatan.  Tetapi ada beberapa kata kunci yang penting dalam 30-ke pertama.  Tanggal pembuatan aplikasi tidak masalah. </p><br><p>  <strong>Definisi Kategori Aplikasi</strong> <br>  Kualitas klasifikasi berdasarkan kategori ternyata agak lebih rendah. </p><br><p><img src="https://habrastorage.org/webt/ye/jp/jw/yejpjwzwnihfbwoslocjy3_857u.png"></p><br><p>  Alasan yang sangat serius untuk ketidakcocokan kategori yang diprediksi dan kategori dalam sumber data adalah kesalahan nyata dalam sumber data.  Karena sejumlah alasan organisasi, klasifikasi tersebut mungkin salah.  Misalnya, alih-alih sebuah "insiden" (kerusakan dalam sistem, perilaku sistem yang tidak terduga), aplikasi dapat ditandai sebagai "informasi" ("ini bukan bug - ini adalah fitur") atau "layanan" ("ya, itu rusak, tapi kami baru saja memulai ulang - dan semuanya akan beres "). <br>  Identifikasi ketidakkonsistenan tersebut adalah salah satu tugas pengklasifikasi. </p><br><p>  Atribut yang signifikan untuk klasifikasi dalam hal kategori adalah kata-kata dari konten aplikasi.  Untuk insiden, ini adalah kata "error", "fix", "when".  Ada juga kata-kata yang menunjukkan beberapa modul sistem - ini adalah modul yang digunakan pengguna untuk bekerja secara langsung dan mengamati munculnya kesalahan langsung atau tidak langsung. </p><br><p>  Menariknya, untuk aplikasi yang didefinisikan sebagai "layanan" - kata-kata teratas juga mendefinisikan beberapa modul sistem.  Suatu kesempatan untuk berpikir, memeriksa, dan akhirnya memperbaikinya. </p><br><p>  <strong>Menentukan waktu pemrosesan aplikasi</strong> <br>  Yang terlemah adalah untuk memprediksi durasi pemrosesan aplikasi. </p><br><p><img src="https://habrastorage.org/webt/tj/of/hc/tjofhcwzgtk8neqx-_9nv68b_2a.png"></p><br><p>  Secara umum, ketergantungan pada jumlah aplikasi yang ditutup untuk waktu tertentu idealnya akan terlihat seperti kebalikan dari eksponen.  Tetapi dengan mempertimbangkan fakta bahwa beberapa insiden memerlukan koreksi dalam sistem, dan ini dilakukan sebagai bagian dari rilis reguler, durasi eksekusi beberapa aplikasi secara artifisial meningkat. </p><br><p>  Oleh karena itu, mungkin classifier mengklasifikasikan beberapa aplikasi "panjang" sebagai "lebih cepat" - dia tidak tahu tentang waktu rilis yang direncanakan, dan percaya bahwa aplikasi perlu ditutup lebih cepat. <br>  Ini juga alasan yang bagus untuk berpikir ... </p><br><h2 id="realizaciya-modeli-v-vide-klassa">  Implementasi model sebagai kelas </h2><br><p>  Model ini diimplementasikan sebagai kelas yang merangkum semua kelas standar scikit-learning yang digunakan - penskalaan, vektorisasi, klasifikasi dan pengaturan yang signifikan. <br>  Persiapan, pelatihan dan penggunaan selanjutnya dari model diimplementasikan sebagai metode kelas, berdasarkan objek tambahan. </p><br><p>  Implementasi objek memungkinkan Anda untuk dengan mudah menghasilkan versi turunan dari model yang menggunakan kelas pengklasifikasi lain dan / atau memprediksi nilai atribut lain dari kumpulan data asli.  Semua ini dilakukan dengan mengganti metode virtual. <br>  Namun, semua prosedur persiapan data mungkin tetap umum untuk semua opsi. </p><br><p>  Selain itu, implementasi model dalam bentuk objek memungkinkan untuk secara alami menyelesaikan masalah penyimpanan antara model yang terlatih antara sesi penggunaan - melalui serialisasi / deserialisasi. </p><br><p>  Untuk cerita bersambung model, mekanisme Python standar, acar / membongkar, digunakan. <br>  Karena ini memungkinkan Anda untuk membuat serial beberapa objek ke dalam file yang sama, ini akan membantu untuk secara konsisten menyimpan pemulihan beberapa model yang termasuk dalam aliran pemrosesan umum. </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Model yang dihasilkan, walaupun relatif sederhana, memberikan hasil yang sangat menarik: </p><br><ul><li>  mengidentifikasi "kelalaian" sistematis dalam klasifikasi berdasarkan kategori </li><li>  menjadi jelas bagian mana dari sistem yang terkait dengan masalah (tampaknya - bukan tanpa alasan) </li><li>  Waktu pemrosesan aplikasi jelas tergantung pada faktor-faktor eksternal yang perlu ditingkatkan secara terpisah. </li></ul><br><p>  Kami belum membangun kembali proses internal berdasarkan "petunjuk" yang diterima.  Tetapi bahkan percobaan kecil ini memungkinkan untuk mengevaluasi kekuatan metode pembelajaran mesin.  Dan juga, mendorong minat tambahan tim dalam analisis proses mereka sendiri dan peningkatannya. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id421711/">https://habr.com/ru/post/id421711/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id421701/index.html">Python Mempelajari Sandbox dan Cheat Sheet</a></li>
<li><a href="../id421703/index.html">Linux di rumah atau ...</a></li>
<li><a href="../id421705/index.html">Otomasi Terhadap Kekacauan</a></li>
<li><a href="../id421707/index.html">FB2D - Kerangka 2D untuk Linux Frame Buffer (Rust)</a></li>
<li><a href="../id421709/index.html">Unit CSS baru (dan lama) yang jarang Anda dengar</a></li>
<li><a href="../id421713/index.html">Cara menemukan bot di YouTube: pola interaksi komentator eksternal</a></li>
<li><a href="../id421717/index.html">Di mana analis belajar?</a></li>
<li><a href="../id421719/index.html">Printer warna 3D Da Vinci. Laporan foto Perusahaan XYZprinting</a></li>
<li><a href="../id421721/index.html">Cara memigrasi ONTAP dan tidak menjadi gila</a></li>
<li><a href="../id421723/index.html">Bagaimana mengubah komputer menjadi radio, dan cara lain untuk mengekstrak musik dari sistem komputasi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>