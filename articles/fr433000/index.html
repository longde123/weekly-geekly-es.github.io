<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèÇüèæ üåâ üö≥ Compilation de Kotlin: JetBrains VS ANTLR VS JavaCC üë©üèª‚Äçüåæ üî¨ üê≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quelle est la vitesse d'analyse de Kotlin et qu'importe? JavaCC ou ANTLR? Les codes source JetBrains conviennent-ils? 

 Comparez, fantasmez et √©merve...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Compilation de Kotlin: JetBrains VS ANTLR VS JavaCC</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433000/"><img src="https://habrastorage.org/webt/cv/to/y3/cvtoy3lpibs4fm_1asygxcsdgse.jpeg" width="300" align="left"><br>  Quelle est la vitesse d'analyse de Kotlin et qu'importe?  JavaCC ou ANTLR?  Les codes source JetBrains conviennent-ils? <br><br>  Comparez, fantasmez et √©merveillez-vous. <br><a name="habracut"></a><br><h1>  tl; dr </h1><br>  <i>Les JetBrains sont trop difficiles √† faire glisser, ANTLR est hype mais lent et inattendu, et JavaCC est trop t√¥t pour √™tre annul√©.</i> <br><br>  Analyser un simple fichier Kotlin avec trois impl√©mentations diff√©rentes: <br><table><tbody><tr><th> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </th> <th> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </th> <th> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </th> <th> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </th> </tr><tr><td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> </tr><tr><td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> </tr><tr><td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> </tr><tr><td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> </tr></tbody></table><br><h4>  Une belle journ√©e ensoleill√©e ... </h4><br>  J'ai d√©cid√© de construire un traducteur en GLSL √† partir d'un langage pratique.  L'id√©e √©tait de programmer des shaders directement dans l'id√©e et d'obtenir un support IDE ¬´gratuit¬ª - syntaxe, d√©bogage et tests unitaires.  Cela s'est av√©r√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vraiment tr√®s pratique</a> . <br><br>  Depuis lors, l'id√©e d'utiliser Kotlin est rest√©e - vous pouvez utiliser le nom vec3, c'est plus strict et plus pratique dans l'IDE.  De plus, c'est du battage m√©diatique.  Bien que, du point de vue de mon responsable interne, ce soient toutes des raisons insuffisantes, l'id√©e est revenue tellement de fois que j'ai d√©cid√© de m'en d√©barrasser simplement en la mettant en ≈ìuvre. <br><br>  <em>Pourquoi pas Java?</em>  <em>Il n'y a pas de surcharge d'op√©rateur, donc la syntaxe de l'arithm√©tique vectorielle sera trop diff√©rente de ce que vous avez l'habitude de voir dans le d√©veloppement de jeu</em> <br><br><h4>  Jetbrains </h4><br>  Les gars de JetBrains ont t√©l√©charg√© leur code de compilation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur le github</a> .  Comment l'utiliser, vous pouvez jeter un ≈ìil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  Au d√©but, j'ai utilis√© leur analyseur avec l'analyseur, car pour traduire dans une autre langue, vous devez savoir de quel type est la variable sans sp√©cifier explicitement le type <code>val x = vec3()</code> .  Ici, le type de lecteur est √©vident, mais dans l'AST, cette information n'est pas si facile √† obtenir, surtout lorsqu'une autre variable est √† droite, ou lors d'un appel de fonction. <br><br>  Ici, j'ai √©t√© d√©√ßu.  Le premier lancement de l'analyseur sur un fichier primitif prend 3 secondes (TROIS SECONDES). <br><br> <code><b>Kotlin JetBrains parser</b> <br> first call elapsed : 3254.482ms <br> min time in next 10 calls: 70.071ms <br> min time in next 100 calls: 29.973ms <br> min time in next 1000 calls: 16.655ms <br> Whole time for 1111 calls: 40.888756 seconds <br></code> <br>  Un tel moment pr√©sente les inconv√©nients √©vidents suivants: <br><br><ol><li>  car il faut plus de trois secondes pour lancer un jeu ou une application. </li><li>  pendant le d√©veloppement, j'utilise une surcharge de shader √† chaud et je vois le r√©sultat imm√©diatement apr√®s avoir chang√© le code. </li><li>  Je red√©marre souvent l'application et je suis content qu'elle d√©marre assez vite (une seconde ou deux). </li></ol><br>  Plus trois secondes pour r√©chauffer l'analyseur - c'est inacceptable.  Bien s√ªr, il est imm√©diatement devenu clair que lors des appels ult√©rieurs, le temps d'analyse tombe √† 50 ms et m√™me √† 20 ms, ce qui supprime (presque) l'inconv√©nient n ¬∞ 2 de l'expression.  Mais les deux autres ne vont nulle part.  De plus, 50 ms par fichier est plus 2500 ms par 50 fichiers (un shader correspond √† 1-2 fichiers).  Et si c'√©tait Android?  (Ici, nous ne parlons que de temps.) <br><br>  <i>Il convient de noter le travail fou de JIT.</i>  <i>Le temps d'analyse d'un fichier simple passe de 70 ms √† 16 ms.</i>  <i>Ce qui signifie, d'une part, que le JIT lui-m√™me consomme des ressources, et d'autre part, le r√©sultat sur une JVM diff√©rente peut √™tre tr√®s diff√©rent.</i> <br><br>  Pour essayer de savoir d'o√π venaient ces chiffres, il y avait une option - utiliser leur analyseur sans analyseur.  Apr√®s tout, j'ai juste besoin d'organiser les types et cela peut √™tre fait relativement facilement, tandis que l'analyseur JetBrains fait quelque chose de beaucoup plus complexe et recueille beaucoup plus d'informations.  Et puis le temps de d√©marrage diminue de moiti√© (mais presque une seconde et demie est toujours d√©cent), et le temps des appels suivants est d√©j√† beaucoup plus int√©ressant - de 8 ms dans les dix premiers √† 0,9 ms quelque part dans le millier. <br><br>  <code><b>Kotlin JetBrains parser (without analyzer)</b></code> <code><a href="">() <br> first call elapsed : 1423.731ms <br> min time in next 10 calls: 8.275ms <br> min time in next 100 calls: 2.323ms <br> min time in next 1000 calls: 0.974ms <br> Whole time for 1111 calls: 3.6884801 seconds <br></a></code> <code><a href="">()</a> <br> first call elapsed : 1423.731ms <br> min time in next 10 calls: 8.275ms <br> min time in next 100 calls: 2.323ms <br> min time in next 1000 calls: 0.974ms <br> Whole time for 1111 calls: 3.6884801 seconds <br></code> <br>  <em>J'ai d√ª collecter de tels chiffres.</em>  <em>Le premier temps de lancement est important lors du chargement des premiers shaders.</em>  <em>C'est essentiel, car ici, vous ne pouvez pas distraire l'utilisateur pendant que les shaders sont charg√©s en arri√®re-plan, il attend juste.</em>  <em>Une baisse de l'ex√©cution est importante pour voir la dynamique elle-m√™me, le fonctionnement de JIT, l'efficacit√© avec laquelle nous pouvons charger des shaders sur une application chaude.</em> <em><br></em> <br>  La principale raison de regarder principalement l'analyseur JetBrains √©tait le d√©sir d'utiliser leur typificateur.  Mais comme le rejeter devient l'option discut√©e, vous pouvez essayer d'utiliser d'autres analyseurs.  De plus, les non-JetBrains seront probablement beaucoup plus petits, moins exigeants sur l'environnement, plus faciles avec le support et l'inclusion de code dans le projet. <br><br><h4>  ANTLR </h4><br>  Il n'y avait pas d'analyseur sur JavaCC, mais sur le battage m√©diatique ANTLR, comme pr√©vu, il y en a ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">deux</a> ). <br><br>  Mais ce qui √©tait inattendu, c'√©tait la vitesse.  Les m√™mes 3 secondes pour le chargement (premier appel) et 140 ms fantastiques pour les appels suivants.  Ici, non seulement le premier lancement dure d√©sagr√©ablement, mais la situation n'est pas corrig√©e.  Apparemment, les gars de JetBrains ont fait de la magie en laissant JIT optimiser leur code de cette fa√ßon.  Parce que ANTLR n'est pas du tout optimis√© dans le temps. <br><br>  <code><b>Kotlin ANTLR parser</b></code> <code><a href="">() <br> first call elapsed : 3705.101ms <br> min time in next 10 calls: 139.596ms <br> min time in next 100 calls: 138.279ms <br> min time in next 1000 calls: 137.20099ms <br> Whole time for 1111 calls: 161.90619 seconds <br></a></code> <code><a href="">()</a> <br> first call elapsed : 3705.101ms <br> min time in next 10 calls: 139.596ms <br> min time in next 100 calls: 138.279ms <br> min time in next 1000 calls: 137.20099ms <br> Whole time for 1111 calls: 161.90619 seconds <br></code> <br><h4>  Javacc </h4><br>  En g√©n√©ral, nous sommes surpris de refuser les services d'ANTLR.  L'analyse n'a pas besoin d'√™tre aussi longue!  Il n'y a aucune ambigu√Øt√© cosmique dans la grammaire de Kotlin, et je l'ai v√©rifi√© sur des fichiers pratiquement vides.  Il est donc temps de d√©couvrir l'ancien JavaCC, de retrousser vos manches et de toujours "le faire vous-m√™me et comment." <br><br>  Cette fois, les chiffres se sont av√©r√©s attendus, bien qu'en comparaison avec les alternatives - √©tonnamment agr√©ables. <br><br>  <code><b>Kotlin JavaCC parser</b></code> <code><a href="">() <br> first call elapsed : 19.024ms <br> min time in next 10 calls: 1.952ms <br> min time in next 100 calls: 0.379ms <br> min time in next 1000 calls: 0.114ms <br> Whole time for 1111 calls: 0.38707677 seconds <br></a></code> <code><a href="">()</a> <br> first call elapsed : 19.024ms <br> min time in next 10 calls: 1.952ms <br> min time in next 100 calls: 0.379ms <br> min time in next 1000 calls: 0.114ms <br> Whole time for 1111 calls: 0.38707677 seconds <br></code> <br>  <i>Avantages soudains de votre analyseur JavaCC</i> <br>  Bien s√ªr, au lieu d'√©crire votre propre analyseur, je voudrais utiliser une solution pr√™te √† l'emploi.  Mais ceux existants ont d'√©normes inconv√©nients: <br><br>  - performances (les pauses lors de la lecture d'un nouveau shader sont inacceptables, ainsi que trois secondes d'√©chauffement au d√©part) <br>  - un √©norme runtime kotlin, je ne sais m√™me pas s'il est possible d'emballer un analyseur dans le produit final en l'utilisant <br>  - par ailleurs, dans la solution actuelle avec Groovy le m√™me probl√®me - le runtime s'√©tire <br><br>  Alors que l'analyseur JavaCC r√©sultant est <br><br>  + excellente vitesse √† la fois au d√©but et dans le processus <br>  + juste quelques classes de l'analyseur lui-m√™me <br><br><h4>  Conclusions </h4><br>  Les JetBrains sont trop difficiles √† faire glisser, ANTLR est hype mais lent et inattendu, et JavaCC est trop t√¥t pour √™tre annul√©. <br><br>  Analyser un simple fichier Kotlin avec trois impl√©mentations diff√©rentes: <br><br><table><tbody><tr><th> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </th> <th> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </th> <th> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </th> <th> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </th> </tr><tr><td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> </tr><tr><td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> </tr><tr><td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> </tr><tr><td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> </tr></tbody></table><br>  √Ä un moment donn√©, j'ai d√©cid√© de regarder la taille du pot avec toutes les d√©pendances.  Les JetBrains sont excellents comme pr√©vu, <strike>mais le runtime ANTLR √©tonne par sa taille</strike> . <br>  <i>MISE √Ä JOUR: Initialement, j'ai √©crit 15 Mo, mais comme sugg√©r√© dans les commentaires, si vous connectez antlr4-runtime au lieu de antlr4, la taille tombe √† la valeur attendue.</i>  <i>Bien que l'analyseur JavaCC lui-m√™me reste 10 fois plus petit que ANTLR (si vous supprimez tout le code, √† l'exception des analyseurs eux-m√™mes).</i> <br>  La taille du pot en tant que tel est bien s√ªr importante pour les t√©l√©phones portables.  Mais cela compte √©galement pour le bureau, car, en fait, cela signifie la quantit√© de code suppl√©mentaire qui peut contenir des bogues, que l'IDE doit indexer, ce qui, exactement, affecte la vitesse du premier chargement et la vitesse de pr√©chauffage.  De plus, pour un code complexe, il y a peu d'espoir de traduire dans une autre langue. <br>  Je ne vous invite pas √† compter les kilo-octets et j'appr√©cie le temps et la commodit√© du programmeur, mais cela vaut quand m√™me la peine de penser aux √©conomies, car c'est ainsi que les projets deviennent maladroits et difficiles √† maintenir. <br><br>  <i>Quelques mots sur ANTLR et JavaCC</i> <br><br>  Une caract√©ristique s√©rieuse d'ANTLR est la s√©paration de la grammaire et du code.  Ce serait bien s'il n'avait pas √† payer si cher.  Oui, et cela n'a d'importance que pour les ¬´d√©veloppeurs en s√©rie de grammaires¬ª, et pour les produits finaux, ce n'est pas si important, car m√™me la grammaire existante devra encore √™tre termin√©e pour √©crire votre code.  De plus, si nous √©conomisons de l'argent et prenons une grammaire ¬´tierce¬ª - cela peut simplement √™tre g√™nant, il faudra quand m√™me bien le comprendre, cela transformera l'arbre pour lui-m√™me.  En g√©n√©ral, JavaCC, bien s√ªr, m√©lange les mouches et les c√¥telettes, mais est-ce vraiment important et est-ce si mauvais? <br><br>  Une autre caract√©ristique d'ANTLR est les nombreuses plates-formes cibles.  Mais ici, vous pouvez regarder de l'autre c√¥t√© - le code sous JavaCC est tr√®s simple.  Et c'est tr√®s simple ... diffus√©!  √Ä droite avec votre code personnalis√© - au moins en C #, au moins en JS. <br><br><h4>  PS </h4><br>  Tout le code est ici <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github.com/kravchik/yast</a> <br><br>  Le r√©sultat de l'analyse est un arbre construit sur YastNode (il s'agit en fait d'une classe tr√®s simple - une carte avec des m√©thodes pratiques et un identifiant).  Mais YastNode n'est pas vraiment un "n≈ìud sph√©rique dans le vide".  C'est cette classe que j'utilise activement, sur la base de laquelle j'ai collect√© plusieurs outils - un typificateur, plusieurs traducteurs et un optimiseur / inliner. <br><br>  L'analyseur JavaCC ne contient pas encore toute la grammaire, il en reste 10%. Mais il ne semble pas que cela puisse affecter les performances - j'ai v√©rifi√© la vitesse au fur et √† mesure de l'ajout de r√®gles, et cela n'a pas chang√© de fa√ßon notable.  De plus, j'ai d√©j√† fait beaucoup plus que ce dont j'avais besoin et j'essaie simplement de partager le r√©sultat inattendu trouv√© dans le processus. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr433000/">https://habr.com/ru/post/fr433000/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr432990/index.html">Lampe en bois √† commande vocale Edison. Prix ‚Äã‚Äãd'√©mission 5 $</a></li>
<li><a href="../fr432992/index.html">Il a mis ses √©couteurs et est mort: nous parlons de la mort √©trange d'un √©colier √† Rimbau</a></li>
<li><a href="../fr432994/index.html">Vivaldi 2.2 - Conversion de quantit√© en qualit√©</a></li>
<li><a href="../fr432996/index.html">Un peu de dictionnaires internes en CPython (et PyPy)</a></li>
<li><a href="../fr432998/index.html">Histoire de No√´l</a></li>
<li><a href="../fr433002/index.html">Venez vous-m√™me ... ou les r√®gles de la communication en √©quipe</a></li>
<li><a href="../fr433004/index.html">Une strat√©gie de migration cloud robuste pour 2019: 7 conseils</a></li>
<li><a href="../fr433008/index.html">Les p√©riph√©riques USB constituent une menace ¬´soudaine¬ª</a></li>
<li><a href="../fr433010/index.html">Avoir une id√©e: syst√®me d'autorisation pour les packages npm</a></li>
<li><a href="../fr433012/index.html">Peut-√™tre que je ne suis en vie qu'√† cause d'elle: pourquoi les patients souffrant d'apn√©e s'appuient-ils sur un programme √©crit par un pirate</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>