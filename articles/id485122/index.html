<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèÜ üìä ‚è∏Ô∏è Judul "Baca artikel untuk Anda." Oktober - Desember 2019 ‚ûó üë≤üèø üôã</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Kami terus mempublikasikan ulasan artikel ilmiah dari anggota komunitas Open Data Science dari saluran #article_essense. Jika Anda ingin m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Judul "Baca artikel untuk Anda." Oktober - Desember 2019</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ods/blog/485122/"><img src="https://habrastorage.org/webt/gx/-y/xl/gx-yxlo7xiz-5y8krpyoj3rgswq.png"><br><p><br>  Halo, Habr!  Kami terus mempublikasikan ulasan artikel ilmiah dari anggota komunitas Open Data Science dari saluran #article_essense.  Jika Anda ingin menerimanya sebelum orang lain - bergabunglah dengan <a href="http://ods.ai/">komunitas</a> ! </p><br><p>  Artikel untuk hari ini: </p><br><ol><li>  <a href="https://habr.com/ru/company/ods/blog/485122/">Poly-encoders: Arsitektur Transformer dan Strategi Pra-pelatihan untuk Penghitungan Multi-kalimat yang Cepat dan Akurat (Facebook, 2019)</a> </li><li>  <a href="https://habr.com/ru/company/ods/blog/485122/">Diskriminator Tersirat dalam Variational Autoencoder (Institut Teknologi Ropar India, 2019)</a> </li><li>  <a href="https://habr.com/ru/company/ods/blog/485122/">Pelatihan mandiri dengan Noisy Student meningkatkan klasifikasi ImageNet (Google Research, Carnegie Mellon University, 2019)</a> </li><li>  <a href="https://habr.com/ru/company/ods/blog/485122/">Kontras Momentum untuk Pembelajaran Representasi Visual Tanpa Pengawasan (Facebook, 2019)</a> </li><li>  <a href="https://habr.com/ru/company/ods/blog/485122/">Benchmarking Neural Network Robustness to Common Corruption dan Perturbations (University of California, Oregon State University, 2019)</a> </li><li>  <a href="https://habr.com/ru/company/ods/blog/485122/">DistilBERT, versi suling BERT: lebih kecil, lebih cepat, lebih murah dan lebih ringan (Hugging Face, 2019)</a> </li><li>  <a href="https://habr.com/ru/company/ods/blog/485122/">Model Bahasa Plug and Play: Pendekatan Sederhana Untuk Pembuatan Teks Terkendali (Uber AI, Caltech, HKUST, 2019)</a> </li><li>  <a href="https://habr.com/ru/company/ods/blog/485122/">Representasi Salience Jauh untuk Estimasi F0 dalam Musik Polifonik (New York University, AS, 2017)</a> </li><li>  <a href="https://habr.com/ru/company/ods/blog/485122/">Menganalisis dan Meningkatkan Kualitas Gambar dari StyleGAN (NVIDIA, 2019)</a> </li></ol><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Tautan ke koleksi seri terakhir:</b> <div class="spoiler_text"><ul><li>  <a href="https://habr.com/ru/company/ods/blog/472672/">Juli - September 2019</a> </li><li>  <a href="https://habr.com/ru/company/ods/blog/471514/">Januari - Juni 2019</a> </li><li>  <a href="https://habr.com/ru/company/ods/blog/352518/">Februari - Maret 2018</a> </li><li>  <a href="https://habrahabr.ru/company/ods/blog/352508/">Desember 2017 - Januari 2018</a> </li><li>  <a href="https://habrahabr.ru/company/ods/blog/343822/">Oktober - November 2017</a> </li><li>  <a href="https://habrahabr.ru/company/ods/blog/339094/">September 2017</a> </li><li>  <a href="https://habrahabr.ru/company/ods/blog/336624/">Agustus 2017</a> </li></ul></div></div><br><h3 id="1-poly-encoders-transformer-architectures-and-pre-training-strategies-for-fast-and-accurate-multi-sentence-scoring">  1. Poly-encoders: Arsitektur Transformer dan Strategi Pra-pelatihan untuk Skor Multi-kalimat yang Cepat dan Akurat </h3><br><p>  Penulis: Samuel Humeau, Kurt Shuster, Marie-Anne Lachaux, Jason Weston (Facebook, 2019) <br>  <a href="https://arxiv.org/abs/1905.01969">‚Üí Artikel asli</a> <br>  Penulis ulasan: Alexey (dalam slack zhirzemli) </p><br><p>  <strong>TLDR</strong> </p><br><p>  Artikel ini mengusulkan pendekatan baru untuk mencetak pasangan kalimat (pernyataan).  Prosedur ini relevan dalam tugas memprediksi apakah respons cocok dengan konteks kondisional, serta dalam tugas-tugas seperti prediksi sentense berikutnya.  Metode Poly-Encoder yang diusulkan dibandingkan dengan strategi Bi-Encoder dan Cross-Encoder.  Metode ini menggabungkan keunggulan Bi-Encoder (kemampuan untuk men-cache presentasi tanggapan) dan Cross-Encoder (bukan pelatihan tanpa syarat konteks dan encoders jawaban) </p><br><img src="https://habrastorage.org/webt/ax/qd/nl/axqdnlibzffxcyjtbfzeguhsdja.png" width="500" height="250"><br><p><br></p><br><p>  <strong>Skor multi-kalimat</strong> </p><br><p>  (Pengingat kecil tentang pendekatan Bi dan Cross Encoder. Bagi mereka yang akrab, Anda dapat melewatkan) </p><br><p>  Tugas menentukan korespondensi konteks (permintaan atau pernyataan pengguna) dengan sekumpulan jawaban yang ada sebagian besar relevan dalam sistem dialog dan pencarian informasi.  Ini dipecahkan baik dengan menemukan kecepatan tertentu (titik produk) antara representasi yang dikodekan dari konteks dan respons, atau dengan secara bersama-sama mengkodekan konteks dan respons menjadi satu vektor dengan transformasi linear berikutnya menjadi skalar. </p><br><p>  Pendekatan pertama disebut Bi-Encoder dan keuntungan nyata dari metode ini adalah kemampuan untuk menghitung secara offline representasi semua jawaban yang tersedia.  Pandangan ini di-cache, dan selama inferensi Anda hanya perlu menemukan vektor kueri, membuat produk titik dengan vektor respons dan mengatur hasilnya.  Selain itu, pendekatan ini memungkinkan pengambilan sampel negatif yang lebih efisien pada tahap pelatihan.  Yaitu, dalam setiap batch, representasi untuk sampel positif dipertimbangkan, dan contoh negatif dapat diambil langsung dari batch yang sama.  Intinya, gunakan kembali forward pass untuk contoh positif dan negatif.  Kerugian dari pendekatan Bi-Encoder adalah kenyataan bahwa representasi konteks dan respon belajar hampir secara mandiri.  Satu-satunya titik di mana setidaknya beberapa jenis aliran informasi mungkin antara tampilan permintaan dan respons adalah botnet dalam bentuk produk titik akhir.  Pada tingkat fitur tekstual apa pun, informasi tidak diraba-raba. </p><br><p>  Pendekatan kedua adalah Cross-Encoder.  Ini melibatkan interaksi konteks dan respons yang lebih kuat dalam proses pembelajaran dan inferensi.  Di sini, urutan token permintaan dan respons digabungkan menjadi satu.  Token pemisah khusus ditempatkan di antara mereka, dan penyematan khusus ditambahkan ke setiap bagian (permintaan, respons).  Bahkan, embedding ini menggeser representasi input dari token respons oleh beberapa konstanta, sehingga model dapat lebih mudah membedakannya dari token permintaan.  Akibatnya, model belajar untuk menemukan representasi bersama dari permintaan dan respons, sehingga lapisan linear akhir (vektor -&gt; skalar) mengembalikan nilai log yang besar untuk pasangan kalimat yang cocok satu sama lain dan nilai yang kecil sebaliknya.  Kerugian dari pendekatan ini adalah ketidakmungkinan menghitung secara offline representasi jawaban: mereka harus dievaluasi pada tahap inferensi, bersama dengan set token permintaan bersyarat.  Juga, trik menggunakan kembali ide contoh negatif dan positif pada tahap pelatihan tidak akan lagi berfungsi di sini.  Anda harus mengumpulkan sampel negatif sebelum pembentukan batch. </p><br><p>  <strong>Motivasi</strong> <br>  Berikut ini adalah solusi yang memungkinkan Anda untuk mengurangi kekurangan dan menggabungkan keunggulan pendekatan Bi dan Cross Encoder.  Idenya adalah bahwa kita ingin melatih pembuat enkode yang, di satu sisi, akan memperhitungkan ketergantungan bersyarat dari token respons pada token permintaan, dan di sisi lain, pemanfaatan ketergantungan ini harus terjadi pada representasi respons dan permintaan yang telah dievaluasi sebelumnya.  Secara geometris, saya pribadi membayangkannya seperti ini: pindahkan botnet (produk titik akhir dari dua pengiriman) sedikit lebih rendah ke jaringan.  Buat beberapa interaksi antara tampilan permintaan dan respons.  Pada saat yang sama, mengimplementasikan interaksi seperti itu tidak terlalu jauh dari lapisan akhir, sehingga bagian utama dari pembuat enkode tetap independen dari pembuat enkode respons. </p><br><p>  <strong>Implementasi</strong> <br>  Implementasi dari ide semacam itu cukup sederhana: pembuat kode kandidat berfungsi seperti pada kasus Bi-Encoder: kita mendapatkan representasi urutan dalam bentuk vektor ([CLS] token) menggunakan model berbasis transformator (BERT).  Kami menyimpan cache representasi ini setelah melatih model. </p><br><p>  Encoder konteks, pada gilirannya, tidak memampatkan representasi dari urutan input menjadi satu vektor.  Di sini kita membiarkan semua vektor urutan dikodekan oleh model. </p><br><p>  Untuk mendapatkan penilaian kesesuaian konteks (satu set vektor) dan kandidat (satu vektor), mekanisme perhatian digunakan.  Vektor kandidat dalam kasus ini adalah permintaan, dan vektor konteks adalah kuncinya.  Ini dianggap sebagai produk titik dan selanjutnya - softmax sesuai dengan nilai yang dihasilkan.  Vektor konteks ditimbang dengan distribusi yang dihasilkan dan dijumlahkan.  Hasilnya, kita mendapatkan representasi konteks dalam bentuk vektor tunggal.  Dan lebih lanjut, seperti pada Bi-Encoder biasa, kami mempertimbangkan titik produk dari konteks dan kandidat. </p><br><p>  Juga, artikel itu mengusulkan sejumlah cara untuk mempercepat pembobotan vektor konteks.  Pilihan yang paling berhasil adalah proses penghitungan perhatian, di mana hanya vektor pertama dari urutan konteks yang diambil. </p><br><p>  <strong>Hasil</strong> <br>  Alhasil, ternyata Cross-Encoder tetap bekerja paling baik.  Tapi Poly-Encoder tidak jauh di belakangnya dalam hal metrik kualitas, dan dalam hal kecepatan inferensi kerjanya ratusan kali lebih cepat. </p><br><h3 id="2-implicit-discriminator-in-variational-autoencoder">  2. Diskriminator Tersirat dalam Variabel Autoencoder </h3><br><p>  Penulis: Prateek Munjal, Akanksha Paul, Narayanan C. Krishnan (Institut Teknologi India Ropar, 2019) <br>  <a href="https://arxiv.org/abs/1909.13062">‚Üí Artikel asli</a> <br>  Penulis ulasan: Alex Chiron (in sliron shiron8bit) </p><br><p>  Dalam artikel tersebut, penulis mengusulkan arsitektur yang mencoba untuk menggabungkan keuntungan dari pendekatan VAE dan GAN untuk menghasilkan gambar, melewati kerugian yang melekat dalam setiap pendekatan: keburaman dalam kasus autoencoder, mode runtuh / mode hilang dalam kasus pelatihan permusuhan.  Mereka mencapai ini karena bobot total antara encoder dan diskriminator dan generator / decoder umum, yang, pertama, mengurangi jumlah bobot jaringan, dan kedua, memungkinkan kita untuk mendapatkan informasi yang berguna dari diskriminator melalui gradien jika generator / decoder tidak jatuh dalam distribusi data aktual. </p><br><p>  <strong>Pendahuluan</strong> <br>  Dalam masalah generasi, peran penting dimainkan oleh kebetulan distribusi data yang dihasilkan Q dengan distribusi data nyata P, yang diukur melalui perbedaan Kullback-Leibler.  Ciri khas dari ukuran keterpencilan distribusi ini adalah asimetris.  Dengan demikian, kita akan mendapatkan gambar yang berbeda tergantung pada apakah kita mempertimbangkan Div_KL (P || Q) atau Div_KL (Q || P).  Jika kita mempertimbangkan dua opsi untuk membandingkan distribusi (pada gambar di bawah), maka dengan Div_KL (P || Q) (alias forward-KL, alias zero avoiding), opsi kedua akan memberikan nilai yang lebih rendah, dan untuk Div_KL (Q || P) (itu mundur-KL, itu juga nol pemaksaan) distribusi dari opsi pertama akan dianggap distribusi yang lebih dekat.  Sebenarnya, hasil VAE dan GAN sangat berbeda: kerugian rekonstruksi (L2) membantu meminimalkan divergensi KL-ke depan (dan dengan demikian kami mempertahankan semua mode, tetapi kami mendapatkan gambar buram), dan pelatihan dengan diskriminator membantu meminimalkan divergensi-KL ke belakang (gambar diperoleh lebih banyak jelas, tetapi ada risiko melewatkan mod) </p><br><img src="https://habrastorage.org/webt/y9/7k/cd/y97kcdipocff08h4dsoaqly3udq.png" width="500" height="250"><br><p><br></p><br><p>  <strong>Arsitektur, Kerugian dan Pelatihan</strong> <br>  Seperti yang telah disebutkan, penulis mengusulkan untuk mempertimbangkan kekurangan dari kedua mode dan menggabungkan kedua minimasi karena arsitektur jaringan (dalam gambar di bawah), di mana sebagian besar bobot encoder dan diskriminator adalah umum (hanya kepala yang terhubung sepenuhnya yang memprediksi 'realitas' gambar dan parameter terpisah. mu, sigma dari lapisan laten VAE), dan juga karena mode pelatihan.  Encoder dan generatornya sama. Sebagian besar kerugian yang digunakan cukup standar: dalam L_enc encoder los, kesalahan pemulihan L2 dan perbedaan Kullback-Leibler ke N (0,1) (L_prior) digunakan, sisanya adalah pelatihan permusuhan (kami meminimalkan keluaran diskriminator ketika melatih pembeda, memaksimalkannya) ketika mempelajari decoder / generator), tetapi ada 2 fitur khas: </p><br><ul><li><p>  Dalam kerugian terkait pelatihan permusuhan, 2 jenis data yang dihasilkan diumpankan ke diskriminator: dipulihkan melalui encoder / decoder dan dihasilkan oleh generator / decoder dari sampel dari N (0,1) </p><br></li><li><p>  Dalam Kehilangan decoder L_dec, ada anggota di mana fitur dari lapisan kedua dari pembeda (lagi, ini adalah lapisan umum terakhir antara pembeda dan encoder) dibandingkan untuk gambar nyata dan dikembalikan. </p><br></li></ul><br><img src="https://habrastorage.org/webt/-d/n5/jh/-dn5jh_obvrbb4am3ujm37hd9qs.png" width="500" height="250"><br><p>  <strong>Hasil</strong> <br>  Para penulis membandingkan hasilnya dengan VAE dan karya-karya lain, dengan satu atau lain cara mencoba untuk menggabungkan VAE dan GAN (VAE-GAN, alpha-GAN dan AGE dari Dmitry Ulyanov dan Victor Lempitsky) pada data celeba dan cifar10 (terima kasih untuk tidak mnist), menerima hampir indikator terbaik mengenai kesalahan rekonstruksi dan metrik Frechet Inception Distance (bandingkan statistik aktivasi untuk mesh pra-terlatih untuk gambar nyata dan yang dihasilkan).  Secara terpisah dicatat bahwa peringkat oleh FID sangat tergantung pada arsitektur yang dipilih, sehingga hasilnya lebih baik untuk memeriksa ensemble 'pakar' (arsitektur yang berbeda). </p><br><h3 id="3-self-training-with-noisy-student-improves-imagenet-classification">  3. Pelatihan mandiri dengan Noisy Student meningkatkan klasifikasi ImageNet </h3><br><p>  Penulis: Qizhe Xie, Eduard Hovy, Minh-Thang Luong, Quoc V. Le (Penelitian Google, Universitas Carnegie Mellon, 2019) <br>  <a href="https://arxiv.org/abs/1911.04252">‚Üí Artikel asli</a> <br>  Penulis ulasan: Alexander Belsky (in slack belskikh) </p><br><p>  Google menerima 87,4% benar-benar mengesankan top1 dan 98,2% top5 akurasi pada gambar.  Zayuzali mengaburkan jaringan pseudo-peredupan dan sangat berani.  Pendekatan itu disebut Noisy Student. </p><br><img src="https://habrastorage.org/webt/es/s8/tm/ess8tmsezy4cjwydsqqfhjxclcu.png"><br><p><br></p><br><p>  <strong>Algoritme adalah</strong> sesuatu seperti ini: </p><br><ol><li>  Kami mengambil model guru, kami mengajarkan citra yang normal. </li><li>  Kami menghasilkan label psudo lunak pada gambar dari dataset JFT. </li><li>  Kami mengajarkan model siswa pada pseudo-label lunak, dan kami mengganggu sesegera mungkin: augs yang kuat, putus sekolah dan kedalaman stokastik </li><li>  Ambil model siswa, gunakan sebagai guru di langkah 2 dan ulangi prosesnya. Dataset diseimbangkan sesuai dengan kelas sebagai berikut.  Untuk mulai dengan, kami mengambil EfficientNet-B0, terlatih pada gambar, mengusir prediksi pada dataset JFT.  Kemudian mereka mengambil contoh-contoh yang kepercayaan maksimumnya di atas 0,3.  Untuk setiap kelas, 130K gambar diambil (jika setelah disaring oleh 0,3 trashhold, mereka lebih sedikit - digandakan, jika lebih banyak - diambil sesuai dengan cakupan predikat tertinggi).  Menerima 130 juta gambar, duplikat emisi, tersisa 81 juta </li></ol><br><p>  <strong>Arsitektur:</strong> <br>  EfficeintNet, apalagi, model siswa mengambil model guru yang jauh lebih gemuk.  Mereka juga memindai EfficientNet sendiri ke EfficientNet-L0 / L1 / L2, menghasilkan model L2 dengan parameter 480M (Resnet50 memiliki parameter 26M, untuk perbandingan) </p><br><p>  <strong>Proses belajar:</strong> <br>  Butchesize 2048. Sota model L2 mengajarkan 350 era.  Model L2 terbesar yang dipelajari dalam mode ini selama 3,5 hari di Cloud TPU v3 Pod dengan 2048 core. </p><br><p>  <strong>Prosedur pembelajaran berulang:</strong> <br>  Awalnya mereka mengajar B7 baik sebagai siswa maupun sebagai guru.  Kemudian, menggunakan B7 sebagai guru, mereka mengajar L0 yang lebih gemuk sebagai siswa.  Kemudian, mengubah tempat mereka seperti ini, kami sampai ke model L2, yang pada akhirnya kami gunakan sebagai guru untuk model L2 yang sama. Hasil :: sota: dengan parameter model 2 kali lebih sedikit dibandingkan dengan sel sebelumnya (FixRes ResNeXt-101 WSL Parameter 829M) </p><br><p>  Juga mendapat <strong>hasil yang</strong> sangat bagus di ImageNet-A / C / P </p><br><img src="https://habrastorage.org/webt/ht/me/ce/htmeceti9jluqoyj84uqcy2fibo.png"><br><p><br></p><br><h3 id="4-momentum-contrast-for-unsupervised-visual-representation-learning">  4. Kontras Momentum untuk Pembelajaran Representasi Visual Tanpa Pengawasan </h3><br><p>  Penulis artikel: Kaiming He, Fan Haoqi, Yuxin Wu, Saining Xie, Ross Girshick (Facebook, 2019) <br>  <a href="https://arxiv.org/abs/1911.05722">‚Üí Artikel asli</a> <br>  Penulis ulasan: Arseny Kravchenko (dalam slack arsenyinfo) </p><br><p>  SotA adalah pretrain tanpa pengawasan untuk beberapa tugas penglihatan komputer (dari klasifikasi hingga estimasi pose padat), diuji pada set data yang berbeda (imagenet, instagram) dan tugas utama (imagenet, COCO, cityscapes, LVIS dll.). </p><br><img src="https://habrastorage.org/webt/li/5p/bn/li5pbnzez-zowzce2movvxthfea.png"><br><p><br></p><br><p>  Bagaimana pretrain tanpa pengawasan lakukan?  Kami menemukan beberapa jenis tugas yang labelnya tidak diperlukan, kami mempelajari pembuat enkode, membekukannya, dan kemudian kami memecahkan masalah utama dengan menambahkan lapisan yang hilang (linear untuk klasifikasi, decoder untuk segmentasi, dan sebagainya).  Salah satu tugas paling populer di ceruk ini adalah diskriminasi instan, berdasarkan pada kerugian kontras, mis.  kami ingin fitur penambahan yang berbeda dari gambar yang sama berdekatan satu sama lain (misalnya, dalam hal jarak kosinus), dan fitur yang berbeda jauh jauh. </p><br><p>  Anda dapat mencoba mengajarkan tugas ini secara end-to-end, tetapi banyak tergantung pada ukuran batch: kualitasnya sangat tergantung pada berbagai contoh di dalam batch.  Eksperimen menunjukkan bahwa dengan bertambahnya ukuran bets, kualitas akhir meningkat.  Tetapi bets ini agak mirip dengan Moskow: itu bukan karet, itu tidak akan bekerja untuk waktu yang lama untuk meningkatkannya di dahi. </p><br><p>  Dudes sel dekat dudes sebelumnya mengacaukan bank memori: fitur batch sebelumnya disimpan secara terpisah dalam memori dan juga digunakan untuk menghasilkan yang negatif, mis.  sampel yang berbeda.  Ini sebagian membantu, tetapi juga tidak sempurna: selama pelatihan, bobot encoder berubah dan fitur lama menjadi buruk. </p><br><p>  Akhirnya, gagasan artikel: </p><br><ol><li>  Mari kita ganti bank memori sederhana dengan antrian di mana fitur yang cukup segar akan terletak; </li><li>  Kami akan menyimpan dua versi pembuat enkode: satu digunakan untuk kumpulan saat ini dan dilatih, dan yang lainnya lebih stabil, bobotnya diperbarui dari versi pertama, tetapi dengan momentum besar; </li><li>  Fitur bets dianggap sebagai enkoder pertama, fitur dalam antrian dihitung oleh enkoder kedua. </li></ol><br><p>  Pendekatan ini memungkinkan untuk lebih dekat dengan kualitas pelatihan end-to-end, tetapi, berkat garis panjang, itu mencapai hasil potensial dari batch besar yang tidak realistis.  Dengan cara ini Anda mendapatkan metrik keren untuk berbagai tugas, termasuk  di beberapa tempat, itu bahkan sedikit lebih baik daripada pretrain gambar tradisional yang diawasi. </p><br><h3 id="5-benchmarking-neural-network-robustness-to-common-corruptions-and-perturbations">  5. Benchmarking Neural Network Robustness to Common Corruption dan Perturbations </h3><br><p>  Penulis: Dan Hendrycks, Thomas Dietterich (University of California, Oregon State University, 2019) <br>  <a href="https://arxiv.org/abs/1903.12261">‚Üí Artikel asli</a> <br>  Penulis ulasan: Vladimir Iglovikov (in ternaus slack) </p><br><img src="https://habrastorage.org/webt/fy/p3/zn/fyp3znumddg9tstty7aukiiuvwg.png" width="500" height="250"><br><p><br></p><br><p>  Itu diterima di ICLR 2019 dan seperti yang saya pahami, ini adalah salah satu karya DL yang belum dilatih di jaringan apa pun. </p><br><p>  Tugasnya seperti ini - tetapi mari kita coba augmentasi untuk validasi ImageNet, tetapi kami akan melatih yang tidak terputus.  Selain itu, tidak seperti adevrsarial, kami tidak memiliki tugas untuk membuat transformasi kecil dan tidak terlihat oleh mata. </p><br><p>  <strong>Apa yang telah dilakukan:</strong> </p><br><ol><li>  Satu set augmentasi telah dipilih.  Para penulis mengatakan bahwa ini adalah yang paling umum, tetapi, menurut pendapat saya, mereka berbohong. <br>  Mereka menggunakan: GaussianNoise, ISONoise, Downscale, Defocus, MotionBlur, ZoomBlur, FrostedGlassBlur, JpegCompression, Snow, Fog, Rain, Transoform elastis, dll. </li><li>  Semua transformasi ini telah diterapkan pada validasi ImageNet.  Dataset yang dihasilkan bernama ImageNet-C </li><li>  Variasi yang disebut ImageNet-P juga diusulkan di mana serangkaian transformasi kekuatan yang berbeda diterapkan pada setiap gambar. </li><li>  Metrik diusulkan untuk menilai stabilitas model. </li><li>  Beberapa model dievaluasi dalam konteks metrik ini: AlexNet, VGG-11, VGG-19, Resnet-50, Resnet-18, VGG-19 + BN, dll </li></ol><br><p>  <strong>Kesimpulan:</strong> </p><br><ol><li>  Semakin kuat augmentasi, semakin banyak akurasi model yang diderita.  : capitan_obvious: </li><li>  Semakin kompleks modelnya, semakin stabil. </li><li>  Menerapkan CLAHE dalam gambar sebelum inferensi sedikit membantu. </li><li>  blok agregasi fitur seperti bantuan DenseNet atau Resnext. </li><li>  Jaringan yang memiliki multiskala lebih stabil.  Contoh dari jaringan tersebut adalah MSDNet, Multigrid (Saya belum pernah mendengar tentang jaringan tersebut) </li></ol><br><p>  <a href="https://github.com/hendrycks/robustness">Kode</a> </p><br><h3 id="6-distilbert-a-distilled-version-of-bert-smaller-faster-cheaper-and-lighter">  6. DistilBERT, versi BERT yang disuling: lebih kecil, lebih cepat, lebih murah dan lebih ringan </h3><br><p>  Penulis: Victor Sanh, Debut Lysandre, Julien Chaumond, Thomas Wolf (Hugging Face, 2019) <br>  <a href="https://arxiv.org/abs/1910.01108">‚Üí Artikel asli</a> <br>  Penulis ulasan: Yuri Kashnitsky (in yorko slack) </p><br><p>  Artikel ini pendek, sangat mudah dibaca.  Pada awalnya, beberapa kata umum tentang perlombaan senjata di NLP dan jejak kaki lingkungan.  Lebih jauh, gagasan distilasi (dan Hinton juga melakukannya di sini). Dalam tugas pemodelan bahasa, kami memprediksi kata berikutnya secara kontekstual.  Biasanya, cross entropy loss membandingkan vektor probabilitas yang diprediksi (panjang keseluruhan kamus) dengan vektor biner, di mana hanya ada satu unit yang menunjukkan kata asli di tempat tertentu dalam set pelatihan.  Yaitu, yang kedua, ketiga, dll.  kata yang dianggap tepat oleh model diabaikan oleh kehilangan.  Sebuah contoh diberikan dalam artikel: "Saya pikir ini adalah awal dari [MASK] yang indah", bukannya [MASK] BERT ingin menggantikan pertama dari semua hari atau kehidupan, tetapi kata-kata yang diprediksi oleh probabilitas masa depan di masa depan, cerita dan dunia juga baik.  Bisakah kita mempertimbangkan fakta bahwa model tersebut menghasilkan distribusi probabilitas yang baik?  Secara kasar, untuk memberikan penghargaan kepada model untuk fakta bahwa tidak ada Murdock, toleransi, kehamilan dan beberapa kata lain yang cocok di atas. </p><br><img src="https://habrastorage.org/webt/wg/xd/rx/wgxdrxth-vykjuhkxszaxakxdke.png" width="500" height="250"><br><p><br></p><br><p>  <strong>Gagasan penyulingan</strong> <br>  Gagasan skema guru-siswa tertentu adalah bahwa kita memiliki model guru yang besar ( <strong>guru</strong> , BERT) dan model yang lebih kecil ( <strong>siswa</strong> , DistilBERT), yang akan mengirimkan "pengetahuan" dari model guru.  Model siswa akan mengoptimalkan kehilangan distilasi, yaitu, hilangnya entropi silang, yang ditentukan untuk distribusi probabilitas guru dan siswa: L = Œ£ t_i * log (s_i).  Yaitu, untuk kata tertentu yang dihapus oleh simbol [MASK], dan yang harus diprediksi berdasarkan konteks, kami membandingkan dua distribusi probabilitas penampilan setiap kata dari kamus: {t_i} dan {s_i} - diprediksi, masing-masing, oleh model guru dan model siswa.  Dengan demikian, sinyal pelatihan yang kaya diperoleh - model siswa pada setiap kata menerima sinyal yang dihitung tidak hanya dengan membandingkan vektor ramalannya dengan kata asli dalam sampel pelatihan, tetapi dengan membandingkannya dengan vektor proyeksi dari model guru. </p><br><p>  <strong>Model DistilBERT</strong> <br>    ,   ‚Äî   ,  .   DistilBERT ‚Äî      BERT,    .   token-type embeddings  pooler, ,    .  ,  DistilBERT  40%  ‚Äî 66 .   110   BERT </p><br><p> <strong> DistilBERT</strong> <br>  DistilBERT  distillation loss     ‚Äî   masked language modeling loss,    BERT   cosine embedding loss ‚Äî           ( ,  ,      "" -   ,  "" ). :   ablation studies, ,   masked language modeling loss,    , ..    distillation loss  cosine embedding loss.   ,    RoBERTa   next sentence prediction   dynamic masking. </p><br><p>      ,  BERT (eng. wiki + Toronto Book Corpus) 90   8 V100 (16 GB).   RoBERTa    1024 V100 (32 GB). </p><br><p> <strong></strong> <br>     BERT ‚Äî "it performed surprisingly well",        DistilBERT ‚Äî  GLUE  surprisingly well ‚Äî     5  9   ,  BERT ,     SQuAD  IMDb ‚Äî  .   ,    DistilBERT   60% ‚Äî  . </p><br><p> <strong> </strong> <br>   DistilBERT  iPhone 7 Plus.   70% ,  BERT-base (  ),     200 .  ablation studies:     ,      ‚Äî distillation loss  cosine embedding loss. </p><br><p>      3          ,  DistilBERT ‚Äî     BERT,   40%  ,   60%    "97%   "    BERT (        ML). </p><br><p> -,      BERT,     . </p><br><p> <strong> :</strong> <br> <a href="https://jalammar.github.io/a-visual-guide-to-using-bert-for-the-first-time/"> Jay Alammar</a> <br> <a href="https://www.kaggle.com/kashnitsky/distillbert-catalyst-amazon-product-reviews">  , DistilBERT + Catalyst:   </a> </p><br><h3 id="7-plug-and-play-language-models-a-simple-approach-to-controlled-text-generation"> 7. Plug and Play Language Models: A Simple Approach To Controlled Text Generation </h3><br><p>  : Sumanth Dathathri, Andrea Madotto, Janice Lan, Jane Hung, Eric Frank, Piero Molino, Jason Yosinski, and Rosanne Liu (Uber AI, Caltech, HKUST, 2019) <br> <a href="https://arxiv.org/abs/1912.02164">‚Üí  </a> <br>  :   (  Egor Timofeev) </p><br><p>               . ,           / /      (, .  <a href="https://arxiv.org/pdf/1909.05858.pdf">https://arxiv.org/pdf/1909.05858.pdf</a> ).     ,         ,     , ,      . </p><br><p> <strong></strong> <br>       (   x_prev    ),        p(x),      conditional LM (,    ‚Äî CTRL)    p(x|a). </p><br><p>       : p(x|a) ‚àù p(x)p(a|x),  p(x)  ,    (, GPT2),  p(a|x) ‚Äî     .       ‚Äî       ,   /.     ,       ,    . </p><br><p>   <strong></strong> : </p><br><ol><li>    ,  log(p(a|x)) ( ).     hidden state  . </li><li>      ,  hidden state      log(p(a|x)).   H_new. </li><li>   :           p(x).    ,    : -,        KL(H, H_new),  -,  .. post-norm fusion ( <a href="https://arxiv.org/pdf/1809.00125.pdf">https://arxiv.org/pdf/1809.00125.pdf</a> ),   p(x)   non conditional LM  ,     . </li><li>      . </li></ol><br><p>           ,  p(a|x). </p><br><p> <strong></strong> <br>       ,   -            topic relevance.    :  (GPT2) &lt;  +    &lt;&lt;       &lt;    + . </p><br><img src="https://habrastorage.org/webt/jx/zm/ye/jxzmyeaubsu6wtcp2np1zda32tk.png" width="500" height="250"><br><p><br></p><br><h3 id="8-deep-salience-representation-for-f0-estimation-in-polyphonic-music"> 8. Deep Salience Representation for F0 Estimation in Polyphonic Music </h3><br><p>  : Rachel M. Bittner, Brian McFee, Justin Salamon, Peter Li, Juan Pablo Bello ( New York University, USA, 2017) <br> <a href="https://bmcfee.github.io/papers/ismir2017_salience.pdf">‚Üí  </a> <br>  :   (  nglaz) </p><br><p>    .  ,                .        ,     ‚Äì    .       ,   -   .   constant-Q ,          (      )          . </p><br><img src="https://habrastorage.org/webt/7l/6y/c0/7l6yc0irzsti2kbks7avmvrb7w4.png" width="500" height="250"><br><p>     .  constant-Q     -   f_min  -    F.    f_min   f_min * h,      ,    ,     .    h   {0.5, 1, 2, 3, 4, 5},        .   ,          3- ,        2-  3-    (, ,  ). ,    ,     ,    ,   (0.5f, f, 2f, 3f, 4f, 5f),    .     ( 55)      .         ,           ,  dilated-. </p><br><p>  , ,     constant-Q       F,           . </p><br><p>    F0 estimation,    ,          .  2017 ,   ,   state-of-the-art.           ,      . </p><br><h3 id="9-analyzing-and-improving-the-image-quality-of-stylegan"> 9. Analyzing and Improving the Image Quality of StyleGAN </h3><br><p>  : Tero Karras, Samuli Laine, Miika Aittala, Janne Hellsten, Jaakko Lehtinen, Timo Aila (NVIDIA, 2019) <br> <a href="http://arxiv.org/abs/1912.04958">‚Üí  </a> <br>  :   (  shiron8bit) </p><br><p> GAN-      ,     ,         .     ,   ,      ,   ,    ( FID)   : </p><br><ul><li>   droplet-like  (    / ),  AdaIN. </li><li>   ,   ProGAN-    /       end-to-end     MSG-GAN.     ,        /,            . </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menambahkan Regulasi Panjang Jalur. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mereka menyarankan prosedur untuk mendeteksi gambar yang dihasilkan: kami menemukan proyeksi gambar ke ruang laten W, jika gambar yang direkonstruksi dekat dengan aslinya, maka kemungkinan besar dihasilkan melalui stylegan2. </font></font></li>
</ul><br><img src="https://habrastorage.org/webt/f6/v3/7p/f6v37pcy3wcpw0epu5rz1-r24qk.png" width="500" height="250"><br><p><br></p><br><p>  <strong>Artefak Tetesan dan AdaIN</strong> <br>  Para penulis artikel memberikan argumen berikut untuk tidak menggunakan lapisan AdaIN: adain menormalkan setiap peta fitur, sehingga menghancurkan informasi tentang nilai besarnya relatif satu sama lain, dan tetesan adalah upaya oleh generator untuk mendorong informasi ini dengan cara yang berbeda.  Sebagai pilihan untuk melemahkan AdaIN, berikut ini diusulkan: kami akan melakukan semua penskalaan (modulasi / demodulasi) langsung dalam konvolusi, berdasarkan gaya yang berasal dari blok A, dan offset dari sinyal keluar (bukan mu (y) / y_ {b, i} di AdaIN) biarkan blok B mengubah kebisingan.  Inovasi ini pada saat yang sama memungkinkan untuk mempercepat pelatihan di bawah kondisi yang sama. </p><br><p>  <strong>Kegagalan dari ProGAN</strong> <br>  Dalam artikel tentang MSG-GAN, diusulkan untuk menggunakan koneksi lewati, menghubungkan blok generator yang cocok dan blok diskriminator dengan resolusi.  Penulis Stylegan mengembangkan ide ini dengan merangkum output dari blok generator dari semua resolusi (dengan upsampling) dan mengumpankan versi gambar downsampled yang sesuai ke input masing-masing blok diskriminator.  Disarankan bahwa blok residu digunakan sebagai opsi kedua, sementara lewati koneksi di generator dan blok residual di diskriminator menunjukkan hasil terbaik (diskriminator mirip dengan LAPGAN, tetapi tanpa diskriminator untuk setiap resolusi, peta fitur diteruskan lebih lanjut). seperti dalam kasus ProGAN, dalam iterasi awal, bagian-bagian grid yang bertanggung jawab untuk resolusi yang lebih rendah dan gambaran keseluruhan memberikan kontribusi yang lebih besar, dan kemudian penekanannya ditransfer ke detail kecil. </p><br><p>  <strong>Pengaturan panjang jalur</strong> <br>  Memperhatikan bahwa nilai FID rendah tidak selalu memberikan gambar berkualitas tinggi, dan juga mencatat korelasi antara kualitas gambar dan metrik PPL (Perceptual Path Length - awalnya perbedaan antara fitur vgg-gambar dengan langkah-langkah kecil dalam Z, tetapi perbedaannya diganti dengan LPIPS), para penulis mengusulkan Path Regulator panjang, yaitu untuk meminimalkan fungsionalitas </p><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><msubsup><mi>J</mi><mi>w</mi><mi>T</mi></msubsup><mi>y</mi><mo>=</mo><mtext>&amp;#xA0;</mtext><mi>n</mi><mi>a</mi><mi>b</mi><mi>l</mi><msub><mi>a</mi><mi>w</mi></msub><mo stretchy=&quot;false&quot;>(</mo><mi>g</mi><mo stretchy=&quot;false&quot;>(</mo><mi>w</mi><mo stretchy=&quot;false&quot;>)</mo><mi>y</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="22.258ex" height="2.78ex" viewBox="0 -883.9 9583.3 1197.1" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/ods/blog/485122/&amp;xid=17259,15700021,15700186,15700190,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhh33dV6woJSrpkitXpHztLONrATww#MJMATHI-4A" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/ods/blog/485122/&amp;xid=17259,15700021,15700186,15700190,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhh33dV6woJSrpkitXpHztLONrATww#MJMATHI-54" x="929" y="488"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/ods/blog/485122/&amp;xid=17259,15700021,15700186,15700190,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhh33dV6woJSrpkitXpHztLONrATww#MJMATHI-77" x="785" y="-212"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/ods/blog/485122/&amp;xid=17259,15700021,15700186,15700190,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhh33dV6woJSrpkitXpHztLONrATww#MJMATHI-79" x="1255" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/ods/blog/485122/&amp;xid=17259,15700021,15700186,15700190,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhh33dV6woJSrpkitXpHztLONrATww#MJMAIN-3D" x="2030" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/ods/blog/485122/&amp;xid=17259,15700021,15700186,15700190,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhh33dV6woJSrpkitXpHztLONrATww#MJMATHI-6E" x="3336" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/ods/blog/485122/&amp;xid=17259,15700021,15700186,15700190,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhh33dV6woJSrpkitXpHztLONrATww#MJMATHI-61" x="3937" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/ods/blog/485122/&amp;xid=17259,15700021,15700186,15700190,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhh33dV6woJSrpkitXpHztLONrATww#MJMATHI-62" x="4466" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/ods/blog/485122/&amp;xid=17259,15700021,15700186,15700190,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhh33dV6woJSrpkitXpHztLONrATww#MJMATHI-6C" x="4896" y="0"></use><g transform="translate(5194,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/ods/blog/485122/&amp;xid=17259,15700021,15700186,15700190,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhh33dV6woJSrpkitXpHztLONrATww#MJMATHI-61" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/ods/blog/485122/&amp;xid=17259,15700021,15700186,15700190,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhh33dV6woJSrpkitXpHztLONrATww#MJMATHI-77" x="748" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/ods/blog/485122/&amp;xid=17259,15700021,15700186,15700190,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhh33dV6woJSrpkitXpHztLONrATww#MJMAIN-28" x="6330" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/ods/blog/485122/&amp;xid=17259,15700021,15700186,15700190,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhh33dV6woJSrpkitXpHztLONrATww#MJMATHI-67" x="6720" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/ods/blog/485122/&amp;xid=17259,15700021,15700186,15700190,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhh33dV6woJSrpkitXpHztLONrATww#MJMAIN-28" x="7200" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/ods/blog/485122/&amp;xid=17259,15700021,15700186,15700190,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhh33dV6woJSrpkitXpHztLONrATww#MJMATHI-77" x="7590" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/ods/blog/485122/&amp;xid=17259,15700021,15700186,15700190,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhh33dV6woJSrpkitXpHztLONrATww#MJMAIN-29" x="8306" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/ods/blog/485122/&amp;xid=17259,15700021,15700186,15700190,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhh33dV6woJSrpkitXpHztLONrATww#MJMATHI-79" x="8696" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/ods/blog/485122/&amp;xid=17259,15700021,15700186,15700190,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhh33dV6woJSrpkitXpHztLONrATww#MJMAIN-29" x="9193" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msubsup><mi>J</mi><mi>w</mi><mi>T</mi></msubsup><mi>y</mi><mo>=</mo><mtext>&nbsp;</mtext><mi>n</mi><mi>a</mi><mi>b</mi><mi>l</mi><msub><mi>a</mi><mi>w</mi></msub><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo><mi>y</mi><mo stretchy="false">)</mo></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> J ^ T_w y = \ nabla_w (g (w) y) </script></p><br>  di mana g adalah generator itu sendiri, J_w adalah Jacobian dalam variabel ruang laten.  Pada saat yang sama, perhitungan Jacobian dapat dilakukan melalui backprop, dan juga dikatakan bahwa untuk memfasilitasi perhitungan, regulator hanya dapat dihitung untuk setiap 16 batch.  Angka a dihitung sebagai rata-rata bergerak eksponensial dari norma Jacobian.Penggunaan Regulasi Panjang Jalur memungkinkan untuk interpolasi yang lebih halus dari ruang tersembunyi W, yang, selain meningkatkan kualitas gambar, dapat meningkatkan reversibilitas (yaitu, menemukan w yang memberikan gambar tertentu setelah dijalankan melalui generator), dan juga membuka perspektif dalam hal animasi dan interpolasi antara bingkai kunci (dalam arsitektur baru, antara proyeksi gambar yang sama, harus ada titik yang bertanggung jawab untuk gambar dekat  I).  Pengenalan regularisasi ini juga memainkan peran dalam menyederhanakan deteksi gambar yang dihasilkan oleh arsitektur ini. <br><p>  Waktu pelatihan untuk 8 GPU pada resolusi 1024 * 1024 adalah dari 2 hingga 9 hari untuk konfigurasi yang berbeda. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id485122/">https://habr.com/ru/post/id485122/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id485102/index.html">Topleaked: alat untuk menangkap kebocoran memori</a></li>
<li><a href="../id485104/index.html">Membuat kunci RFID universal untuk interkom</a></li>
<li><a href="../id485108/index.html">Statistik spesialis PMI bersertifikat di Rusia pada 01/10/2020</a></li>
<li><a href="../id485110/index.html">Pengalaman saya tentang pekerjaan jarak jauh yang efektif</a></li>
<li><a href="../id485118/index.html">Clean Code oleh Robert Martin. Abstrak. Bagaimana cara menulis kode yang jelas dan indah?</a></li>
<li><a href="../id485124/index.html">Tes murni dalam PHP dan PHPUnit</a></li>
<li><a href="../id485126/index.html">Mu-mu, pakan-pakan, dukun: evolusi komunikasi akustik</a></li>
<li><a href="../id485128/index.html">Menghemat lisensi Mikrotik CHR</a></li>
<li><a href="../id485132/index.html">Bergabung dengan Google Play Indie Games Festival</a></li>
<li><a href="../id485136/index.html">Pelacakan dan Pemantauan Istio: Layanan Mikro dan Prinsip Ketidakpastian</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>