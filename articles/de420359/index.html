<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥓 ⏫ 🐱 Var, let oder const? Variable Scope Issues und ES6 🎍 👈🏾 🈂️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bereiche in JavaScript waren schon immer ein heikles Thema, insbesondere im Vergleich zu streng organisierten Sprachen wie C und Java. Viele Jahre lan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Var, let oder const? Variable Scope Issues und ES6</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/420359/"> Bereiche in JavaScript waren schon immer ein heikles Thema, insbesondere im Vergleich zu streng organisierten Sprachen wie C und Java.  Viele Jahre lang wurde der Anwendungsbereich von JS nicht besonders ausführlich diskutiert, da die Sprache einfach keine Mittel hatte, die die aktuelle Situation wesentlich beeinflussen würden.  In ECMAScript 6 gibt es jedoch einige neue Funktionen, mit denen Entwickler den Umfang von Variablen besser steuern können.  Diese Funktionen werden jetzt von Browsern sehr gut unterstützt und sind für die meisten Entwickler gut zugänglich.  Neue Schlüsselwörter zum Deklarieren von Variablen unter Berücksichtigung der Tatsache, dass das alte Schlüsselwort <code>var</code> nicht verschwunden ist, bedeuten jedoch nicht nur neue Möglichkeiten, sondern auch das Auftreten neuer Fragen.  Wann sollten die Schlüsselwörter <code>let</code> und <code>const</code> ?  Wie verhalten sie sich?  In welchen Situationen ist das Schlüsselwort <code>var</code> noch relevant?  Das Material, dessen Übersetzung wir heute veröffentlichen, zielt darauf ab, das Problem des Umfangs von Variablen in JavaScript zu untersuchen. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/v4/6q/as/v46qas_2e_rx9sypmgyz4trnhr0.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Variable Bereiche: Ein Überblick</font> </h2><br>  Der Umfang einer Variablen ist ein wichtiges Konzept in der Programmierung, das jedoch einige Entwickler, insbesondere Anfänger, verwirren kann.  Der Bereich einer Variablen ist der Teil des Programms, in dem auf diese Variable zugegriffen werden kann. <br><br>  Schauen Sie sich das folgende Beispiel an: <br><br><pre> <code class="hljs matlab">var myVar = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setMyVar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myVar</span></span></span><span class="hljs-function"> = 2; } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setMyVar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(myVar)</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>  Was wird die <code>console.log</code> Methode ausgeben?  Die Antwort auf diese Frage wird niemanden überraschen: Sie wird <code>2</code> ausgeben.  Die Variable <code>myVar</code> außerhalb einer Funktion deklariert, die uns mitteilt, dass sie im globalen Bereich deklariert ist.  Daher kann jede im selben Bereich deklarierte Funktion auf <code>myVar</code> zugreifen.  Wenn es um Code geht, der in einem Browser ausgeführt wird, haben sogar Funktionen, die in anderen mit der Seite verbundenen Dateien deklariert sind, Zugriff auf diese Variable. <br><br>  Schauen Sie sich nun den folgenden Code an: <br><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setMyVar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">var</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myVar</span></span></span><span class="hljs-function"> = 2; } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setMyVar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(myVar)</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>  Äußerlich sind seine Änderungen im Vergleich zum vorherigen Beispiel unbedeutend.  Wir haben nämlich nur die Variablendeklaration in die Funktion eingefügt.  Was wird <code>console.log</code> jetzt ausgeben?  In der Tat nichts, da diese Variable nicht deklariert ist und wenn Sie versuchen, darauf zuzugreifen, wird eine Meldung über einen nicht behandelten <code>ReferenceError</code> Fehler angezeigt.  Dies geschah, weil die Variable innerhalb der Funktion mit dem Schlüsselwort <code>var</code> deklariert wurde.  Infolgedessen ist der Bereich dieser Variablen auf den inneren Bereich der Funktion beschränkt.  Im Hauptteil dieser Funktion kann darauf zugegriffen werden. Funktionen, die in diese Funktion eingebettet sind, können damit arbeiten, sind jedoch von außen nicht zugänglich.  Wenn wir mehrere Funktionen auf derselben Ebene benötigen, um eine bestimmte Variable zu verwenden, müssen wir diese Variable an derselben Stelle deklarieren, an der diese Funktionen deklariert sind, dh eine Ebene höher als ihr interner Bereich. <br><br>  Hier ist eine interessante Beobachtung: Der Code der meisten Websites und Webanwendungen gilt nicht für die Arbeit eines Programmierers.  Die meisten Softwareprojekte sind das Ergebnis der Teamentwicklung und verwenden außerdem Bibliotheken und Frameworks von Drittanbietern.  Selbst wenn nur ein Programmierer an der Entwicklung einer Website beteiligt ist, verwendet er normalerweise externe Ressourcen.  Aus diesem Grund wird normalerweise nicht empfohlen, Variablen im globalen Bereich zu deklarieren, da Sie nicht im Voraus wissen können, welche Variablen von anderen Entwicklern deklariert werden, deren Code im Projekt verwendet wird.  Um dieses Problem zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">umgehen</a> , können Sie einige Tricks anwenden, insbesondere das " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Modul</a> " -Muster und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IIFE,</a> wenn Sie den objektorientierten Ansatz auf die JavaScript-Entwicklung anwenden, obwohl die Kapselung von Daten und Funktionen in gewöhnlichen Objekten den gleichen Effekt erzielen kann.  Im Allgemeinen kann festgestellt werden, dass Variablen, deren Umfang über das hinausgeht, was sie benötigen, normalerweise ein Problem darstellen, mit dem etwas getan werden muss. <br><br><h2>  <font color="#3AC1EF">Var-Schlüsselwortproblem</font> </h2><br>  Also haben wir das Konzept des "Umfangs" herausgefunden.  Kommen wir nun zu komplexeren Dingen.  Sehen Sie sich den folgenden Code an: <br><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">varTest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(var i = 0; i &lt; 3; i++)</span></span></span><span class="hljs-function"> {   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span><span class="hljs-function">; } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span><span class="hljs-function">; } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">varTest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>  Was wird nach der Ausführung an die Konsole gelangen?  Es ist klar, dass die Werte des ansteigenden Zählers <code>i</code> : <code>0</code> , <code>1</code> und <code>2</code> innerhalb der Schleife angezeigt werden.  Nach dem Ende der Schleife läuft das Programm weiter.  Jetzt versuchen wir, auf dieselbe Zählervariable zuzugreifen, die in der <code>for</code> Schleife außerhalb dieser Schleife deklariert wurde.  Was wird daraus? <br><br>  Nach dem Aufruf von <code>i</code> außerhalb der Schleife gelangt 3 in die Konsole, da das Schlüsselwort <code>var</code> auf Funktionsebene wirkt.  Wenn Sie eine Variable mit <code>var</code> deklarieren, können Sie in einer Funktion darauf zugreifen, auch nachdem Sie die Konstruktion verlassen haben, in der sie deklariert wurde. <br><br>  Dies kann zu einem Problem werden, wenn Funktionen komplexer werden.  Betrachten Sie das folgende Beispiel: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myVar = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) {   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myVar = <span class="hljs-number"><span class="hljs-number">2</span></span>;   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myVar); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myVar); } doSomething();</code> </pre> <br>  Was wird jetzt zur Konsole gelangen?  <code>2</code> und <code>2</code> .  Wir deklarieren eine Variable, initialisieren sie mit der Nummer 1 und versuchen dann, dieselbe Variable in der <code>if</code> neu zu definieren.  Da diese beiden Deklarationen im selben Bereich existieren, können wir keine neue Variable mit demselben Namen deklarieren, obwohl wir offensichtlich genau das tun möchten.  Infolgedessen wird die erste Variable in der <code>if</code> überschrieben. <br><br>  Dies ist genau der größte Fehler des Schlüsselworts <code>var</code> .  Der Umfang der damit deklarierten Variablen ist zu groß.  Dies kann zu versehentlichem Überschreiben von Daten und anderen Fehlern führen.  Große Sichtbereiche führen häufig zu ungenauen Programmen.  Im Allgemeinen sollte eine Variable einen Umfang haben, der durch ihre Bedürfnisse begrenzt ist, diese jedoch nicht überschreitet.  Es wäre schön, Variablen deklarieren zu können, deren Umfang nicht so groß ist wie bei Verwendung von <code>var</code> , was es bei Bedarf ermöglichen würde, stabilere und fehlerfreiere Softwarekonstrukte zu verwenden.  Tatsächlich bietet uns ECMAScript 6 solche Möglichkeiten. <br><br><h2>  <font color="#3AC1EF">Neue Möglichkeiten zum Deklarieren von Variablen</font> </h2><br>  Der ECMAScript 6-Standard (ein neuer Satz von JavaScript-Funktionen, auch bekannt als ES6 und ES2015) bietet zwei neue Möglichkeiten, Variablen zu deklarieren, die sich im Vergleich zu <code>var</code> im Umfang unterscheiden und über einige weitere Funktionen verfügen.  Dies sind die Schlüsselwörter <code>let</code> und <code>const</code> .  Beide geben uns den sogenannten Blockumfang.  Dies bedeutet, dass der Umfang ihrer Verwendung auf einen Codeblock beschränkt werden kann, z. B. eine <code>for</code> Schleife oder eine <code>if</code> .  Dies gibt dem Entwickler mehr Flexibilität bei der Auswahl des Variablenbereichs.  Betrachten Sie die neuen Schlüsselwörter. <br><br><h3>  <font color="#3AC1EF">▍Verwendung des Schlüsselworts let</font> </h3><br>  Das Schlüsselwort <code>let</code> ist <code>var</code> sehr ähnlich, der Hauptunterschied ist der begrenzte Umfang der damit deklarierten Variablen.  Wir schreiben eines der obigen Beispiele neu und ersetzen <code>var</code> durch <code>let</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myVar = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) {   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myVar = <span class="hljs-number"><span class="hljs-number">2</span></span>;   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myVar); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myVar); } doSomething();</code> </pre> <br>  In diesem Fall gelangen die Nummern <code>2</code> und <code>1</code> zur Konsole.  Dies liegt daran, dass die <code>if</code> einen neuen Bereich für die mit dem Schlüsselwort <code>let</code> deklarierte Variable festlegt.  Dies führt dazu, dass die zweite deklarierte Variable eine völlig unabhängige Entität ist, die nicht mit der ersten verwandt ist.  Sie können unabhängig voneinander mit ihnen arbeiten.  Dies bedeutet jedoch nicht, dass verschachtelte Codeblöcke wie unsere <code>if</code> vollständig von Variablen abgeschnitten sind, die mit dem Schlüsselwort <code>let</code> in dem Bereich deklariert wurden, in dem sie sich befinden.  Sehen Sie sich den folgenden Code an: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myVar = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myVar); } } doSomething();</code> </pre> <br>  In diesem Beispiel erhält die Konsole die Nummer <code>1</code> .  Der Code in der <code>if</code> hat Zugriff auf die Variable, die wir außerhalb erstellt haben.  Daher wird der Wert in der Konsole angezeigt.  Und was passiert, wenn Sie versuchen, den Bereich zu mischen?  Gehen Sie zum Beispiel folgendermaßen vor: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myVar = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myVar);   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myVar = <span class="hljs-number"><span class="hljs-number">2</span></span>;   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myVar); } } doSomething();</code> </pre> <br>  Es scheint, dass der erste Aufruf von <code>console.log</code> <code>1</code> ausgibt. Wenn Sie jedoch versuchen, diesen Code auszuführen, wird ein <code>ReferenceError</code> Fehler <code>myVar</code> , der besagt, dass die Variable <code>myVar</code> für diesen Bereich nicht definiert oder nicht initialisiert ist (der Text dieses Fehlers unterscheidet sich unterschiedlich Browser).  In JavaScript gibt es so etwas wie das Anheben von Variablen an die Spitze ihres Bereichs.  Das heißt, wenn eine Variable in einem bestimmten Bereich deklariert wird, reserviert JavaScript einen Platz dafür, noch bevor der Befehl zum Deklarieren ausgeführt wird.  Wie genau dies geschieht, ist bei Verwendung von <code>var</code> und <code>let</code> . <br><br>  Betrachten Sie das folgende Beispiel: <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(varTest); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> varTest = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(letTest); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> letTest = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br>  In beiden Fällen versuchen wir, die Variable zu verwenden, bevor wir sie deklarieren.  Konsolenausgabebefehle verhalten sich jedoch anders.  Die erste, die eine Variable verwendet, die später mit dem Schlüsselwort <code>var</code> deklariert wird, gibt <code>undefined</code> - das heißt, was in diese Variable geschrieben wird.  Der zweite Befehl, der versucht, auf die Variable zuzugreifen, die später mit dem Schlüsselwort <code>let</code> deklariert wird, löst einen <code>ReferenceError</code> und teilt uns mit, dass wir versuchen, die Variable zu verwenden, bevor sie deklariert oder initialisiert wird.  Was ist los? <br><br>  Tatsache ist jedoch, dass die für seine Ausführung verantwortlichen Mechanismen vor der Ausführung des Codes diesen Code untersuchen, herausfinden, ob darin Variablen deklariert werden, und sie in diesem Fall unter Vorbehalt von Speicherplatz für sie auslösen.  In diesem Fall werden Variablen, die mit dem Schlüsselwort <code>var</code> deklariert wurden, innerhalb ihres Gültigkeitsbereichs auf <code>undefined</code> initialisiert, selbst wenn auf sie zugegriffen wird, bevor sie deklariert werden.  Das Hauptproblem hierbei ist, dass der <code>undefined</code> Wert in einer Variablen nicht immer anzeigt, dass sie versuchen, die Variable vor ihrer Deklaration zu verwenden.  Schauen Sie sich das folgende Beispiel an: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> var1; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(var1); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(var2); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> var2 = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  In diesem Fall <code>var2</code> beide Aufrufe von <code>console.log</code> <code>undefined</code> ausgegeben, obwohl <code>var1</code> und <code>var2</code> unterschiedlich <code>var2</code> .  Der Punkt hier ist, dass in Variablen, die mit <code>var</code> deklariert, aber nicht initialisiert wurden, der <code>undefined</code> Wert automatisch geschrieben wird.  Gleichzeitig enthalten, wie bereits erwähnt, mit <code>var</code> deklarierte Variablen, auf die zugegriffen wird, bevor sie deklariert werden, auch <code>undefined</code> .  Wenn in einem solchen Code etwas schief geht, ist es daher nicht möglich zu verstehen, was genau die Fehlerquelle ist - unter Verwendung einer nicht initialisierten Variablen oder unter Verwendung einer Variablen vor ihrer Deklaration. <br><br>  Der Platz für Variablen, die mit dem Schlüsselwort <code>let</code> deklariert wurden, ist in ihrem Block reserviert, aber bevor sie deklariert werden, fallen sie in die temporäre Totzone (TDZ, Temporal Dead Zone).  Dies führt dazu, dass sie nicht verwendet werden können, bevor sie deklariert wurden, und ein Versuch, auf eine solche Variable zuzugreifen, führt zu einem Fehler.  Das System kennt jedoch die Ursache des Problems genau und meldet sie.  Dies ist in diesem Beispiel deutlich zu sehen: <br><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> var1; console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(var1); console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(var2); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> var2 = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  Hier wird beim ersten Aufruf von <code>console.log</code> <code>undefined</code> ausgegeben, und beim zweiten Aufruf wird ein <code>ReferenceError</code> Fehler ausgegeben, der uns mitteilt, dass die Variable noch nicht deklariert oder initialisiert wurde. <br><br>  Wenn daher die Verwendung von <code>var</code> <code>undefined</code> erscheint, kennen wir den Grund für dieses Verhalten des Programms nicht.  Eine Variable kann entweder deklariert und nicht initialisiert werden oder sie ist möglicherweise noch nicht in diesem Bereich deklariert, sie wird jedoch im Code unter dem Befehl deklariert, um darauf zuzugreifen.  Mit dem Schlüsselwort <code>let</code> können wir verstehen, was genau passiert, was für das Debuggen viel nützlicher ist. <br><br><h3>  <font color="#3AC1EF">▍Verwendung des Schlüsselworts const</font> </h3><br>  Das <code>const</code> Schlüsselwort ist <code>let</code> sehr ähnlich, aber sie haben einen wichtigen Unterschied.  Dieses Schlüsselwort wird verwendet, um Konstanten zu deklarieren.  Die Werte der Konstanten können nach ihrer Initialisierung nicht mehr geändert werden.  Es ist zu beachten, dass dies nur für Werte primitiver Typen, Wasser, Zeichenfolgen oder Zahlen gilt.  Wenn die Konstante etwas Komplexeres ist, z. B. ein Objekt oder ein Array, kann die interne Struktur einer solchen Entität geändert werden. Sie können sie nicht einfach durch eine andere ersetzen.  Sehen Sie sich den folgenden Code an: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">let</span></span> mutableVar = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">const</span></span> immutableVar = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">mutableVar</span></span> = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">immutableVar</span></span> = <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre> <br>  Dieser Code wird bis zur letzten Zeile ausgeführt.  Der Versuch, einer Konstanten einen neuen Wert zuzuweisen, führt zu einem <code>TypeError</code> Fehler.  So verhalten sich Konstanten, aber wie bereits erwähnt, können die Objekte, die Konstanten initialisieren, geändert werden, sie können Mutationen unterliegen, was zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Überraschungen</a> führen kann. <br><br>  Vielleicht fragen Sie sich als JavaScript-Entwickler, warum die Immunität von Variablen wichtig ist.  Konstanten sind ein neues Phänomen in JavaScript, während sie ein wesentlicher Bestandteil von Sprachen wie C oder Java sind.  Warum ist dieses Konzept so beliebt?  Tatsache ist, dass wir durch die Verwendung von Konstanten darüber nachdenken, wie unser Code funktioniert.  In einigen Situationen kann das Ändern des Werts einer Variablen den Code stören, z. B. wenn die Nummer Pi darin geschrieben ist und ständig darauf zugegriffen wird oder wenn die Variable einen Link zu einem HTML-Element enthält, mit dem Sie ständig arbeiten müssen.  Angenommen, hier ist eine Konstante, in die ein Link zu einer bestimmten Schaltfläche geschrieben ist: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myButton = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'#my-button'</span></span>);</code> </pre> <br>  Wenn der Code vom Link zum HTML-Element abhängt, müssen wir die Unveränderlichkeit dieses Links sicherstellen.  Infolgedessen können wir sagen, dass das Schlüsselwort <code>const</code> nicht nur den Weg der Verbesserungen im Bereich der Sichtbarkeit einschlägt, sondern auch die Möglichkeit einschränkt, die Werte von Konstanten zu ändern, die mit diesem Schlüsselwort deklariert wurden.  Denken Sie daran, wie wir gesagt haben, dass eine Variable genau den Umfang haben sollte, den sie benötigt.  Diese Idee kann fortgesetzt werden, indem eine Empfehlung abgegeben wird, wonach eine Variable nur die Fähigkeit haben sollte, sich zu ändern, was für eine ordnungsgemäße Arbeit damit erforderlich ist, und nicht mehr.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier ist</a> gutes Material zum Thema Immunität, aus dem eine wichtige Schlussfolgerung gezogen werden kann, wonach die Verwendung unveränderlicher Variablen uns dazu bringt, genauer über unseren Code nachzudenken, was zu einer Verbesserung der Reinheit des Codes und zu einer Verringerung der Anzahl unangenehmer Überraschungen führt, die sich aus seiner Funktionsweise ergeben. <br><br>  Als ich anfing, die Schlüsselwörter <code>let</code> und <code>const</code> , habe ich im Grunde genommen <code>let</code> und nur dann auf <code>const</code> , wenn ein neuer Wert in eine mit <code>let</code> deklarierte Variable geschrieben wurde <code>let</code> die dem Programm schaden könnte.  Aber als ich mehr über das Programmieren lernte, überlegte ich es mir anders.  Jetzt ist mein Hauptwerkzeug <code>const</code> und ich kann es nur verwenden, wenn der Wert der Variablen neu geschrieben werden muss.  Dies lässt mich darüber nachdenken, ob es wirklich notwendig ist, den Wert einer bestimmten Variablen zu ändern.  In den meisten Fällen ist dies nicht erforderlich. <br><br><h2>  <font color="#3AC1EF">Benötigen wir das Schlüsselwort var?</font> </h2><br>  Die Schlüsselwörter <code>let</code> und <code>const</code> tragen zu einem verantwortungsbewussteren Programmieransatz bei.  Gibt es Situationen, in denen das Schlüsselwort <code>var</code> noch benötigt wird?  Ja gibt es.  Es gibt verschiedene Situationen, in denen dieses Schlüsselwort für uns immer noch nützlich ist.  Überlegen Sie genau, worüber wir sprechen, bevor Sie <code>var</code> in <code>let</code> oder <code>const</code> ändern. <br><br><h3>  <font color="#3AC1EF">▍ Unterstützungsstufe für verschiedene Schlüsselwörter durch Browser</font> </h3><br>  Mit dem Schlüsselwort <code>var</code> deklarierte Variablen haben eine sehr wichtige Funktion, die <code>let</code> und <code>const</code> fehlt.  Wir sprechen nämlich von der Tatsache, dass absolut alle Browser dieses Schlüsselwort unterstützen.  Obwohl die Unterstützung für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">let</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">const durch</a> Browser sehr gut ist, besteht das Risiko, dass Ihr Programm in einem Browser landet, der sie nicht unterstützt.  Um die Konsequenzen eines solchen Vorfalls zu verstehen, müssen Sie überlegen, wie Browser mit nicht unterstütztem JavaScript-Code umgehen und nicht wie sie beispielsweise auf CSS-Code reagieren, den sie nicht verstehen. <br><br>  Wenn der Browser einige CSS-Funktionen nicht unterstützt, führt dies im Grunde zu einer gewissen Verzerrung der Anzeige auf dem Bildschirm.  Eine Site in einem Browser, die keinen der von der Site verwendeten Stile unterstützt, sieht nicht wie erwartet aus, kann aber sehr wahrscheinlich verwendet werden.  Wenn Sie beispielsweise <code>let</code> und der Browser dieses Schlüsselwort nicht unterstützt, funktioniert Ihr JS-Code dort einfach nicht.  Es wird nicht sein - das ist alles.  Angesichts der Tatsache, dass JavaScript eine der wichtigsten Komponenten des modernen Webs ist, kann dies zu einem ernsthaften Problem werden, wenn Ihre Programme in veralteten Browsern funktionieren müssen. <br><br>  Wenn Leute über die Browserunterstützung für Websites sprechen, fragen sie normalerweise, in welchem ​​Browser die Website optimal funktioniert.  Wenn es sich um eine Site handelt, deren Funktionalität auf der Verwendung von <code>let</code> und <code>const</code> basiert, muss eine ähnliche Frage anders gestellt werden: „In welchen Browsern funktioniert unsere Site nicht?“.  Und das ist viel ernster, als darüber zu sprechen, ob <code>display: flex</code> oder nicht.  Bei den meisten Websites ist die Anzahl der Benutzer mit veralteten Browsern nicht groß genug, um sich Sorgen zu machen.  Wenn es sich jedoch um einen Online-Shop oder um Websites handelt, deren Eigentümer Werbung kaufen, kann dies eine sehr wichtige Überlegung sein.  Bevor Sie in solchen Projekten neue Chancen nutzen, sollten Sie das Risikoniveau bewerten. <br><br>  Wenn Sie wirklich alte Browser unterstützen müssen, aber <code>let</code> , <code>const</code> und andere neue ES6-Funktionen verwenden möchten, besteht eine der Lösungen für dieses Problem darin, einen JavaScript-Transporter wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Babel zu verwenden</a> .  Transpiler bieten die Übersetzung von neuem Code in das, was alte Browser verstehen.  Mit Babel können Sie modernen Code schreiben, der die neuesten Funktionen der Sprache verwendet, und ihn dann in Code konvertieren, den ältere Browser ausführen können. <br><br>   ,   ?   ,        . ,      ,     ,     ,   .  ,   .  ,      ,      .     ES6-,     Babel,   Babel   ,      ,   .      ,      ,      .     .     ?   -  IE8     ? ,           ,  ,   ,  ,     . <br><br><h3> <font color="#3AC1EF">▍ var     </font> </h3><br>    ,     <code>var</code>  ,    .    .   : <br><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myVar = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myVar = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  ,     myVar    ! }</span></span></code> </pre> <br> ,     <code>myVar</code>    ,      ,        .  ,         .     ,    , ,    ,      .     ,        .        <code>var</code> . <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myVar = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myVar = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myVar); <span class="hljs-comment"><span class="hljs-comment">// 2 console.log(window.myVar); // 1 }</span></span></code> </pre> <br>          <code>var</code> ,       <code>window</code> .   <code>let</code>  <code>const</code>   .       ,     JS-   ,          (,  ,     )  ,     . <br><br>  ,         .       ,           .    ,  ,   ,    : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myGlobalVars = {}; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myVar = <span class="hljs-number"><span class="hljs-number">1</span></span>; myGlobalVars.myVar = myVar; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myVar = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myVar); <span class="hljs-comment"><span class="hljs-comment">// 2 console.log(myGlobalVars.myVar); // 1 }</span></span></code> </pre> <br> ,     ,     ,      , .   ,  ,      <code>var</code>  , ,     ,   ,  ,   . <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br> ,  ?   ?      : <br><br><ul><li>    IE10  -  ?              —       <code>var</code> . </li><li>         JavaScript,    ,  ,      <code>var</code> ,  <code>const</code> .  -      (,      ,        ) —  <code>let</code> . </li></ul><br>    <code>let</code>  <code>const</code> ,   ECMAScript 6,           ( )   -  -.       ,    ,       ,    . ,    - ,    «»  «»     , ,  <code>let</code>  <code>const</code> ,          . <br><br> <b> !</b>     ,       <code>const</code>       <code>var</code> ,   <code>let</code>    ,   ,   ,  ? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de420359/">https://habr.com/ru/post/de420359/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de420349/index.html">IT-Outsourcing-Checkliste: Arbeiten ohne Risiken</a></li>
<li><a href="../de420351/index.html">So führen Sie Benutzersuchen auf GitHub mit Vue durch</a></li>
<li><a href="../de420353/index.html">Wir machen Shrimp noch nützlicher: Fügen Sie Bildtranscodierungen zu anderen Formaten hinzu</a></li>
<li><a href="../de420355/index.html">Smart Watch Pebble: Wie man über Nacht zur Seltenheit wird</a></li>
<li><a href="../de420357/index.html">Vuex: Strukturierung großer Projekte und Arbeiten mit Modulen</a></li>
<li><a href="../de420361/index.html">Fehler beim Ausführen von TextBox.GetLineText in .NET WPF</a></li>
<li><a href="../de420363/index.html">HPE-Webinare von August bis Oktober: Neue Themen (+ SHD, KI-Praxis, schlüsselfertiger Petabyte-Speicher)</a></li>
<li><a href="../de420367/index.html">Klimatisierte Apokalypse: Smart-Grid-Blackout-Szenario</a></li>
<li><a href="../de420369/index.html">Extreme Extended Edge oder IEEE 802.1BR-Switching</a></li>
<li><a href="../de420371/index.html">Zum Thema Fahrradbau im Bereich der Elektropostlagerung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>