<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•ì ‚è´ üê± Var, let oder const? Variable Scope Issues und ES6 üéç üëàüèæ üàÇÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bereiche in JavaScript waren schon immer ein heikles Thema, insbesondere im Vergleich zu streng organisierten Sprachen wie C und Java. Viele Jahre lan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Var, let oder const? Variable Scope Issues und ES6</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/420359/"> Bereiche in JavaScript waren schon immer ein heikles Thema, insbesondere im Vergleich zu streng organisierten Sprachen wie C und Java.  Viele Jahre lang wurde der Anwendungsbereich von JS nicht besonders ausf√ºhrlich diskutiert, da die Sprache einfach keine Mittel hatte, die die aktuelle Situation wesentlich beeinflussen w√ºrden.  In ECMAScript 6 gibt es jedoch einige neue Funktionen, mit denen Entwickler den Umfang von Variablen besser steuern k√∂nnen.  Diese Funktionen werden jetzt von Browsern sehr gut unterst√ºtzt und sind f√ºr die meisten Entwickler gut zug√§nglich.  Neue Schl√ºsselw√∂rter zum Deklarieren von Variablen unter Ber√ºcksichtigung der Tatsache, dass das alte Schl√ºsselwort <code>var</code> nicht verschwunden ist, bedeuten jedoch nicht nur neue M√∂glichkeiten, sondern auch das Auftreten neuer Fragen.  Wann sollten die Schl√ºsselw√∂rter <code>let</code> und <code>const</code> ?  Wie verhalten sie sich?  In welchen Situationen ist das Schl√ºsselwort <code>var</code> noch relevant?  Das Material, dessen √úbersetzung wir heute ver√∂ffentlichen, zielt darauf ab, das Problem des Umfangs von Variablen in JavaScript zu untersuchen. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/v4/6q/as/v46qas_2e_rx9sypmgyz4trnhr0.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Variable Bereiche: Ein √úberblick</font> </h2><br>  Der Umfang einer Variablen ist ein wichtiges Konzept in der Programmierung, das jedoch einige Entwickler, insbesondere Anf√§nger, verwirren kann.  Der Bereich einer Variablen ist der Teil des Programms, in dem auf diese Variable zugegriffen werden kann. <br><br>  Schauen Sie sich das folgende Beispiel an: <br><br><pre> <code class="hljs matlab">var myVar = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setMyVar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myVar</span></span></span><span class="hljs-function"> = 2; } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setMyVar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(myVar)</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>  Was wird die <code>console.log</code> Methode ausgeben?  Die Antwort auf diese Frage wird niemanden √ºberraschen: Sie wird <code>2</code> ausgeben.  Die Variable <code>myVar</code> au√üerhalb einer Funktion deklariert, die uns mitteilt, dass sie im globalen Bereich deklariert ist.  Daher kann jede im selben Bereich deklarierte Funktion auf <code>myVar</code> zugreifen.  Wenn es um Code geht, der in einem Browser ausgef√ºhrt wird, haben sogar Funktionen, die in anderen mit der Seite verbundenen Dateien deklariert sind, Zugriff auf diese Variable. <br><br>  Schauen Sie sich nun den folgenden Code an: <br><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setMyVar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">var</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myVar</span></span></span><span class="hljs-function"> = 2; } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setMyVar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(myVar)</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>  √Ñu√üerlich sind seine √Ñnderungen im Vergleich zum vorherigen Beispiel unbedeutend.  Wir haben n√§mlich nur die Variablendeklaration in die Funktion eingef√ºgt.  Was wird <code>console.log</code> jetzt ausgeben?  In der Tat nichts, da diese Variable nicht deklariert ist und wenn Sie versuchen, darauf zuzugreifen, wird eine Meldung √ºber einen nicht behandelten <code>ReferenceError</code> Fehler angezeigt.  Dies geschah, weil die Variable innerhalb der Funktion mit dem Schl√ºsselwort <code>var</code> deklariert wurde.  Infolgedessen ist der Bereich dieser Variablen auf den inneren Bereich der Funktion beschr√§nkt.  Im Hauptteil dieser Funktion kann darauf zugegriffen werden. Funktionen, die in diese Funktion eingebettet sind, k√∂nnen damit arbeiten, sind jedoch von au√üen nicht zug√§nglich.  Wenn wir mehrere Funktionen auf derselben Ebene ben√∂tigen, um eine bestimmte Variable zu verwenden, m√ºssen wir diese Variable an derselben Stelle deklarieren, an der diese Funktionen deklariert sind, dh eine Ebene h√∂her als ihr interner Bereich. <br><br>  Hier ist eine interessante Beobachtung: Der Code der meisten Websites und Webanwendungen gilt nicht f√ºr die Arbeit eines Programmierers.  Die meisten Softwareprojekte sind das Ergebnis der Teamentwicklung und verwenden au√üerdem Bibliotheken und Frameworks von Drittanbietern.  Selbst wenn nur ein Programmierer an der Entwicklung einer Website beteiligt ist, verwendet er normalerweise externe Ressourcen.  Aus diesem Grund wird normalerweise nicht empfohlen, Variablen im globalen Bereich zu deklarieren, da Sie nicht im Voraus wissen k√∂nnen, welche Variablen von anderen Entwicklern deklariert werden, deren Code im Projekt verwendet wird.  Um dieses Problem zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">umgehen</a> , k√∂nnen Sie einige Tricks anwenden, insbesondere das " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Modul</a> " -Muster und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IIFE,</a> wenn Sie den objektorientierten Ansatz auf die JavaScript-Entwicklung anwenden, obwohl die Kapselung von Daten und Funktionen in gew√∂hnlichen Objekten den gleichen Effekt erzielen kann.  Im Allgemeinen kann festgestellt werden, dass Variablen, deren Umfang √ºber das hinausgeht, was sie ben√∂tigen, normalerweise ein Problem darstellen, mit dem etwas getan werden muss. <br><br><h2>  <font color="#3AC1EF">Var-Schl√ºsselwortproblem</font> </h2><br>  Also haben wir das Konzept des "Umfangs" herausgefunden.  Kommen wir nun zu komplexeren Dingen.  Sehen Sie sich den folgenden Code an: <br><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">varTest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(var i = 0; i &lt; 3; i++)</span></span></span><span class="hljs-function"> {   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span><span class="hljs-function">; } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span><span class="hljs-function">; } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">varTest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>  Was wird nach der Ausf√ºhrung an die Konsole gelangen?  Es ist klar, dass die Werte des ansteigenden Z√§hlers <code>i</code> : <code>0</code> , <code>1</code> und <code>2</code> innerhalb der Schleife angezeigt werden.  Nach dem Ende der Schleife l√§uft das Programm weiter.  Jetzt versuchen wir, auf dieselbe Z√§hlervariable zuzugreifen, die in der <code>for</code> Schleife au√üerhalb dieser Schleife deklariert wurde.  Was wird daraus? <br><br>  Nach dem Aufruf von <code>i</code> au√üerhalb der Schleife gelangt 3 in die Konsole, da das Schl√ºsselwort <code>var</code> auf Funktionsebene wirkt.  Wenn Sie eine Variable mit <code>var</code> deklarieren, k√∂nnen Sie in einer Funktion darauf zugreifen, auch nachdem Sie die Konstruktion verlassen haben, in der sie deklariert wurde. <br><br>  Dies kann zu einem Problem werden, wenn Funktionen komplexer werden.  Betrachten Sie das folgende Beispiel: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myVar = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) {   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myVar = <span class="hljs-number"><span class="hljs-number">2</span></span>;   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myVar); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myVar); } doSomething();</code> </pre> <br>  Was wird jetzt zur Konsole gelangen?  <code>2</code> und <code>2</code> .  Wir deklarieren eine Variable, initialisieren sie mit der Nummer 1 und versuchen dann, dieselbe Variable in der <code>if</code> neu zu definieren.  Da diese beiden Deklarationen im selben Bereich existieren, k√∂nnen wir keine neue Variable mit demselben Namen deklarieren, obwohl wir offensichtlich genau das tun m√∂chten.  Infolgedessen wird die erste Variable in der <code>if</code> √ºberschrieben. <br><br>  Dies ist genau der gr√∂√üte Fehler des Schl√ºsselworts <code>var</code> .  Der Umfang der damit deklarierten Variablen ist zu gro√ü.  Dies kann zu versehentlichem √úberschreiben von Daten und anderen Fehlern f√ºhren.  Gro√üe Sichtbereiche f√ºhren h√§ufig zu ungenauen Programmen.  Im Allgemeinen sollte eine Variable einen Umfang haben, der durch ihre Bed√ºrfnisse begrenzt ist, diese jedoch nicht √ºberschreitet.  Es w√§re sch√∂n, Variablen deklarieren zu k√∂nnen, deren Umfang nicht so gro√ü ist wie bei Verwendung von <code>var</code> , was es bei Bedarf erm√∂glichen w√ºrde, stabilere und fehlerfreiere Softwarekonstrukte zu verwenden.  Tats√§chlich bietet uns ECMAScript 6 solche M√∂glichkeiten. <br><br><h2>  <font color="#3AC1EF">Neue M√∂glichkeiten zum Deklarieren von Variablen</font> </h2><br>  Der ECMAScript 6-Standard (ein neuer Satz von JavaScript-Funktionen, auch bekannt als ES6 und ES2015) bietet zwei neue M√∂glichkeiten, Variablen zu deklarieren, die sich im Vergleich zu <code>var</code> im Umfang unterscheiden und √ºber einige weitere Funktionen verf√ºgen.  Dies sind die Schl√ºsselw√∂rter <code>let</code> und <code>const</code> .  Beide geben uns den sogenannten Blockumfang.  Dies bedeutet, dass der Umfang ihrer Verwendung auf einen Codeblock beschr√§nkt werden kann, z. B. eine <code>for</code> Schleife oder eine <code>if</code> .  Dies gibt dem Entwickler mehr Flexibilit√§t bei der Auswahl des Variablenbereichs.  Betrachten Sie die neuen Schl√ºsselw√∂rter. <br><br><h3>  <font color="#3AC1EF">‚ñçVerwendung des Schl√ºsselworts let</font> </h3><br>  Das Schl√ºsselwort <code>let</code> ist <code>var</code> sehr √§hnlich, der Hauptunterschied ist der begrenzte Umfang der damit deklarierten Variablen.  Wir schreiben eines der obigen Beispiele neu und ersetzen <code>var</code> durch <code>let</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myVar = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) {   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myVar = <span class="hljs-number"><span class="hljs-number">2</span></span>;   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myVar); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myVar); } doSomething();</code> </pre> <br>  In diesem Fall gelangen die Nummern <code>2</code> und <code>1</code> zur Konsole.  Dies liegt daran, dass die <code>if</code> einen neuen Bereich f√ºr die mit dem Schl√ºsselwort <code>let</code> deklarierte Variable festlegt.  Dies f√ºhrt dazu, dass die zweite deklarierte Variable eine v√∂llig unabh√§ngige Entit√§t ist, die nicht mit der ersten verwandt ist.  Sie k√∂nnen unabh√§ngig voneinander mit ihnen arbeiten.  Dies bedeutet jedoch nicht, dass verschachtelte Codebl√∂cke wie unsere <code>if</code> vollst√§ndig von Variablen abgeschnitten sind, die mit dem Schl√ºsselwort <code>let</code> in dem Bereich deklariert wurden, in dem sie sich befinden.  Sehen Sie sich den folgenden Code an: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myVar = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myVar); } } doSomething();</code> </pre> <br>  In diesem Beispiel erh√§lt die Konsole die Nummer <code>1</code> .  Der Code in der <code>if</code> hat Zugriff auf die Variable, die wir au√üerhalb erstellt haben.  Daher wird der Wert in der Konsole angezeigt.  Und was passiert, wenn Sie versuchen, den Bereich zu mischen?  Gehen Sie zum Beispiel folgenderma√üen vor: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myVar = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myVar);   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myVar = <span class="hljs-number"><span class="hljs-number">2</span></span>;   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myVar); } } doSomething();</code> </pre> <br>  Es scheint, dass der erste Aufruf von <code>console.log</code> <code>1</code> ausgibt. Wenn Sie jedoch versuchen, diesen Code auszuf√ºhren, wird ein <code>ReferenceError</code> Fehler <code>myVar</code> , der besagt, dass die Variable <code>myVar</code> f√ºr diesen Bereich nicht definiert oder nicht initialisiert ist (der Text dieses Fehlers unterscheidet sich unterschiedlich Browser).  In JavaScript gibt es so etwas wie das Anheben von Variablen an die Spitze ihres Bereichs.  Das hei√üt, wenn eine Variable in einem bestimmten Bereich deklariert wird, reserviert JavaScript einen Platz daf√ºr, noch bevor der Befehl zum Deklarieren ausgef√ºhrt wird.  Wie genau dies geschieht, ist bei Verwendung von <code>var</code> und <code>let</code> . <br><br>  Betrachten Sie das folgende Beispiel: <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(varTest); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> varTest = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(letTest); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> letTest = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br>  In beiden F√§llen versuchen wir, die Variable zu verwenden, bevor wir sie deklarieren.  Konsolenausgabebefehle verhalten sich jedoch anders.  Die erste, die eine Variable verwendet, die sp√§ter mit dem Schl√ºsselwort <code>var</code> deklariert wird, gibt <code>undefined</code> - das hei√üt, was in diese Variable geschrieben wird.  Der zweite Befehl, der versucht, auf die Variable zuzugreifen, die sp√§ter mit dem Schl√ºsselwort <code>let</code> deklariert wird, l√∂st einen <code>ReferenceError</code> und teilt uns mit, dass wir versuchen, die Variable zu verwenden, bevor sie deklariert oder initialisiert wird.  Was ist los? <br><br>  Tatsache ist jedoch, dass die f√ºr seine Ausf√ºhrung verantwortlichen Mechanismen vor der Ausf√ºhrung des Codes diesen Code untersuchen, herausfinden, ob darin Variablen deklariert werden, und sie in diesem Fall unter Vorbehalt von Speicherplatz f√ºr sie ausl√∂sen.  In diesem Fall werden Variablen, die mit dem Schl√ºsselwort <code>var</code> deklariert wurden, innerhalb ihres G√ºltigkeitsbereichs auf <code>undefined</code> initialisiert, selbst wenn auf sie zugegriffen wird, bevor sie deklariert werden.  Das Hauptproblem hierbei ist, dass der <code>undefined</code> Wert in einer Variablen nicht immer anzeigt, dass sie versuchen, die Variable vor ihrer Deklaration zu verwenden.  Schauen Sie sich das folgende Beispiel an: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> var1; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(var1); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(var2); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> var2 = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  In diesem Fall <code>var2</code> beide Aufrufe von <code>console.log</code> <code>undefined</code> ausgegeben, obwohl <code>var1</code> und <code>var2</code> unterschiedlich <code>var2</code> .  Der Punkt hier ist, dass in Variablen, die mit <code>var</code> deklariert, aber nicht initialisiert wurden, der <code>undefined</code> Wert automatisch geschrieben wird.  Gleichzeitig enthalten, wie bereits erw√§hnt, mit <code>var</code> deklarierte Variablen, auf die zugegriffen wird, bevor sie deklariert werden, auch <code>undefined</code> .  Wenn in einem solchen Code etwas schief geht, ist es daher nicht m√∂glich zu verstehen, was genau die Fehlerquelle ist - unter Verwendung einer nicht initialisierten Variablen oder unter Verwendung einer Variablen vor ihrer Deklaration. <br><br>  Der Platz f√ºr Variablen, die mit dem Schl√ºsselwort <code>let</code> deklariert wurden, ist in ihrem Block reserviert, aber bevor sie deklariert werden, fallen sie in die tempor√§re Totzone (TDZ, Temporal Dead Zone).  Dies f√ºhrt dazu, dass sie nicht verwendet werden k√∂nnen, bevor sie deklariert wurden, und ein Versuch, auf eine solche Variable zuzugreifen, f√ºhrt zu einem Fehler.  Das System kennt jedoch die Ursache des Problems genau und meldet sie.  Dies ist in diesem Beispiel deutlich zu sehen: <br><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> var1; console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(var1); console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(var2); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> var2 = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  Hier wird beim ersten Aufruf von <code>console.log</code> <code>undefined</code> ausgegeben, und beim zweiten Aufruf wird ein <code>ReferenceError</code> Fehler ausgegeben, der uns mitteilt, dass die Variable noch nicht deklariert oder initialisiert wurde. <br><br>  Wenn daher die Verwendung von <code>var</code> <code>undefined</code> erscheint, kennen wir den Grund f√ºr dieses Verhalten des Programms nicht.  Eine Variable kann entweder deklariert und nicht initialisiert werden oder sie ist m√∂glicherweise noch nicht in diesem Bereich deklariert, sie wird jedoch im Code unter dem Befehl deklariert, um darauf zuzugreifen.  Mit dem Schl√ºsselwort <code>let</code> k√∂nnen wir verstehen, was genau passiert, was f√ºr das Debuggen viel n√ºtzlicher ist. <br><br><h3>  <font color="#3AC1EF">‚ñçVerwendung des Schl√ºsselworts const</font> </h3><br>  Das <code>const</code> Schl√ºsselwort ist <code>let</code> sehr √§hnlich, aber sie haben einen wichtigen Unterschied.  Dieses Schl√ºsselwort wird verwendet, um Konstanten zu deklarieren.  Die Werte der Konstanten k√∂nnen nach ihrer Initialisierung nicht mehr ge√§ndert werden.  Es ist zu beachten, dass dies nur f√ºr Werte primitiver Typen, Wasser, Zeichenfolgen oder Zahlen gilt.  Wenn die Konstante etwas Komplexeres ist, z. B. ein Objekt oder ein Array, kann die interne Struktur einer solchen Entit√§t ge√§ndert werden. Sie k√∂nnen sie nicht einfach durch eine andere ersetzen.  Sehen Sie sich den folgenden Code an: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">let</span></span> mutableVar = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">const</span></span> immutableVar = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">mutableVar</span></span> = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">immutableVar</span></span> = <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre> <br>  Dieser Code wird bis zur letzten Zeile ausgef√ºhrt.  Der Versuch, einer Konstanten einen neuen Wert zuzuweisen, f√ºhrt zu einem <code>TypeError</code> Fehler.  So verhalten sich Konstanten, aber wie bereits erw√§hnt, k√∂nnen die Objekte, die Konstanten initialisieren, ge√§ndert werden, sie k√∂nnen Mutationen unterliegen, was zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úberraschungen</a> f√ºhren kann. <br><br>  Vielleicht fragen Sie sich als JavaScript-Entwickler, warum die Immunit√§t von Variablen wichtig ist.  Konstanten sind ein neues Ph√§nomen in JavaScript, w√§hrend sie ein wesentlicher Bestandteil von Sprachen wie C oder Java sind.  Warum ist dieses Konzept so beliebt?  Tatsache ist, dass wir durch die Verwendung von Konstanten dar√ºber nachdenken, wie unser Code funktioniert.  In einigen Situationen kann das √Ñndern des Werts einer Variablen den Code st√∂ren, z. B. wenn die Nummer Pi darin geschrieben ist und st√§ndig darauf zugegriffen wird oder wenn die Variable einen Link zu einem HTML-Element enth√§lt, mit dem Sie st√§ndig arbeiten m√ºssen.  Angenommen, hier ist eine Konstante, in die ein Link zu einer bestimmten Schaltfl√§che geschrieben ist: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myButton = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'#my-button'</span></span>);</code> </pre> <br>  Wenn der Code vom Link zum HTML-Element abh√§ngt, m√ºssen wir die Unver√§nderlichkeit dieses Links sicherstellen.  Infolgedessen k√∂nnen wir sagen, dass das Schl√ºsselwort <code>const</code> nicht nur den Weg der Verbesserungen im Bereich der Sichtbarkeit einschl√§gt, sondern auch die M√∂glichkeit einschr√§nkt, die Werte von Konstanten zu √§ndern, die mit diesem Schl√ºsselwort deklariert wurden.  Denken Sie daran, wie wir gesagt haben, dass eine Variable genau den Umfang haben sollte, den sie ben√∂tigt.  Diese Idee kann fortgesetzt werden, indem eine Empfehlung abgegeben wird, wonach eine Variable nur die F√§higkeit haben sollte, sich zu √§ndern, was f√ºr eine ordnungsgem√§√üe Arbeit damit erforderlich ist, und nicht mehr.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier ist</a> gutes Material zum Thema Immunit√§t, aus dem eine wichtige Schlussfolgerung gezogen werden kann, wonach die Verwendung unver√§nderlicher Variablen uns dazu bringt, genauer √ºber unseren Code nachzudenken, was zu einer Verbesserung der Reinheit des Codes und zu einer Verringerung der Anzahl unangenehmer √úberraschungen f√ºhrt, die sich aus seiner Funktionsweise ergeben. <br><br>  Als ich anfing, die Schl√ºsselw√∂rter <code>let</code> und <code>const</code> , habe ich im Grunde genommen <code>let</code> und nur dann auf <code>const</code> , wenn ein neuer Wert in eine mit <code>let</code> deklarierte Variable geschrieben wurde <code>let</code> die dem Programm schaden k√∂nnte.  Aber als ich mehr √ºber das Programmieren lernte, √ºberlegte ich es mir anders.  Jetzt ist mein Hauptwerkzeug <code>const</code> und ich kann es nur verwenden, wenn der Wert der Variablen neu geschrieben werden muss.  Dies l√§sst mich dar√ºber nachdenken, ob es wirklich notwendig ist, den Wert einer bestimmten Variablen zu √§ndern.  In den meisten F√§llen ist dies nicht erforderlich. <br><br><h2>  <font color="#3AC1EF">Ben√∂tigen wir das Schl√ºsselwort var?</font> </h2><br>  Die Schl√ºsselw√∂rter <code>let</code> und <code>const</code> tragen zu einem verantwortungsbewussteren Programmieransatz bei.  Gibt es Situationen, in denen das Schl√ºsselwort <code>var</code> noch ben√∂tigt wird?  Ja gibt es.  Es gibt verschiedene Situationen, in denen dieses Schl√ºsselwort f√ºr uns immer noch n√ºtzlich ist.  √úberlegen Sie genau, wor√ºber wir sprechen, bevor Sie <code>var</code> in <code>let</code> oder <code>const</code> √§ndern. <br><br><h3>  <font color="#3AC1EF">‚ñç Unterst√ºtzungsstufe f√ºr verschiedene Schl√ºsselw√∂rter durch Browser</font> </h3><br>  Mit dem Schl√ºsselwort <code>var</code> deklarierte Variablen haben eine sehr wichtige Funktion, die <code>let</code> und <code>const</code> fehlt.  Wir sprechen n√§mlich von der Tatsache, dass absolut alle Browser dieses Schl√ºsselwort unterst√ºtzen.  Obwohl die Unterst√ºtzung f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">let</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">const durch</a> Browser sehr gut ist, besteht das Risiko, dass Ihr Programm in einem Browser landet, der sie nicht unterst√ºtzt.  Um die Konsequenzen eines solchen Vorfalls zu verstehen, m√ºssen Sie √ºberlegen, wie Browser mit nicht unterst√ºtztem JavaScript-Code umgehen und nicht wie sie beispielsweise auf CSS-Code reagieren, den sie nicht verstehen. <br><br>  Wenn der Browser einige CSS-Funktionen nicht unterst√ºtzt, f√ºhrt dies im Grunde zu einer gewissen Verzerrung der Anzeige auf dem Bildschirm.  Eine Site in einem Browser, die keinen der von der Site verwendeten Stile unterst√ºtzt, sieht nicht wie erwartet aus, kann aber sehr wahrscheinlich verwendet werden.  Wenn Sie beispielsweise <code>let</code> und der Browser dieses Schl√ºsselwort nicht unterst√ºtzt, funktioniert Ihr JS-Code dort einfach nicht.  Es wird nicht sein - das ist alles.  Angesichts der Tatsache, dass JavaScript eine der wichtigsten Komponenten des modernen Webs ist, kann dies zu einem ernsthaften Problem werden, wenn Ihre Programme in veralteten Browsern funktionieren m√ºssen. <br><br>  Wenn Leute √ºber die Browserunterst√ºtzung f√ºr Websites sprechen, fragen sie normalerweise, in welchem ‚Äã‚ÄãBrowser die Website optimal funktioniert.  Wenn es sich um eine Site handelt, deren Funktionalit√§t auf der Verwendung von <code>let</code> und <code>const</code> basiert, muss eine √§hnliche Frage anders gestellt werden: ‚ÄûIn welchen Browsern funktioniert unsere Site nicht?‚Äú.  Und das ist viel ernster, als dar√ºber zu sprechen, ob <code>display: flex</code> oder nicht.  Bei den meisten Websites ist die Anzahl der Benutzer mit veralteten Browsern nicht gro√ü genug, um sich Sorgen zu machen.  Wenn es sich jedoch um einen Online-Shop oder um Websites handelt, deren Eigent√ºmer Werbung kaufen, kann dies eine sehr wichtige √úberlegung sein.  Bevor Sie in solchen Projekten neue Chancen nutzen, sollten Sie das Risikoniveau bewerten. <br><br>  Wenn Sie wirklich alte Browser unterst√ºtzen m√ºssen, aber <code>let</code> , <code>const</code> und andere neue ES6-Funktionen verwenden m√∂chten, besteht eine der L√∂sungen f√ºr dieses Problem darin, einen JavaScript-Transporter wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Babel zu verwenden</a> .  Transpiler bieten die √úbersetzung von neuem Code in das, was alte Browser verstehen.  Mit Babel k√∂nnen Sie modernen Code schreiben, der die neuesten Funktionen der Sprache verwendet, und ihn dann in Code konvertieren, den √§ltere Browser ausf√ºhren k√∂nnen. <br><br>   ,   ?   ,        . ,      ,     ,     ,   .  ,   .  ,      ,      .     ES6-,     Babel,   Babel   ,      ,   .      ,      ,      .     .     ?   -  IE8     ? ,           ,  ,   ,  ,     . <br><br><h3> <font color="#3AC1EF">‚ñç var     </font> </h3><br>    ,     <code>var</code>  ,    .    .   : <br><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myVar = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myVar = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  ,     myVar    ! }</span></span></code> </pre> <br> ,     <code>myVar</code>    ,      ,        .  ,         .     ,    , ,    ,      .     ,        .        <code>var</code> . <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myVar = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myVar = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myVar); <span class="hljs-comment"><span class="hljs-comment">// 2 console.log(window.myVar); // 1 }</span></span></code> </pre> <br>          <code>var</code> ,       <code>window</code> .   <code>let</code>  <code>const</code>   .       ,     JS-   ,          (,  ,     )  ,     . <br><br>  ,         .       ,           .    ,  ,   ,    : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myGlobalVars = {}; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myVar = <span class="hljs-number"><span class="hljs-number">1</span></span>; myGlobalVars.myVar = myVar; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myVar = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myVar); <span class="hljs-comment"><span class="hljs-comment">// 2 console.log(myGlobalVars.myVar); // 1 }</span></span></code> </pre> <br> ,     ,     ,      , .   ,  ,      <code>var</code>  , ,     ,   ,  ,   . <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br> ,  ?   ?      : <br><br><ul><li>    IE10  -  ?              ‚Äî       <code>var</code> . </li><li>         JavaScript,    ,  ,      <code>var</code> ,  <code>const</code> .  -      (,      ,        ) ‚Äî  <code>let</code> . </li></ul><br>    <code>let</code>  <code>const</code> ,   ECMAScript 6,           ( )   -  -.       ,    ,       ,    . ,    - ,    ¬´¬ª  ¬´¬ª     , ,  <code>let</code>  <code>const</code> ,          . <br><br> <b> !</b>     ,       <code>const</code>       <code>var</code> ,   <code>let</code>    ,   ,   ,  ? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de420359/">https://habr.com/ru/post/de420359/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de420349/index.html">IT-Outsourcing-Checkliste: Arbeiten ohne Risiken</a></li>
<li><a href="../de420351/index.html">So f√ºhren Sie Benutzersuchen auf GitHub mit Vue durch</a></li>
<li><a href="../de420353/index.html">Wir machen Shrimp noch n√ºtzlicher: F√ºgen Sie Bildtranscodierungen zu anderen Formaten hinzu</a></li>
<li><a href="../de420355/index.html">Smart Watch Pebble: Wie man √ºber Nacht zur Seltenheit wird</a></li>
<li><a href="../de420357/index.html">Vuex: Strukturierung gro√üer Projekte und Arbeiten mit Modulen</a></li>
<li><a href="../de420361/index.html">Fehler beim Ausf√ºhren von TextBox.GetLineText in .NET WPF</a></li>
<li><a href="../de420363/index.html">HPE-Webinare von August bis Oktober: Neue Themen (+ SHD, KI-Praxis, schl√ºsselfertiger Petabyte-Speicher)</a></li>
<li><a href="../de420367/index.html">Klimatisierte Apokalypse: Smart-Grid-Blackout-Szenario</a></li>
<li><a href="../de420369/index.html">Extreme Extended Edge oder IEEE 802.1BR-Switching</a></li>
<li><a href="../de420371/index.html">Zum Thema Fahrradbau im Bereich der Elektropostlagerung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>