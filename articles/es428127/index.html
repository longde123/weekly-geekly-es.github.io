<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèΩ‚Äçü§ù‚Äçüßëüèª üçî üòó Cach√© de Nginx: todo nuevo - bien olvidado viejo üîÇ üçò üôä</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En la vida de cada proyecto, llega el momento en que el servidor deja de cumplir con los requisitos de SLA y literalmente comienza a ahogarse en la ca...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cach√© de Nginx: todo nuevo - bien olvidado viejo</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428127/">  En la vida de cada proyecto, llega el momento en que el servidor deja de cumplir con los requisitos de SLA y literalmente comienza a ahogarse en la cantidad de tr√°fico entrante.  Despu√©s de eso, comienza el largo proceso de encontrar cuellos de botella, consultas pesadas, √≠ndices creados incorrectamente, datos no almacenados en cach√© o viceversa, datos actualizados con demasiada frecuencia en el cach√© y otros lados oscuros del proyecto. <br><br>  Pero, ¬øqu√© hacer cuando su c√≥digo es "perfecto", todas las solicitudes pesadas se colocan en segundo plano, todo lo posible fue almacenado en cach√© y el servidor a√∫n no alcanza los indicadores de SLA que necesitamos?  Si es posible, por supuesto, puede comprar autom√≥viles nuevos, distribuir parte del tr√°fico y olvidarse del problema por un tiempo. <br><br>  Pero si tiene la sensaci√≥n de que su servidor es capaz de m√°s, o si hay un par√°metro m√°gico que acelera el sitio 100 veces, puede recordar la funci√≥n nginx incorporada que le permite almacenar en cach√© las respuestas del backend.  Echemos un vistazo a lo que es y c√≥mo puede ayudar a aumentar el n√∫mero de solicitudes procesadas por el servidor. <a name="habracut"></a><br><br><h3>  ¬øQu√© es el cach√© Nginx y c√≥mo funciona? </h3><br>  El cach√© Nginx puede reducir significativamente la cantidad de solicitudes para el backend.  Esto se logra almacenando la respuesta HTTP durante un tiempo determinado y al acceder nuevamente al recurso, devolvi√©ndolo de la memoria cach√© sin enviar la solicitud del backend.  El almacenamiento en cach√©, incluso por un per√≠odo corto, dar√° un aumento significativo a la cantidad de solicitudes procesadas por el servidor. <br><br>  Antes de continuar con la configuraci√≥n de nginx, debe asegurarse de que est√© construido con el m√≥dulo "ngx_http_proxy_module", ya que lo configuraremos utilizando este m√≥dulo. <br><br>  Para mayor comodidad, puede transferir la configuraci√≥n a un archivo separado, por ejemplo, "/etc/nginx/conf.d/cache.conf".  Echemos un vistazo a la directiva proxy_cache_path, que le permite configurar los ajustes de almacenamiento en cach√©. <br><br><pre><code class="hljs swift">proxy_cache_path /<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/lib/nginx/proxy_cache levels=<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span> keys_zone=proxy_cache:15m max_size=1G;</code> </pre> <br>  "/ Var / lib / nginx / proxy_cache" especifica la ruta de almacenamiento de cach√© en el servidor.  Es en este directorio que nginx guardar√° los archivos con la respuesta del backend.  Al mismo tiempo, nginx no crear√° de forma independiente un directorio para la memoria cach√©, debe hacerse cargo de esto usted mismo. <br><br>  "Niveles = 1: 2": establece el nivel de anidamiento de directorios con un cach√©.  Los niveles de anidaci√≥n se indican mediante ":", en este caso se crear√°n 2 directorios, en total se permiten 3 niveles de anidaci√≥n.  Para cada nivel de anidaci√≥n, los valores del 1 al 2 est√°n disponibles, lo que indica c√≥mo crear el nombre del directorio. <br><br>  El punto importante es que el nombre del directorio no se elige al azar, sino que se crea en funci√≥n del nombre del archivo.  El nombre del archivo, a su vez, es el resultado de la funci√≥n md5 de la clave de cach√©; veremos la clave de cach√© un poco m√°s tarde. <br><br>  Veamos en la pr√°ctica c√≥mo se construye la ruta al archivo de cach√©: <br><br><pre> <code class="hljs swift">/<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/lib/nginx/proxy_cache/<span class="hljs-number"><span class="hljs-number">2</span></span>/<span class="hljs-number"><span class="hljs-number">49</span></span>/07edcfe6974569ab4da6634ad4e5d492</code> </pre> <br>  El par√°metro "Keys_zone = proxy_cache: 15m" establece el nombre de la zona en la memoria compartida, donde se almacenan todas las claves activas y la informaci√≥n sobre ellas.  A trav√©s de ":" indica el tama√±o de la memoria asignada en MB.  Seg√∫n nginx, 1 MB es suficiente para almacenar 8 mil claves. <br><br>  "Max_size = 1G" define el tama√±o m√°ximo de cach√© para todas las p√°ginas por encima de las cuales nginx se encargar√° de eliminar los datos menos necesarios. <br><br>  Tambi√©n es posible controlar la vida √∫til de los datos en la memoria cach√©, para esto es suficiente definir el par√°metro "inactivo" de la directiva "proxy_cache_path", que es de 10 minutos por defecto.  Si durante el tiempo especificado en el par√°metro "inactivo" no hubo llamadas a los datos de la memoria cach√©, estos datos se eliminan incluso si la memoria cach√© a√∫n no est√° "agria". <br><br>  ¬øC√≥mo es este cach√©?  Este es en realidad un archivo normal en el servidor, cuyo contenido est√° escrito: <br><br>  ‚Ä¢ clave de cach√©; <br>  ‚Ä¢ cabeceras de cach√©; <br>  ‚Ä¢ respuesta de contenido desde el backend. <br><br>  Si todo est√° claro con los encabezados y la respuesta del backend, entonces hay una serie de preguntas a la "clave de cach√©".  ¬øC√≥mo se construye y c√≥mo se puede administrar? <br><br>  Para describir la plantilla para construir una clave de cach√© en nginx, hay una directiva proxy_cache_key, en la que se especifica una cadena como par√°metro.  Una cadena puede constar de cualquier variable disponible en nginx. <br><br>  Por ejemplo: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_key</span></span> <span class="hljs-variable"><span class="hljs-variable">$request_method</span></span><span class="hljs-variable"><span class="hljs-variable">$host</span></span><span class="hljs-variable"><span class="hljs-variable">$orig_uri</span></span>:<span class="hljs-variable"><span class="hljs-variable">$cookie_some_cookie</span></span>:<span class="hljs-variable"><span class="hljs-variable">$arg_some_arg</span></span>;</code> </pre> <br>  El s√≠mbolo ":" entre el par√°metro de cookie y el par√°metro get se usa para evitar colisiones entre claves de cach√©, puede elegir cualquier otro s√≠mbolo de su elecci√≥n.  Por defecto, nginx usa la siguiente l√≠nea para generar la clave: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_key</span></span> <span class="hljs-variable"><span class="hljs-variable">$scheme</span></span><span class="hljs-variable"><span class="hljs-variable">$proxy_host</span></span><span class="hljs-variable"><span class="hljs-variable">$request_uri</span></span>;</code> </pre> <br>  Deben tenerse en cuenta las siguientes directivas que lo ayudar√°n a administrar su almacenamiento en cach√© de manera m√°s flexible: <br><br>  <i>proxy_cache_valid</i> : especifica el tiempo de almacenamiento en cach√© de la respuesta.  Es posible indicar el estado espec√≠fico de la respuesta, por ejemplo 200, 302, 404, etc., o indicar todo de una vez utilizando la construcci√≥n "any".  Si solo se especifica el tiempo de almacenamiento en cach√©, nginx predeterminar√° solo los estados de 200, 301 y 302. <br><br>  Un ejemplo: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_valid</span></span> <span class="hljs-number"><span class="hljs-number">15m</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_valid</span></span> <span class="hljs-number"><span class="hljs-number">404</span></span> <span class="hljs-number"><span class="hljs-number">15s</span></span>;</code> </pre><br>  En este ejemplo, establecemos la vida √∫til de la cach√© en 15 minutos para los estados 200, 301, 302 (nginx los usa de forma predeterminada, ya que no especificamos un estado espec√≠fico).  La siguiente l√≠nea establece el tiempo de almacenamiento en cach√© en 15 segundos, solo para respuestas con un estado de 404. <br><br>  <i>proxy_cache_lock</i> : esta directiva ayudar√° a evitar varios pases al backend inmediatamente despu√©s de configurar el cach√©, solo establezca el valor en la posici√≥n "on".  Todas las dem√°s solicitudes esperar√°n una respuesta en el cach√© o un tiempo de espera para bloquear la solicitud a la p√°gina.  En consecuencia, todos los tiempos de espera se pueden configurar. <br><br>  <i>proxy_cache_lock_age</i> : le permite establecer un l√≠mite de tiempo de espera para una respuesta del servidor, despu√©s de lo cual se le enviar√° la siguiente solicitud despu√©s de un conjunto de cach√©.  El valor predeterminado es de 5 segundos. <br><br>  <i>proxy_cache_lock_timeout</i> : establece el tiempo de espera para el bloqueo, despu√©s de lo cual la solicitud se enviar√° al back-end, pero la respuesta no se almacenar√° en cach√©.  El valor predeterminado es de 5 segundos. <br><br>  <i>proxy_cache_use_stale</i> : otra directiva √∫til que le permite configurar cu√°ndo es posible utilizar un cach√© obsoleto. <br><br>  Un ejemplo: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_use_stale</span></span> <span class="hljs-literal"><span class="hljs-literal">error</span></span> timeout updating;</code> </pre> <br>  En este caso, utilizar√° un cach√© desactualizado en caso de un error de conexi√≥n, enviando una solicitud, leyendo una respuesta del servidor, excediendo el l√≠mite de espera para enviar una solicitud, leyendo una respuesta del servidor o si los datos en el cach√© se actualizan en el momento de la solicitud. <br><br>  <i>proxy_cache_bypass</i> : especifica las condiciones bajo las cuales nginx no recibir√° una respuesta de la memoria cach√©, sino que redirigir√° inmediatamente la solicitud al back-end.  Si al menos uno de los par√°metros no est√° vac√≠o y no es igual a "0".  Un ejemplo: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_bypass</span></span> <span class="hljs-variable"><span class="hljs-variable">$cookie_nocache</span></span> <span class="hljs-variable"><span class="hljs-variable">$arg_nocache</span></span>;</code> </pre> <br>  <i>proxy_no_cache</i> : establece la condici√≥n bajo la cual nginx no guardar√° la respuesta del backend en el cach√©.  El principio de funcionamiento es el mismo que el de la directiva proxy_cache_bypass. <br><br><h3>  Posibles problemas con el almacenamiento en cach√© de la p√°gina </h3><br>  Como se mencion√≥ anteriormente, junto con el almacenamiento en cach√© de una respuesta HTTP, nginx guarda los encabezados recibidos del back-end.  Si su sitio utiliza una sesi√≥n, la cookie de sesi√≥n tambi√©n se almacenar√° en cach√©.  Todos los usuarios que visiten la p√°gina que tuvo la suerte de almacenar en cach√© recibir√°n sus datos personales almacenados en la sesi√≥n. <br><br>  El pr√≥ximo desaf√≠o que enfrentar√° es la gesti√≥n de almacenamiento en cach√©.  Por supuesto, puede establecer un tiempo de cach√© insignificante de 2-5 minutos y esto ser√° suficiente en la mayor√≠a de los casos.  Pero esto no es aplicable en todas las situaciones, por lo que reinventaremos nuestra bicicleta.  Ahora, lo primero es lo primero. <br><br>  <b>Gesti√≥n de preservaci√≥n de cookies</b> <br><br>  El almacenamiento en cach√© en el lado nginx impone algunas restricciones de dise√±o.  Por ejemplo, no podemos usar sesiones en p√°ginas almacenadas en cach√©, ya que el usuario no llega al backend, otra limitaci√≥n es la entrega de cookies por parte del backend.  Como nginx almacena en cach√© todos los encabezados, para evitar almacenar la sesi√≥n de otra persona en el cach√©, debemos prohibir la entrega de cookies para las p√°ginas almacenadas en cach√©.  La directiva proxy_ignore_headers nos ayudar√° con esto.  El argumento enumera los encabezados que deben ignorarse desde el backend. <br><br>  Un ejemplo: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">proxy_ignore_headers</span></span> <span class="hljs-string"><span class="hljs-string">"Set-Cookie"</span></span>;</code> </pre> <br>  Con esta l√≠nea, ignoramos la instalaci√≥n de cookies desde el servidor proxy, es decir, el usuario recibir√° una respuesta sin el encabezado "Set-Cookies".  En consecuencia, todo lo que el backend intent√≥ escribir en la cookie se ignorar√° en el lado del cliente, ya que ni siquiera sabr√° que estaba destinado a algo.  Esta restricci√≥n de cookies debe considerarse al desarrollar una aplicaci√≥n.  Por ejemplo, para solicitar autorizaci√≥n, puede desactivar el encendido del encabezado para que el usuario reciba una cookie de sesi√≥n. <br><br>  Tambi√©n debe tener en cuenta la duraci√≥n de la sesi√≥n, se puede ver en el par√°metro " <i>session.gc_maxlifetime</i> " de la configuraci√≥n de php.ini.  Imagine que el usuario inici√≥ sesi√≥n en el sitio y comenz√≥ a ver las noticias, todos los datos ya est√°n en el cach√© nginx.  Despu√©s de un tiempo, el usuario se da cuenta de que su autorizaci√≥n ha desaparecido y nuevamente necesita pasar por el proceso de autorizaci√≥n, aunque todo este tiempo estuvo en el sitio, viendo las noticias.  Esto sucedi√≥ porque en todas sus solicitudes, nginx devolvi√≥ el resultado del cach√© sin enviar una solicitud al backend.  Por lo tanto, el servidor decidi√≥ que el usuario estaba inactivo y despu√©s de un tiempo especificado en " <i>session.gc_maxlifetime</i> " elimin√≥ el archivo de sesi√≥n. <br><br>  Para evitar que esto suceda, podemos emular solicitudes de back-end.  Por ejemplo, a trav√©s de ajax env√≠e una solicitud que se garantizar√° que pase al backend.  Para pasar el cach√© nginx al backend, solo env√≠e una solicitud POST, tambi√©n puede usar la regla de la directiva "proxy_cache_bypass", o simplemente deshabilitar el cach√© para esta p√°gina.  La solicitud no tiene que devolver algo, puede ser un archivo con una sola l√≠nea que inicia la sesi√≥n.  El prop√≥sito de dicha solicitud es extender la vida √∫til de la sesi√≥n mientras el usuario est√° en el sitio, y nginx entrega concienzudamente los datos en cach√© a todas sus solicitudes. <br><br>  <b>Gesti√≥n de vaciado de cach√©</b> <br><br>  Primero debe determinar los requisitos, qu√© objetivo estamos tratando de lograr.  Digamos que nuestro sitio tiene una secci√≥n con una transmisi√≥n de texto de eventos deportivos populares.  Cuando se carga la p√°gina desde el cach√©, todos los mensajes nuevos vienen en sockets.  Para que el usuario vea los mensajes actuales en el momento actual en el primer arranque, en lugar de hace 15 minutos, necesitamos poder borrar de forma independiente el cach√© nginx en cualquier momento.  Al mismo tiempo, nginx puede no estar ubicado en la misma m√°quina que la aplicaci√≥n.  Adem√°s, uno de los requisitos para un restablecimiento ser√° la capacidad de eliminar el cach√©, en varias p√°ginas a la vez. <br><br>  Antes de comenzar a escribir su soluci√≥n, veamos qu√© ofrece nginx de f√°brica.  Para restablecer el cach√©, nginx tiene una directiva especial llamada "proxy_cache_purge", que registra la condici√≥n para restablecer el cach√©.  La condici√≥n es en realidad una l√≠nea normal que, si no est√° vac√≠a y no es "0", eliminar√° el cach√© con la clave que se pasa.  Considere un peque√±o ejemplo. <br><br><pre> <code class="hljs perl">proxy_cache_path /data/nginx/cache keys_zone=cache_zone:<span class="hljs-number"><span class="hljs-number">10</span></span><span class="hljs-keyword"><span class="hljs-keyword">m</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">map</span></span> $request_method $purge_method { PURGE <span class="hljs-number"><span class="hljs-number">1</span></span>; default <span class="hljs-number"><span class="hljs-number">0</span></span>; } server { ... location / { proxy_pass http:<span class="hljs-regexp"><span class="hljs-regexp">//backend</span></span>; proxy_cache cache_zone; proxy_cache_key $uri; proxy_cache_purge $purge_method; } }</code> </pre><br>  <i>Se toma un ejemplo del sitio web oficial de nginx.</i> <br><br>  La variable $ purge_method es responsable de vaciar el cach√©, que es una condici√≥n para la directiva proxy_cache_purge y se establece en 0 de forma predeterminada.  Esto significa que nginx funciona en modo "normal" (guarda las respuestas del backend).  Pero si cambia el m√©todo de solicitud a "PURGE", en lugar de enviar la solicitud para el backend con guardar la respuesta, la entrada de cach√© se eliminar√° utilizando la clave de cach√© correspondiente.  Tambi√©n es posible especificar una m√°scara de eliminaci√≥n especificando un "*" al final de la clave de cach√©.  Por lo tanto, no necesitamos conocer la ubicaci√≥n de la memoria cach√© en el disco y el principio de formaci√≥n de claves, nginx asume estas responsabilidades.  Pero tambi√©n hay desventajas en este enfoque. <br><br><ul><li>  La directiva proxy_cache_purge est√° disponible como parte de una suscripci√≥n comercial. </li><li>  Solo es posible eliminar el cach√© de forma puntual, o mediante el uso de la m√°scara del formulario {clave de cach√©} "*" </li></ul><br>  Dado que las direcciones de las p√°ginas en cach√© pueden ser completamente diferentes, sin partes comunes, el enfoque con la m√°scara "*" y la directiva "proxy_cache_purge" no es adecuado para nosotros.  Queda por recordar una peque√±a teor√≠a y descubrir tu idea favorita. <br><br>  Sabemos que el cach√© nginx es un archivo normal en el servidor.  Especificamos independientemente el directorio para almacenar archivos de cach√© en la directiva "proxy_cache_path", incluso especificamos la l√≥gica de formar la ruta al archivo desde este directorio usando "niveles".  Lo √∫nico que nos falta es la formaci√≥n correcta de la clave de almacenamiento en cach√©.  Pero tambi√©n podemos verlo en la directiva "proxy_cache_key".  Ahora todo lo que tenemos que hacer es: <br><br><ul><li>  formar la ruta completa a la p√°gina, exactamente como se especifica en la directiva proxy_cache_key; </li><li>  codificar la cadena resultante en md5; </li><li>  crear directorios anidados utilizando la regla del par√°metro "niveles". </li><li>  Y ahora ya tenemos la ruta completa al archivo de cach√© en el servidor.  Ahora todo lo que nos queda es eliminar este mismo archivo.  Desde la parte introductoria, sabemos que nginx puede no estar ubicado en la m√°quina de la aplicaci√≥n, por lo que debe permitir eliminar varias direcciones a la vez.  Nuevamente, describimos el algoritmo: </li><li>  Las rutas generadas a los archivos de cach√© las escribiremos en el archivo; </li><li>  Escribamos un script bash simple que colocamos en la m√°quina con la aplicaci√≥n.  Su tarea ser√° conectarse a trav√©s de ssh al servidor donde tenemos nginx de cach√© y eliminar todos los archivos de cach√© especificados en el archivo generado desde el paso 1; </li></ul><br>  Pasamos de la teor√≠a a la pr√°ctica, escribiremos un peque√±o ejemplo que ilustra nuestro algoritmo de trabajo. <br><br>  Paso 1. Generando un archivo con rutas al cach√©. <br><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$urls</span></span> = [ <span class="hljs-string"><span class="hljs-string">'httpGETdomain.ru/news/111/1:2'</span></span>, <span class="hljs-string"><span class="hljs-string">'httpGETdomain.ru/news/112/3:4'</span></span>, ]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_nginx_cache_path</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url)</span></span></span></span> { <span class="hljs-variable"><span class="hljs-variable">$nginxHash</span></span> = md5(<span class="hljs-variable"><span class="hljs-variable">$url</span></span>); <span class="hljs-variable"><span class="hljs-variable">$firstDir</span></span> = substr(<span class="hljs-variable"><span class="hljs-variable">$nginxHash</span></span>, <span class="hljs-literal"><span class="hljs-literal">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-variable"><span class="hljs-variable">$secondDir</span></span> = substr(<span class="hljs-variable"><span class="hljs-variable">$nginxHash</span></span>, <span class="hljs-literal"><span class="hljs-literal">-3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"/var/lib/nginx/proxy_cache/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$firstDir</span></span></span><span class="hljs-string">/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$secondDir</span></span></span><span class="hljs-string">/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$nginxHash</span></span></span><span class="hljs-string">"</span></span>; } //        tmp <span class="hljs-variable"><span class="hljs-variable">$filePath</span></span> = tempnam(<span class="hljs-string"><span class="hljs-string">'tmp'</span></span>, <span class="hljs-string"><span class="hljs-string">'nginx_cache_'</span></span>); //      <span class="hljs-variable"><span class="hljs-variable">$fileStream</span></span> = fopen(<span class="hljs-variable"><span class="hljs-variable">$filePath</span></span>, <span class="hljs-string"><span class="hljs-string">'a'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-variable"><span class="hljs-variable">$urls</span></span> as <span class="hljs-variable"><span class="hljs-variable">$url</span></span>) { //      <span class="hljs-variable"><span class="hljs-variable">$cachePath</span></span> = to_nginx_cache_path(<span class="hljs-variable"><span class="hljs-variable">$url</span></span>); //       fwrite(<span class="hljs-variable"><span class="hljs-variable">$fileStream</span></span>, <span class="hljs-variable"><span class="hljs-variable">$cachePath</span></span> . PHP_EOL); } //     fclose(<span class="hljs-variable"><span class="hljs-variable">$fileStream</span></span>); //  bash       exec(<span class="hljs-string"><span class="hljs-string">"/usr/local/bin/cache_remover </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$filePath</span></span></span><span class="hljs-string">"</span></span>);</code> </pre><br>  Tenga en cuenta que la variable $ urls contiene la url de las p√°ginas en cach√©, ya en el formato proxy_cache_key especificado en la configuraci√≥n de nginx.  Url act√∫a como una etiqueta para las entidades que se muestran en la p√°gina.  Por ejemplo, puede crear una tabla regular en la base de datos, donde cada entidad se asignar√° a una p√°gina espec√≠fica en la que se muestra.  Luego, al cambiar cualquier dato, podemos hacer una selecci√≥n en la tabla y eliminar el cach√© de todas las p√°ginas que necesitamos. <br><br>  Paso 2. Con√©ctese al servidor de cach√© y elimine los archivos de cach√©. <br><br><pre> <code class="hljs smalltalk">#      ,      <span class="hljs-type"><span class="hljs-type">FILE_LIST</span></span>=`cat <span class="hljs-string"><span class="hljs-string">$1</span></span> | tr <span class="hljs-comment"><span class="hljs-comment">"\n"</span></span> <span class="hljs-comment"><span class="hljs-comment">" "</span></span>` #   ssh  <span class="hljs-type"><span class="hljs-type">SSH</span></span>=`which ssh` <span class="hljs-type"><span class="hljs-type">USER</span></span>=<span class="hljs-comment"><span class="hljs-comment">"root"</span></span> #         nginx <span class="hljs-type"><span class="hljs-type">HOST</span></span>=<span class="hljs-comment"><span class="hljs-comment">"10.10.1.0"</span></span> #   <span class="hljs-type"><span class="hljs-type">KEY</span></span>=<span class="hljs-comment"><span class="hljs-comment">"/var/keys/id_rsa"</span></span> # <span class="hljs-type"><span class="hljs-type">SSH</span></span> ,          <span class="hljs-string"><span class="hljs-string">$S</span></span>SH -i <span class="hljs-string"><span class="hljs-string">${</span></span><span class="hljs-type"><span class="hljs-type">KEY</span></span>} <span class="hljs-string"><span class="hljs-string">${</span></span><span class="hljs-type"><span class="hljs-type">USER</span></span>}@<span class="hljs-string"><span class="hljs-string">${</span></span><span class="hljs-type"><span class="hljs-type">HOST</span></span>} <span class="hljs-comment"><span class="hljs-comment">"rm -f ${FILE_LIST}"</span></span> #       rm -rf rm -f <span class="hljs-string"><span class="hljs-string">$1</span></span> #  </code> </pre><br>  Los ejemplos anteriores son solo orientativos, no los use en producci√≥n.  En los ejemplos, se omiten las comprobaciones de los par√°metros de entrada y las restricciones de comando.  Uno de los problemas que puede encontrar es limitar la longitud del argumento al comando rm.  Al realizar pruebas en entornos de desarrollo en peque√±os vol√∫menes, esto puede pasarse por alto f√°cilmente, y en producci√≥n, aparece el error "rm: Lista de argumentos demasiado larga". <br><br><h3>  Cach√© de bloque personalizado </h3><br>  Resumamos lo que logramos hacer: <br><br><ul><li>  reducido la carga en el backend; </li><li>  Aprenda a administrar el almacenamiento en cach√© </li><li>  aprendi√≥ a vaciar el cach√© en cualquier momento dado. </li></ul><br>  Pero no todo es tan bueno como podr√≠a parecer a primera vista.  Ahora, probablemente, si no todos los primeros, entonces precisamente cada segundo sitio tiene una funcionalidad de registro / autorizaci√≥n, despu√©s de pasar por el cual querremos mostrar el nombre de usuario en alg√∫n lugar del encabezado.  El bloque con el nombre es √∫nico y debe mostrar el nombre de usuario con el que estamos autorizados.  Dado que nginx guarda la respuesta del backend, y en el caso de la p√°gina es el contenido html de la p√°gina, el bloque con datos personales tambi√©n se almacenar√° en cach√©.  Todos los visitantes del sitio ver√°n el nombre del primer usuario que pas√≥ al backend para obtener un conjunto de cach√©. <br>  Por lo tanto, el backend no debe proporcionar bloques en los que se encuentre la informaci√≥n personal para que esta informaci√≥n no se encuentre en el cach√© nginx. <br><br>  Es necesario considerar la carga alternativa de tales partes de la p√°gina.  Como siempre, esto se puede hacer de muchas maneras, por ejemplo, despu√©s de cargar la p√°gina, enviar una solicitud ajax y mostrar el cargador en lugar de contenido personal.  Otra forma que consideraremos hoy es usar etiquetas ssi.  Primero comprendamos qu√© es SSI, y luego c√≥mo podemos usarlo junto con el cach√© nginx. <br><br><h3>  ¬øQu√© es SSI y c√≥mo funciona? </h3><br>  SSI (inclusiones del lado del servidor, inclusiones del lado del servidor) es un conjunto de comandos integrados en una p√°gina html que le dice al servidor qu√© hacer. <br><br>  Aqu√≠ hay una lista de dichos comandos (directivas): <br><br>  ‚Ä¢ if / elif / else / endif: el operador de ramificaci√≥n; <br>  ‚Ä¢ echo: muestra los valores de las variables; <br>  ‚Ä¢ include: le permite insertar el contenido de otro archivo en el documento. <br>  Solo se discutir√° la √∫ltima directiva.  La directiva include tiene dos par√°metros: <br>  ‚Ä¢ archivo: especifica la ruta al archivo en el servidor.  En cuanto al directorio actual; <br>  ‚Ä¢ virtual: indica la ruta virtual al documento en el servidor. <br><br>  Estamos interesados ‚Äã‚Äãen el par√°metro "virtual", ya que especificar la ruta completa al archivo en el servidor no siempre es conveniente, o en el caso de una arquitectura distribuida, el archivo en el servidor simplemente no est√° all√≠.  Directiva de ejemplo: <br><br><pre> <code class="hljs xml"><span class="hljs-comment"><span class="hljs-comment">&lt;!--#include virtual="/user/personal_news/"--&gt;</span></span></code> </pre> <br>  Para que nginx comience a procesar inserciones ssi, debe modificar la ubicaci√≥n de la siguiente manera: <br><br><pre> <code class="hljs cs">location / { ssi <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>; ... }</code> </pre><br>  Ahora todas las solicitudes procesadas por la ubicaci√≥n "/" podr√°n realizar inserciones ssi. <br><br>  ¬øC√≥mo pasar√° nuestra solicitud a trav√©s de todo este esquema? <br><br><ul><li>  el cliente solicita la p√°gina; </li><li>  Nginx representa la solicitud del backend; </li><li>  el backend le da a la p√°gina inserciones ssi; </li><li>  el resultado se almacena en el cach√©; </li><li>  Nginx "pregunta" los bloques que faltan; </li><li>  La p√°gina resultante se env√≠a al cliente. </li></ul><br>  Como puede ver en los pasos, las construcciones ssi entrar√°n en la memoria cach√© nginx, lo que permitir√° no almacenar en cach√© los bloques personales, y se enviar√° una p√°gina html preparada con todas las inserciones al cliente.  Aqu√≠ nuestra carga funciona, nginx solicita independientemente los bloques de p√°gina que faltan.  Pero como cualquier otra soluci√≥n, este enfoque tiene sus ventajas y desventajas.  Imagine que hay varios bloques en la p√°gina que deber√≠an mostrarse de manera diferente seg√∫n el usuario, luego cada uno de estos bloques se reemplazar√° con un inserto ssi.  Nginx, como se esperaba, solicitar√° cada bloque de este tipo desde el backend, es decir, una solicitud del usuario generar√° inmediatamente varias solicitudes para el backend, lo que no quisiera en absoluto. <br><br><h3>  Deshacerse de las persistentes solicitudes de backend a trav√©s de ssi </h3><br>  Para resolver este problema, el m√≥dulo nginx "ngx_http_memcached_module" nos ayudar√°.  El m√≥dulo permite recibir valores del servidor memcached.  Escribir a trav√©s del m√≥dulo no funcionar√°, el servidor de aplicaciones deber√≠a encargarse de esto.  Considere un peque√±o ejemplo de configuraci√≥n de nginx junto con un m√≥dulo: <br><br><pre> <code class="hljs nginx"><span class="hljs-section"><span class="hljs-section">server</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /page { <span class="hljs-attribute"><span class="hljs-attribute">set</span></span> <span class="hljs-variable"><span class="hljs-variable">$memcached_key</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$uri</span></span></span><span class="hljs-string">"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">memcached_pass</span></span> <span class="hljs-number"><span class="hljs-number">127.0.0.1:11211</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">error_page</span></span> <span class="hljs-number"><span class="hljs-number">404</span></span> <span class="hljs-number"><span class="hljs-number">502</span></span> <span class="hljs-number"><span class="hljs-number">504</span></span> = <span class="hljs-variable"><span class="hljs-variable">@fallback</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> <span class="hljs-variable"><span class="hljs-variable">@fallback</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> http://backend; } }</code> </pre><br>  En la variable $ memcache_key especificamos la clave por la cual nginx intentar√° obtener datos de memcache.  Los par√°metros para conectarse al servidor memcache se establecen en la directiva memcached_pass.  La conexi√≥n se puede especificar de varias maneras: <br><br>  ‚Ä¢ nombre de dominio; <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">memcached_pass</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">cache</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.domain</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.ru</span></span>;</code> </pre> <br>  ‚Ä¢ Direcci√≥n IP y puerto; <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">memcached_pass</span></span> localhost:<span class="hljs-number"><span class="hljs-number">11211</span></span>;</code> </pre> <br>  ‚Ä¢ z√≥calo unix; <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">memcached_pass</span></span> unix:/tmp/memcached.socket;</code> </pre> <br>  ‚Ä¢ Directiva aguas arriba. <br><br><pre> <code class="hljs axapta">upstream cachestream { hash $request_uri consistent; <span class="hljs-keyword"><span class="hljs-keyword">server</span></span> <span class="hljs-number"><span class="hljs-number">10.10</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span>:<span class="hljs-number"><span class="hljs-number">11211</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">server</span></span> <span class="hljs-number"><span class="hljs-number">10.10</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span>:<span class="hljs-number"><span class="hljs-number">11211</span></span>; } location / { ... memcached_pass cachestream; ... }</code> </pre><br>  Si nginx logr√≥ obtener una respuesta del servidor de cach√©, entonces se la da al cliente.  Si no hay datos en el cach√©, la solicitud se enviar√° al backend a trav√©s de "@fallback".  Esta peque√±a configuraci√≥n del m√≥dulo memcached en nginx nos ayudar√° a reducir la cantidad de solicitudes de aprobaci√≥n para el backend de las inserciones ssi. <br><br>  Esperamos que este art√≠culo sea √∫til y pudimos mostrar una de las formas de optimizar la carga en el servidor, considerar los principios b√°sicos para configurar el almacenamiento en cach√© de nginx y cerrar los problemas que surgen al usarlo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es428127/">https://habr.com/ru/post/es428127/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es428117/index.html">Procesadores de tensor gratuitos de Google en la nube colaborativa</a></li>
<li><a href="../es428119/index.html">"Clase-campos-propuesta" o "¬øQu√© sali√≥ mal en tc39 commit"</a></li>
<li><a href="../es428121/index.html">Stan Drapkin. Trampas de criptograf√≠a de alto nivel en .NET</a></li>
<li><a href="../es428123/index.html">Semana de la seguridad 41: buenas noticias</a></li>
<li><a href="../es428125/index.html">¬øQui√©nes son los an√°lisis de productos y por qu√© se necesitan en un equipo?</a></li>
<li><a href="../es428129/index.html">Simple l√≥gica difusa unida "de lo que era" para un motor de turbina de gas</a></li>
<li><a href="../es428131/index.html">Toda la verdad sobre RTOS. Art√≠culo # 17. Grupos de banderas de eventos: Introducci√≥n y servicios b√°sicos</a></li>
<li><a href="../es428133/index.html">Hasura Arquitectura de alto rendimiento GraphQL a SQL Server</a></li>
<li><a href="../es428135/index.html">C√≥mo configurar o deshabilitar el linting en el editor de c√≥digo incorporado</a></li>
<li><a href="../es428137/index.html">Olimpiada, concurso de ideas, conferencias sobre gesti√≥n de proyectos de TI y proyecciones de pel√≠culas: 10 pr√≥ximos eventos en la Universidad ITMO</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>