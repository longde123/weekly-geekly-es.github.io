<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧓🏿 👍🏾 🖋️ Proyek WideNES - melampaui batas layar NES 👬 ✊🏾 📑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada pertengahan 1980-an, Nintendo Entertainment System (NES) adalah konsol yang harus dimiliki. Suara terbaik, grafis terbaik, dan permainan terbaik ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Proyek WideNES - melampaui batas layar NES</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421555/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d6f/68d/6f7/d6f68d6f7f1e05516af8dcae1443bcb9.gif" alt="gambar"></div><br>  Pada pertengahan 1980-an, Nintendo Entertainment System (NES) adalah konsol yang harus dimiliki.  Suara terbaik, grafis terbaik, dan permainan terbaik di antara semua konsol pada waktu itu - konsol memperluas batas yang dimungkinkan.  Sejauh ini, proyek-proyek seperti <em>Super Mario Bros</em>  , <em>The Legend of Zelda</em> dan <em>Metroid</em> dianggap beberapa game terbaik sepanjang masa. <br><br>  Lebih dari 30 tahun setelah rilis NES, game klasik terasa hebat, yang tidak bisa dikatakan tentang perangkat keras tempat mereka bekerja.  Dengan resolusi hanya 256x240, konsol NES tidak dapat memberikan ruang permainan yang cukup.  Namun demikian, pengembang yang tak kenal takut berhasil masuk ke dalam game NES yang luar biasa, dunia yang tak terlupakan: ruang bawah tanah seperti Labirin <em>Zelda yang</em> seperti labirin, ruang luas planet ini di <em>Metroid</em> , tingkat terang <em>Super Mario Bros.</em>  .  Namun, karena keterbatasan perangkat keras NES, pemain tidak pernah bisa melampaui 256x240 ... <br><br>  Sampai saat ini. <br><br>  Saya mempersembahkan kepada Anda proyek <strong>wideNES</strong> - cara baru untuk memainkan NES klasik! <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/921/157/9b0/9211579b0ba7322cf563254fcd26c9cc.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dcd/433/ea0/dcd433ea06a9dec672c3457d76ee2181.gif"></div><br>  <strong>wideNES</strong> adalah teknologi baru untuk <em>secara otomatis</em> dan <em>interaktif</em> menandai game NES <em>secara real time</em> . <br><br>  Ketika pemain bergerak di sekitar level, wideNES merekam layar, secara bertahap membangun peta bagian dunia yang dijelajahi.  Di level berikutnya, wideNES menyinkronkan gameplay di layar dengan peta yang dihasilkan, yang pada dasarnya memungkinkan pemain untuk melihat lebih banyak dengan "melihat" di luar batas layar NES!  Yang terbaik dari semuanya, cara Anda menandai game wideNES <em>benar-benar universal</em> , yang memungkinkan berbagai game NES bekerja dengan wideNES tanpa konfigurasi apa pun! <br><br>  Tapi bagaimana cara kerjanya? <br><br><hr><br>  Jika Anda ingin memeriksa cara kerja wideNES sebelum membaca artikel, silakan!  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ANESE</a> adalah emulator NES yang saya tulis, dan saat ini merupakan satu-satunya emulator yang mengimplementasikan wideNES.  Namun, patut diingat bahwa ANESE <em>bukan</em> emulator NES terbaik di dunia, dalam hal UI dan akurasi emulasi.  Sebagian besar fitur (termasuk masuknya wideNES) hanya tersedia melalui baris perintah, dan meskipun banyak game populer berfungsi dengan baik, beberapa lainnya mungkin berperilaku dengan cara yang tidak terduga. <br><br><hr><br><h2>  Cara kerja wideNES </h2><br>  Sebelum mempelajari detail, penting untuk menjelaskan secara singkat bagaimana NES membuat grafik. <br><br><h3>  Transfer Pixel Menggunakan PPU </h3><br>  Inti dari NES adalah prosesor MOS 6502 yang terhormat. Di akhir 70-an dan awal 80-an, 6502 digunakan di <em>mana</em> - <em>mana</em> dan bekerja di mesin legendaris seperti Commodore 64, Apple II dan banyak lainnya.  Itu murah, mudah diprogram dan <em>cukup</em> kuat untuk berbahaya. <br><br>  Melengkapi 6502 di konsol NES adalah coprocessor grafis yang kuat yang disebut <em>Picture Processing Unit</em> (PPU).  Dibandingkan dengan koprosesor video sederhana yang digunakan pada sistem yang lebih lama, PPU adalah peningkatan besar dalam hal kegunaan.  Sebagai contoh, lima tahun sebelum rilis NES, prosesor Atari 2600 6502 digunakan untuk mengirimkan instruksi grafis ke coprocessor <em>untuk setiap baris raster</em> , yang membuat prosesor sangat sedikit waktu untuk menjalankan logika permainan.  Sebagai perbandingan: PPU hanya membutuhkan beberapa perintah <em>per frame</em> , dan ini memberi 6502 cukup waktu untuk membuat gameplay yang menarik dan inovatif. <br><br>  PPU adalah chip yang luar biasa, caranya rendering grafik hampir tidak seperti karya GPU modern, dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">serangkaian artikel lengkap akan diperlukan</a> untuk sepenuhnya menjelaskan fungsinya.  Karena wideNES hanya menggunakan sebagian kecil fungsi PPU, cukup untuk mempertimbangkannya secara singkat: <br><br><ul><li>  Resolusi: 256x240 piksel, 60 Hz </li><li>  Ini bekerja secara independen dari CPU <br><ul><li>  Berkomunikasi dengan CPU menggunakan <em>I / O dengan pemetaan memori</em> (kisaran alamat 0x2000 - 0x2007) </li></ul></li><li>  2 lapisan render: lapisan <strong>sprite</strong> dan lapisan <strong>latar belakang</strong> <ul><li>  <strong>Lapisan sprite</strong> <br><ul><li>  Setiap sprite individu dapat ditempatkan di mana saja di layar. </li><li>  Bagus untuk objek bergerak: pemain, musuh, kerang </li><li>  Hingga 64 8x8 piksel sprite </li></ul></li><li>  <strong>Lapisan latar belakang</strong> <br><ul><li>  Terikat ke grid </li><li>  Bagus untuk elemen statis: platform, hambatan besar, dekorasi </li><li>  Memori video cukup untuk menyimpan 64x30 ubin ukuran 8x8 piksel <br><ul><li>  Resolusi <em>internal</em> sejati 512x240, dengan viewport 256x240 </li><li>  Mendukung <strong><em>pengguliran perangkat keras</em></strong> untuk mengubah viewport 256x240 <br><ul><li>  Register PPUSCROLL (alamat 0x2005) mengontrol perubahan viewport dalam X / Y </li></ul></li></ul></li></ul></li></ul></li></ul><br>  Setelah berurusan dengan ikhtisar yang <em>sangat</em> singkat ini, mari kita beralih ke yang paling menarik: bagaimana cara kerja wideNES? <br><br><h3>  Ide utama </h3><br>  Di akhir setiap frame, CPU mengirimkan informasi perubahan ke PPU.  Ini termasuk posisi sprite baru, data level baru dan, yang sangat penting untuk wideNES, <em>offset viewport baru</em> .  Karena wideNES bekerja di emulator, sangat mudah bagi kami untuk melacak nilai-nilai yang dituliskan ke register PPUSCROLL, yang artinya sangat mudah untuk menghitung berapa banyak layar telah bergerak di antara dua frame! <br><br>  Hmm, apa yang akan terjadi jika, alih-alih menggambar setiap frame baru <em>langsung di atas</em> frame lama, frame baru akan digambar di atas frame sebelumnya, tetapi bergeser ke nilai gulir saat ini?  Kemudian, seiring berjalannya waktu, bagian level yang semakin besar akan tetap ada di layar, secara bertahap membangun gambar level lengkap! <br><br>  Untuk memeriksa apakah ide ini ada nilainya, saya dengan cepat membuat sketsa implementasi pertama. <br><br>  Menyusun ... <br>  Meluncurkan ... <br>  Unduh <em>Super Mario Bros.</em>  ... <br><br>  Voila! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ed/7cb/c7f/1ed7cbc7ff1998d1f5f19af6ca09bb54.gif"></div><br>  Berhasil! <br><br>  Tampaknya ... <br><br><hr><br><h3>  Pendekatan lain: mengapa tidak mengekstrak level langsung dari file ROM? </h3><br>  Tanpa mempertimbangkan rincian implementasi, menjadi jelas bahwa teknik ini memiliki batasan serius: peta permainan penuh hanya dapat dikumpulkan ketika pemain secara independen menjelajahi seluruh permainan. <br><br>  Bagaimana jika ada cara untuk mengekstraksi level dari ROM NES <em>mentah</em> ?! <br><br>  Bisakah teknik semacam itu ada? <br><br>  Yah, kemungkinan besar tidak. <br><br>  Jika Anda mengambil dua game untuk NES, Anda dapat menjamin bahwa mereka hanya memiliki satu kesamaan - keduanya bekerja untuk NES.  Yang lainnya bisa sangat berbeda!  Ketidakcocokan seperti itu adalah bencana nyata, karena game NES pada dasarnya memiliki jumlah pilihan tak terbatas untuk menyimpan data level! <br><br>  Beberapa orang telah mengekstraksi level penuh dengan teknik terbalik cara mereka menyimpan data level dari <em>beberapa</em> game (kadang-kadang dengan penciptaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">editor peta</a> berfitur lengkap!), Tapi ini adalah tugas yang sulit, membutuhkan banyak pekerjaan, ketekunan dan kecerdasan. <br><br>  Untuk mengekstraksi data level dari ROM, perlu untuk menentukan bagian ROM mana yang berkode (bukan data), dan ini sulit dilakukan, karena <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menemukan semua kode dalam file biner setara dengan masalah berhenti</a> ! <br><br>  WideNES menggunakan pendekatan yang jauh lebih sederhana: alih-alih menebak bagaimana game mengemas data level dalam ROM, wideNES hanya meluncurkan game dan melacak hasilnya! <br><br><hr><br><h3>  Menggulir melebihi 255 </h3><br>  NES adalah sistem 8-bit, yaitu, register PPUSCROLL hanya dapat menerima nilai 8-bit.  Ini membatasi offset gulir maksimum hingga 255 piksel, yaitu, jumlah maksimum 8-bit.  Tidak ada kebetulan bahwa resolusi layar NES adalah 240x256 piksel, mis. Pergeseran 255-piksel <em>hanya cukup</em> untuk menggulir seluruh layar. <br><br>  Tetapi apa yang terjadi ketika menggulir <em>lebih dari</em> 255? <br><br>  Pertama, game mengatur ulang register PPUSCROLL menjadi 0. Ini menjelaskan mengapa <em>SMB</em> dijalankan sampai awal ketika Mario bergerak terlalu jauh ke kanan. <br><br>  Kemudian, untuk mengkompensasi pembatasan PPUSCROLL 8-bit, game memperbarui register PPU lain: PPUCTRL (alamat 0x2000).  2 bit terbawah dari PPUCTRL mengatur "titik awal" dari adegan saat ini dalam peningkatan layar penuh.  Misalnya, menulis nilai 1 menggeser viewport ke kanan sebesar 256 piksel, nilai 2 menggeser viewport turun menjadi 240 piksel.  Offset PPUCTRL didorong ke <em>tumpukan</em> dengan register PPUSCROLL, yang memungkinkan Anda untuk menggulir layar secara horizontal dalam 512 piksel atau secara vertikal dalam 480 piksel. <br><br>  Tapi build, apakah hanya ada cukup memori video untuk dua layar level?  Apa yang terjadi ketika viewport menggulir terlalu jauh ke kanan dan "melampaui" VRAM?  Untuk menangani kasus ini, PPU mengimplementasikan konvolusi: semua bagian viewport di luar memori video yang dipilih hanya diciutkan ke tepi yang berlawanan dari memori video. <br><br>  Lipat seperti itu, dikombinasikan dengan manipulasi register PPUSCROLL dan PPUCTRL yang cerdas, memungkinkan game NES untuk menciptakan ilusi dunia yang sangat tinggi / lebar!  Berkat pemuatan malas dari tingkat di luar jendela tampilan dan pengguliran bertahap ke dalamnya, pemain tidak pernah menyadari bahwa di dalam VRAM mereka benar-benar “berlari dalam lingkaran”! <br><br>  Ilustrasi yang sangat baik dari wiki nesdev menunjukkan bagaimana <em>Super Mario Bros</em>  menggunakan properti ini untuk membuat level lebih dari dua layar: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d6f/68d/6f7/d6f68d6f7f1e05516af8dcae1443bcb9.gif"></div><br>  Mari kita kembali ke pertanyaan yang sedang kita diskusikan: bagaimana wideNES menangani pengguliran di luar 256? <br><br>  Yah, sejujurnya, wideNES <em>sepenuhnya mengabaikan</em> register PPUCTRL dan hanya melacak perbedaan PPUSCROLL antara frame! <br><br>  Jika PPUSCROLL tiba-tiba melompat ke sekitar 256, yang biasanya berarti bahwa karakter pemain telah bergerak ke kiri / atas pada layar, dan jika ia tiba-tiba melompat ke sekitar 0, ini biasanya berarti bahwa pemain telah bergerak di sekitar layar ke kanan / ke bawah. <br><br>  Meskipun heuristik ini mungkin terlihat sederhana - dan memang - sebenarnya, ia bekerja dengan baik! <br><br>  Setelah menerapkan heuristik ini, <em>Super Mario Bros</em>  , <em>Metroid</em> dan banyak game lain telah bekerja dengan hampir sempurna! <br><br>  Saya sangat senang, jadi saya melanjutkan dan mengunggah klasik NES lainnya - <em>Super Mario Bros.</em>  <em>3</em> ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a21/1ee/233/a211ee233bcdea56af5b983f9b8715cf.gif"></div><br>  Hmm ... Tidak terlalu cantik. <br><br><h3>  Mengabaikan elemen layar statis </h3><br>  Banyak permainan memiliki elemen UI statis di sekitar tepi layar.  Dalam kasus <em>SMB3,</em> ini adalah kolom di sebelah kiri dan bilah status di bagian bawah status. <br><br>  Secara default, sampel wideNES dengan kenaikan 16-piksel dari tepi layar, yaitu, semua elemen statis di tepi diambil sampelnya!  Tidak bagus! <br><br>  Untuk mengatasi masalah ini, wideNES mengimplementasikan aturan dan heuristik yang mencoba mengenali dan menutupi elemen layar statis secara otomatis. <br><br>  Secara umum, game NES menggunakan tiga jenis elemen layar statis: HUD, mask, dan bilah status. <br><br><h4>  HUD - tidak masalah </h4><br>  Jika sebuah game memaksakan HUD di atas level, maka kemungkinan HUD terdiri dari beberapa sprite.  Contoh: HUD di <em>Metroid</em> . <br><br>  Untungnya, HUD tersebut tidak menimbulkan masalah, karena wideNES saat ini mengabaikan lapisan sprite.  Hebat! <br><br><h4>  Masker - tidak ada tempat yang lebih mudah </h4><br>  PPU memiliki fitur yang memungkinkan game untuk menutupi 8 piksel paling kiri dari lapisan latar belakang.  Ini diaktifkan dengan mengatur bit kedua dari register (alamat 0x2001).  Banyak game menggunakan fitur ini, tetapi menjelaskan <em>mengapa</em> mereka melakukannya di luar ruang lingkup artikel ini. <br><br>  Mengenali topeng yang disertakan sangat sederhana: wideNES hanya melacak nilai PPUMASK dan mengabaikan 8 piksel paling kiri ketika bit kedua diatur dalam register! <br><br>  Tampaknya menerapkan aturan sederhana ini <em>memperbaiki</em> masalah dengan <em>SMB3</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e5/6ce/6ce/8e56ce6ce6e3f59203422816794e21de.gif"></div><br>  ... baik, atau <em>hampir</em> dihilangkan. <br><br><h4>  Bilah status adalah yang paling sulit </h4><br>  Karena keterbatasan PPU pada waktu tertentu di layar tidak boleh ada lebih dari 64 sprite;  apalagi, setiap saat di <em>setiap baris raster tidak</em> boleh ada lebih dari 8 sprite.  Pembatasan ini mencegah pengembang membuat HUD kompleks dari sprite dan memaksa mereka untuk menggunakan bagian-bagian dari lapisan latar belakang untuk menampilkan informasi. <br><br>  Selain topeng, tidak ada cara mudah di PPU untuk memisahkan lapisan latar belakang ke area permainan dan area status.  Oleh karena itu, para pengembang pergi ke trik, yang mengarah ke banyak cara <em>ortodoks</em> untuk membuat panel status ... <br><br>  WideNES menggunakan berbagai heuristik untuk mengenali berbagai jenis panel status, tetapi untuk menghemat waktu, saya hanya akan mempertimbangkan salah satu yang paling menarik: pelacakan IRQ mid-frame. <br><br><h3>  Pelacakan IRQ Mid-Frame </h3><br>  Tidak seperti GPU modern dengan buffer bingkai internal yang besar, PPU <em>umumnya tidak memiliki buffer bingkai!</em>  Untuk menghemat ruang, PPU menyimpan adegan sebagai kisi 64x32 petak 8x8 piksel.  Alih-alih menghitung data piksel, ubin disimpan sebagai <em>petunjuk</em> ke Memori CHR (Memori Karakter), yang berisi semua data piksel. <br><br>  Karena NES dikembangkan pada tahun 80-an, PPU dibuat tanpa mempertimbangkan teknologi tampilan modern.  Alih-alih merender frame penuh secara bersamaan, PPU mengeluarkan sinyal video NTSC, yang harus ditampilkan pada layar CRT yang menampilkan <em>piksel</em> video <em>demi piksel</em> , <em>baris demi baris</em> , dari atas ke bawah, dari atas ke bawah, dari kiri ke kanan, dari kiri ke kanan. <br><br>  Mengapa semua ini penting? <br><br>  Karena PPU membuat frame dari atas ke bawah, baris demi baris, Anda dapat mengirim instruksi PPU ke <em>mid-frame</em> untuk membuat efek video yang tidak mungkin dilakukan dengan pendekatan lain!  Efek-efek ini dapat berupa sederhana (misalnya, mengubah palet), atau cukup kompleks (misalnya, Anda dapat menebaknya, membuat bilah status!). <br><br>  Untuk menjelaskan bagaimana penulisan PPU bingkai tengah dapat membuat bilah status, saya mencatat dump video slice PPU dan CHR memori mentah untuk satu bingkai <em>SMB3</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf6/565/049/cf6565049202c1a832222de6edb291c3.png"></div><br>  Semuanya terlihat baik-baik saja, tidak ada yang istimewa ... tetapi lihat saja bilah status!  Dia benar-benar terdistorsi! <br><br>  Sekarang lihat dump mentah yang sama, tetapi dibuat setelah baris 196 ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5df/8e4/be6/5df8e4be6a32dcefa00429da5fbb4755.png"></div><br>  Ya, levelnya terlihat mengerikan, tetapi bilah status terlihat hebat! <br><br>  Apa yang sedang terjadi di sini? <br><br>  <em>SMB3</em> mengatur timer untuk memicu IRQ (interupsi) tepat setelah rendering baris raster 195. Ini melewati instruksi berikut ke penangan IRQ: <br><br><ul><li>  Setel PPUSCROLL ke (0,0) (sehingga bilah status tetap di tempatnya) </li><li>  Kami mengganti kartu ubin di Memori CHR (kami menyusun grafik bilah status) </li></ul><br>  Karena sisa layer sudah dirender, PPU tidak akan "memperbarui" frame.  Alih-alih, ia akan terus merender dengan opsi ini, menampilkan bilah status yang tidak terdistorsi! <br><br>  Mari kita kembali ke wideNES: dengan mengamati semua IRQ di tengah frame dan mengingat garis raster di mana mereka terjadi, wideNES dapat mengabaikan semua garis raster berikutnya dalam catatan!  Jika IRQ terjadi pada garis raster di atas 240/2, maka semua baris <em>sebelumnya</em> diabaikan, karena gangguan awal pada garis raster berarti bahwa bilah status mungkin ada <em>di bagian atas</em> layar. <br><br>  Setelah menerapkan heuristik ini, <em>Super Mario Bros</em>  <em>3</em> didapat sempurna! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/146/44a/b08/14644ab0880d7a2827bcad22d028a0be.gif"></div><br><hr><br>  Saya secara singkat mempertimbangkan kemungkinan menggunakan perpustakaan visi komputer, seperti OpenCV, untuk mengenali panel status (atau sebagian besar area statis layar), tetapi sebagai hasilnya saya memutuskan untuk mengabaikannya.  Menggunakan perpustakaan visi komputer yang besar, kompleks dan buram bertentangan dengan cita-cita wideNES, di mana saya mencoba menggunakan aturan dan heuristik yang ringkas, sederhana dan transparan untuk mendapatkan hasil. <br><br><hr><br><h3>  Pengenalan adegan </h3><br>  Dengan pengecualian dari beberapa contoh yang menonjol (misalnya, <em>Metroid</em> ), game untuk NES biasanya <em>tidak</em> lulus dalam satu level besar yang tidak dapat dipisahkan.  Sebaliknya, sebagian besar game NES dibagi menjadi banyak “adegan” independen kecil dengan pintu atau layar transisi di antara mereka. <br><br>  Karena wideNES tidak memiliki konsep "adegan," hal-hal buruk terjadi ketika mengubah adegan ... <br><br>  Sebagai contoh, ini adalah transisi pertama dari adegan <em>Castlevania</em> , di mana Simon Belmont memasuki istana Dracula: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f7/b5b/8e4/7f7b5b8e4edf5c31dd19682b333d75c9.gif"></div><br>  Wow, semuanya buruk!  wideNES sepenuhnya menulis ulang bagian terakhir dari level dengan layar pertama dari level baru! <br><br>  Jelas, wideNES membutuhkan cara mengenali perubahan adegan.  Tapi yang mana? <br><br>  <em>Hashing perseptual!</em> <br><br>  Tidak seperti fungsi hash <em>kriptografis</em> , yang cenderung mendistribusikan data input yang serupa secara merata di seluruh ruang informasi output, fungsi hash <em>persepsi</em> mencoba untuk menjaga data input yang serupa “berdekatan” di ruang data output.  Oleh karena itu, hash persepsi ideal untuk mengenali gambar yang serupa! <br><br>  Fungsi hash perseptual dapat menjadi sangat kompleks, beberapa di antaranya dapat mengenali gambar yang serupa jika salah satunya diputar, diskalakan, direntangkan, dan warna diubah di dalamnya.  Untungnya, wideNES tidak memerlukan fungsi hash yang kompleks karena setiap frame dijamin memiliki ukuran yang sama.  Oleh karena itu, wideNES menggunakan hash perceptual yang ada yang paling sederhana: <em>menjumlahkan semua piksel pada layar!</em> <br><br>  Ini sederhana, tetapi bekerja dengan cukup baik! <br><br>  Misalnya, lihat bagaimana transisi antar adegan menonjol jika Anda merencanakan hash perseptual dari waktu ke waktu dalam <em>The Legend of Zelda</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f07/799/5e3/f077995e3d509802139543805d7ae61b.png"></div><br>  Saat ini, wideNES menggunakan ambang batas tetap antara nilai hash perseptual untuk menyelesaikan transisi antara adegan, tetapi hasilnya jauh dari ideal.  Gim yang berbeda menggunakan palet yang berbeda, dan ada banyak kasus di mana wideNES berpikir bahwa transisi telah terjadi, tetapi kenyataannya tidak.  Idealnya, wideNES harus menggunakan nilai ambang batas dinamis, tetapi sejauh ini yang tetap akan dilakukan. <br><br>  Setelah menerapkan heuristik baru ini, wideNES berhasil mengenali pintu masuk Simon dari <em>Castlevania</em> ke kastil dan karenanya menciptakan kanvas baru. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/644/6da/e81/6446dae81018592433a99f4f50a8b4d0.gif"></div><br>  Dan dengan keputusan ini, kami menempatkan potongan besar terakhir dari puzzle wideNES. <br><br>  Setelah menerapkan serialisasi paling sederhana, saya akhirnya dapat menjalankan game untuk NES, bermain di beberapa level dan secara otomatis menghasilkan peta level! <br><br><h2>  Apa yang menanti wideNES di masa depan? </h2><br>  wideNES terdiri dari dua bagian yang terpisah: <em>kernel</em> wideNES, yang merupakan aturan / heuristik yang mendasari teknologi, dan implementasi spesifik dari wideNES di dalam emulator ANESE. <br><br><h3>  Peningkatan <em>inti</em> WideNES </h3><br>  Pertama, wideNES rentan terhadap pengenalan transisi yang terlalu agresif antar adegan.  Jumlah positif palsu dapat diminimalkan dengan menggunakan algoritma hashing persepsi yang lebih cocok atau dengan beralih ke nilai ambang batas dinamis antara hash persepsi. <br><br>  Pekerjaan tambahan juga diperlukan untuk mengenali elemen layar statis.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Misalnya, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Megaman IV</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memiliki IRQ di tengah frame, tetapi tidak ada bilah status, itulah sebabnya wideNES secara keliru mengabaikan bagian solid dari lapangan permainan. Meskipun kasus khusus ini dapat diperbaiki dengan penyetelan manual, lebih baik menggunakan heuristik yang lebih cerdas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beberapa game NES menggulir layar dengan cara "unik". Salah satu contoh yang paling terkenal adalah </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Legend of Zelda</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang menggunakan PPUSCROLL untuk gulir horizontal, tetapi menggunakan register yang sama sekali berbeda untuk gulir vertikal - PPUADDR. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zelda</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah game yang cukup populer, jadi wideNES mengimplementasikan heuristik khusus untuk </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zelda</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ada gim lain dengan mode gulir “unik” yang serupa, yang juga membutuhkan heuristik tersendiri. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akan bermanfaat untuk menemukan beberapa cara untuk "menjahit" adegan yang identik. Misalnya, jika pengguna memainkan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Super Mario Bros.</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Level 1, tetapi merangkak ke pipa untuk masuk ke gua bawah tanah dengan koin, wideNES akan membuat dua adegan terpisah untuk Level 1: adegan A, level sampai Mario memasuki zona dengan koin, dan adegan B, level, dari saat ini ketika Mario keluar dari pipa dan naik ke tiang bendera. Jika game kemudian dinyalakan kembali dan Level 1 diputar ulang </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tanpa</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> masuk ke dalam pipa, maka wideNES hanya akan memperbarui adegan A, yang akan berisi peta tingkat penuh, tetapi adegan B akan "putus".</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akhirnya, wideNES harus melacak transisi antar adegan. </font><font style="vertical-align: inherit;">Tanpa data ini, tidak akan mungkin untuk membuat grafik transisi antara adegan untuk menghasilkan peta dunia permainan yang </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> terdiri dari satu dunia besar.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Meningkatkan implementasi wideNES di ANESE </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat ini wideNES diimplementasikan hanya dalam emulator NES yang saya tulis dengan nama ANESE. ANESE adalah </font><font style="vertical-align: inherit;">emulator yang </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sangat</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sederhana: sebagian besar opsi disembunyikan di belakang flag CLI, dan satu-satunya UI yang diterapkan adalah overlay pemilihan file paling sederhana! Ia masih </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sangat</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jauh dari level "produksi". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terlepas dari kurangnya UI, ANESE dan wideNES, peningkatan kompatibilitas dan kecepatan tidak akan merugikan. ANESE adalah emulator pertama yang saya tulis, dan ini terlihat! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada beberapa masalah kompatibilitas di dalamnya - banyak game tidak bekerja dengan benar atau tidak memulai sama sekali. Untungnya, ketidaksempurnaan ANESE tidak berarti bahwa wideNES adalah teknologi yang buruk. wideNES dibangun di atas prinsip-prinsip terbukti yang akan mudah diimplementasikan di emulator lain!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam hal kecepatan, ANESE dan wideNES tidak sempurna, dan bahkan pada PC yang relatif kuat, kinerja kadang-kadang bisa turun di bawah 60fps! ANESE dan wideNES perlu mengimplementasikan banyak optimasi. Selain perbaikan umum dari kernel ANESE, ada kebutuhan untuk meningkatkan perekaman frame wideNES, rendering peta, dan pengambilan sampel hash.</font></font><br><br><h2>  Kesimpulan </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam artikel itu, saya berbicara tentang aspek-aspek utama wideNES, tetapi tidak dapat menjelaskan banyak fitur kecil. Misalnya, wideNES menyimpan peta nilai hash dan gulir sebenarnya dari setiap frame, yang digunakan untuk mengaktifkan adegan berulang. Ini dan banyak fitur lainnya dijelaskan dalam kode sumber yang dikomentari secara luas untuk wideNES, yang diposting pada </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">halaman proyek wideNES</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bekerja dengan wideNES adalah pengalaman yang benar-benar luar biasa, tetapi dengan pendekatan semester akademik baru di Waterloe University, saya ragu bahwa dalam waktu dekat saya akan dapat terus mengembangkan wideNES. Saat ini, fungsi utama wideNES sedang bekerja, dan saya senang saya bisa menulis posting ini menjelaskan beberapa teknologinya!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coba gunakan wideNES dan bagikan perasaan Anda! </font><font style="vertical-align: inherit;">Unduh </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ANESE</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , luncurkan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Super Mario Bros. </font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Legend of Zelda</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atau </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metroid</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan </font><em><font style="vertical-align: inherit;">mainkanlah</font></em><font style="vertical-align: inherit;"> dengan cara baru!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id421555/">https://habr.com/ru/post/id421555/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id421545/index.html">Ulasan PocketBook 616 - dompet 2018 paling hemat dengan fungsi backlight</a></li>
<li><a href="../id421547/index.html">Penerimaan Pusat Data Independen</a></li>
<li><a href="../id421549/index.html">Kami sedang menulis dokumentasi teknis: panduan untuk orang awam</a></li>
<li><a href="../id421551/index.html">Menguasai Vuex - Dari Nol ke Pahlawan</a></li>
<li><a href="../id421553/index.html">Kami berbagi konten teknologi: kami telah mengumpulkan semua materi kami di satu situs</a></li>
<li><a href="../id421557/index.html">Buka pelajaran "Pemrograman Asinkron di Jawa"</a></li>
<li><a href="../id421559/index.html">Arsitektur komponen UI dalam aplikasi iOS</a></li>
<li><a href="../id421561/index.html">12 pertanyaan tentang skuter yang tidak malu bertanya</a></li>
<li><a href="../id421563/index.html">Anda mungkin harus duduk dengan cara yang berbeda untuk menghilangkan sakit punggung.</a></li>
<li><a href="../id421565/index.html">Bagaimana robot humanoid yang kasar bisa menipu Anda</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>