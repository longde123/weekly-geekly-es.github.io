<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☔️ ☢️ 🈹 视频的人脸检测：Raspberry Pi和神经计算棒 ⬛️ 👇🏿 🧘🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="大约一年前， 英特尔Movidius发布了一种用于高效推理卷积神经网络的设备-Movidius神经计算棒（NCS）。 该设备允许使用神经网络在能耗有限的情况下（包括机器人任务）识别或检测物体。 NCS具有USB接口，功耗不超过1瓦。 在本文中，我将讨论将NCS与Raspberry Pi一起用于检测视...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>视频的人脸检测：Raspberry Pi和神经计算棒</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424973/"> 大约一年前， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">英特尔Movidius</a>发布了一种用于高效推理卷积神经网络的设备-Movidius神经计算棒（NCS）。 该设备允许使用神经网络在能耗有限的情况下（包括机器人任务）识别或检测物体。  NCS具有USB接口，功耗不超过1瓦。 在本文中，我将讨论将NCS与Raspberry Pi一起用于检测视频中人脸的经验，包括训练Mobilenet-SSD检测器并在Raspberry上启动它。 <br><br> 所有代码都可以在我的两个存储库中找到： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">探测器培训</a>和人<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">脸检测演示</a> 。 <br><br><img src="https://habrastorage.org/webt/qu/b_/tj/qub_tj1u6ztw9irfy9ivtaaidcc.jpeg"><br><a name="habracut"></a><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在我的第一篇文章中，</a>我已经写过有关使用NCS进行面部检测的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文章</a> ：然后我们谈论的是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">YOLOv2</a>检测器，我将其从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Darknet</a>格式转换为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Caffe</a>格式，然后在NCS上启动了它。 转换过程非常简单：由于这两种格式以不同的方式定义了检测器的最后一层，因此必须使用Darknet中的一段代码在CPU上分别解析神经网络的输出。 此外，该检测器在速度（笔记本电脑上高达5.1 FPS）和准确性上都不能令人满意-后来我确信，由于对图像质量敏感，因此很难从Raspberry Pi上获得好的结果。 <br><br> 最后，我决定只训练我的探测器。 选择权在于带有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Mobilenet</a>编码器的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SSD</a>检测器： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Mobilenet</a>的轻巧卷积使您能够在不损失质量的情况下实现高速传输，并且SSD检测器并不逊色于YOLO，并且可以开箱即用地用于NCS。 <br><br><div class="spoiler">  <b class="spoiler_title">Mobilenet-SSD检测器如何工作</b> <div class="spoiler_text"> 让我们从Mobilenet开始。 在此架构中完成 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mn" id="MJXp-Span-2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3 </font></font></span><span class="MJXp-mtext" id="MJXp-Span-3" style="color: red;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\乘</font></font></span><span class="MJXp-mn" id="MJXp-Span-4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.414ex" height="2.762ex" viewBox="0 -831.5 2331 1189" role="img" focusable="false" style="vertical-align: -0.83ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/424973/&amp;usg=ALkJrhjPKp9CF_6J4jqBdmzxkmnGeVDUog#MJMAIN-33" x="0" y="0"></use><g fill="red" stroke="red" transform="translate(500,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/424973/&amp;usg=ALkJrhjPKp9CF_6J4jqBdmzxkmnGeVDUog#MJMAIN-5C"></use><g transform="translate(500,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(59.251) matrix(1 0 0 -1 0 0)">乘</text></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/424973/&amp;usg=ALkJrhjPKp9CF_6J4jqBdmzxkmnGeVDUog#MJMAIN-33" x="1830" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1"> 3 \乘3 </script>  （在所有通道上）卷积被两个轻量级卷积代替：第一个 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-5"><span class="MJXp-mn" id="MJXp-Span-6"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3 </font></font></span><span class="MJXp-mtext" id="MJXp-Span-7" style="color: red;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\乘</font></font></span><span class="MJXp-mn" id="MJXp-Span-8"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.414ex" height="2.762ex" viewBox="0 -831.5 2331 1189" role="img" focusable="false" style="vertical-align: -0.83ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/424973/&amp;usg=ALkJrhjPKp9CF_6J4jqBdmzxkmnGeVDUog#MJMAIN-33" x="0" y="0"></use><g fill="red" stroke="red" transform="translate(500,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/424973/&amp;usg=ALkJrhjPKp9CF_6J4jqBdmzxkmnGeVDUog#MJMAIN-5C"></use><g transform="translate(500,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(59.251) matrix(1 0 0 -1 0 0)">乘</text></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/424973/&amp;usg=ALkJrhjPKp9CF_6J4jqBdmzxkmnGeVDUog#MJMAIN-33" x="1830" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-2"> 3 \乘3 </script> 分别为每个频道，然后完成 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-9"><span class="MJXp-mn" id="MJXp-Span-10"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><span class="MJXp-mtext" id="MJXp-Span-11" style="color: red;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\乘</font></font></span><span class="MJXp-mrow" id="MJXp-Span-12"><span class="MJXp-mo" id="MJXp-Span-13" style="margin-left: 0.278em; margin-right: 0.278em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以</font></font></span></span><span class="MJXp-mn" id="MJXp-Span-14"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="7.341ex" height="2.762ex" viewBox="0 -831.5 3160.5 1189" role="img" focusable="false" style="vertical-align: -0.83ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/424973/&amp;usg=ALkJrhjPKp9CF_6J4jqBdmzxkmnGeVDUog#MJMAIN-31" x="0" y="0"></use><g fill="red" stroke="red" transform="translate(500,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/424973/&amp;usg=ALkJrhjPKp9CF_6J4jqBdmzxkmnGeVDUog#MJMAIN-5C"></use><g transform="translate(500,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(59.251) matrix(1 0 0 -1 0 0)">乘</text></g></g><g transform="translate(1830,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(59.251) matrix(1 0 0 -1 0 0)">以</text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/424973/&amp;usg=ALkJrhjPKp9CF_6J4jqBdmzxkmnGeVDUog#MJMAIN-31" x="2660" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-3"> 1 \乘以1 </script> 卷积。 每次卷积后，将使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">BatchNorm</a>和非线性（ReLU）。 通常将接收图像作为输入的第一个网络卷积完成。 由于预测质量的略微下降，该体系结构可以显着降低计算的复杂性。 有一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">更高级的选项</a> ，但是我还没有尝试过。 <br><br>  SSD（单发检测器）的工作方式如下：两个输出挂在几个卷积编码器的输出上 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-15"><span class="MJXp-mn" id="MJXp-Span-16"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><span class="MJXp-mtext" id="MJXp-Span-17" style="color: red;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\乘</font></font></span><span class="MJXp-mrow" id="MJXp-Span-18"><span class="MJXp-mo" id="MJXp-Span-19" style="margin-left: 0.278em; margin-right: 0.278em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以</font></font></span></span><span class="MJXp-mn" id="MJXp-Span-20"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="7.341ex" height="2.762ex" viewBox="0 -831.5 3160.5 1189" role="img" focusable="false" style="vertical-align: -0.83ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/424973/&amp;usg=ALkJrhjPKp9CF_6J4jqBdmzxkmnGeVDUog#MJMAIN-31" x="0" y="0"></use><g fill="red" stroke="red" transform="translate(500,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/424973/&amp;usg=ALkJrhjPKp9CF_6J4jqBdmzxkmnGeVDUog#MJMAIN-5C"></use><g transform="translate(500,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(59.251) matrix(1 0 0 -1 0 0)">乘</text></g></g><g transform="translate(1830,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(59.251) matrix(1 0 0 -1 0 0)">以</text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/424973/&amp;usg=ALkJrhjPKp9CF_6J4jqBdmzxkmnGeVDUog#MJMAIN-31" x="2660" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-4"> 1 \乘以1 </script> 卷积层：一个预测类的概率，另一个-边界框的坐标。 第三层提供当前级别的默认帧的坐标和位置。 意思是：任何一层的输出自然地分为单元； 靠近神经网络的末端，它们变得越来越小（在这种情况下，由于<code>stride=2</code>的卷积），每个细胞的视野都增加了。 对于几个选定层中的每个层上的每个像元，我们设置了几个不同大小和长宽比的默认帧，并使用其他卷积层来校正坐标并预测每个此类帧的类概率。 因此，SSD检测器（如YOLO）始终考虑相同数量的帧。 可以在不同的层上检测到同一对象：在训练期间，信号被发送到与该对象非常相交的所有帧，并且在应用过程中，使用非最大抑制（NMS）组合检测。 最后一层结合了来自所有层的检测结果，考虑了它们的完整坐标，切断了概率阈值并产生了NMS。 <br></div></div><br><h2> 侦探训练 </h2><br><h3> 建筑学 </h3><br> 训练探测器的代码位于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a> 。 <br><br> 我决定使用在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PASCAL VOC0712</a>上训练有素的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">现成Mobilenet-SSD检测器</a> ，并训练它来检测人脸。 首先，它有助于更​​快地训练网络，其次，您无需重新发明轮子。 <br><br> 原始项目包括<code>gen.py</code>脚本，该脚本从字面上收集了<code>.prototxt</code>模型文件，并替换了输入参数。 我将其转移到我的项目中，从而扩展了功能。 该脚本允许您生成四种类型的配置文件： <br><br><ul><li>  <b>火车</b> ：在入口-一个训练的LMDB基础，在输出-一个具有损失函数及其梯度的计算层，其中有BatchNorm </li><li>  <b>test</b> ：在输入处-测试LMDB基础，在输出处-具有质量计算（平均平均精度）的层，存在BatchNorm </li><li>  <b>deploy</b> ：在输入-图像，在输出-带有预测的层，BatchNorm丢失 </li><li>  <b>deploy_bn</b> ：在输入-图像，在输出-具有预测的层，存在BatchNorm </li></ul><br> 稍后我添加了后一个选项，以便您可以在脚本中从BatchNorm加载并转换网格，而无需接触LMDB数据库-否则，在没有数据库的情况下，将无法进行任何操作。  （通常，在Caffe中，数据源是在网络体系结构中设置的，这对我来说似乎很奇怪-至少这不是很实际）。 <br><br><div class="spoiler">  <b class="spoiler_title">网络架构是什么样的（简短）</b> <div class="spoiler_text"><ul><li> 登录名： <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-21"><span class="MJXp-mn" id="MJXp-Span-22"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">300 </font></font></span><span class="MJXp-mtext" id="MJXp-Span-23" style="color: red;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\乘</font></font></span><span class="MJXp-mn" id="MJXp-Span-24"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">300 </font></font></span><span class="MJXp-mtext" id="MJXp-Span-25" style="color: red;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\乘</font></font></span><span class="MJXp-mn" id="MJXp-Span-26"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="14.315ex" height="2.762ex" viewBox="0 -831.5 6163.5 1189" role="img" focusable="false" style="vertical-align: -0.83ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/424973/&amp;usg=ALkJrhjPKp9CF_6J4jqBdmzxkmnGeVDUog#MJMAIN-33"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/424973/&amp;usg=ALkJrhjPKp9CF_6J4jqBdmzxkmnGeVDUog#MJMAIN-30" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/424973/&amp;usg=ALkJrhjPKp9CF_6J4jqBdmzxkmnGeVDUog#MJMAIN-30" x="1001" y="0"></use><g fill="red" stroke="red" transform="translate(1501,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/424973/&amp;usg=ALkJrhjPKp9CF_6J4jqBdmzxkmnGeVDUog#MJMAIN-5C"></use><g transform="translate(500,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(59.251) matrix(1 0 0 -1 0 0)">乘</text></g></g><g transform="translate(2831,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/424973/&amp;usg=ALkJrhjPKp9CF_6J4jqBdmzxkmnGeVDUog#MJMAIN-33"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/424973/&amp;usg=ALkJrhjPKp9CF_6J4jqBdmzxkmnGeVDUog#MJMAIN-30" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/424973/&amp;usg=ALkJrhjPKp9CF_6J4jqBdmzxkmnGeVDUog#MJMAIN-30" x="1001" y="0"></use></g><g fill="red" stroke="red" transform="translate(4333,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/424973/&amp;usg=ALkJrhjPKp9CF_6J4jqBdmzxkmnGeVDUog#MJMAIN-5C"></use><g transform="translate(500,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(59.251) matrix(1 0 0 -1 0 0)">乘</text></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/424973/&amp;usg=ALkJrhjPKp9CF_6J4jqBdmzxkmnGeVDUog#MJMAIN-33" x="5663" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-5"> 300 \乘300 \乘3 </script></li><li> 完全<b>转换转换</b> ：32个通道， <code>stride=2</code> </li><li>  Mobilenet卷积<b>conv1-conv11</b> ： <b>64、128、128、256、256、512</b> ... 512通道，其中一些<code>stride=2</code> </li><li> 检测层： <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-27"><span class="MJXp-mn" id="MJXp-Span-28"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">19 </font></font></span><span class="MJXp-mtext" id="MJXp-Span-29" style="color: red;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\乘</font></font></span><span class="MJXp-mrow" id="MJXp-Span-30"><span class="MJXp-mo" id="MJXp-Span-31" style="margin-left: 0.278em; margin-right: 0.278em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以</font></font></span></span><span class="MJXp-mn" id="MJXp-Span-32"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 19 </font></font></span><span class="MJXp-mtext" id="MJXp-Span-33" style="color: red;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\乘</font></font></span><span class="MJXp-mrow" id="MJXp-Span-34"><span class="MJXp-mo" id="MJXp-Span-35" style="margin-left: 0.278em; margin-right: 0.278em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以</font></font></span></span><span class="MJXp-mn" id="MJXp-Span-36"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 512</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="18.169ex" height="2.762ex" viewBox="0 -831.5 7822.5 1189" role="img" focusable="false" style="vertical-align: -0.83ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/424973/&amp;usg=ALkJrhjPKp9CF_6J4jqBdmzxkmnGeVDUog#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/424973/&amp;usg=ALkJrhjPKp9CF_6J4jqBdmzxkmnGeVDUog#MJMAIN-39" x="500" y="0"></use><g fill="red" stroke="red" transform="translate(1001,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/424973/&amp;usg=ALkJrhjPKp9CF_6J4jqBdmzxkmnGeVDUog#MJMAIN-5C"></use><g transform="translate(500,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(59.251) matrix(1 0 0 -1 0 0)">乘</text></g></g><g transform="translate(2331,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(59.251) matrix(1 0 0 -1 0 0)">以</text></g><g transform="translate(3160,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/424973/&amp;usg=ALkJrhjPKp9CF_6J4jqBdmzxkmnGeVDUog#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/424973/&amp;usg=ALkJrhjPKp9CF_6J4jqBdmzxkmnGeVDUog#MJMAIN-39" x="500" y="0"></use></g><g fill="red" stroke="red" transform="translate(4161,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/424973/&amp;usg=ALkJrhjPKp9CF_6J4jqBdmzxkmnGeVDUog#MJMAIN-5C"></use><g transform="translate(500,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(59.251) matrix(1 0 0 -1 0 0)">乘</text></g></g><g transform="translate(5491,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(59.251) matrix(1 0 0 -1 0 0)">以</text></g><g transform="translate(6321,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/424973/&amp;usg=ALkJrhjPKp9CF_6J4jqBdmzxkmnGeVDUog#MJMAIN-35"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/424973/&amp;usg=ALkJrhjPKp9CF_6J4jqBdmzxkmnGeVDUog#MJMAIN-31" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/424973/&amp;usg=ALkJrhjPKp9CF_6J4jqBdmzxkmnGeVDUog#MJMAIN-32" x="1001" y="0"></use></g></g></svg></span><script type="math/tex" id="MathJax-Element-6"> 19 \乘以19 \乘以512 </script></li><li>  Mobilenet卷积<b>conv12，conv13</b> ：1024个通道， <b>conv12的</b> <code>stride=2</code> </li><li> 检测层： <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-37"><span class="MJXp-mn" id="MJXp-Span-38"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10 </font></font></span><span class="MJXp-mtext" id="MJXp-Span-39" style="color: red;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\乘</font></font></span><span class="MJXp-mrow" id="MJXp-Span-40"><span class="MJXp-mo" id="MJXp-Span-41" style="margin-left: 0.278em; margin-right: 0.278em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以</font></font></span></span><span class="MJXp-mn" id="MJXp-Span-42"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10 </font></font></span><span class="MJXp-mtext" id="MJXp-Span-43" style="color: red;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\乘</font></font></span><span class="MJXp-mrow" id="MJXp-Span-44"><span class="MJXp-mo" id="MJXp-Span-45" style="margin-left: 0.278em; margin-right: 0.278em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以</font></font></span></span><span class="MJXp-mn" id="MJXp-Span-46"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1024</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="19.331ex" height="2.762ex" viewBox="0 -831.5 8323 1189" role="img" focusable="false" style="vertical-align: -0.83ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/424973/&amp;usg=ALkJrhjPKp9CF_6J4jqBdmzxkmnGeVDUog#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/424973/&amp;usg=ALkJrhjPKp9CF_6J4jqBdmzxkmnGeVDUog#MJMAIN-30" x="500" y="0"></use><g fill="red" stroke="red" transform="translate(1001,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/424973/&amp;usg=ALkJrhjPKp9CF_6J4jqBdmzxkmnGeVDUog#MJMAIN-5C"></use><g transform="translate(500,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(59.251) matrix(1 0 0 -1 0 0)">乘</text></g></g><g transform="translate(2331,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(59.251) matrix(1 0 0 -1 0 0)">以</text></g><g transform="translate(3160,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/424973/&amp;usg=ALkJrhjPKp9CF_6J4jqBdmzxkmnGeVDUog#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/424973/&amp;usg=ALkJrhjPKp9CF_6J4jqBdmzxkmnGeVDUog#MJMAIN-30" x="500" y="0"></use></g><g fill="red" stroke="red" transform="translate(4161,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/424973/&amp;usg=ALkJrhjPKp9CF_6J4jqBdmzxkmnGeVDUog#MJMAIN-5C"></use><g transform="translate(500,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(59.251) matrix(1 0 0 -1 0 0)">乘</text></g></g><g transform="translate(5491,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(59.251) matrix(1 0 0 -1 0 0)">以</text></g><g transform="translate(6321,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/424973/&amp;usg=ALkJrhjPKp9CF_6J4jqBdmzxkmnGeVDUog#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/424973/&amp;usg=ALkJrhjPKp9CF_6J4jqBdmzxkmnGeVDUog#MJMAIN-30" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/424973/&amp;usg=ALkJrhjPKp9CF_6J4jqBdmzxkmnGeVDUog#MJMAIN-32" x="1001" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/424973/&amp;usg=ALkJrhjPKp9CF_6J4jqBdmzxkmnGeVDUog#MJMAIN-34" x="1501" y="0"></use></g></g></svg></span><script type="math/tex" id="MathJax-Element-7"> 10 \乘以10 \乘以1024 </script></li><li> 全卷积<b>conv14_1，conv14_2</b> ： <b>256，512</b>通道，第一个<code>kernel_size=1</code> ，第二个<code>stride=2</code> </li><li> 检测层： <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-47"><span class="MJXp-mn" id="MJXp-Span-48"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5 </font></font></span><span class="MJXp-mtext" id="MJXp-Span-49" style="color: red;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\乘</font></font></span><span class="MJXp-mn" id="MJXp-Span-50"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5 </font></font></span><span class="MJXp-mtext" id="MJXp-Span-51" style="color: red;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\乘</font></font></span><span class="MJXp-mn" id="MJXp-Span-52"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">512</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="11.99ex" height="2.762ex" viewBox="0 -831.5 5162.5 1189" role="img" focusable="false" style="vertical-align: -0.83ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/424973/&amp;usg=ALkJrhjPKp9CF_6J4jqBdmzxkmnGeVDUog#MJMAIN-35" x="0" y="0"></use><g fill="red" stroke="red" transform="translate(500,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/424973/&amp;usg=ALkJrhjPKp9CF_6J4jqBdmzxkmnGeVDUog#MJMAIN-5C"></use><g transform="translate(500,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(59.251) matrix(1 0 0 -1 0 0)">乘</text></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/424973/&amp;usg=ALkJrhjPKp9CF_6J4jqBdmzxkmnGeVDUog#MJMAIN-35" x="1830" y="0"></use><g fill="red" stroke="red" transform="translate(2331,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/424973/&amp;usg=ALkJrhjPKp9CF_6J4jqBdmzxkmnGeVDUog#MJMAIN-5C"></use><g transform="translate(500,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(59.251) matrix(1 0 0 -1 0 0)">乘</text></g></g><g transform="translate(3661,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/424973/&amp;usg=ALkJrhjPKp9CF_6J4jqBdmzxkmnGeVDUog#MJMAIN-35"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/424973/&amp;usg=ALkJrhjPKp9CF_6J4jqBdmzxkmnGeVDUog#MJMAIN-31" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/424973/&amp;usg=ALkJrhjPKp9CF_6J4jqBdmzxkmnGeVDUog#MJMAIN-32" x="1001" y="0"></use></g></g></svg></span><script type="math/tex" id="MathJax-Element-8"> 5 \乘5 \乘512 </script></li><li> 全卷积<b>conv15_1，conv15_2</b> ： <b>128，256</b>通道，第一个<code>kernel_size=1</code> ，第二个<code>stride=2</code> </li><li> 检测层： <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-53"><span class="MJXp-mn" id="MJXp-Span-54"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3 </font></font></span><span class="MJXp-mtext" id="MJXp-Span-55" style="color: red;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\乘</font></font></span><span class="MJXp-mn" id="MJXp-Span-56"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3 </font></font></span><span class="MJXp-mtext" id="MJXp-Span-57" style="color: red;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\乘</font></font></span><span class="MJXp-mn" id="MJXp-Span-58"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">256</font></font></span></span></span><script type="math/tex" id="MathJax-Element-9"> 3 \乘3 \乘256 </script></li><li> 完成<b>conv16_1，conv16_2卷积</b> ： <b>128、256个</b>通道，第一个<code>kernel_size=1</code> ，第二个<code>stride=2</code> </li><li> 检测层： <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-59"><span class="MJXp-mn" id="MJXp-Span-60"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font></span><span class="MJXp-mtext" id="MJXp-Span-61" style="color: red;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\乘</font></font></span><span class="MJXp-mrow" id="MJXp-Span-62"><span class="MJXp-mo" id="MJXp-Span-63" style="margin-left: 0.278em; margin-right: 0.278em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以</font></font></span></span><span class="MJXp-mn" id="MJXp-Span-64"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2 </font></font></span><span class="MJXp-mtext" id="MJXp-Span-65" style="color: red;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\乘</font></font></span><span class="MJXp-mrow" id="MJXp-Span-66"><span class="MJXp-mo" id="MJXp-Span-67" style="margin-left: 0.278em; margin-right: 0.278em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以</font></font></span></span><span class="MJXp-mn" id="MJXp-Span-68"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 256</font></font></span></span></span><script type="math/tex" id="MathJax-Element-10"> 2 \乘以2 \乘以256 </script></li><li> 全卷积<b>conv17_1，conv17_2</b> ：64，128通道，第一个<code>kernel_size=1</code> ，第二个<code>stride=2</code> </li><li> 检测层： <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-69"><span class="MJXp-mn" id="MJXp-Span-70"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><span class="MJXp-mtext" id="MJXp-Span-71" style="color: red;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\乘</font></font></span><span class="MJXp-mrow" id="MJXp-Span-72"><span class="MJXp-mo" id="MJXp-Span-73" style="margin-left: 0.278em; margin-right: 0.278em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以</font></font></span></span><span class="MJXp-mn" id="MJXp-Span-74"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1 </font></font></span><span class="MJXp-mtext" id="MJXp-Span-75" style="color: red;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\乘</font></font></span><span class="MJXp-mrow" id="MJXp-Span-76"><span class="MJXp-mo" id="MJXp-Span-77" style="margin-left: 0.278em; margin-right: 0.278em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以</font></font></span></span><span class="MJXp-mn" id="MJXp-Span-78"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 128</font></font></span></span></span><script type="math/tex" id="MathJax-Element-11"> 1 \乘以1 \乘以128 </script></li><li> 最后一层检测输出 </li></ul><br></div></div><br> 我稍微纠正了网络体系结构。 变更清单： <br><br><ul><li> 显然，类的数量已更改为1（不计算背景）。 </li><li> 训练过程中切块的长宽比限制：从 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-79"><span class="MJXp-mo" id="MJXp-Span-80" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-mn" id="MJXp-Span-81">0.5</span><span class="MJXp-mo" id="MJXp-Span-82" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mn" id="MJXp-Span-83">2.0</span><span class="MJXp-mo" id="MJXp-Span-84" style="margin-left: 0em; margin-right: 0em;">]</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-12-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-12"> [0.5,2.0] </script> 在 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-85"><span class="MJXp-mo" id="MJXp-Span-86" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-mn" id="MJXp-Span-87">0.7</span><span class="MJXp-mo" id="MJXp-Span-88" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mn" id="MJXp-Span-89">1.4</span><span class="MJXp-mo" id="MJXp-Span-90" style="margin-left: 0em; margin-right: 0em;">]</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-13-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-13"> [0.7,1.4] </script>  （我决定稍微简化一下任务，而不是从拉伸的图片中学习）。 </li><li> 在默认帧中，仅剩下方形帧，每个单元格两个。 我大大减小了它们的尺寸，因为在经典的物体检测问题中，人脸明显小于物体。 </li></ul><br>  Caffe计算默认框架尺寸如下：具有最小框架尺寸 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-91"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-92">s</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-14-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-14"> s </script> 和最大 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-93"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-94">L</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-15-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-15"> L </script>  ，它会创建一个尺寸较大的框架 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-95"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-96">s</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-16-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-16"> s </script> 和 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-97"><span class="MJXp-mtext" id="MJXp-Span-98">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-99">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-100">q</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-101">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-102">t</span><span class="MJXp-mrow" id="MJXp-Span-103"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-104">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-105">L</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-17-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-17"> \ sqrt {sL} </script>  。 由于我想检测尽可能小的脸部，因此我为每个检测层计算了全<code>stride</code> ，并将最小帧大小与其等效。 使用这些参数，小的默认框架将彼此靠近放置并且不会相交。 因此，我们至少可以保证对于某种框架，将存在与对象的交集。 我将最大尺寸设置为两倍。 对于<b>conv16_2，conv17_2</b>层<b>，</b>我将眼睛的尺寸设置为相同。 这样 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-106"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-107">s</span><span class="MJXp-mrow" id="MJXp-Span-108"><span class="MJXp-mo" id="MJXp-Span-109" style="margin-left: 0.278em; margin-right: 0.278em;">，</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-110">L</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-18-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-18"> s，L </script> 对于所有层是： <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-111"><span class="MJXp-mrow" id="MJXp-Span-112"><span class="MJXp-mo" id="MJXp-Span-113" style="margin-left: 0.278em; margin-right: 0.278em;">（</span></span><span class="MJXp-mn" id="MJXp-Span-114">16.32</span><span class="MJXp-mrow" id="MJXp-Span-115"><span class="MJXp-mo" id="MJXp-Span-116" style="margin-left: 0.278em; margin-right: 0.278em;">）</span></span><span class="MJXp-mrow" id="MJXp-Span-117"><span class="MJXp-mo" id="MJXp-Span-118" style="margin-left: 0.278em; margin-right: 0.278em;">，</span></span><span class="MJXp-mrow" id="MJXp-Span-119"><span class="MJXp-mo" id="MJXp-Span-120" style="margin-left: 0.278em; margin-right: 0.278em;">（</span></span><span class="MJXp-mn" id="MJXp-Span-121">32.64</span><span class="MJXp-mrow" id="MJXp-Span-122"><span class="MJXp-mo" id="MJXp-Span-123" style="margin-left: 0.278em; margin-right: 0.278em;">）</span></span><span class="MJXp-mrow" id="MJXp-Span-124"><span class="MJXp-mo" id="MJXp-Span-125" style="margin-left: 0.278em; margin-right: 0.278em;">，</span></span><span class="MJXp-mrow" id="MJXp-Span-126"><span class="MJXp-mo" id="MJXp-Span-127" style="margin-left: 0.278em; margin-right: 0.278em;">（</span></span><span class="MJXp-mn" id="MJXp-Span-128">64</span><span class="MJXp-mo" id="MJXp-Span-129" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mn" id="MJXp-Span-130">128</span><span class="MJXp-mrow" id="MJXp-Span-131"><span class="MJXp-mo" id="MJXp-Span-132" style="margin-left: 0.278em; margin-right: 0.278em;">）</span></span><span class="MJXp-mrow" id="MJXp-Span-133"><span class="MJXp-mo" id="MJXp-Span-134" style="margin-left: 0.278em; margin-right: 0.278em;">，</span></span><span class="MJXp-mrow" id="MJXp-Span-135"><span class="MJXp-mo" id="MJXp-Span-136" style="margin-left: 0.278em; margin-right: 0.278em;">（</span></span><span class="MJXp-mn" id="MJXp-Span-137">128</span><span class="MJXp-mo" id="MJXp-Span-138" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mn" id="MJXp-Span-139">214</span><span class="MJXp-mrow" id="MJXp-Span-140"><span class="MJXp-mo" id="MJXp-Span-141" style="margin-left: 0.278em; margin-right: 0.278em;">）</span></span><span class="MJXp-mrow" id="MJXp-Span-142"><span class="MJXp-mo" id="MJXp-Span-143" style="margin-left: 0.278em; margin-right: 0.278em;">，</span></span><span class="MJXp-mrow" id="MJXp-Span-144"><span class="MJXp-mo" id="MJXp-Span-145" style="margin-left: 0.278em; margin-right: 0.278em;">（</span></span><span class="MJXp-mn" id="MJXp-Span-146">214</span><span class="MJXp-mo" id="MJXp-Span-147" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mn" id="MJXp-Span-148">300</span><span class="MJXp-mrow" id="MJXp-Span-149"><span class="MJXp-mo" id="MJXp-Span-150" style="margin-left: 0.278em; margin-right: 0.278em;">）</span></span><span class="MJXp-mrow" id="MJXp-Span-151"><span class="MJXp-mo" id="MJXp-Span-152" style="margin-left: 0.278em; margin-right: 0.278em;">，</span></span><span class="MJXp-mrow" id="MJXp-Span-153"><span class="MJXp-mo" id="MJXp-Span-154" style="margin-left: 0.278em; margin-right: 0.278em;">（</span></span><span class="MJXp-mn" id="MJXp-Span-155">214</span><span class="MJXp-mo" id="MJXp-Span-156" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mn" id="MJXp-Span-157">300</span><span class="MJXp-mrow" id="MJXp-Span-158"><span class="MJXp-mo" id="MJXp-Span-159" style="margin-left: 0.278em; margin-right: 0.278em;">）</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-19-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-19">（16.32），（32.64），（64,128），（128,214），（214,300），（214,300）</script><br><br><div class="spoiler">  <b class="spoiler_title">某些默认帧的外观（为清晰起见有噪声）</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/j9/ti/gj/j9tigjn9tq7sdz6m3tyxa1v2r9s.png"><br></div></div><br><h3> 资料 </h3><br> 我使用了两个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">数据集</a> ： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WIDER Face</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FDDB</a> 。  WIDER包含许多带有非常小且模糊的面部的图片，并且FDDB更倾向于较大的面部图像（并且比WIDER小一个数量级）。 它们中的注释格式略有不同，但是这些已经是详细信息。 <br><br> 我并没有使用所有数据进行训练：我丢出了太小的面孔（少于6个像素或少于图像宽度的2％），丢出了所有纵横比小于0.5或大于2的图片，丢掉了WIDER数据集中所有标记为“模糊”的图片，因为它们大部分对应于非常小的人，所以我至少必须以某种方式调整大小脸的比例。 在那之后，我使所有框架都变成正方形，并扩大了最小的一面：我决定对面部比例不是很感兴趣，并且神经网络的任务也得到了简化。 我还丢掉了所有的黑白图片，这些图片很少，数据库构建脚本也因此崩溃了。 <br><br> 要使用它们进行培训和测试，您需要从它们组装一个LMDB基础。 怎么做： <br><br><ul><li> 对于每个图像，将以<code>.xml</code>格式创建标记。 </li><li>  <code>train.txt</code>的<code>train.txt</code>文件的格式为<code>"path/to/image.png path/to/labels.xml"</code> ，并创建了相同的测试文件。 </li><li> 使用格式为<code>"test_image_name height width"</code>行<code>test_name_size.txt</code>一个<code>test_name_size.txt</code>文件。 </li><li> 创建具有数字<code>labelmap.prototxt</code>匹配项的<code>labelmap.prototxt</code>文件 </li></ul><br><br>  <code>ssd-caffe/scripts/create_annoset.py</code> （来自Makefile的示例）： <br><br><pre> <code class="bash hljs">python3 /opt/movidius/ssd-caffe/scripts/create_annoset.py --anno-type=detection \ --label-map-file=$(wider_dir)/labelmap.prototxt --min-dim=0 --max-dim=0 \ --resize-width=0 --resize-height=0 --check-label --encode-type=jpg --encoded \ --redo $(wider_dir) \ $(wider_dir)/trainval.txt $(wider_dir)/WIDER_train/lmdb/wider_train_lmdb ./data</code> </pre><br><div class="spoiler">  <b class="spoiler_title">labelmap.prototxt</b> <div class="spoiler_text"><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">item</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">name</span></span>: <span class="hljs-string"><span class="hljs-string">"none_of_the_above"</span></span> label: <span class="hljs-number"><span class="hljs-number">0</span></span> display_name: <span class="hljs-string"><span class="hljs-string">"background"</span></span> } <span class="hljs-selector-tag"><span class="hljs-selector-tag">item</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">name</span></span>: <span class="hljs-string"><span class="hljs-string">"face"</span></span> label: <span class="hljs-number"><span class="hljs-number">1</span></span> display_name: <span class="hljs-string"><span class="hljs-string">"face"</span></span> }</code> </pre><br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">示例.xml标记</b> <div class="spoiler_text"><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?xml version="1.0" ?&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">annotation</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">size</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">width</span></span></span><span class="hljs-tag">&gt;</span></span>348<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">width</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">height</span></span></span><span class="hljs-tag">&gt;</span></span>450<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">height</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">depth</span></span></span><span class="hljs-tag">&gt;</span></span>3<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">depth</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">size</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">object</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span>face<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bndbox</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">xmin</span></span></span><span class="hljs-tag">&gt;</span></span>161<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">xmin</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ymin</span></span></span><span class="hljs-tag">&gt;</span></span>43<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ymin</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">xmax</span></span></span><span class="hljs-tag">&gt;</span></span>241<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">xmax</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ymax</span></span></span><span class="hljs-tag">&gt;</span></span>123<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ymax</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bndbox</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">object</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">annotation</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br></div></div><br> 同时使用两个数据集仅意味着您需要成对地仔细合并相应的文件，而不要忘记正确地注册路径以及将文件改组以进行训练。 <br><br> 之后，您可以开始训练。 <br><br><h3> 培训课程 </h3><br> 在我的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Colab Notebook中</a>可以找到模型训练的代码。 <br><br> 我在Google Colaboratory进行了培训，因为我的笔记本电脑几乎没有进行网格测试，并且通常都挂断了培训。 合作使我能够足够快速且免费地训练网络。 唯一要注意的是，我必须为Colaboratory编写一个SSD-Caffe编译脚本（包括诸如重新编译boost和编辑源代码之类的奇怪事情），这大约需要40分钟。 更多细节可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在我以前的出版物中</a>找到。 <br><br> 合作实验室还有一个功能：12小时后，汽车死亡，永久删除所有数据。 避免数据丢失的最好方法是每500-1000次训练迭代将Google磁盘安装到系统中并在其中节省网络权重。 <br><br> 至于我的检测器，在Colaboratory的一个会议中他设法取消了4,500次迭代，并在两个会议中接受了全面的培训。 <br><br> 对于最佳模型，我强调的测试数据集的预测质量（平均平均精度）（具有上述限制的WIDER和FDDB合并）约为0.87。 为了按照训练期间保存的比例测量mAP，有一个脚本<code>scripts/plot_map.py</code> 。 <br><br> 检测器处理数据集中的一个（非常奇怪的）示例： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nw/kc/jy/nwkcjyrtsz09v2fivdbs4uny3lc.png" width="60%"></div><br><h2> 在NCS上启动 </h2><br> 人脸检测演示在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a> 。 <br><br> 要为Neural Compute Stick编译神经网络，您需要<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Movidius NCSDK</a> ：它包含用于编译和分析神经网络的实用程序，以及C ++和Python API。 值得注意的是，第二个版本是最近发布的，它与第一个版本不兼容：由于某些原因，所有API函数都被重命名，神经网络的内部格式已更改，添加了FIFO以与NCS交互，并且（最终）自动从float 32位转换为float 16位，这在C ++中是非常缺乏的。 我将所有项目都更新为第二个版本，但保留了一些拐杖以确保与第一个版本兼容。 <br><br> 训练完检测器后，值得将BatchNorm层与相邻的卷积合并以加速神经网络。  <code>merge_bn.py</code>脚本<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">从这里开始</a> ，我也是从Mobilenet-SSD项目借来的。 <br><br> 然后，您需要调用<code>mvNCCompile</code>实用程序，例如： <br><br><pre> <code class="bash hljs">mvNCCompile -s 12 -o graph_ssd -w ssd-face.caffemodel ssd-face.prototxt</code> </pre><br> 项目的Makefile中有一个<code>graph_ssd</code>目标。 生成的<code>graph_ssd</code>文件是NCS可以理解的格式的神经网络描述。 <br><br> 现在介绍如何与设备本身进行交互。 该过程不是很复杂，但是需要相当大量的代码。 操作顺序大致如下： <br><br><ul><li> 通过序列号获取设备描述符 </li><li> 开启装置 </li><li> 将编译后的神经网络文件读取到缓冲区（作为二进制文件） </li><li> 为NCS创建一个空的计算图 </li><li> 使用文件中的数据将图形放置在设备上，并在输入/输出上为其选择FIFO； 现在可以释放带有文件内容的缓冲区 </li><li> 检测器启动： <br><ul><li> 从相机（或任何其他来源）获取图像 </li><li> 处理：将其缩放为所需的大小，转换为float32并转换为[-1,1]范围 </li><li> 将图像上传到设备并请求推理 </li><li> 请求结果（程序将被阻止，直到收到结果为止） </li><li> 解析结果，选择对象的框架（关于格式-进一步） </li><li> 显示预测 </li></ul><br></li><li> 释放所有资源：删除FIFO和计算图，关闭设备并删除其句柄 </li></ul><br> 几乎所有使用NCS的操作都有其自己的独立功能，在C ++中，它看起来非常繁琐，您必须仔细监视所有资源的释放。 为了不重载代码，我创建<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">了一个包装器类以与NCS一起使用</a> 。 在其中，所有初始化工作都隐藏在构造函数和<code>load_file</code>函数中，并且在释放资源时（在析构函数中）隐藏，使用NCS的工作减少为调用2-3个类方法。 另外，还有一个方便的功能可以解释发生的错误。 <br><br> 通过将输入大小和输出大小（元素数）传递给构造函数来创建包装器： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NCSWrapper </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NCS</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(NETWORK_INPUT_SIZE*NETWORK_INPUT_SIZE*</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">, NETWORK_OUTPUT_SIZE)</span></span></span></span>;</code> </pre><br> 我们用神经网络加载编译后的文件，同时初始化我们需要的所有内容： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!NCS.load_file(<span class="hljs-string"><span class="hljs-string">"./models/face/graph_ssd"</span></span>)) { NCS.print_error_code(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br> 我们将图像转换为float32（ <code>image</code>为<code>cv::Mat</code> ，格式为<code>CV_32FC3</code> ）并将其下载到设备： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!NCS.load_tensor_nowait((<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>*)image.data)) { NCS.print_error_code(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre><br> 我们得到结果（ <code>result</code>是一个自由<code>float</code>指针，结果缓冲区由包装器支持）； 直到计算完成，程序才被阻止： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!NCS.get_result(result)) { NCS.print_error_code(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre><br> 实际上，包装器还具有一种允许您同时加载数据和获取结果的方法： <code>load_tensor((float*)image.data, result)</code> 。 我拒绝使用它是有原因的：使用单独的方法，可以稍微加快代码执行速度。 加载映像后，CPU将一直处于空闲状态，直到使用NCS执行结果为止（在这种情况下，约为100毫秒），此时您可以做一些有用的工作：读取一个新帧并将其转换，并显示以前的检测结果。 这就是演示程序的实现方式，在我看来，它会稍微提高FPS。 您可以走得更远，并在两个不同的流中异步启动图像处理和面部检测器-这确实有效，并且可以加快速度，但是在演示程序中未实现。 <br><br> 结果，检测器返回大小为<code>7*(keep_top_k+1)</code>的float数组。 在这里， <code>keep_top_k</code>是在模型的<code>.prototxt</code>文件中指定的参数，并显示应返回多少次检测（以置信度递减的顺序）。 可以在最后一层的模型<code>.prototxt</code>文件中配置此参数以及负责按最小置信度值过滤检测的参数和非最大抑制参数。 值得注意的是，如果Caffe返回的检测数量与图像中找到的检测数量相同，则NCS始终返回检测的<code>keep_top_k</code>以便数组大小恒定。 <br><br> 结果数组本身的组织方式如下：如果我们将其视为具有<code>keep_top_k+1</code>行和7列的矩阵，则在第一行中，第一个元素中将有检测次数，从第二行开始，将以<code>"garbage, class_index, class_probability, x_min, y_min, x_max, y_max"</code>的格式进行检测<code>"garbage, class_index, class_probability, x_min, y_min, x_max, y_max"</code> 。 坐标在[0,1]范围内指定，因此需要将其乘以图片的高度/宽度。 数组的其余元素将是垃圾。 在这种情况下，即使在获得结果之前（似乎恰好在NCS上），也会自动执行非最大抑制。 <br><br><div class="spoiler">  <b class="spoiler_title">检测器解析</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_detection_boxes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">* predictions, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> w, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> h, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> thresh, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; probs, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;cv::Rect&gt;&amp; boxes)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num = predictions[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> score = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cls = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">1</span></span>; i&lt;num+<span class="hljs-number"><span class="hljs-number">1</span></span>; i++) { score = predictions[i*<span class="hljs-number"><span class="hljs-number">7</span></span>+<span class="hljs-number"><span class="hljs-number">2</span></span>]; cls = predictions[i*<span class="hljs-number"><span class="hljs-number">7</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (score&gt;thresh &amp;&amp; cls&lt;=<span class="hljs-number"><span class="hljs-number">1</span></span>) { probs.push_back(score); boxes.push_back(Rect(predictions[i*<span class="hljs-number"><span class="hljs-number">7</span></span>+<span class="hljs-number"><span class="hljs-number">3</span></span>]*w, predictions[i*<span class="hljs-number"><span class="hljs-number">7</span></span>+<span class="hljs-number"><span class="hljs-number">4</span></span>]*h, (predictions[i*<span class="hljs-number"><span class="hljs-number">7</span></span>+<span class="hljs-number"><span class="hljs-number">5</span></span>]-predictions[i*<span class="hljs-number"><span class="hljs-number">7</span></span>+<span class="hljs-number"><span class="hljs-number">3</span></span>])*w, (predictions[i*<span class="hljs-number"><span class="hljs-number">7</span></span>+<span class="hljs-number"><span class="hljs-number">6</span></span>]-predictions[i*<span class="hljs-number"><span class="hljs-number">7</span></span>+<span class="hljs-number"><span class="hljs-number">4</span></span>])*h)); } } }</code> </pre><br></div></div><br><h2>  Raspberry Pi启动功能 </h2><br> 该演示程序本身可以在具有Ubuntu的常规计算机或便携式计算机上运行，​​或在具有Raspbian Stretch的Raspberry Pi上运行。 我正在使用Raspberry Pi 2 B型，但该演示也应在其他型号上运行。 该项目的makefile包含两个用于切换模式的目标： <code>make switch_desk</code>用于计算机/笔记本电脑，以及<code>make switch_rpi</code>用于Raspberry Pi。 程序代码的根本区别在于，在第一种情况下，OpenCV用于从相机读取数据，在第二种情况下，使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RaspiCam</a>库。 要在Raspberry上运行演示，您必须编译并安装它。 <br><br> 现在很重要的一点：安装NCSDK。 如果您遵循Raspberry Pi上的标准安装说明，它将不会有任何好处：安装程序将尝试拖动并编译SSD-Caffe和Tensorflow。 相反，NCSDK需要<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在仅API模式下</a>进行<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">编译</a> 。 在这种模式下，只有C ++和Python API可用（也就是说，将无法编译和分析神经网络图）。 这意味着必须首先在常规计算机上编译神经网络图，然后将其复制到Raspberry。 为了方便起见，我向存储库添加了两个编译文件，分别是YOLO和SSD。 <br><br> 另一个有趣的地方是NCS与Raspberry的纯粹物理连接。 将它连接到USB连接器似乎并不难，但是您需要记住，它的外壳会阻塞其他三个连接器（它非常健康，因为它可以充当散热器）。 最简单的方法是通过USB电缆连接。 <br><br> 还需要牢记的是，不同版本的USB的执行速度会有所不同（对于该特定的神经网络：USB 3.0为102毫秒，USB 2.0为92毫秒）。 <br><br> 现在介绍NCS的功能。 根据文档，它消耗的功率高达1瓦（在USB连接器上为5伏时，它将高达200毫安；相比之下：Raspberry相机的最大消耗为250毫安）。 当使用2安培的常规5伏充电器供电时，一切正常。 但是，尝试将两个或多个NCS连接到Raspberry可能会导致问题。 在这种情况下，建议使用带有外部电源的USB分配器。 <br><br> 在Raspberry上，演示速度比在计算机/笔记本电脑上慢：7.2 FPS对10.4 FPS。 这是由于几个因素造成的：首先，无法摆脱CPU上的计算，但执行速度要慢得多。 其次，数据传输速度会影响（对于USB 2.0）。 <br><br> 另外，为了进行比较，我在第一篇文章中尝试在Raspberry YOLOv2上运行人脸检测器，但是效果很差：以3.6 FPS的速度，即使在简单的框架上，它也遗漏了很多人脸。 显然，它对输入图像的参数非常敏感，在Raspberry相机的情况下其质量远非理想。 尽管我不得不稍微调整RapiCam设置中的视频设置，但SSD的工作稳定得多。 他有时还会错过框架中的面孔，但是很少这样做。 为了增加实际应用中的稳定性，您可以添加一个简单的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">质心跟踪器</a> 。 <br><br> 顺便说一句：可以在Python中复制相同的内容，有一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">关于PyImageSearch</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">教程</a> （Mobilenet-SSD用于对象检测任务）。 <br><br><h4> 其他想法 </h4><br> 我还测试了一些想法来加速神经网络本身： <br><br> 第一个想法：您只能保留对<code>conv11</code>和<code>conv13</code>层的检测，并删除所有多余的层。 您将获得一个检测器，该检测器只能检测小脸并且工作更快。 总而言之，不值得。 <br><br> 第二个想法很有趣，但是没有用：我试图从权重接近零的神经网络中抛出卷积，希望它会变得更快。 但是，这种卷积很少，除去它们只会使神经网络稍慢一点（唯一的预感：这是由于通道数不再是2的幂的事实）。 <br><br><h2> 结论 </h2><br> 作为机器人项目的子任务，我想了很长时间在Raspberry上检测人脸。 我在速度和质量方面不喜欢经典的检测器，因此决定尝试神经网络方法，同时测试Neural Compute Stick，其结果是在GitHub上有两个项目，在Habré上有三篇文章（包括当前的一篇）。 通常，结果适合我-最有可能的是，我将在机器人中使用此检测器（也许还会有另一篇文章）。 值得注意的是，我的解决方案可能不是最佳的-尽管如此，这是一个培训项目，部分原因是出于对NCS的好奇心。 尽管如此，我希望本文对某人有用。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN424973/">https://habr.com/ru/post/zh-CN424973/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN424963/index.html">扎克伯格资助：共同构建科学工具</a></li>
<li><a href="../zh-CN424965/index.html">使用ReasonReact进行应用程序开发</a></li>
<li><a href="../zh-CN424967/index.html">面向初学者的JavaScript快捷方式</a></li>
<li><a href="../zh-CN424969/index.html">Node.js指南，第9部分：使用文件系统</a></li>
<li><a href="../zh-CN424971/index.html">Habrokast“手动日落”＃1。 尝试建立用于开发Windows玩具的环境</a></li>
<li><a href="../zh-CN424975/index.html">SIEM深度：现成的相关性。 第2部分。数据模式反映“世界”模型</a></li>
<li><a href="../zh-CN424977/index.html">从错误中学习：优化App Store和Google Play上的应用程序</a></li>
<li><a href="../zh-CN424979/index.html">榆树 舒适而笨拙。 Http，任务</a></li>
<li><a href="../zh-CN424981/index.html">Google搜索引擎代码中的Easter Egg Text RPG</a></li>
<li><a href="../zh-CN424985/index.html">在重要的司法先例中，美国情报机构无法窃听信使中的电话</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>