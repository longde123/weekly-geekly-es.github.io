<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüë©‚Äçüëß üåØ ‚öîÔ∏è Recursos do uso do tipo de dados Symbol em JavaScript ‚ùï üå¶Ô∏è üíã</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As primitivas de caracteres s√£o uma das inova√ß√µes do padr√£o ES6, que trouxe alguns recursos valiosos para o JavaScript. Os s√≠mbolos representados pelo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Recursos do uso do tipo de dados Symbol em JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/444340/">  As primitivas de caracteres s√£o uma das inova√ß√µes do padr√£o ES6, que trouxe alguns recursos valiosos para o JavaScript.  Os s√≠mbolos representados pelo tipo de dados Symbol s√£o especialmente √∫teis quando usados ‚Äã‚Äãcomo identificadores para propriedades do objeto.  Em conex√£o com esse cen√°rio de aplica√ß√£o, surge a pergunta sobre o que eles podem, o que as linhas n√£o podem. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/iz/wl/9d/izwl9dqxozauowr9lu69j04rvyo.jpeg"></a> <br><br>  No material, cuja tradu√ß√£o publicamos hoje, falaremos sobre o tipo de dados Symbol em JavaScript.  Come√ßaremos analisando alguns dos recursos JavaScript que voc√™ precisa navegar para lidar com s√≠mbolos. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Informa√ß√µes preliminares</font> </h2><br>  De fato, no JavaScript, existem dois tipos de valores.  O primeiro tipo - valores primitivos, o segundo - objeto (eles tamb√©m incluem fun√ß√µes).  Os valores primitivos incluem tipos de dados simples como n√∫meros (isso inclui tudo, desde n√∫meros inteiros a n√∫meros de ponto flutuante, valores <code>Infinity</code> e <code>NaN</code> ), valores l√≥gicos, cadeias de caracteres, valores <code>undefined</code> e <code>null</code> .  Observe que, ao verificar <code>typeof null === 'object'</code> retorna <code>true</code> , <code>null</code> √© um valor primitivo. <br><br>  Valores primitivos s√£o imut√°veis.  Eles n√£o podem ser alterados.  Obviamente, voc√™ pode escrever algo novo em uma vari√°vel que armazena um valor primitivo.  Por exemplo, isso grava um novo valor na vari√°vel <code>x</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>; x++;</code> </pre> <br>  Mas, ao mesmo tempo, n√£o h√° altera√ß√£o (muta√ß√£o) do valor num√©rico primitivo <code>1</code> . <br><br>  Em algumas linguagens, por exemplo, em C, existem conceitos de passar argumentos de fun√ß√µes por refer√™ncia e por valor.  JavaScript tamb√©m tem algo semelhante.  Como exatamente o trabalho com dados √© organizado depende de seu tipo.  Se um valor primitivo representado por uma determinada vari√°vel for passado para a fun√ß√£o e, em seguida, for alterado nessa fun√ß√£o, o valor armazenado na vari√°vel original n√£o ser√° alterado.  No entanto, se voc√™ passar o valor do objeto representado pela vari√°vel para a fun√ß√£o e modific√°-lo, o que √© armazenado nessa vari√°vel tamb√©m ser√° alterado. <br><br>  Considere o seguinte exemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">primitiveMutator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function">) </span></span>{ val = val + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>; primitiveMutator(x); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(x); <span class="hljs-comment"><span class="hljs-comment">// 1 function objectMutator(val) { val.prop = val.prop + 1; } let obj = { prop: 1 }; objectMutator(obj); console.log(obj.prop); // 2</span></span></code> </pre> <br>  Valores primitivos (com exce√ß√£o do misterioso <code>NaN</code> , que n√£o √© igual a si mesmo) sempre acabam sendo iguais a outros valores primitivos que se parecem com eles.  Por exemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> first = <span class="hljs-string"><span class="hljs-string">"abc"</span></span> + <span class="hljs-string"><span class="hljs-string">"def"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> second = <span class="hljs-string"><span class="hljs-string">"ab"</span></span> + <span class="hljs-string"><span class="hljs-string">"cd"</span></span> + <span class="hljs-string"><span class="hljs-string">"ef"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(first === second); <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre> <br>  No entanto, a constru√ß√£o de valores de objetos com a mesma apar√™ncia externa n√£o levar√° ao fato de que as entidades ser√£o obtidas, quando comparadas, sua igualdade entre si ser√° revelada.  Voc√™ pode verificar isso: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj1 = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Intrinsic"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj2 = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Intrinsic"</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj1 === obj2); <span class="hljs-comment"><span class="hljs-comment">// false //     .name   : console.log(obj1.name === obj2.name); // true</span></span></code> </pre> <br>  Os objetos desempenham um papel fundamental no JavaScript.  Eles s√£o usados ‚Äã‚Äãliteralmente em todos os lugares.  Por exemplo, eles s√£o frequentemente usados ‚Äã‚Äãna forma de cole√ß√µes de chave / valor.  Por√©m, antes do advento do tipo de dados <code>Symbol</code> , apenas cadeias de caracteres podiam ser usadas como chaves de objeto.  Essa foi uma limita√ß√£o s√©ria no uso de objetos na forma de cole√ß√µes.  Ao tentar atribuir um valor n√£o-string como uma chave de objeto, esse valor foi convertido em uma string.  Voc√™ pode verificar isso: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = {}; obj.foo = <span class="hljs-string"><span class="hljs-string">'foo'</span></span>; obj[<span class="hljs-string"><span class="hljs-string">'bar'</span></span>] = <span class="hljs-string"><span class="hljs-string">'bar'</span></span>; obj[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">2</span></span>; obj[{}] = <span class="hljs-string"><span class="hljs-string">'someobj'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj); <span class="hljs-comment"><span class="hljs-comment">// { '2': 2, foo: 'foo', bar: 'bar',    '[object Object]': 'someobj' }</span></span></code> </pre> <br>  A prop√≥sito, embora isso nos afaste um pouco do t√≥pico dos caracteres, gostaria de observar que a estrutura de dados do <code>Map</code> foi criada para permitir o uso de armazenamentos de dados de chave / valor em situa√ß√µes em que a chave n√£o √© uma string. <br><br><h2>  <font color="#3AC1EF">O que √© um s√≠mbolo?</font> </h2><br>  Agora que descobrimos os recursos dos valores primitivos no JavaScript, finalmente estamos prontos para come√ßar a falar sobre caracteres.  Um s√≠mbolo √© um significado primitivo √∫nico.  Se voc√™ se aproximar dos s√≠mbolos a partir dessa posi√ß√£o, notar√° que os s√≠mbolos a esse respeito s√£o semelhantes aos objetos, pois a cria√ß√£o de v√°rias inst√¢ncias dos s√≠mbolos levar√° √† cria√ß√£o de valores diferentes.  Al√©m disso, os s√≠mbolos s√£o valores primitivos imut√°veis.  Aqui est√° um exemplo de trabalho com caracteres: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> s1 = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> s2 = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(s1 === s2); <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre> <br>  Ao criar uma inst√¢ncia de um caractere, voc√™ pode usar o argumento opcional da primeira string.  Este argumento √© uma descri√ß√£o do s√≠mbolo que se destina ao uso na depura√ß√£o.  Este valor n√£o afeta o pr√≥prio s√≠mbolo. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> s1 = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'debug'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-string"><span class="hljs-string">'debug'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> s2 = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'xxyy'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(s1 === str); <span class="hljs-comment"><span class="hljs-comment">// false console.log(s1 === s2); // false console.log(s1); // Symbol(debug)</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">S√≠mbolos como chaves para propriedade de objetos</font> </h2><br>  Os s√≠mbolos podem ser usados ‚Äã‚Äãcomo chaves de propriedade para objetos.  Isso √© muito importante.  Aqui est√° um exemplo de us√°-los como tal: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sym = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(); obj[sym] = <span class="hljs-string"><span class="hljs-string">'foo'</span></span>; obj.bar = <span class="hljs-string"><span class="hljs-string">'bar'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj); <span class="hljs-comment"><span class="hljs-comment">// { bar: 'bar' } console.log(sym in obj); // true console.log(obj[sym]); // foo console.log(Object.keys(obj)); // ['bar']</span></span></code> </pre> <br>  Observe que as chaves especificadas por caracteres n√£o s√£o retornadas quando o m√©todo <code>Object.keys()</code> √© <code>Object.keys()</code> .  O c√≥digo escrito antes da apar√™ncia dos caracteres em JS n√£o sabe nada sobre eles; como resultado, as informa√ß√µes sobre as chaves dos objetos representados por caracteres n√£o devem ser retornadas pelo m√©todo <code>Object.keys()</code> antigo. <br><br>  √Ä primeira vista, pode parecer que os recursos de caracteres acima permitem que voc√™ os use para criar propriedades particulares de objetos JS.  Em muitas outras linguagens de programa√ß√£o, voc√™ pode criar propriedades de objetos ocultos usando classes.  A falta desse recurso √© considerada uma das defici√™ncias do JavaScript. <br><br>  Infelizmente, o c√≥digo que funciona com objetos pode acessar livremente suas chaves de seq√º√™ncia de caracteres.  Al√©m disso, o c√≥digo pode acessar chaves especificadas por caracteres, mesmo se o c√≥digo do qual eles trabalham com o objeto n√£o tiver acesso ao caractere correspondente.  Por exemplo, usando o m√©todo <code>Reflect.ownKeys()</code> , voc√™ pode obter uma lista de todas as chaves de um objeto, tanto as que s√£o seq√º√™ncias de caracteres quanto as que s√£o os caracteres: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tryToAddPrivate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">o</span></span></span><span class="hljs-function">) </span></span>{ o[<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'Pseudo Private'</span></span>)] = <span class="hljs-number"><span class="hljs-number">42</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">prop</span></span>: <span class="hljs-string"><span class="hljs-string">'hello'</span></span> }; tryToAddPrivate(obj); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.ownKeys(obj));       <span class="hljs-comment"><span class="hljs-comment">// [ 'prop', Symbol(Pseudo Private) ] console.log(obj[Reflect.ownKeys(obj)[1]]); // 42</span></span></code> </pre> <br>  Observe que atualmente est√° em andamento o trabalho para equipar as classes com a capacidade de usar propriedades particulares.  Esse recurso √© chamado de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">campos particulares</a> .  √â verdade que n√£o afeta absolutamente todos os objetos, referindo-se apenas √†queles criados com base em classes previamente preparadas.  O suporte para campos particulares j√° est√° dispon√≠vel no navegador Chrome vers√£o 72 e anterior. <br><br><h2>  <font color="#3AC1EF">Impedir colis√µes de nomes de propriedades de objetos</font> </h2><br>  Os s√≠mbolos, √© claro, n√£o acrescentam ao JavaScript a capacidade de criar propriedades privadas de objetos, mas s√£o uma inova√ß√£o valiosa na linguagem por outros motivos.  Ou seja, s√£o √∫teis em situa√ß√µes em que determinadas bibliotecas precisam adicionar propriedades a objetos descritos fora delas e, ao mesmo tempo, n√£o ter medo de uma colis√£o dos nomes das propriedades dos objetos. <br><br>  Considere um exemplo no qual duas bibliotecas diferentes desejam adicionar metadados a um objeto.  √â poss√≠vel que ambas as bibliotecas precisem equipar o objeto com alguns identificadores.  Se voc√™ simplesmente usar algo como uma cadeia de caracteres de <code>id</code> de duas letras para o nome dessa propriedade, poder√° encontrar uma situa√ß√£o em que uma biblioteca substitua a propriedade especificada pela outra. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lib1tag</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function">) </span></span>{ obj.id = <span class="hljs-number"><span class="hljs-number">42</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lib2tag</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function">) </span></span>{ obj.id = <span class="hljs-number"><span class="hljs-number">369</span></span>; }</code> </pre> <br>  Se usarmos os s√≠mbolos em nosso exemplo, cada biblioteca poder√° gerar, na inicializa√ß√£o, os s√≠mbolos necess√°rios.  Esses s√≠mbolos podem ser usados ‚Äã‚Äãpara atribuir propriedades a objetos e para acessar essas propriedades. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> library1property = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'lib1'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lib1tag</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function">) </span></span>{ obj[library1property] = <span class="hljs-number"><span class="hljs-number">42</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> library2property = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'lib2'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lib2tag</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function">) </span></span>{ obj[library2property] = <span class="hljs-number"><span class="hljs-number">369</span></span>; }</code> </pre> <br>  √â analisando esse cen√°rio que voc√™ pode se beneficiar da apar√™ncia de caracteres em JavaScript. <br><br>  No entanto, pode haver uma pergunta sobre o uso de bibliotecas para os nomes de propriedades de objetos, cadeias aleat√≥rias ou cadeias com uma estrutura complexa, incluindo, por exemplo, o nome da biblioteca.  Sequ√™ncias semelhantes podem formar algo como namespaces para identificadores usados ‚Äã‚Äãpor bibliotecas.  Por exemplo, pode ser assim: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> library1property = uuid(); <span class="hljs-comment"><span class="hljs-comment">//       function lib1tag(obj) { obj[library1property] = 42; } const library2property = 'LIB2-NAMESPACE-id'; //     function lib2tag(obj) { obj[library2property] = 369; }</span></span></code> </pre> <br>  Em geral, voc√™ pode faz√™-lo.  Abordagens semelhantes, de fato, s√£o muito semelhantes ao que acontece ao usar s√≠mbolos.  E se, usando identificadores aleat√≥rios ou espa√ßos para nome, algumas bibliotecas n√£o gerarem, por acaso, os mesmos nomes de propriedade, n√£o haver√° problemas com os nomes. <br><br>  Um leitor astuto diria agora que as duas abordagens consideradas para nomear propriedades de objetos n√£o s√£o completamente equivalentes.  Os nomes de propriedades gerados aleatoriamente ou usando espa√ßos para nome t√™m uma desvantagem: as chaves correspondentes s√£o muito f√°ceis de encontrar, especialmente se o c√≥digo pesquisar nas chaves de objetos ou serializ√°-las.  Considere o seguinte exemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> library2property = <span class="hljs-string"><span class="hljs-string">'LIB2-NAMESPACE-id'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    function lib2tag(obj) { obj[library2property] = 369; } const user = { name: 'Thomas Hunter II', age: 32 }; lib2tag(user); JSON.stringify(user); // '{"name":"Thomas Hunter II","age":32,"LIB2-NAMESPACE-id":369}'</span></span></code> </pre> <br>  Se um s√≠mbolo fosse usado para o nome da chave nessa situa√ß√£o, a representa√ß√£o JSON do objeto n√£o conteria o valor do s√≠mbolo.  Por que isso √© assim?  O fato √© que o fato de um novo tipo de dados ter aparecido em JavaScript n√£o significa que foram feitas altera√ß√µes na especifica√ß√£o JSON.  O JSON suporta, como chaves de propriedade, apenas cadeias.  Ao serializar um objeto, nenhuma tentativa √© feita para representar os caracteres de qualquer maneira especial. <br><br>  O problema considerado de obter nomes de propriedades na representa√ß√£o JSON de objetos pode ser resolvido usando <code>Object.defineProperty()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> library2property = uuid(); <span class="hljs-comment"><span class="hljs-comment">//   function lib2tag(obj) { Object.defineProperty(obj, library2property, {   enumerable: false,   value: 369 }); } const user = { name: 'Thomas Hunter II', age: 32 }; lib2tag(user); // '{"name":"Thomas Hunter II",  "age":32,"f468c902-26ed-4b2e-81d6-5775ae7eec5d":369}' console.log(JSON.stringify(user)); console.log(user[library2property]); // 369</span></span></code> </pre> <br>  As chaves de seq√º√™ncia de caracteres que s√£o "ocultas" ao definir seu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">descritor</a> <code>enumerable</code> como <code>false</code> se comportam da mesma maneira que as chaves representadas por caracteres.  Ambos n√£o s√£o exibidos quando <code>Object.keys()</code> chamado e ambos podem ser detectados usando <code>Reflect.ownKeys()</code> .  Aqui est√° o que parece: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = {}; obj[<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>()] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(obj, <span class="hljs-string"><span class="hljs-string">'foo'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">enumberable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(obj)); <span class="hljs-comment"><span class="hljs-comment">// [] console.log(Reflect.ownKeys(obj)); // [ 'foo', Symbol() ] console.log(JSON.stringify(obj)); // {}</span></span></code> </pre> <br>  Aqui, devo dizer, quase recriamos as possibilidades de s√≠mbolos, usando outros meios de JS.  Em particular, ambas as chaves representadas por s√≠mbolos e chaves privadas n√£o se enquadram na representa√ß√£o JSON de um objeto.  Ambos podem ser encontrados consultando o m√©todo <code>Reflect.ownKeys()</code> .  Como resultado, ambos n√£o podem ser chamados de verdadeiramente privados.  Se assumirmos que alguns valores aleat√≥rios ou espa√ßos de nomes de bibliotecas s√£o usados ‚Äã‚Äãpara gerar nomes-chave, isso significa que nos livramos do risco de colis√µes de nomes. <br><br>  No entanto, h√° uma pequena diferen√ßa entre o uso de nomes de s√≠mbolos e nomes criados usando outros mecanismos.  Como as strings s√£o imut√°veis ‚Äã‚Äãe os caracteres s√£o garantidos √∫nicos, sempre h√° a possibilidade de que algu√©m, depois de passar por todas as combina√ß√µes poss√≠veis de caracteres em uma string, cause uma colis√£o de nomes.  Do ponto de vista matem√°tico, isso significa que os personagens realmente nos d√£o uma oportunidade valiosa que as strings n√£o t√™m. <br><br>  No Node.js, ao examinar objetos (por exemplo, usando <code>console.log()</code> ), se um m√©todo de objeto chamado <code>inspect</code> detectado, esse m√©todo ser√° usado para obter uma representa√ß√£o em cadeia do objeto e exibi-la na tela.  √â f√°cil entender que absolutamente todo mundo n√£o pode levar isso em considera√ß√£o; portanto, esse comportamento do sistema pode levar a uma chamada para o m√©todo de <code>inspect</code> objeto, que √© projetado para resolver problemas que n√£o est√£o relacionados √† forma√ß√£o da representa√ß√£o de seq√º√™ncia de caracteres do objeto.  Esse recurso foi descontinuado no Node.js. 10, na vers√£o 11, m√©todos com um nome semelhante s√£o simplesmente ignorados.  Agora, para implementar esse recurso, <code>require('util').inspect.custom</code> .  Isso significa que ningu√©m jamais poder√° interromper inadvertidamente o sistema criando um m√©todo de objeto chamado <code>inspect</code> . <br><br><h2>  <font color="#3AC1EF">Imita√ß√£o de propriedades privadas</font> </h2><br>  Aqui est√° uma abordagem interessante que voc√™ pode usar para simular as propriedades particulares dos objetos.  Essa abordagem envolve o uso de outro recurso JavaScript moderno - objetos proxy.  Esses objetos servem como inv√≥lucros para outros objetos que permitem ao programador intervir nas a√ß√µes executadas com esses objetos. <br><br>  Os objetos proxy oferecem v√°rias maneiras de interceptar as a√ß√µes executadas nos objetos.  Estamos interessados ‚Äã‚Äãna capacidade de controlar a opera√ß√£o de leitura de chaves de um objeto.  N√£o entraremos em detalhes sobre objetos proxy aqui.  Se voc√™ estiver interessado, d√™ uma olhada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nesta</a> publica√ß√£o. <br><br>  Podemos usar proxies para controlar quais propriedades do objeto s√£o vis√≠veis do lado de fora.  Nesse caso, queremos criar um proxy que oculte duas propriedades que conhecemos.  Um deles tem o nome da string <code>_favColor</code> e o segundo √© representado por um caractere gravado na vari√°vel <code>favBook</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> proxy; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> favBook = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'fav book'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = {   <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Thomas Hunter II'</span></span>,   <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">32</span></span>,   <span class="hljs-attr"><span class="hljs-attr">_favColor</span></span>: <span class="hljs-string"><span class="hljs-string">'blue'</span></span>,   [favBook]: <span class="hljs-string"><span class="hljs-string">'Metro 2033'</span></span>,   [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'visible'</span></span>)]: <span class="hljs-string"><span class="hljs-string">'foo'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handler = {   <span class="hljs-attr"><span class="hljs-attr">ownKeys</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">target</span></span></span><span class="hljs-function">) =&gt;</span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> reportedKeys = [];     <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> actualKeys = <span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.ownKeys(target);     <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> actualKeys) {       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key === favBook || key === <span class="hljs-string"><span class="hljs-string">'_favColor'</span></span>) {         <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>;       }       reportedKeys.push(key);     }     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reportedKeys;   } }; proxy = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Proxy</span></span>(obj, handler); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(proxy)); <span class="hljs-comment"><span class="hljs-comment">// [ 'name', 'age' ] console.log(Reflect.ownKeys(proxy)); // [ 'name', 'age', Symbol(visible) ] console.log(Object.getOwnPropertyNames(proxy)); // [ 'name', 'age' ] console.log(Object.getOwnPropertySymbols(proxy)); // [Symbol(visible)] console.log(proxy._favColor); // 'blue</span></span></code> </pre> <br>  Lidar com uma propriedade cujo nome √© representado pela string <code>_favColor</code> n√£o √© dif√≠cil: basta ler o c√≥digo-fonte.  Teclas din√¢micas (como as teclas uuid que vimos acima) podem ser selecionadas com for√ßa bruta.  Mas sem refer√™ncia ao s√≠mbolo, voc√™ n√£o pode acessar o valor do <code>Metro 2033</code> partir do objeto <code>proxy</code> . <br><br>  Note-se que no Node.js h√° um recurso que viola a privacidade dos objetos proxy.  Esse recurso n√£o existe no pr√≥prio idioma, portanto, n√£o √© relevante para outros tempos de execu√ß√£o do JS, como um navegador.  O fato √© que esse recurso permite acessar o objeto oculto atr√°s do objeto proxy, se voc√™ tiver acesso ao objeto proxy.  Aqui est√° um exemplo que demonstra a capacidade de ignorar os mecanismos mostrados no snippet de c√≥digo anterior: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [originalObject] = process .binding(<span class="hljs-string"><span class="hljs-string">'util'</span></span>) .getProxyDetails(proxy); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> allKeys = <span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.ownKeys(originalObject); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(allKeys[<span class="hljs-number"><span class="hljs-number">3</span></span>]); <span class="hljs-comment"><span class="hljs-comment">// Symbol(fav book)</span></span></code> </pre> <br>  Agora, para impedir o uso desse recurso em uma inst√¢ncia espec√≠fica do Node.js., voc√™ deve modificar o objeto <code>Reflect</code> global ou a liga√ß√£o do processo <code>util</code> .  No entanto, essa √© outra tarefa.  Se voc√™ estiver interessado, d√™ uma olhada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nesta</a> postagem sobre como proteger APIs baseadas em JavaScript. <br><br><h2>  <font color="#3AC1EF">Sum√°rio</font> </h2><br>  Neste artigo, falamos sobre o tipo de dados <code>Symbol</code> , sobre quais recursos ele oferece aos desenvolvedores de JavaScript e sobre quais mecanismos de linguagem existentes podem ser usados ‚Äã‚Äãpara simular esses recursos. <br><br>  <b>Caros leitores!</b>  Voc√™ usa s√≠mbolos em seus projetos JavaScript? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt444340/">https://habr.com/ru/post/pt444340/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt444328/index.html">O redesenho da interface do usu√°rio costuma ser uma perda de tempo</a></li>
<li><a href="../pt444330/index.html">O CMS sem servidor √© finalmente um concorrente digno do Wordpress</a></li>
<li><a href="../pt444332/index.html">Seguran√ßa da informa√ß√£o e catering: como os gerentes pensam sobre os produtos de TI</a></li>
<li><a href="../pt444336/index.html">Listas de captura r√°pidas: qual √© a diferen√ßa entre links fracos, fortes e n√£o propriet√°rios?</a></li>
<li><a href="../pt444338/index.html">Encapsulamento em Python 3</a></li>
<li><a href="../pt444342/index.html">Desenvolvendo aplicativos JavaScript simples e modernos usando o Webpack e tecnologias avan√ßadas da Web</a></li>
<li><a href="../pt444344/index.html">10 etapas para um projeto Python bem-sucedido</a></li>
<li><a href="../pt444346/index.html">GraphQL e Golang</a></li>
<li><a href="../pt444348/index.html">Qual a diferen√ßa entre os componentes funcionais do React e os componentes baseados em classe?</a></li>
<li><a href="../pt444350/index.html">Por algum motivo, o MVP (produto m√≠nimo vi√°vel) n√£o inicia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>