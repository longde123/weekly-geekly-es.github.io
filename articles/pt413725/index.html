<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👐🏿 🍨 👨🏼 Trabalhando com matrizes no bash 🔓 🙌🏿 👩🏿‍🎤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Os programadores usam regularmente o bash para resolver muitas tarefas relacionadas ao desenvolvimento de software. Ao mesmo tempo, matrizes bash são ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Trabalhando com matrizes no bash</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/413725/">  Os programadores usam regularmente o bash para resolver muitas tarefas relacionadas ao desenvolvimento de software.  Ao mesmo tempo, matrizes bash são frequentemente consideradas um dos recursos mais incompreensíveis desse shell (provavelmente, matrizes perdem apenas para expressões regulares a esse respeito).  O autor do material, cuja tradução publicamos hoje, convida todos para o maravilhoso mundo das matrizes bash, que, se você se acostumar com a sintaxe incomum, podem trazer muitos benefícios. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/efa/72d/7c7/efa72d7c779f3915863c44ac528143a2.jpg" alt="imagem"></div><a name="habracut"></a><br><h2>  <font color="#3AC1EF">O verdadeiro desafio que os arrays do bash são úteis</font> </h2><br>  Escrever sobre o bash é controverso.  O fato é que os artigos sobre o bash geralmente se transformam em guias do usuário dedicados a histórias sobre os recursos sintáticos dos comandos em questão.  Este artigo foi escrito de forma diferente. Esperamos que você não o encontre no próximo "manual do usuário". <br><br>  Dado o exposto, imagine um cenário real para o uso de matrizes no bash.  Suponha que você tenha a tarefa de avaliar e otimizar um utilitário a partir de um novo conjunto interno de ferramentas usadas em sua empresa.  Na primeira etapa deste estudo, você precisa testá-lo com diferentes conjuntos de parâmetros.  O teste tem como objetivo estudar como um novo conjunto de ferramentas se comporta quando eles usam um número diferente de threads.  Para simplificar a apresentação, assumimos que a “caixa de ferramentas” é uma “caixa preta” compilada a partir do código C ++.  Ao usá-lo, o único parâmetro que podemos influenciar é o número de threads reservados para o processamento de dados.  Chamar o sistema sob investigação na linha de comando é assim: <br><br><pre><code class="hljs pgsql">./pipeline <span class="hljs-comment"><span class="hljs-comment">--threads 4</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">O básico</font> </h2><br>  Antes de tudo, declaramos uma matriz que contém os valores do parâmetro <code>--threads</code> com o qual queremos testar o sistema.  Essa matriz é assim: <br><br><pre> <code class="hljs lisp">allThreads=(<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span> <span class="hljs-number"><span class="hljs-number">32</span></span> <span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-number"><span class="hljs-number">128</span></span>)</code> </pre> <br>  Neste exemplo, todos os elementos são números, mas, de fato, em matrizes bash, você pode armazenar números e seqüências de caracteres ao mesmo tempo.  Por exemplo, a declaração de uma matriz desse tipo é bastante aceitável: <br><br><pre> <code class="hljs lisp">myArray=(<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-string"><span class="hljs-string">"three"</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-string"><span class="hljs-string">"five"</span></span>)</code> </pre> <br>  Como com outras variáveis ​​do bash, verifique se não há espaços ao redor do sinal <code>=</code> .  Caso contrário, o bash considerará o nome da variável o nome do programa que ele precisa executar e <code>=</code> o primeiro argumento! <br><br>  Agora que inicializamos a matriz, vamos extrair alguns elementos dela.  Aqui você pode observar, por exemplo, que o <code>echo $allThreads</code> produzirá apenas o primeiro elemento da matriz. <br><br>  Para entender os motivos desse comportamento, vamos desviar um pouco das matrizes e relembrar como trabalhar com variáveis ​​no bash.  Considere o seguinte exemplo: <br><br><pre> <code class="hljs bash"><span class="hljs-built_in"><span class="hljs-built_in">type</span></span>=<span class="hljs-string"><span class="hljs-string">"article"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Found 42 </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$type</span></span></span><span class="hljs-string">"</span></span></code> </pre> <br>  Suponha que você tenha uma variável do <code>$type</code> que contenha uma sequência que represente um substantivo.  Após esta palavra, adicione a letra <code>s</code> .  No entanto, você não pode simplesmente adicionar esta letra ao final do nome da variável, pois isso transformará o comando para acessar a variável em <code>$types</code> , ou seja, trabalharemos com uma variável completamente diferente.  Nessa situação, você pode usar uma construção como o <code>echo "Found 42 "$type"s"</code> .  Mas é melhor resolver esse problema usando colchetes: <code>echo "Found 42 ${type}s"</code> , que nos permite dizer ao bash onde o nome da variável começa e termina (curiosamente, a mesma sintaxe é usada no JavaScript ES6 para incorporar variáveis em expressões em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">seqüências de caracteres padrão</a> ). <br><br>  Agora de volta às matrizes.  Acontece que, embora chaves geralmente não sejam necessárias ao trabalhar com variáveis, elas são necessárias para trabalhar com matrizes.  Eles permitem que você defina índices para acessar os elementos da matriz.  Por exemplo, um comando do formulário <code>echo ${allThreads[1]}</code> produzirá o segundo elemento da matriz.  Se você esquecer as chaves na construção acima, o bash perceberá <code>[1]</code> como uma string e processará o que acontece de acordo. <br><br>  Como você pode ver, as matrizes no bash têm uma sintaxe estranha, mas nelas, pelo menos, a numeração dos elementos começa do zero.  Isso os torna semelhantes aos arrays de muitas outras linguagens de programação. <br><br><h2>  <font color="#3AC1EF">Maneiras de acessar elementos da matriz</font> </h2><br>  No exemplo acima, usamos índices inteiros em matrizes especificadas explicitamente.  Agora considere mais duas maneiras de trabalhar com matrizes. <br><br>  O primeiro método é aplicável se precisarmos do <code>$i</code> ésimo elemento da matriz, em que <code>$i</code> é uma variável que contém o índice do elemento de matriz desejado.  Você pode extrair esse elemento da matriz usando uma construção do formulário <code>echo ${allThreads[$i]}</code> . <br><br>  O segundo método permite exibir todos os elementos da matriz.  Consiste em substituir o índice numérico pelo símbolo <code>@</code> (pode ser interpretado como um comando apontando para todos os elementos da matriz).  É assim: <code>echo ${allThreads[@]}</code> . <br><br><h2>  <font color="#3AC1EF">Iterando Elementos da Matriz em Loops</font> </h2><br>  Os princípios acima, de trabalhar com elementos de matriz, serão úteis para resolver o problema de enumerar elementos de matriz.  No nosso caso, isso significa iniciar o comando <code>pipeline</code> em estudo com cada um dos valores, que simboliza o número de threads e é armazenado em uma matriz.  É assim: <br><br><pre> <code class="hljs powershell"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-variable"><span class="hljs-variable">$</span></span>{allThreads[<span class="hljs-selector-tag"><span class="hljs-selector-tag">@</span></span>]}; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ./pipeline -<span class="hljs-literal"><span class="hljs-literal">-threads</span></span> <span class="hljs-variable"><span class="hljs-variable">$t</span></span> done</code> </pre> <br><h2>  <font color="#3AC1EF">Enumerando índices de matriz em loops</font> </h2><br>  Agora considere uma abordagem ligeiramente diferente para classificar matrizes.  Em vez de iterar sobre os elementos, podemos iterar sobre os índices da matriz: <br><br><pre> <code class="hljs powershell"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-variable"><span class="hljs-variable">$</span></span>{!allThreads[<span class="hljs-selector-tag"><span class="hljs-selector-tag">@</span></span>]}; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ./pipeline -<span class="hljs-literal"><span class="hljs-literal">-threads</span></span> <span class="hljs-variable"><span class="hljs-variable">$</span></span>{allThreads[<span class="hljs-variable"><span class="hljs-variable">$i</span></span>]} done</code> </pre> <br>  Vamos analisar o que está acontecendo aqui.  Como já vimos, uma construção no formato <code>${allThreads[@]}</code> representa todos os elementos da matriz.  Quando adicionamos um ponto de exclamação aqui, transformamos essa construção em <code>${!allThreads[@]}</code> , o que leva ao fato de que ele retorna os índices da matriz (de 0 a 7 no nosso caso). <br><br>  Em outras palavras, o loop <code>for</code> sobre todos os índices da matriz representada como a variável <code>$i</code> , e no corpo da loop, os elementos da matriz que servem como valores do parâmetro <code>${allThreads[$i]}</code> são <code>--thread</code> usando a construção <code>${allThreads[$i]}</code> . <br><br>  A leitura deste código é mais difícil que a do exemplo anterior.  Portanto, surge a questão de para que servem todas essas dificuldades.  E precisamos disso porque, em algumas situações, ao processar matrizes em loops, você precisa conhecer os índices e os valores dos elementos.  Por exemplo, se você precisar pular o primeiro elemento de uma matriz, a iteração sobre os índices nos salvará, por exemplo, da necessidade de criar uma variável adicional e de incrementá-la em um loop para trabalhar com os elementos da matriz. <br><br><h2>  <font color="#3AC1EF">Matrizes de preenchimento</font> </h2><br>  Até agora, exploramos o sistema invocando o comando <code>pipeline</code> e passando cada um dos valores do parâmetro <code>--threads</code> nos interessa.  Agora, suponha que este comando dê a duração de um determinado processo em segundos.  Gostaríamos de interceptar os dados retornados a cada iteração e salvá-los em outra matriz.  Isso nos dará a oportunidade de trabalhar com os dados armazenados após o término de todos os testes. <br><br><h2>  <font color="#3AC1EF">Construções úteis de sintaxe</font> </h2><br>  Antes de falarmos sobre como adicionar dados às matrizes, vejamos algumas construções de sintaxe úteis.  Para começar, precisamos de um mecanismo para obter a saída de dados por comandos bash.  Para capturar a saída de um comando, você precisa usar a seguinte construção: <br><br><pre> <code class="hljs lua"><span class="hljs-built_in"><span class="hljs-built_in">output</span></span>=$( ./my_script.sh )</code> </pre> <br>  Após executar este comando, o que o <code>myscript.sh</code> <code>$output</code> será armazenado na variável <code>$output</code> . <br><br>  A segunda construção, que será útil muito em breve, permite anexar novos dados às matrizes.  É assim: <br><br><pre> <code class="hljs lisp">myArray+=( <span class="hljs-string"><span class="hljs-string">"newElement1"</span></span> <span class="hljs-string"><span class="hljs-string">"newElement2"</span></span> )</code> </pre> <br><h2>  <font color="#3AC1EF">Resolução de problemas</font> </h2><br>  Agora, se você reunir tudo o que acabamos de aprender, poderá criar um script para testar o sistema, que executa um comando com cada um dos valores de parâmetro da matriz e armazena na outra matriz o que esse comando exibe. <br><br><pre> <code class="hljs powershell">allThreads=(<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span> <span class="hljs-number"><span class="hljs-number">32</span></span> <span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-number"><span class="hljs-number">128</span></span>) allRuntimes=() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-variable"><span class="hljs-variable">$</span></span>{allThreads[<span class="hljs-selector-tag"><span class="hljs-selector-tag">@</span></span>]}; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> runtime=<span class="hljs-variable"><span class="hljs-variable">$</span></span>(./pipeline -<span class="hljs-literal"><span class="hljs-literal">-threads</span></span> <span class="hljs-variable"><span class="hljs-variable">$t</span></span>) allRuntimes+=( <span class="hljs-variable"><span class="hljs-variable">$runtime</span></span> ) done</code> </pre> <br><h2>  <font color="#3AC1EF">O que vem a seguir?</font> </h2><br>  Acabamos de examinar como usar matrizes bash para iterar sobre os parâmetros usados ​​ao iniciar um programa e salvar os dados que esse programa retorna.  No entanto, as opções para usar matrizes não se limitam a esse cenário.  Aqui estão mais alguns exemplos. <br><br><h2>  <font color="#3AC1EF">Alertas de Problemas</font> </h2><br>  Nesse cenário, examinaremos um aplicativo dividido em módulos.  Cada um desses módulos possui seu próprio arquivo de log.  Podemos escrever um script de tarefa <code>cron</code> que, se forem encontrados problemas no arquivo de log correspondente, notificará por e-mail a pessoa responsável por cada um dos módulos: <br><br><pre> <code class="hljs kotlin">#  -    logPaths=(<span class="hljs-string"><span class="hljs-string">"api.log"</span></span> <span class="hljs-string"><span class="hljs-string">"auth.log"</span></span> <span class="hljs-string"><span class="hljs-string">"jenkins.log"</span></span> <span class="hljs-string"><span class="hljs-string">"data.log"</span></span>) logEmails=(<span class="hljs-string"><span class="hljs-string">"jay@email"</span></span> <span class="hljs-string"><span class="hljs-string">"emma@email"</span></span> <span class="hljs-string"><span class="hljs-string">"jon@email"</span></span> <span class="hljs-string"><span class="hljs-string">"sophia@email"</span></span>) #         <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ${!logPaths[@]}; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> log=${logPaths[$i]} stakeholder=${logEmails[$i]} numErrors=$( tail -n <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$log</span></span></span><span class="hljs-string">"</span></span> | grep <span class="hljs-string"><span class="hljs-string">"ERROR"</span></span> | wc -l ) #       <span class="hljs-number"><span class="hljs-number">5</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$numErrors</span></span></span><span class="hljs-string">"</span></span> -gt <span class="hljs-number"><span class="hljs-number">5</span></span> ]]; then   emailRecipient=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$stakeholder</span></span></span><span class="hljs-string">"</span></span>   emailSubject=<span class="hljs-string"><span class="hljs-string">"WARNING: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${log}</span></span></span><span class="hljs-string"> showing unusual levels of errors"</span></span>   emailBody=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${numErrors}</span></span></span><span class="hljs-string"> errors found in log </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${log}</span></span></span><span class="hljs-string">"</span></span>   echo <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$emailBody</span></span></span><span class="hljs-string">"</span></span> | mailx -s <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$emailSubject</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$emailRecipient</span></span></span><span class="hljs-string">"</span></span> fi done</code> </pre> <br><h2>  <font color="#3AC1EF">Solicitações de API</font> </h2><br>  Suponha que você queira coletar informações sobre quais usuários comentam suas postagens no Medium.  Como não temos acesso direto ao banco de dados deste site, não discutiremos consultas SQL.  No entanto, você pode usar várias APIs para acessar esse tipo de dados. <br><br>  Para evitar longas conversas sobre autenticação e tokens, usaremos como ponto de extremidade o serviço de teste de API público <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">JSONPlaceholder</a> .  Após receber uma publicação do serviço e extrair dados de seu código nos endereços de email dos comentaristas, podemos colocar esses dados em uma matriz: <br><br><pre> <code class="hljs kotlin">endpoint=<span class="hljs-string"><span class="hljs-string">"https://jsonplaceholder.typicode.com/comments"</span></span> allEmails=() #   <span class="hljs-number"><span class="hljs-number">10</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> postId <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> {<span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">10</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> #    API       response=$(curl <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${endpoint}</span></span></span><span class="hljs-string">?postId=</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${postId}</span></span></span><span class="hljs-string">"</span></span>) #  jq   JSON       allEmails+=( $( jq <span class="hljs-string"><span class="hljs-string">'.[].email'</span></span> &lt;&lt;&lt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$response</span></span></span><span class="hljs-string">"</span></span> ) ) done</code> </pre> <br>  Observe que a ferramenta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">jq</a> é usada aqui, o que permite analisar o JSON na linha de comandos.  Não entraremos em detalhes sobre o trabalho com o jq, se você estiver interessado nesta ferramenta - consulte a documentação. <br><br><h2>  <font color="#3AC1EF">Bash ou Python?</font> </h2><br>  Matrizes - um recurso útil e está disponível não apenas no bash.  Quem escreve scripts para a linha de comando pode ter uma pergunta lógica sobre em quais situações vale a pena usar o bash e em que, por exemplo, Python. <br><br>  Na minha opinião, a resposta a esta pergunta está em quanto o programador depende de uma tecnologia específica.  Digamos, se o problema puder ser resolvido diretamente na linha de comando, nada impede o uso do bash.  No entanto, no caso de, por exemplo, o script no qual você se interessar fazer parte de um projeto escrito em Python, você poderá usar o Python. <br><br>  Por exemplo, para resolver o problema considerado aqui, você pode usar um script escrito em Python, no entanto, isso se resumirá em escrever wrappers para Python para bash: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> subprocess all_threads = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">128</span></span>] all_runtimes = [] #         <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> all_threads: cmd = <span class="hljs-string"><span class="hljs-string">'./pipeline --threads {}'</span></span>.format(t) #   subprocess   ,    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, shell=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) output = p.communicate()[<span class="hljs-number"><span class="hljs-number">0</span></span>] all_runtimes.append(output)</code> </pre> <br>  Talvez a solução para esse problema com o bash, sem envolver outras tecnologias, seja mais curta e compreensível, e aqui você pode fazer completamente sem o Python. <br><br><h2>  <font color="#3AC1EF">Sumário</font> </h2><br>  Neste material, analisamos muitos projetos usados ​​para trabalhar com matrizes.  Aqui está uma tabela onde você encontrará o que analisamos e algo novo. <br><table><tbody><tr><td>  Construção de sintaxe </td><td>  Descrição do produto </td></tr><tr><td> <code>arr=()</code> </td> <td>  Crie uma matriz vazia </td></tr><tr><td> <code>arr=(1 2 3)</code> </td> <td>  Inicialização de matriz </td></tr><tr><td> <code>${arr[2]}</code> </td> <td>  Obtendo o terceiro elemento de uma matriz </td></tr><tr><td> <code>${arr[@]}</code> </td> <td>  Obtendo todos os elementos da matriz </td></tr><tr><td> <code>${!arr[@]}</code> </td> <td>  Obtendo índices de matriz </td></tr><tr><td> <code>${#arr[@]}</code> </td> <td>  Cálculo do tamanho da matriz </td></tr><tr><td> <code>arr[0]=3</code> </td> <td>  Substituindo o primeiro elemento de uma matriz </td></tr><tr><td> <code>arr+=(4)</code> </td> <td>  Juntando uma matriz de valores </td></tr><tr><td> <code>str=$(ls)</code> </td> <td>  Salvando a Saída do <code>ls</code> como uma Cadeia de Caracteres </td></tr><tr><td> <code>arr=( $(ls) )</code> </td> <td>  Salvando a saída do <code>ls</code> como uma matriz de nomes de arquivos </td></tr><tr><td> <code>${arr[@]:s:n}</code> </td> <td>  Obtendo elementos da matriz de elemento com índice <code>s</code> para elemento com índice <code>s+(n-1)</code> <br></td></tr></tbody></table><br>  À primeira vista, os arrays do bash podem parecer bastante estranhos, mas as possibilidades que eles oferecem valem a pena lidar com essas esquisitices.  Acreditamos que, ao dominar as matrizes do bash, você as usará com bastante frequência.  É fácil imaginar inúmeros cenários nos quais essas matrizes podem ser úteis. <br><br>  <b>Caros leitores!</b>  Se você tiver exemplos interessantes de uso de matrizes em scripts bash, compartilhe-os. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt413725/">https://habr.com/ru/post/pt413725/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt413715/index.html">Pensão de aposentadoria em TI</a></li>
<li><a href="../pt413717/index.html">GraphQL para plataformas InterSystems</a></li>
<li><a href="../pt413719/index.html">C ++ 20 a caminho! Encontro no Rapperswil Yona</a></li>
<li><a href="../pt413721/index.html">Time Check: Timejacking vs Bitcoin</a></li>
<li><a href="../pt413723/index.html">Saga de serviços eletrônicos e suas localizações. Parte 2. Armário Eletrônico</a></li>
<li><a href="../pt413729/index.html">Como e por que escrevemos nosso ECS</a></li>
<li><a href="../pt413731/index.html">Pesquisa de Mercado de Trabalho BA / SA</a></li>
<li><a href="../pt413733/index.html">Mikrosh, Krista, Apogee, Lviv - os primeiros computadores take-away soviéticos</a></li>
<li><a href="../pt413739/index.html">Como digitalizamos toda a Internet e o que aprendemos</a></li>
<li><a href="../pt413741/index.html">O que era e como: impressões da equipe WWDC Redmadrobot</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>