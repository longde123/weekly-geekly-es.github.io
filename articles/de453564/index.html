<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⏳ 👨🏼‍⚖️ 🕘 Machen Sie es wahr - Entwickeln Sie ein Logikspiel für Unity 💇🏿 💺 🧓🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich möchte den Entwicklungsprozess eines einfachen Handyspiels von zwei Entwicklern und einem Künstler teilen. Dieser Artikel beschreibt weitgehend di...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Machen Sie es wahr - Entwickeln Sie ein Logikspiel für Unity</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453564/"><img src="https://habrastorage.org/webt/4k/h-/6e/4kh-6e4-iwvtuaz42eqb2gg81iu.png"><br><br>  Ich möchte den Entwicklungsprozess eines einfachen Handyspiels von zwei Entwicklern und einem Künstler teilen.  Dieser Artikel beschreibt weitgehend die technische Implementierung. <br>  Achtung, viel Text! <br><br>  Der Artikel ist keine Anleitung oder Lektion, obwohl ich hoffe, dass die Leser etwas Nützliches daraus lernen können.  Entwickelt für Entwickler, die mit Unity vertraut sind und über Programmiererfahrung verfügen. <br><a name="habracut"></a><br><a name="Content"></a><h4>  Inhalt: </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Idee</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gameplay</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Handlung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwicklung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kern</a> <br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Elektrische Elemente</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Löser</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ElementsProvider</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CircuitGenerator</a> </li></ol><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spielklassen</a> <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwicklungsansatz und DI</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Konfiguration</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Elektrische Elemente</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spielverwaltung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Level Laden</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zwischensequenzen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zusätzliches Gameplay</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Monetarisierung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Benutzeroberfläche</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Analytik</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kamerapositionierung und Diagramme</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Farbschemata</a> </li></ol><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Editor-Erweiterungen</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a> <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Generator</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Löser</a> </li></ol><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nützlich</a> <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Asserthelp</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SceneObjectsHelper</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Coroutinestarter</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gizmo</a> </li></ol><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Testen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwicklungszusammenfassung</a> <br><br><a name="Idea"></a><h2>  Idee </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br><br>  Es gab die Idee, in kurzer Zeit ein einfaches Handyspiel zu machen. <br><br>  Bedingungen: <br><br><ul><li>  Einfach zu implementierendes Spiel </li><li>  Mindestanforderungen an die Kunst </li><li>  Kurze Entwicklungszeit (mehrere Monate) </li><li>  Mit einfacher Automatisierung der Erstellung von Inhalten (Levels, Orte, Spielelemente) </li><li>  Erstelle schnell ein Level, wenn das Spiel aus einer endlichen Anzahl von Levels besteht </li></ul><br>  Um zu entscheiden, aber was eigentlich?  Schließlich kam die Idee auf, ein Spiel zu machen, nicht die Idee eines Spiels.  Es wurde beschlossen, sich vom App Store inspirieren zu lassen. <br><br>  Zu den oben genannten Elementen werden hinzugefügt: <br><br><ul><li>  Das Spiel sollte eine gewisse Beliebtheit bei den Spielern haben (Anzahl der Downloads + Bewertungen) </li><li>  Der App Store sollte nicht mit ähnlichen Spielen überfüllt sein </li></ul><br>  Es wurde ein Spiel gefunden, dessen Gameplay auf logischen Toren basiert.  Es gab keine ähnlichen in großer Anzahl. Das Spiel hat viele Downloads und positive Bewertungen.  Trotzdem gab es einige Nachteile, die in Ihrem Spiel berücksichtigt werden können. <br><br>  Das Gameplay des Spiels ist, dass der Level eine digitale Schaltung mit vielen Ein- und Ausgängen ist.  Der Spieler muss eine Kombination von Eingängen auswählen, damit der Ausgang logisch ist. 1. Es klingt nicht sehr schwierig.  Das Spiel hat auch automatisch generierte Levels, was darauf hindeutet, dass die Erstellung von Levels automatisiert werden kann, obwohl dies nicht sehr einfach klingt.  Das Spiel ist auch gut zum Lernen, was mir sehr gut gefallen hat. <br><br>  Vorteile: <br><br><ul><li>  Technische Einfachheit des Gameplays </li><li>  Sieht mit Autotests einfach zu testen aus </li><li>  Fähigkeit, Level automatisch zu generieren </li></ul><br>  Nachteile: <br><br><ul><li>  Sie müssen zuerst Ebenen erstellen </li></ul><br>  Erforschen Sie nun die Fehler des Spiels, die Sie inspiriert haben. <br><br><ul><li>  Nicht an das benutzerdefinierte Seitenverhältnis angepasst, z. B. 18: 9 </li><li>  Es gibt keine Möglichkeit, ein schwieriges Level zu überspringen oder einen Hinweis zu erhalten </li><li>  In den Bewertungen gab es Beschwerden über eine kleine Anzahl von Ebenen </li><li>  Die Bewertungen beschwerten sich über die mangelnde Vielfalt der Elemente </li></ul><br>  Wir fahren mit der Planung unseres Spiels fort: <br><br><ul><li>  Wir verwenden Standard-Logikgatter (AND, NAND, OR, NOR, XOR, XNOR, NOR, NOT). </li><li>  Tore werden mit einem Bild anstelle einer Textbezeichnung angezeigt, die leichter zu unterscheiden ist.  Da Elemente eine Standard-ANSI-Notation haben, verwenden wir sie. </li><li>  Wir verwerfen den Schalter, der einen Eingang mit einem der Ausgänge verbindet.  Aufgrund der Tatsache, dass Sie auf sich selbst klicken müssen und nicht ein wenig in die realen digitalen Elemente passen.  Ja, und ein Kippschalter in einem Chip ist kaum vorstellbar. </li><li>  Fügen Sie die Elemente des Codierers und Decodierers hinzu. </li><li>  Wir führen einen Modus ein, in dem der Spieler das gewünschte Element in der Zelle mit festen Werten an den Eingängen der Schaltung auswählen muss. </li><li>  Wir bieten dem Spieler Hilfe: Hinweis + Überspringstufe. </li><li>  Es wäre schön, eine Handlung hinzuzufügen. </li></ul><br><a name="Gameplay"></a><h2>  Gameplay </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br><br>  Modus 1: Der Spieler erhält eine Schaltung und kann die Werte an den Eingängen ändern. <br>  Modus 2: Der Spieler erhält eine Schaltung, in der er die Elemente ändern kann, aber die Werte an den Eingängen nicht ändern kann. <br><br>  Das Gameplay wird in Form von vorbereiteten Levels sein.  Nach Abschluss des Levels muss der Spieler ein Ergebnis erzielen. Dies erfolgt in Form der traditionellen drei Sterne, abhängig vom Ergebnis der Passage. <br><br>  Was können die Leistungsindikatoren sein: <br>  Anzahl der Aktionen: Jede Interaktion mit Spielelementen erhöht den Zähler. <br>  Die Anzahl der Unterschiede im resultierenden Zustand zum Original.  Berücksichtigt nicht, wie viele Versuche der Spieler ausführen musste.  Leider passt es nicht zum zweiten Regime. <br>  Es wäre schön, den gleichen Modus mit zufälliger Level-Generierung hinzuzufügen.  Aber vorerst, verschieben Sie es für später. <br><br><a name="Plot"></a><h2>  Handlung </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br><br>  Während ich über das Gameplay nachdachte und mit der Entwicklung begann, schienen verschiedene Ideen das Spiel zu verbessern.  Und es erschien eine interessante Idee - eine Handlung hinzuzufügen. <br><br>  Es geht um einen Ingenieur, der Schaltungen entwirft.  Nicht schlecht, aber nicht vollständig. Vielleicht lohnt es sich, die Herstellung von Chips basierend auf den Aktivitäten des Spielers anzuzeigen?  Irgendwie Routine gibt es kein verständliches und einfaches Ergebnis. <br><br>  Die Idee!  Ein Ingenieur entwickelt mit seinen Logikschaltungen einen coolen Roboter.  Der Roboter ist ziemlich einfach verständlich und passt perfekt zum Gameplay. <br><br>  Erinnern Sie sich an den ersten Absatz „Mindestanforderungen an Kunst“?  Etwas passt nicht zu den Zwischensequenzen in der Handlung.  Dann kommt ein bekannter Künstler zur Rettung, der sich bereit erklärt, uns zu helfen. <br><br>  Nun entscheiden wir uns für das Format und die Integration von Zwischensequenzen in das Spiel. <br><br>  Das Diagramm muss als Zwischensequenz ohne Bewertung oder als Textbeschreibung angezeigt werden, um Lokalisierungsprobleme zu beseitigen, das Verständnis zu vereinfachen und viele auf Mobilgeräten ohne Ton abzuspielen.  Das Spiel ist ein sehr reales Element digitaler Schaltkreise, das heißt, es ist durchaus möglich, dies mit der Realität zu verbinden. <br><br>  Zwischensequenzen und Ebenen sollten separate Szenen sein.  Vor einem bestimmten Level wird eine bestimmte Szene geladen. <br><br>  Nun, die Aufgabe ist festgelegt, es gibt Ressourcen zu erfüllen, die Arbeit hat begonnen zu kochen. <br><br><a name="Development"></a><h2>  Entwicklung </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br><br>  Ich habe mich sofort für die Plattform entschieden, das ist Unity.  Ja, ein bisschen übertrieben, aber ich kenne sie trotzdem. <br><br>  Während der Entwicklung wird der Code sofort mit Tests oder sogar danach geschrieben.  Für eine ganzheitliche Darstellung werden die Tests jedoch in einem separaten Abschnitt unten aufgeführt.  Im aktuellen Abschnitt wird der Entwicklungsprozess getrennt vom Testen beschrieben. <br><br><a name="Core"></a><h3>  Kern </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br><br>  Der Kern des Gameplays sieht ziemlich einfach aus und ist nicht an die Engine gebunden. Deshalb haben wir mit dem Design in Form von C # -Code begonnen.  Es scheint, dass Sie eine separate Kern-Kern-Logik auswählen können.  Nehmen Sie es zu einem separaten Projekt heraus. <br><br>  Unity arbeitet mit einer C # -Lösung und Projekte im Inneren sind für einen normalen .NET-Entwickler etwas ungewöhnlich. SLN- und CSsproj-Dateien werden von Unity selbst generiert, und Änderungen in diesen Dateien werden auf der Unity-Seite nicht berücksichtigt.  Er wird sie einfach überschreiben und alle Änderungen löschen.  Um ein neues Projekt zu erstellen, müssen Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Assembly Definition-</a> Datei verwenden. <br><br><img src="https://habrastorage.org/webt/b2/84/92/b28492ps5o-_mv62mdvo1frk4l8.png"><br><br><img src="https://habrastorage.org/webt/vd/xk/_k/vdxk_k9ydjfhu1aiee8ctlx3eau.png"><br><br>  Unity generiert jetzt ein Projekt mit dem entsprechenden Namen.  Alles, was sich in dem Ordner mit der .asmdef-Datei befindet, bezieht sich auf dieses Projekt und diese Assembly. <br><br><a name="CoreElectricalElements"></a><h4>  Elektrische Elemente </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br><br>  Die Aufgabe besteht darin, im Code die Interaktion logischer Elemente miteinander zu beschreiben. <br><br><ul><li>  Ein Element kann mehrere Eingänge und mehrere Ausgänge haben. </li><li>  Der Eingang des Elements muss mit dem Ausgang eines anderen Elements verbunden sein </li><li>  Das Element selbst muss eine eigene Logik enthalten. </li></ul><br>  Fangen wir an. <br><br><ul><li>  <b>Das Element</b> enthält eine eigene Funktionslogik und Verknüpfungen zu seinen Eingängen.  Wenn Sie einen Wert von einem Element anfordern, werden Werte von den Eingaben übernommen, auf diese logisch angewendet und das Ergebnis zurückgegeben.  Es können mehrere Ausgänge vorhanden sein, daher wird der Wert für einen bestimmten Ausgang angefordert. Der Standardwert ist 0. </li><li>  Um Werte am Eingang zu erfassen, gibt es einen <b>Eingangsanschluss</b> p, in dem eine Verknüpfung zu einem anderen - dem Ausgangsanschluss - gespeichert ist. </li><li>  <b>Der Ausgabekonnektor</b> verweist auf ein bestimmtes Element und speichert eine Verknüpfung zu seinem Element. Wenn er einen Wert anfordert, fordert er ihn vom Element an. </li></ul><br><img src="https://habrastorage.org/webt/am/7q/yo/am7qyonro-bohnomthogk8qy8o0.png"><br><br>  Die Pfeile geben die Richtung der Daten an, die Abhängigkeit der Elemente in die entgegengesetzte Richtung. <br>  Definieren Sie die Schnittstelle des Anschlusses.  Sie können den Wert daraus erhalten. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IConnector</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Value { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } }</code> </pre> <br>  Wie kann man es an einen anderen Stecker anschließen? <br><br>  Definieren Sie weitere Schnittstellen. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IInputConnector</span></span> : <span class="hljs-title"><span class="hljs-title">IConnector</span></span> { IOutputConnector ConnectedOtherConnector { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre> <br>  IInputConnector ist ein Eingangsconnector und hat eine Verbindung zu einem anderen Connector. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IOutputConnector</span></span> : <span class="hljs-title"><span class="hljs-title">IConnector</span></span> { IElectricalElement Element { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } }</code> </pre> <br>  Der Ausgangsanschluss bezieht sich auf sein Element, von dem er einen Wert anfordert. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IElectricalElement</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetValue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params"> number = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span></span><span class="hljs-function">)</span></span>; }</code> </pre> <br>  Das elektrische Element muss eine Methode enthalten, die einen Wert für einen bestimmten Ausgang zurückgibt. Number ist die Nummer des Ausgangs. <br><br>  <i>Ich habe es IElectricalElement genannt, obwohl es nur logische Spannungspegel überträgt, aber andererseits kann es ein Element sein, das überhaupt keine Logik hinzufügt, sondern nur einen Wert vermittelt, wie ein Leiter.</i> <br><br>  Fahren wir nun mit der Implementierung fort <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">InputConnector</span></span> : <span class="hljs-title"><span class="hljs-title">IInputConnector</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IOutputConnector ConnectedOtherConnector { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Value { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ConnectedOtherConnector?.Value ?? <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } }</code> </pre> <br>  Der eingehende Connector ist möglicherweise nicht verbunden. In diesem Fall wird false zurückgegeben. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">OutputConnector</span></span> : <span class="hljs-title"><span class="hljs-title">IOutputConnector</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> number; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OutputConnector</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params"> number = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.number = number; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IElectricalElement Element { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Value =&gt; Element.GetValue(number); } }</code> </pre> <br>  Die Ausgabe sollte einen Link zu ihrem Element und seiner Nummer in Bezug auf das Element haben. <br>  Außerdem fordert er unter Verwendung dieser Nummer einen Wert vom Element an. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ElectricalElementBase</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IInputConnector[] Input { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre><br>  Die Basisklasse für alle Elemente enthält nur ein Array von Eingaben. <br><br>  Beispielimplementierung eines Elements: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">And</span></span> : <span class="hljs-title"><span class="hljs-title">ElectricalElementBase</span></span>, <span class="hljs-title"><span class="hljs-title">IElectricalElement</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetValue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params"> number = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> outputValue = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input?.Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { outputValue = Input[<span class="hljs-number"><span class="hljs-number">0</span></span>].Value; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Input) { outputValue &amp;= item.Value; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> outputValue; } }</code> </pre> <br>  Die Implementierung basiert vollständig auf logischen Operationen ohne eine harte Wahrheitstabelle.  Vielleicht nicht so explizit wie bei der Tabelle, aber sie ist flexibel und funktioniert mit einer beliebigen Anzahl von Eingaben. <br>  Alle Logikgatter haben einen Ausgang, sodass der Wert am Ausgang nicht von der Eingangsnummer abhängt. <br><br>  Invertierte Elemente werden wie folgt hergestellt: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Nand</span></span> : <span class="hljs-title"><span class="hljs-title">And</span></span>, <span class="hljs-title"><span class="hljs-title">IElectricalElement</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> new </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetValue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params"> number = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !<span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.GetValue(number); } }</code> </pre> <br>  Es ist erwähnenswert, dass hier die GetValue-Methode überschrieben und nicht virtuell überschrieben wird.  Dies geschieht auf der Grundlage der Logik, dass Nand sich weiterhin wie Und verhält, wenn er in Und speichert.  Es war auch möglich, die Komposition anzuwenden, dies würde jedoch zusätzlichen Code erfordern, was wenig Sinn macht. <br><br>  Neben herkömmlichen Ventilen wurden folgende Elemente erstellt: <br>  Quelle - eine Quelle mit konstantem Wert von 0 oder 1. <br>  Leiter - genau der gleiche oder Leiter, hat nur eine etwas andere Anwendung, siehe Generation. <br>  AlwaysFalse - gibt immer 0 zurück, was für den zweiten Modus benötigt wird. <br><br><a name="Solver"></a><h4>  Löser </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br><br>  Als nächstes ist eine Klasse nützlich, um automatisch Kombinationen zu finden, die am Ausgang der Schaltung 1 ergeben. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ISolver</span></span> { ICollection&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[]&gt; GetSolutions(IElectricalElement root, <span class="hljs-keyword"><span class="hljs-keyword">params</span></span> Source[] sources); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Solver</span></span> : <span class="hljs-title"><span class="hljs-title">ISolver</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ICollection&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[]&gt; GetSolutions(IElectricalElement root, <span class="hljs-keyword"><span class="hljs-keyword">params</span></span> Source[] sources) { <span class="hljs-comment"><span class="hljs-comment">// max value can be got with this count of bits(sources count), also it's count of combinations -1 // for example 8 bits provide 256 combinations, and max value is 255 int maxValue = Pow(sources.Length); // inputs that can solve circuit var rightInputs = new List&lt;bool[]&gt;(); for (int i = 0; i &lt; maxValue; i++) { var inputs = GetBoolArrayFromInt(i, sources.Length); for (int j = 0; j &lt; sources.Length; j++) { sources[j].Value = inputs[j]; } if (root.GetValue()) { rightInputs.Add(inputs); } } return rightInputs; } private static int Pow(int power) { int x = 2; for (int i = 1; i &lt; power; i++) { x *= 2; } return x; } private static bool[] GetBoolArrayFromInt(int value, int length) { var bitArray = new BitArray(new[] {value}); var boolArray = new bool[length]; for (int i = length - 1; i &gt;= 0; i—) { boolArray[i] = bitArray[i]; } return boolArray; }</span></span></code> </pre> <br>  Die Lösungen sind Brute Force.  Hierzu wird die maximale Anzahl bestimmt, die durch einen Satz von Bits in einer Menge ausgedrückt werden kann, die der Anzahl von Quellen entspricht.  Das heißt, 4 Quellen = 4 Bits = maximale Zahl 15. Wir sortieren alle Zahlen von 0 bis 15. <br><br><a name="ElementsProvider"></a><h4>  ElementsProvider </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br><br>  Zur Vereinfachung der Generierung habe ich beschlossen, für jedes Element eine Nummer zu definieren. Dazu habe ich die ElementsProvider-Klasse mit der IElementsProvider-Schnittstelle erstellt. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IElementsProvider</span></span> { IList&lt;Func&lt;IElectricalElement&gt;&gt; Gates { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } IList&lt;Func&lt;IElectricalElement&gt;&gt; Conductors { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } IList&lt;ElectricalElementType&gt; GateTypes { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } IList&lt;ElectricalElementType&gt; ConductorTypes { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ElementsProvider</span></span> : <span class="hljs-title"><span class="hljs-title">IElementsProvider</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IList&lt;Func&lt;IElectricalElement&gt;&gt; Gates { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Func&lt;IElectricalElement&gt;&gt; { () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> And(), () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Nand(), () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Or(), () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Nor(), () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Xor(), () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Xnor() }; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IList&lt;Func&lt;IElectricalElement&gt;&gt; Conductors { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Func&lt;IElectricalElement&gt;&gt; { () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Conductor(), () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Not() }; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IList&lt;ElectricalElementType&gt; GateTypes { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;ElectricalElementType&gt; { ElectricalElementType.And, ElectricalElementType.Nand, ElectricalElementType.Or, ElectricalElementType.Nor, ElectricalElementType.Xor, ElectricalElementType.Xnor }; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IList&lt;ElectricalElementType&gt; ConductorTypes { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;ElectricalElementType&gt; { ElectricalElementType.Conductor, ElectricalElementType.Not }; }</code> </pre> <br>  Die ersten beiden Listen sind so etwas wie Fabriken, die einen Artikel mit der angegebenen Nummer angeben.  Die letzten beiden Listen sind eine Krücke, die aufgrund der Funktionen von Unity verwendet werden muss.  Darüber weiter. <br><br><a name="CircuitGenerator"></a><h4>  CircuitGenerator </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br><br>  Der schwierigste Teil der Entwicklung ist nun die Schaltungserzeugung. <br><br>  Die Aufgabe besteht darin, eine Liste von Schemata zu erstellen, aus denen Sie im Editor das gewünschte auswählen können.  Die Erzeugung wird nur für einfache Ventile benötigt. <br><br>  Bestimmte Parameter des Schemas werden festgelegt. Dies sind: die Anzahl der Ebenen (horizontale Linien von Elementen) und die maximale Anzahl von Elementen in der Ebene.  Sie müssen auch bestimmen, aus welchen Gates Sie Schaltungen erzeugen müssen. <br><br>  Mein Ansatz war es, die Aufgabe in zwei Teile aufzuteilen - Strukturgenerierung und Auswahl von Optionen. <br><br>  Der Strukturgenerator bestimmt die Positionen und Verbindungen von Logikelementen. <br>  Der Variantengenerator wählt gültige Kombinationen von Elementen in Positionen aus. <br><br><h4>  Strukturgenerator </h4><br>  Die Struktur besteht aus Schichten von Logikelementen und Schichten von Leitern / Wechselrichtern.  Die gesamte Struktur enthält keine realen Elemente, sondern Container für diese. <br><br>  Der Container ist eine von IElectricalElement geerbte Klasse, die eine Liste gültiger Elemente enthält und zwischen diesen wechseln kann.  Jeder Artikel hat eine eigene Nummer in der Liste. <br><br><pre> <code class="cs hljs">ElectricalElementContainer : ElectricalElementBase, IElectricalElement</code> </pre> <br><br>  Ein Container kann "sich" auf eines der Elemente aus der Liste setzen.  Während der Initialisierung müssen Sie eine Liste der Delegierten angeben, die die Elemente erstellen.  Im Inneren ruft es jeden Delegierten an und erhält den Artikel.  Dann können Sie den spezifischen Typ dieses Elements festlegen. Dadurch wird das interne Element mit denselben Eingaben wie im Container verbunden, und die Ausgabe aus dem Container wird aus der Ausgabe dieses Elements übernommen. <br><br><img src="https://habrastorage.org/webt/wq/kt/bn/wqktbn6x7esbfnqxkuwh606qvqa.png"><br><br>  Methode zum Festlegen der Liste der Elemente: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetElements</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IList&lt;Func&lt;IElectricalElement&gt;&gt; elements</span></span></span><span class="hljs-function">)</span></span> { Elements = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;IElectricalElement&gt;(elements.Count); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> elements) { Elements.Add(item()); } }</code> </pre> <br>  Als nächstes können Sie den Typ folgendermaßen einstellen: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetType</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> number</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isInitialized == <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(UnitializedElementsExceptionMessage); } SelectedType = number; RealElement = Elements[number]; ((ElectricalElementBase) RealElement).Input = Input; }</code> </pre> <br>  Danach funktioniert es als angegebenes Element. <br><br>  Die folgende Struktur wurde für die Schaltung erstellt: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CircuitStructure</span></span> : <span class="hljs-title"><span class="hljs-title">ICloneable</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IDictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, ElectricalElementContainer[]&gt; Gates; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IDictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, ElectricalElementContainer[]&gt; Conductors; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Source[] Sources; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> And FinalDevice; }</code> </pre> <br>  Wörterbücher speichern hier die Ebenennummer im Schlüssel und eine Reihe von Containern für diese Ebene.  Als nächstes folgt eine Reihe von Quellen und ein FinalDevice, mit dem alles verbunden ist. <br><br>  Somit erstellt der Strukturgenerator Container und verbindet sie miteinander.  Dies alles wird in Ebenen von unten nach oben erstellt.  Der Boden ist am breitesten (die meisten Elemente).  Die darüber liegende Ebene enthält zweimal weniger Elemente usw., bis wir ein Minimum erreichen.  Die Ausgänge aller Elemente der obersten Schicht sind mit dem Endgerät verbunden. <br><br>  Die Logikelementschicht enthält Container für Gates.  In der Leiterschicht gibt es Elemente mit einem Ein- und Ausgang.  Elemente dort können entweder ein Leiter oder ein NO-Element sein.  Der Leiter geht zum Ausgang, was zum Eingang kam, und das NO-Element gibt den invertierten Wert am Ausgang zurück. <br><br>  Der erste, der ein Array von Quellen erstellt.  Die Erzeugung erfolgt von unten nach oben, zuerst wird die Leiterschicht erzeugt, dann die Logikschicht und am Ausgang wieder Leiter. <br><br><img src="https://habrastorage.org/webt/pq/bj/hs/pqbjhsbn3xxxi6r6wosryczrdjc.png"><br><br>  Aber solche Pläne sind sehr langweilig!  Wir wollten unser Leben noch mehr vereinfachen und beschlossen, die erzeugten Strukturen interessanter (komplexer) zu machen. Es wurde beschlossen, Strukturmodifikationen mit Verzweigung oder Verbindung durch viele Schichten hinzuzufügen. <br><br>  Um „vereinfacht“ zu sagen - das bedeutet, dass Sie Ihr Leben in etwas anderem komplizieren müssen. <br>  Das Erzeugen von Schaltkreisen mit maximaler Modifizierbarkeit erwies sich als mühsame und nicht ganz praktische Aufgabe.  Aus diesem Grund hat unser Team beschlossen, die folgenden Kriterien zu erfüllen: <br>  Die Entwicklung dieser Aufgabe dauerte nicht lange. <br>  Mehr oder weniger adäquate Erzeugung modifizierter Strukturen. <br>  Es gab keine Schnittpunkte zwischen den Leitern. <br>  Aufgrund einer langen und harten Programmierung wurde die Lösung um 16 Uhr geschrieben. <br>  Werfen wir einen Blick auf den Code und ̶̶̶̶̶̶̶̶̶̶. <br><br>  <i>Hier wird die OverflowArray-Klasse angetroffen.</i>  <i>Aus historischen Gründen wurde es nach der grundlegenden Strukturgenerierung hinzugefügt und hat mehr mit der Variantengenerierung zu tun, daher befindet es sich unten.</i>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a></i> <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerable&lt;CircuitStructure&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateStructure</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lines, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxElementsInLine, StructureModification modification</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> baseStructure = GenerateStructure(lines, maxElementsInLine); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; lines; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxValue = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> branchingSign = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (modification == StructureModification.All) { maxValue = <span class="hljs-number"><span class="hljs-number">2</span></span>; branchingSign = <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lengthOverflowArray = baseStructure.Gates[(i * <span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>].Length; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> elementArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OverflowArray(lengthOverflowArray, maxValue); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> numberOfOption = Math.Pow(<span class="hljs-number"><span class="hljs-number">2</span></span>, lengthOverflowArray); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">1</span></span>; k &lt; numberOfOption - <span class="hljs-number"><span class="hljs-number">1</span></span>; k++) { elementArray.Increase(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (modification == StructureModification.Branching || modification == StructureModification.All) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CheckOverflowArrayForAllConnection(elementArray, branchingSign, lengthOverflowArray)) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } } <span class="hljs-comment"><span class="hljs-comment">// Clone CircuitStructure var structure = (CircuitStructure) baseStructure.Clone(); ConfigureInputs(lines, structure.Conductors, structure.Gates); var sources = AddSourcesLayer(structure.Conductors, maxElementsInLine); var finalElement = AddFinalElement(structure.Conductors); structure.Sources = sources; structure.FinalDevice = finalElement; int key = (i * 2) + 1; ModifyStructure(structure, elementArray, key, modification); ClearStructure(structure); yield return structure; } } }</span></span></code> </pre> <br>  Nachdem ich diesen Code angesehen habe, möchte ich verstehen, was darin passiert. <br>  Keine Sorge!  Eine kurze Erklärung ohne Details eilt zu Ihnen. <br><br>  Als erstes erstellen wir eine gewöhnliche (Basis-) Struktur. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> baseStructure = GenerateStructure(lines, maxElementsInLine);</code> </pre> <br>  Als Ergebnis einer einfachen Überprüfung setzen wir das Verzweigungszeichen (branchingSign) auf den entsprechenden Wert. Warum ist dies erforderlich?  Weiter wird es klar sein. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxValue = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> branchingSign = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (modification == StructureModification.All) { maxValue = <span class="hljs-number"><span class="hljs-number">2</span></span>; branchingSign = <span class="hljs-number"><span class="hljs-number">2</span></span>; }</code> </pre> <br>  Jetzt bestimmen wir die Länge unseres OverflowArray und initialisieren es. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lengthOverflowArray = baseStructure.Gates[(i * <span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>].Length; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> elementArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OverflowArray(lengthOverflowArray, maxValue);</code> </pre> <br>  Damit wir unsere Manipulationen mit der Struktur fortsetzen können, müssen wir die Anzahl der möglichen Variationen unseres OverflowArray herausfinden.  Zu diesem Zweck wurde in der nächsten Zeile eine Formel angewendet. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lengthOverflowArray = baseStructure.Gates[(i * <span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>].Length;</code> </pre> <br>  Als nächstes folgt eine verschachtelte Schleife, in der die gesamte „Magie“ stattfindet und für die es all dieses Vorwort gab. Ganz am Anfang erhöhen wir die Werte unseres Arrays. <br><br><pre> <code class="cs hljs">elementArray.Increase();</code> </pre><br>  Danach sehen wir eine Validierungsprüfung, als Ergebnis gehen wir weiter oder die nächste Iteration. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (modification == StructureModification.Branching || modification == StructureModification.All) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CheckOverflowArrayForAllConnection(elementArray, branchingSign, lengthOverflowArray)) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } }</code> </pre><br>  Wenn das Array die Validierungsprüfung bestanden hat, klonen wir unsere Basisstruktur.  Das Klonen ist erforderlich, da wir unsere Struktur für viele weitere Iterationen ändern werden. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Clone CircuitStructure var structure = (CircuitStructure) baseStructure.Clone(); ConfigureInputs(lines, structure.Conductors, structure.Gates); var sources = AddSourcesLayer(structure.Conductors, maxElementsInLine); var finalElement = AddFinalElement(structure.Conductors); structure.Sources = sources; structure.FinalDevice = finalElement;</span></span></code> </pre> <br>  Und schließlich beginnen wir, die Struktur zu modifizieren und sie von unnötigen Elementen zu befreien.  Sie wurden durch strukturelle Veränderungen unnötig. <br><br><pre> <code class="cs hljs">ModifyStructure(structure, elementArray, key, modification); ClearStructure(structure);</code> </pre> <br>  Ich sehe den Punkt nicht im Detail, um Dutzende kleiner Funktionen zu analysieren, die "irgendwo dort" in den Tiefen ausgeführt werden. <br><br><h4>  Variantengenerator </h4><br>  Die Struktur + Elemente, die darin enthalten sein sollten, heißen CircuitVariant. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> CircuitVariant { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CircuitStructure Structure; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IDictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[]&gt; Gates; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IDictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[]&gt; Conductors; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IList&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[]&gt; Solutions; }</code> </pre> <br>  Das erste Feld ist eine Verknüpfung zur Struktur.  Die zweiten beiden Wörterbücher, in denen der Schlüssel die Nummer der Ebene ist und der Wert ein Array ist, das die Anzahl der Elemente an ihren Stellen in der Struktur enthält. <br><br>  Wir fahren mit der Auswahl der Kombinationen fort.  Wir können eine bestimmte Anzahl gültiger Logikelemente und Leiter haben.  Insgesamt können 6 Logikelemente und 2 Leiter vorhanden sein. <br>  Sie können sich ein Zahlensystem mit einer Basis von 6 vorstellen und in jeder Kategorie die Zahlen erhalten, die den Elementen entsprechen.  Durch Erhöhen dieser Hexadezimalzahl können Sie also alle Kombinationen von Elementen durchlaufen. <br><br>  Das heißt, eine hexadezimale Zahl von drei Ziffern besteht aus 3 Elementen.  Es ist nur zu berücksichtigen, dass die Anzahl der Elemente nicht 6, sondern 4 übertragen werden kann. <br><br>  Um eine solche Zahl zu entladen, habe ich die Struktur bestimmt <br><a name="ClampedInt"></a><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ClampedInt { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Value { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = Mathf.Clamp(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, MaxValue); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MaxValue; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClampedInt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxValue</span></span></span><span class="hljs-function">)</span></span> { MaxValue = maxValue; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryIncrease</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Value + <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;= MaxValue) { Value++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// overflow return true; } }</span></span></code> </pre> <br><a name="OverflowArray"></a><br>  Als nächstes kommt eine Klasse mit dem seltsamen Namen <b>OverflowArray</b> .  Das Wesentliche ist, dass es das <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ClampedInt-</a></b> Array speichert und die hohe Ordnung erhöht, falls ein Überlauf <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in der niedrigen</a></b> Ordnung usw. <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auftritt</a></b> , bis der Maximalwert in allen Zellen erreicht ist. <br><br>  In Übereinstimmung mit jedem ClampedInt werden die Werte des entsprechenden ElectricalElementContainer festgelegt.  Somit ist es möglich, alle möglichen Kombinationen auszusortieren.  Wenn Sie ein Schema mit Elementen (z. B. And (0) und Xor (4)) erstellen möchten, müssen Sie nicht alle Optionen sortieren, einschließlich der Elemente 1, 2, 3.  Dafür erhalten die Elemente während der Generierung ihre lokalen Nummern (z. B. And = 0, Xor = 1) und werden anschließend wieder in globale Nummern konvertiert. <br><br>  So können Sie alle möglichen Kombinationen in allen Elementen durchlaufen. <br><br>  Nachdem die Werte in den Containern eingestellt wurden, wird die Schaltung mit <b>Solver</b> auf Lösungen überprüft.  Wenn die Schaltung die Entscheidung besteht, kehrt sie zurück. <br><br>  Nachdem die Schaltung erzeugt wurde, wird die Anzahl der Lösungen überprüft.  Es sollte den Grenzwert nicht überschreiten und keine Entscheidungen treffen, die ausschließlich aus 0 oder 1 bestehen. <br><br><div class="spoiler">  <b class="spoiler_title">Viel Code</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IVariantsGenerator</span></span> { <span class="hljs-function"><span class="hljs-function">IEnumerable&lt;CircuitVariant&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Generate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IEnumerable&lt;CircuitStructure&gt; structures, ICollection&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; availableGates, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> useNot, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxSolutions = </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">.MaxValue</span></span></span><span class="hljs-function">)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">VariantsGenerator</span></span> : <span class="hljs-title"><span class="hljs-title">IVariantsGenerator</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ISolver solver; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> IElementsProvider elementsProvider; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VariantsGenerator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ISolver solver, IElementsProvider elementsProvider</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.solver = solver; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.elementsProvider = elementsProvider; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerable&lt;CircuitVariant&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Generate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IEnumerable&lt;CircuitStructure&gt; structures, ICollection&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; availableGates, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> useNot, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxSolutions = </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">.MaxValue</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> manyGates = availableGates.Count &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> availableLeToGeneralNumber = GetDictionaryFromAllowedElements(elementsProvider.Gates, availableGates); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gatesList = GetElementsList(availableLeToGeneralNumber, elementsProvider.Gates); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> availableConductorToGeneralNumber = useNot ? GetDictionaryFromAllowedElements(elementsProvider.Conductors, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}) : GetDictionaryFromAllowedElements(elementsProvider.Conductors, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] {<span class="hljs-number"><span class="hljs-number">0</span></span>}); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> conductorsList = GetElementsList(availableConductorToGeneralNumber, elementsProvider.Conductors); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> structure <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> structures) { InitializeCircuitStructure(structure, gatesList, conductorsList); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gates = GetListFromLayersDictionary(structure.Gates); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> conductors = GetListFromLayersDictionary(structure.Conductors); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gatesArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OverflowArray(gates.Count, availableGates.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> conductorsArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OverflowArray(conductors.Count, useNot ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useNot &amp;&amp; conductorsArray.EqualInts) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } SetContainerValuesAccordingToArray(conductors, conductorsArray); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (manyGates &amp;&amp; gatesArray.Length &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; gatesArray.EqualInts) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } SetContainerValuesAccordingToArray(gates, gatesArray); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> solutions = solver.GetSolutions(structure.FinalDevice, structure.Sources); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (solutions.Any() &amp;&amp; solutions.Count &lt;= maxSolutions &amp;&amp; !(solutions.Any(s =&gt; s.All(b =&gt; b)) || solutions.Any(s =&gt; s.All(b =&gt; !b)))) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> variant = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CircuitVariant { Conductors = GetElementsNumberFromLayers(structure.Conductors, availableConductorToGeneralNumber), Gates = GetElementsNumberFromLayers(structure.Gates, availableLeToGeneralNumber), Solutions = solutions, Structure = structure }; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> variant; } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!gatesArray.Increase()); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (useNot &amp;&amp; !conductorsArray.Increase()); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeCircuitStructure</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CircuitStructure structure, IList&lt;Func&lt;IElectricalElement&gt;&gt; gates, IList&lt;Func&lt;IElectricalElement&gt;&gt; conductors</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lElements = GetListFromLayersDictionary(structure.Gates); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> lElements) { item.SetElements(gates); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cElements = GetListFromLayersDictionary(structure.Conductors); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cElements) { item.SetElements(conductors); } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IList&lt;Func&lt;IElectricalElement&gt;&gt; GetElementsList(IDictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; availableToGeneralGate, IReadOnlyList&lt;Func&lt;IElectricalElement&gt;&gt; elements) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Func&lt;IElectricalElement&gt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> availableToGeneralGate) { list.Add(elements[item.Value]); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IDictionary&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">, </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetDictionaryFromAllowedElements</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IReadOnlyCollection&lt;Func&lt;IElectricalElement&gt;&gt; allElements, IEnumerable&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; availableElements</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> enabledDic = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;(allElements.Count); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; allElements.Count; i++) { enabledDic.Add(i, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> availableElements) { enabledDic[item] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> availableToGeneralNumber = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enabledDic) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item.Value) { availableToGeneralNumber.Add(index, item.Key); index++; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> availableToGeneralNumber; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetContainerValuesAccordingToArray</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IReadOnlyList&lt;ElectricalElementContainer&gt; containers, IOverflowArray overflowArray</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; containers.Count; i++) { containers[i].SetType(overflowArray[i].Value); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IReadOnlyList&lt;ElectricalElementContainer&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetListFromLayersDictionary</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IDictionary&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, ElectricalElementContainer[]&gt; layers</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> elements = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;ElectricalElementContainer&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> layer <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> layers) { elements.AddRange(layer.Value); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elements; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IDictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[]&gt; GetElementsNumberFromLayers(IDictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, ElectricalElementContainer[]&gt; layers, IDictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; elementIdToGlobal = <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dic = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[]&gt;(layers.Count); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> convert = elementIdToGlobal != <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> layer <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> layers) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> values = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[layer.Value.Length]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; layer.Value.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!convert) { values[i] = layer.Value[i].SelectedType; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { values[i] = elementIdToGlobal[layer.Value[i].SelectedType]; } } dic.Add(layer.Key, values); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dic; } }</code> </pre> <br></div></div><br>  Jeder der Generatoren gibt eine Variante mit der Yield-Anweisung zurück.  So generiert CircuitGenerator mit StructureGenerator und VariantsGenerator IEnumerable. (Der Ansatz mit Ertrag hat in Zukunft sehr geholfen, siehe unten) <br><br>  Daraus folgt, dass der Optionsgenerator eine Liste von Strukturen erhält.  Sie können Optionen für jede Struktur unabhängig generieren.  Dies könnte parallelisiert werden, aber das Hinzufügen von AsParallel funktionierte nicht (wahrscheinlich ergeben sich Interferenzen).  Das manuelle Parallelisieren wird lange dauern, da wir diese Option verwerfen.  <i>Tatsächlich habe ich versucht, eine parallele Generierung durchzuführen, es hat funktioniert, aber es gab einige Schwierigkeiten, weil es nicht in das Repository ging.</i> <br><br><a name="GameClasses"></a><h3>  Spielklassen </h3><br><a name="Approach"></a><h4>  Entwicklungsansatz und DI </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br><br>  Das Projekt wird unter <b>Dependency Injection</b> (DI) erstellt.  Dies bedeutet, dass Klassen einfach eine Art Objekt benötigen können, das der Schnittstelle entspricht, und nicht an der Erstellung dieses Objekts beteiligt sind.  Was sind die Vorteile: <br><br><ul><li>  Der Ort der Erstellung und Initialisierung des Abhängigkeitsobjekts wird an einer Stelle definiert und von der Logik der abhängigen Klassen getrennt, wodurch die Codeduplizierung beseitigt wird. </li><li>  Beseitigt die Notwendigkeit, den gesamten Abhängigkeitsbaum auszugraben und alle Abhängigkeiten zu instanziieren. </li><li>  Ermöglicht das einfache Ändern der Implementierung der Schnittstelle, die an vielen Stellen verwendet wird. </li></ul><br>  Als DI-Container im Projekt wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://github.com/modesttree/Zenject">Zenject</a> verwendet. <br><br>  Zenject hat mehrere Kontexte, ich benutze nur zwei davon: <br><br><ul><li>  Projektkontext - Registrierung von Abhängigkeiten innerhalb der gesamten Anwendung. </li><li>  Szenenkontext: Die Registrierung von Klassen, die nur in einer bestimmten Szene existieren und deren Lebensdauer durch die Lebensdauer der Szene begrenzt ist. </li><li>  Ein statischer Kontext ist ein allgemeiner Kontext für alles im Allgemeinen. Die Besonderheit ist, dass er im Editor vorhanden ist.  Ich benutze für die Injektion im Editor </li></ul><br>  Die Klassenregistrierung wird in <b>Installer</b> s gespeichert.  Ich verwende <b>ScriptableObjectInstaller</b> für den Projektkontext und <b>MonoInstaller</b> für den Szenenkontext. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die meisten Klassen, die ich bei AsSingle registriere, sind eher Container für Methoden, da sie keinen Status enthalten. Ich verwende AsTransient für Klassen, in denen es einen internen Status gibt, der anderen Klassen nicht gemeinsam sein sollte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Danach müssen Sie irgendwie MonoBehaviour-Klassen erstellen, die diese Elemente darstellen. Ich habe auch Klassen in Bezug auf Unity einem separaten Projekt zugewiesen, abhängig vom Kernprojekt. </font></font><br><br><img src="https://habrastorage.org/webt/eg/s1/se/egs1seui5csmxylqk9we7qhedwc.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Für MonoBehaviour-Klassen ziehe ich es vor, meine eigenen Schnittstellen zu erstellen. Dies ermöglicht Ihnen zusätzlich zu den Standardvorteilen von Schnittstellen, eine sehr große Anzahl von MonoBehaviour-Mitgliedern auszublenden.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Einfachheit halber erstellt DI häufig eine einfache Klasse, in der die gesamte Logik ausgeführt wird, und einen MonoBehaviour-Wrapper dafür. </font><font style="vertical-align: inherit;">Zum Beispiel hat die Klasse Start- und Aktualisierungsmethoden. Ich erstelle solche Methoden in der Klasse, füge dann in der MonoBehaviour-Klasse ein Abhängigkeitsfeld hinzu und rufe in den entsprechenden Methoden Start und Aktualisierung auf. </font><font style="vertical-align: inherit;">Dies gibt dem Konstrukteur die „richtige“ Injektion, die Ablösung der Hauptklasse vom DI-Behälter und die Fähigkeit, leicht zu testen.</font></font><br><br><a name="Config"></a><h4>  Konfiguration </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit Konfiguration meine ich Daten, die der gesamten Anwendung gemeinsam sind. </font><font style="vertical-align: inherit;">In meinem Fall sind dies Fertighäuser, Kennungen für Werbung und Einkäufe, Tags, Szenennamen usw. </font><font style="vertical-align: inherit;">Für diese Zwecke verwende ich ScriptableObjects:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Für jede Datengruppe wird eine ScriptableObject-Nachkommenklasse zugewiesen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es werden die erforderlichen serialisierbaren Felder erstellt </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Leseeigenschaften aus diesen Feldern werden hinzugefügt. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Schnittstelle zu den obigen Feldern ist hervorgehoben </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eine Klasse registriert sich bei einer Schnittstelle in einem DI-Container </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gewinn </font></font></li></ol><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ITags</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> FixedColor { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> BackgroundColor { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> ForegroundColor { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> AccentedColor { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } } [CreateAssetMenu(fileName = <span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(Tags), menuName = <span class="hljs-string"><span class="hljs-string">"Configuration/"</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(Tags))] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Tags</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span>, <span class="hljs-title"><span class="hljs-title">ITags</span></span> { [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> fixedColor; [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> backgroundColor; [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> foregroundColor; [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> accentedColor; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> FixedColor =&gt; fixedColor; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> BackgroundColor =&gt; backgroundColor; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> ForegroundColor =&gt; foregroundColor; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> AccentedColor =&gt; accentedColor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { fixedColor.AssertNotEmpty(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(fixedColor)); backgroundColor.AssertNotEmpty(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(backgroundColor)); foregroundColor.AssertNotEmpty(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(foregroundColor)); accentedColor.AssertNotEmpty(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(accentedColor)); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Für die Konfiguration ein separates Installationsprogramm (Code abgekürzt): </font></font><br><br><pre> <code class="cs hljs">CreateAssetMenu(fileName = <span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(ConfigurationInstaller), menuName = <span class="hljs-string"><span class="hljs-string">"Installers/"</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(ConfigurationInstaller))] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ConfigurationInstaller</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObjectInstaller</span></span>&lt;<span class="hljs-title"><span class="hljs-title">ConfigurationInstaller</span></span>&gt; { [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> EditorElementsPrefabs editorElementsPrefabs; [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> LevelCompletionSteps levelCompletionSteps; [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CommonValues commonValues; [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> AdsConfiguration adsConfiguration; [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CutscenesConfiguration cutscenesConfiguration; [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Colors colors; [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Tags tags; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InstallBindings</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Container.Bind&lt;IEditorElementsPrefabs&gt;().FromInstance(editorElementsPrefabs).AsSingle(); Container.Bind&lt;ILevelCompletionSteps&gt;().FromInstance(levelCompletionSteps).AsSingle(); Container.Bind&lt;ICommonValues&gt;().FromInstance(commonValues).AsSingle(); Container.Bind&lt;IAdsConfiguration&gt;().FromInstance(adsConfiguration).AsSingle(); Container.Bind&lt;ICutscenesConfiguration&gt;().FromInstance(cutscenesConfiguration).AsSingle(); Container.Bind&lt;IColors&gt;().FromInstance(colors).AsSingle(); Container.Bind&lt;ITags&gt;().FromInstance(tags).AsSingle(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { editorElementsPrefabs.AssertNotNull(); levelCompletionSteps.AssertNotNull(); commonValues.AssertNotNull(); adsConfiguration.AssertNotNull(); cutscenesConfiguration.AssertNotNull(); colors.AssertNOTNull(); tags.AssertNotNull(); } }</code> </pre> <br><a name="GameElectricalElements"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Elektrische Elemente </font></font></h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt müssen Sie sich die elektrischen Elemente irgendwie vorstellen </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IElectricalElementMb</span></span> { GameObject GameObject { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } IElectricalElement Element { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } IOutputConnectorMb[] OutputConnectorsMb { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } IInputConnectorMb[] InputConnectorsMb { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } Transform Transform { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetInputConnectorsMb</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">InputConnectorMb[] inputConnectorsMb</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetOutputConnectorsMb</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">OutputConnectorMb[] outputConnectorsMb</span></span></span><span class="hljs-function">)</span></span>; } [DisallowMultipleComponent] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ElectricalElementMb</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span>, <span class="hljs-title"><span class="hljs-title">IElectricalElementMb</span></span> { [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> OutputConnectorMb[] outputConnectorsMb; [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> InputConnectorMb[] inputConnectorsMb; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform Transform =&gt; transform; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject GameObject =&gt; gameObject; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> =&gt; name; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> =&gt; name = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> IElectricalElement Element { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IOutputConnectorMb[] OutputConnectorsMb =&gt; outputConnectorsMb; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IInputConnectorMb[] InputConnectorsMb =&gt; inputConnectorsMb; }</code> </pre> <br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Provide additional data to be able to configure it after manual install. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public interface IElectricalElementMbEditor : IElectricalElementMb { ElectricalElementType Type { get; } } public class ElectricalElementMbEditor : ElectricalElementMb, IElectricalElementMbEditor { [SerializeField] private ElectricalElementType type; public ElectricalElementType Type =&gt; type; }</span></span></code> </pre> <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IInputConnectorMb</span></span> : <span class="hljs-title"><span class="hljs-title">IConnectorMb</span></span> { IOutputConnectorMb OutputConnectorMb { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } IInputConnector InputConnector { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } }</code> </pre> <br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">InputConnectorMb</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span>, <span class="hljs-title"><span class="hljs-title">IInputConnectorMb</span></span> { [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> OutputConnectorMb outputConnectorMb; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform Transform =&gt; transform; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IOutputConnectorMb OutputConnectorMb { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> =&gt; outputConnectorMb; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> =&gt; outputConnectorMb = (OutputConnectorMb) <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IInputConnector InputConnector { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InputConnector(); <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> UNITY_EDITOR private void OnDrawGizmos() { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (outputConnectorMb != null) { Handles.DrawLine(transform.position, outputConnectorMb.Transform.position); } } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben die Zeile public IElectricalElement Element {get; </font><font style="vertical-align: inherit;">set;</font></font> }} <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nur hier ist, wie man diesen Artikel installiert? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine gute Option wäre, generisch zu machen: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">public class ElectricalElementMb: MonoBehaviour, IElectricalElementMb wobei T: IElectricalElement </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber der Haken ist, dass Unity generisch in MonoBehavior-Klassen nicht unterstützt. </font><font style="vertical-align: inherit;">Darüber hinaus unterstützt Unity keine Serialisierung von Eigenschaften und Schnittstellen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trotzdem ist es zur Laufzeit durchaus möglich, IElectricalElement Element {get; </font><font style="vertical-align: inherit;">set;</font></font> }} <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gewünschter Wert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe enum ElectricalElementType erstellt, in dem alle erforderlichen Typen vorhanden sind. </font><font style="vertical-align: inherit;">Enum wird von Unity gut serialisiert und im Inspektor als Dropdown-Liste angezeigt. </font><font style="vertical-align: inherit;">Definiert zwei Arten von Elementen: Welche werden zur Laufzeit erstellt und welche werden im Editor erstellt und können gespeichert werden. </font><font style="vertical-align: inherit;">Somit gibt es IElectricalElementMb und IElectricalElementMbEditor, die zusätzlich ein Feld vom Typ ElectricalElementType enthalten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der zweite Typ muss ebenfalls zur Laufzeit initialisiert werden. </font><font style="vertical-align: inherit;">Zu diesem Zweck gibt es eine Klasse, die zu Beginn alle Elemente umgeht und sie abhängig vom Typ im Aufzählungsfeld initialisiert. </font><font style="vertical-align: inherit;">Wie folgt:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Dictionary&lt;ElectricalElementType, Func&lt;IElectricalElement&gt;&gt; ElementByType = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;ElectricalElementType, Func&lt;IElectricalElement&gt;&gt; { {ElectricalElementType.And, () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> And()}, {ElectricalElementType.Or, () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Or()}, {ElectricalElementType.Xor, () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Xor()}, {ElectricalElementType.Nand, () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Nand()}, {ElectricalElementType.Nor, () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Nor()}, {ElectricalElementType.NOT, () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NOT()}, {ElectricalElementType.Xnor, () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Xnor()}, {ElectricalElementType.Source, () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Source()}, {ElectricalElementType.Conductor, () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Conductor()}, {ElectricalElementType.Placeholder, () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AlwaysFalse()}, {ElectricalElementType.Encoder, () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Encoder()}, {ElectricalElementType.Decoder, () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Decoder()} };</code> </pre> <br><a name="GameManagement"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spielverwaltung </font></font></h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als nächstes stellt sich die Frage, wo die Logik des Spiels selbst platziert werden soll (Überprüfen der Durchgangsbedingungen, Zählen der Durchgänge der Passage und Helfen des Spielers). Es gibt auch Fragen zum Speicherort der Logik zum Speichern und Laden von Fortschritten, Einstellungen und anderen Dingen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dazu unterscheide ich bestimmte Managerklassen, die für eine bestimmte Aufgabenklasse verantwortlich sind. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DataManager</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist für das Speichern von Daten aus den Ergebnissen der Übergabe der Benutzer- und Spieleinstellungen verantwortlich. Es wird von AsSingle im Rahmen des Projekts registriert. Dies bedeutet, dass er einer für die gesamte Anwendung ist. Während die Anwendung ausgeführt wird, werden Daten direkt im DataManager gespeichert. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Er verwendet den </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IFileStoreService</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , der für das Laden und Speichern von Daten und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IFileSerializer verantwortlich ist</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verantwortlich für die Serialisierung von Dateien in einer vorgefertigten Form zum Speichern. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LevelGameManager</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist ein Spielmanager in einer einzelnen Szene. </font></font><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe ein kleines GodObject bekommen, weil er immer noch für die Benutzeroberfläche verantwortlich ist, dh das Öffnen und Schließen des Menüs, die Reaktion auf die Schaltflächen. Angesichts der Größe des Projekts und der fehlenden Notwendigkeit, es zu erweitern, ist dies jedoch akzeptabel. Eine noch einfachere und besser sichtbare Abfolge von Aktionen.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es gibt zwei Möglichkeiten. Dies ist, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">was LevelGameManager1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LevelGameManager2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für Modus 1 bzw. 2 </font><b><font style="vertical-align: inherit;">aufgerufen</font></b><font style="vertical-align: inherit;"> werden </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im ersten Fall basiert die Logik auf der Reaktion auf den Fall einer Änderung des Werts in einer der Quellen und der Überprüfung des Werts am Ausgang der Schaltung.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im zweiten Fall reagiert die Logik auf ein Elementänderungsereignis und überprüft auch die Werte am Schaltungsausgang. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt einige aktuelle Level-Informationen wie Level-Nummer und Spielerunterstützung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daten zur aktuellen Ebene werden in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CurrentLevelData</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gespeichert </font><font style="vertical-align: inherit;">. Dort wird eine Levelnummer gespeichert - eine boolesche Eigenschaft mit einem Check for Help, einem Angebotsflag zur Auswertung des Spiels und Daten zur Unterstützung des Spielers.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ICurrentLevelData</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LevelNumber { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HelpExist { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ProposeRate { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ICurrentLevelDataMode1</span></span> : <span class="hljs-title"><span class="hljs-title">ICurrentLevelData</span></span> { IEnumerable&lt;SourcePositionValueHelp&gt; PartialHelp { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ICurrentLevelDataMode2</span></span> : <span class="hljs-title"><span class="hljs-title">ICurrentLevelData</span></span> { IEnumerable&lt;PlaceTypeHelp&gt; PartialHelp { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hilfe für den ersten Modus sind die Quellennummern und -werte. Im zweiten Modus ist dies der Elementtyp, der in der Zelle festgelegt werden muss. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Auflistung enthält Strukturen, in denen die Position und der Wert gespeichert sind, die an der angegebenen Position festgelegt werden müssen. Ein Wörterbuch wäre schöner, aber Unity kann keine Wörterbücher serialisieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Unterschiede zwischen den Szenen verschiedener Modi bestehen darin, dass im Kontext der Szene ein anderer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LevelGameManager</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und ein anderer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ICurrentLevelData festgelegt werden</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Allgemeinen habe ich einen ereignisgesteuerten Ansatz für die Kommunikation von Elementen. </font><font style="vertical-align: inherit;">Einerseits ist es logisch und bequem. </font><font style="vertical-align: inherit;">Auf der anderen Seite besteht die Möglichkeit, Probleme zu bekommen, ohne sich bei Bedarf abzumelden. </font><font style="vertical-align: inherit;">Trotzdem gab es bei diesem Projekt keine Probleme und der Umfang ist nicht zu groß. </font><font style="vertical-align: inherit;">Normalerweise erfolgt zu Beginn der Szene ein Abonnement für alles, was Sie benötigen. </font><font style="vertical-align: inherit;">Zur Laufzeit wird fast nichts erstellt, daher gibt es keine Verwirrung.</font></font><br><br><a name="LevelsLoading"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Level Laden </font></font></h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jedes Level im Spiel wird durch eine Unity-Szene dargestellt. Es muss ein Level-Präfix und eine Nummer enthalten, z. B. „Level23“. </font><font style="vertical-align: inherit;">Das Präfix ist in der Konfiguration enthalten. </font><font style="vertical-align: inherit;">Das Laden der Ebene erfolgt über den Namen, der aus dem Präfix gebildet wird. </font><font style="vertical-align: inherit;">Somit kann die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LevelsManager-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klasse </font><font style="vertical-align: inherit;">Ebenen nach Anzahl laden.</font></font><br><br><a name="Cutscenes"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zwischensequenzen </font></font></h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zwischensequenzen sind gewöhnliche Unity-Szenen mit Zahlen im Titel, ähnlich den Ebenen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Animation selbst wird mithilfe der Zeitleiste implementiert. </font><font style="vertical-align: inherit;">Leider habe ich weder Animationsfähigkeiten noch die Fähigkeit, mit Timeline zu arbeiten. Schießen Sie also nicht auf den Pianisten - er spielt so gut er kann. </font></font><br><br><img src="https://habrastorage.org/webt/h8/ny/rf/h8nyrfwesvjp8v6kmy70tcfiduc.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Wahrheit stellte sich heraus, dass eine logische Zwischensequenz aus verschiedenen Szenen mit verschiedenen Objekten bestehen sollte. </font><font style="vertical-align: inherit;">Es stellte sich heraus, dass dies etwas spät bemerkt wurde, aber es wurde einfach entschieden: indem Teile der Zwischensequenzen an verschiedenen Stellen auf der Bühne platziert und die Kamera sofort bewegt wurden.</font></font><br><br><img src="https://habrastorage.org/webt/s1/jq/jc/s1jqjces_osngyiexu03i3inrlk.png"><br><br><a name="AdditionalGameplay"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zusätzliches Gameplay </font></font></h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Spiel wird anhand der Anzahl der Aktionen pro Level und der Verwendung von Hinweisen geschätzt. Je weniger Action desto besser. Durch die Verwendung des Tooltips wird die maximale Bewertung auf 2 Sterne reduziert und die Stufe auf 1 Stern übersprungen. Um die Passage zu bewerten, wird die Anzahl der Schritte zum Passieren gespeichert. Es besteht aus zwei Werten: dem Minimalwert (für 3 Sterne) und dem Maximum (1 Stern). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Anzahl der Schritte zum Übergeben von Ebenen wird nicht in der Szenendatei selbst, sondern in der Konfigurationsdatei gespeichert, da Sie die Anzahl der Sterne für die übergebene Ebene anzeigen müssen. Dies erschwerte den Prozess der Erstellung von Ebenen geringfügig. Es war besonders interessant, die Änderungen im Versionskontrollsystem zu sehen: </font></font><br><br><img src="https://habrastorage.org/webt/fl/uc/4q/fluc4q2iu7946a11fywzat8afck.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versuchen Sie zu erraten, zu welcher Ebene es gehört. Es war natürlich möglich, das Wörterbuch zu speichern, aber erstens wurde es nicht von Unity serialisiert, zweitens musste man die Nummern manuell einstellen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn es für den Spieler schwierig ist, das Level zu beenden, kann er einen Hinweis erhalten - die richtigen Werte für einige Eingaben oder das richtige Element im zweiten Modus. Dies wurde auch manuell durchgeführt, obwohl es automatisiert werden konnte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Hilfe des Spielers nicht geholfen hat, kann er das Level komplett überspringen. Wenn ein Level fehlt, erhält der Spieler 1 Stern für ihn. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Benutzer, der eine Ebene mit einem Hinweis übergeben hat, kann sie eine Weile nicht erneut ausführen, sodass es schwierig ist, die Ebene mit neuem Speicher wie ohne Hinweis erneut auszuführen.</font></font><br><br><a name="Monetization"></a><h4>  Monetarisierung </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Spiel hat zwei Arten der Monetarisierung: Anzeigen anzeigen und Anzeigen für Geld deaktivieren. Eine Anzeigenanzeige umfasst das Anzeigen von Anzeigen zwischen Ebenen und das Anzeigen von belohnten Anzeigen, um eine Ebene zu überspringen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn der Spieler bereit ist, für das Deaktivieren von Werbung zu zahlen, kann er dies tun. In diesem Fall werden Anzeigen zwischen Ebenen und beim Überspringen einer Ebene nicht angezeigt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Für die Werbung wurde eine Klasse namens </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AdsService</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit einer Schnittstelle erstellt</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IAdsService</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> AdsDisabled { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadBetweenLevelAd</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowBetweenLevelAd</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> force = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadHelpAd</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Action onLoaded = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowHelpAd</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Action onRewarded, Action onClosed</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HelpAdLoaded { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier ist HelpAd eine belohnte Anzeige für das Überspringen eines Levels. Anfangs haben wir die Hilfe teilweise und vollständig angerufen. Teilweise ist ein Hinweis und voll ist eine Sprungstufe. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Klasse enthält innerhalb der Begrenzung der Häufigkeit, mit der Anzeigen nach dem ersten Start des Spiels nach Zeit geschaltet werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Implementierung verwendet das </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Google Mobile Ads Unity Plugin</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit belohnter Werbung bin ich auf einen Rechen getreten - es stellt sich heraus, dass loyale Delegierte in einem anderen Thread angerufen werden können, es ist nicht ganz klar, warum. Daher ist es besser, dass diese Delegaten im Code, der sich auf Unity bezieht, nichts aufrufen. Wenn ein Kauf getätigt wurde, um Werbung zu deaktivieren, wird die Werbung nicht angezeigt und der Delegierte führt sofort die erfolgreiche Anzeige der Werbung aus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt eine Schnittstelle zum Einkaufen</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IPurchaseService</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsAdsDisablePurchased { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action DisableAdsPurchased; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BuyDisableAds</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveDisableAd</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der Implementierung wird </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unity IAP</font></font></a> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verwendet </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Es gibt einen Trick beim Kauf von Anzeigenabschaltungen. </font><font style="vertical-align: inherit;">Google Play scheint keine Informationen darüber zu liefern, dass der Spieler einen Kauf gekauft hat. </font><font style="vertical-align: inherit;">Es wird nur die Bestätigung kommen, dass sie einmal bestanden hat. </font><font style="vertical-align: inherit;">Wenn Sie jedoch den Status des Produkts nach dem Kauf nicht als </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">abgeschlossen,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sondern als </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ausstehend </font></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">festlegen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , können Sie die Eigenschaft des </font><b><font style="vertical-align: inherit;">hasReceipt-</font></b><font style="vertical-align: inherit;"> Produkts überprüfen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wenn dies zutrifft, wurde der Kauf abgeschlossen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl es natürlich einen solchen Ansatz verwirrt. Ich vermute, dass es nicht alles glatt sein kann. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die RemoveDisableAd-Methode wird zum Zeitpunkt des Tests benötigt und entfernt den gekauften Werbeausfall.</font></font><br><br><a name="UI"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Benutzeroberfläche </font></font></h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle Schnittstellenelemente arbeiten nach einem ereignisorientierten Ansatz. </font><font style="vertical-align: inherit;">Schnittstellenelemente selbst enthalten normalerweise keine andere Logik als Ereignisse, die von öffentlichen Methoden aufgerufen werden, die Unity verwenden kann. </font><font style="vertical-align: inherit;">Es werden zwar auch einige Aufgaben ausgeführt, die sich nur auf die Schnittstelle beziehen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">UiElementBase</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span>, <span class="hljs-title"><span class="hljs-title">IUiElement</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action ShowClick; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action HideCLick; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Show</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); ShowClick?.Invoke(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Hide</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); HideCLick?.Invoke(); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PauseMenu</span></span> : <span class="hljs-title"><span class="hljs-title">UiElementEscapeClose</span></span>, <span class="hljs-title"><span class="hljs-title">IPauseMenu</span></span> { [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Text levelNumberText; [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> LocalizedText finishedText; [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> GameObject restartButton; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> levelNumber; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action GoToMainMenuClick; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action RestartClick; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LevelNumber { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> =&gt; levelNumberText.text = <span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{finishedText.Value}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">value</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string">"</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DisableRestartButton</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { restartButton.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GoToMainMenu</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GoToMainMenuClick?.Invoke(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Restart</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { RestartClick?.Invoke(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der Tat ist dies nicht immer der Fall. </font><font style="vertical-align: inherit;">Es ist gut, diese Elemente als aktive Ansicht zu belassen und daraus einen Ereignis-Listener zu machen, so etwas wie einen Controller, der die erforderlichen Aktionen für Manager auslöst.</font></font><br><br><a name="Analytics"></a><h4>  Analytik </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf dem Weg des geringsten Widerstands wurde </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unity Analytics</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ausgewählt </font><font style="vertical-align: inherit;">. Einfach zu implementieren, obwohl für ein kostenloses Abonnement beschränkt - es ist unmöglich, die Quelldaten zu exportieren. Es gibt auch ein Limit für die Anzahl der Events - 100 / Stunde pro Spieler. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie für die Analyse die Wrapper-Klasse </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AnalyticsService</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Es verfügt über Methoden für jeden Ereignistyp, empfängt die erforderlichen Parameter und bewirkt, dass das Ereignis mit den in Unity integrierten Tools gesendet wird. Das Erstellen einer Methode für jede Veranstaltung ist sicherlich nicht die beste Vorgehensweise insgesamt, aber in einem wissentlich kleinen Projekt ist es besser, als etwas Großes und Kompliziertes zu tun. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle verwendeten Ereignisse sind </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CustomEvent.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sie werden aus dem Namen des Ereignisses und dem Namen und Wert des Wörterbuchparameters erstellt. </font><font style="vertical-align: inherit;">AnalyticsService ruft die erforderlichen Werte aus den Parametern ab und erstellt darin ein Wörterbuch. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle Ereignisnamen und Parameter werden in Konstanten platziert. </font><font style="vertical-align: inherit;">Nicht in Form eines herkömmlichen Ansatzes mit ScriptableObject, da sich diese Werte niemals ändern sollten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methodenbeispiel:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LevelComplete</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> number, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> stars, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> actionCount, TimeSpan timeSpent, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> levelMode</span></span></span><span class="hljs-function">)</span></span> { CustomEvent(LevelCompleteEventName, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt; { {LevelNumber, number}, {LevelStars, stars}, {LevelActionCount, actionCount}, {LevelTimeSpent, timeSpent}, {LevelMode, levelMode} }); }</code> </pre> <br><a name="CameraAlign"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kamerapositionierung und Diagramme </font></font></h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Aufgabe besteht darin, FinalDevice im gleichen Abstand vom oberen Rand und Quellen vom unteren Rand oben auf dem Bildschirm zu platzieren, auch immer im gleichen Abstand vom unteren Rand. </font><font style="vertical-align: inherit;">Darüber hinaus haben die Bildschirme unterschiedliche Seitenverhältnisse. Sie müssen die Größe der Kamera anpassen, bevor Sie den Pegel starten, damit er richtig in die Schaltung passt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dazu wird die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CameraAlign-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klasse </font><b><font style="vertical-align: inherit;">erstellt</font></b><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Größenalgorithmus:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Finde alle notwendigen Elemente auf der Bühne </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Finden Sie die minimale Breite und Höhe basierend auf dem Seitenverhältnis </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bestimmen Sie die Kameragröße </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stellen Sie die Kamera in die Mitte </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verschieben Sie FinalDevice an den oberen Bildschirmrand </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verschieben Sie die Quellen an den unteren Bildschirmrand </font></font></li></ol><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CameraAlign</span></span> : <span class="hljs-title"><span class="hljs-title">ICameraAlign</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ISceneObjectsHelper sceneObjectsHelper; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ICommonValues commonValues; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CameraAlign</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ISceneObjectsHelper sceneObjectsHelper, ICommonValues commonValues</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.sceneObjectsHelper = sceneObjectsHelper; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.commonValues = commonValues; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Align</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Camera camera</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> elements = sceneObjectsHelper.FindObjectsOfType&lt;IElectricalElementMb&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> finalDevice = sceneObjectsHelper.FindObjectOfType&lt;IFinalDevice&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sources = elements.OfType&lt;ISourceMb&gt;().ToArray(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (finalDevice != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; sources.Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> leftPos = elements.Min(s =&gt; s.Transform.position.x); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rightPos = elements.Max(s =&gt; s.Transform.position.x); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> width = Mathf.Abs(leftPos - rightPos); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fPos = finalDevice.Transform.position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> height = Mathf.Abs(sources.First().Transform.position.y - fPos.y) * camera.aspect; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> size = Mathf.Max(width * commonValues.CameraOffset, height * commonValues.CameraOffset); camera.orthographicSize = Mathf.Clamp(size, commonValues.MinCameraSize, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>.MaxValue); camera.transform.position = GetCenterPoint(elements, <span class="hljs-number"><span class="hljs-number">-1</span></span>); fPos = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(fPos.x, camera.ScreenToWorldPoint(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(Screen.width, Screen.height)).y - commonValues.FinalDeviceTopOffset * camera.orthographicSize); finalDevice.Transform.position = fPos; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sourceY = camera.ScreenToWorldPoint(Vector2.zero).y + commonValues.SourcesBottomOffset; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sources) { item.Transform.position = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(item.Transform.position.x, sourceY); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.Log(<span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">nameof</span></span></span></span><span class="hljs-string"><span class="hljs-subst">(CameraAlign)}</span></span></span><span class="hljs-string">: No final device or no sources in scene"</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCenterPoint</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ICollection&lt;IElectricalElementMb&gt; elements, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> top = elements.Max(e =&gt; e.Transform.position.y); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> bottom = elements.Min(e =&gt; e.Transform.position.y); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> left = elements.Min(e =&gt; e.Transform.position.x); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> right = elements.Max(e =&gt; e.Transform.position.x); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x = left + ((right - left) / <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y = bottom + ((top - bottom) / <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(x, y, z); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Diese Methode wird aufgerufen, wenn die Szene in der Wrapper-Klasse beginnt. </font></font><br><br><a name="Colors"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Farbschemata </font></font></h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da das Spiel eine sehr primitive Oberfläche haben wird, habe ich mich für zwei Farbschemata entschieden, Schwarz und Weiß. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dazu wurde eine Schnittstelle erstellt</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IColors</span></span> { Color ColorAccent { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } Color Background { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } Color Foreground { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action ColorsChanged; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Farben können direkt im Unity-Editor eingestellt werden, dies kann zum Testen verwendet werden. Dann können sie umgeschaltet werden und haben zwei Farbsätze. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hintergrund- und Vordergrundfarben können sich ändern, ein Farbakzent in jedem Modus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da der Player ein nicht standardmäßiges Thema festlegen kann, müssen die Farbdaten in der Einstellungsdatei gespeichert werden. Wenn die Einstellungsdatei keine Farbdaten enthielt, werden diese mit Standardwerten gefüllt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dann gibt es mehrere Klassen: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CameraColorAdjustment</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - verantwortlich für das Einstellen der Hintergrundfarbe an der Kamera, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UiColorAdjustment</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Einstellen der Farben von Schnittstellenelementen und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TextMeshColorAdjustment</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Legt die Farbe der Zahlen auf den Quellen fest. </font><font style="vertical-align: inherit;">UiColorAdjustment verwendet auch Tags. </font><font style="vertical-align: inherit;">Im Editor können Sie jedes Element mit einem Tag markieren, das angibt, für welche Art von Farbe es festgelegt werden soll (Hintergrund, Vordergrund, AccentColor und FixedColor). </font><font style="vertical-align: inherit;">Dies wird alles zu Beginn der Szene oder bei einem Farbschemawechsel eingestellt.</font></font><br><br>  Ergebnis: <br><br><img src="https://habrastorage.org/webt/jk/6o/zz/jk6ozzdaz6h8ixxrykmnocrtgze.png"><br><br><img src="https://habrastorage.org/webt/kl/4d/u6/kl4du6hxim70hyncofiakaiqsi4.png"><br><br><a name="Editor"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Editor-Erweiterungen </font></font></h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um den Entwicklungsprozess zu vereinfachen und zu beschleunigen, ist es häufig erforderlich, das richtige Tool zu erstellen, das von Standard-Editor-Tools nicht bereitgestellt wird. </font><font style="vertical-align: inherit;">Der traditionelle Ansatz in Unity besteht darin, eine EditorWindow-Nachkommenklasse zu erstellen. </font><font style="vertical-align: inherit;">Es gibt auch einen Ansatz mit UiElements, der sich jedoch noch in der Entwicklung befindet. Daher habe ich mich für den traditionellen Ansatz entschieden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie einfach eine Klasse erstellen, die etwas aus dem UnityEditor-Namespace neben anderen Klassen für das Spiel verwendet, wird das Projekt einfach nicht zusammengestellt, da dieser Namespace im Build nicht verfügbar ist. </font><font style="vertical-align: inherit;">Es gibt verschiedene Lösungen:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wählen Sie ein separates Projekt für Editor-Skripte aus </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Legen Sie Dateien im Ordner Assets / Editor ab </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wickeln Sie diese Dateien in #if UNITY_EDITOR </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Projekt verwendet den ersten Ansatz und manchmal #if UNITY_EDITOR, falls erforderlich, fügt der Klasse, die im Build erforderlich ist, einen kleinen Teil für den Editor hinzu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle Klassen, die nur in dem Editor benötigt werden, den ich in der Assembly definiert habe und der nur im Editor verfügbar ist. </font><font style="vertical-align: inherit;">Sie wird nicht zum Build des Spiels gehen. </font></font><br><br><img src="https://habrastorage.org/webt/-u/yv/ie/-uyviepp1z3u4aal0mgbzlothxg.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wäre jetzt schön, DI in Ihren Editor-Erweiterungen zu haben. </font><font style="vertical-align: inherit;">Dafür benutze ich Zenject.StaticContext. </font><font style="vertical-align: inherit;">Um es im Editor festzulegen, wird eine Klasse mit dem Attribut InitializeOnLoad verwendet, in der sich ein statischer Konstruktor befindet.</font></font><br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">InitializeOnLoad</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EditorInstaller</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditorInstaller</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> container = StaticContext.Container; container.Bind&lt;IElementsProvider&gt;().To&lt;ElementsProvider&gt;().AsSingle(); container.Bind&lt;ISolver&gt;().To&lt;Solver&gt;().AsSingle(); .... } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um ScriptableObject-Klassen in einem statischen Kontext zu registrieren, verwende ich den folgenden Code: </font></font><br><br><pre> <code class="cs hljs">BindFirstScriptableObject&lt;ISceneNameConfiguration, SceneNameConfiguration&gt;(container); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> BindFirstScriptableObject&lt;TInterface, TImplementation&gt;(DiContainer container) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TImplementation : ScriptableObject, TInterface { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = GetFirstScriptableObject&lt;TImplementation&gt;(); container.Bind&lt;TInterface&gt;().FromInstance(obj).AsSingle(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T GetFirstScriptableObject&lt;T&gt;() <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : ScriptableObject { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> guids = AssetDatabase.FindAssets(<span class="hljs-string"><span class="hljs-string">"t:"</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(T).Name); <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = AssetDatabase.GUIDToAssetPath(guids.First()); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = AssetDatabase.LoadAssetAtPath&lt;T&gt;(path); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Implementierung ist nur für diese Zeile erforderlich. AssetDatabase.LoadAssetAtPath (Pfad) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist nicht möglich, dem Konstruktor </font><font style="vertical-align: inherit;">eine </font><font style="vertical-align: inherit;">Abhängigkeit </font><font style="vertical-align: inherit;">hinzuzufügen </font><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie </font><font style="vertical-align: inherit;">stattdessen das Attribut [Inject] zu den Abhängigkeitsfeldern in der Fensterklasse hinzu und rufen </font><font style="vertical-align: inherit;">Sie </font><font style="vertical-align: inherit;">beim </font><font style="vertical-align: inherit;">Start </font><font style="vertical-align: inherit;">des Fensters </font><font style="vertical-align: inherit;">StaticContext.Container.Inject (this) </font><font style="vertical-align: inherit;">auf </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich empfehle außerdem, dem Fensteraktualisierungszyklus eine Nullprüfung eines der abhängigen Felder hinzuzufügen. Wenn das Feld leer ist, führen Sie die obige Zeile aus. </font><font style="vertical-align: inherit;">Denn nach dem Ändern des Codes im Projekt kann Unity das Fenster neu erstellen und Awake nicht darauf aufrufen.</font></font><br><br><a name="GeneratorWindow"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Generator </font></font></h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br><br><img src="https://habrastorage.org/webt/4i/cp/ud/4icpudizv2-8r-bwrbkk3bva8kq.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstansicht des Generators </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Fenster sollte eine Schnittstelle zum Generieren einer Liste von Schemata mit Parametern, Anzeigen einer Liste von Schemata und Platzieren des ausgewählten Schemas in der aktuellen Szene bieten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Fenster besteht aus drei Abschnitten von links nach rechts:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Generierungseinstellungen </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Liste der Optionen in Form von Schaltflächen </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ausgewählte Option als Text </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spalten werden mit EditorGUILayout.BeginVertical () und EditorGUILayout.EndVertical () erstellt. Leider hat es nicht funktioniert, die Größen zu korrigieren und zu begrenzen, aber das ist nicht so kritisch. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es stellte sich heraus, dass der Erzeugungsprozess auf einer großen Anzahl von Schaltkreisen nicht so schnell ist. Mit den Elementen von I werden viele Kombinationen erhalten. Wie der Profiler gezeigt hat, ist der langsamste Teil die Schaltung selbst. Parallelisierung ist keine Option, alle Optionen verwenden ein Schema, aber es ist schwierig, diese Struktur zu klonen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dann dachte ich, dass wahrscheinlich der gesamte Code der Editor-Erweiterungen im Debug-Modus funktioniert. Unter Release funktioniert das Debuggen nicht so gut, Haltepunkte werden nicht gestoppt, Zeilen werden übersprungen usw. Nachdem die Leistung gemessen wurde, stellte sich heraus, dass die Geschwindigkeit des Generators in Unity der von der Konsolenanwendung gestarteten Debug-Assembly entspricht, die ~ 6-mal langsamer als Release ist.</font></font> Denken Sie daran. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alternativ können Sie eine externe Assemblierung durchführen und mit der Assembly zur Unity-DLL hinzufügen. Dies erschwert jedoch die Assemblierung und Bearbeitung des Projekts erheblich. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Generierungsprozess wurde sofort in eine separate Task mit dem folgenden Code gebracht: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CircuitGenerator.Generate (Zeilen, maxElementsInLine, availableLogicalElements, useNOT, Änderung) .ToList () </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bereits besser, der Editor hängt zum Zeitpunkt der Generierung nicht. </font><font style="vertical-align: inherit;">Es ist jedoch weiterhin erforderlich, einige Minuten lang zu warten (mehr als 20 Minuten bei großen Schaltkreisen). </font><font style="vertical-align: inherit;">Außerdem gab es das Problem, dass die Aufgabe nicht so einfach erledigt werden kann und so lange funktioniert, bis die Generierung abgeschlossen ist.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Viel Code</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Ext</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IEnumerable&lt;CircuitVariant&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OrderVariants</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IEnumerable&lt;CircuitVariant&gt; circuitVariants</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> circuitVariants.OrderBy(a =&gt; a.Solutions.Count()) .ThenByDescending(a =&gt; a.Solutions .Select(b =&gt; b.Sum(i =&gt; i ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">-1</span></span>)) .OrderByDescending(b=&gt;b) .First()); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IEditorGenerator</span></span> : <span class="hljs-title"><span class="hljs-title">IDisposable</span></span> { CircuitVariant[] FilteredVariants { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LastPage { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FilterVariants</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> page</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lines, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxElementsInLine, ICollection&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; availableGates, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> useNOT, StructureModification? modification, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxSolutions</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fetch</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EditorGenerator</span></span> : <span class="hljs-title"><span class="hljs-title">IEditorGenerator</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> PageSize = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ICircuitGenerator circuitGenerator; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ConcurrentBag&lt;CircuitVariant&gt; variants; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;CircuitVariant&gt; sortedVariants; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Thread generatingThread; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditorGenerator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ICircuitGenerator circuitGenerator</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.circuitGenerator = circuitGenerator; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { generatingThread?.Abort(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CircuitVariant[] FilteredVariants { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LastPage { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FilterVariants</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> page</span></span></span><span class="hljs-function">)</span></span> { CheckVariants(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sortedVariants == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Fetch(); } FilteredVariants = sortedVariants.Skip(page * PageSize) .Take(PageSize) .ToArray(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = sortedVariants.Count; LastPage = count % PageSize == <span class="hljs-number"><span class="hljs-number">0</span></span> ? (count / PageSize) - <span class="hljs-number"><span class="hljs-number">1</span></span> : count / PageSize; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fetch</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CheckVariants(); sortedVariants = variants.OrderVariants() .ToList(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lines, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxElementsInLine, ICollection&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; availableGates, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> useNOT, StructureModification? modification, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxSolutions</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (generatingThread != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Stop(); } variants = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentBag&lt;CircuitVariant&gt;(); generatingThread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = circuitGenerator.Generate(lines, maxElementsInLine, availableGates, useNOT, modification, maxSolutions); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> v) { variants.Add(item); } }); generatingThread.Start(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { generatingThread?.Abort(); sortedVariants = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; variants = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; generatingThread = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; FilteredVariants = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckVariants</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (variants == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">"VariantsGeneration is not started. Use Start before."</span></span>); } } ~EditorGenerator() { generatingThread.Abort(); } }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Idee ist, dass der Hintergrund generiert wird und auf Anfrage die interne Liste der sortierten Optionen aktualisiert wird. Dann können Sie Seite für Seite Optionen auswählen. Somit muss nicht jedes Mal sortiert werden, was die Arbeit an großen Listen erheblich beschleunigt. Die Schemata sind nach „Interessantheit“ sortiert: nach Anzahl der Lösungen, nach Erhöhung und nach den verschiedenen Werten, die für die Lösung erforderlich sind. Das heißt, eine Schaltung mit einer Lösung von 1 1 1 1 ist weniger interessant als 1 0 1 1. </font></font><br><br><img src="https://habrastorage.org/webt/mr/ud/aa/mrudaajqtmoetizlrvzd1muja4q.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Somit stellte sich heraus, ohne auf das Ende der Erzeugung zu warten, bereits eine Schaltung für den Pegel auszuwählen. Ein weiteres Plus ist, dass der Editor aufgrund der Paginierung nicht wie Vieh langsamer wird.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Unity-Funktion ist sehr störend, da beim Klicken auf Wiedergabe der Inhalt des Fensters wie alle generierten Daten zurückgesetzt wird. </font><font style="vertical-align: inherit;">Wenn sie leicht serialisierbar wären, könnten sie als Dateien gespeichert werden. </font><font style="vertical-align: inherit;">Auf diese Weise können Sie sogar die Ergebnisse der Generierung zwischenspeichern. </font><font style="vertical-align: inherit;">Leider ist es schwierig, eine komplexe Struktur zu serialisieren, in der Objekte aufeinander verweisen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Außerdem habe ich jedem Tor Zeilen hinzugefügt, wie z</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.Length == <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Input[<span class="hljs-number"><span class="hljs-number">0</span></span>].Value &amp;&amp; Input[<span class="hljs-number"><span class="hljs-number">1</span></span>].Value; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Welches stark verbesserte Leistung. </font></font><br><br><a name="SolverWindow"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Löser </font></font></h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie die Schaltung im Editor zusammenstellen, müssen Sie schnell verstehen können, ob sie gelöst wird und wie viele Lösungen sie hat. </font><font style="vertical-align: inherit;">Zu diesem Zweck habe ich ein "Solver" -Fenster erstellt. </font><font style="vertical-align: inherit;">Es bietet Lösungen für das aktuelle Schema in Form eines Textes. </font></font><br><br><img src="https://habrastorage.org/webt/k4/4e/pk/k44epkd08ngv_gh2rpejtr6jzkg.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Logik seines „Backends“:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSourcesLabel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sourcesMb = sceneObjectsHelper.FindObjectsOfType&lt;SourceMb&gt;().OrderBy(s =&gt; s.name); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sourcesLabelSb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sourcesMb) { sourcesLabelSb.Append(<span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{item.name.Replace(</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">"Source"</span></span></span></span><span class="hljs-string"><span class="hljs-subst">, </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">"Src"</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string">\t"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sourcesLabelSb.ToString(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IEnumerable&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[]&gt; FindSolutions() { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> elementsMb = sceneObjectsHelper.FindObjectsOfType&lt;IElectricalElementMbEditor&gt;(); elementsConfigurator.Configure(elementsMb); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> root = sceneObjectsHelper.FindObjectOfType&lt;FinalDevice&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">"No final device in scene"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sourcesMb = sceneObjectsHelper.FindObjectsOfType&lt;SourceMb&gt;().OrderBy(s =&gt; s.name); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sources = sourcesMb.Select(mb =&gt; (Source) mb.Element).ToArray(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> solver.GetSolutions(root.Element, sources); }</code> </pre> <br><a name="Useful"></a><h3>  Nützlich </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br><br><a name="AssertHelper"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Asserthelp </font></font></h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um zu überprüfen, ob die Werte in Assets festgelegt sind, verwende ich Erweiterungsmethoden, die ich in OnEnable aufrufe </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AssertHelper</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AssertType</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IElectricalElementMbEditor elementMbEditor, ElectricalElementType expectedType</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elementMbEditor.Type != expectedType) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">$"Field for </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{expectedType}</span></span></span><span class="hljs-string"> require element with such type, but given element is </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{elementMbEditor.Type}</span></span></span><span class="hljs-string">"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AssertNOTNull&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> T obj, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> fieldName = <span class="hljs-string"><span class="hljs-string">""</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(fieldName)) { fieldName = <span class="hljs-string"><span class="hljs-string">$"of type </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">typeof</span></span></span></span><span class="hljs-string"><span class="hljs-subst">(T).Name}</span></span></span><span class="hljs-string">"</span></span>; } Debug.LogError(<span class="hljs-string"><span class="hljs-string">$"Field </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{fieldName}</span></span></span><span class="hljs-string"> is not installed"</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AssertNOTEmpty</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> str, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fieldName = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">""</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrWhiteSpace(str)) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">$"Field </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{fieldName}</span></span></span><span class="hljs-string"> is not installed"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AssertSceneCanBeLoaded</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Application.CanStreamedLevelBeLoaded(name)) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">$"Scene </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{name}</span></span></span><span class="hljs-string"> can't be loaded."</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Überprüfen, ob die Szene geladen werden kann, schlägt manchmal fehl, obwohl die Szene möglicherweise geladen wird. </font><font style="vertical-align: inherit;">Vielleicht ist dies ein Fehler in Unity. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anwendungsbeispiele:</font></font><br><br><pre> <code class="cs hljs">mainMenuSceneName.AssertNOTEmpty(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(mainMenuSceneName)).AssertSceneCanBeLoaded(); levelNamePrefix.AssertNOTEmpty(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(levelNamePrefix)); editorElementsPrefabs.AssertNOTNull(); not.AssertType(ElectricalElementType.NOT); <span class="hljs-comment"><span class="hljs-comment">//     enum    </span></span></code> </pre> <br><a name="SceneObjectsHelper"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SceneObjectsHelper </font></font></h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Für die Arbeit mit Szenenelementen war auch die SceneObjectsHelper-Klasse hilfreich: </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Viel Code</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Circuit.Game.Utility</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ISceneObjectsHelper</span></span> { T[] FindObjectsOfType&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> includeDisabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>; T FindObjectOfType&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> includeDisabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>; T Instantiate&lt;T&gt;(T prefab) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : Object; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> DestroyObjectsOfType&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> includeDisabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> immediate = <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Destroy&lt;T&gt;(T obj, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> immediate = <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : Object; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DestroyAllChildren</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Transform transform</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Inject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> obj</span></span></span><span class="hljs-function">)</span></span>; T GetComponent&lt;T&gt;(GameObject obj) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SceneObjectsHelper</span></span> : <span class="hljs-title"><span class="hljs-title">ISceneObjectsHelper</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> DiContainer diContainer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SceneObjectsHelper</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">DiContainer diContainer</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.diContainer = diContainer; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> T GetComponent&lt;T&gt;(GameObject obj) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj.GetComponents&lt;Component&gt;().OfType&lt;T&gt;().FirstOrDefault(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> T[] FindObjectsOfType&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> includeDisabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (includeDisabled) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Resources.FindObjectsOfTypeAll(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Object)).OfType&lt;T&gt;().ToArray(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Object.FindObjectsOfType&lt;Component&gt;().OfType&lt;T&gt;().ToArray(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> DestroyObjectsOfType&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> includeDisabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> immediate = <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> objects = includeDisabled ? Resources.FindObjectsOfTypeAll(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Object)).OfType&lt;T&gt;().ToArray() : Object.FindObjectsOfType&lt;Component&gt;().OfType&lt;T&gt;().ToArray(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> objects) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (immediate) { Object.DestroyImmediate((item <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Component)?.gameObject); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Object.Destroy((item <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Component)?.gameObject); } } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Destroy&lt;T&gt;(T obj, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> immediate = <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : Object { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (immediate) { Object.DestroyImmediate(obj); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Object.Destroy(obj); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DestroyAllChildren</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Transform transform</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> childCount = transform.childCount; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; childCount; i++) { Destroy(transform.GetChild(i).gameObject); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> T FindObjectOfType&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> includeDisabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (includeDisabled) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Resources.FindObjectsOfTypeAll(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Object)).OfType&lt;T&gt;().FirstOrDefault(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Object.FindObjectsOfType&lt;Component&gt;().OfType&lt;T&gt;().FirstOrDefault(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Inject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> obj</span></span></span><span class="hljs-function">)</span></span> { diContainer.Inject(obj); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> T Instantiate&lt;T&gt;(T prefab) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : Object { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = Object.Instantiate(prefab); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Component) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> components = ((Component) (<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>) obj).gameObject.GetComponents&lt;Component&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> component <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> components) { Inject(component); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Inject(obj); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj; } } }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier sind einige Dinge möglicherweise nicht sehr effektiv, wenn eine hohe Leistung erforderlich ist, aber sie werden selten für mich benötigt und erzeugen keinen Einfluss. </font><font style="vertical-align: inherit;">Mit ihnen können Sie beispielsweise Objekte über die Benutzeroberfläche finden, die ziemlich hübsch aussieht.</font></font><br><br><a name="CoroutineStarter"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Coroutinestarter </font></font></h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coroutine starten kann nur MonoBehaviour. </font><font style="vertical-align: inherit;">Also habe ich die CoroutineStarter-Klasse erstellt und im Kontext der Szene registriert.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ICoroutineStarter</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BeginCoroutine</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IEnumerator routine</span></span></span><span class="hljs-function">)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CoroutineStarter</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span>, <span class="hljs-title"><span class="hljs-title">ICoroutineStarter</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BeginCoroutine</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IEnumerator routine</span></span></span><span class="hljs-function">)</span></span> { StartCoroutine(routine); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Einführung solcher Tools erleichterte nicht nur die Bequemlichkeit, sondern auch das automatische Testen. </font><font style="vertical-align: inherit;">Zum Beispiel die Ausführung von Coroutine in Tests:</font></font><br><br><pre> <code class="cs hljs">coroutineStarter.When(x =&gt; x.BeginCoroutine(Arg.Any&lt;IEnumerator&gt;())).Do(info =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = (IEnumerator) info[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (a.MoveNext()) { } });</code> </pre> <br><a name="Gizmo"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gizmo </font></font></h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um unsichtbare Elemente bequem anzeigen zu können, empfehle ich die Verwendung von Gizmo-Bildern, die nur in der Szene sichtbar sind. </font><font style="vertical-align: inherit;">Sie erleichtern die Auswahl eines unsichtbaren Elements mit einem Klick. </font><font style="vertical-align: inherit;">Auch Verbindungen von Elementen in Form von Linien hergestellt:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmos</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (outputConnectorMb != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Handles.DrawLine(transform.position, outputConnectorMb.Transform.position); } }</code> </pre> <br><img src="https://habrastorage.org/webt/ta/ce/d5/taced5wyeyhwkpj5vtiuvauu68s.png"><br><br><a name="Testing"></a><h3>  Testen </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich wollte das Beste aus automatischen Tests herausholen, da Tests verwendet wurden, wo immer dies möglich und einfach zu verwenden war. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Für Unit-Tests ist es üblich, Scheinobjekte anstelle der Klassen zu verwenden, die die Schnittstelle implementieren, von der die Testklasse abhängt. Dafür habe ich die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NSubstitute-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bibliothek benutzt </font><font style="vertical-align: inherit;">. Was freut mich sehr. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unity unterstützt NuGet nicht, daher musste ich die DLL separat und dann die Assembly abrufen, da eine Abhängigkeit zur AssemblyDefinition-Datei hinzugefügt und ohne Probleme verwendet wird. </font></font><br><br><img src="https://habrastorage.org/webt/y-/bh/sp/y-bhsprsfvxo-j9javgdhdzzhig.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Für automatische Tests bietet Unity TestRunner an, das mit dem sehr beliebten </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUnit-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Testframework funktioniert </font><font style="vertical-align: inherit;">. Aus Sicht von TestRunner gibt es zwei Arten von Tests:</font></font><br><br><ul><li> EditMode —     ,   .    Nunit .    ,    .        GameObject  Monobehaviour .   ,     EditMode . </li><li> PlayMode —     .    </li></ul><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EditMode Nach meiner Erfahrung gab es in diesem Modus viele Unannehmlichkeiten und seltsames Verhalten. Trotzdem ist es praktisch, den Zustand der gesamten Anwendung automatisch zu überprüfen. Sie bieten auch eine ehrliche Überprüfung des Codes in Methoden wie Start, Update und dergleichen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayMode-Tests können als normale NUnit-Tests beschrieben werden, es gibt jedoch eine Alternative. Im PlayMode müssen Sie möglicherweise eine Weile oder eine bestimmte Anzahl von Frames warten. Dazu müssen Tests ähnlich wie bei Coroutine beschrieben werden. Der zurückgegebene Wert sollte IEnumerator / IEnumerable sein. Um die Zeit zu überspringen, müssen Sie beispielsweise Folgendes verwenden:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>;</code> </pre> <br>  oder <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return new </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WaitForSeconds</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt andere Rückgabewerte. </font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei einem solchen Test muss das </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UnityTest-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Attribut festgelegt werden </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es gibt auch </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UnitySetUp- und UnityTearDown-Attribute, mit denen Sie einen ähnlichen Ansatz verwenden müssen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich teile wiederum EditMode-Tests für Modular und Integration. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unit-Tests testen nur eine Klasse vollständig isoliert von anderen Klassen. </font><font style="vertical-align: inherit;">Solche Tests erleichtern häufig die Vorbereitung der Umgebung für die zu testende Klasse, und wenn Fehler bestanden werden, können Sie das Problem genauer lokalisieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Unit-Tests teste ich viele Kernklassen und Klassen, die direkt im Spiel benötigt werden. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Schaltungselementtests sind sehr ähnlich, daher habe ich eine Basisklasse erstellt</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ElectricalElementTestsBase</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TElement</span></span>&gt; <span class="hljs-title"><span class="hljs-title">where</span></span> <span class="hljs-title"><span class="hljs-title">TElement</span></span> : <span class="hljs-title"><span class="hljs-title">ElectricalElementBase</span></span>, <span class="hljs-title"><span class="hljs-title">IElectricalElement</span></span>, <span class="hljs-title"><span class="hljs-title">new</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> TElement element; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> IInputConnector mInput1; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> IInputConnector mInput2; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> IInputConnector mInput3; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> IInputConnector mInput4; [OneTimeSetUp] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Setup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { element = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TElement(); mInput1 = Substitute.For&lt;IInputConnector&gt;(); mInput2 = Substitute.For&lt;IInputConnector&gt;(); mInput3 = Substitute.For&lt;IInputConnector&gt;(); mInput4 = Substitute.For&lt;IInputConnector&gt;(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetValue_3Input</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> input1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> input2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> input3, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> expectedOutput</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// arrange mInput1.Value.Returns(input1); mInput2.Value.Returns(input2); mInput3.Value.Returns(input3); element.Input = new[] {mInput1, mInput2, mInput3}; // act bool result = element.GetValue(); // assert Assert.AreEqual(expectedOutput, result); } protected void GetValue_2Input(bool input1, bool input2, bool expectedOutput) { // arrange mInput1.Value.Returns(input1); mInput2.Value.Returns(input2); element.Input = new[] {mInput1, mInput2}; // act bool result = element.GetValue(); // assert Assert.AreEqual(expectedOutput, result); } protected void GetValue_1Input(bool input, bool expectedOutput) { // arrange mInput1.Value.Returns(input); element.Input = new[] {mInput1}; // act bool result = element.GetValue(); // assert Assert.AreEqual(expectedOutput, result); } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Weitere Elementtests sehen folgendermaßen aus: </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AndTests</span></span> : <span class="hljs-title"><span class="hljs-title">ElectricalElementTestsBase</span></span>&lt;<span class="hljs-title"><span class="hljs-title">And</span></span>&gt; { [TestCase(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>)] [TestCase(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>)] [TestCase(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>)] [TestCase(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> new </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetValue_2Input</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> input1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> input2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> output</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.GetValue_2Input(input1, input2, output); } [TestCase(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>)] [TestCase(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> new </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetValue_1Input</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> input, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> expectedOutput</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.GetValue_1Input(input, expectedOutput); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vielleicht ist dies eine Komplikation in Bezug auf das Verständnis, die in Tests normalerweise nicht erforderlich ist, aber ich wollte nicht elf Mal dasselbe kopieren und einfügen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt auch Tests von GameManagern. </font><font style="vertical-align: inherit;">Da sie viel gemeinsam haben, haben sie auch eine Basisklasse von Tests. </font><font style="vertical-align: inherit;">Spielmanager in beiden Modi sollten identische und unterschiedliche Funktionen haben. </font><font style="vertical-align: inherit;">Allgemeine Dinge werden mit den gleichen Tests für jeden Nachfolger getestet und das spezifische Verhalten wird zusätzlich getestet. </font><font style="vertical-align: inherit;">Trotz des Ereignisansatzes war es nicht schwierig, das Verhalten des Ereignisses zu testen:</font></font><br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FullHelpAgree_FinishLevel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// arrange levelGameManager.Start(); helpMenu.ClearReceivedCalls(); dataManager.ClearReceivedCalls(); // act helpMenu.FullHelpClick += Raise.Event&lt;Action&gt;(); fullHelpWindow.Agreed += Raise.Event&lt;Action&lt;bool&gt;&gt;(true); // assert dataManager.Received().SaveGame(); helpMenu.Received().Hide(); } [Test] public void ChangeSource_RootOutBecomeTrue_SavesGameOpensMenu() { // arrange currentLevelData.IsTestLevel.Returns(false); rootOutputMb.OutputConnector.Value.Returns(true); // act levelGameManager.Start(); levelFinishedMenu.ClearReceivedCalls(); dataManager.ClearReceivedCalls(); source.ValueChanged += Raise.Event&lt;Action&lt;bool&gt;&gt;(true); // assert dataManager.Received().SaveGame(); levelFinishedMenu.Received().Show(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Integrationstests habe ich auch Klassen für den Editor getestet und sie aus dem statischen Kontext des DI-Containers übernommen. </font><font style="vertical-align: inherit;">Überprüfen Sie daher auch die korrekte Injektion, was nicht weniger wichtig ist als der Unit-Test.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PlacerTests</span></span> { [Inject] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ICircuitEditorPlacer circuitEditorPlacer; [Inject] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ICircuitGenerator circuitGenerator; [Inject] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> IEditorSolver solver; [Inject] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ISceneObjectsHelper sceneObjectsHelper; [TearDown] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TearDown</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { sceneObjectsHelper.DestroyObjectsOfType&lt;IElectricalElementMb&gt;(immediate: <span class="hljs-literal"><span class="hljs-literal">true</span></span>); } [OneTimeSetUp] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Setup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> container = StaticContext.Container; container.Inject(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } [TestCase(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)] [TestCase(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)] [TestCase(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PlaceSolve_And_NoModifications_AllVariantsSolved</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lines, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> elementsInLine</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> variants = circuitGenerator.Generate(lines, elementsInLine, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; {<span class="hljs-number"><span class="hljs-number">0</span></span>}, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> variant <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> variants) { circuitEditorPlacer.PlaceCircuit(variant); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> solutions = solver.FindSolutions(); CollectionAssert.IsNOTEmpty(solutions); } } [TestCase(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, StructureModification.Branching)] [TestCase(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, StructureModification.ThroughLayer)] [TestCase(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, StructureModification.All)] [TestCase(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, StructureModification.Branching)] [TestCase(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, StructureModification.ThroughLayer)] [TestCase(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, StructureModification.All)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PlaceSolve_And_Modifications_AllVariantsSolved</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lines, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> elementsInLine, StructureModification modification</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> variants = circuitGenerator.Generate(lines, elementsInLine, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; {<span class="hljs-number"><span class="hljs-number">0</span></span>}, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, modification); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> variant <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> variants) { circuitEditorPlacer.PlaceCircuit(variant); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> solutions = solver.FindSolutions(); CollectionAssert.IsNOTEmpty(solutions); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieser Test verwendet reale Implementierungen aller Abhängigkeiten und setzt auch Objekte auf der Bühne, was in EditMode-Tests durchaus möglich ist. Es ist wahr zu testen, ob es sie gesund gemacht hat - ich habe keine Ahnung, wie, also überprüfe ich, ob die ausgeschriebene Schaltung Lösungen hat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der Integration gibt es auch Tests für CircuitGenerator (StructureGenerator + VariantsGenerator) und Solver</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CircuitGeneratorTests</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ICircuitGenerator circuitGenerator; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ISolver solver; [SetUp] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Setup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { solver = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Solver(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gates = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Func&lt;IElectricalElement&gt;&gt; { () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> And(), () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Or(), () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Xor() }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> conductors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Func&lt;IElectricalElement&gt;&gt; { () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Conductor(), () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Not() }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> elements = Substitute.For&lt;IElementsProvider&gt;(); elements.Conductors.Returns(conductors); elements.Gates.Returns(gates); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> structGenerator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StructureGenerator(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> variantsGenerator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> VariantsGenerator(solver, elements); circuitGenerator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CircuitGenerator(structGenerator, variantsGenerator); } [Test] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Generate_2l_2max_ReturnsVariants</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// act var variants = circuitGenerator.Generate(2, 2, new[] {0, 1, 2}, false).ToArray(); // assert Assert.True(variants.Any()); AssertLayersNotContains(variants.First().Structure.Gates, typeof(Nand)); AssertLayersNotContains(variants.First().Structure.Gates, typeof(Nor)); AssertLayersNotContains(variants.First().Structure.Gates, typeof(Xnor)); AssertLayersNotContains(variants.First().Structure.Conductors, typeof(Not)); AssertLayersContains(variants.First().Structure.Gates, typeof(Or)); AssertLayersContains(variants.First().Structure.Gates, typeof(Xor)); AssertLayersContains(variants.First().Structure.Conductors, typeof(Conductor)); } [Test] public void Generate_2l_2max_RestrictedElementsWithConductors() { // arrange var available = new[] {0}; // act var variants = circuitGenerator.Generate(2, 2, available, true).ToArray(); // assert Assert.True(variants.Any()); var lElements = new List&lt;int&gt;(); var layers = variants.Select(v =&gt; v.Gates); foreach (var layer in layers) { foreach (var item in layer.Values) { lElements.AddRange(item); } } Assert.True(lElements.Contains(0)); Assert.False(lElements.Contains(1)); Assert.False(lElements.Contains(2)); AssertLayersContains(variants.First().Structure.Gates, typeof(And)); AssertLayersContains(variants.First().Structure.Conductors, typeof(Conductor)); AssertLayersContains(variants.First().Structure.Conductors, typeof(Not)); AssertLayersNotContains(variants.First().Structure.Gates, typeof(Nand)); AssertLayersNotContains(variants.First().Structure.Gates, typeof(Or)); AssertLayersNotContains(variants.First().Structure.Gates, typeof(Nor)); AssertLayersNotContains(variants.First().Structure.Gates, typeof(Xnor)); AssertLayersNotContains(variants.First().Structure.Gates, typeof(Xor)); } private static void AssertLayersContains(IDictionary&lt;int, ElectricalElementContainer[]&gt; layers, Type elementType) { AssertLayersContains(layers, elementType, true); } private static void AssertLayersNotContains(IDictionary&lt;int, ElectricalElementContainer[]&gt; layers, Type elementType) { AssertLayersContains(layers, elementType, false); } private static void AssertLayersContains(IDictionary&lt;int, ElectricalElementContainer[]&gt; layers, Type elementType, bool shouldContain) { bool contains = false; foreach (var layer in layers) { foreach (var item in layer.Value) { contains |= item.Elements.Select(e =&gt; e.GetType()).Contains(elementType); } } Assert.AreEqual(shouldContain, contains); } } }</span></span></code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayMode-Tests werden als Systemtests verwendet. Sie überprüfen Fertighäuser, Injektionen usw. Eine gute Option ist die Verwendung vorgefertigter Szenen, in denen der Test nur einige Interaktionen lädt und erzeugt. Aber ich benutze eine vorbereitete leere Szene zum Testen, in der sich die Umgebung von der im Spiel unterscheidet. Es wurde versucht, mit PlayMode den gesamten Spielprozess zu testen, z. B. das Menü aufzurufen, das Level einzugeben usw. Die Arbeit dieser Tests erwies sich jedoch als instabil, sodass beschlossen wurde, sie für später (nie) zu verschieben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist praktisch, Tools zur Bewertung der Abdeckung zum Schreiben von Tests zu verwenden, aber leider habe ich keine Lösungen gefunden, die mit Unity funktionieren.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich fand ein Problem, dass mit dem Unity-Upgrade auf 2018.3 die Tests viel langsamer und bis zu zehnmal langsamer arbeiteten (in einem synthetischen Beispiel). </font><font style="vertical-align: inherit;">Das Projekt enthält 288 EditMode-Tests, die 11 Sekunden lang ausgeführt werden, obwohl dort so lange nichts unternommen wurde.</font></font><br><br><a name="Resume"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Entwicklungszusammenfassung </font></font></h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br><br><img src="https://habrastorage.org/webt/kl/4d/u6/kl4du6hxim70hyncofiakaiqsi4.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Screenshot der Spielebene Die</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Logik einiger Spiele kann unabhängig von der Plattform formuliert werden. Dies erleichtert in einem frühen Stadium die Entwicklung und Testbarkeit durch Autotests. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DI ist bequem. Selbst unter Berücksichtigung der Tatsache, dass Unity es nicht nativ hat, funktioniert die seitlich verschraubte Seite ziemlich erträglich. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit Unity können Sie ein Projekt automatisch testen. Richtig, da alle integrierten GameObject-Komponenten keine Schnittstellen haben und nur direkt zum Verspotten von Dingen wie Collider, SpriteRenderer, MeshRenderer usw. verwendet werden können. wird nicht funktionieren. Mit GetComponent können Sie zwar Komponenten auf der Schnittstelle abrufen. Schreiben Sie optional Ihre eigenen Wrapper für alles.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Verwendung von Autotests vereinfachte das Generieren der anfänglichen Logik, während es keine Benutzeroberfläche für den Code gab. Bei mehreren Tests wurde sofort während der Entwicklung ein Fehler festgestellt. Natürlich traten weitere Fehler auf, aber häufig war es möglich, zusätzliche Tests zu schreiben / vorhandene zu ändern und ihn später automatisch abzufangen. Fehler mit DI, Prefabs, skriptfähigen Objekten und dergleichen, Tests sind schwer zu erkennen, aber es ist möglich, da Sie echte Installationsprogramme für Zenject verwenden können, wodurch die Abhängigkeiten enger werden, wie es im Build geschieht.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unity erzeugt eine große Menge an Fehlern und Abstürzen. </font><font style="vertical-align: inherit;">Oft werden Fehler durch einen Neustart des Editors behoben. </font><font style="vertical-align: inherit;">Konfrontiert mit einem seltsamen Verlust von Verweisen auf Objekte in Fertighäusern. </font><font style="vertical-align: inherit;">Manchmal wird das Fertighaus als Referenz zerstört (ToString () gibt "null" zurück), obwohl alles funktioniert, wird das Fertighaus auf die Szene gezogen und der Link ist nicht leer. </font><font style="vertical-align: inherit;">Manchmal gehen in allen Szenen einige Verbindungen verloren. </font><font style="vertical-align: inherit;">Alles scheint installiert zu sein, es hat funktioniert, aber wenn Sie zu einem anderen Zweig wechseln, sind alle Szenen unterbrochen - es gibt keine Verknüpfungen zwischen den Elementen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Glücklicherweise wurden diese Fehler häufig durch Neustart des Editors oder manchmal durch Löschen des Bibliotheksordners behoben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Insgesamt ist von der Idee bis zur Veröffentlichung bei Google Play etwa ein halbes Jahr vergangen. </font><font style="vertical-align: inherit;">Die Entwicklung selbst dauerte ca. 3 Monate in der Freizeit von der Hauptarbeit.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de453564/">https://habr.com/ru/post/de453564/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de453546/index.html">Benötigen Sie eine kleine Tastatur - machen Sie es selbst</a></li>
<li><a href="../de453548/index.html">Wir beleben das bremsende Samsung Galaxy TAB 2 WiFi</a></li>
<li><a href="../de453554/index.html">Wie sich Starlink von SpaceX geändert hat</a></li>
<li><a href="../de453558/index.html">Einführung in das maschinelle Lernen</a></li>
<li><a href="../de453562/index.html">Digitale Veranstaltungen in Moskau vom 27. Mai bis 2. Juni</a></li>
<li><a href="../de453566/index.html">Stellen Sie die Legende wieder her: ein Aufruf zum Austausch offener Daten, die bei der Wiederherstellung von Notre Dame helfen können</a></li>
<li><a href="../de453568/index.html">Neuerstellung eines Symbols: Aufruf zur Freigabe offener Daten zur Wiederherstellung von Notre-Dame</a></li>
<li><a href="../de453570/index.html">Microsoft Edge für MacOS</a></li>
<li><a href="../de453572/index.html">Microsoft Edge für MacOS</a></li>
<li><a href="../de453574/index.html">B2B-Produktmanagement</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>