<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¼ğŸ½ ğŸ” ğŸŒªï¸ Analisis statis volume besar kode Python: pengalaman Instagram. Bagian 2 ğŸ§—ğŸ¿ ğŸ’¹ ğŸ¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari ini kami menerbitkan bagian kedua dari terjemahan materi yang ditujukan untuk analisis statis volume besar kode Python sisi-server di Instagram. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analisis statis volume besar kode Python: pengalaman Instagram. Bagian 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/473770/">  Hari ini kami menerbitkan bagian kedua dari terjemahan materi yang ditujukan untuk analisis statis volume besar kode Python sisi-server di Instagram. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/we/qg/3b/weqg3bwqroi2rbycaj_7vhqqe6s.jpeg"></a> <br><br>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian pertama</a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Programmer yang sudah bosan dengan linting</font> </h2><br>  Mempertimbangkan bahwa kita memiliki sekitar seratus aturan linting kita sendiri, penghitungan rekomendasi yang dikeluarkan oleh aturan ini dengan cepat dapat dengan cepat menghabiskan waktu pengembang.  Akan lebih baik menghabiskan waktu yang dihabiskan untuk meluruskan gaya kode atau menyingkirkan pola usang untuk membuat sesuatu yang baru dan untuk mengembangkan proyek. <br><br>  Kami menemukan bahwa ketika programmer melihat terlalu banyak notifikasi yang berasal dari linter, mereka mulai mengabaikan semua pesan ini.  Ini juga berlaku untuk pemberitahuan penting. <br>  Misalkan kita memutuskan untuk mendeklarasikan fungsi <code>fn</code> usang dan menggunakan fungsi dengan nama yang lebih baik, <code>add</code> .  Jika Anda tidak memberi tahu pengembang tentang hal ini, mereka tidak akan tahu bahwa mereka tidak perlu lagi menggunakan fungsi <code>fn</code> .  Lebih buruk lagi, mereka tidak tahu apa yang harus digunakan daripada fungsi ini.  Dalam situasi ini, Anda dapat membuat aturan linter.  Tetapi basis kode besar apa pun sudah akan berisi banyak aturan.  Akibatnya, kemungkinan notifikasi linter penting akan hilang di tumpukan notifikasi bug minor. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2a/740/be6/f2a740be601e4f94db05ea3e934a23e2.png"></div><br>  <i><font color="#999999">Linter terlalu nitpicking dan "sinyal berguna" dapat dengan mudah tersesat dalam "noise"</font></i> <br><br>  Apa yang akan kita lakukan dengan ini? <br><br>  Anda dapat secara otomatis memperbaiki banyak masalah yang terdeteksi oleh linter.  Jika linter itu sendiri dapat dibandingkan dengan dokumentasi yang muncul di mana diperlukan, maka koreksi otomatis semacam itu sedikit refactoring kode yang dieksekusi di mana ia diperlukan.  Mengingat banyaknya pengembang yang bekerja di Instagram, hampir mustahil untuk melatih mereka masing-masing dalam teknik penulisan kode terbaik kami.  Menambahkan kemampuan koreksi kode otomatis ke sistem memungkinkan kami untuk mendidik pengembang tentang teknik baru ketika mereka tidak mengetahui teknik ini.  Ini membantu kami dengan cepat memperbarui pengembang.  Koreksi otomatis, di samping itu, memungkinkan kami untuk membuat pemrogram fokus pada hal-hal penting, daripada berfokus pada perubahan kode kecil yang monoton.  Secara umum, dapat dicatat bahwa koreksi kode otomatis lebih efektif dan berguna dalam hal pengembang pelatihan daripada pemberitahuan linter sederhana. <br><br>  Jadi, bagaimana cara membuat sistem untuk koreksi kode otomatis?  Lint berbasis pohon sintaks memberi kita informasi tentang simpul disfungsional.  Akibatnya, kita tidak perlu membuat logika untuk mendeteksi masalah, karena kita sudah memiliki aturan yang sesuai untuk linter!  Karena kita tahu simpul mana yang tidak cocok untuk kita, dan tentang di mana kode sumbernya berada, kita dapat, tanpa risiko merusak sesuatu, misalnya, mengganti nama fungsi <code>fn</code> dengan <code>add</code> .  Ini sangat cocok untuk memperbaiki satu pelanggaran aturan yang dieksekusi karena pelanggaran tersebut terdeteksi.  Tetapi bagaimana jika kita memperkenalkan aturan baru untuk linter, yang berarti ada ratusan fragmen kode dalam basis kode yang tidak mematuhi aturan ini?  Bisakah semua ketidakkonsistenan ini diperbaiki terlebih dahulu? <br><br><h2>  <font color="#3AC1EF">Mod Kode</font> </h2><br>  Codemod hanyalah cara untuk menemukan masalah dan membuat perubahan pada kode sumber.  Codemods berbasis skrip.  Codemod dapat dianggap sebagai "steroid refactoring".  Rentang tugas yang dipecahkan oleh mode kode sangat luas: dari yang sederhana, seperti mengubah nama variabel dalam suatu fungsi, hingga yang kompleks, seperti menulis ulang suatu fungsi sehingga diperlukan argumen baru.  Ketika bekerja dengan codemod, konsep yang sama digunakan seperti operasi linter.  Tetapi alih-alih memberi tahu programmer tentang masalah, seperti yang dilakukan linter, mode kode secara otomatis menyelesaikan masalah ini. <br><br>  Bagaimana cara menulis kode?  Pertimbangkan sebuah contoh.  Di sini kami ingin berhenti menggunakan <code>get_global</code> .  Dalam situasi ini, Anda dapat menggunakan linter, tetapi tidak akan diketahui berapa lama waktu yang diperlukan untuk memperbaiki seluruh kode, di samping itu, tugas ini akan didistribusikan di antara banyak pengembang.  Pada saat yang sama, bahkan jika proyek menggunakan sistem koreksi kode otomatis, mungkin butuh beberapa waktu untuk memproses semua kode. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/173/a84/0a0/173a840a0b021e0e388d75a8240a617a.png"></div><br>  <i><font color="#999999">Kami ingin menjauh dari menggunakan get_global dan menggunakan variabel instan sebagai gantinya</font></i> <br><br>  Untuk mengatasi masalah ini, kita bisa, bersama-sama dengan aturan linter yang mendeteksi itu, menulis kode kode.  Kami percaya bahwa membiarkan pola dan API lama meninggalkan kode secara bertahap akan mengganggu pengembang dan menurunkan keterbacaan kode.  Kami lebih memilih untuk segera menghapus kode usang, dan tidak melihat bagaimana kode itu secara bertahap menghilang dari proyek. <br><br>  Mengingat volume kode kami dan jumlah pengembang aktif, ini seringkali berarti secara otomatis menghilangkan desain yang usang.  Jika kami dapat dengan cepat menghapus kode dari pola yang usang, ini berarti kami dapat mempertahankan produktivitas semua pengembang Instagram. <br><br>  Jadi, bagaimana cara membuat codemod?  Bagaimana cara mengganti hanya fragmen kode yang menarik minat kami, sambil menjaga komentar, indentasi, dan yang lainnya?  Ada alat yang didasarkan pada pohon sintaksis tertentu (seperti apa yang dibuat LibCST) yang memungkinkan Anda untuk memodifikasi kode dengan presisi bedah dan menyimpan semua konstruksi tambahan di dalamnya.  Akibatnya, jika kita perlu mengubah nama fungsi dari <code>fn</code> untuk <code>add</code> di pohon di bawah ini, maka kita dapat menulis <code>add</code> alih-alih <code>fn</code> di simpul <code>Name</code> , dan kemudian menulis pohon ke disk! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5bf/f9e/eda/5bff9eedabf6933a157a2473f44594b2.png"></div><br>  <i><font color="#999999">Anda dapat melakukan mode kode dengan menulis tambahkan ke simpul Nama daripada fn.</font></i>  <i><font color="#999999">Kemudian pohon yang diubah dapat ditulis ke disk.</font></i>  <i><font color="#999999">Anda dapat membaca lebih lanjut tentang ini di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> LibCST.</font></i> <br><br>  Sekarang kita sudah terbiasa dengan mod kode, mari kita lihat contoh praktisnya.  Karyawan Instagram bekerja keras untuk membuat basis kode proyek diketik sepenuhnya.  Kodmody serius membantu mereka dalam hal ini. <br><br>  Jika kita memiliki sekumpulan fungsi yang tidak diketik yang perlu diketik, kita dapat mencoba menghasilkan tipe yang dikembalikan oleh mereka dengan inferensi tipe yang biasa!  Misalnya, jika suatu fungsi mengembalikan nilai hanya dari satu tipe primitif, kami cukup menetapkan jenis nilai pengembalian ini ke fungsi.  Jika fungsi mengembalikan nilai tipe logis, misalnya, jika membandingkan sesuatu dengan sesuatu atau memeriksa sesuatu, maka kita dapat menetapkannya <code>bool</code> tipe nilai pengembalian.  Kami menemukan bahwa dalam perjalanan kerja praktis dengan basis kode Instagram, ini adalah operasi yang cukup aman. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02b/166/8b7/02b1668b7569147bb60e060c131b7e90.png"></div><br>  <i><font color="#999999">Mencari tahu jenis nilai yang dikembalikan oleh fungsi</font></i> <br><br>  Tetapi bagaimana jika fungsi tidak secara eksplisit mengembalikan nilai apa pun, atau secara implisit mengembalikan <code>None</code> ?  Jika fungsi tidak secara eksplisit mengembalikan apa pun, maka dapat ditetapkan jenis <code>None</code> . <br><br>  Ini, tidak seperti contoh sebelumnya, bisa lebih berbahaya karena adanya pola umum yang digunakan pengembang.  Misalnya, dalam metode kelas dasar, Anda bisa melempar pengecualian <code>NotImplemented</code> , dan dalam metode subclass yang menimpa metode ini, Anda bisa mengembalikan string.  Penting untuk dicatat bahwa semua teknik ini heuristik, tetapi hasil penerapannya sering kali ternyata benar.  Akibatnya, mereka dapat dianggap berguna. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a2d/292/c8f/a2d292c8f2567a848974a6852c0fa7b3.png"></div><br>  <i><font color="#999999">Fungsi Yang Tidak Mengembalikan Apa-apa</font></i> <br><br><h2>  <font color="#3AC1EF">Memperluas Modul Kode dengan Pyre</font> </h2><br>  Mari kita melangkah lebih jauh.  Instagram menggunakan Pyre, sistem pengecekan tipe statis full-blown mirip dengan mypy.  Menggunakan Pyre memungkinkan kita memeriksa jenis dalam basis kode.  Bagaimana jika kita menggunakan data yang dihasilkan oleh Pyre untuk memperluas kemampuan codemod?  Berikut ini adalah contoh dari data tersebut.  Sangat mudah untuk melihat bahwa hampir semua yang Anda butuhkan untuk memperbaiki anotasi jenis secara otomatis! <br><br><pre> <code class="python hljs">$ pyre Æ› Found <span class="hljs-number"><span class="hljs-number">2</span></span> type errors! testing/utils.py:<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span> Missing <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> annotation [<span class="hljs-number"><span class="hljs-number">3</span></span>]: Returning `SomeClass` but no <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> specified. testing/utils.py:<span class="hljs-number"><span class="hljs-number">10</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span> Missing <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> annotation [<span class="hljs-number"><span class="hljs-number">3</span></span>]: Returning `testing.other.SomeOtherClass` but no <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> specified.</code> </pre> <br>  Pyre selama pekerjaan melakukan analisis terperinci dari urutan eksekusi setiap fungsi.  Akibatnya, alat ini kadang-kadang dengan probabilitas yang sangat tinggi dapat membuat asumsi bahwa fungsi yang tidak dicatat harus dikembalikan.  Ini berarti bahwa jika Pyre percaya bahwa fungsi mengembalikan tipe sederhana, kami menetapkan fungsi ini tipe kembali.  Namun, sekarang, secara potensial, kita perlu memproses perintah impor juga.  Ini berarti bahwa kita perlu tahu apakah ada sesuatu yang diimpor atau dideklarasikan secara lokal.  Nanti kita akan menyentuh topik ini sebentar. <br><br>  Manfaat apa yang kita dapatkan dari secara otomatis menambahkan informasi jenis yang mudah ditampilkan dalam kode?  Nah, tipe adalah dokumentasi!  Jika fungsi sepenuhnya diketik, maka pengembang tidak perlu membaca kodenya untuk mengetahui fitur panggilannya dan fitur menggunakan apa yang dikembalikan. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_description</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(page: WikiPage)</span></span></span><span class="hljs-function"> -&gt; Optional[str]:</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> page.draft:        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> page.metadata[<span class="hljs-string"><span class="hljs-string">"description"</span></span>]  <span class="hljs-comment"><span class="hljs-comment"># &lt;-    ?</span></span></code> </pre> <br>  Banyak dari kita telah menemukan kode Python yang serupa.  Basis kode Instagram juga memiliki sesuatu yang serupa.  Jika fungsi <code>get_description</code> tidak diketik, maka Anda perlu melihat beberapa modul untuk mengetahui apa yang dikembalikan.  Pada saat yang sama, bahkan jika kita berbicara tentang fungsi yang lebih sederhana, jenis nilai pengembalian yang mudah diturunkan, varian yang diketiknya dirasakan lebih mudah daripada yang tidak diketik. <br><br>  Selain itu, Pyre tidak memverifikasi operasi yang benar dari badan fungsi jika fungsi tersebut tidak sepenuhnya dijelaskan.  Dalam contoh berikut, panggilan ke <code>some_function</code> akan gagal.  Akan menyenangkan untuk mengetahui hal ini sebelum kode masuk ke produksi. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">some_function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(in: int)</span></span></span><span class="hljs-function"> -&gt; bool:</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">some_other_function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> some_function(<span class="hljs-string"><span class="hljs-string">"bla"</span></span>): <span class="hljs-comment"><span class="hljs-comment"># &lt;-             print("Yay!")</span></span></code> </pre> <br>  Dalam hal ini, kami dapat mencari tahu tentang kesalahan yang sama setelah kode masuk ke produksi.  Faktanya adalah <code>some_other_function</code> tidak memiliki anotasi tipe return.  Jika kita mencatatnya menggunakan mekanisme heuristik kita menggunakan tipe <code>None</code> disimpulkan secara otomatis, maka kita akan menemukan masalah dengan jenisnya sebelum dapat menyebabkan masalah.  Ini, tentu saja, adalah contoh buatan, tetapi di Instagram masalah seperti itu serius.  Jika Anda memiliki jutaan baris kode, maka Anda, dalam proses peninjauan kode, mungkin akan kehilangan hal-hal yang tampak sangat jelas dalam contoh sederhana. <br><br>  Di Instagram, metode di atas berdasarkan tipe yang dideduksi secara otomatis memungkinkan pengetikan sekitar 10% dari fungsi.  Akibatnya, orang tidak lagi harus secara manual mengedit ribuan fungsi.  Kelebihan dari kode yang diketik jelas, tetapi ini, dalam konteks percakapan kami, mengarah ke keuntungan penting lainnya.  Basis kode yang diketik sepenuhnya membuka kemungkinan yang lebih besar untuk memproses kode menggunakan codemods. <br><br>  Jika kami memercayai anotasi jenis, itu artinya Pyre dapat membuka kemungkinan tambahan untuk kami.  Mari kita lihat kembali contoh di mana kita mengganti nama fungsinya.  Bagaimana jika entitas yang kita beri nama baru diwakili oleh metode kelas dan bukan fungsi global? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d9/ce4/104/6d9ce41040213049ace2a2fe539f9d20.png"></div><br>  <i><font color="#999999">Fungsi adalah metode kelas</font></i> <br><br>  Jika Anda menggabungkan informasi jenis yang diterima dari Pyre dan mode kode yang mengubah nama fungsi, Anda dapat, secara tak terduga, melakukan koreksi ke tempat fungsi dipanggil dan di mana ia diumumkan!  Dalam contoh ini, karena kita tahu apa yang ada di sisi kiri konstruk <code>a.fn</code> , kita juga tahu bahwa mengubah konstruk ini menjadi <code>a.add</code> . <br><br><h2>  <font color="#3AC1EF">Analisis statis lebih maju</font> </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b74/7cb/336/b747cb3364794c02e73bd84b116d1d27.png"></div><br>  <i><font color="#999999">Python memiliki empat jenis cakupan: ruang lingkup global, ruang lingkup tingkat kelas dan fungsi, ruang lingkup bersarang</font></i> <br><br>  Analisis cakupan memungkinkan kita untuk menggunakan codemod yang lebih kuat.  Ingat salah satu contoh di atas, di mana kita berbicara tentang fakta bahwa menambahkan anotasi jenis juga dapat berarti perlunya bekerja dengan perintah impor?  Jika sistem menganalisis ruang lingkup, ini berarti bahwa kita dapat mengetahui jenis mana yang digunakan dalam file yang ada di dalamnya berkat perintah impor, yang dideklarasikan secara lokal, dan mana yang hilang.  Demikian pula, jika Anda tahu bahwa variabel global tumpang tindih oleh argumen fungsi, Anda dapat menghindari secara tidak sengaja mengubah nama argumen tersebut saat mengganti nama variabel global. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Dalam upaya kami untuk memperbaiki semua kesalahan dalam kode Instagram, kami memahami satu hal.  Terdiri dari fakta bahwa pencarian kode yang perlu diperbaiki seringkali lebih penting daripada perbaikan itu sendiri.  Pemrogram sering harus menyelesaikan tugas-tugas sederhana - seperti mengganti nama fungsi, menambahkan argumen ke metode, atau membagi modul menjadi beberapa bagian.  Semua ini lumrah, tetapi ukuran basis kode kami berarti bahwa seseorang tidak akan dapat menemukan setiap baris yang perlu diubah.  Itulah mengapa sangat penting untuk menggabungkan kemampuan codemod dengan analisis statis yang andal.  Ini memungkinkan kita untuk lebih percaya diri menemukan bagian-bagian dari kode yang perlu diubah, yang berarti memungkinkan kita untuk membuat mode kode lebih aman dan lebih kuat. <br><br>  <b>Pembaca yang budiman!</b>  Apakah Anda menggunakan mod kode? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id473770/">https://habr.com/ru/post/id473770/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id473760/index.html">Psss, mau cerita IT yang mengerikan?</a></li>
<li><a href="../id473762/index.html">Pekerjaan bukanlah serigala, bagian 1. Pencarian pekerjaan: 9 lap HR-a</a></li>
<li><a href="../id473764/index.html">Parcel adalah pembangun proyek favorit saya</a></li>
<li><a href="../id473766/index.html">Analisis statis volume besar kode Python: pengalaman Instagram. Bagian 1</a></li>
<li><a href="../id473768/index.html">5 buku teratas untuk mereka yang ingin meningkatkan keterampilan mereka</a></li>
<li><a href="../id473774/index.html">Cloud Aman di DF Cloud</a></li>
<li><a href="../id473776/index.html">Penyatuan aturan validasi dengan contoh Asp core + VueJS</a></li>
<li><a href="../id473778/index.html">Optimalisasi Gambar: Cara Menggunakan AI Google Visi untuk Memahami Prinsip Peringkat Gambar</a></li>
<li><a href="../id473780/index.html">Deteksi kontur cepat dalam video 4K: warna dan bentuk kompleks</a></li>
<li><a href="../id473784/index.html">Bagaimana cara menulis kontrak pintar untuk WebAssembly di jaringan Ontology? Bagian 2: C ++</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>