<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤛 ☘️ ✍🏻 SQL中的Lambda函数...让我们想一想 🧔🏾 🧜🏼 🦑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="顾名思义，本文将涉及的内容。 

 此外，作者还将从他的角度解释为什么这样做是必要的，并告诉我们SUBJ不仅是一种时尚的技术，而且是“一项双重必要的业务-既愉快又有用”。 

 看到几个有才华的人如何做某事（一种编程语言，为什么不这样做），确切地知道他们正在解决什么问题以及他们为自己设定的任务，总是...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>SQL中的Lambda函数...让我们想一想</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435120/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/sl/ch/fp/slchfpm_a-deoh62fqiazjgdc5k.png" alt="图片"></div><br> 顾名思义，本文将涉及的内容。 <br><br> 此外，作者还将从他的角度解释为什么这样做是必要的，并告诉我们SUBJ不仅是一种时尚的技术，而且是“一项双重必要的业务-既愉快又有用”。 <br><a name="habracut"></a><br> 看到几个有才华的人如何做某事（一种编程语言，为什么不这样做），确切地知道他们正在解决什么问题以及他们为自己设定的任务，总是很有趣的。 并测试自己的创作。 不能将它与巨型委员会的巨大创造相提并论，巨型委员会将维持宇宙的和谐放在首位，并且谁知道这一点。 <br><br> 比较例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FORTRAN</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PL / 1</a>的命运。 现在谁会记得这个PL / 1。 <br><br> 从这个角度来看，例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AWK</a>是非常成功的。 值得一说的是，以A的名字叫<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Alfred Aho</a> （《 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">龙书》</a>的作者之一），W的是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Peter Weinberger</a> ，他在Fortran-77上有过帮助，K的人是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Brian Kernigan</a> ，如果没有他的话。 该语言旨在处理进程之间管道中的即时文本流。 <br><br> 该语言是无类型的（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这不是完全正确的</a> ），其语法与C非常相似，具有过滤功能，关联数组，流开始/结束事件，换行事件... <br><br> 该语言也给作者留下了深刻的印象，那就是它的解释器不需要安装，在类UNIX的系统下，它总是存在，而在Windows下，仅复制可执行文件就可以了，一切正常。 但是，事实并非如此。 <br><br> 在此过程中，作者不得不经常使用SQL + AWK捆绑软件，这就是原因。  SQL仍然是最初用来控制数据流的声明性语言。 它以聚合函数的形式提供了非常有限的机会来处理查询执行的上下文。 <br><br> 例如，如何使用SQL构建二维直方图？ <br><br><pre><code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--   100 x 100 SELECT count(), round(x, -2) AS cx, round(y, -2) AS cy FROM samples GROUP BY cx, xy</span></span></code> </pre> <br> 但是，可以说，使用GROUP BY意味着要进行排序，如果您拥有数亿（甚至更多）行，这也不是一件容易的事。 <br><div class="spoiler">  <b class="spoiler_title">UPD：他们在评论中纠正了我的观点，即这并不完全正确（或根本不正确）</b> <div class="spoiler_text">  SQL处理器具有在根据分组标准构造散列的过程中执行聚合功能的能力。 为此，有必要拥有足够的可用内存量以将哈希图放置在内存中。 <br><br> 然后，将在读取表时更新组的上下文，并且在读取结束时，我们将已经具有计算的结果。 <br> 可以将相同的技术扩展到窗口功能（下图），只是上下文会“变厚”。 <br><br> 如果组的数量事先未知或很大，则SQL处理器将被迫建立一个临时索引并在第二遍中遍历它。 <br><br> 例如，在简单的情况下，例如这里-一个简单的COUNT，一个通用选项是可能的-一个临时索引（cx，cy，count），然后只有少量的组，它们都将存储在缓存页面上的内存中。 在复杂的情况下，窗口功能会导致组的状态变得不平凡，并且不断地（取消）对其进行序列化根本不是医生命令的。 <br></div></div> 简介：SQL处理器在无法估计GROUP BY之后的组数时会诉诸排序。 但是，按计算值进行分组只是（通常）情况。 <br><br> 因此，您必须执行以下操作： <br><br><pre> <code class="bash hljs">psql -t -q -c <span class="hljs-string"><span class="hljs-string">'select x, y from samples'</span></span> | gawk -f mk_hist2d.awk</code> </pre> <br> 其中，mk_hist2d.awk在关联数组中累积统计信息，并在工作完成后显示该统计信息 <br><br><pre> <code class="cpp hljs"># mk_hist2d.awk { bucket[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>($<span class="hljs-number"><span class="hljs-number">2</span></span>*<span class="hljs-number"><span class="hljs-number">0.01</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>($<span class="hljs-number"><span class="hljs-number">3</span></span>*<span class="hljs-number"><span class="hljs-number">0.01</span></span>)]+=$<span class="hljs-number"><span class="hljs-number">1</span></span>; } END { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">500</span></span>; i++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j=<span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">500</span></span>; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((i, j) in bucket) print i*<span class="hljs-number"><span class="hljs-number">100.</span></span><span class="hljs-string"><span class="hljs-string">" "</span></span>j*<span class="hljs-number"><span class="hljs-number">100.</span></span><span class="hljs-string"><span class="hljs-string">" "</span></span>bucket[i, j]; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> print i*<span class="hljs-number"><span class="hljs-number">100.</span></span><span class="hljs-string"><span class="hljs-string">" "</span></span>j*<span class="hljs-number"><span class="hljs-number">100.</span></span><span class="hljs-string"><span class="hljs-string">" 0"</span></span>; } }</code> </pre><br> 但是只有一个-完整的数据流必须从服务器发送到工作机器，这并不便宜。 <br><br> 是否可以通过某种方式将令人愉悦的与有用的相结合-在执行SQL查询期间累积统计信息，而无需求助于排序？ 是的，例如，使用自定义聚合函数。 <br><br><h4> 自定义汇总功能 </h4><br>  Subj存在于不同的系统中，在任何地方都以自己的方式做了一些事。 <br><br><ol><li>  <b>PostgreSQL的</b> 文档在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a> 。 更多细节<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里</a> 。 <br> 这<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">是</a>计算最大帐户余额的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">地方</a> 。 <br> 这是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一个</a>计算布尔列中更多内容<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的示例</a> -true或false。 <br><br> 看起来像这样- <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AGGREGATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mode</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">boolean</span></span>) ( SFUNC = mode_bool_state, STYPE = <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span>[], FINALFUNC = mode_bool_final, INITCOND = <span class="hljs-string"><span class="hljs-string">'{0,0}'</span></span> );</code> </pre><br>  <b>SFUNC</b>是一个针对流中每一行调用的函数， <br> 其中的第一个参数是<b>STYPE</b>类型。 <br><br>  <b>FINALFUNC</b>用于完成计算并返回合计值。 <br>  <b>INITCOND-</b>内部状态的初始值（ <b>STYPE</b> ）的初始化，作为第一个参数传递。 <br> 鉴于函数可以用C编写（这意味着对于内部状态，您可以使用在关闭请求时自动释放的内存），这是一个非常强大的工具。 在其使用范围之外，仍然必须能够使用。 </li><li>  <b>MS SQL</b> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">以前</a> （2000年），在请求之前，有必要创建一个ActiveX对象，以使用该对象进行聚合。 <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">现在</a> （2016年以上），这是在CLR环境中完成的。 您将必须创建一个自定义<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">函数</a> ，创建并注册一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">程序集</a> 。 然后，您可以创建一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">聚合</a> 。 <br> 计算几何平均值以及合并字符串<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的示例</a> ：带有附加参数和用于存储中间状态的用户定义类型。 </li><li>  <b>甲骨文</b> <br> 在Oracle中，这是使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ODCIAggregate</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">数据盒式磁带</a> （接口）完成的。 <br> 要创建自己的聚合，您需要编写一个实现4种方法的自定义类型 <br>  -初始化（ODCIAggregateInitialize），静态的，应创建所需类型的实例并通过参数返回 <br>  -迭代（ODCIAggregateIterate），在每行数据上调用 <br>  -合并（ODCIAggregateMerge），用于合并并行执行的聚合 <br>  -完成（ODCIAggregateTerminate）-结果输出 <br> 示例： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1，2，3，4</a> 。 </li><li>  <b>DB2</b> <br> 在DB2中没有明确的方法来使用定制聚合。 <br> 但是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">您可以</a>将标准函数（尽管是MAX）转换为用户定义的类型（在Java中），并使系统执行以下形式的查询 <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> Complex <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-built_in"><span class="hljs-built_in">real</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DOUBLE</span></span>, i <span class="hljs-keyword"><span class="hljs-keyword">DOUBLE</span></span> ) … <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> complexNumbers ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">number</span></span> Complex ) … <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum..real, sum..i <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> GetAggrResult(<span class="hljs-keyword"><span class="hljs-keyword">MAX</span></span>(BuildComplexSum(<span class="hljs-built_in"><span class="hljs-built_in">number</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> complexNumbers ) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> t(<span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>)</code> </pre></li></ol><br> 在所有这些系统中值得注意的是什么？ <br><br><ul><li> 一种或另一种方式，您将需要在数据库中创建一些对象。 是AGGREGATE还是TYPE。 至少需要适当的权利。  <i>而且只想在他的膝盖上加上一些数字。</i> <br></li><li> 您可能必须用另一种语言编写某些内容，无论是C，C＃还是Java。 <br> 为了将写入的内容集成到系统中，再次需要权限。  <i>但是我只想要...</i> <br></li><li> 初始化困难。 假设您要读取不同篮子尺寸的直方图。 似乎更容易-在声明汇总（PostgreSQL）和整个业务时，我们将指示所需的INITCOND。 但是，对于每个篮子的大小，您将需要自己的汇总，并且再次需要权利。 <br><br> 在这里，您可以求助于肮脏的技巧，并从初始化行（向前）和数据中滑动联合处理器，而不是在构造函数中构造上下文，而是在接收到第一行时构造上下文。 <br></li><li> 但是，即使有上述限制，自定义聚合也可以计算任何内容。 <br></li><li> 重要的是<u>聚合可以并行化</u> ，至少PostgreSQL，Oracle（Enterprise Edition）可以做到。 为此，真相将必须学习如何序列化/反序列化中间状态，以及冻结从不同流接收到的中间状态。 </li></ul><br><h4> 视窗功能 </h4><br> 窗口函数出现在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SQL：2003</a>标准中。 目前，它们受以上所有系统的支持。 本质上，窗口功能是单元工作的扩展。 而且，当然，自定义聚合函数也可以在窗口上下文中工作。 <br><br> 扩展名是这个。 在SQL：2003之前，聚合函数在某个窗口中工作，该窗口要么是整个结果集，要么是其一部分，与GROUP BY表达式中字段值的组合相对应。 用户现在可以自由操作该窗口。 <br><br> 区别在于，使用窗口计算的值将添加到单独列中的输出中，并且不需要使用聚合函数折叠整个流。 因此，在一个请求中，您可以在自己的上下文（窗口）中使用多个窗口聚合。 之前可能有几个聚合函数，但是它们都在一个窗口中工作。 <br><br> 大笔画 <br><br><ul><li>  <b>超过（）</b> <br> 窗口是整个结果集。 假设查询“ <i>来自Samples</i>的<i>select count（1）</i> ”返回169。在这种情况下，将“ <i>select count（1）over Samples（）之上</i> ”运行，我们得到的列被写入169次，即169次。 </li><li>  <b>结束（提交依据）</b> <br> 它类似于GROUP BY，对于每个值组合，都会创建一个窗口，在其中执行聚合函数。 假设在“样品”表中，一个整数列是val，数据是1到169之间的数字。 <br> 然后查询“ <i>从样本中选择计数（1）超过（除以（12 + val）/ 13）</i> ”将返回一列，其中将值13写入169次。 <br></li><li>  <b>超过（订购）</b> <br> 可以与PARTITION BY结合使用，使您可以在光标期间动态更改窗口的大小，在这种情况下，窗口从组的开始延伸到当前光标位置。 结果，对于该组，结果在聚合列中不是相同的值，而是它自己的值。 方便计算累计金额。 查询结果 <br>  <i>“从Samples中选择（按Val排序）之上的sum（val）</i> ”将是一列，其中第n个元素将包含从1到n的自然数之和。 </li><li>  <b>超过（行）</b> <br> 允许您从光标位置或ORDER BY范围的开始/结束处定义窗口框架。 <br><br> 例如，“ <i>... ROWS 1 PRECEDING ...</i> ”表示窗口由当前行和前一行组成。  “ <i>...跟随1跟随和2跟随...之间的行</i> ”-窗口在光标之后紧接两行。 <br><br> 在此模式下，CURRENT ROW指示当前光标位置。 例如，“行与当前行之间的行”表示从当前行到范围的结尾。 </li><li>  <b>超过（范围）</b> <br> 与ROWS的不同之处在于，此处的CURRENT ROW表示作为窗口的起点，是ORDER BY范围的起点，而作为窗口的终点-ORDER BY范围的最后一行。 </li></ul><br> 在不同系统上使用窗口函数的语法略有不同。 <br><br> 综上所述，开发人员在分析了各种SQL报表的构造后，突出显示了最常见的情况并在语法中将它们具体化了，仍然感到有些痛苦。 <br><br><h4> 记录返回功能 </h4><br> 在聚合/窗口函数的输出中，每个结果行对应于传入数据流中的特定范围的行。 在生活中，这种对应并不总是存在。 <br><br> 例如，需要构造协方差矩阵10X10（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">为此</a>需要672X672）。 这<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">可以一次</a>完成，为此，我们使用10个数字参数执行由我们编写的聚合函数。 她的工作结果是一个10行10值记录集，每个矩阵元素引用输入流的所有行（无论有多少行）。 <br><br> 我们可以说-因此，例如在PostgreSQl中， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">您可以</a>从函数返回二维数组（例如：“ ARRAY [[1,2]，[3,4]”）。 或者只是将矩阵序列化为一行。 <br><br> 很好，但并非总是可以在这种方法可接受的框架内保持结果的大小。 <br><br><div class="spoiler">  <b class="spoiler_title">抒情离题</b> <div class="spoiler_text"> 例如，我们的任务是概括几何。 <br><br> 几何形状的大小对我们来说是未知的，也可能是来自数千万个点的欧亚大陆的海岸线。 反之亦然，这是一个非常粗糙的几何图形，您需要使用样条曲线对其进行平滑处理。 我想将参数传递给聚合并获取数据流，而不是向量或字符串。 <br><br> 您当然可以说问题牵强，没有人解决，DBMS中的几何以一种特殊的方式存储，有专门的程序来处理几何，... <br><br> 实际上，将几何图形逐点存储在常规表中非常方便，这仅是因为仅通过移动一个点就无需重写整个Blob。 在DBMS中的空间数据泄漏到各处之前，例如在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ArcSDE中</a> 。 <br><br> 一旦几何体Blob的平均大小超过页面大小，直接使用点就变得更加有利可图。 如果有机会以点数进行操作，那么历史之轮也许会再次转向。 <br></div></div><br> 协方差矩阵仍然不是输入流和输出流之间去同步的一个很好的例子，因为在最后同时获得了整个结果。 假设您要处理/压缩源数据流。 同时 <br><br><ul><li> 有很多数据，它们位于没有索引的“堆”中，实际上它们只是“快速”写入磁盘 </li><li> 您需要将它们归类为不同的类别，这些类别相对较少 </li><li> 在类别中，在时间间隔内取平均值，仅存储平均值，测量次数和方差 </li><li> 所有这些都需要快速完成 </li></ul><br> 有哪些选择？ <br><br><ol><li> 在SQL中，需要按时间间隔/类别进行排序，这与最后一点相矛盾。 </li><li> 如果数据已经按时间排序（实际上并不能保证），并且有可能将此事实传达给SQL处理器，则可以使用窗口函数和一次传递。 </li><li> 编写一个单独的应用程序来完成所有这些工作。 在PL / SQL中，或更可能的情况是，在C / C ++中，由于有大量数据。 </li><li> 返回记录的函数。 也许他们可以帮助我们。 </li></ol><br> 有关A.4的更多详细信息。 为此有两种机制-临时表和管道功能。 <br><br><ol><li> 传送带功能。 <br> 这种机制<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">出现</a>在Oracle中（从9i，2001开始），并且允许返回记录集的函数不累积数据，而是根据需要进行计算（类似于通过管道连接的两个进程的stdout和stdin的同步）。 <br> 即 流水线函数的结果可能在退出此函数之前开始进行处理。 为此，在函数的定义中就可以说 <br><br><pre> <code class="sql hljs"> FUNCTION f_trans(p refcur_t) RETURN outrecset PIPELINED IS …</code> </pre> <br> 并在正文中记录结果行 <br><br><pre> <code class="sql hljs">LOOP … out_rec.var_char1 := in_rec.email; out_rec.var_char2 := in_rec.phone_number; PIPE ROW(out_rec); … <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span>;</code> </pre> <br> 结果，我们有 <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span>( refcur_pkg.f_trans( <span class="hljs-keyword"><span class="hljs-keyword">CURSOR</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> employees <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> department_id = <span class="hljs-number"><span class="hljs-number">60</span></span>)));</code> </pre><br> 有管道功能时，根本不需要自定义聚合。 <br><br> 真棒，甲骨文！ <br><br> 不久之前（2014年），管道功能也<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">出现</a>在DB2中（IBM i 7.1 TR9，i 7.2 TR1）。 </li><li> 临时表。 <br> 首先，似乎MS SQL和PostgreSQL都不能从聚合函数返回游标。 <br><br> 好吧，让我们类似于流水线函数，将游标作为参数，进行处理，将其添加到临时表中，然后将游标返回给它。 <br><br> 但是，在MS SQL中<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">，无法</a>通过参数将游标传递到存储过程，只能在过程中创建游标并通过输出返回参数。  PostgreSQL也可以这样<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">说</a> 。 <br><br> 好吧，好的，只需打开游标，减去它，处理值，计算结果，将其添加到临时表中并呈现游标即可。 <br><br> 或更简单地说，我们将查询结果添加到一个临时表中，对其进行处理，然后将结果通过游标返回到另一个临时表中。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我</a>能说<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">什么</a> 首先，也是最重要的是，通过游标读取数据要比流中的处理慢。 其次，为什么要使用SQL处理器，让我们用光标读取表，用手创建临时表，在循环中编写连接逻辑……就像在C / C ++中插入汇编程序一样，有时您可以自己处理，但最好不要滥用它。 </li></ol><br> 因此，考虑到函数返回记录集的问题后，我们得出以下结论： <br><br><ul><li> 自定义聚合不会真正帮助我们。 </li><li> 无论如何，您都需要在数据库中创建一些对象。 无论是功能表还是临时表。 至少需要适当的权利。  <i>并且只想处理一些数字。</i> <br></li><li> 但是，即使有上述限制，有时它也不是很优雅，但是使用此方法可以解决问题。 </li></ul><br><h4> 还有什么 </h4><br> 实际上，如果我们已经有解决问题的机会，那么作者还需要什么？ <br> 实际上，图灵机还可以计算任何东西，只是速度不是很快且不太方便。 <br><br> 我们制定如下要求： <br><br><ol><li> 它必须是一个可与其他运算符（选择，投影等）同等使用的关系运算符 </li><li> 它必须是将一个数据流转换为另一个数据流的运算符 </li><li> 输入和输出流之间没有同步 </li><li> 运算符声明定义输出流的结构 </li><li> 操作员具有动态初始化的能力（以函数的形式，更确切地说是其主体，直接在操作员的定义中指定） </li><li> 以及函数形式的析构函数（...） </li><li> 以及每次从输入流中收到新行时调用的函数（...） </li><li> 操作员具有执行上下文-工作所需的用户定义的变量和/或集合集 </li><li> 要运行此运算符，您不需要创建数据库对象，不需要其他权限 </li><li> 工作所需的所有内容都用一种语言在一个地方定义 </li></ol><br> 曾几何时<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">，</a>作者创建了这样的运算符，该运算符扩展了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">TTM /教程D</a>的已实现子集的自制处理器<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">。</a> 现在，针对SQL提出了相同的想法。 <br><br> 值得警告的是，此处SQL结束并且即兴开始。 语法保留了原来的语法，最后，语法糖可以是任何东西，它不会改变本质。 <br><br> 因此， <b>咀嚼</b>操作员包括 <br><br><ol><li> 包含输出字段及其类型列表的标题。 <br> 每个输出（和输入）字段都是一个局部变量。 <br> 例如： <i>“ chew {“ var1” float，“ var2” integer}”</i>表示输出流中将有两列-浮点数和整数 </li><li> 实体-事件的回调列表，此刻-流的开始，流的结束，行。 按照语法，函数接近PL / SQL。 预定义的函数<i>__interrupt</i> （）是PIPE的类似物，它从对应于输出列的变量中获取值并将其放置在输出流中。 如果输出流的缓冲区溢出，则处理程序的工作将暂停，并且流的接收方的工作将开始。 <br> 例如：“ hook”初始化“ {var1：= 0;  var2：= -1;  }“ </li></ol><br> 显示示例的最简单方法。 <br><br><ul><li> 聚合函数SUM的类似物。 <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--  'select sum(val) from samples' -- select * from samples chew {“sum(val)” float} --    hook “init” { “sum(val)” := 0; --      } hook “row” { if (not isnull("val")) then "sum(val)" := "sum(val)" + "val"; end if; } hook “finit” { call __interrupt(); --  PIPE }</span></span></code> </pre><br> 它看起来很笨重，但这只是一个例子， <br> 无需编写C程序来添加几个数字。 </li><li> 求和+ AVG <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--  'select sum(val), avg(val) from samples' -- select * from samples chew { “sum(val)” float, “avg(val)” float --       } hook “init” { “sum(val)” := 0; “avg(val)” := 0; var num integer; num := 0; --    ,       } hook “row” { if (not isnull("val")) then "sum(val)" := "sum(val)" + "val"; num := num + 1; end if; } hook “finit” { if (num &gt; 0) then “avg(val)” := “sum(val)” / num; end if; call __interrupt(); }</span></span></code> </pre><br> 在这里，我们提请注意以下事实：求和仅发生一次。 </li><li>  SUM + GROUP BY <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--  'select sum(val) from samples group by type' -- select * from --     ( samples val, type from samples order by type ) chew { “sum(val)” float } hook “init” { “sum(val)” := 0; var gtype integer; gtype := NULL; var num integer; --   num := 0; } hook “row” { if (gtype &lt;&gt; “type”) then __interrupt(); “gtype” := type; "sum(val)" := 0; num := 0; end if; if (not isnull("val")) then "sum(val)" := "sum(val)" + "val"; num := num + 1; end if; } hook “finit” { if (num &gt; 0) then call __interrupt(); end if; }</span></span></code> </pre></li><li>  ROW_NUMBER（）个（）个以上 <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">-- select row_number() over() as num, * from samples -- select * from samples chew { “num” integer, * --        --   '* except val1, ...valX',   TTM } hook “init” { num := 0; } hook “row” { num := num + 1; call __interrupt(); }</span></span></code> </pre></li></ul><br> 是否有可能提供一个示例，说明该方法所获得的结果是通常用常规方法无法获得的？ 我们有他们。 <br><br> 有时会发生数据几乎被排序的情况。 它们甚至可能已经完全排序，但是不确定。 <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">假设在上面的示例（数据流压缩）中，数据来自不同的来源，并且由于各种原因，可以将它们进行少量混合。</font></font>即<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来自一个带有时间戳T1的源的行可以位于来自另一个带有时间戳T2的源的行之后，而T1 &lt;T2。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">即使我们保证T1和T2之间的差异永远不会超过某个（稀疏的）常数，我们也不能在这里进行排序（以传统方式）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然而，使用所提出的方法，仅在输入已经接收到时间戳超过该间隔的右边界的时间戳至少超过给定常数的行之后，才可能缓冲输入流并处理当前时间间隔的数据。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里有一个非常重要的观点。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只有我们知道数据几乎已排序。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只有我们知道该常数的值。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该常数仅对于该问题是特征，并且可能仅对于该实验是特征。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而且，我们会根据自己的职责使用此技巧来避免排序。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们对任务的标准知识并不以告诉SQL处理器的标准方式存在，并且很难想象。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并且使用lambda函数提供了一种通用的方式来强制SQL处理器完全在需要的地方执行我们需要的操作。</font></font><br><br><h4> 结论 </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">拟议的设计看起来很难实现。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无论如何，要使用有效的PL / SQL。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这个想法本身是简单而直观的，不会在语言中添加新的实体。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是一个单元，如有必要，它将替换聚合和窗口函数GROUP BY。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一种机制，使您无需传统SQL处理器就无法进行排序。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但最重要的是，它是一种机制，使您可以自由地以最必要的方式处理数据。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">感谢Dorofei Proleskovsky参与本文的准备。</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN435120/">https://habr.com/ru/post/zh-CN435120/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN435106/index.html">再说一次passport.js</a></li>
<li><a href="../zh-CN435108/index.html">使用Prolog</a></li>
<li><a href="../zh-CN435112/index.html">企业面试</a></li>
<li><a href="../zh-CN435114/index.html">春季数据JPA</a></li>
<li><a href="../zh-CN435118/index.html">Save File Me-具有客户端加密的免费备份服务</a></li>
<li><a href="../zh-CN435122/index.html">如何在Playstation上的《毁灭战士》中实现火焰</a></li>
<li><a href="../zh-CN435124/index.html">世界立柱构造的杰作：带可变数目乐队的录音室监听变压器</a></li>
<li><a href="../zh-CN435126/index.html">有组织和举办公司会议的经验，以供分析师使用</a></li>
<li><a href="../zh-CN435128/index.html">Pi-Sonos：失控的爱好</a></li>
<li><a href="../zh-CN435132/index.html">游牧民族：问题与解决方案</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>