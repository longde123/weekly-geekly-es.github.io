<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗄️ 🍍 👩🏾‍🍳 Im Auftrag von Embedded-Entwicklern: Suche nach Fehlern in Amazon FreeRTOS 🏀 🕴🏼 🧑🏿‍🤝‍🧑🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jeder, der Mikrocontroller programmiert, kennt FreeRTOS wahrscheinlich oder hat zumindest von diesem Betriebssystem gehört. Die Mitarbeiter von Amazon...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Im Auftrag von Embedded-Entwicklern: Suche nach Fehlern in Amazon FreeRTOS</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/473972/">  Jeder, der Mikrocontroller programmiert, kennt FreeRTOS wahrscheinlich oder hat zumindest von diesem Betriebssystem gehört.  Die Mitarbeiter von Amazon haben beschlossen, die Funktionen dieses Betriebssystems für die Arbeit mit AWS Internet of Things-Diensten zu erweitern - so erschien Amazon FreeRTOS.  Wir, die Entwickler des PVS-Studio-Code-Analysators, wurden gebeten, diese Projekte in der Mail und in den Kommentaren unter den Artikeln zu überprüfen.  Nun, du hast gefragt - wir haben es getan.  Was dabei herauskam - lesen Sie weiter. <br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d2/efa/d2f/8d2efad2f7885ec13add7368f6d2ff96.png" alt="Abbildung 3"></div><a name="habracut"></a><br><h2>  Ein bisschen über Projekte </h2><br>  Zunächst erzähle ich Ihnen ein wenig über den "Vater" des geprüften Projekts - FreeRTOS (den Quellcode finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ).  Wie Wikipedia sagt, ist FreeRTOS ein Multitasking-Echtzeitbetriebssystem für eingebettete Systeme. <br><br>  Es wurde im guten alten C geschrieben, was nicht überraschend ist - dieses Betriebssystem sollte unter für Mikrocontroller typischen Bedingungen funktionieren: geringe Rechenleistung, wenig RAM und dergleichen.  Die C-Sprache ermöglicht es Ihnen, mit Ressourcen auf niedrigem Niveau zu arbeiten und hat eine hohe Leistung. Daher ist sie am besten für die Entwicklung eines solchen Betriebssystems geeignet. <br><br>  Nun zurück zu Amazon, das nicht still sitzt und sich in verschiedenen vielversprechenden Bereichen entwickelt.  Zum Beispiel entwickelt Amazon die AAA-Engine des Amazon Lumberyard-Spiels, die wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ebenfalls getestet haben</a> . <br><br>  Ein solcher Bereich ist das Internet der Dinge (Internet der Dinge, IoT).  Um sich in diesem Bereich weiterzuentwickeln, hat Amazon beschlossen, ein eigenes Betriebssystem zu schreiben - und den FreeRTOS-Kernel als Grundlage genommen. <br><br>  Das resultierende System - Amazon FreeRTOS - ist so positioniert, dass es "die Möglichkeit bietet, eine sichere Verbindung zu Amazon Web Services wie AWS IoT Core oder AWS IoT Greengrass herzustellen".  Der Quellcode für dieses Projekt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wird</a> auf Github <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gespeichert</a> . <br><br>  In diesem Artikel werden wir untersuchen, ob es Fehler in FreeRTOS gibt und wie sicher das Betriebssystem von Amazon in Bezug auf die statische Code-Analyse ist. <br><br><h2>  Wie war der Scheck? </h2><br>  Der Code wurde mit einem automatischen Fehlersuchwerkzeug überprüft: PVS-Studio Static Code Analyzer.  Es kann Fehler in Programmen erkennen, die in C, C ++, C # und Java geschrieben wurden. <br><br>  Bevor Sie mit der Analyse beginnen, müssen Sie das Projekt zusammenstellen. Ich bin mir also sicher, dass ich alle erforderlichen Abhängigkeiten habe und alles mit dem Projekt in Ordnung ist.  Es gibt verschiedene Möglichkeiten, ein Projekt zu überprüfen, z. B. mithilfe eines Kompilierungsüberwachungssystems.  Ich habe die Analyse mit dem Plug-In für Visual Studio durchgeführt. Es ist gut, dass die Repositorys beider Projekte über eine Reihe von Projektdateien verfügen, die das Erstellen unter Windows vereinfachen. <br><br>  Alles, was ich brauchte, war, die Projekte zu sammeln, um sicherzustellen, dass alles für die Überprüfung erforderlich war.  Als nächstes startete ich die Analyse und voila!  - Vor mir ein vorgefertigter Analysatorbericht. <br><br>  In diesen Projekten enthaltene Bibliotheken von Drittanbietern können ebenfalls Fehler enthalten und natürlich auch den Betrieb des Programms beeinträchtigen.  Ich habe sie jedoch aus Gründen der Reinheit der Erzählung von der Analyse ausgeschlossen. <br><br>  So werden die Projekte analysiert, Berichte empfangen, interessante Fehler ausgeschrieben.  Es ist Zeit, mit ihrer Analyse fortzufahren! <br><br><h2>  Was versteckt FreeRTOS </h2><br>  Anfangs hatte ich erwartet, zwei separate Artikel zu schreiben: einen für jedes Betriebssystem.  Ich rieb mir bereits die Hände und bereitete mich darauf vor, einen guten Artikel über FreeRTOS zu schreiben.  Ich erwartete die Entdeckung von mindestens ein paar saftigen Fehlern (wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CWE-457</a> ) und schaute gespannt auf die wenigen Warnungen des Analysators und ... und nichts.  Ich habe keinen interessanten Fehler gefunden. <br><br>  Viele Warnungen, die der Analysator ausgegeben hat, waren für FreeRTOS nicht relevant.  Solche Warnungen waren beispielsweise 64-Bit-Mängel wie das <i>Umwandeln</i> von <i>size_t</i> in <i>uint32_t</i> .  Dies liegt an der Tatsache, dass FreeRTOS für Geräte mit einer Zeigergröße von nicht mehr als 32 Bit ausgelegt ist. <br><br>  Ich habe alle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V1027-</a> Warnungen in Bezug auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Umwandlungen</a> zwischen Zeigern auf nicht verwandte Strukturen sorgfältig geprüft.  Wenn reduzierbare Strukturen die gleiche Ausrichtung haben, ist ein solcher Guss kein Fehler.  Und ich habe keine einzige gefährliche Besetzung gefunden! <br><br>  Alle anderen verdächtigen Stellen bezogen sich entweder auf den Codierungsstil oder wurden mit einem Kommentar versehen, in dem erläutert wurde, warum dies hier genau geschieht und warum dies kein Fehler ist. <br><br>  Im Allgemeinen möchte ich die Entwickler von FreeRTOS kontaktieren.  Ihr seid wirklich großartig!  Wir haben fast nie so saubere und qualitativ hochwertige Projekte wie Ihres getroffen.  Und ich war sehr erfreut, sauberen, ordentlichen und gut dokumentierten Code zu lesen.  Hut ab vor dir. <br><br>  Obwohl ich an diesem Tag keine interessanten Fehler finden konnte, verstand ich, dass ich hier nicht aufhören würde.  Ich ging mit der festen Überzeugung nach Hause, dass in der Version von Amazon 100% etwas Interessantes zu finden sein würde und dass ich morgen definitiv genug Fehler für den Artikel sammeln würde.  Wie Sie wahrscheinlich vermutet haben, hatte ich recht. <br><br><h2>  Was verbirgt Amazon FreeRTOS </h2><br>  Die Amazon-Version des Systems erwies sich als ... gelinde gesagt etwas schlechter.  Das Erbe von FreeRTOS ist genauso sauber geblieben, aber die neuen Revisionen erwiesen sich als recht interessant. <br><br>  An einigen Stellen wurde die Logik des Programms verletzt, irgendwo wurde falsch mit Zeigern gearbeitet.  An einigen Stellen könnte der Code zu undefiniertem Verhalten führen, aber irgendwo wusste der Programmierer einfach nichts über das von ihm erstellte Fehlermuster.  Ich habe sogar einige ernsthafte potenzielle Schwachstellen gefunden. <br><br>  Etwas, das ich mit der Einführung verzögert habe.  Beginnen wir mit der Analyse der Fehler! <br><br><h3>  Verletzung der Programmlogik </h3><br>  Beginnen wir mit den Problembereichen, die deutlich machen, dass das Programm nicht genau so läuft, wie es der Programmierer erwartet hat.  Der erste Ort dieser Art ist verdächtige Arbeit mit einem Array: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @brief Pool of request and associated response buffers, * handles, and configurations. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> _requestPool_t _requestPool = { <span class="hljs-number"><span class="hljs-number">0</span></span> }; .... <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _scheduleAsyncRequest(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> reqIndex, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> currentRange) { .... <span class="hljs-comment"><span class="hljs-comment">/* Set the user private data to use in the asynchronous callback context. */</span></span> _requestPool.pRequestDatas[reqIndex].pConnHandle = &amp;_connHandle; _requestPool.pRequestDatas[reqIndex].pConnConfig = &amp;_connConfig; _requestPool.pRequestDatas[reqIndex].reqNum = reqIndex; _requestPool.pRequestDatas[reqIndex].currRange = currentRange; _requestPool.pRequestDatas[reqIndex].currDownloaded = <span class="hljs-number"><span class="hljs-number">0</span></span>; _requestPool.pRequestDatas[reqIndex].numReqBytes = numReqBytes; .... _requestPool.pRequestDatas-&gt;scheduled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; .... }</code> </pre> <br>  PVS-Studio hat zwei Warnungen für diesen Code ausgegeben: <br><br><ul><li>  V619 Das Array '_requestPool.pRequestDatas' wird als Zeiger auf ein einzelnes Objekt verwendet.  iot_demo_https_s3_download_async.c 973 </li><li>  V574 Der Zeiger '_requestPool.pRequestDatas' wird gleichzeitig als Array und als Zeiger auf ein einzelnes Objekt verwendet.  Überprüfen Sie die Zeilen: 931, 973. iot_demo_https_s3_download_async.c 973 </li></ul><br>  Für alle Fälle möchte ich Sie daran erinnern: Der Name des Arrays ist ein Zeiger auf sein erstes Element.  Das heißt, wenn <i>_requestPool.pRequestDatas</i> ein Array von Strukturen ist, ist <i>_requestPool.pRequestDatas [i] .scheduled der</i> Zugriff auf das <i>geplante</i> Mitglied der <i>i-</i> ten Struktur des Arrays.  Wenn Sie <i>_requestPool.pRequestDatas-&gt; Scheduled</i> schreiben, bedeutet dies den Zugriff auf das <i>geplante</i> Mitglied der ersten Struktur des Arrays. <br><br>  Dies geschieht im obigen Code-Snippet.  Die letzte Zeile ändert den Wert immer nur für ein Mitglied der ersten Struktur des Arrays.  An sich ist dieser Aufruf bereits verdächtig, aber die Situation hier ist noch offensichtlicher: Im gesamten Funktionskörper wird auf das Array <i>_requestPool.pRequestDatas</i> per Index zugegriffen, und erst am Ende des Indizierungsvorgangs wurde vergessen, angewendet zu werden. <br><br>  So wie ich es verstehe, sollte die letzte Zeile so aussehen: <br><br><pre> <code class="cpp hljs">_requestPool.pRequestDatas[reqIndex].scheduled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre> <br>  Der folgende Fehler liegt in einer kleinen Funktion, daher werde ich ihn in seiner Gesamtheit angeben: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Return true if the string " pcString" is found * inside the token pxTok in JSON file pcJson. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> BaseType_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prvGGDJsoneq</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * pcJson, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">jsmntok_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pxTok, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * pcString )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ulStringSize = ( <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ) pxTok-&gt;end - ( <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ) pxTok-&gt;start; BaseType_t xStatus = pdFALSE; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( pxTok-&gt;type == JSMN_STRING ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ( <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ) <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>( pcString ) == ulStringSize ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ( <span class="hljs-keyword"><span class="hljs-keyword">int16_t</span></span> ) <span class="hljs-built_in"><span class="hljs-built_in">strncmp</span></span>( &amp;pcJson[ pxTok-&gt;start ], <span class="hljs-comment"><span class="hljs-comment">// &lt;= pcString, ulStringSize ) == 0 ) { xStatus = pdTRUE; } } } return xStatus; }</span></span></code> </pre> <br>  <b>PVS-Studio Warnung:</b> V642 [CWE-197] Das Speichern des Funktionsergebnisses 'strncmp' in der Variablen 'short' ist unangemessen.  Die signifikanten Bits könnten verloren gehen und die Logik des Programms brechen.  aws_greengrass_discovery.c 637 <br><br>  Werfen wir einen Blick auf die Funktionsdefinition von strncmp: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">strncmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *lhs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *rhs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count )</span></span></span></span>;</code> </pre> <br>  Im Beispiel wird ein Ergebnis vom Typ <i>int</i> mit einer Größe von 32 Bit in eine Variable vom Typ <i>int16_t konvertiert</i> .  Bei einer solchen "Verengungs" -Umwandlung gehen die höchstwertigen Bits des Rückgabewerts verloren.  Wenn die Funktion <i>strncmp</i> beispielsweise <i>0x00010000</i> zurückgibt, <i>geht die</i> Funktion während der Konvertierung verloren und die Bedingung ist erfüllt. <br><br>  In der Tat ist es seltsam, eine solche Besetzung in einem Zustand zu sehen.  Warum überhaupt, wenn Sie normales <i>int</i> mit Null vergleichen können?  Wenn der Programmierer jedoch bewusst wollte, dass die Funktion manchmal <i>true zurückgibt</i> , auch wenn dies nicht der <i>Fall sein</i> sollte, warum wird dieses schwierige Verhalten dann nicht durch den Kommentar beschrieben?  Aber dann ist das schon ein Lesezeichen.  Im Allgemeinen neige ich dazu zu glauben, dass dies ein Fehler ist.  Was denkst du? <br><br><h3>  Undefiniertes Verhalten und Zeiger </h3><br>  Jetzt wird es ein ziemlich großes Beispiel geben.  Es verbirgt die mögliche Dereferenzierung eines Nullzeigers: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> _networkReceiveCallback(....) { IotHttpsReturnCode_t status = IOT_HTTPS_OK; _httpsResponse_t* pCurrentHttpsResponse = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; IotLink_t* pQItem = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; .... <span class="hljs-comment"><span class="hljs-comment">/* Get the response from the response queue. */</span></span> IotMutex_Lock(&amp;(pHttpsConnection-&gt;connectionMutex)); pQItem = IotDeQueue_PeekHead(&amp;(pHttpsConnection-&gt;respQ)); IotMutex_Unlock(&amp;(pHttpsConnection-&gt;connectionMutex)); <span class="hljs-comment"><span class="hljs-comment">/* If the receive callback is invoked * and there is no response expected, * then this a violation of the HTTP/1.1 protocol. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pQItem == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { IotLogError(....); fatalDisconnect = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; status = IOT_HTTPS_NETWORK_ERROR; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> iotCleanup; } .... iotCleanup : <span class="hljs-comment"><span class="hljs-comment">/* Report errors back to the application. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (status != IOT_HTTPS_OK) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( pCurrentHttpsResponse-&gt;isAsync &amp;&amp; pCurrentHttpsResponse-&gt;pCallbacks-&gt;errorCallback) { pCurrentHttpsResponse-&gt;pCallbacks-&gt;errorCallback(....); } pCurrentHttpsResponse-&gt;syncStatus = status; } .... }</code> </pre> <br>  <b>PVS-Studio Warnung:</b> V522 [CWE-690] Möglicherweise wird ein potenzieller Nullzeiger 'pCurrentHttpsResponse' dereferenziert.  iot_https_client.c 1184 <br><br>  Problem-Dereferenzen sind ganz unten, <i>wenn</i> .  Mal sehen, was hier passiert. <br><br>  Zu Beginn der Funktion werden die <i>Variablen</i> <i>pCurrentHttpsResponse</i> und <i>pQItem</i> auf <i>NULL</i> initialisiert, und die Statusvariable wird auf <i>IOT_HTTPS_OK ​​initialisiert</i> , was bedeutet, dass alles reibungslos verläuft. <br><br>  Als nächstes wird <i>pQItem</i> der von der Funktion <i>IotDeQueue_PeekHead</i> zurückgegebene Wert <i>zugewiesen</i> , der einen Zeiger auf den Anfang einer doppelt verbundenen Warteschlange zurückgibt. <br><br>  Was passiert, wenn die Warteschlange leer ist?  In diesem Fall gibt die Funktion <i>IotDeQueue_PeekHead</i> <i>NULL zurück</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> IotLink_t* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IotDeQueue_PeekHead</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IotDeQueue_t* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pQueue)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IotListDouble_PeekHead(pQueue); } .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> IotLink_t* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IotListDouble_PeekHead</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IotListDouble_t* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pList)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">/* @[declare_linear_containers_list_double_peekhead] */</span></span></span><span class="hljs-function"> </span></span>{ IotLink_t* pHead = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pList != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IotListDouble_IsEmpty(pList) == <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { pHead = pList-&gt;pNext; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pHead; }</code> </pre> <br>  Als nächstes ist die Bedingung <i>pQItem == NULL</i> erfüllt und der Steuerungsfluss <i>geht</i> über <i>goto</i> zum unteren Teil des Funktionskörpers.  Zu diesem Zeitpunkt bleibt der <i>pCurrentHttpsResponse-</i> Zeiger null und der <i>Status ist</i> nicht mehr gleich <i>IOT_HTTPS_OK</i> .  Infolgedessen werden wir in <i>genau diesen</i> Zweig fallen, <i>wenn</i> und ... breit!  Die Konsequenzen dieser Dereferenzierung kennen Sie selbst. <br><br>  Okay  Es war ein leicht verziertes Beispiel.  Jetzt mache ich Sie auf eine sehr einfache und verständliche mögliche Dereferenzierung aufmerksam: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PKI_mbedTLSSignatureToPkcs11Signature</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * pxSignaturePKCS, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * pxMbedSignature )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xReturn = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> * pxNextLength; <span class="hljs-comment"><span class="hljs-comment">/* The 4th byte contains the length of the R component */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> ucSigComponentLength = pxMbedSignature[ <span class="hljs-number"><span class="hljs-number">3</span></span> ]; <span class="hljs-comment"><span class="hljs-comment">// &lt;= if( ( pxSignaturePKCS == NULL ) || ( pxMbedSignature == NULL ) ) { xReturn = FAILURE; } .... }</span></span></code> </pre> <br>  <b>PVS-Studio Warnung:</b> V595 [CWE-476] Der Zeiger 'pxMbedSignature' wurde verwendet, bevor er gegen nullptr verifiziert wurde.  Überprüfen Sie die Zeilen: 52, 54. iot_pki_utils.c 52 <br><br>  Diese Funktion erhält zwei Zeiger auf <i>uint8_t</i> .  Beide Zeiger werden auf <i>NULL</i> geprüft, was eine gute Praxis ist - solche Situationen müssen sofort geklärt werden. <br><br>  Aber hier ist das Pech: <i>Wenn pxMbedSignature</i> überprüft wird, wird es bereits eine Zeile darüber buchstäblich dereferenziert.  Ta-daa! <br><br>  Ein weiteres Beispiel für spekulativen Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">CK_RV </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vAppendSHA256AlgorithmIdentifierSequence</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * x32ByteHashedMessage, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * x51ByteHashOidBuffer )</span></span></span><span class="hljs-function"> </span></span>{ CK_RV xResult = CKR_OK; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> xOidSequence[] = pkcs11STUFF_APPENDED_TO_RSA_SIG; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ( x32ByteHashedMessage == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) || ( x51ByteHashOidBuffer == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) ) { xResult = CKR_ARGUMENTS_BAD; } <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>( x51ByteHashOidBuffer, xOidSequence, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>( xOidSequence ) ); <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>( &amp;x51ByteHashOidBuffer[ <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>( xOidSequence ) ], x32ByteHashedMessage, <span class="hljs-number"><span class="hljs-number">32</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xResult; }</code> </pre> <br>  <b>PVS-Studio-Warnungen:</b> <br><br><ul><li>  V1004 [CWE-628] Der Zeiger 'x51ByteHashOidBuffer' wurde unsicher verwendet, nachdem er gegen nullptr überprüft wurde.  Überprüfen Sie die Zeilen: 275, 280. iot_pkcs11.c 280 </li><li>  V1004 [CWE-628] Der Zeiger 'x32ByteHashedMessage' wurde unsicher verwendet, nachdem er gegen nullptr überprüft wurde.  Überprüfen Sie die Zeilen: 275, 281. iot_pkcs11.c 281 </li></ul><br>  Der Analysator warnt davor, dass Funktionsparameter, die Zeiger sind, unsicher verwendet werden, nachdem sie auf <i>NULL</i> getestet wurden.  In der Tat werden die Argumente überprüft, aber wenn sich herausstellt, dass eines von ihnen <i>NULL ist</i> , werden keine Maßnahmen ergriffen, außer zum Schreiben in <i>xResult</i> .  Dieser Code scheint zu sagen: „Ja, das bedeutet, dass die Argumente schlecht waren.  Wir werden es jetzt aufschreiben, während Sie fortfahren, fahren Sie fort. " <br><br>  Fazit: <i>NULL</i> wird an <i>memcpy übergeben</i> .  Was kann daraus werden?  Wo und welche werden die Werte kopiert?  In der Tat lohnt es sich nicht, darüber zu raten, weil  Der Standard <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">besagt eindeutig,</a> dass ein solcher Aufruf zu undefiniertem Verhalten führt (siehe Absatz 1). <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf7/7d6/856/cf77d6856666f6a1529a1744832bd5bf.png" alt="Abbildung 2"></div><br><br>  Der Analysebericht enthält immer noch Beispiele für fehlerhafte Operationen mit Zeigern, die ich in Amazon FreeRTOS gefunden habe. Ich denke jedoch, dass die angegebenen Beispiele bereits ausreichen, um Ihnen die Möglichkeiten von PVS-Studio zur Erkennung solcher Fehler zu demonstrieren.  Betrachten Sie etwas Neues. <br><br><h3>  WAHR! = 1 </h3><br>  Einige Fehler, die ich gefunden habe, bezogen sich auf ein Muster, das leider oft vergessen wird. <br><br>  Tatsache ist, dass sich der <i>Bool-</i> Typ (aus C ++) vom <i>BOOL-</i> Typ (normalerweise in C verwendet) unterscheidet.  Die erste kann nur <i>wahr</i> oder <i>falsch enthalten</i> .  Das zweite ist ein Typedef eines Integer-Typs ( <i>int</i> , <i>long</i> usw.).  Für ihn ist „falsch“ der Wert <i>0</i> und „wahr“ ein anderer Wert als Null. <br><br>  Da es in C keinen integrierten Booleschen Typ gibt, werden diese Konstanten der Einfachheit halber definiert: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FALSE 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TRUE 1</span></span></code> </pre> <br>  Betrachten Sie nun ein Beispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mbedtls_hardware_poll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* output, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* olen)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lStatus = MBEDTLS_ERR_ENTROPY_SOURCE_FAILED; HCRYPTPROV hProv = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Unferenced parameter. */</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)data; <span class="hljs-comment"><span class="hljs-comment">/* * This is port-specific for the Windows simulator, * so just use Crypto API. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TRUE == CryptAcquireContextA( &amp;hProv, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TRUE == CryptGenRandom(hProv, len, output)) { lStatus = <span class="hljs-number"><span class="hljs-number">0</span></span>; *olen = len; } CryptReleaseContext(hProv, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lStatus; }</code> </pre> <br>  <b>PVS-Studio-Warnungen:</b> <br><br><ul><li>  V676 [CWE-253] Es ist falsch, die Variable vom Typ BOOL mit TRUE zu vergleichen.  aws_entropy_hardware_poll.c 48 </li><li>  V676 [CWE-253] Es ist falsch, die Variable vom Typ BOOL mit TRUE zu vergleichen.  Der richtige Ausdruck lautet: 'FALSE! = CryptGenRandom (hProv, len, output)'.  aws_entropy_hardware_poll.c 51 </li></ul><br>  Einen Fehler gefunden?  Und es ist :) Funktionen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>CryptAcquireContextA</i></a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><i>CryptGenRandom</i></a> sind Standardfunktionen aus dem Header <i>wincrypt.h</i> .  Bei Erfolg geben sie einen Wert ungleich Null zurück.  Ich betone - <i>ungleich Null</i> .  Theoretisch kann dies also ein anderer Wert als Null sein: <i>1</i> , <i>314</i> , <i>42</i> , <i>420</i> . <br><br>  Anscheinend hat der Programmierer, der die Funktion aus dem Beispiel geschrieben hat, nicht darüber nachgedacht, und als Ergebnis werden die erhaltenen Werte mit der Einheit verglichen. <br><br>  Mit welcher Wahrscheinlichkeit ist die Bedingung <i>TRUE == CryptGenRandom (....)</i> nicht erfüllt?  Es ist schwer zu sagen.  Möglicherweise gibt <i>CryptGenRandom</i> eine Einheit häufiger als andere Werte zurück, und möglicherweise wird immer nur eine zurückgegeben.  Wir können nicht sicher wissen: Die Implementierung dieser kryptografischen Funktion ist vor den Augen sterblicher Programmierer verborgen :) <br><br>  Es ist wichtig zu bedenken, dass solche Vergleiche potenziell gefährlich sind.  Und statt: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TRUE == GetBOOL())</code> </pre> <br>  Verwenden Sie eine sicherere Option: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FALSE != GetBOOL())</code> </pre> <br><h3>  Optimierungsprobleme </h3><br>  Mehrere Analysatorwarnungen wurden mit langsam laufenden Konstrukten in Verbindung gebracht.  Zum Beispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _IotHttpsDemo_GetS3ObjectFileSize(....) { .... pFileSizeStr = <span class="hljs-built_in"><span class="hljs-built_in">strstr</span></span>(contentRangeValStr, <span class="hljs-string"><span class="hljs-string">"/"</span></span>); .... }</code> </pre> <br>  <b>PVS-Studio Warnung:</b> V817 Es ist effizienter, nach '/' als nach einer Zeichenfolge zu suchen.  iot_demo_https_common.c 205 <br><br>  Kurz und klar, nicht wahr?  Die <i>strstr-</i> Funktion wird hier verwendet, um nach nur einem Zeichen zu suchen, das als Zeichenfolge an den Parameter übergeben wird (es steht in doppelten Anführungszeichen). <br><br>  Dieser Ort kann möglicherweise optimiert werden, indem <i>strstr</i> durch <i>strchr ersetzt wird</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _IotHttpsDemo_GetS3ObjectFileSize(....) { .... pFileSizeStr = <span class="hljs-built_in"><span class="hljs-built_in">strchr</span></span>(contentRangeValStr, <span class="hljs-string"><span class="hljs-string">'/'</span></span>); .... }</code> </pre> <br>  Dann funktioniert die Suche etwas schneller.  Eine Kleinigkeit, aber nett. <br><br>  Solche Optimierungen sind natürlich gut, und der Analysator hat einen anderen Ort gefunden, der viel deutlicher optimiert werden kann: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vRunOTAUpdateDemo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; ; ) { .... xConnectInfo.cleanSession = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; xConnectInfo.clientIdentifierLength = (<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>)<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(clientcredentialIOT_THING_NAME); xConnectInfo.pClientIdentifier = clientcredentialIOT_THING_NAME; .... } }</code> </pre> <br>  <b>Warnung PVS-Studio:</b> V814 Leistungsminderung.  Die 'strlen'-Funktion wurde innerhalb des Körpers einer Schleife mehrmals aufgerufen.  aws_iot_ota_update_demo.c 235 <br><br>  Hmmm ... Innerhalb der Schleife wird bei jeder Iteration <i>strlen</i> aufgerufen, das jedes Mal die Länge derselben Zeile berechnet.  Nicht die effizienteste Operation :) <br><br>  <i>Werfen</i> wir einen Blick auf die Definition von <i>clientcredentialIOT_THING_NAME</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * @brief Host name. * * @todo Set this to the unique name of your IoT Thing. */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> clientcredentialIOT_THING_NAME </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span></span></code> </pre> <br>  Der Benutzer wird aufgefordert, hier den Namen seines Geräts einzugeben.  Standardmäßig ist es leer und in diesem Fall ist alles in Ordnung.  Aber was ist, wenn der Benutzer dort einen langen und schönen Namen eingeben möchte?  Zum Beispiel würde ich meine Idee gerne " <i>Die leidenschaftliche und hoch entwickelte Kaffeemaschine BarBarista-N061E The Ultimate Edition</i> " nennen.  Können Sie sich vorstellen, was meine Überraschung wäre, wenn meine schöne Kaffeemaschine danach etwas langsamer arbeiten würde?  Durcheinander! <br><br>  Um den Fehler zu beheben, sollte <i>strlen</i> aus dem Schleifenkörper genommen werden.  Schließlich ändert sich der Gerätename nicht, während das Programm ausgeführt wird.  Ehhh, hier wäre <i>constexpr</i> von C ++ ... <br><br>  Okay, okay, ich gebe zu: hier war ich etwas verdickt.  Wie mein Kollege Andrei Karpov feststellte, wissen moderne Compiler, was <i>strlen ist,</i> und er hat persönlich beobachtet, wie sie einfach eine Konstante im Binärcode verwenden, wenn sie verstehen, dass sich die Länge des Strings nicht ändern kann.  Es besteht also eine hohe Wahrscheinlichkeit, dass im Build-Modus der Release-Version anstelle der tatsächlichen Berechnung der Zeichenfolgenlänge einfach ein zuvor berechneter Wert verwendet wird.  Dies funktioniert jedoch nicht immer, so dass das Schreiben eines solchen Codes keine gute Praxis ist. <br><br><h2>  Ein paar Worte zu MISRA </h2><br>  Der PVS-Studio-Analysator verfügt über zahlreiche Regeln, mit denen Sie Ihren Code auf Übereinstimmung mit den Standards MISRA C und MISRA C ++ überprüfen können.  Was sind diese Standards? <br><br>  MISRA ist der Codierungsstandard für hochempfindliche eingebettete Systeme.  Es enthält eine Reihe strenger Regeln und Richtlinien zum Schreiben von Code und zum Einrichten des Entwicklungsprozesses.  Es gibt einige dieser Regeln, die nicht nur darauf abzielen, schwerwiegende Fehler zu beseitigen, sondern auch auf verschiedene „Code-Gerüche“ sowie den verständlichsten und lesbarsten Code zu schreiben. <br><br>  Das Befolgen des MISRA-Standards hilft somit nicht nur, Fehler und Schwachstellen zu vermeiden, sondern auch erheblich - erheblich!  - die Wahrscheinlichkeit ihres Auftretens in einem vorhandenen Code verringern. <br><br>  MISRA wird in der Luft- und Raumfahrt, in der Medizin, in der Automobilindustrie und im Militär eingesetzt - wo Menschenleben von der Qualität der eingebetteten Software abhängen. <br><br>  Anscheinend kennen Amazon FreeRTOS-Entwickler diesen Standard und befolgen ihn größtenteils.  Das ist richtig: Wenn Sie ein breit angelegtes Betriebssystem für eingebettete Systeme schreiben, müssen Sie über Sicherheit nachdenken. <br><br>  Ich habe jedoch einige Verstöße gegen den MISRA-Standard festgestellt.  Ich werde hier keine Beispiele für Regeln wie "Keine Union verwenden" oder "Eine Funktion sollte nur eine Rückkehr am Ende des Körpers haben" nennen - leider sind sie nicht spektakulär, wie die meisten MISRA-Regeln.  Ich gebe Ihnen besser Beispiele für Verstöße, die möglicherweise schwerwiegende Folgen haben können. <br><br>  Beginnen wir mit den Makros: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FreeRTOS_ms_to_tick(ms) ( ( ms * configTICK_RATE_HZ + 500 ) / 1000 )</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SOCKETS_htonl( ulIn ) ( ( uint32_t ) \ ( ( ( ulIn &amp; 0xFF ) </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; 24 ) | ( ( ulIn &amp; 0xFF00 ) &lt;&lt; 8 ) \ | ( ( ulIn &amp; 0xFF0000 ) &gt;&gt; 8 ) | ( ( ulIn &amp; 0xFF000000 ) &gt;&gt; 24 ) ) )</span></span></span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LEFT_ROTATE( x, c ) ( ( x </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; c ) | ( x &gt;&gt; ( 32 - c ) ) )</span></span></span></span></code> </pre> <br>  <b>PVS-Studio-Warnungen:</b> <br><br><ul><li>  V2546 [MISRA C 20.7] Das Makro und seine Parameter sollten in Klammern stehen.  Überprüfen Sie den Parameter 'ms' des Makros 'FreeRTOS_ms_to_tick'.  FreeRTOS_IP.h 201 </li><li>  V2546 [MISRA C 20.7] Das Makro und seine Parameter sollten in Klammern stehen.  Überprüfen Sie den Parameter 'ulIn' des Makros 'SOCKETS_htonl'.  iot_secure_sockets.h 512 </li><li>  V2546 [MISRA C 20.7] Das Makro und seine Parameter sollten in Klammern stehen.  Überprüfen Sie die Parameter 'x', 'c' des Makros 'LEFT_ROTATE'.  iot_device_metrics.c 90 </li></ul><br>  Ja, genau das haben Sie gedacht.  Die Parameter dieser Makros werden nicht in Klammern gesetzt.  Wenn jemand versehentlich so etwas schreibt <br><br><pre> <code class="cpp hljs">val = LEFT_ROTATE(A[i] | <span class="hljs-number"><span class="hljs-number">1</span></span>, B);</code> </pre> <br>  dann öffnet sich ein solches "Aufruf" -Makro in: <br><br><pre> <code class="cpp hljs">val = ( ( A[i] | <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; B ) | ( A[i] | <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;&gt; ( <span class="hljs-number"><span class="hljs-number">32</span></span> - B ) ) );</code> </pre> <br>  Erinnern Sie sich an die Prioritäten der Operationen?  Zuerst wird eine bitweise Verschiebung durchgeführt, und erst nachdem es ein bitweises "oder" ist.  Daher wird die Logik des Programms verletzt.  Ein einfacheres Beispiel: Was passiert, wenn der Ausdruck " <i>x + y</i> " an das Makro <i>FreeRTOS_ms_to_tick übergeben wird</i> ?  Eines der Hauptziele von MISRA ist es, das Auftreten solcher Situationen zu verhindern. <br><br>  Jemand könnte Einwände erheben: „Wenn Sie Programmierer haben, die nichts davon wissen, wird Sie kein Standard retten!“ Und ich werde dem nicht zustimmen.  Programmierer sind auch Menschen, und egal wie erfahren ein Mensch ist, auch er kann müde werden und am Ende des Arbeitstages einen Fehler machen.  Dies ist einer der Gründe, warum MISRA dringend die Verwendung automatisierter Analysetools empfiehlt, um ein Projekt auf Übereinstimmung mit dem Standard zu validieren. <br><br>  Ich wende mich an die Entwickler von Amazon FreeRTOS: PVS-Studio hat 12 weitere unsichere Makros gefunden, daher sind Sie dort mit ihnen vorsichtiger :) <br><br>  Ein weiterer interessanter MISRA-Verstoß: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @brief Callback for an asynchronous request to notify * that the response is complete. * * @param[in] 0pPrivData - User private data configured * with the HTTPS Client library request configuration. * @param[in] respHandle - Identifier for the current response finished. * @param[in] rc - Return code from the HTTPS Client Library * signaling a possible error. * @param[in] status - The HTTP response status. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> _responseCompleteCallback(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* pPrivData, IotHttpsResponseHandle_t respHandle, IotHttpsReturnCode_t rc, <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> status) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>* pUploadSuccess = (<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>*)pPrivData; <span class="hljs-comment"><span class="hljs-comment">/* When the remote server response with 200 OK, the file was successfully uploaded. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (status == IOT_HTTPS_STATUS_OK) { *pUploadSuccess = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { *pUploadSuccess = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* Post to the semaphore that the upload is finished. */</span></span> IotSemaphore_Post(&amp;(_uploadFinishedSem)); }</code> </pre> <br>  Können Sie den Fehler selbst finden? <br><br>  <b>PVS-Studio Warnung:</b> V2537 [MISRA C 2.7] Funktionen sollten keine nicht verwendeten Parameter haben.  Überprüfen Sie den Parameter: 'rc'.  iot_demo_https_s3_upload_async.c 234 <br><br>  Schauen Sie genauer hin: Der Parameter <i>rc</i> wird nirgendwo im Funktionskörper verwendet.  Darüber hinaus wird im Kommentar zur Funktion ausdrücklich geschrieben, dass dieser Parameter der Rückkehrcode einer anderen Funktion ist und einen Fehler signalisieren kann.  Warum wird dieser Parameter dann in keiner Weise verarbeitet?  Hier stimmt eindeutig etwas nicht. <br><br>  Selbst ohne solche Kommentare weisen nicht verwendete Parameter häufig auf eine fehlerhafte Programmlogik hin.  Warum werden sie sonst in der Funktionssignatur benötigt? <br><br>  Hier habe ich eine kleine Funktion angegeben, die für ein Beispiel im Artikel gut geeignet ist.  Zusätzlich zu ihr habe ich 10 weitere unbenutzte Parameter gefunden.  Viele von ihnen werden in größeren Funktionen verwendet, und es ist nicht einfach, sie zu finden. <br><br>  Es ist verdächtig, dass sie vorher nicht gefunden wurden.  In der Tat können Compiler solche Fälle leicht erkennen. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b80/6c7/bb9/b806c7bb94c335ce2712e9b46cffc560.png" alt="Abbildung 1"></div><br><br><h2>  Fazit </h2><br>  Dies waren nicht alle Problembereiche, die der Analysator gefunden hatte, aber der Artikel war bereits ziemlich groß.  Ich hoffe, dass die Entwickler von Amazon FreeRTOS dank dieser Probleme einige Mängel beheben können und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PVS-Studio</a> vielleicht sogar selbst <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ausprobieren</a> möchten.  Auf diese Weise können Warnungen eingehender untersucht werden, und die Arbeit mit einer praktischen Benutzeroberfläche ist in der Tat viel einfacher als das Betrachten eines Textberichts. <br><br>  Vielen Dank für das Lesen unserer Artikel!  Wir sehen uns in der nächsten Ausgabe: D. <br><br>  PS Es ist einfach so passiert, dass dieser Artikel am 31. Oktober veröffentlicht wurde.  Deshalb wünsche ich allen ein frohes Halloween! <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br>  Wenn Sie diesen Artikel einem englischsprachigen Publikum zugänglich machen möchten, verwenden Sie bitte den Link zur Übersetzung: George Gribkov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auf Anfrage eingebetteter Entwickler: Erkennen von Fehlern in Amazon FreeRTOS</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de473972/">https://habr.com/ru/post/de473972/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de473956/index.html">Geheime Informationen einer Telefongesellschaft eines Drogendealers</a></li>
<li><a href="../de473958/index.html">Japaner von NICT führten einen funktionierenden Glasfasercluster mit einer Bandbreite von 1 Pbit / s ein</a></li>
<li><a href="../de473960/index.html">Strategien zur Inhaltslokalisierung</a></li>
<li><a href="../de473962/index.html">Der dunkle Modus ist jetzt überall. Ist es so nützlich? (am Ende der Nachbefragung)</a></li>
<li><a href="../de473966/index.html">Auf Anfrage eingebetteter Entwickler: Erkennen von Fehlern in Amazon FreeRTOS</a></li>
<li><a href="../de473974/index.html">Intercom'19 - Eine Konferenz über Kommunikationsautomatisierung von Voximplant findet am 14. November statt</a></li>
<li><a href="../de473976/index.html">AWS Elasticsearch: Grundlegend fehlerhaftes Produkt</a></li>
<li><a href="../de473978/index.html">Solche Schmerzen, solche Schmerzen, Registrierkasse als Dienstleistung 2: 0</a></li>
<li><a href="../de473980/index.html">Technologie und die reale Welt: 4 Start-ups, die die Zukunft der Innenarchitektur verändern</a></li>
<li><a href="../de473982/index.html">NB-IoT: Wie funktioniert es? Teil 3: SCEF - ein einziges Zugriffsfenster auf Betreiberdienste</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>