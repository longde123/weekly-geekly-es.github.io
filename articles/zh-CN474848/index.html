<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏁 👩🏾‍🔧 🧙 俄罗斯方块作为打印机 👩🏽‍🎨 ↖️ 👎🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="旋转，重新排列和降低预定的形状顺序，“俄罗斯方块打印机算法”使用“俄罗斯方块”机制生成任意位图。 

 算法说明 
 该算法将源图像的像素逐行转换为Tetris场的平方，从下到上移动。 为了生成单个正方形，该算法组装了一个由矩形区域组成的结构，该矩形区域完全由其下方的一个正方形支撑。 矩形区域的组装...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>俄罗斯方块作为打印机</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474848/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/sa/az/2c/saaz2chpnuatbjn-rdg3zcryjwo.png"></div><br> 旋转，重新排列和降低预定的形状顺序，“俄罗斯方块打印机算法”使用“俄罗斯方块”机制生成任意位图。 <br><br><h2> 算法说明 </h2><br> 该算法将源图像的像素逐行转换为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Tetris</a>场的平方，从下到上移动。 为了生成单个正方形，该算法组装了一个由矩形区域组成的结构，该矩形区域完全由其下方的一个正方形支撑。 矩形区域的组装完成后，将其线条清除，在其下方保留一个正方形。 这是此行为的三个示例。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/895/c80/be8/895c80be864793bcd951c4edb6943f19.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c6/cdf/615/3c6cdf6159a7bbb9dd2dc95e87374055.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/104/674/951/104674951b666a97f36c4d069006df5d.gif"></div><br> 如下所示，该算法还可以生成具有一种结构的多个正方形。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/caa/aef/04b/caaaef04b763c02d872079282d3b57d5.gif"></div><br> 在构造行的过程中，以这种方式创建的所有正方形都必须基于某种东西。 在上面显示的图像中，生成的正方形位于运动场的地板上。 但是，如果任意线包含孔，则它将无法提供在其上方构建线所必需的支撑。 该算法通过在带孔的字符串顶部创建一个平坦平台来解决此问题。 在下面的动画中，建立在线条顶部的平台由一个红色正方形组成。 平台是一个临时结构，插入最后一个形状会将其删除。 <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/acf/f14/c6d/acff14c6d078f15cc01523e4c24389cb.gif"></div><br> 下图所示的5个红色正方形所在的行位于3个红色正方形所在的行的顶部。 这是通过在底线顶部构建一个平坦平台来实现的。 该平台提供了生成5个红色正方形所需的支持。 最后，通过插入最后一个形状删除平台，然后将新行放置到位。 请注意，如果算法需要以相反的顺序生成线（在5个红色正方形的线上方3个红色正方形的线），则将不需要平台。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/851/0ad/35c/8510ad35cdbf5639b06b5f17957eec79.gif"></div><br><h2> 一平方模式 </h2><br> 作为参考，我将给出7个tetramino（游戏作品）的名称。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cef/817/4aa/cef8174aa74b378cb17af2fe0c6f1c7b.png"></div><br> 本文中介绍的Tetris Printer Algorithm版本专门设计用于渲染旧视频游戏中的sprite。 这些游戏将图形打包为8×8的图块，并为每个像素分配了2个字节。 因此，子画面通常仅包含3种颜色以及透明区域，并且通常大小为16×16或16×32像素。 <br><br> 下面的动画显示了用于创建单个正方形的所有图案。 每个图案都使用可互换的四氨基J，T和L，在底部创建一个正方形。 该算法将此四氨基分配给精灵中存在的3种颜色之一。 其余的四氨基分配了任意颜色。 在整个游戏过程中，所有颜色保持不变。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dfa/b1f/efc/dfab1fefc65efed365513213cdf5ad12.gif"></div><br> 由于三个四氨基的形状，不可能在前两列和后两列中用所有三种颜色创建一个正方形。 因此，用于渲染具有16个像素宽度的sprite的运动场的最小宽度为2 + 16 + 2 = 20平方。 但是，事实证明20太少了。 <br><br> 如下所示，单个底部正方形上方的区域不能仅由一条线组成，因为只有适合它的图形（丁米诺I）没有支撑。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/87f/1e5/645/87f1e56455f90295b076e72296cc58c1.gif"></div><br> 用两条线，伸展整个比赛场地以便获得支持的唯一方法是使用tetramino S和Z。但是在这种情况下，顶行将保留孔。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/58c/ea6/8ef/58cea68ef0e7d83c102402e9ed0255fb.gif"></div><br> 底部正方形上方所需的最小行数为3，并且如上几次所示，存在这种模式。  20平方是放置16像素宽度的精灵所需的最小宽度。 但是20×3 +1 = 61，这个数字不能被4整除，这意味着它不能用四氨基建造。 但是，宽度21为21×3 +1 = 64，它可以由16个四氨基组成。 实际上，此宽度允许算法渲染精灵高达17个像素的宽度。 <br><br> 原始俄罗斯方块的运动场大小为10×20平方（比例为1：2）。 在此算法版本中，此比率得以保留-运动场的大小为21×42平方。 <br><br> 由于四氨基J，T和L在创建一个正方形时是可互换的，并且这些四氨基中的3个正方形参与在其上方创建线，因此有21-3 = 18个样式可用于创建一个正方形。 但是，由于镜像对称，实际上只有9条线。其中9条中的大多数都使用3条线。但是，彻底的计算机研究表明，这两种图形还需要更多。 下一个可能的选择是7行，因为21×7 + 1 = 148，需要37个四氨基。 如下图所示，存在这种模式。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ee/0b4/889/9ee0b488962c79ad6c84255efd033b5d.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a2/643/2ca/7a26432ca3f6e11d43f134057f3bfa73.gif"></div><br><h2> 多个正方形图案 </h2><br> 用于创建多个正方形的图案限于由单个正方形的图案创建的相同三种颜色。 生成的正方形是由四氨基J，T和L创建的，它们各自在创建线上方的一条线上占据3个正方形。 单个图案可以创建的最大正方形数为21/3 =7。但是，对于宽度为16像素的子画面，最右边的四氨基不能创建正方形。 即使在精灵的宽度为17像素的情况下，它也可以创建仅一种颜色的正方形。 因此，很少使用从7个正方形开始创建的模式。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e01/9cc/957/e019cc9577348937886f2f160fd8ad1b.gif"></div><br> 可以使用枚举的组合来确定用于创建任意数量的正方形的模式的数量。 考虑下面的模式，该模式代表三个正方形上方的一行。 三个相邻的白色方块的每个块表示四氨基的一部分； 创建的正方形未显示。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cef/b6d/fe5/cefb6dfe5d0c9c3b644189dc13901e63.gif"></div><br> 三个四氨基产生4个空隙。 可以将21-3×3 = 12个暗角正方形任意插入这些空隙中以形成特定的图案。 可以通过将这些黑色正方形放置在将单个白色正方形视为分隔线的线上来计算分配这些黑色正方形的方式数量。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/373/160/0fb/3731600fb90642ff32fa58ee059cf4c3.gif"></div><br> 因此，将任务简化为计算多项式系数的值。 查看这些白色正方形，您可以理解，这是选择15种方法中的3种方法的问题。 <img src="https://habrastorage.org/getpro/habr/post_images/5d4/344/bdb/5d4344bdb66112361fa655447baff0a3.png">  = 455。 <br><br> 在一般情况下，对于<i>n</i>等于 <img src="https://habrastorage.org/getpro/habr/post_images/f0d/252/47d/f0d25247d7defed1af6417ed76660ba6.png">  。 但是实际上，由于镜像对称，它们的数量只有后者的一半。 如果数量是奇数，然后除以2，我们将四舍五入到最接近的整数，以在其中包含一个理想对称的模式，该模式应该存在于该集合中，例如，对于455，如下所示。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e6/093/98d/5e609398dfe585680459774fc3b96cdc.gif"></div><br> 将这个公式应用于7个四氨基，我们确认了一个明显的事实：只有一个模式可以创建7个正方形。 <br><br> 创建6个正方形的模式可以通过两种方式构建：两条实线（2×21 + 6 = 48）和六条实线（6×21 + 6 = 132），这需要12和33个四氨基。 上面的公式显示，有84种模式可创建6个正方形，但仅能用2条完整的线条构建其中的35种。  49个图案需要6线。 由于下面显示的对称图案，所以数字是奇数。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c07/fe9/a24/c07fe9a243e3cdfe37103d4f16d01024.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a9/8c5/91b/8a98c591b95b4fc8a533e67adead58ad.gif"></div><br> 还值得注意的是，这里可以使用2条线，因为与创建一个需要四氨基S和Z的正方形的图案相反，在这些图案中使用了6个数字。 <br><br> 下表显示了每种图案类型创建的正方形数，完整线数，所使用的四氨基数量和图案数。 <br><br><div class="scrollable-table"><table><tbody><tr><th> 创建正方形 </th><th> 全线 </th><th> 四氨基 </th><th> 模式 </th></tr><tr><td>  1个 </td><td>  7和3 </td><td>  37和16 </td><td>  19（4和15） </td></tr><tr><td>  2 </td><td>  6 </td><td>  32 </td><td>  136 </td></tr><tr><td>  3 </td><td>  5 </td><td>  27 </td><td>  455 </td></tr><tr><td>  4 </td><td>  4 </td><td>  22 </td><td>  715 </td></tr><tr><td>  5 </td><td>  3 </td><td>  17 </td><td>  462 </td></tr><tr><td>  6 </td><td>  2和6 </td><td>  12和33 </td><td>  84（35和49） </td></tr><tr><td>  7 </td><td>  1个 </td><td>  7 </td><td>  1个 </td></tr></tbody></table></div><br> 模式的例子。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/569/9dc/055/5699dc0558af1a833b43b57defdefbf7.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d1/b83/682/1d1b83682d599094bcb138958706b8bf.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/efd/510/bbb/efd510bbb099696e35b7e0b9156f35d4.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/079/bd5/d7a/079bd5d7a149568bda463270a5b3baaf.gif"></div><br><h2> 平台类 </h2><br> 在构造线之前，算法会检查其下方的线。 如果底行无法为其上方的所有方块提供支撑，则需要一个临时平台。 卸下平台后，一条新的线下降，并且由于原始Tetris中的重力实现方式，一些正方形仍然悬在空中。 <br><br> 下图显示了10种平台模式。 平台的构建从降低最后一条生成的线的一个正方形的顶部上的四氨基T开始。 其余的四氨基依赖于该第一个T。也就是说，如果先前生成的线包含至少1个正方形，例如下图中的红色正方形，我们可以在其上方创建一个平坦平台以生成下一行。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b0/299/e1d/5b0299e1d7f2916a802a49ea11c4eb16.gif"></div><br> 在构建平台的中间，完成并删除了底行，在其上方保留了三行。 在创建模式在平台顶部生成下一个精灵行之前，不会插入将删除这些行的最后一个四氨基J或L。 最后一个数字可防止在前两行中创建正方形。 但是，如上所述，由于此过程中使用的四氨基J，T和L的几何形状，用于创建正方形的图案仅限于17个内部列。 <br><br> 此外，在Tetramino T之上构建平台的19种可能方法中，上面仅显示了10种。 <br><br><h2> 打包矩阵 </h2><br> 如上所述，6个正方形创建模式的一个子集仅涉及清除两条线。 所有其他样式需要6行。 要了解为什么会这样，请考虑以下模式。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/370/9bf/3aa/3709bf3aa8fd860b3dbcc04014dfef8b.gif"></div><br> 这些四氨基可与四氨基J和L互换，并且每个都向公共行添加3个相邻的正方形。 要完成的行由下面显示的矩阵表示。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ed/532/67a/3ed53267a1b216691289f68439470301.gif"></div><br> 现在整个事情是用四氨基填充空白空间。 从左侧开始，唯一的选择是使用tetramino I序列。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/779/b54/9f5/779b549f51bef09e54217790f2110eb5.gif"></div><br> 填充剩余空间的唯一方法是使用J和O或I和L。这两个选项如下所示。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de8/08e/33a/de808e33aa8f69d807c60b798e8ed0c1.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aec/a24/be8/aeca24be817f0cc88dc0ef3175ada63c.gif"></div><br> 不幸的是，上面显示的矩阵不支持四氨基O和L。 这个6平方的图案需要更大的矩阵。 <br><br> 在创建一个正方形的两种模式中也会出现类似的问题。 考虑下面的矩阵： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fba/ec4/6ad/fbaec46ad778d94b5844c22d35ebc4ed.gif"></div><br> 填充右边最底行的唯一方法是链接序列Z。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e8/3e1/5b2/5e83e15b210424010966f17b2ee1b72c.gif"></div><br> 同样，在左下角获得3个空正方形的唯一方法是tetraminoS。 <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/297/9ae/b51/2979aeb51a67c1c0a51c7e5105890744.gif"></div><br> 中线的S和Z之间有一个空的正方形，填充它的唯一方法是使用tetramino J，T或L，如下图所示。 <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a0/364/433/2a036443351a7c1ec90fe0d534c38049.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f3/f88/7e8/8f3f887e84bcdbd7176b530af8757666.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e3c/dc1/a0a/e3cdc1a0a243388524f4e5ffb8ac13d8.gif"></div><br> 插入这些形状中的任何一个都会分隔空格。 左侧的空白区域分别包含5、6和7个空白。 由于这些值均不能被4整除，因此无法继续。 该单个正方形图案需要更大的矩阵。 <br><br> 如下图所示，这同样适用于创建一个正方形的另一种模式。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd3/c11/c6c/fd3c11c6ce8d7e4b60a257486caef4e2.gif"></div><br> 用四氨基S和Z填充大部分底线后，中间的线之间没有空隙。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a6/e39/49c/3a6e3949c8f9f0849921a11ccf54596a.gif"></div><br> 如下图所示，孔镶块划分出空白区域，左侧的空白区域分别包含9、10或11个正方形。 没有一个数字可以被4整除。 <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15d/d8b/9b2/15dd8b9b24d8054598665cbff061344e.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d6/928/f4d/6d6928f4d884b746af74059ec210b96d.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c5/269/800/0c5269800d3ebdcb62e1131c03e32db0.gif"></div><br> 但是，打包矩阵并不是生成正方形图案的唯一方法。 例如，看看下面的4个正方形创建者。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4fc/22b/653/4fc22b6538117dca3baff88c595337e4.gif"></div><br> 以下是尝试将图案呈现为一组包装的丁胺酮的尝试。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3f5/53f/bfc/3f553fbfc96ecfbbef8f7304c80a80fe.gif"></div><br> 跳过最后一个L，因为仅在完成和删除第三行之后才形成最后一个L的空间。 <br><br> 但是经过彻底的搜索，发现该技术不能为上述的单正方形图案提供仅使用3条线的功能。 此外，它不允许在两行中实现任何新的6平方的模式。 无需在打包矩阵之外查找剩余的模式，因为它们已经使用了最小量的四氨基。 并且将自己限制在打包矩阵中，我们将更快地找到所有必需的模式。 <br><br><h2> 模式搜索 </h2><br> 为了简化数据输出，“俄罗斯方块打印机算法”仅限于在运动场的顶部中心点创建四氨基，然后旋转，水平移动并降低它。 经过一段距离后，他再也不必水平移动图形了。 这种限制大大减少了搜索空间，因为它不允许在添加到矩阵的图形下形成间隙。 作为示例，让我们看下面的3个方阵。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/466/4d1/250/4664d1250708c9d9daeb800eb2ac7f47.gif"></div><br> 如果我们将J放在矩阵的中心，如上所示，那么我们将得到2个空方格的间隙，无法用后续图形填充。 因此，搜索将不会遵循此路径。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/562/934/866/56293486665cf1557d513f63fa700622.gif"></div><br> 由于不允许覆盖间隙，因此矩阵中的每一列都可以视为一堆实心正方形，并且这些堆叠的高度充分描述了整个矩阵的内容。 无论行数如何，具有21个元素的一维整数数组都足以描述二维矩阵。 <br><br> 当图形落入矩阵中时，相应列的堆栈高度会增加。 为了加速这一过程，所有四胺都需要预先分析。 有19个四米诺米级转弯，搜索将它们视为一个唯一的图形。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/40e/d13/9e0/40ed139e0a5612cac1f5d074a0093d96.png"></div><br> 图像左上角的Tetramino J占据3列。 当降低到矩阵上时，3个相邻堆栈的高度分别增加1、1、2个正方形。 但是在降低图形之前，图形的下部轮廓必须对应于各个堆叠的上部轮廓。 如果这个J躺在运动场的地板上，则在这些列的每一列下应该有1个，1个和0个空正方形的间隙。 由于禁止间隙，因此3叠的相对高度必须完全匹配该图案。 <br><br> 缺少间隙的另一个结果是，当图形落入矩阵时，行从下至上填充。 在矩阵中部之前或同时未完成其下所有行的情况下，无法填充行。 在填充矩阵的过程中，其下边界实际上向上移动。 因此，矩阵列堆栈只有在其高度减去已完成的行数大于0时才能提供支持。将形状添加到矩阵时，至少一个相应的列必须提供支持。 <br><br> 搜索存储第二个一维数组，该数组包含每行中已填充正方形的数量。 上面的J在相应的线3和1中包含一个正方形。 将其插入矩阵时，这些值将添加到数组的相应元素中。 已完成的行数是值为21的元素数。 <br><br> 如上一节所述，如果添加的图将矩阵除，则结果区域的大小应除以4。例如，在下图中，添加I创建2个区域，每个区域包含46个空正方形。 由于46不能被4整除，因此不再有任何方法可以填充矩阵的其余部分。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0d/c1e/91a/c0dc1e91a707d5b2fea279dd5c370ec4.gif"></div><br> 当堆栈的高度等于矩阵的高度时，出现分离。 通过增加相应堆栈的高度插入图形后，可以通过扫描高度数组并将每个堆栈中剩余的空间相加来确定空白区域的所有划分区域的尺寸。 检测到拆分后，将检查并重置此编号。 <br><br> 用于生成所有模式的搜索使用随机增量构造，这是一种以随机顺序系统地检查所有组合的回溯算法。 通过随机插入形状来递增构造溶液，使其像晶体一样生长。 随机性提供了包含断面的不规则性，这些断面用作后续添加形状的基础。 大多数矩阵都非常快速地随机打包，并且当空白空间变得稀缺时，回溯就起作用了。 <br><br> 在执行搜索之前，执行将图形添加到矩阵的371种方式的随机排列。 搜索功能的伪代码如下所示。 <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">search</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Matrix matrix, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> remaining)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (remaining == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SOLUTION } attempts := attempts + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (attempts &gt;= MAX_ATTEMPTS) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TIMEOUT } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (     S  Z) {        S  Z <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (  ) { Result result := search(matrix, remaining - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result == SOLUTION) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SOLUTION }       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result == TIMEOUT) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TIMEOUT } } }          <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(   ,    ) {      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (   ) { Result result := search(matrix, remaining - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result == SOLUTION) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SOLUTION }       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result == TIMEOUT) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TIMEOUT } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NO_SOLUTION }</code> </pre> <br> 传递给搜索函数的原始矩阵为空，但最下面一行包含3个相邻正方形的块除外。 它与需要添加的剩余图形数一起发送。 如果<code>remaining</code>为0，则矩阵包含解，函数返回。 每个递归调用都会增加尝试的全局尝试<code>attempts</code> 。 如果它超过<code>MAX_ATTEMPTS</code> （其值为1000），那么搜索将再次开始。 <br><br> 如果空间允许，第三个<code>if</code>尝试将四氨基S或Z添加到矩阵的底部。 这样做的意思是避免出现如下所示的情况，即当算法花时间填充矩阵的一部分时，由于缺乏支持而无法填充其余部分。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36d/3f9/b81/36d3f9b81275718dccb5d40e70d7843b.gif"></div><br> 感谢<code>if</code>它迅速形成了一个构建平台： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d0/aa1/ed7/1d0aa1ed7c08ed07b3f31e22ab92ea42.gif"></div><br> 尝试将图形添加到矩阵，需要进行上述检查。 给定已完成的行，该算法将检查图形是否将得到支持。 它还检查是否将其除以因插入形状而创建的每个独立空白空间的大小4。 <br><br><h2> 影像转换 </h2><br> 俄罗斯方块打印机算法将位图的每一行转换为一系列遍。 从左向右移动，每个段落以“贪婪”的方式将四氨基J，T和L插入到放置它们的位置。 例如，下图显示了位图的16个像素行。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c1/4c5/b69/9c14c5b69ae9a4599ee0856a250256a8.gif"></div><br> 下图显示了覆盖这16个像素所需的5次通过。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/989/f7d/760/989f7d76010dd0d7e523361148e0e323.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c4/920/25a/4c492025a6033a3eda85fd240118b657.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f1/44f/373/0f144f3734988b25dd231a1a445c52fd.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c1/e37/392/6c1e373927f4842ad379ff2b6c42b123.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9a/64b/222/a9a64b222baaf24ed13674bdac9b8d01.gif"></div><br> 算法尝试插入的形状顺序由像素的颜色确定。 为了使形状不重叠，使用了布尔值的一维数组。 要插入图形，数组中必须存在3个零元素。 成功插入图3后，相应的数组元素取值为1。 <br><br> 为了跟踪多遍之间的完成像素，使用了第二个一维布尔值数组。 当每个项目为1时，该行将完成。 <br><br> 在每次扫描结束时，图像转换器都会在表格中搜索所有用于创建一个或多个正方形的图案。 在输出中，它传递了相应的图案，底部插入了四氨基J，T和L，例如，上面显示的第一遍显示为以下用于创建5个正方形的图案： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c67/b1b/377/c67b1b3778a37bf7008438052679942e.gif"></div><br><h2> 即时搜寻 </h2><br> 上一节中描述的图像转换器非常快，因为它使用包含所有用于创建正方形的图案的常量表，并且不会实时搜索它们。 但是，实时搜索可以使用表中未包含的模式，因此可以大大减少生成图像所需的四氨基酚数量。 他使用先前段落中创建的正方形，将它们用作辅助支撑。 例如，如上所述，以下用于创建一个正方形的模式需要7条实线。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ee/0b4/889/9ee0b488962c79ad6c84255efd033b5d.gif"></div><br> 但是，在下图的左下角的上一个段落中创建的一个红色正方形提供了额外的支持，从而将实线的数量减少到了3。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dfa/d3e/271/dfad3e271c5623daedc462821b82b8af.gif"></div><br> 此外，通过翻转四氨基J，T或L，实时搜索可以覆盖3个相邻的相同颜色的像素。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a31/e09/776/a31e097766437cb13ebde1e35ee66453.gif"></div><br> 实际上，它可以结合反向和反向四氨基，一次通过覆盖大量像素。 例如，可以将覆盖16个像素的上述5次通过减少为以下所示的单次通过。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64c/653/c31/64c653c31d38daeef85189e3b2eacaa8.gif"></div><br> 为了获得此图案，图像转换器首先急切包装上翘的四氨基J，T和L。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7a/e98/67e/e7ae9867e1419492f6f19f6816d18f04.gif"></div><br> 然后，他急切地尝试添加未翻转的版本，在这种情况下，他设法添加了另一个J。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba2/4f3/1d4/ba24f31d49baa855fc449c3cf98f09ca.gif"></div><br> 原则上，在此过程中也可以使用预先计算的查找表，但是这种表的绝对大小使其在实践中不适用。 <br><br> 在此示例中，将要创建的行上方的行中的8个正方形添加到空矩阵的底部行。 对于21平方英尺宽的运动场上的<i>n个</i>正方形，矩阵<i>h</i>的高度是最小的正整数，因此<i>21h-n</i>可被4整除。在这种情况下，需要高度为4的矩阵。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b2a/c2e/d2b/b2ac2ed2bc3a422d0d94fff2b10bf9e0.gif"></div><br> 实时搜索的工作方式与上述搜索算法完全相同，但有较小的改进。 和以前一样，矩阵列堆栈仅在列高减去已完成的行数大于零时才提供支持。 当差异为零时，列堆栈不应提供支持。 但是，在此版本中，如果它等于零，它将检查由先前遍次生成的所创建行中的平方。 也就是说，矩阵底部行下方的行中的任何正方形都为空列提供支持。 <br><br> 另外，由于搜索是实时执行的，因此使其详尽无遗。 如果在给定的尝试次数后仍未找到解决方案，则他将在矩阵顶部再添加4行，然后再次尝试。 此后，如果在给定的尝试次数之后他仍然找不到解决方案，那么在当前段落中，他将返回本文前面部分介绍的带有预先计算的搜索表和图像转换的方法。 <br><br><h2> 列印 </h2><br> 要进行打印，您必须遵循Tetris运动场上图像转换器显示的说明。 打印机以标准方向在运动场的顶部中心点创建特定的丁胺。 然后打印机旋转它，水平移动它并放下它。 视频中显示了此过程： <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/PJkHwulsac4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2> 源代码 </h2><br>  Java 7项目的源代码在<a href="">此处</a> 。 <br><br> 包<code>search.precomputed</code>和<code>search.realtime</code>中提供了用于预先准备的表和实时的搜索算法。 他们使用位于<code>search</code>包中的一些通用类。 预先计算的搜索结果以文本文件序列的<code>patterns</code>存储在<code>patterns</code>包中。 文本文件将打包的矩阵以ASCII字符存储，以<code>A</code>开头<code>A</code> 例如， <code>emitters1.txt</code> （用于创建一个正方形的一组模式）中的前三个矩阵如下所示： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lv/yo/mo/lvyomov6ld5rle3bqj1jnjegic4.png"></div><br> 如文章中反复所述，上述矩阵中的3个相邻的<code>A</code>符号可以用四氨基J，T或L代替。符号<code>B</code> ， <code>C</code> ， <code>D</code>等表示您需要创建的四氨基序列。 <br><br>  <code>imageconverter.ImageConverter</code>类包含<code>main</code>方法，该方法接收一个命令行参数：图像精灵文件的名称。 图片不能大于17×32像素，并且不能包含3种以上的不透明颜色。 所有其他像素必须是透明的。 <br><br> 有趣的是，在旧的视频游戏中，开发人员经常使用背景来获得额外的颜色。 例如，Bubble泡泡的气泡的学生和嘴巴，Donkey Kong的Donkey Kong的学生和Pakman小姐的mole鼠的眉毛。 吃豆人实际上是透明的。 黑色来自纯色背景。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3fe/67d/330/3fe67d330fce92bff0b4595902e5f5bb.png"></div><br> 俄罗斯方块运动场的背景可以类似的方式使用。 <br><br>  <code>ImageConverter</code>输出如下所示： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rs/vt/ms/rsvtmsq6olz9bm1huiqbqgbouj4.png"></div><br> 第一行中的3个十六进制值是从子画面图像文件中提取的3种不透明颜色。 它们对应于四氨基J，T和L的颜色。其他四氨基的颜色不影响图像。 其余的块是在游戏场上执行的打包模式（对于<code>Z</code>之后至<code>a</code> <a href="">的字符</a> <code>a</code>请参见<a href="">ASCII字符表</a> ）。 突出显示的黄色块构成了平台。 第一块添加平台，第二块删除平台。 <br><br>  <code>printer.Printer</code>类接收这种格式的文本文件，并通过播放Tetris生成图像文件。 <br><br> 用于生成类似于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">俄罗斯方块</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NES版本的</a>视频的打印机算法在文本文件的每个块中定义了每种丁胺醇类型。 然后它以相反的顺序从起点和初始方向移动到文件中指示的图形的旋转角度和下降坐标。 注意：由于数字下降的速度非常快，在真正的NES版本的俄罗斯方块中不可能超过30级。 假定打印机足够快地将其所有命令传输到运动场。 为了弥补这一点。 <br><br> 要重新生成特征码文件，请使用<code>search.precomputed.PatternSearcher</code> 。 可以通过更改源代码文件开头的常量来自定义。 <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MATRIX_WIDTH = <span class="hljs-number"><span class="hljs-number">21</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MATRIX_HEIGHT = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> EMITTED_SQUARES = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> RANDOM_SETS = <span class="hljs-number"><span class="hljs-number">100000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MAX_ATTEMPTS = <span class="hljs-number"><span class="hljs-number">1000</span></span>;</code> </pre> <br>  <code>RANDOM_SETS</code>是将图形添加到矩阵的371种方式的随机排列数。 设置为<code>100000</code> ，在启动时初始化排列需要花费几秒钟的时间。 另外，它们的存储需要超过1 GB的内存。 <br><br>  <code>MAX_ATTEMPTS</code>控制搜索的执行时间。 相对较小的值<code>1000</code>可以使搜索快速丢弃无法很好地展现自己的随机起点。 但是，为了证明对于特定的矩阵大小和创建的平方数没有解决方案，有必要充分探索整个搜索空间。 为此，您可以将<code>MAX_ATTEMPTS</code>设置为<code>Integer.MAX_VALUE</code> 。 <br><br> 在图像转换器使用的<code>search.realtime.RealtimeSearcher</code>可以找到类似的常量。 如上所述，较大的<code>RANDOM_SETS</code>值需要增加最大内存，并导致启动时间更长。  <code>MAX_RETRIES</code>控制尝试次数，之后实时搜索放弃并返回带有预先计算表的搜索。 <br><br> 请记住，两种搜索算法都使用100％的CPU，从而创建了许多并行线程，这些线程的大小等于可用处理器的数量。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2d/8b9/bd5/c2d8b9bd50fd64a3a7e739d51201c880.png"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN474848/">https://habr.com/ru/post/zh-CN474848/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN474838/index.html">SIBUR挑战赛2019-工业数据分析竞赛</a></li>
<li><a href="../zh-CN474840/index.html">他们在外国大学的数据科学专业学习什么</a></li>
<li><a href="../zh-CN474842/index.html">案例：汽车服务。 开展广告活动并实施Bitrix24</a></li>
<li><a href="../zh-CN474844/index.html">Dell XPS 13 7390：非常紧凑的笔记本电脑，适合经常在办公室外工作的人们使用</a></li>
<li><a href="../zh-CN474846/index.html">从垃圾中清理世界河流的计划</a></li>
<li><a href="../zh-CN474850/index.html">Google对AI的量子赌注及其对全人类的意义</a></li>
<li><a href="../zh-CN474852/index.html">EcmaScript中的词法环境和闭包</a></li>
<li><a href="../zh-CN474854/index.html">触发电子邮件-如何吸引观众</a></li>
<li><a href="../zh-CN474856/index.html">内容本地化策略</a></li>
<li><a href="../zh-CN474858/index.html">您需要了解的有关Red Hat OpenShift Service Mesh的知识</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>