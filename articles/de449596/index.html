<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèª‚ÄçüöÄ ‚è¨ ‚§¥Ô∏è Einfaches SFML-Spiel üêøÔ∏è üï¥üèæ üë®üèæ‚Äç‚öñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir werden das Spiel in C ++ mithilfe der SFML-Bibliothek "taggen". F√ºnfzehn ist ein bekanntes Puzzle, das so aussieht: 


 Auf einem 4x4-Spielfeld we...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einfaches SFML-Spiel</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449596/">  Wir werden das Spiel in C ++ mithilfe der SFML-Bibliothek "taggen".  F√ºnfzehn ist ein bekanntes Puzzle, das so aussieht: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7u/hl/by/7uhlbycd1tkovgw_igia0xwklc8.jpeg"></div><br>  Auf einem 4x4-Spielfeld werden 15 W√ºrfel mit Zahlen von 1 bis 15 und ein freier Platz zuf√§llig platziert.  Sie k√∂nnen die W√ºrfel immer nur einzeln und nur an eine leere Stelle bewegen.  Das Ziel des Spiels ist es, W√ºrfel auf dem Spielfeld in der Reihenfolge zu bauen, die ihrer Anzahl entspricht. <br><br>  Also fangen wir an. <br><a name="habracut"></a><br>  Starten Sie Visual Studio und erstellen Sie ein neues leeres Projekt.  Sie k√∂nnen es benennen, was Sie wollen, ich habe "15" genannt.  Erstellen Sie in diesem Projekt eine neue main.cpp-Datei und eine leere Hauptfunktion: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// main.cpp int main() { return 0; }</span></span></code> </pre> <br>  Laden Sie als N√§chstes die SFML-Bibliothek von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sfml-dev.org herunter</a> und entpacken Sie sie.  Die entpackte Bibliothek enth√§lt die Ordner, die wir ben√∂tigen: <b>include</b> , <b>lib</b> und <b>bin</b> .  F√ºgen Sie in den Projekteigenschaften im Abschnitt C / C ++ unter <i>Zus√§tzliche Include-Verzeichnisse</i> den Pfad zum <b>Include-</b> Ordner hinzu: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zd/t8/ky/zdt8kyekzv1txcad5vhycwphdma.png"></div><br>  F√ºgen Sie dort im Abschnitt Linker in <i>Additional Library Directories</i> den Pfad zum <b>lib-</b> Ordner hinzu: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9l/us/lb/9luslb9vhfieeof3lczrjq_85u0.png"></div><br>  Und aus dem <b>bin-</b> Verzeichnis m√ºssen Sie die DLL-Dateien kopieren und in ein Verzeichnis mit der exe-Datei unseres Projekts einf√ºgen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ew/nk/ex/ewnkexitg7y6mvlxwb4fvs2_ums.png"></div><br>  Dar√ºber hinaus m√ºssen Sie im Abschnitt "Linker" und im Abschnitt "Eingabe" die in " <i>Zus√§tzliche Abh√§ngigkeiten"</i> verwendeten Bibliotheksdateien hinzuf√ºgen.  In unserem Fall reicht es aus, drei Dateien hinzuzuf√ºgen: sfml-system-d.lib, sfml-window-d.lib und sfml-graphics-d.lib: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k1/zc/p-/k1zcp-w1_jcbgd8rzy0itmhwe7m.png"></div><br>  Das Symbol <b>-d</b> im Dateinamen bedeutet, dass es sich um eine Debug-Version handelt und in der Debug-Konfiguration verwendet werden sollte.  In den Einstellungen der Release-Version m√ºssen Sie Dateien ohne das Zeichen <b>-d</b> im Namen angeben. <br><br>  Eine gute Anleitung zum Verbinden der SFML-Bibliothek mit dem Visual Studio-Projekt finden Sie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Website der</a> Bibliothek. <br><br>  Versuchen wir nun, die Bibliothek in unserem Projekt zu verwenden.  Erstellen Sie ein Fenster und starten Sie die Ereignisschleife: <br><br><div class="spoiler">  <b class="spoiler_title">main.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// main.cpp #include &lt;SFML/Graphics.hpp&gt; int main() { //    600  600    60    sf::RenderWindow window(sf::VideoMode(600, 600), "15"); window.setFramerateLimit(60); sf::Event event; while (window.isOpen()) { while (window.pollEvent(event)) { if (event.type == sf::Event::Closed) window.close(); if (event.type == sf::Event::KeyPressed) { //    -    if (event.key.code == sf::Keyboard::Escape) window.close(); } } //      window.clear(); window.display(); } return 0; }</span></span></code> </pre> <br></div></div><br>  Das Ergebnis ist ein quadratisches Fenster mit einer Gr√∂√üe von 600 x 600 Pixel und einem schwarzen Hintergrund: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qb/l3/_o/qbl3_op1hp84mtuq5b49c2q1dlc.png"></div><br>  Das Fenster kann wie gewohnt mit der Maus oder √ºber die Esc-Taste geschlossen werden.  Ein Tastatur-Tastendruck-Handler ist ebenfalls in der Nachrichtenverarbeitungsschleife enthalten. <br><br>  Bevor wir zur Sache kommen, ben√∂tigen wir eine Schriftart, um Text auf dem Bildschirm anzuzeigen.  Zum Beispiel habe ich die Schriftart TrueType Calibri verwendet. <br><br>  Jetzt k√∂nnen wir anfangen, unser Spiel zu machen. <br><br>  Erstelle eine neue Spielklasse: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gb/-b/sf/gb-bsf2p5hjalkleyc4s_nm5vso.png"></div><br>  Die Klasse ist f√ºr den Betrieb des Spiels und das Rendern des Spielfelds verantwortlich.  Dazu erben wir unsere Klasse von den Klassen Drawable und Transformable der SFML-Bibliothek. <br><br>  Also fangen wir an, unsere Klasse zu beschreiben <br><br><div class="spoiler">  <b class="spoiler_title">Game.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;SFML/Graphics.hpp&gt; const int SIZE = 4; //      const int ARRAY_SIZE = SIZE * SIZE; //   const int FIELD_SIZE = 500; //      const int CELL_SIZE = 120; //     enum class Direction { Left = 0, Right = 1, Up = 2, Down = 3 }; class Game : public sf::Drawable, public sf::Transformable { protected: int elements[ARRAY_SIZE]; int empty_index; bool solved; sf::Font font; public: Game(); void Init(); bool Check(); void Move(Direction direction); public: virtual void draw(sf::RenderTarget&amp; target, sf::RenderStates states) const; };</span></span></span></span></code> </pre><br></div></div><br>  Zuerst verbinden wir die Grafikbibliothek: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;SFML/Graphics.hpp&gt;</span></span></span></span></code> </pre> <br>  Hier deklarieren wir einige Konstanten, die f√ºr das Spiel erforderlich sind: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SIZE = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      const int ARRAY_SIZE = SIZE * SIZE; //    const int FIELD_SIZE = 500; //      const int CELL_SIZE = 120; //    </span></span></code> </pre> <br>  Wir deklarieren auch unseren Typ enum, der die Bewegungsrichtung der Platte bestimmt: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Direction</span></span></span><span class="hljs-class"> {</span></span> Left = <span class="hljs-number"><span class="hljs-number">0</span></span>, Right = <span class="hljs-number"><span class="hljs-number">1</span></span>, Up = <span class="hljs-number"><span class="hljs-number">2</span></span>, Down = <span class="hljs-number"><span class="hljs-number">3</span></span> };</code> </pre> <br>  Und schlie√ülich die Klasse selbst: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Game</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sf::Drawable, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sf::Transformable { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elements[ARRAY_SIZE]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> empty_index; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> solved; sf::Font font; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Game(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Move</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Direction direction)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sf::RenderTarget&amp; target, sf::RenderStates states)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; };</code> </pre> <br>  Das Wichtigste, was wir darin haben, ist ein Array von Elementen, die ganzzahlige Werte enthalten, die dem Zustand des Spielfelds entsprechen.  Die Elemente im Array entsprechen den Elementen des Spielfelds von links nach rechts, von oben nach unten, dh die ersten 4 Elemente des Arrays entsprechen der ersten Zeile des Feldes, die zweiten 4 Elemente der zweiten Zeile usw. <br><br>  Als n√§chstes werden zwei Variablen, die bei jeder Bewegung berechnet werden, <b>leer_index</b> (ein Index im Array, der einer freien Zelle entspricht) und <b>gel√∂st</b> (ein Zeichen daf√ºr, dass das R√§tsel gel√∂st ist). <br><br>  Dar√ºber hinaus wird die Schriftvariable in der Klasse festgelegt, die die Schriftart festlegt, die beim Anzeigen von Text im Fenster verwendet wird. <br><br>  Jetzt werden wir die Implementierung der Methoden unserer Klasse schreiben. <br><br><div class="spoiler">  <b class="spoiler_title">Game.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Game.h"</span></span></span><span class="hljs-meta"> Game::Game() { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//      font.loadFromFile("calibri.ttf"); Init(); } void Game::Init() { //    for (int i = 0; i &lt; ARRAY_SIZE - 1; i++) elements[i] = i + 1; //        empty_index = ARRAY_SIZE - 1; elements[empty_index] = 0; //     = 0 solved = true; } bool Game::Check() { //    for (unsigned int i = 0; i &lt; ARRAY_SIZE; i++) { if (elements[i] &gt; 0 &amp;&amp; elements[i] != i + 1) return false; } return true; } void Game::Move(Direction direction) { //       int col = empty_index % SIZE; int row = empty_index / SIZE; //          int move_index = -1; if (direction == Direction::Left &amp;&amp; col &lt; (SIZE - 1)) move_index = empty_index + 1; if (direction == Direction::Right &amp;&amp; col &gt; 0) move_index = empty_index - 1; if (direction == Direction::Up &amp;&amp; row &lt; (SIZE - 1)) move_index = empty_index + SIZE; if (direction == Direction::Down &amp;&amp; row &gt; 0) move_index = empty_index - SIZE; //      if (empty_index &gt;= 0 &amp;&amp; move_index &gt;= 0) { int tmp = elements[empty_index]; elements[empty_index] = elements[move_index]; elements[move_index] = tmp; empty_index = move_index; } solved = Check(); } void Game::draw(sf::RenderTarget&amp; target, sf::RenderStates states) const { states.transform *= getTransform(); sf::Color color = sf::Color(200, 100, 200); //     sf::RectangleShape shape(sf::Vector2f(FIELD_SIZE, FIELD_SIZE)); shape.setOutlineThickness(2.f); shape.setOutlineColor(color); shape.setFillColor(sf::Color::Transparent); target.draw(shape, states); //       shape.setSize(sf::Vector2f(CELL_SIZE - 2, CELL_SIZE - 2)); shape.setOutlineThickness(2.f); shape.setOutlineColor(color); shape.setFillColor(sf::Color::Transparent); //        sf::Text text("", font, 52); for (unsigned int i = 0; i &lt; ARRAY_SIZE; i++) { shape.setOutlineColor(color); text.setFillColor(color); text.setString(std::to_string(elements[i])); if (solved) { //      shape.setOutlineColor(sf::Color::Cyan); text.setFillColor(sf::Color::Cyan); } else if (elements[i] == i + 1) { //        text.setFillColor(sf::Color::Green); } //   ,   if (elements[i] &gt; 0) { //      sf::Vector2f position(i % SIZE * CELL_SIZE + 10.f, i / SIZE * CELL_SIZE + 10.f); shape.setPosition(position); //     text.setPosition(position.x + 30.f + (elements[i] &lt; 10 ? 15.f : 0.f), position.y + 25.f); target.draw(shape, states); target.draw(text, states); } } }</span></span></span></span></code> </pre><br></div></div><br>  Der Klassenkonstruktor l√§dt die Schriftart aus der externen Datei und ruft die Spielinitialisierungsmethode auf: <br><br><pre> <code class="cpp hljs">Game::Game() { <span class="hljs-comment"><span class="hljs-comment">//      font.loadFromFile("calibri.ttf"); Init(); }</span></span></code> </pre> <br>  Die Spielinitialisierungsmethode f√ºllt das Array mit Elementen in der richtigen Reihenfolge und setzt das Vorzeichen des gel√∂sten Puzzles: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Game::Init() { <span class="hljs-comment"><span class="hljs-comment">//    for (int i = 0; i &lt; ARRAY_SIZE - 1; i++) elements[i] = i + 1; //   -     empty_index = ARRAY_SIZE - 1; elements[empty_index] = 0; //     = 0 solved = true; }</span></span></code> </pre> <br>  Ja, zun√§chst wird das Spiel als gel√∂st initialisiert, und vor Spielbeginn werden die W√ºrfel mit zuf√§lligen Z√ºgen gemischt. <br><br>  Die folgende Methode pr√ºft, ob das R√§tsel gel√∂st ist, und gibt das Ergebnis der Pr√ºfung zur√ºck: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Game::Check() { <span class="hljs-comment"><span class="hljs-comment">//    for (unsigned int i = 0; i &lt; ARRAY_SIZE; i++) { if (elements[i] &gt; 0 &amp;&amp; elements[i] != i + 1) return false; } return true; }</span></span></code> </pre> <br>  Und schlie√ülich eine Methode, die Plattenbewegungen in einem Spiel implementiert: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Game::Move(Direction direction) { <span class="hljs-comment"><span class="hljs-comment">//       int col = empty_index % SIZE; int row = empty_index / SIZE; //          int move_index = -1; if (direction == Direction::Left &amp;&amp; col &lt; (SIZE - 1)) move_index = empty_index + 1; if (direction == Direction::Right &amp;&amp; col &gt; 0) move_index = empty_index - 1; if (direction == Direction::Up &amp;&amp; row &lt; (SIZE - 1)) move_index = empty_index + SIZE; if (direction == Direction::Down &amp;&amp; row &gt; 0) move_index = empty_index - SIZE; //      if (empty_index &gt;= 0 &amp;&amp; move_index &gt;= 0) { int tmp = elements[empty_index]; elements[empty_index] = elements[move_index]; elements[move_index] = tmp; empty_index = move_index; } solved = Check(); }</span></span></code> </pre> <br>  Die letzte Methode der Klasse ist die Methode, die das Spielfeld zeichnet: <br><br><div class="spoiler">  <b class="spoiler_title">zeichnen</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Game::draw(sf::RenderTarget&amp; target, sf::RenderStates states) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { states.transform *= getTransform(); sf::Color color = sf::Color(<span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>); <span class="hljs-comment"><span class="hljs-comment">//     sf::RectangleShape shape(sf::Vector2f(FIELD_SIZE, FIELD_SIZE)); shape.setOutlineThickness(2.f); shape.setOutlineColor(color); shape.setFillColor(sf::Color::Transparent); target.draw(shape, states); //       shape.setSize(sf::Vector2f(CELL_SIZE - 2, CELL_SIZE - 2)); shape.setOutlineThickness(2.f); shape.setOutlineColor(color); shape.setFillColor(sf::Color::Transparent); //        sf::Text text("", font, 52); for (unsigned int i = 0; i &lt; ARRAY_SIZE; i++) { shape.setOutlineColor(color); text.setFillColor(color); text.setString(std::to_string(elements[i])); if (solved) { //      shape.setOutlineColor(sf::Color::Cyan); text.setFillColor(sf::Color::Cyan); } else if (elements[i] == i + 1) { //        text.setFillColor(sf::Color::Green); } //   ,   if (elements[i] &gt; 0) { //      sf::Vector2f position(i % SIZE * CELL_SIZE + 10.f, i / SIZE * CELL_SIZE + 10.f); shape.setPosition(position); //     text.setPosition(position.x + 30.f + (elements[i] &lt; 10 ? 15.f : 0.f), position.y + 25.f); //    target.draw(shape, states); //    target.draw(text, states); } } }</span></span></code> </pre> <br></div></div><br>  Bei der Rendering-Methode verwenden wir als erstes die Koordinatentransformation durch Multiplikation mit der Transformationsmatrix.  Dies ist notwendig, um die Koordinaten unseres Spielfeldes einstellen zu k√∂nnen.  Zeichnen Sie als N√§chstes mithilfe der RectangleShape-Objekte der SFML-Bibliothek die R√§nder des Spielfelds und die R√§nder jedes W√ºrfels im Spiel.  Auf die W√ºrfel zeichnen wir auch den Text mit der Kennzeichen.  Wenn das R√§tsel gel√∂st ist, wird die Farbe der W√ºrfel au√üerdem anders ausgef√ºhrt. <br><br>  Es ist Zeit, zur Hauptfunktion zur√ºckzukehren: <br><br><div class="spoiler">  <b class="spoiler_title">main.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// main.cpp #include &lt;SFML/Graphics.hpp&gt; #include "Game.h" int main() { //    600  600    60    sf::RenderWindow window(sf::VideoMode(600, 600), "15"); window.setFramerateLimit(60); sf::Font font; font.loadFromFile("calibri.ttf"); //     sf::Text text("F2 - New Game / Esc - Exit / Arrow Keys - Move Tile", font, 20); text.setFillColor(sf::Color::Cyan); text.setPosition(5.f, 5.f); //    Game game; game.setPosition(50.f, 50.f); sf::Event event; int move_counter = 0; //       while (window.isOpen()) { while (window.pollEvent(event)) { if (event.type == sf::Event::Closed) window.close(); if (event.type == sf::Event::KeyPressed) { //    -    if (event.key.code == sf::Keyboard::Escape) window.close(); if (event.key.code == sf::Keyboard::Left) game.Move(Direction::Left); if (event.key.code == sf::Keyboard::Right) game.Move(Direction::Right); if (event.key.code == sf::Keyboard::Up) game.Move(Direction::Up); if (event.key.code == sf::Keyboard::Down) game.Move(Direction::Down); //   if (event.key.code == sf::Keyboard::F2) { game.Init(); move_counter = 100; } } } //     ,    if (move_counter-- &gt; 0) game.Move((Direction)(rand() % 4)); //      window.clear(); window.draw(game); window.draw(text); window.display(); } return 0; }</span></span></code> </pre> <br></div></div><br>  Laden Sie zun√§chst die Schriftart und erstellen Sie ein Textobjekt, um eine Textzeile mit der Zuweisung von Schl√ºsseln anzuzeigen.  Als n√§chstes erstellen Sie unser Spielobjekt und setzen die Position des Feldes auf einen Punkt mit Koordinaten (50,50) - so r√ºcken wir vom Rand des Fensters ein. <br><br>  Ich habe beschlossen, das Spiel √ºber die Tastatur zu steuern. Bei jedem Dr√ºcken der Pfeiltasten rufen wir die Move-Methode f√ºr das Spielobjekt auf, um die Platte in die entsprechende Richtung zu bewegen. <br><br>  Das Dr√ºcken der Taste F2 ist der Beginn eines neuen Spiels. Im Handler dieses Ereignisses initialisieren wir das Spiel neu (was dazu f√ºhrt, dass W√ºrfel an ihren Stellen platziert werden) und setzen den Wert des Z√§hlers f√ºr Z√ºge auf 100. Dieser Z√§hler wird weiter verwendet, um Z√ºge in zuf√§llige Richtungen auszuf√ºhren, bis wird nicht zur√ºckgesetzt und die W√ºrfel mischen sich nicht.  Somit werden wir definitiv den gel√∂sten Zustand des Puzzles bekommen. <br><br>  Das ist im Grunde alles, kompilieren, zusammenbauen, ausf√ºhren: <br><br><img src="https://habrastorage.org/webt/p0/ne/rg/p0nerg896fzcjdv2rwaqy47kr7m.png"><img src="https://habrastorage.org/webt/8s/c5/pc/8sc5pcprcxdaplxgekluevknn4c.png"><br><br>  In diesem Artikel habe ich gezeigt, wie Sie mit der SFML-Bibliothek schnell ein einfaches C ++ - Spiel erstellen k√∂nnen.  Die Architektur des Programms selbst ist jedoch alles andere als ideal.  Im n√§chsten Artikel werden wir versuchen, etwas dagegen zu unternehmen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de449596/">https://habr.com/ru/post/de449596/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de449578/index.html">Die Illusion von intelligentem Design</a></li>
<li><a href="../de449584/index.html">Advantech EKI-2000 Industrial Unmanaged Switches</a></li>
<li><a href="../de449586/index.html">Das schwierige Prinzip der alleinigen Verantwortung</a></li>
<li><a href="../de449588/index.html">Was ist die St√§rke und Schw√§che des Hosting-Marktes</a></li>
<li><a href="../de449590/index.html">Die Marktkapitalisierung von Microsoft betrug mehr als 1 Billion US-Dollar</a></li>
<li><a href="../de449600/index.html">"Smart Home" mit Yandex.Alisa</a></li>
<li><a href="../de449602/index.html">Inspiriert von Produktion und Basketball: Wie Yandex eine Programmiermeisterschaft vorbereitet</a></li>
<li><a href="../de449604/index.html">Wenn neue Technologien wichtiger sind als die Grundlagen: Warum sich das ‚Äûbiegsame‚Äú Samsung Galaxy Fold als Fehlschlag herausstellte</a></li>
<li><a href="../de449606/index.html">Demontage der Shuliavsky-Br√ºcke in Kiew am 19. April</a></li>
<li><a href="../de449608/index.html">Warum Unsch√§rfe vertrauliche Informationen nicht schlecht verbirgt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>