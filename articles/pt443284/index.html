<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•£ üßñ üé• √çndices no PostgreSQL - 4 (Btree) üîâ üêΩ üïû</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="J√° discutimos o mecanismo de indexa√ß√£o do PostgreSQL e a interface dos m√©todos de acesso , bem como o √≠ndice de hash , um dos m√©todos de acesso. Vamos...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√çndices no PostgreSQL - 4 (Btree)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/443284/">  J√° discutimos o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mecanismo de indexa√ß√£o do</a> PostgreSQL e a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">interface dos m√©todos de acesso</a> , bem como o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√≠ndice de hash</a> , um dos m√©todos de acesso.  Vamos agora considerar a √°rvore B, o √≠ndice mais tradicional e amplamente usado.  Este artigo √© grande, portanto, seja paciente. <br><br><h1>  Btree </h1><br><h2>  Estrutura </h2><br>  O tipo de √≠ndice B-tree, implementado como m√©todo de acesso "btree", √© adequado para dados que podem ser classificados.  Em outras palavras, os operadores "maior", "maior ou igual", "menor", "menor ou igual" e "igual" devem ser definidos para o tipo de dados.  Observe que √†s vezes os mesmos dados podem ser classificados de maneira diferente, o que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nos leva de volta</a> ao conceito de fam√≠lia de operadores. <br><a name="habracut"></a><br>  Como sempre, as linhas de √≠ndice da √°rvore B s√£o compactadas em p√°ginas.  Nas p√°ginas folha, essas linhas cont√™m dados a serem indexados (chaves) e refer√™ncias a linhas da tabela (TIDs).  Nas p√°ginas internas, cada linha faz refer√™ncia a uma p√°gina filha do √≠ndice e cont√©m o valor m√≠nimo nessa p√°gina. <br><br>  As √°rvores B t√™m algumas caracter√≠sticas importantes: <br><br><ul><li>  As √°rvores B s√£o balanceadas, ou seja, cada p√°gina de folha √© separada da raiz pelo mesmo n√∫mero de p√°ginas internas.  Portanto, a pesquisa de qualquer valor leva o mesmo tempo. <br></li><li>  As √°rvores B s√£o multi-ramificadas, ou seja, cada p√°gina (geralmente 8 KB) cont√©m muitos TIDs (centenas).  Como resultado, a profundidade das √°rvores B √© bem pequena, na verdade, de 4 a 5 para tabelas muito grandes. <br></li><li>  Os dados no √≠ndice s√£o classificados em ordem n√£o decrescente (entre as p√°ginas e dentro de cada p√°gina) e as p√°ginas do mesmo n√≠vel s√£o conectadas umas √†s outras por uma lista bidirecional.  Portanto, podemos obter um conjunto de dados ordenados apenas por uma lista percorrendo uma ou outra dire√ß√£o sem retornar √† raiz a cada vez. <br></li></ul><br>  Abaixo est√° um exemplo simplificado do √≠ndice em um campo com chaves inteiras. <br><br><img src="https://habrastorage.org/web/2e4/4f4/003/2e44f400317048c78e4cec04ab45e48e.png"><br><br>  A primeira p√°gina do √≠ndice √© uma metap√°gina, que faz refer√™ncia √† raiz do √≠ndice.  Os n√≥s internos est√£o localizados abaixo da raiz e as p√°ginas folha est√£o na linha inferior.  As setas para baixo representam refer√™ncias de n√≥s folha para linhas de tabela (TIDs). <br><br><h3>  Pesquisa por igualdade </h3><br>  Vamos considerar a pesquisa de um valor em uma √°rvore pela condi√ß√£o " <em>indexed-field</em> = <em>expression</em> ".  Digamos, estamos interessados ‚Äã‚Äãna chave de 49. <br><br><img src="https://habrastorage.org/web/9fd/814/c9e/9fd814c9e79443b2a774403a817bf734.png"><br><br>  A pesquisa come√ßa com o n√≥ raiz e precisamos determinar para qual dos n√≥s filhos descer.  Conhecendo as chaves no n√≥ raiz (4, 32, 64), descobrimos, portanto, os intervalos de valores nos n√≥s filhos.  Desde 32 ‚â§ 49 &lt;64, precisamos descer para o segundo n√≥ filho.  Em seguida, o mesmo processo √© repetido recursivamente at√© chegarmos a um n√≥ folha a partir do qual as TIDs necess√°rias podem ser obtidas. <br><br>  Na realidade, v√°rios detalhes complicam esse processo aparentemente simples.  Por exemplo, um √≠ndice pode conter chaves n√£o exclusivas e pode haver tantos valores iguais que eles n√£o cabem em uma p√°gina.  Voltando ao nosso exemplo, parece que dever√≠amos descer do n√≥ interno sobre a refer√™ncia ao valor de 49. Mas, como mostra a figura, dessa forma, pularemos uma das teclas "49" na folha anterior .  Portanto, uma vez que encontramos uma chave exatamente igual em uma p√°gina interna, precisamos descer uma posi√ß√£o para a esquerda e, em seguida, examinar as linhas de √≠ndice do n√≠vel subjacente da esquerda para a direita em busca da chave procurada. <br><br>  (Outra complica√ß√£o √© que, durante a pesquisa, outros processos podem alterar os dados: a √°rvore pode ser reconstru√≠da, as p√°ginas podem ser divididas em duas etc. Todos os algoritmos s√£o projetados para que essas opera√ß√µes simult√¢neas n√£o interfiram entre si e n√£o causem bloqueios extras sempre que poss√≠vel. Mas evitaremos expandir isso.) <br><br><h3>  Pesquisa por desigualdade </h3><br>  Ao pesquisar pela condi√ß√£o " <em>campo indexado</em> ‚â§ <em>express√£o</em> " (ou " <em>campo indexado</em> ‚â• <em>express√£o</em> "), primeiro encontramos um valor (se houver) no √≠ndice pela condi√ß√£o de igualdade " <em>campo indexado</em> = <em>express√£o</em> " e depois percorremos p√°ginas da folha na dire√ß√£o apropriada at√© o fim. <br><br>  A figura ilustra esse processo para n ‚â§ 35: <br><br><img src="https://habrastorage.org/web/35e/62a/f80/35e62af80ca44349b7728ad806226208.png"><br><br>  Os operadores "maior" e "menos" s√£o suportados de maneira semelhante, exceto que o valor encontrado inicialmente deve ser descartado. <br><br><h3>  Pesquisa por faixa </h3><br>  Ao pesquisar pelo intervalo " <em>express√£o1</em> ‚â§ <em>campo indexado</em> ‚â§ <em>express√£o2</em> ", encontramos um valor pela condi√ß√£o " <em>campo indexado</em> = <em>express√£o1</em> " e continuamos percorrendo as p√°ginas das folhas enquanto a condi√ß√£o " <em>campo indexado</em> ‚â§ <em>express√£o2</em> " √© atendida;  ou vice-versa: comece com a segunda express√£o e caminhe em uma dire√ß√£o oposta at√© alcan√ßarmos a primeira express√£o. <br><br>  A figura mostra esse processo para a condi√ß√£o 23 ‚â§ n ‚â§ 64: <br><br><img src="https://habrastorage.org/web/2d6/b24/d86/2d6b24d86fb24c9ab437cc8155658e58.png"><br><br><h2>  Exemplo </h2><br>  Vejamos um exemplo de como s√£o os planos de consulta.  Como sempre, usamos o banco de dados de demonstra√ß√£o e, desta vez, consideraremos a tabela da aeronave.  Ele cont√©m apenas nove linhas e o planejador optaria por n√£o usar o √≠ndice, pois a tabela inteira cabe uma p√°gina.  Mas esta tabela √© interessante para n√≥s com um prop√≥sito ilustrativo. <br><br><pre><code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts;</code> </pre> <pre> <code class="plaintext hljs"> aircraft_code | model | range ---------------+---------------------+------- 773 | Boeing 777-300 | 11100 763 | Boeing 767-300 | 7900 SU9 | Sukhoi SuperJet-100 | 3000 320 | Airbus A320-200 | 5700 321 | Airbus A321-200 | 5600 319 | Airbus A319-100 | 6700 733 | Boeing 737-300 | 4200 CN1 | Cessna 208 Caravan | 1200 CR2 | Bombardier CRJ-200 | 2700 (9 rows)</code> </pre><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> aircrafts(range); demo=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> enable_seqscan = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>;</code> </pre><br>  (Ou explicitamente, "crie √≠ndice em aeronaves usando btree (range)", mas √© uma √°rvore B criada por padr√£o.) <br><br>  Pesquisa por igualdade: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> range = <span class="hljs-number"><span class="hljs-number">3000</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------- Index Scan using aircrafts_range_idx on aircrafts Index Cond: (range = 3000) (2 rows)</code> </pre><br>  Pesquisa por desigualdade: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> range &lt; <span class="hljs-number"><span class="hljs-number">3000</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------- Index Scan using aircrafts_range_idx on aircrafts Index Cond: (range &lt; 3000) (2 rows)</code> </pre><br>  E por faixa: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> <span class="hljs-number"><span class="hljs-number">3000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-number"><span class="hljs-number">5000</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------- Index Scan using aircrafts_range_idx on aircrafts Index Cond: ((range &gt;= 3000) AND (range &lt;= 5000)) (2 rows)</code> </pre><br><h2>  Classifica√ß√£o </h2><br>  Vamos enfatizar novamente que, com qualquer tipo de verifica√ß√£o (√≠ndice, somente √≠ndice ou bitmap), o m√©todo de acesso "btree" retorna dados ordenados, que podemos ver claramente nas figuras acima. <br><br>  Portanto, se uma tabela tiver um √≠ndice na condi√ß√£o de classifica√ß√£o, o otimizador considerar√° as duas op√ß√µes: varredura de √≠ndice da tabela, que retorna prontamente os dados classificados e varredura seq√ºencial da tabela com a classifica√ß√£o subsequente do resultado. <br><br><h3>  Ordem de classifica√ß√£o </h3><br>  Ao criar um √≠ndice, podemos especificar explicitamente a ordem de classifica√ß√£o.  Por exemplo, podemos criar um √≠ndice por faixas de v√¥o desta maneira em particular: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> aircrafts(range <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>);</code> </pre><br>  Nesse caso, valores maiores apareceriam na √°rvore √† esquerda, enquanto valores menores apareceriam √† direita.  Por que isso pode ser necess√°rio se podemos percorrer os valores indexados em qualquer dire√ß√£o? <br><br>  O objetivo √© √≠ndices com v√°rias colunas.  Vamos criar uma exibi√ß√£o para mostrar modelos de aeronaves com uma divis√£o convencional em embarca√ß√µes de curto, m√©dio e longo alcance: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> aircrafts_v <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> model, <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> range &lt; <span class="hljs-number"><span class="hljs-number">4000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> range &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts; demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts_v;</code> </pre><pre> <code class="plaintext hljs"> model | class ---------------------+------- Boeing 777-300 | 3 Boeing 767-300 | 2 Sukhoi SuperJet-100 | 1 Airbus A320-200 | 2 Airbus A321-200 | 2 Airbus A319-100 | 2 Boeing 737-300 | 2 Cessna 208 Caravan | 1 Bombardier CRJ-200 | 1 (9 rows)</code> </pre><br>  E vamos criar um √≠ndice (usando a express√£o): <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> aircrafts( (<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> range &lt; <span class="hljs-number"><span class="hljs-number">4000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> range &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>), model);</code> </pre><br>  Agora podemos usar esse √≠ndice para obter dados classificados por ambas as colunas em ordem crescente: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts_v <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, model;</code> </pre><pre> <code class="plaintext hljs"> class | model -------+--------------------- 1 | Bombardier CRJ-200 1 | Cessna 208 Caravan 1 | Sukhoi SuperJet-100 2 | Airbus A319-100 2 | Airbus A320-200 2 | Airbus A321-200 2 | Boeing 737-300 2 | Boeing 767-300 3 | Boeing 777-300 (9 rows)</code> </pre><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts_v <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, model;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------------- Index Scan using aircrafts_case_model_idx on aircrafts (1 row)</code> </pre><br>  Da mesma forma, podemos executar a consulta para classificar os dados em ordem decrescente: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts_v <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>;</code> </pre><pre> <code class="plaintext hljs"> class | model -------+--------------------- 3 | Boeing 777-300 2 | Boeing 767-300 2 | Boeing 737-300 2 | Airbus A321-200 2 | Airbus A320-200 2 | Airbus A319-100 1 | Sukhoi SuperJet-100 1 | Cessna 208 Caravan 1 | Bombardier CRJ-200 (9 rows)</code> </pre><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts_v <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------------------- Index Scan BACKWARD using aircrafts_case_model_idx on aircrafts (1 row)</code> </pre><br>  No entanto, n√£o podemos usar esse √≠ndice para obter dados classificados por uma coluna em ordem decrescente e pela outra coluna em ordem crescente.  Isso exigir√° classifica√ß√£o separadamente: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts_v <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------- Sort Sort Key: (CASE ... END), aircrafts.model DESC -&gt; Seq Scan on aircrafts (3 rows)</code> </pre><br>  (Observe que, como √∫ltimo recurso, o planejador escolheu a varredura sequencial, independentemente da configura√ß√£o "enable_seqscan = off" feita anteriormente. Isso ocorre porque, na verdade, essa configura√ß√£o n√£o pro√≠be a varredura de tabela, mas apenas define seu custo astron√¥mico - consulte o plano com "Custos".) <br><br>  Para fazer essa consulta usar o √≠ndice, o √∫ltimo deve ser criado com a dire√ß√£o de classifica√ß√£o necess√°ria: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> aircrafts_case_asc_model_desc_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> aircrafts( (<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> range &lt; <span class="hljs-number"><span class="hljs-number">4000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> range &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>); demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts_v <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------------------- Index Scan using aircrafts_case_asc_model_desc_idx on aircrafts (1 row)</code> </pre><br><h3>  Ordem das colunas </h3><br>  Outro problema que surge ao usar √≠ndices de v√°rias colunas √© a ordem de listar colunas em um √≠ndice.  Para a √°rvore B, essa ordem √© de enorme import√¢ncia: os dados dentro das p√°ginas ser√£o classificados pelo primeiro campo, depois pelo segundo e assim por diante. <br><br>  Podemos representar o √≠ndice que constru√≠mos em intervalos e modelos de intervalo de maneira simb√≥lica, da seguinte maneira: <br><br><img src="https://habrastorage.org/web/90c/71b/c8b/90c71bc8b51441b7b3c0df21b6a8888b.png"><br><br>  Na verdade, um √≠ndice t√£o pequeno certamente caber√° em uma p√°gina raiz.  Na figura, ele √© deliberadamente distribu√≠do entre v√°rias p√°ginas para maior clareza. <br><br>  Est√° claro neste gr√°fico que a pesquisa por predicados como "class = 3" (pesquisa apenas no primeiro campo) ou "class = 3 e model = 'Boeing 777-300'" (pesquisa nos dois campos) funcionar√° com efici√™ncia. <br><br>  No entanto, a pesquisa pelo predicado ‚Äúmodel = 'Boeing 777-300'‚Äù ser√° muito menos eficiente: come√ßando pela raiz, n√£o podemos determinar para qual n√≥ filho descer, portanto, teremos que descer para todos eles.  Isso n√£o significa que um √≠ndice como esse nunca possa ser usado - sua efici√™ncia est√° em quest√£o.  Por exemplo, se tiv√©ssemos tr√™s classes de aeronaves e muitos modelos em cada classe, ter√≠amos que examinar cerca de um ter√ßo do √≠ndice e isso poderia ter sido mais eficiente do que a verifica√ß√£o completa da tabela ... ou n√£o. <br><br>  No entanto, se criarmos um √≠ndice como este: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> aircrafts( model, (<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> range &lt; <span class="hljs-number"><span class="hljs-number">4000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> range &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>));</code> </pre><br>  a ordem dos campos ser√° alterada: <br><br><img src="https://habrastorage.org/web/458/c5f/d22/458c5fd22e26467d9f0c56e308d8db5f.png"><br><br>  Com esse √≠ndice, a pesquisa pelo predicado "model = 'Boeing 777-300'" funcionar√° eficientemente, mas a pesquisa pelo predicado "class = 3" n√£o funcionar√°. <br><br><h3>  Nulos </h3><br>  O m√©todo de acesso "Btree" indexa NULLs e suporta a pesquisa por condi√ß√µes √â NULL e N√ÉO √â NULL. <br><br>  Vamos considerar a tabela de v√¥os, onde ocorrem NULLs: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> flights(actual_arrival); demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> actual_arrival <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------- Bitmap Heap Scan on flights Recheck Cond: (actual_arrival IS NULL) -&gt; Bitmap Index Scan on flights_actual_arrival_idx Index Cond: (actual_arrival IS NULL) (4 rows)</code> </pre><br>  NULLs est√£o localizados em uma ou na outra extremidade dos n√≥s folha, dependendo de como o √≠ndice foi criado (NULLS FIRST ou NULLS LAST).  Isso √© importante se uma consulta incluir classifica√ß√£o: o √≠ndice poder√° ser usado se o comando SELECT especificar a mesma ordem de NULLs na sua cl√°usula ORDER BY que a ordem especificada para o √≠ndice criado (NULLS FIRST ou NULLS LAST). <br><br>  No exemplo a seguir, esses pedidos s√£o os mesmos, portanto, podemos usar o √≠ndice: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> actual_arrival <span class="hljs-keyword"><span class="hljs-keyword">NULLS LAST</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------------- Index Scan using flights_actual_arrival_idx on flights (1 row)</code> </pre><br>  E aqui esses pedidos s√£o diferentes, e o otimizador escolhe a varredura seq√ºencial com a classifica√ß√£o subsequente: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> actual_arrival <span class="hljs-keyword"><span class="hljs-keyword">NULLS FIRST</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------- Sort Sort Key: actual_arrival NULLS FIRST -&gt; Seq Scan on flights (3 rows)</code> </pre><br>  Para usar o √≠ndice, ele deve ser criado com NULLs localizados no in√≠cio: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> flights_nulls_first_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> flights(actual_arrival <span class="hljs-keyword"><span class="hljs-keyword">NULLS FIRST</span></span>); demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> actual_arrival <span class="hljs-keyword"><span class="hljs-keyword">NULLS FIRST</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------- Index Scan using flights_nulls_first_idx on flights (1 row)</code> </pre><br>  Problemas como esse certamente s√£o causados ‚Äã‚Äãpor NULLs n√£o serem classificados, ou seja, o resultado da compara√ß√£o de NULL e qualquer outro valor √© indefinido: <br><br><pre> <code class="pgsql hljs">demo=# \pset <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &lt; <span class="hljs-number"><span class="hljs-number">42</span></span>;</code> </pre><pre> <code class="plaintext hljs"> ?column? ---------- NULL (1 row)</code> </pre><br>  Isso contraria o conceito de √°rvore B e n√£o se encaixa no padr√£o geral.  Os NULLs, no entanto, desempenham um papel t√£o importante nos bancos de dados que sempre precisamos abrir exce√ß√µes para eles. <br><br>  Como os NULLs podem ser indexados, √© poss√≠vel usar um √≠ndice mesmo sem as condi√ß√µes impostas √† tabela (j√° que o √≠ndice cont√©m informa√ß√µes sobre todas as linhas da tabela).  Isso pode fazer sentido se a consulta exigir ordem de dados e o √≠ndice garantir a ordem necess√°ria.  Nesse caso, o planejador pode escolher o acesso ao √≠ndice para salvar em uma classifica√ß√£o separada. <br><br><h2>  Propriedades </h2><br>  Vamos examinar as propriedades do m√©todo de acesso "btree" (as consultas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">j√° foram fornecidas</a> ). <br><br><pre> <code class="plaintext hljs"> amname | name | pg_indexam_has_property --------+---------------+------------------------- btree | can_order | t btree | can_unique | t btree | can_multi_col | t btree | can_exclude | t</code> </pre><br>  Como vimos, o B-tree pode solicitar dados e suporta exclusividade - e este √© o √∫nico m√©todo de acesso que nos fornece propriedades como essas.  Os √≠ndices de v√°rias colunas tamb√©m s√£o permitidos, mas outros m√©todos de acesso (embora nem todos eles) tamb√©m possam suportar esses √≠ndices.  Discutiremos o suporte √† restri√ß√£o EXCLUDE da pr√≥xima vez, e n√£o sem raz√£o. <br><br><pre> <code class="plaintext hljs"> name | pg_index_has_property ---------------+----------------------- clusterable | t index_scan | t bitmap_scan | t backward_scan | t</code> </pre><br>  O m√©todo de acesso "Btree" suporta as duas t√©cnicas para obter valores: verifica√ß√£o de √≠ndice, bem como verifica√ß√£o de bitmap.  E como pudemos ver, o m√©todo de acesso pode percorrer a √°rvore "para frente" e "para tr√°s". <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ asc | t desc | f nulls_first | f nulls_last | t orderable | t distance_orderable | f returnable | t search_array | t search_nulls | t</code> </pre><br>  As primeiras quatro propriedades dessa camada explicam como exatamente os valores de uma determinada coluna espec√≠fica s√£o ordenados.  Neste exemplo, os valores s√£o classificados em ordem crescente ("asc") e os NULLs s√£o fornecidos por √∫ltimo ("nulls_last").  Mas, como j√° vimos, outras combina√ß√µes s√£o poss√≠veis. <br><br>  A propriedade "Search_array" indica suporte para express√µes como esta pelo √≠ndice: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> aircraft_code <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-string"><span class="hljs-string">'733'</span></span>,<span class="hljs-string"><span class="hljs-string">'763'</span></span>,<span class="hljs-string"><span class="hljs-string">'773'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------------------- Index Scan using aircrafts_pkey on aircrafts Index Cond: (aircraft_code = ANY ('{733,763,773}'::bpchar[])) (2 rows)</code> </pre><br>  A propriedade "Retorn√°vel" indica suporte √† varredura apenas de √≠ndice, o que √© razo√°vel, pois as linhas do √≠ndice armazenam os valores indexados (diferentemente do √≠ndice de hash, por exemplo).  Aqui faz sentido dizer algumas palavras sobre a cobertura de √≠ndices baseados em √°rvore B. <br><br><h3>  √çndices exclusivos com linhas adicionais </h3><br>  Como discutimos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">anteriormente</a> , um √≠ndice de cobertura √© aquele que armazena todos os valores necess√°rios para uma consulta, n√£o sendo necess√°rio o acesso √† pr√≥pria tabela (quase).  Um √≠ndice exclusivo pode ser especificamente coberto. <br><br>  Mas vamos assumir que queremos adicionar colunas extras necess√°rias para uma consulta ao √≠ndice exclusivo.  No entanto, a exclusividade de tais valores compostos n√£o garante a exclusividade da chave e ser√£o necess√°rios dois √≠ndices nas mesmas colunas: um exclusivo para suportar a restri√ß√£o de integridade e outro para ser usado como cobertura.  Isso √© ineficiente, com certeza. <br><br>  Em nossa empresa, a Anastasiya Lubennikova <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">lubennikovaav</a> aprimorou o m√©todo "btree" para que colunas adicionais, n√£o exclusivas, pudessem ser inclu√≠das em um √≠ndice exclusivo.  Esperamos que esse patch seja adotado pela comunidade para se tornar parte do PostgreSQL, mas isso n√£o acontecer√° t√£o cedo quanto na vers√£o 10. Neste momento, o patch est√° dispon√≠vel no Pro Standard 9.5+ e √© isso que parece gosto. <br><br><blockquote>  De fato, este patch foi confirmado no PostgreSQL 11. <br></blockquote><br>  Vamos considerar a tabela de reservas: <br><br><pre> <code class="pgsql hljs">demo=# \d bookings</code> </pre><pre> <code class="plaintext hljs"> Table "bookings.bookings" Column | Type | Modifiers --------------+--------------------------+----------- book_ref | character(6) | not null book_date | timestamp with time zone | not null total_amount | numeric(10,2) | not null Indexes: "bookings_pkey" PRIMARY KEY, btree (book_ref) Referenced by: TABLE "tickets" CONSTRAINT "tickets_book_ref_fkey" FOREIGN KEY (book_ref) REFERENCES bookings(book_ref)</code> </pre><br>  Nesta tabela, a chave prim√°ria (book_ref, c√≥digo de reserva) √© fornecida por um √≠ndice "btree" regular.  Vamos criar um novo √≠ndice exclusivo com uma coluna adicional: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unique</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> bookings_pkey2 <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> bookings(book_ref) <span class="hljs-keyword"><span class="hljs-keyword">INCLUDE</span></span> (book_date);</code> </pre><br>  Agora substitu√≠mos o √≠ndice existente por um novo (na transa√ß√£o, para aplicar todas as altera√ß√µes simultaneamente): <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>; demo=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> bookings <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> bookings_pkey <span class="hljs-keyword"><span class="hljs-keyword">cascade</span></span>; demo=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> bookings <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">primary key</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> bookings_pkey2; demo=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> tickets <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">foreign key</span></span> (book_ref) <span class="hljs-keyword"><span class="hljs-keyword">references</span></span> bookings (book_ref); demo=# <span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>;</code> </pre><br>  Isto √© o que obtemos: <br><br><pre> <code class="pgsql hljs">demo=# \d bookings</code> </pre><pre> <code class="plaintext hljs"> Table "bookings.bookings" Column | Type | Modifiers --------------+--------------------------+----------- book_ref | character(6) | not null book_date | timestamp with time zone | not null total_amount | numeric(10,2) | not null Indexes: "bookings_pkey2" PRIMARY KEY, btree (book_ref) INCLUDE (book_date) Referenced by: TABLE "tickets" CONSTRAINT "tickets_book_ref_fkey" FOREIGN KEY (book_ref) REFERENCES bookings(book_ref)</code> </pre><br>  Agora, um e o mesmo √≠ndice funciona como exclusivo e serve como um √≠ndice de cobertura para esta consulta, por exemplo: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> book_ref, book_date <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bookings <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> book_ref = <span class="hljs-string"><span class="hljs-string">'059FC4'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------- Index Only Scan using bookings_pkey2 on bookings Index Cond: (book_ref = '059FC4'::bpchar) (2 rows)</code> </pre><br><h2>  Cria√ß√£o do √≠ndice </h2><br>  √â sabido, mas n√£o menos importante, que, para uma tabela de tamanho grande, √© melhor carregar dados sem √≠ndices e criar os √≠ndices necess√°rios posteriormente.  Isso n√£o √© apenas mais r√°pido, mas provavelmente o √≠ndice ter√° um tamanho menor. <br><br>  O fato √© que a cria√ß√£o do √≠ndice "btree" usa um processo mais eficiente do que a inser√ß√£o de valores por linha na √°rvore.  Aproximadamente, todos os dados dispon√≠veis na tabela s√£o classificados e as p√°ginas em folha desses dados s√£o criadas.  As p√°ginas internas s√£o "constru√≠das sobre" essa base at√© que toda a pir√¢mide converja para a raiz. <br><br>  A velocidade desse processo depende do tamanho da RAM dispon√≠vel, limitada pelo par√¢metro "maintenance_work_mem".  Portanto, aumentar o valor do par√¢metro pode acelerar o processo.  Para √≠ndices exclusivos, a mem√≥ria do tamanho "work_mem" √© alocada al√©m de "maintenance_work_mem". <br><br><h3>  Sem√¢ntica de compara√ß√£o </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A √∫ltima vez</a> que mencionamos que o PostgreSQL precisa saber quais fun√ß√µes hash exigem valores de tipos diferentes e que essa associa√ß√£o √© armazenada no m√©todo de acesso "hash".  Da mesma forma, o sistema deve descobrir como ordenar valores.  Isso √© necess√°rio para classifica√ß√µes, agrupamentos (algumas vezes), jun√ß√µes de mesclagem e assim por diante.  O PostgreSQL n√£o se liga a nomes de operadores (como&gt;, &lt;, =), pois os usu√°rios podem definir seu pr√≥prio tipo de dados e atribuir nomes diferentes aos operadores correspondentes.  Uma fam√≠lia de operadores usada pelo m√©todo de acesso "btree" define os nomes dos operadores. <br><br>  Por exemplo, esses operadores de compara√ß√£o s√£o usados ‚Äã‚Äãna fam√≠lia de operadores "bool_ops": <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> opfamily_operator, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_am am, pg_opfamily opf, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opf.opfmethod = am.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opf.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'btree'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.opfname = <span class="hljs-string"><span class="hljs-string">'bool_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> amopstrategy;</code> </pre><pre> <code class="plaintext hljs"> opfamily_operator | amopstrategy ---------------------+-------------- &lt;(boolean,boolean) | 1 &lt;=(boolean,boolean) | 2 =(boolean,boolean) | 3 &gt;=(boolean,boolean) | 4 &gt;(boolean,boolean) | 5 (5 rows)</code> </pre><br>  Aqui podemos ver cinco operadores de compara√ß√£o, mas como j√° mencionado, n√£o devemos confiar em seus nomes.  Para descobrir qual compara√ß√£o cada operador faz, o conceito de estrat√©gia √© introduzido.  Cinco estrat√©gias s√£o definidas para descrever a sem√¢ntica do operador: <br><br><ul><li>  1 - menos </li><li>  2 - menor ou igual </li><li>  3 - igual </li><li>  4 - maior ou igual </li><li>  5 - maior </li></ul><br>  Algumas fam√≠lias de operadores podem conter v√°rios operadores que implementam uma estrat√©gia.  Por exemplo, a fam√≠lia de operadores "integer_ops" cont√©m os seguintes operadores para a estrat√©gia 1: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> opfamily_operator <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_am am, pg_opfamily opf, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opf.opfmethod = am.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opf.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'btree'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.opfname = <span class="hljs-string"><span class="hljs-string">'integer_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopstrategy = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> opfamily_operator;</code> </pre><pre> <code class="plaintext hljs"> opfamily_operator ---------------------- &lt;(integer,bigint) &lt;(smallint,smallint) &lt;(integer,integer) &lt;(bigint,bigint) &lt;(bigint,integer) &lt;(smallint,integer) &lt;(integer,smallint) &lt;(smallint,bigint) &lt;(bigint,smallint) (9 rows)</code> </pre><br>  Gra√ßas a isso, o otimizador pode evitar a convers√£o de tipos ao comparar valores de diferentes tipos contidos em uma fam√≠lia de operadores. <br><br><h3>  Suporte de √≠ndice para um novo tipo de dados </h3><br>  A documenta√ß√£o fornece <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um exemplo</a> de cria√ß√£o de um novo tipo de dados para n√∫meros complexos e de uma classe de operador para classificar valores desse tipo.  Este exemplo usa a linguagem C, que √© absolutamente razo√°vel quando a velocidade √© cr√≠tica.  Mas nada nos impede de usar SQL puro para o mesmo experimento, apenas para tentar entender melhor a sem√¢ntica da compara√ß√£o. <br><br>  Vamos criar um novo tipo composto com dois campos: partes reais e imagin√°rias. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> complex <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (re <span class="hljs-type"><span class="hljs-type">float</span></span>, im <span class="hljs-type"><span class="hljs-type">float</span></span>);</code> </pre><br>  Podemos criar uma tabela com um campo do novo tipo e adicionar alguns valores √† tabela: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> numbers(x complex); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> numbers <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> ((<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">10.0</span></span>)), ((<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">3.0</span></span>)), ((<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>));</code> </pre><br>  Agora surge uma pergunta: como ordenar n√∫meros complexos se nenhuma rela√ß√£o de ordem √© definida para eles no sentido matem√°tico? <br><br>  Como se v√™, os operadores de compara√ß√£o j√° est√£o definidos para n√≥s: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numbers <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> x;</code> </pre><pre> <code class="plaintext hljs"> x -------- (0,10) (1,1) (1,3) (3 rows)</code> </pre><br>  Por padr√£o, a classifica√ß√£o √© componente por componente para um tipo composto: os primeiros campos s√£o comparados, os segundos campos e assim por diante, aproximadamente da mesma maneira que as seq√º√™ncias de texto s√£o comparadas caractere por caractere.  Mas podemos definir uma ordem diferente.  Por exemplo, n√∫meros complexos podem ser tratados como vetores e ordenados pelo m√≥dulo (comprimento), que √© calculado como a raiz quadrada da soma dos quadrados das coordenadas (o teorema de Pit√°goras).  Para definir essa ordem, vamos criar uma fun√ß√£o auxiliar que calcula o m√≥dulo: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> modulus(a complex) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">select</span></span></span><span class="pgsql"> sqrt(a.re*a.re + a.im*a.im); $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">language</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>;</code> </pre><br>  Agora definiremos sistematicamente fun√ß√µes para todos os cinco operadores de compara√ß√£o usando esta fun√ß√£o auxiliar: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> complex_lt(a complex, b complex) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-type"><span class="hljs-type">boolean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">select</span></span></span><span class="pgsql"> modulus(a) &lt; modulus(b); $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">language</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> complex_le(a complex, b complex) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-type"><span class="hljs-type">boolean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">select</span></span></span><span class="pgsql"> modulus(a) &lt;= modulus(b); $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">language</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> complex_eq(a complex, b complex) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-type"><span class="hljs-type">boolean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">select</span></span></span><span class="pgsql"> modulus(a) = modulus(b); $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">language</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> complex_ge(a complex, b complex) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-type"><span class="hljs-type">boolean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">select</span></span></span><span class="pgsql"> modulus(a) &gt;= modulus(b); $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">language</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> complex_gt(a complex, b complex) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-type"><span class="hljs-type">boolean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">select</span></span></span><span class="pgsql"> modulus(a) &gt; modulus(b); $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">language</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>;</code> </pre><br>  E criaremos operadores correspondentes.  Para ilustrar que eles n√£o precisam ser chamados "&gt;", "&lt;" e assim por diante, vamos dar a eles nomes "estranhos". <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> #&lt;#(leftarg=complex, rightarg=complex, procedure=complex_lt); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> #&lt;=#(leftarg=complex, rightarg=complex, procedure=complex_le); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> #=#(leftarg=complex, rightarg=complex, procedure=complex_eq); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> #&gt;=#(leftarg=complex, rightarg=complex, procedure=complex_ge); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> #&gt;#(leftarg=complex, rightarg=complex, procedure=complex_gt);</code> </pre><br>  Neste ponto, podemos comparar n√∫meros: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> (<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>)::complex #&lt;# (<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">3.0</span></span>)::complex;</code> </pre><pre> <code class="plaintext hljs"> ?column? ---------- t (1 row)</code> </pre><br>  Al√©m de cinco operadores, o m√©todo de acesso "btree" exige que mais uma fun√ß√£o (excessiva, mas conveniente) seja definida: ele deve retornar -1, 0 ou 1 se o primeiro valor for menor que, igual a ou maior que o segundo um.  Essa fun√ß√£o auxiliar √© chamada de suporte.  Outros m√©todos de acesso podem exigir a defini√ß√£o de outras fun√ß√µes de suporte. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> complex_cmp(a complex, b complex) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">select</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">case</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">when</span></span></span><span class="pgsql"> modulus(a) &lt; modulus(b) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">then</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">-1</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">when</span></span></span><span class="pgsql"> modulus(a) &gt; modulus(b) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">then</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">else</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">end</span></span></span><span class="pgsql">; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">language</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>;</code> </pre><br>  Agora estamos prontos para criar uma classe de operadores (e a fam√≠lia de operadores com o mesmo nome ser√° criada automaticamente): <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> complex_ops <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> complex <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> btree <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> #&lt;#, <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> #&lt;=#, <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> #=#, <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> #&gt;=#, <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> #&gt;#, <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> complex_cmp(complex,complex);</code> </pre><br>  Agora a classifica√ß√£o funciona como desejado: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numbers <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> x;</code> </pre><pre> <code class="plaintext hljs"> x -------- (1,1) (1,3) (0,10) (3 rows)</code> </pre><br>  E certamente ser√° suportado pelo √≠ndice "btree". <br><br>  Para concluir a imagem, voc√™ pode obter fun√ß√µes de suporte usando esta consulta: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amp.amprocnum, amp.amproc, amp.amproclefttype::<span class="hljs-type"><span class="hljs-type">regtype</span></span>, amp.amprocrighttype::<span class="hljs-type"><span class="hljs-type">regtype</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opfamily opf, pg_am am, pg_amproc amp <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opf.opfname = <span class="hljs-string"><span class="hljs-string">'complex_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.opfmethod = am.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'btree'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amp.amprocfamily = opf.oid;</code> </pre><pre> <code class="plaintext hljs"> amprocnum | amproc | amproclefttype | amprocrighttype -----------+-------------+----------------+----------------- 1 | complex_cmp | complex | complex (1 row)</code> </pre><br><h2>  Internals </h2><br>  Podemos explorar a estrutura interna do B-tree usando a extens√£o "pageinspect". <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> pageinspect;</code> </pre><br>  Metapagem do √≠ndice: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bt_metap(<span class="hljs-string"><span class="hljs-string">'ticket_flights_pkey'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> magic | version | root | level | fastroot | fastlevel --------+---------+------+-------+----------+----------- 340322 | 2 | 164 | 2 | 164 | 2 (1 row)</code> </pre><br>  O mais interessante aqui √© o n√≠vel do √≠ndice: o √≠ndice em duas colunas para uma tabela com um milh√£o de linhas, exigindo apenas dois n√≠veis (n√£o incluindo a raiz). <br><br>  Informa√ß√£o estat√≠stica no bloco 164 (raiz): <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>, live_items, dead_items, avg_item_size, page_size, free_size <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bt_page_stats(<span class="hljs-string"><span class="hljs-string">'ticket_flights_pkey'</span></span>,<span class="hljs-number"><span class="hljs-number">164</span></span>);</code> </pre><pre> <code class="plaintext hljs"> type | live_items | dead_items | avg_item_size | page_size | free_size ------+------------+------------+---------------+-----------+----------- r | 33 | 0 | 31 | 8192 | 6984 (1 row)</code> </pre><br>  E os dados no bloco (o campo "dados", que √© sacrificado aqui para a largura da tela, cont√©m o valor da chave de indexa√ß√£o na representa√ß√£o bin√°ria): <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> itemoffset, ctid, itemlen, left(data,<span class="hljs-number"><span class="hljs-number">56</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bt_page_items(<span class="hljs-string"><span class="hljs-string">'ticket_flights_pkey'</span></span>,<span class="hljs-number"><span class="hljs-number">164</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid | itemlen | data ------------+---------+---------+---------------------------------------------------------- 1 | (3,1) | 8 | 2 | (163,1) | 32 | 1d 30 30 30 35 34 33 32 33 30 35 37 37 31 00 00 ff 5f 00 3 | (323,1) | 32 | 1d 30 30 30 35 34 33 32 34 32 33 36 36 32 00 00 4f 78 00 4 | (482,1) | 32 | 1d 30 30 30 35 34 33 32 35 33 30 38 39 33 00 00 4d 1e 00 5 | (641,1) | 32 | 1d 30 30 30 35 34 33 32 36 35 35 37 38 35 00 00 2b 09 00 (5 rows)</code> </pre><br>  O primeiro elemento refere-se a t√©cnicas e especifica o limite superior de todos os elementos no bloco (um detalhe de implementa√ß√£o que n√£o discutimos), enquanto os dados em si come√ßam com o segundo elemento.  √â claro que o n√≥ filho mais √† esquerda √© o bloco 163, seguido pelo bloco 323 e assim por diante.  Eles, por sua vez, podem ser explorados usando as mesmas fun√ß√µes. <br><br>  Agora, seguindo uma boa tradi√ß√£o, faz sentido ler a documenta√ß√£o, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">README</a> e o c√≥digo-fonte. <br><br>  Ainda mais uma extens√£o potencialmente √∫til √© o " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">amcheck</a> ", que ser√° incorporado no PostgreSQL 10, e para vers√µes inferiores, voc√™ pode obt√™-lo no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github</a> .  Essa extens√£o verifica a consist√™ncia l√≥gica dos dados nas √°rvores B e nos permite detectar falhas com anteced√™ncia. <br><blockquote>  Isso √© verdade, "amcheck" faz parte do PostgreSQL a partir da vers√£o 10. <br></blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Continue lendo</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt443284/">https://habr.com/ru/post/pt443284/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt443272/index.html">O mito das pragas nichrome</a></li>
<li><a href="../pt443274/index.html">Compila√ß√£o de not√≠cias da ind√∫stria de jogos de 8 de mar√ßo a domingo</a></li>
<li><a href="../pt443276/index.html">Programador de consultas surpresa no banco de dados PostgreSQL</a></li>
<li><a href="../pt443280/index.html">A hist√≥ria de como montei um home theater de 120 polegadas com canos, cordas, uma tela dobr√°vel e veludo preto</a></li>
<li><a href="../pt443282/index.html">O que devemos construir uma blockchain?</a></li>
<li><a href="../pt443286/index.html">TDMS Fairway. Mecanismo de preenchimento autom√°tico para as principais inscri√ß√µes nos desenhos e detalhes dos documentos</a></li>
<li><a href="../pt443288/index.html">Navega√ß√£o em projetos com v√°rios m√≥dulos</a></li>
<li><a href="../pt443290/index.html">Zen Erlang [e Elixir - aprox. tradutor]</a></li>
<li><a href="../pt443292/index.html">Estudamos o princ√≠pio de opera√ß√£o de unidades em usando o exemplo da tarefa "Layout de um pr√©-carregador flex√≠vel"</a></li>
<li><a href="../pt443294/index.html">O que √© permitido pelo Jupyter?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>