<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõ∏ üë©üèª‚Äçüé§ üë©üèª‚Äçüíª Comprendre les courtiers de messages. Apprentissage de la m√©canique de la messagerie via ActiveMQ et Kafka. Chapitre 3. Kafka üê≥ üññüèº üîç</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Poursuite de la traduction d'un petit livre: 
 "Comprendre les courtiers de messages", 
 auteur: Jakub Korab, √©diteur: O'Reilly Media, Inc., date de p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comprendre les courtiers de messages. Apprentissage de la m√©canique de la messagerie via ActiveMQ et Kafka. Chapitre 3. Kafka</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466585/"> Poursuite de la traduction d'un petit livre: <br>  "Comprendre les courtiers de messages", <br>  auteur: Jakub Korab, √©diteur: O'Reilly Media, Inc., date de publication: juin 2017, ISBN: 9781492049296. <br><br>  <b>Traduction termin√©e: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tele.gg/middle_java</a></b> <br><br>  Partie pr√©c√©dente: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comprendre les courtiers de messages.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Apprentissage de la m√©canique de la messagerie via ActiveMQ et Kafka.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Chapitre 2. ActiveMQ</a> <br><a name="habracut"></a><br><h2>  CHAPITRE 3 </h2><br><h2>  Kafka </h2><br>  Kafka a √©t√© d√©velopp√© sur LinkedIn pour contourner certaines des limitations des courtiers de messages traditionnels et pour √©viter d'avoir √† configurer plusieurs courtiers de messages pour diff√©rentes interactions point √† point, ce qui est d√©crit dans la section ¬´Mise √† l'√©chelle verticale et horizontale¬ª √† la page 28 de ce livre. LinkedIn s'est fortement appuy√© sur l'absorption unidirectionnelle de tr√®s grandes quantit√©s de donn√©es, telles que les clics sur les pages et les journaux d'acc√®s, tout en permettant √† plusieurs syst√®mes d'utiliser ces donn√©es.  h, sans affecter les performances des autres producteurs ou konsyumerov.  En fait, la raison pour laquelle Kafka existe est d'obtenir l'architecture de messagerie d√©crite par Universal Data Pipeline. <br><br>  Compte tenu de cet objectif ultime, d'autres exigences ont naturellement surgi.  Kafka doit: <br><br><ul><li>  Soyez extr√™mement rapide </li><li>  Fournir un d√©bit de messagerie sup√©rieur </li><li>  Prise en charge des mod√®les Publisher-Subscriber et Point-to-Point </li><li>  Ne ralentissez pas avec l'ajout de consommateurs.  Par exemple, les performances des files d'attente et des rubriques dans ActiveMQ se d√©t√©riorent √† mesure que le nombre de consommateurs √† destination augmente. </li><li>  √ätre √©volutif horizontalement;  si un seul message persiste ne peut le faire qu'√† la vitesse maximale du disque, alors pour augmenter les performances, il est logique d'aller au-del√† des limites d'une instance de courtier </li><li>  D√©limiter l'acc√®s au stockage et √† la r√©cup√©ration des messages </li></ul><br>  Pour y parvenir, Kafka a adopt√© une architecture qui a red√©fini les r√¥les et responsabilit√©s des clients et des courtiers de messagerie.  Le mod√®le JMS est tr√®s ax√© sur le courtier, o√π il est responsable de la distribution des messages, et les clients n'ont qu'√† se soucier d'envoyer et de recevoir des messages.  Kafka, d'autre part, est orient√© vers le client, le client assumant de nombreuses fonctions d'un courtier traditionnel, telles que la distribution √©quitable des messages pertinents parmi les consommateurs, en √©change de recevoir un courtier extr√™mement rapide et √©volutif.  Pour les personnes travaillant avec des syst√®mes de messagerie traditionnels, travailler avec Kafka n√©cessite un changement d'attitude fondamental. <br>  Cette direction technique a conduit √† la cr√©ation d'une infrastructure de messagerie qui peut augmenter le d√©bit de plusieurs ordres de grandeur par rapport √† un courtier conventionnel.  Comme nous le verrons, cette approche est lourde de compromis, ce qui signifie que Kafka n'est pas adapt√© √† certains types de charges et de logiciels install√©s. <br><br><h3>  Mod√®le de destination unifi√©e </h3><br>  Pour r√©pondre aux exigences d√©crites ci-dessus, Kafka a combin√© la publication-abonnement et la messagerie point √† point dans un seul type de destinataire - le <i>sujet</i> .  C'est d√©routant pour les personnes travaillant avec des syst√®mes de messagerie, o√π le mot ¬´sujet¬ª fait r√©f√©rence √† un m√©canisme de diffusion √† partir duquel (√† partir du sujet) la lecture n'est pas fiable (n'est pas durable).  Les sujets Kafka doivent √™tre consid√©r√©s comme un type de destination hybride, tel que d√©fini dans l'introduction de ce livre. <br><blockquote>  Dans la suite de ce chapitre, sauf indication contraire explicite, le terme sujet fera r√©f√©rence au sujet Kafka. </blockquote><br>  Pour bien comprendre comment les sujets se comportent et quelles garanties ils offrent, nous devons d'abord examiner comment ils sont mis en ≈ìuvre dans Kafka. <br>  <i>Chaque sujet dans Kafka a son propre journal.</i> <br>  Les producteurs qui envoient des messages √† Kafka s'ajoutent √† ce magazine, et les consommateurs lisent le magazine √† l'aide de pointeurs qui avancent constamment.  Kafka supprime p√©riodiquement les parties les plus anciennes du journal, que les messages de ces parties aient √©t√© lus ou non.  Un √©l√©ment central de la conception de Kafka est que le courtier ne se soucie pas de savoir si les messages sont lus ou non - c'est la responsabilit√© du client. <br><blockquote>  Les termes ¬´journal¬ª et ¬´index¬ª ne se trouvent pas dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation de Kafka</a> .  Ces termes bien connus sont utilis√©s ici pour aider √† la compr√©hension. </blockquote><br>  Ce mod√®le est compl√®tement diff√©rent d'ActiveMQ, o√π les messages de toutes les files d'attente sont stock√©s dans un journal, et le courtier marque les messages comme supprim√©s apr√®s leur lecture. <br>  Allons maintenant un peu plus loin et regardons le magazine th√©matique plus en d√©tail. <br>  Kafka Magazine se compose de plusieurs partitions ( <a href="">figure 3-1</a> ).  Kafka garantit un ordre strict dans chaque partition.  Cela signifie que les messages √©crits sur la partition dans un certain ordre seront lus dans le m√™me ordre.  Chaque partition est impl√©ment√©e en tant que fichier journal tournant (journal) qui contient un <i>sous</i> - <i>ensemble de</i> tous les messages envoy√©s au sujet par ses producteurs.  La rubrique cr√©√©e contient une partition par d√©faut.  Le partitionnement est l'id√©e centrale de Kafka pour la mise √† l'√©chelle horizontale. <br><br><img src="https://habrastorage.org/webt/tm/w2/yf/tmw2yf3lanppqtrumxoidotplhi.png"><br>  <i>Figure 3-1.</i>  <i>Cloisons Kafka</i> <br><br>  Lorsque le producteur envoie un message au sujet Kafka, il d√©cide √† quelle partition envoyer le message.  Nous examinerons cela plus en d√©tail plus tard. <br><br><h2>  Lire des messages </h2><br>  Un client qui souhaite lire des messages contr√¥le un pointeur nomm√© appel√© <i>groupe de consommateurs</i> , qui indique le <i>d√©calage d'un</i> message dans une partition.  Un d√©calage est une position avec un nombre croissant qui commence √† 0 au d√©but de la partition.  Ce groupe de consommateurs, r√©f√©renc√© dans l'API via un identifiant d√©fini par l'utilisateur group_id, correspond √† un <i>seul consommateur ou syst√®me logique</i> . <br><br>  La plupart des syst√®mes de messagerie lisent les donn√©es du destinataire via plusieurs instances et threads pour traiter les messages en parall√®le.  Ainsi, il y aura g√©n√©ralement de nombreux cas de consommateurs qui partagent le m√™me groupe de consommateurs. <br><br>  Le probl√®me de lecture peut √™tre repr√©sent√© comme suit: <br><br><ul><li>  Le sujet a plusieurs partitions </li><li>  Plusieurs groupes de consommateurs peuvent utiliser le sujet en m√™me temps. </li><li>  Un groupe de consommateurs peut avoir plusieurs instances distinctes. </li></ul><br>  Il s'agit d'un probl√®me de plusieurs √† plusieurs non trivial.  Pour comprendre comment Kafka g√®re les relations entre les groupes de consommateurs, les instances de consommateurs et les partitions, examinons une s√©rie de scripts de lecture de plus en plus complexes. <br><br><h3>  Consommateurs et groupes de consommateurs </h3><br>  Prenons un sujet √† partition unique comme point de d√©part ( <a href="">figure 3-2</a> ). <br><br><img src="https://habrastorage.org/webt/6z/tz/dh/6ztzdhqmjweck-z15htxb2xbe28.png"><br>  <i>Figure 3-2.</i>  <i>Le consommateur lit √† partir de la partition</i> <br><br>  Lorsqu'une instance de consommateur est connect√©e avec son propre group_id √† cette rubrique, une partition √† lire et un d√©calage dans cette partition lui sont attribu√©s.  La position de ce d√©calage est configur√©e dans le client comme un pointeur vers la position la plus r√©cente (le message le plus r√©cent) ou la position la plus ancienne (le message le plus ancien).  Le consommateur demande (interroge) des messages du sujet, ce qui conduit √† leur lecture s√©quentielle dans le journal. <br>  La position de d√©calage est r√©guli√®rement <i>valid√©e</i> dans Kafka et enregistr√©e sous forme de messages dans la <i>rubrique</i> interne <i>_consumer_offsets</i> .  Contrairement aux courtiers habituels, les messages lus ne sont toujours pas supprim√©s et le client peut rembobiner le d√©calage afin de retraiter les messages d√©j√† consult√©s. <br><br>  Lorsqu'un deuxi√®me consommateur logique est connect√© √† l'aide d'un autre group_id, il contr√¥le un deuxi√®me pointeur ind√©pendant du premier ( <a href="">figure 3-3</a> ).  Ainsi, le sujet Kafka agit comme une file d'attente dans laquelle il y a un consommateur et, comme sujet r√©gulier, un √©diteur-abonn√© (pub-sub), auquel plusieurs consommateurs sont abonn√©s, avec l'avantage suppl√©mentaire que tous les messages sont enregistr√©s et peuvent √™tre trait√©s plusieurs fois. <br><br><img src="https://habrastorage.org/webt/qe/v1/yk/qev1yktga3s-g1gqlynylbe3n9w.png"><br>  <i>Figure 3-3.</i>  <i>Deux consommateurs dans diff√©rents groupes de consommateurs lisent √† partir de la m√™me partition</i> <br><br><h3>  Consommateurs du groupe des consommateurs </h3><br>  Lorsqu'une instance du consommateur lit les donn√©es de la partition, il contr√¥le compl√®tement le pointeur et traite les messages, comme d√©crit dans la section pr√©c√©dente. <br>  Si plusieurs instances des consommateurs √©taient connect√©es avec le m√™me group_id au sujet avec la m√™me partition, la derni√®re instance connect√©e recevra alors le contr√¥le du pointeur et √† partir de l√†, elle recevra tous les messages ( <a href="">Figure 3-4</a> ). <br><br><img src="https://habrastorage.org/webt/0j/ao/f2/0jaof2mdwg3cqvmwemhtxkrltuq.png"><br>  <i>Figure 3-4.</i>  <i>Deux consommateurs dans le m√™me groupe de consommateurs lisent √† partir de la m√™me partition</i> <br><br>  Ce mode de traitement, dans lequel le nombre d'instances de consommateurs d√©passe le nombre de partitions, peut √™tre consid√©r√© comme une sorte de consommateur monopolistique.  Cela peut √™tre utile si vous avez besoin d'un clustering "actif-passif" (ou "chaud-chaud") de vos instances de consommateurs, bien que le fonctionnement parall√®le de plusieurs consommateurs ("actif-actif" ou "chaud-chaud") soit beaucoup plus typique que les consommateurs. en mode veille. <br><blockquote>  Ce comportement de distribution des messages, d√©crit ci-dessus, peut √™tre surprenant par rapport au comportement d'une file d'attente JMS standard.  Dans ce mod√®le, les messages envoy√©s √† la file d'attente seront r√©partis √©galement entre les deux consommateurs. </blockquote><br>  Le plus souvent, lorsque nous cr√©ons plusieurs instances de compilateurs, nous le faisons soit pour le traitement parall√®le des messages, soit pour augmenter la vitesse de lecture, soit pour augmenter la stabilit√© du processus de lecture.  √âtant donn√© qu'une seule instance d'un consommateur peut lire les donn√©es d'une partition, comment cela est-il possible dans Kafka? <br><br>  Une fa√ßon de proc√©der consiste √† utiliser une instance du consommateur pour lire tous les messages et les envoyer au pool de threads.  Bien que cette approche augmente le d√©bit de traitement, elle augmente la complexit√© de la logique des consommateurs et ne fait rien pour augmenter la stabilit√© du syst√®me de lecture.  Si une instance du consommateur s'√©teint en raison d'une panne de courant ou d'un √©v√©nement similaire, la relecture s'arr√™te. <br><br>  La mani√®re canonique de r√©soudre ce probl√®me dans Kafka est d'utiliser plus de partitions. <br><br><h3>  Partitionnement </h3><br>  Les partitions sont le principal m√©canisme de parall√©lisation de la lecture et de la mise √† l'√©chelle du sujet au-del√† de la bande passante d'une instance du courtier.  Pour mieux comprendre cela, examinons une situation o√π il existe un sujet avec deux partitions et un consommateur souscrit √† ce sujet ( <a href="">figure 3-5</a> ). <br><br><img src="https://habrastorage.org/webt/en/9g/ct/en9gct0o017cqp8buawguwlscty.png"><br>  <i>Figure 3-5.</i>  <i>Un consommateur lit √† partir de plusieurs partitions</i> <br><br>  Dans ce sc√©nario, le consultant obtient le contr√¥le sur les pointeurs correspondant √† son group_id dans les deux partitions et la lecture des messages des deux partitions commence. <br>  Lorsqu'un calculateur suppl√©mentaire est ajout√© √† cette rubrique pour le m√™me group_id, Kafka r√©affecte (r√©affecte) l'une des partitions de la premi√®re √† la seconde.  Apr√®s cela, chaque instance du consommateur sera soustraite d'une partition du sujet ( <a href="">figure 3-6</a> ). <br><br>  Pour vous assurer que les messages sont trait√©s en parall√®le dans 20 threads, vous aurez besoin d'au moins 20 partitions.  S'il y aura moins de partitions, vous aurez toujours des consommateurs qui n'ont rien √† travailler, comme d√©crit pr√©c√©demment dans la discussion sur les moniteurs exclusifs. <br><br><img src="https://habrastorage.org/webt/8b/a0/um/8ba0umn2yzr9yy3vztonhdfiub0.png"><br>  <i>Figure 3-6.</i>  <i>Deux consommateurs dans le m√™me groupe de consommateurs lisent √† partir de partitions diff√©rentes</i> <br><br>  Ce sch√©ma r√©duit consid√©rablement la complexit√© du courtier Kafka par rapport √† la distribution des messages n√©cessaire pour prendre en charge la file d'attente JMS.  Il n'est pas n√©cessaire de prendre soin des points suivants: <br><br><ul><li>  Quel consommateur devrait recevoir le message suivant en fonction de la distribution √† tour de r√¥le, de la capacit√© actuelle du tampon de pr√©lecture ou des messages pr√©c√©dents (comme pour les groupes de messages JMS). </li><li>  Quels messages ont √©t√© envoy√©s √† quels consommateurs et devraient-ils √™tre renvoy√©s en cas de d√©faillance. </li></ul><br>  Tout ce que le courtier Kafka doit faire est d'envoyer syst√©matiquement des messages au conseiller lorsque celui-ci le demande. <br><br>  Cependant, les exigences de parall√©lisation de la relecture et de la r√©exp√©dition des messages infructueux ne disparaissent pas - leur responsabilit√© passe simplement du courtier au client.  Cela signifie qu'ils doivent √™tre pris en compte dans votre code. <br><br><h2>  Envoi de messages </h2><br>  La responsabilit√© de d√©cider √† quelle partition envoyer le message est le producteur du message.  Pour comprendre le m√©canisme par lequel cela se fait, vous devez d'abord consid√©rer ce que nous envoyons r√©ellement. <br><br>  Alors que dans JMS, nous utilisons une structure de message avec des m√©tadonn√©es (en-t√™tes et propri√©t√©s) et un corps contenant une charge utile, dans Kafka, le message est <i>une paire cl√©-valeur</i> .  La charge utile du message est envoy√©e en tant que valeur.  Une cl√©, d'autre part, est principalement utilis√©e pour le partitionnement et doit contenir une <i>cl√© sp√©cifique</i> √† la <i>logique m√©tier</i> pour placer les messages associ√©s dans la m√™me partition. <br><br>  Dans le chapitre 2, nous avons discut√© du sc√©nario de paris en ligne, lorsque les √©v√©nements connexes doivent √™tre trait√©s dans l'ordre par un seul consommateur: <br><br><ol><li>  Le compte utilisateur est configur√©. </li><li>  L'argent est cr√©dit√© sur le compte. </li><li>  Un pari est effectu√© qui retire de l'argent du compte. </li></ol><br>  Si chaque √©v√©nement est un message envoy√© au sujet, alors dans ce cas l'identifiant du compte sera la cl√© naturelle. <br>  Lorsqu'un message est envoy√© √† l'aide de l'API Kafka Producer, il est transmis √† la fonction de partition qui, compte tenu du message et de l'√©tat actuel du cluster Kafka, renvoie l'identifiant de la partition √† laquelle le message doit √™tre envoy√©.  Cette fonctionnalit√© est impl√©ment√©e en Java via l'interface de partitionnement. <br><br>  Cette interface est la suivante: <br><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Partitioner</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">partition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String topic, Object key, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] keyBytes, Object value, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] valueBytes, Cluster cluster)</span></span></span></span>; }</code> </pre> <br>  L'impl√©mentation du partitionneur utilise l'algorithme de hachage √† usage g√©n√©ral par d√©faut sur la cl√© ou le tourniquet si la cl√© n'est pas sp√©cifi√©e pour d√©terminer la partition.  Cette valeur par d√©faut fonctionne bien dans la plupart des cas.  Cependant, √† l'avenir, vous voudrez peut-√™tre √©crire le v√¥tre. <br><br><h3>  √âcrire votre propre strat√©gie de partitionnement </h3><br>  Regardons un exemple lorsque vous souhaitez envoyer des m√©tadonn√©es avec la charge utile du message.  La charge utile dans notre exemple est une instruction pour effectuer un d√©p√¥t sur un compte de jeu.  Une instruction est quelque chose que nous voudrions garantir de ne pas modifier pendant la transmission, et nous voulons √™tre s√ªrs que seul un syst√®me sup√©rieur de confiance peut initier cette instruction.  Dans ce cas, les syst√®mes d'envoi et de r√©ception conviennent de l'utilisation de la signature pour authentifier le message. <br>  Dans un JMS standard, nous d√©finissons simplement la propri√©t√© de signature de message et l'ajoutons au message.  Cependant, Kafka ne nous fournit pas de m√©canisme de transmission des m√©tadonn√©es - uniquement la cl√© et la valeur. <br><br>  √âtant donn√© que la valeur est la charge utile d'un virement bancaire (charge utile de virement bancaire), dont nous voulons maintenir l'int√©grit√©, nous n'avons pas d'autre choix que de d√©terminer la structure de donn√©es √† utiliser dans la cl√©.  En supposant que nous ayons besoin d'un identifiant de compte pour le partitionnement, puisque tous les messages li√©s au compte doivent √™tre trait√©s dans l'ordre, nous proposerons la structure JSON suivante: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"signature"</span></span>: <span class="hljs-string"><span class="hljs-string">"541661622185851c248b41bf0cea7ad0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"accountId"</span></span>: <span class="hljs-string"><span class="hljs-string">"10007865234"</span></span> }</code> </pre> <br>  √âtant donn√© que la valeur de la signature variera en fonction de la charge utile, la strat√©gie de hachage de l'interface de partitionnement par d√©faut ne regroupera pas de mani√®re fiable les messages associ√©s.  Par cons√©quent, nous devrons r√©diger notre propre strat√©gie, qui analysera cette cl√© et partagera la valeur de accountId. <br><blockquote>  Kafka inclut des sommes de contr√¥le pour d√©tecter la corruption des messages dans le r√©f√©rentiel et dispose d'un ensemble complet de fonctionnalit√©s de s√©curit√©.  M√™me alors, des exigences sp√©cifiques √† l'industrie apparaissent parfois, comme celle ci-dessus. </blockquote><br>  La strat√©gie de partitionnement des utilisateurs doit garantir que tous les messages associ√©s se retrouvent dans la m√™me partition.  Bien que cela semble simple, l'exigence peut √™tre compliqu√©e en raison de l'importance de la commande des messages associ√©s et de la fa√ßon dont le nombre de partitions est fix√© dans le sujet. <br><br>  Le nombre de partitions dans le sujet peut changer au fil du temps, car elles peuvent √™tre ajout√©es si le trafic d√©passe les attentes initiales.  Ainsi, les cl√©s de message peuvent √™tre associ√©es √† la partition √† laquelle elles ont √©t√© envoy√©es √† l'origine, ce qui implique une partie de l'√©tat qui doit √™tre r√©partie entre les instances de producteur. <br><br>  Un autre facteur √† consid√©rer est la distribution uniforme des messages entre les partitions.  En r√®gle g√©n√©rale, les cl√©s ne sont pas r√©parties √©galement entre les messages et les fonctions de hachage ne garantissent pas une distribution √©quitable des messages pour un petit ensemble de cl√©s. <br>  Il est important de noter que, quelle que soit la fa√ßon dont vous d√©cidez de diviser les messages, le s√©parateur lui-m√™me peut devoir √™tre r√©utilis√©. <br><br>  Tenez compte de l'exigence de r√©plication des donn√©es entre les clusters Kafka dans diff√©rents emplacements g√©ographiques.  √Ä cet effet, Kafka est livr√© avec un outil en ligne de commande appel√© MirrorMaker, qui est utilis√© pour lire les messages d'un cluster et les transf√©rer vers un autre. <br><br>  MirrorMaker doit comprendre les cl√©s de la rubrique r√©pliqu√©e afin de maintenir l'ordre relatif entre les messages lors de la r√©plication entre les clusters, car le nombre de partitions pour cette rubrique peut ne pas co√Øncider dans deux clusters. <br><br>  Les strat√©gies de partitionnement personnalis√©es sont relativement rares, car les hachages par d√©faut ou le tourniquet fonctionnent avec succ√®s dans la plupart des sc√©narios.  Cependant, si vous avez besoin de garanties strictes de commande ou si vous devez extraire des m√©tadonn√©es des charges utiles, le partitionnement est quelque chose que vous devriez examiner de plus pr√®s. <br><br>  L'√©volutivit√© et les avantages de performance de Kafka proviennent du transfert de certaines responsabilit√©s d'un courtier traditionnel √† un client.  Dans ce cas, une d√©cision est prise sur la r√©partition des messages potentiellement li√©s entre plusieurs consommateurs travaillant en parall√®le. <br><blockquote>  Les courtiers JMS doivent √©galement r√©pondre √† ces exigences.  Fait int√©ressant, le m√©canisme d'envoi de messages li√©s au m√™me compte impl√©ment√© via les groupes de messages JMS (une sorte de strat√©gie d'√©quilibrage de charge r√©manente (SLB)) requiert √©galement que l'exp√©diteur marque les messages comme li√©s.  Dans le cas de JMS, le courtier est responsable de l'envoi de ce groupe de messages associ√©s √† l'un des nombreux clients et du transfert de propri√©t√© du groupe si le client est tomb√©. </blockquote><br><h2>  Accord avec le producteur </h2><br>  Le partitionnement n'est pas la seule chose √† consid√©rer lors de l'envoi de messages.  Examinons les m√©thodes send () de la classe Producer dans l'API Java: <br><br><pre> <code class="java hljs">Future &lt; RecordMetadata &gt; send(ProducerRecord &lt; K, V &gt; record); Future &lt; RecordMetadata &gt; send(ProducerRecord &lt; K, V &gt; record, Callback callback);</code> </pre> <br>  Il convient de noter tout de suite que les deux m√©thodes renvoient Future, ce qui indique que l'op√©ration d'envoi n'est pas effectu√©e imm√©diatement.  Par cons√©quent, il s'av√®re que le message (ProducerRecord) est √©crit dans le tampon d'envoi pour chaque partition active et transmis au courtier dans le flux d'arri√®re-plan de la biblioth√®que cliente Kafka.  Bien que cela rend le travail incroyablement rapide, cela signifie qu'une application inexp√©riment√©e peut perdre des messages si son processus est arr√™t√©. <br><br>  Comme toujours, il existe un moyen de rendre l'op√©ration d'envoi plus fiable en raison des performances.  La taille de ce tampon peut √™tre d√©finie sur 0 et le thread de l'application d'envoi sera oblig√© d'attendre que le message soit envoy√© au courtier, comme suit: <br><br><pre> <code class="java hljs">RecordMetadata metadata = producer.send(record).get();</code> </pre> <br><h2>  Encore une fois sur la lecture des messages </h2><br>  La lecture des messages pr√©sente des difficult√©s suppl√©mentaires qui doivent √™tre prises en compte.  Contrairement √† l'API JMS, qui peut d√©marrer un √©couteur de message en r√©ponse √† un message, l'interface <i>Consumer</i> Kafka interroge uniquement.  Examinons de plus pr√®s la m√©thode <i>poll ()</i> utilis√©e √† cet effet: <br><br><pre> <code class="java hljs">ConsumerRecords &lt; K, V &gt; poll(<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> timeout);</code> </pre> <br>  La valeur de retour de la m√©thode est une structure de conteneur contenant plusieurs objets <i>ConsumerRecord</i> provenant potentiellement de plusieurs partitions.  <i>Un ConsumerRecord</i> lui-m√™me est un objet d√©tenteur pour une paire cl√©-valeur avec des m√©tadonn√©es associ√©es, telles que la partition dont il est d√©riv√©. <br><br>  Comme indiqu√© au chapitre 2, nous devons constamment nous souvenir de ce qui arrive aux messages apr√®s leur traitement r√©ussi ou √©chou√©, par exemple, si le client ne peut pas traiter le message ou s'il interrompt le travail.  Dans JMS, cela a √©t√© g√©r√© via le mode d'accus√© de r√©ception.  Le courtier supprimera le message trait√© avec succ√®s ou remettra le message brut ou retourn√© (√† condition que des transactions aient √©t√© utilis√©es). <br>  Kafka fonctionne d'une mani√®re compl√®tement diff√©rente.  Les messages ne sont pas supprim√©s dans le courtier apr√®s la relecture et la responsabilit√© de ce qui se produit en cas d'√©chec incombe au code lui-m√™me. <br><br>  Comme nous l'avons d√©j√† dit, un groupe de consommateurs est associ√© √† une compensation dans le magazine.  La position du journal associ√©e √† ce biais correspond au message suivant qui sera √©mis en r√©ponse √† <i>poll ()</i> .  Crucial en lecture est le moment o√π ce d√©calage augmente. <br><br>  Revenant au mod√®le de lecture discut√© pr√©c√©demment, le traitement des messages comprend trois √©tapes: <br><br><ol><li>  R√©cup√©rez un message √† lire. </li><li>  Traitez le message. </li><li>  Confirmer le message. </li></ol><br>  Kafka Consumer Advisor est livr√© avec l' <i>option de</i> configuration <i>enable.auto.commit</i> .  Il s'agit d'un param√®tre par d√©faut couramment utilis√©, comme c'est g√©n√©ralement le cas avec les param√®tres contenant le mot ¬´auto¬ª. <br><br>  Avant Kafka 0.10, le client utilisant ce param√®tre envoyait le d√©calage du dernier message lu lors du prochain appel <i>poll ()</i> apr√®s le traitement.  Cela signifiait que tous les messages qui √©taient d√©j√† r√©cup√©r√©s pouvaient √™tre retrait√©s si le client les avait d√©j√† trait√©s, mais qu'ils √©taient d√©truits de mani√®re inattendue avant d'appeler <i>poll ()</i> .  √âtant donn√© que le courtier ne conserve aucun √©tat concernant le nombre de fois que le message a √©t√© lu, le prochain consommateur qui r√©cup√®re ce message ne saura pas que quelque chose de mauvais s'est produit.  Ce comportement √©tait pseudo transactionnel.  Le d√©calage n'a √©t√© valid√© qu'en cas de traitement r√©ussi du message, mais si le client a interrompu, le courtier a de nouveau envoy√© le m√™me message √† un autre client.  Ce comportement √©tait conforme √† la garantie de remise de message " <i>au moins une fois</i> ". <br><br>  Dans Kafka 0.10, le code client a √©t√© modifi√© de telle mani√®re que la validation a commenc√© √† √™tre p√©riodiquement lanc√©e par la biblioth√®que cliente, conform√©ment au param√®tre <i>auto.commit.interval.ms</i> .  Ce comportement se situe quelque part entre les modes JMS AUTO_ACKNOWLEDGE et DUPS_OK_ACKNOWLEDGE.  Lors de l'utilisation de la validation automatique, les messages pouvaient √™tre confirm√©s, qu'ils aient √©t√© r√©ellement trait√©s ou non - cela pouvait arriver dans le cas d'un consommateur lent.  Si le calculateur √©tait interrompu, les messages √©taient r√©cup√©r√©s par le prochain calculateur, √† partir d'une position s√©curis√©e, ce qui pouvait entra√Æner un saut de message.  Dans ce cas, Kafka n'a pas perdu de messages, le code de lecture ne les a tout simplement pas trait√©s. <br><br>  Ce mode a les m√™mes perspectives que dans la version 0.9: les messages peuvent √™tre trait√©s, mais en cas d'√©chec, le d√©calage peut ne pas √™tre ferm√©, ce qui pourrait potentiellement conduire √† une duplication de livraison.  Plus vous r√©cup√©rez de messages lorsque vous effectuez <i>poll ()</i> , plus ce probl√®me est important. <br><br>  Comme indiqu√© dans la section ¬´Soustraction de messages de la file d'attente¬ª du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">chapitre 2</a> , il n'y a rien de tel qu'une remise de message unique dans le syst√®me de messagerie, compte tenu des modes de d√©faillance. <br><br>  Dans Kafka, il existe deux fa√ßons de corriger (valider) un d√©calage (d√©calage): automatiquement et manuellement.  Dans les deux cas, les messages peuvent √™tre trait√©s plusieurs fois, dans le cas o√π le message a √©t√© trait√© mais a √©chou√© avant la validation.  Vous ne pouvez pas non plus traiter le message du tout si la validation s'est produite en arri√®re-plan et que votre code a √©t√© termin√© avant le d√©but du traitement (√©ventuellement dans Kafka 0.9 et les versions ant√©rieures). <br><br>  Vous pouvez contr√¥ler le processus de validation manuelle des d√©calages dans l'API Kafka <i>Consumer</i> en d√©finissant <i>enable.auto.commit</i> sur false et en appelant explicitement l'une des m√©thodes suivantes: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">commitSync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">commitAsync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br>  Si vous souhaitez traiter le message ¬´au moins une fois¬ª, vous devez valider le d√©calage manuellement √† l'aide de <i>commitSync ()</i> en ex√©cutant cette commande imm√©diatement apr√®s le traitement des messages. <br><br>  Ces m√©thodes ne permettent pas de traiter les messages accus√©s de r√©ception avant qu'ils ne soient trait√©s, mais ils ne font rien pour √©liminer la duplication potentielle du traitement, tout en cr√©ant l'apparence d'une transactionnalit√©.  Kafka n'a effectu√© aucune transaction.  Le client n'a pas la possibilit√© de faire ce qui suit: <br><br><ul><li>  Annulez automatiquement un message d'annulation.  Les consommateurs eux-m√™mes doivent g√©rer les exceptions r√©sultant de charges utiles et de d√©connexions dorsales, car ils ne peuvent pas compter sur le courtier pour renvoyer des messages. </li><li>  Envoyez des messages √† plusieurs sujets au sein d'une m√™me op√©ration atomique.  Comme nous le verrons bient√¥t, le contr√¥le de divers sujets et partitions peut √™tre localis√© sur diff√©rentes machines du cluster Kafka, qui ne coordonnent pas les transactions lors de l'envoi.  Au moment d'√©crire ces lignes, certains travaux ont √©t√© r√©alis√©s pour rendre cela possible avec le KIP-98. </li><li>  Associez la lecture d'un message d'un sujet √† l'envoi d'un autre message √† un autre sujet.  Encore une fois, l'architecture de Kafka d√©pend de nombreuses machines ind√©pendantes fonctionnant comme un seul bus et aucune tentative n'est faite pour le cacher.  Par exemple, aucun composant API ne permettrait de lier le <i>consommateur</i> et le <i>producteur</i> dans une transaction.  Dans JMS, cela est fourni par l'objet <i>Session √†</i> partir duquel <i>MessageProducers</i> et <i>MessageConsumers</i> sont cr√©√©s. </li></ul><br>  Si nous ne pouvons pas compter sur les transactions, comment pouvons-nous fournir une s√©mantique plus proche de celles fournies par les syst√®mes de messagerie traditionnels? <br><br>  S'il existe une possibilit√© que le d√©calage du consommateur augmente avant que le message n'ait √©t√© trait√©, par exemple lors de la d√©faillance du client, le client n'aura aucun moyen de savoir si le groupe de clients a manqu√© le message lorsque la partition est affect√©e.  Ainsi, une strat√©gie consiste √† rembobiner le d√©calage √† la position pr√©c√©dente.  L'API Kafka Consumer Advisor fournit les m√©thodes suivantes pour cela: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">seek</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TopicPartition partition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">seekToBeginning</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection &lt; TopicPartition &gt; partitions)</span></span></span></span>;</code> </pre> <br>  La m√©thode <i>seek ()</i> peut √™tre utilis√©e avec la m√©thode <br>  <i>offsetsForTimes (Map &lt;TopicPartition, Long&gt; timestampsToSearch)</i> pour revenir √† un √©tat √† un moment donn√© dans le pass√©. <br><br>  Implicitement, l'utilisation de cette approche signifie qu'il est tr√®s probable que certains messages qui ont √©t√© trait√©s pr√©c√©demment seront lus et trait√©s √† nouveau.  Pour √©viter cela, nous pouvons utiliser la lecture idempotente, comme d√©crit dans le chapitre 4, pour suivre les messages pr√©c√©demment consult√©s et √©liminer les doublons. <br><br>  Comme alternative, le code de votre consommateur peut √™tre simple si la perte ou la duplication de messages est autoris√©e.  Lorsque nous examinons les sc√©narios d'utilisation pour lesquels Kafka est g√©n√©ralement utilis√©, par exemple, le traitement des √©v√©nements du journal, des mesures, du suivi des clics, etc., nous comprenons que la perte de messages individuels est peu susceptible d'avoir un impact significatif sur les applications environnantes.  Dans de tels cas, les valeurs par d√©faut sont acceptables.  En revanche, si votre application doit transf√©rer des paiements, vous devez prendre soin de chaque message individuel.  Tout se r√©sume au contexte. <br><br>  Les observations personnelles montrent qu'avec l'augmentation de l'intensit√© du message, la valeur de chaque message individuel diminue.  Les messages √† volume √©lev√© ont tendance √† devenir pr√©cieux lorsqu'ils sont affich√©s sous forme agr√©g√©e. <br><br><h2>  Haute disponibilit√© </h2><br>  L'approche de haute disponibilit√© de Kafka est tr√®s diff√©rente d'ActiveMQ.  Kafka est d√©velopp√© sur la base de clusters √©volutifs horizontalement dans lesquels toutes les instances du courtier re√ßoivent et distribuent des messages simultan√©ment. <br><br>  Le cluster Kafka se compose de plusieurs instances de courtier s'ex√©cutant sur diff√©rents serveurs.  Kafka a √©t√© con√ßu pour fonctionner sur un mat√©riel autonome conventionnel, o√π chaque n≈ìud a son propre stockage d√©di√©.  L'utilisation du stockage en r√©seau (SAN) n'est pas recommand√©e car plusieurs n≈ìuds de calcul peuvent entrer en concurrence pour les intervalles de temps de stockage et cr√©er des conflits. <br><br>  Kafka est un syst√®me <i>constamment</i> activ√©.  De nombreux grands utilisateurs de Kafka n'√©teignent jamais leurs clusters et le logiciel fournit toujours des mises √† jour via un red√©marrage coh√©rent.  Ceci est r√©alis√© en garantissant la compatibilit√© avec la version pr√©c√©dente pour les messages et les interactions entre les courtiers. <br><br>  Les courtiers sont connect√©s √† un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cluster de</a> serveurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ZooKeeper</a> , qui agit comme un registre de configuration donn√© et est utilis√© pour coordonner les r√¥les de chaque courtier.  ZooKeeper lui-m√™me est un syst√®me distribu√© qui fournit une haute disponibilit√© gr√¢ce √† la r√©plication des informations en √©tablissant un <i>quorum</i> . <br><br>  Dans le cas de base, la rubrique est cr√©√©e dans le cluster Kafka avec les propri√©t√©s suivantes: <br><br><ul><li>  Le nombre de partitions.  Comme indiqu√© pr√©c√©demment, la valeur exacte utilis√©e ici d√©pend du niveau souhait√© de lecture simultan√©e. </li><li>  Le coefficient de r√©plication (facteur) d√©termine combien d'instances de courtier dans le cluster doivent contenir les journaux de cette partition. </li></ul><br>  En utilisant ZooKeepers pour la coordination, Kafka essaie de r√©partir √©quitablement les nouvelles partitions entre les courtiers du cluster.  Cette op√©ration est effectu√©e par une instance, qui agit en tant que contr√¥leur. <br><br>  Lors de l'ex√©cution <i>de chaque partition du sujet, le</i> <i>contr√¥leur</i> attribue au courtier les r√¥les de <i>leader</i> (leader, ma√Ætre, leader) et <i>followers</i> (followers, esclaves, subordonn√©s).  Le courtier, agissant en tant que leader de cette partition, est responsable de la r√©ception de tous les messages qui lui sont envoy√©s par les producteurs et de la distribution des messages aux consommateurs.  Lors de l'envoi de messages √† une partition de rubrique, ils sont r√©pliqu√©s sur tous les n≈ìuds du courtier agissant en tant que suiveurs pour cette partition.  Chaque n≈ìud contenant les journaux de la partition est appel√© <i>r√©plique</i> .  Un courtier peut agir en tant que leader pour certaines partitions et en tant que suiveur pour d'autres. <br><br>  Un suiveur contenant tous les messages stock√©s par le leader est appel√© une <i>r√©plique synchronis√©e</i> (une r√©plique dans un √©tat synchronis√©, une r√©plique synchronis√©e).  Si le courtier agissant en tant que leader de la partition est d√©connect√©, tout courtier qui est dans l'√©tat mis √† jour ou synchronis√© pour cette partition peut assumer le r√¥le de leader.  Il s'agit d'un design incroyablement durable. <br><br>  Une partie de la configuration du producteur est le param√®tre <i>acks</i> , qui d√©termine le nombre de r√©pliques qui doivent accuser r√©ception d'un message avant que le flux d'application continue √† envoyer: 0, 1 ou tous.  Si la valeur est d√©finie sur <i>all</i> , le leader enverra une confirmation au producteur d√®s r√©ception du message d√®s qu'il recevra la confirmation de l'enregistrement de plusieurs r√©pliques (y compris lui-m√™me) d√©finies par le <i>param√®tre de</i> rubrique <i>min.insync.replicas</i> (par d√©faut 1).  Si le message ne peut pas √™tre r√©pliqu√© avec succ√®s, le producteur <i>l√®vera</i> une exception pour l'application ( <i>NotEnoughReplicas</i> ou <i>NotEnoughReplicasAfterAppend</i> ). <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans une configuration typique, une rubrique est cr√©√©e avec un coefficient de r√©plication de 3 (1 leader, 2 suiveurs pour chaque partition) et le param√®tre </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">min.insync.replicas est</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> d√©fini sur 2. Dans ce cas, le cluster permettra √† l'un des courtiers g√©rant la partition d'√™tre d√©connect√© sans affecter les applications clientes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela nous ram√®ne au compromis d√©j√† familier entre performances et fiabilit√©. La r√©plication se produit en raison du temps d'attente suppl√©mentaire pour les accus√©s de r√©ception (accus√©s de r√©ception) des abonn√©s. Bien qu'elle s'ex√©cute en parall√®le, la r√©plication d'au moins trois n≈ìuds a les m√™mes performances que deux (en ignorant l'augmentation de l'utilisation de la bande passante r√©seau).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En utilisant ce sch√©ma de r√©plication, Kafka √©vite intelligemment la n√©cessit√© d'√©crire physiquement chaque message sur le disque en utilisant l'op√©ration </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sync ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Chaque message envoy√© par le producteur sera √©crit dans le journal de partition, mais, comme expliqu√© au chapitre 2, l'√©criture dans le fichier est initialement effectu√©e dans le tampon du syst√®me d'exploitation. Si ce message est r√©pliqu√© sur une autre instance de Kafka et est dans sa m√©moire, la perte d'un leader ne signifie pas que le message lui-m√™me a √©t√© perdu - une r√©plique synchronis√©e peut le prendre sur lui. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√©sactiver le fonctionnement </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sync ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">signifie que Kafka peut recevoir des messages √† la vitesse avec laquelle il peut les √©crire en m√©moire. Inversement, plus vous √©vitez de vider la m√©moire sur le disque, mieux c'est. Pour cette raison, il n'est pas rare que les courtiers Kafka allouent 64 Go ou plus de m√©moire. Cette utilisation de la m√©moire signifie qu'une instance de Kafka peut facilement fonctionner √† des vitesses plusieurs milliers de fois plus rapides qu'un courtier de messages traditionnel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kafka peut √©galement √™tre configur√© pour utiliser </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sync ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aux packages de messages. √âtant donn√© que tout chez Kafka est orient√© package, il fonctionne plut√¥t bien pour de nombreux cas d'utilisation et est un outil utile pour les utilisateurs qui ont besoin de garanties tr√®s solides. La plupart des performances pures de Kafka sont li√©es aux messages envoy√©s au courtier sous forme de paquets et au fait que ces messages sont lus √† partir du courtier par blocs successifs √† l'aide d' </font><font style="vertical-align: inherit;">op√©rations de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">copie nulle</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (op√©rations qui n'effectuent pas la t√¢che de copier des donn√©es d'une zone m√©moire vers un autre). Ce dernier est un gros gain en termes de performances et de ressources et n'est possible que gr√¢ce √† l'utilisation de la structure de donn√©es de journal sous-jacente qui d√©finit le sch√©ma de partition.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dans un cluster Kafka, des performances beaucoup plus √©lev√©es sont possibles que lors de l'utilisation d'un seul courtier Kafka, car les partitions de rubrique peuvent √™tre mises √† l'√©chelle horizontalement sur de nombreuses machines distinctes. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R√©sum√© </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans ce chapitre, nous avons examin√© comment l'architecture Kafka r√©interpr√®te la relation entre les clients et les courtiers pour fournir un pipeline de messagerie incroyablement robuste, avec une bande passante plusieurs fois sup√©rieure √† celle d'un courtier de messages classique. Nous avons discut√© de la fonctionnalit√© qu'il utilise pour atteindre cet objectif et bri√®vement examin√© l'architecture des applications qui fournissent cette fonctionnalit√©. Dans le chapitre suivant, nous discuterons des probl√®mes courants que les applications de messagerie doivent r√©soudre et discuterons des strat√©gies pour les r√©soudre. Nous concluons le chapitre en d√©crivant comment parler des technologies de messagerie en g√©n√©ral afin que vous puissiez √©valuer leur ad√©quation √† vos cas d'utilisation. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Traduction termin√©e: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tele.gg/middle_java</font></font></a></b> <br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √Ä suivre ...</font></font></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr466585/">https://habr.com/ru/post/fr466585/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr466575/index.html">Passer des listes bidimensionnelles de python √† DLL</a></li>
<li><a href="../fr466577/index.html">Comment deux √©tudiants ont cr√©√© le jeu sous iOS et combien ils y ont gagn√©</a></li>
<li><a href="../fr466579/index.html">L'histoire des algorithmes de randomisation Tetris</a></li>
<li><a href="../fr466581/index.html">Le darwinisme quantique: une id√©e expliquant la r√©alit√© objective passe le premier test</a></li>
<li><a href="../fr466583/index.html">Une br√®ve histoire du d√©tecteur de mensonge</a></li>
<li><a href="../fr466587/index.html">Variables CSS et th√®me de couleur pour le site en plusieurs lignes</a></li>
<li><a href="../fr466589/index.html">Comment recevoir des donn√©es de Google Analytics √† l'aide de R dans Microsoft SQL Server</a></li>
<li><a href="../fr466591/index.html">MVC sans C: Qu'est-ce qui changera SwiftUI dans l'architecture d'application?</a></li>
<li><a href="../fr466593/index.html">Situation: perspectives du cloud hybride et de l'IaaS</a></li>
<li><a href="../fr466597/index.html">Historique de la deuxi√®me place dans la Mini AI Cup 4: Paper IO</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>