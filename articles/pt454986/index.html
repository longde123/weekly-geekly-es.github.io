<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙇🏾 🤗 👩🏿‍🤝‍👩🏽 Introdução às redes neurais convolucionais 👨‍🔧 👐 🈴</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O curso completo em russo pode ser encontrado neste link . 
 O curso de inglês original está disponível neste link . 


 Novas palestras são agendadas...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Introdução às redes neurais convolucionais</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454986/"> O curso completo em russo pode ser encontrado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste link</a> . <br>  O curso de inglês original está disponível <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste link</a> . <br><br><img src="https://habrastorage.org/webt/uh/pm/jt/uhpmjticdnfsyigvpgkhb0t-a4s.png"><br>  <i>Novas palestras são agendadas a cada 2-3 dias.</i> <br><a name="habracut"></a><br><h2>  Entrevista com Sebastian </h2><br>  - Então, estamos novamente com Sebastian na terceira parte deste curso.  Sebastian, eu sei que você fez muito desenvolvimento usando redes neurais convolucionais.  Você pode nos contar um pouco mais sobre essas redes e quais são elas?  Estou certo de que os alunos do nosso curso ouvirão com menos interesse, porque nesta parte eles terão que desenvolver a rede neural convolucional. <br>  Ótimo!  Assim, as redes neurais convolucionais são uma excelente maneira de estruturar a rede, construindo a chamada invariância (alocação de recursos imutáveis).  Por exemplo, considere a idéia de reconhecimento de padrões no palco ou na fotografia, você quer entender se Sebastian está ou não representado.  Não importa em que parte da fotografia eu estou, onde minha cabeça está localizada - no centro da fotografia ou no canto.  Reconhecimento da minha cabeça, meu rosto deve ocorrer independentemente de onde eles estão localizados na imagem.  Isso é invariância, variabilidade de localização, que é realizada por redes neurais convolucionais. <br>  Muito interessante!  Você pode nos dizer as principais tarefas nas quais as redes neurais convolucionais são usadas? <br>  - As redes neurais convolucionais são bastante usadas quando se trabalha com áudio e vídeo, incluindo imagens médicas.  Eles também são usados ​​em tecnologias de linguagem, onde especialistas usam aprendizado profundo para entender e reproduzir construções de linguagem.  De fato, existem muitas aplicações para essa tecnologia, eu diria mesmo que são infinitas!  Sua tecnologia pode ser usada em finanças e em outras áreas. <br>  "Eu usei redes neurais convolucionais para analisar imagens de satélite." <br>  Ótimo!  A tarefa padrão! <br>  - Em sua opinião, podemos considerar as redes neurais convolucionais como a última e mais avançada ferramenta no desenvolvimento da aprendizagem profunda? <br>  Ha!  Eu já aprendi a nunca dizer nunca.  Sempre haverá algo novo e incrível! <br>  "Então ainda temos trabalho a fazer?"  :) <br>  - Haverá trabalho suficiente! <br>  Excelente!  Neste curso, estamos apenas ensinando futuros pioneiros em aprendizado de máquina.  Você deseja seus alunos antes que eles comecem a construir sua primeira rede neural convolucional? <br>  - Aqui está um fato interessante para você.  As redes neurais convolucionais foram inventadas em 1989, e isso faz muito tempo!  A maioria de vocês nem nasceu naquela época, o que significa que não é o gênio do algoritmo que importa, mas os dados nos quais esse algoritmo opera.  Vivemos em um mundo onde existem muitos dados para analisar e procurar padrões.  Temos a capacidade de emular as funções da mente humana usando essa enorme quantidade de dados.  Quando você trabalha em redes neurais convolucionais, tente se concentrar em encontrar os dados corretos e aplicá-los - veja o que acontece e, às vezes, pode ser uma verdadeira mágica, como foi o caso em nosso caso quando estávamos resolvendo o problema de detectar o câncer de pele. <br>  Ótimo!  Bem, vamos finalmente à mágica! <br><br><h2>  1. Introdução </h2><br>  Na última lição, aprendemos como desenvolver redes neurais profundas capazes de classificar imagens de elementos de vestuário a partir do conjunto de dados Fashion MNIST. <br><br><img src="https://habrastorage.org/webt/v5/tt/hk/v5tthkilik-9reer8owxjpv-x3m.png"><br><br>  Os resultados obtidos durante o trabalho na rede neural foram impressionantes - 88% de precisão na classificação.  E isso está em algumas linhas de código (sem levar em conta o código para a construção de gráficos e imagens)! <br><br><pre><code class="python hljs">model = tf.keras.Sequential([ tf.keras.layers.Flatten(input_shape=(<span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)), tf.keras.layers.Dense(<span class="hljs-number"><span class="hljs-number">128</span></span>, activation=tf.nn.relu), tf.keras.layers.Dense(<span class="hljs-number"><span class="hljs-number">10</span></span>, activation=tf.nn.softmax) ])</code> </pre> <br><pre> <code class="python hljs">model.compile(optimizer=<span class="hljs-string"><span class="hljs-string">'adam'</span></span>, loss=<span class="hljs-string"><span class="hljs-string">'sparse_categorical_crossentropy'</span></span>, metrics=[<span class="hljs-string"><span class="hljs-string">'accuracy'</span></span>])</code> </pre><br><pre> <code class="python hljs">NUM_EXAMPLES = <span class="hljs-number"><span class="hljs-number">60000</span></span> train_dataset = train_dataset.repeat().shuffle(NUM_EXAMPLES).batch(<span class="hljs-number"><span class="hljs-number">32</span></span>) test_dataset = test_dataset.batch(<span class="hljs-number"><span class="hljs-number">32</span></span>)</code> </pre><br><pre> <code class="python hljs">model.fit(train_dataset, epochs=<span class="hljs-number"><span class="hljs-number">5</span></span>, steps_per_epoch=math.ceil(num_train_examples/<span class="hljs-number"><span class="hljs-number">32</span></span>))</code> </pre><br><pre> <code class="python hljs">test_loss, test_accuracy = model.evaluate(test_dataset, steps=math.ceil(num_test_examples/<span class="hljs-number"><span class="hljs-number">32</span></span>)) print(<span class="hljs-string"><span class="hljs-string">': '</span></span>, test_accuracy)</code> </pre><br> <code>: 0.8782 <br></code> <br>  Também experimentamos o efeito do número de neurônios em camadas ocultas e o número de iterações de treinamento na precisão do modelo.  Mas como tornamos esse modelo ainda melhor e mais preciso?  Uma maneira de conseguir isso é usar redes neurais convolucionais, abreviada para SNA.  O SNA mostra maior precisão na resolução dos problemas de classificação de imagens do que as redes neurais padrão totalmente conectadas que encontramos nas classes anteriores.  É por esse motivo que o SNA se tornou tão popular e foi graças a eles que se tornou possível uma inovação tecnológica no campo da visão de máquina. <br><br>  Nesta lição, aprenderemos como é fácil desenvolver um classificador SNA do zero usando o TensorFlow e o Keras.  Usaremos o mesmo conjunto de dados do Fashion MNIST que usamos na lição anterior.  No final desta lição, comparamos a precisão da classificação dos elementos de vestuário da rede neural anterior com a rede neural convolucional desta lição. <br><br>  Antes de mergulhar no desenvolvimento, vale a pena aprofundar um pouco o princípio de funcionamento das redes neurais convolucionais. <br><br>  Dois conceitos básicos em redes neurais convolucionais: <br><br><ul><li>  convolução </li><li>  operação de subamostragem (pooling, max pooling) </li></ul><br><br>  Vamos dar uma olhada neles. <br><br><h2>  Convolução </h2><br>  Nesta parte da lição, aprenderemos uma técnica chamada convolução.  Vamos ver como isso funciona. <br><br>  Tire uma imagem em tons de cinza e, por exemplo, imagine que suas dimensões são 6 px de altura e 6 px de largura. <br><br><img src="https://habrastorage.org/webt/jd/rh/6y/jdrh6y3zzszxmhixrfnaxmndr-m.png"><br><br>  Nosso computador interpreta a imagem como uma matriz bidimensional de pixels.  Como nossa imagem está em tons de cinza, o valor de cada pixel estará no intervalo de 0 a 255. 0 - preto, 255 - branco. <br><br>  Na imagem abaixo, vemos uma representação da imagem 6px x 6px e os valores de pixel correspondentes: <br><br><img src="https://habrastorage.org/webt/qz/mw/jd/qzmwjdfjxnu88pat92ciearc4ng.png"><br><br>  Como você já sabe, antes de trabalhar com imagens, é necessário normalizar os valores de pixel - traga os valores para um intervalo de 0 a 1. No entanto, neste exemplo, para facilitar a explicação, salvaremos os valores de pixel da imagem e não os normalizaremos. <br><br>  A essência da convolução é criar outro conjunto de valores, chamado de kernel ou filtro.  Um exemplo pode ser visto na imagem abaixo - uma matriz 3 x 3: <br><br><img src="https://habrastorage.org/webt/16/8x/g0/168xg0hysoiy8pwlygw-nxmw-ck.png"><br><br>  Então podemos digitalizar nossa imagem usando o kernel.  As dimensões da nossa imagem são 6x6px e os núcleos são 3x3px.  A camada convolucional é aplicada ao núcleo e a cada seção da imagem de entrada. <br><br>  Vamos imaginar que queremos convolver sobre um pixel com um valor de 25 (3 linhas, 3 colunas) e a primeira coisa que precisa ser feita é centralizar o núcleo sobre esse pixel: <br><br><img src="https://habrastorage.org/webt/dt/qs/5x/dtqs5xle8lhrv0h504wbk3gzgnw.png"><br><br>  Na imagem, o posicionamento do núcleo é destacado em amarelo.  Agora, examinaremos apenas os valores de pixel que estão em nosso retângulo amarelo, cujos tamanhos correspondem aos tamanhos do nosso núcleo de convolução. <br><br>  Agora pegamos os valores de pixel da imagem e do kernel, multiplicamos cada pixel da imagem pelo pixel correspondente do kernel e adicionamos todos os valores do produto e atribuímos o valor de pixel resultante à nova imagem. <br><br><img src="https://habrastorage.org/webt/tz/xe/oc/tzxeocatpow2ytacpikwfpj--w8.png"><br><br><img src="https://habrastorage.org/webt/eu/ty/tj/eutytjlyn4js82ry704lkaz6gpq.png"><br><br><img src="https://habrastorage.org/webt/x5/3k/hs/x53khs1exvxwdbmn2mnxihg2wxa.png"><br><br>  Realizamos uma operação semelhante com todos os pixels em nossa imagem.  Mas o que deveria acontecer com os pixels nas bordas? <br><br><img src="https://habrastorage.org/webt/2h/af/nf/2hafnfev-ft4bioova_jjepqby4.png"><br><br>  Existem várias soluções.  Primeiramente, podemos simplesmente ignorar esses pixels, mas, neste caso, perderemos informações sobre a imagem, que podem ser significativas, e a imagem minimizada se tornará menor que a original.  Em segundo lugar, podemos simplesmente "matar", com zero valor, os pixels cujos valores principais estão além do escopo da imagem.  O processo é chamado alinhamento. <br><br><img src="https://habrastorage.org/webt/fc/wa/1s/fcwa1sx3ekaufxf0zzstuzzk7bo.png"><br><br>  Agora que fizemos o alinhamento com valores de zero pixel, podemos calcular o valor do pixel final na imagem minimizada como antes. <br><br>  Uma convolução é o processo de aplicação de um núcleo (filtro) a cada parte da imagem de entrada; por analogia com uma camada totalmente conectada (camada densa), veremos que a convolução é a mesma camada em Keras. <br><br>  Agora, vejamos o segundo conceito de redes neurais convolucionais - a operação de subamostragem (pooling, max-pooling). <br><br><h2>  Operação de subamostragem (pool, max-pooling) </h2><br>  Agora, consideraremos o segundo conceito fundamental subjacente às redes neurais convolucionais - a operação de subamostragem (pooling, max-pooling).  Em palavras simples, uma operação de subamostragem é o processo de compactar (reduzir o tamanho) de uma imagem adicionando os valores dos blocos de pixels.  Vamos ver como isso funciona em um exemplo concreto. <br><br><img src="https://habrastorage.org/webt/ya/d4/31/yad431do5fnnuwenxqlv7sxkq2g.png"><br><br>  Para executar a operação de subamostragem, precisamos decidir sobre dois componentes desse processo - o tamanho da amostra (o tamanho da grade retangular) e o tamanho da etapa.  Neste exemplo, usaremos uma grade retangular 3x3 e a etapa 3. A etapa determina o número de pixels pelos quais a grade retangular deve ser deslocada ao executar a operação de subamostragem. <br><br>  Depois de decidirmos o tamanho da grade e o tamanho da etapa, precisamos encontrar o valor máximo de pixel que cai na grade selecionada.  No exemplo acima, os valores 1, 0, 4, 8, 2, 5, 20, 13, 25 caem na grade.O valor máximo é 25. Esse valor é "transferido" para a nova imagem.  A grade é deslocada 3 pixels para a direita e o processo de seleção do valor máximo e transferência para uma nova imagem é repetido. <br><br><img src="https://habrastorage.org/webt/ht/o0/ef/hto0efftnhidlrtascm-p3gqb_m.png"><br><br>  Como resultado, uma imagem menor será obtida em comparação com a imagem de entrada original.  No nosso exemplo, foi obtida uma imagem com metade do tamanho da imagem original.  O tamanho da imagem final varia dependendo da escolha do tamanho da grade retangular e do tamanho da etapa. <br><br>  Vamos ver como isso funcionará no Python! <br><br><h2>  Sumário </h2><br>  Familiarizamos-nos com conceitos como convolução e operação de pool máximo. <br><br>  Convolução é o processo de aplicação de um filtro ("núcleo") em uma imagem.  A operação de subamostragem por valor máximo é o processo de redução do tamanho de uma imagem combinando um grupo de pixels em um único valor máximo desse grupo. <br><br>  Como veremos na parte prática, a camada convolucional pode ser adicionada à rede neural usando a camada <code>Conv2D</code> em Keras.  Essa camada é semelhante à camada Densa e contém pesos e compensações que passam por otimização (seleção).  <code>Conv2D</code> camada <code>Conv2D</code> também contém filtros ("kernels"), cujos valores também são otimizados.  Portanto, na camada <code>Conv2D</code> , os valores dentro da matriz de filtro são as variáveis ​​que sofrem otimização. <br><br>  Alguns termos que conseguimos encontrar: <br><br><ul><li>  <b>SNS</b> - redes neurais convolucionais.  Uma rede neural que contém pelo menos uma camada convolucional.  Um SNA típico contém outras camadas, como camadas de amostra e totalmente conectadas. </li><li>  <b>Convolução</b> é o processo de aplicação de um filtro ("núcleo") em uma imagem. </li><li>  <b>Um filtro (núcleo)</b> é uma matriz de tamanho menor que os dados de entrada, destinada à conversão de dados de entrada em blocos. </li><li>  <b>Alinhamento</b> é o processo de adicionar, na maioria das vezes zero valores, às bordas de uma imagem. </li><li>  <b>A operação de subamostragem</b> é o processo de redução do tamanho de uma imagem através da amostragem.  Existem vários tipos de camadas de subamostragem, por exemplo, uma camada de subamostragem média (amostragem de um valor médio); no entanto, uma subamostragem pelo valor máximo é mais frequentemente usada. </li><li>  <b>A subamostragem pelo valor máximo</b> é o processo de subamostragem, durante o qual muitos valores são convertidos em um único valor - o máximo entre a amostragem. </li><li>  <b>Etapa</b> - o número de pixels de deslocamento pelo filtro (núcleo) na imagem. </li><li>  <b>Amostragem (downsampling)</b> - o processo de redução do tamanho da imagem. </li></ul><br><h2>  CoLab: classificação de elementos de vestuário Fashion MNIST usando uma rede neural convolucional </h2><br>  Estávamos circulados em torno de um dedo!  Faz sentido executar essa parte prática somente após a conclusão da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">parte anterior</a> - todo o código, exceto um bloco, permanece o mesmo.  A estrutura de nossa rede neural está mudando, e essas são quatro linhas adicionais para camadas neurais convolucionais e camadas de subamostragem no valor máximo (pool máximo). <br><br><pre> <code class="python hljs">model = tf.keras.Sequential([ tf.keras.layers.Conv2D(<span class="hljs-number"><span class="hljs-number">32</span></span>, (<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>), padding=<span class="hljs-string"><span class="hljs-string">'same'</span></span>, activation=tf.nn.relu, input_shape=(<span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)), tf.keras.layers.MaxPooling2D((<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), strides=<span class="hljs-number"><span class="hljs-number">2</span></span>), tf.keras.layers.Conv2D(<span class="hljs-number"><span class="hljs-number">64</span></span>, (<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>), padding=<span class="hljs-string"><span class="hljs-string">'same'</span></span>, activation=tf.nn.relu), tf.keras.layers.MaxPooling2D((<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), strides=<span class="hljs-number"><span class="hljs-number">2</span></span>), tf.keras.layers.Flatten(), tf.keras.layers.Dense(<span class="hljs-number"><span class="hljs-number">128</span></span>, activation=tf.nn.relu), tf.keras.layers.Dense(<span class="hljs-number"><span class="hljs-number">10</span></span>, activation=tf.nn.softmax) ])</code> </pre><br>  Todas as explicações detalhadas de como trabalhar, elas prometem nos dar na próxima parte - 4 partes. <br><br>  Ah sim.  A precisão do modelo na fase de treinamento tornou-se igual a 97% (o modelo “treinado” nas <code>epochs=10</code> ) e, ao executar o conjunto de dados para os testes, mostrou exatamente 91%.  Um aumento notável na precisão em relação à arquitetura anterior, onde usamos apenas camadas totalmente conectadas - 88%. <br><br><h2>  Sumário </h2><br>  Nesta parte da lição, estudamos um novo tipo de rede neural - rede neural convolucional.  Nós nos familiarizamos com termos como “convolução” e “operação de pool máximo”, desenvolvemos e treinamos uma rede neural convolucional a partir do zero.  Como resultado, vimos que nossa rede neural convolucional produz mais precisão do que a rede neural que desenvolvemos na última lição. <br><br>  Nota do autor da tradução. <br><br>  O curso é chamado "Introdução à aprendizagem profunda usando o TensorFlow", portanto, não vamos reclamar da falta de explicações detalhadas do princípio das redes neurais convolucionais (camadas) - os próximos dois artigos serão sobre o princípio de operação da rede neural convolucional e sua estrutura interna (os artigos não estão relacionados ao curso, mas foram recomendados pelos participantes do StackOverflow para uma melhor compreensão do que está acontecendo). <br><br>  ... e call to action padrão - inscreva-se, coloque um plus e compartilhe :) <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">YouTube</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Telegram</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">VKontakte</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt454986/">https://habr.com/ru/post/pt454986/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt454974/index.html">Lockheed Martin patenteia impressão 3D com diamante</a></li>
<li><a href="../pt454976/index.html">Max Patrol 8. Visão geral da ferramenta de gerenciamento de vulnerabilidades</a></li>
<li><a href="../pt454978/index.html">Um bug no Linux 5.1 levou à perda de dados - um patch de correção já foi lançado</a></li>
<li><a href="../pt454980/index.html">O que havia no primeiro iPod: vinte álbuns que Steve Jobs escolheu em 2001</a></li>
<li><a href="../pt454982/index.html">Como colocamos a amostragem no SIBUR em novas faixas</a></li>
<li><a href="../pt454990/index.html">“É aconselhável que você tenha um gato” - como uma startup pode atirar no Product Hunt</a></li>
<li><a href="../pt454994/index.html">Quais são as vantagens do carregamento sem fio e por que o futuro está por trás disso? Experiência pessoal para 2019</a></li>
<li><a href="../pt454996/index.html">Cosmonaut Training Center com o nome de Yu.A. Gagarin e Roscosmos começaram o recrutamento aberto para a equipe de cosmonautas</a></li>
<li><a href="../pt454998/index.html">Julia e computação paralela</a></li>
<li><a href="../pt455000/index.html">Mudança cuidadosa para a Holanda com sua esposa. Parte 3: trabalho, colegas e outras formas de vida</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>