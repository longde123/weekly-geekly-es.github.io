<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïµüèæ üîµ üèáüèø MotionLayout: as anima√ß√µes s√£o melhores, menos c√≥digo üë©üèø‚Äçüéì üßóüèª üï∞Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O Google continua a melhorar nossas vidas, lan√ßando novas bibliotecas e APIs √∫teis. Entre os quais estava o novo MotionLayout. Dada a abund√¢ncia de an...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MotionLayout: as anima√ß√µes s√£o melhores, menos c√≥digo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/458854/"><img src="https://habrastorage.org/webt/wk/q7/cq/wkq7cqwqisgnz3lof9qfobt5bte.png"><br>  <i>O Google continua a melhorar nossas vidas, lan√ßando novas bibliotecas e APIs √∫teis.</i>  <i>Entre os quais estava o novo MotionLayout.</i>  <i>Dada a abund√¢ncia de anima√ß√µes em nossos aplicativos, meu colega Cedric Holtz implementou imediatamente a anima√ß√£o mais importante de nosso aplicativo - votar em namoro - usando a nova API, economizando uma quantidade enorme de c√≥digo.</i>  <i>Eu compartilho a tradu√ß√£o do artigo dele.</i> <br><br>  A confer√™ncia Google I / O 2019 terminou recentemente, na qual foram anunciadas atualiza√ß√µes e as mais recentes melhorias em nosso amado SDK.  Pessoalmente, fiquei particularmente interessado na apresenta√ß√£o de Nicholas Road e John Hoford sobre a funcionalidade futura do ConstraintLayout.  Mais especificamente, sobre sua expans√£o na forma de MotionLayout. <br><br>  Ap√≥s o lan√ßamento da vers√£o beta, eu queria implementar uma anima√ß√£o de namoro com base nesta biblioteca. <a name="habracut"></a><br><br>  Primeiro, vamos definir os termos: <br><br><blockquote>  "MotionLayout √© um ConstraintLayout que permite animar layouts entre diferentes estados."  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Documenta√ß√£o</a> </blockquote><br><br>  Se voc√™ n√£o leu uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">s√©rie de artigos de</a> Nicholas Road que explica as principais id√©ias do MotionLayout, eu recomendo a leitura. <br><br>  Ent√£o, com a introdu√ß√£o feita, agora vamos ver o que queremos obter: <br><br><img src="https://habrastorage.org/webt/wm/kb/qm/wmkbqmy_ulwafy_jvkvpadfafyu.gif"><br><br><h2>  Pilha de cart√µes </h2><br><h3>  Mostramos o mapa deslocado </h3><br>  Para come√ßar, adicione MotionLayout ao diret√≥rio de layout, que at√© agora cont√©m apenas um cart√£o superior: <br><br><pre><code class="kotlin hljs">&lt;androidx.constraintlayout.motion.widget.MotionLayout android:id=<span class="hljs-string"><span class="hljs-string">"@+id/motionLayout"</span></span>     xmlns:android=<span class="hljs-string"><span class="hljs-string">"http://schemas.android.com/apk/res/android"</span></span>     xmlns:app=<span class="hljs-string"><span class="hljs-string">"http://schemas.android.com/apk/res-auto"</span></span>     android:layout_width=<span class="hljs-string"><span class="hljs-string">"match_parent"</span></span>     android:layout_height=<span class="hljs-string"><span class="hljs-string">"match_parent"</span></span>     app:layoutDescription=<span class="hljs-string"><span class="hljs-string">"@xml/scene_swipe"</span></span>     app:motionDebug=<span class="hljs-string"><span class="hljs-string">"SHOW_ALL"</span></span>&gt;     &lt;FrameLayout         android:id=<span class="hljs-string"><span class="hljs-string">"@+id/topCard"</span></span>         android:layout_width=<span class="hljs-string"><span class="hljs-string">"0dp"</span></span>         android:layout_height=<span class="hljs-string"><span class="hljs-string">"0dp"</span></span> /&gt; &lt;/androidx.constraintlayout.motion.widget.MotionLayout&gt;</code> </pre> <br>  Preste aten√ß√£o a esta linha: app: motionDebug = "SHOW_ALL".  Ele nos permite exibir informa√ß√µes de depura√ß√£o, a trajet√≥ria dos objetos, os estados com o in√≠cio e o final da anima√ß√£o, bem como o progresso atual.  A linha ajuda muito na depura√ß√£o, mas n√£o esque√ßa de exclu√≠-la antes de envi√°-la ao produto: n√£o h√° lembrete disso. <br><br>  Como voc√™ pode ver, n√£o definimos nenhuma restri√ß√£o para a exibi√ß√£o aqui.  Eles ser√£o tirados da cena (MotionScene), que agora definimos. <br><br>  Vamos come√ßar definindo o estado inicial: um cart√£o fica no centro da tela, com recuos ao redor. <br><br><pre> <code class="kotlin hljs">&lt;MotionScene xmlns:android=<span class="hljs-string"><span class="hljs-string">"http://schemas.android.com/apk/res/android"</span></span>    xmlns:app=<span class="hljs-string"><span class="hljs-string">"http://schemas.android.com/apk/res-auto"</span></span>&gt;    &lt;ConstraintSet android:id=<span class="hljs-string"><span class="hljs-string">"@+id/rest"</span></span>&gt;        &lt;Constraint            android:id=<span class="hljs-string"><span class="hljs-string">"@id/topCard"</span></span>            android:layout_width=<span class="hljs-string"><span class="hljs-string">"match_parent"</span></span>            android:layout_height=<span class="hljs-string"><span class="hljs-string">"match_parent"</span></span>            android:layout_marginBottom=<span class="hljs-string"><span class="hljs-string">"50dp"</span></span>            android:layout_marginEnd=<span class="hljs-string"><span class="hljs-string">"50dp"</span></span>            android:layout_marginStart=<span class="hljs-string"><span class="hljs-string">"50dp"</span></span>            android:layout_marginTop=<span class="hljs-string"><span class="hljs-string">"50dp"</span></span>            app:layout_constraintEnd_toEndOf=<span class="hljs-string"><span class="hljs-string">"parent"</span></span>            app:layout_constraintStart_toStartOf=<span class="hljs-string"><span class="hljs-string">"parent"</span></span>&gt;    &lt;/ConstraintSet&gt; &lt;/MotionScene&gt;</code> </pre> <br>  Adicione conjuntos de restri√ß√µes (ConstraintSet) e passe.  Eles refletir√£o o estado do cart√£o superior quando ele for completamente deslocado para a esquerda ou direita.  Queremos que o mapa pare antes de desaparecer da tela para mostrar uma bela anima√ß√£o que confirma nossa decis√£o. <br><br><pre> <code class="kotlin hljs">&lt;ConstraintSet    android:id=<span class="hljs-string"><span class="hljs-string">"@+id/pass"</span></span>    app:deriveConstraintsFrom=<span class="hljs-string"><span class="hljs-string">"@+id/rest"</span></span>&gt;    &lt;Constraint        android:id=<span class="hljs-string"><span class="hljs-string">"@id/topCard"</span></span>        android:layout_width=<span class="hljs-string"><span class="hljs-string">"0dp"</span></span>        android:layout_height=<span class="hljs-string"><span class="hljs-string">"match_parent"</span></span>        android:layout_marginBottom=<span class="hljs-string"><span class="hljs-string">"80dp"</span></span>        android:layout_marginEnd=<span class="hljs-string"><span class="hljs-string">"200dp"</span></span>        android:layout_marginStart=<span class="hljs-string"><span class="hljs-string">"50dp"</span></span>        android:layout_marginTop=<span class="hljs-string"><span class="hljs-string">"20dp"</span></span>        app:layout_constraintEnd_toEndOf=<span class="hljs-string"><span class="hljs-string">"parent"</span></span>        app:layout_constraintWidth_percent=<span class="hljs-string"><span class="hljs-string">"0.7"</span></span> /&gt; &lt;/ConstraintSet&gt; &lt;ConstraintSet    android:id=<span class="hljs-string"><span class="hljs-string">"@+id/like"</span></span>    app:deriveConstraintsFrom=<span class="hljs-string"><span class="hljs-string">"@id/rest"</span></span>&gt;    &lt;Constraint        android:id=<span class="hljs-string"><span class="hljs-string">"@id/topCard"</span></span>        android:layout_width=<span class="hljs-string"><span class="hljs-string">"0dp"</span></span>        android:layout_height=<span class="hljs-string"><span class="hljs-string">"match_parent"</span></span>        android:layout_marginBottom=<span class="hljs-string"><span class="hljs-string">"80dp"</span></span>        android:layout_marginEnd=<span class="hljs-string"><span class="hljs-string">"50dp"</span></span>        android:layout_marginStart=<span class="hljs-string"><span class="hljs-string">"200dp"</span></span>        android:layout_marginTop=<span class="hljs-string"><span class="hljs-string">"20dp"</span></span>        app:layout_constraintStart_toStartOf=<span class="hljs-string"><span class="hljs-string">"parent"</span></span>        app:layout_constraintWidth_percent=<span class="hljs-string"><span class="hljs-string">"0.7"</span></span> /&gt; &lt;/ConstraintSet&gt;</code> </pre><br>  Adicione os dois conjuntos de restri√ß√µes √† cena anterior.  Eles s√£o quase id√™nticos, apenas espelhados nos dois lados da tela. <br><br>  Agora temos tr√™s conjuntos de restri√ß√µes - iniciar, curtir e passar.  Vamos definir a transi√ß√£o entre esses estados. <br><br>  Para fazer isso, adicione uma transi√ß√£o √† esquerda para deslizar e a outra √† direita para deslizar. <br><br><pre> <code class="kotlin hljs">&lt;Transition    app:constraintSetEnd=<span class="hljs-string"><span class="hljs-string">"@+id/pass"</span></span>    app:constraintSetStart=<span class="hljs-string"><span class="hljs-string">"@+id/rest"</span></span>    app:duration=<span class="hljs-string"><span class="hljs-string">"300"</span></span>&gt;    &lt;OnSwipe        app:dragDirection=<span class="hljs-string"><span class="hljs-string">"dragLeft"</span></span>        app:onTouchUp=<span class="hljs-string"><span class="hljs-string">"autoComplete"</span></span>        app:touchAnchorId=<span class="hljs-string"><span class="hljs-string">"@id/topCard"</span></span>        app:touchAnchorSide=<span class="hljs-string"><span class="hljs-string">"left"</span></span>        app:touchRegionId=<span class="hljs-string"><span class="hljs-string">"@id/topCard"</span></span> /&gt; &lt;/Transition&gt; &lt;Transition    app:constraintSetEnd=<span class="hljs-string"><span class="hljs-string">"@+id/like"</span></span>    app:constraintSetStart=<span class="hljs-string"><span class="hljs-string">"@+id/rest"</span></span>    app:duration=<span class="hljs-string"><span class="hljs-string">"300"</span></span>&gt;    &lt;OnSwipe        app:dragDirection=<span class="hljs-string"><span class="hljs-string">"dragRight"</span></span>        app:onTouchUp=<span class="hljs-string"><span class="hljs-string">"autoComplete"</span></span>        app:touchAnchorId=<span class="hljs-string"><span class="hljs-string">"@+id/topCard"</span></span>        app:touchAnchorSide=<span class="hljs-string"><span class="hljs-string">"right"</span></span>        app:touchRegionId=<span class="hljs-string"><span class="hljs-string">"@id/topCard"</span></span> /&gt; &lt;/Transition&gt;</code> </pre><br>  Assim, para o cart√£o superior, definimos a anima√ß√£o de furto para a esquerda e o mesmo - espelho para o furto para a direita. <br><br>  Essas propriedades ajudar√£o a melhorar a intera√ß√£o com a nossa cena: <br><br><ul><li>  touchRegionId: como adicionamos preenchimento ao redor do mapa, precisamos garantir que o toque seja reconhecido apenas na √°rea do pr√≥prio mapa, e n√£o em todo o MotionLayout.  Isso pode ser feito usando touchRegionId. <br></li><li>  onTouchUp: o que acontecer√° com a anima√ß√£o ap√≥s o lan√ßamento do cart√£o?  Ele deve seguir em frente ou retornar ao seu estado inicial, para que o preenchimento autom√°tico seja aplic√°vel. <br></li></ul><br>  Vamos ver o que aconteceu: <br><br><img src="https://habrastorage.org/webt/zs/zq/ox/zszqoxe4dsdpphvu3fro0_3tjtk.gif"><br><br><h3>  O mapa sai automaticamente da tela </h3><br>  Agora, trabalharemos na anima√ß√£o, que come√ßar√° quando o mapa sair da tela. <br><br>  Adicionamos mais dois conjuntos de ConstraintSet para cada estado final de nossas anima√ß√µes: o mapa deixa a tela esquerda e direita. <br><br>  Nos exemplos a seguir, mostrarei como criar o estado similar e o estado de passagem repetir√° o mesmo espelhado.  Um exemplo de trabalho pode ser visto completamente no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">reposit√≥rio</a> . <br><br><pre> <code class="kotlin hljs">&lt;ConstraintSet android:id=<span class="hljs-string"><span class="hljs-string">"@+id/offScreenLike"</span></span>&gt;    &lt;Constraint        android:id=<span class="hljs-string"><span class="hljs-string">"@id/topCard"</span></span>        android:layout_width=<span class="hljs-string"><span class="hljs-string">"0dp"</span></span>        android:layout_height=<span class="hljs-string"><span class="hljs-string">"match_parent"</span></span>        android:layout_marginBottom=<span class="hljs-string"><span class="hljs-string">"80dp"</span></span>        android:layout_marginEnd=<span class="hljs-string"><span class="hljs-string">"50dp"</span></span>        android:layout_marginTop=<span class="hljs-string"><span class="hljs-string">"20dp"</span></span>        app:layout_constraintStart_toEndOf=<span class="hljs-string"><span class="hljs-string">"parent"</span></span>        app:layout_constraintWidth_percent=<span class="hljs-string"><span class="hljs-string">"0.7"</span></span> /&gt;   &lt;/ConstraintSet&gt;</code> </pre> <br>  Agora, como no exemplo anterior, voc√™ precisa determinar a transi√ß√£o do estado de furto para o estado final.  A transi√ß√£o deve funcionar automaticamente imediatamente ap√≥s a anima√ß√£o do furto.  Isso pode ser feito usando a autoTransition: <br><br><pre> <code class="kotlin hljs">&lt;Transition app:autoTransition=<span class="hljs-string"><span class="hljs-string">"animateToEnd"</span></span> app:constraintSetEnd=<span class="hljs-string"><span class="hljs-string">"@+id/offScreenLike"</span></span> app:constraintSetStart=<span class="hljs-string"><span class="hljs-string">"@+id/like"</span></span> app:duration=<span class="hljs-string"><span class="hljs-string">"150"</span></span> /&gt;</code> </pre><br>  Agora temos um cart√£o magn√©tico que pode ser deslizado da tela! <br><br><img src="https://habrastorage.org/webt/vt/ip/i0/vtipi0xzpmomh5mlkqpoytwedze.gif"><br><br><h3>  Anima√ß√£o do mapa inferior </h3><br><br>  Agora vamos fazer a carta de baixo para criar a ilus√£o de infinito do baralho. <br><br>  Adicione mais um mapa ao layout, semelhante ao primeiro: <br><br><pre> <code class="kotlin hljs">&lt;FrameLayout    android:id=<span class="hljs-string"><span class="hljs-string">"@+id/bottomCard"</span></span>    android:layout_width=<span class="hljs-string"><span class="hljs-string">"0dp"</span></span>    android:layout_height=<span class="hljs-string"><span class="hljs-string">"0dp"</span></span>    android:background=<span class="hljs-string"><span class="hljs-string">"@color/colorAccent"</span></span> /&gt;</code> </pre> <br>  Altere o XML para definir as restri√ß√µes que se aplicam a este mapa em cada est√°gio da anima√ß√£o: <br><br><pre> <code class="kotlin hljs">&lt;ConstraintSet android:id=<span class="hljs-string"><span class="hljs-string">"@id/rest"</span></span>&gt;    &lt;!-- ... --&gt;    &lt;Constraint android:id=<span class="hljs-string"><span class="hljs-string">"@id/bottomCard"</span></span>&gt;        &lt;Layout            android:layout_width=<span class="hljs-string"><span class="hljs-string">"match_parent"</span></span>            android:layout_height=<span class="hljs-string"><span class="hljs-string">"match_parent"</span></span>            android:layout_marginBottom=<span class="hljs-string"><span class="hljs-string">"50dp"</span></span>            android:layout_marginEnd=<span class="hljs-string"><span class="hljs-string">"50dp"</span></span>            android:layout_marginStart=<span class="hljs-string"><span class="hljs-string">"50dp"</span></span>            android:layout_marginTop=<span class="hljs-string"><span class="hljs-string">"50dp"</span></span> /&gt;        &lt;Transform            android:scaleX=<span class="hljs-string"><span class="hljs-string">"0.90"</span></span>            android:scaleY=<span class="hljs-string"><span class="hljs-string">"0.90"</span></span> /&gt;    &lt;/Constraint&gt; &lt;/ConstraintSet&gt; &lt;ConstraintSet    android:id=<span class="hljs-string"><span class="hljs-string">"@+id/offScreenLike"</span></span>    app:deriveConstraintsFrom=<span class="hljs-string"><span class="hljs-string">"@id/like"</span></span>&gt;    &lt;!-- ... --&gt;    &lt;Constraint android:id=<span class="hljs-string"><span class="hljs-string">"@id/bottomCard"</span></span>&gt;        &lt;Transform            android:scaleX=<span class="hljs-string"><span class="hljs-string">"1"</span></span>            android:scaleY=<span class="hljs-string"><span class="hljs-string">"1"</span></span> /&gt;    &lt;/Constraint&gt; &lt;/ConstraintSet&gt;</code> </pre> <br>  Para fazer isso, podemos usar a conveniente propriedade ConstraintSet. <br><br>  Por padr√£o, cada novo conjunto recebe atributos do MotionLayout pai.  Mas, usando o sinalizador deriveConstraintsFrom, voc√™ pode definir outro pai para o nosso conjunto.  Deve-se ter em mente que, se definirmos restri√ß√µes usando a marca de restri√ß√£o, redefiniremos todas as restri√ß√µes do conjunto pai.  Para evitar isso, voc√™ pode definir atributos espec√≠ficos nas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tags</a> para que apenas elas sejam substitu√≠das. <br><br><img src="https://habrastorage.org/webt/vz/ff/zb/vzffzb5u7rlwpayywz7zfm6gnyk.png"><br><br>  No nosso caso, isso significa que, no conjunto de passes, n√£o definimos a tag Layout, mas a copiamos do pai.  No entanto, substitu√≠mos o Transform, portanto, substitu√≠mos todos os atributos especificados na tag Transform por nossos pr√≥prios, nesse caso, uma altera√ß√£o na escala. <br><br>  √â f√°cil usar o MotionLayout para adicionar um novo elemento e integr√°-lo perfeitamente √†s anima√ß√µes de nossa cena. <br><br><img src="https://habrastorage.org/webt/_-/73/jp/_-73jp-vstz02uondgcnyzwcxqe.gif"><br><br><h3>  Tornando a anima√ß√£o infinita </h3><br><br>  Depois que a anima√ß√£o √© conclu√≠da, o cart√£o superior n√£o pode ser retirado, porque agora se tornou um cart√£o inferior.  Para obter uma anima√ß√£o infinita, voc√™ precisa trocar os cart√µes. <br><br>  No come√ßo, eu queria fazer isso com uma nova transi√ß√£o: <br><br><pre> <code class="kotlin hljs">&lt;Transition    app:autoTransition=<span class="hljs-string"><span class="hljs-string">"jumpToEnd"</span></span>    app:constraintSetEnd=<span class="hljs-string"><span class="hljs-string">"@+id/rest"</span></span>    app:constraintSetStart=<span class="hljs-string"><span class="hljs-string">"@+id/offScreenLike"</span></span>    app:duration=<span class="hljs-string"><span class="hljs-string">"0"</span></span> /&gt;</code> </pre> <br><img src="https://habrastorage.org/webt/jb/6h/lz/jb6hlzynphpyptximrzq1wgfqfw.gif"><br><br>  A anima√ß√£o inteira √© reproduzida como deveria.  Agora temos uma pilha de cart√µes que voc√™ pode passar sem parar! <br><br>  Depois de um pequeno golpe, notei algo.  A transi√ß√£o para o final da anima√ß√£o do baralho p√°ra quando voc√™ toca no cart√£o.  Mesmo que a dura√ß√£o da anima√ß√£o seja zero, ela ainda p√°ra, o que √© ruim. <br><br><img src="https://habrastorage.org/webt/yv/nq/mo/yvnqmowevaznpjimh5kbtiplwco.gif"><br><br>  Consegui vencer de apenas uma maneira - alterando programaticamente a transi√ß√£o ativa no MotionLayout. <br><br>  Para fazer isso, definiremos um retorno de chamada ap√≥s a conclus√£o da anima√ß√£o.  Assim que offScreenLike e offScreenPass forem conclu√≠dos, basta redefinir a transi√ß√£o de volta ao estado de repouso e zerar o progresso. <br><br><pre> <code class="kotlin hljs">motionLayout.setTransitionListener(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : TransitionAdapter() {    <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onTransitionCompleted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(motionLayout: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">MotionLayout</span></span></span></span><span class="hljs-function"><span class="hljs-params">, currentId: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> {        <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (currentId) {            R.id.offScreenPass,            R.id.offScreenLike -&gt; {                motionLayout.progress = <span class="hljs-number"><span class="hljs-number">0f</span></span>                motionLayout.setTransition(R.id.rest, R.id.like)            }        }    }   })</code> </pre> <br>  N√£o importa qual transi√ß√£o definimos, passamos ou gostamos, quando deslizamos o dedo, passamos para a desejada. <br><br><img src="https://habrastorage.org/webt/li/9b/yo/li9byopqw8itzxzsgj2wgwbufxm.gif"><br><br>  Parece o mesmo, mas a anima√ß√£o n√£o para!  Vamos seguir em frente! <br><br><h3>  Liga√ß√£o de dados </h3><br>  Crie dados de teste para exibir nos mapas.  Por enquanto, nos limitaremos a alterar a cor de fundo de cada cart√£o. <br><br>  Criamos um ViewModel com um m√©todo svayp que substitui apenas novos dados.  Ligue-o √† Activity desta maneira: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> viewModel = ViewModelProviders .of(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) .<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(SwipeRightViewModel::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">viewModel</span></span></span><span class="hljs-class"> .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">modelStream</span></span></span><span class="hljs-class"> .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">observe</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, Observer { bindCard(it) }) motionLayout.setTransitionListener(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : TransitionAdapter() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onTransitionCompleted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(motionLayout: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">MotionLayout</span></span></span></span><span class="hljs-function"><span class="hljs-params">, currentId: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (currentId) { R.id.offScreenPass, R.id.offScreenLike -&gt; { motionLayout.progress = <span class="hljs-number"><span class="hljs-number">0f</span></span> motionLayout.setTransition(R.id.rest, R.id.like) viewModel.swipe() } } } })</code> </pre><br>  Resta informar o ViewModel sobre a conclus√£o da anima√ß√£o de furto e atualizar√° os dados exibidos no momento. <br><br><img src="https://habrastorage.org/webt/vl/j6/ar/vlj6arofcxa3lc7ny2z-ww1yxxg.gif"><br><br><h2>  √çcones pop-up </h2><br>  Adicione duas visualiza√ß√µes que, quando deslizadas, aparecem em um dos lados da tela (apenas uma √© mostrada abaixo, a segunda √© espelhada). <br><br><pre> <code class="kotlin hljs">&lt;ImageView android:id=<span class="hljs-string"><span class="hljs-string">"@+id/likeIndicator"</span></span> android:layout_width=<span class="hljs-string"><span class="hljs-string">"0dp"</span></span> android:layout_height=<span class="hljs-string"><span class="hljs-string">"0dp"</span></span> /&gt;</code> </pre><br>  Agora, para os mapas, voc√™ precisa definir os estados de anima√ß√£o com essas visualiza√ß√µes. <br><br><pre> <code class="kotlin hljs">&lt;ConstraintSet android:id=<span class="hljs-string"><span class="hljs-string">"@id/rest"</span></span>&gt;    &lt;!-- ... --&gt;    &lt;Constraint android:id=<span class="hljs-string"><span class="hljs-string">"@+id/like"</span></span>&gt;        &lt;Layout            android:layout_width=<span class="hljs-string"><span class="hljs-string">"40dp"</span></span>            android:layout_height=<span class="hljs-string"><span class="hljs-string">"40dp"</span></span>            app:layout_constraintBottom_toBottomOf=<span class="hljs-string"><span class="hljs-string">"parent"</span></span>            app:layout_constraintStart_toEndOf=<span class="hljs-string"><span class="hljs-string">"parent"</span></span>            app:layout_constraintTop_toTopOf=<span class="hljs-string"><span class="hljs-string">"parent"</span></span> /&gt;        &lt;Transform            android:scaleX=<span class="hljs-string"><span class="hljs-string">"0.5"</span></span>            android:scaleY=<span class="hljs-string"><span class="hljs-string">"0.5"</span></span> /&gt;        &lt;PropertySet android:alpha=<span class="hljs-string"><span class="hljs-string">"0"</span></span> /&gt;    &lt;/Constraint&gt;   &lt;/ConstraintSet&gt; &lt;ConstraintSet    android:id=<span class="hljs-string"><span class="hljs-string">"@+id/like"</span></span>    app:deriveConstraintsFrom=<span class="hljs-string"><span class="hljs-string">"@id/rest"</span></span>&gt;    &lt;!-- ... --&gt;    &lt;Constraint android:id=<span class="hljs-string"><span class="hljs-string">"@+id/like"</span></span>&gt;        &lt;Layout            android:layout_width=<span class="hljs-string"><span class="hljs-string">"100dp"</span></span>            android:layout_height=<span class="hljs-string"><span class="hljs-string">"100dp"</span></span>            app:layout_constraintBottom_toBottomOf=<span class="hljs-string"><span class="hljs-string">"@id/topCard"</span></span>            app:layout_constraintEnd_toEndOf=<span class="hljs-string"><span class="hljs-string">"@id/topCard"</span></span>            app:layout_constraintStart_toStartOf=<span class="hljs-string"><span class="hljs-string">"@id/topCard"</span></span>            app:layout_constraintTop_toTopOf=<span class="hljs-string"><span class="hljs-string">"@id/topCard"</span></span> /&gt;        &lt;Transform            android:scaleX=<span class="hljs-string"><span class="hljs-string">"1"</span></span>            android:scaleY=<span class="hljs-string"><span class="hljs-string">"1"</span></span> /&gt;        &lt;PropertySet android:alpha=<span class="hljs-string"><span class="hljs-string">"1"</span></span> /&gt;    &lt;/Constraint&gt; &lt;/ConstraintSet&gt;</code> </pre><br>  N√£o h√° necessidade de definir restri√ß√µes nas anima√ß√µes que v√£o al√©m da tela, pois elas s√£o herdadas dos pais.  E no nosso caso, este √© um estado de furto. <br><br>  √â tudo o que precisamos fazer.  Agora voc√™ pode adicionar componentes √†s cadeias de anima√ß√£o com muita facilidade. <br><br><img src="https://habrastorage.org/webt/wg/4g/1g/wg4g1grirk3zwqrfzwyahfp8i3i.gif"><br><br><h2>  Execute a anima√ß√£o programaticamente </h2><br><br>  Podemos criar dois bot√µes nos cart√µes para que o usu√°rio possa n√£o apenas deslizar, mas controlar usando os bot√µes. <br><br>  Cada bot√£o inicia a mesma anima√ß√£o que o furto. <br><br>  Como de costume, assine cliques no bot√£o e inicie a anima√ß√£o diretamente no objeto MotionLayout: <br><br><pre> <code class="kotlin hljs">likeButton.setOnClickListener {    motionLayout.transitionToState(R.id.like) } passButton.setOnClickListener {    motionLayout.transitionToState(R.id.pass) }</code> </pre><br>  Precisamos adicionar bot√µes aos cart√µes superior e inferior para que a anima√ß√£o seja reproduzida continuamente.  No entanto, para o mapa inferior, a inscri√ß√£o por clique n√£o √© necess√°ria, porque n√£o est√° vis√≠vel ou o mapa superior √© animado e n√£o queremos interromp√™-lo. <br><br><img src="https://habrastorage.org/webt/ic/zj/_v/iczj_vz8nrpdzlxtmjsaqc3bmiu.gif"><br><br>  Outro √≥timo exemplo de como o MotionLayout lida com altera√ß√µes de estado para n√≥s.  Vamos diminuir a anima√ß√£o um pouco: <br><br><img src="https://habrastorage.org/webt/d6/bk/ne/d6bkne2bvugopppwypug25l30m8.gif"><br><br>  Veja a transi√ß√£o que o MotionLayout realiza quando o passe √© substitu√≠do.  A magia! <br><br><h1>  Passe o mapa ao longo da curva </h1><br>  Suponha que gostemos se o mapa se mover n√£o em uma linha reta, mas em uma curva (para ser honesto, eu s√≥ queria tentar fazer isso). <br><br>  Ent√£o voc√™ precisa definir KeyPosition para o movimento nas duas dire√ß√µes, para que o caminho do movimento seja curvado por um arco. <br><br>  Adicione isso √† cena do movimento: <br><br><pre> <code class="kotlin hljs">&lt;Transition    app:constraintSetEnd=<span class="hljs-string"><span class="hljs-string">"@+id/like"</span></span>    app:constraintSetStart=<span class="hljs-string"><span class="hljs-string">"@+id/rest"</span></span>    app:duration=<span class="hljs-string"><span class="hljs-string">"300"</span></span>&gt;    &lt;!-- ... --&gt;    &lt;KeyFrameSet&gt;        &lt;KeyPosition            app:drawPath=<span class="hljs-string"><span class="hljs-string">"path"</span></span>            app:framePosition=<span class="hljs-string"><span class="hljs-string">"50"</span></span>            app:keyPositionType=<span class="hljs-string"><span class="hljs-string">"pathRelative"</span></span>            app:motionTarget=<span class="hljs-string"><span class="hljs-string">"@id/topCard"</span></span>            app:percentX=<span class="hljs-string"><span class="hljs-string">"0.5"</span></span>            app:percentY=<span class="hljs-string"><span class="hljs-string">"-0.1"</span></span> /&gt;           &lt;/KeyFrameSet&gt; &lt;/Transition&gt;</code> </pre> <br><img src="https://habrastorage.org/webt/ij/z4/4m/ijz44micij7kdu81k4-tc-zggjc.gif"><br>  Agora o mapa se move ao longo de um caminho curvo n√£o-banal.  Magicamente! <br><br><h1>  Conclus√£o </h1><br>  Quando voc√™ compara a quantidade de c√≥digo que recebi ao criar essas anima√ß√µes com nossa implementa√ß√£o atual de anima√ß√µes semelhantes na produ√ß√£o, o resultado √© impressionante. <br><br>  O MotionLayout manipula imperceptivelmente o cancelamento de transi√ß√µes (por exemplo, quando tocado), criando cadeias de anima√ß√£o, alterando propriedades durante as transi√ß√µes e muito mais.  Essa ferramenta altera tudo fundamentalmente, simplificando bastante a l√≥gica da interface do usu√°rio. <br><br>  Vale a pena trabalhar mais algumas coisas (principalmente desabilitar anima√ß√µes e rolagem bidirecional no RecyclerView), mas tenho certeza de que isso √© solucion√°vel. <br><br>  Lembre-se de que a biblioteca ainda est√° no status beta, mas j√° abre muitas oportunidades interessantes para n√≥s.  Esperamos ansiosamente o lan√ßamento do MotionLayout, que, tenho certeza, ser√° √∫til mais de uma vez no futuro.  Voc√™ pode ver o aplicativo totalmente funcional deste artigo no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">reposit√≥rio</a> . <br><br>  <i>PS: e como eles me deram a palavra como tradutor, nossa equipe do Android tem um lugar para um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">desenvolvedor</a> .</i>  <i>Obrigado pela aten√ß√£o.</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt458854/">https://habr.com/ru/post/pt458854/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt458842/index.html">Paci√™ncia e trabalho extrair√£o o texto inteiro</a></li>
<li><a href="../pt458844/index.html">Destrui√ß√£o de silo atrav√©s da abordagem de adapta√ß√£o VeriSM ‚Ñ¢</a></li>
<li><a href="../pt458846/index.html">Como desenvolver outro jogo de plataformas usando o Unity. Outro tutorial</a></li>
<li><a href="../pt458848/index.html">Libera√ß√£o Rust 1.36.0: caracter√≠stica futura, estabiliza√ß√£o de aloca√ß√£o e MaybeUninit <T></a></li>
<li><a href="../pt458850/index.html">Aprenda ingl√™s de maneira barata e eficiente. Parte 2</a></li>
<li><a href="../pt458856/index.html">Pilhas AAA baratas e caras</a></li>
<li><a href="../pt458860/index.html">Ajustando os par√¢metros do kernel do Linux para otimizar o PostgreSQL</a></li>
<li><a href="../pt458864/index.html">Concurso de desenvolvedores de bot para TamTam</a></li>
<li><a href="../pt458866/index.html">Como o balanceador de equipe funciona no World of Tanks Blitz</a></li>
<li><a href="../pt458868/index.html">Barulho no big data. An√°lise de entropia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>