<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•© üå§Ô∏è üôá DIY Do-it-yourself-Spielekonsole üèÇüèΩ üë∂üèª üï¥üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Beitrag ist eine Einf√ºhrung in mein Projekt "hausgemachte" Konsolen-Videokonsolen, die von Grund auf neu erstellt wurden. Ich war sowohl von Re...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>DIY Do-it-yourself-Spielekonsole</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444006/"><p><img src="https://habrastorage.org/getpro/habr/post_images/0b1/45a/7c0/0b145a7c0f4c0821cdb77654ef2a8cd3.jpg" alt="Bild"></p><br><p>  Dieser Beitrag ist eine Einf√ºhrung in mein Projekt "hausgemachte" Konsolen-Videokonsolen, die von Grund auf neu erstellt wurden.  Ich war sowohl von Retro-Konsolen als auch von modernen Mustern inspiriert, bekam aber meine eigene Architektur.  Meine Freunde sagten mir st√§ndig, ich solle √ºber mein Projekt sprechen und nicht alles ausschlie√ülich "f√ºr mich" tun, also ver√∂ffentliche ich hier diesen Beitrag. </p><a name="habracut"></a><br><p>  <strong>Achtung, dies ist eine √úbersetzung</strong> </p><br><h1 id="kak-vsyo-nachalos">  Wie alles begann </h1><br><p>  Mein Name ist Sergio Vieira, ich bin in den 80ern und 90ern in Portugal aufgewachsen und habe eine lange Nostalgie f√ºr Retro-Spiele, insbesondere f√ºr Konsolen der dritten und vierten Generation. </p><br><p>  Vor einigen Jahren habe ich beschlossen, die Elektronik besser zu verstehen und mein eigenes Pr√§fix zu erstellen. </p><br><p>  Von Beruf bin ich Programmierer und hatte keine Erfahrung als Elektronikingenieur, au√üer (und sollte nicht in Betracht gezogen werden) unabh√§ngigen Upgrades meines Destkop. </p><br><p>  Obwohl ich keine Erfahrung hatte, sagte ich mir "Warum nicht?", Kaufte mehrere B√ºcher, mehrere elektronische Kits und begann zu lernen, basierend auf meinen Gef√ºhlen dar√ºber, was es wert war, studiert zu werden. </p><br><p>  Ich wollte ein Pr√§fix machen, das denen √§hnelt, die mich nostalgisch machen. Ich wollte etwas zwischen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NES</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Super Nintendo</a> oder vielleicht zwischen dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sega Master System</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mega Drive</a> . </p><br><p>  Diese Konsolen hatten eine CPU, einen Original-Videochip (damals wurden sie nicht als GPU bezeichnet) und einen Audio-Chip, manchmal eingebaut und manchmal extern. </p><br><p>  Die Spiele wurden auf Kassetten verteilt, bei denen es sich im Allgemeinen um Eisenerweiterungen handelte, manchmal nur um ROM-Chips, und manchmal um zus√§tzliche Komponenten. </p><br><p>  Der urspr√ºngliche Plan bestand darin, ein Pr√§fix mit den folgenden Merkmalen zu erstellen: </p><br><ul><li>  Ohne Emulation sollten Spiele und Programme auf echter Hardware funktionieren, nicht unbedingt auf der gleichen Zeit, aber schnell genug f√ºr die Aufgabe und nicht mehr. </li><li>  Mit einer echten Retro-CPU. </li><li>  Mit analogem TV-Ausgang. </li><li>  Mit Ton </li><li>  Mit Dual-Controller-Unterst√ºtzung </li><li>  Scrolling Becks und Animations-Sprites </li><li>  Mit Funktionen zur Unterst√ºtzung von Plattformspielen wie Mario und nat√ºrlich allen m√∂glichen anderen Spielen. </li><li>  Mit dem Herunterladen von Spielen und Programmen von SD-Karten. </li></ul><br><p>  Warum SD-Karten und keine Kassetten? Im Grunde ist es so viel praktischer, dass Sie sie von Ihrem Computer kopieren k√∂nnen.  Und Patronen w√ºrden zum einen mehr Eisen in der Set-Top-Box bedeuten und zum anderen Eisen f√ºr jedes Programm produzieren. </p><br><h1 id="proizvodstvo">  Produktion </h1><br><h2 id="video-signal">  Videosignal </h2><br><p>  Als erstes habe ich ein Videosignal erzeugt. </p><br><p>  Jede Konsole aus der Zeit, die ich als Beispiel genommen habe, hatte verschiedene propriet√§re Grafikchips, was bedeutet, dass sie alle unterschiedliche Spezifikationen hatten. <br>  Aus diesem Grund wollte ich keinen vorgefertigten Grafikchip verwenden, sondern wollte, dass meine Konsole eindeutige Grafikspezifikationen aufweist.  Und da ich keinen eigenen Grafikchip herstellen konnte und zu diesem Zeitpunkt noch kein FPGA verwenden konnte, beschloss ich, mich auf die durch Software generierte Erzeugung eines Grafiksignals mit einem 8-Bit-Mikrocontroller mit 20 Megahertz zu beschr√§nken. </p><br><p>  Dies ist nicht zu viel und nur eine ausreichend leistungsf√§hige L√∂sung f√ºr Grafiken des Niveaus, an dem ich interessiert war. </p><br><p>  Und so begann ich, den Atmega644-Mikrocontroller mit einer Reinheit von 20 MHz zu verwenden, um ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PAL</a> -Videosignal f√ºr den Fernseher zu erzeugen.  Ich musste das PAL-Protokoll <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">etwas √ºbertreffen</a> , weil der Chip selbst nicht wei√ü, wie es geht. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d7b/8ee/74d/d7b8ee74dbd4c844e65f2a1766e33a0a.jpg" alt="imageVPU Test 1"></p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/96b/d85/e5c/96bd85e5c323152604a68bb3c8341f69.jpg" alt="imageVPU Test 2"></p><br><p>  Der Mikrocontroller erzeugt eine 8-Bit-Farbe (RGB332, 3 Bit Rot, 3 Bit Gr√ºn und 2 Bit Blau) und der passive DAC konvertiert alles in RGB.  Gl√ºcklicherweise sind in Portugal fast alle Fernseher mit einem SCART-Anschluss ausgestattet und unterst√ºtzen den RGB-Eingang. </p><br><h2 id="pravilnaya-graficheskaya-podsistema">  Das richtige Grafik-Subsystem </h2><br><p>  Da der Mikrocontroller ziemlich leistungsf√§hig ist und ich mich entschied, ihn ausschlie√ülich zur Erzeugung eines Videosignals zu verwenden (ich nannte ihn VPU - Video Processing Unit), entschied ich mich, gleichzeitig einen Doppelpuffer zu organisieren. </p><br><p>  Es stellte sich heraus, dass der zweite Mikrocontroller (PPU, Bildverarbeitungseinheit, Atmega1284-Chip ebenfalls bei 20 MHz) ein Bild im RAM-Chip 1 (ich nannte es VRAM1) erzeugte und der erste gleichzeitig den Inhalt des zweiten Chips (VRAM2) an den Fernseher sendete. </p><br><p>  Nach einem Bild und zwei Bildern im PAL-System von 1/25 Sekunde schaltet die VPU die VRAMs um und sie werden ausgetauscht, die PPU erzeugt ein Bild in VRAM2 und die VPU speichert VRAM1 auf dem TV-Ausgang. </p><br><p>  Die Grafikkarte erwies sich als sehr kompliziert, da ich externe Hardware verwenden musste, damit beide Mikrocontroller beide Speichermodule verwenden konnten, und um den Zugriff auf den RAM zu beschleunigen, da sie auch Bit-Banging aufweist. Daher musste ich Chips der Serie 74 als Z√§hler, Leitungsselektoren, Transceiver usw. hinzuf√ºgen. . </p><br><p>  Die Firmware f√ºr VPU und PPU erwies sich ebenfalls als umst√§ndlich, da ich viel Code schreiben musste, um die maximale Geschwindigkeit aus den Grafiken herauszuholen.  Zuerst wurde alles in Assembler geschrieben, dann wurde ein Teil in C umgeschrieben. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/7a2/43d/c87/7a243dc873ceaf16fe0e2d183d388dd1.jpg" alt="imageVideo Board 1"></p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2a9/c59/cca/2a9c59cca5b2d64f25abdfd2f59912e5.jpg" alt="imageVideo Board 2"></p><br><p>  Infolgedessen erzeugt die PPU ein Bild mit 224 x 192 Pixeln, das dann √ºber die VPU an den Fernseher gesendet wird.  M√∂glicherweise ist die Aufl√∂sung niedrig, aber tats√§chlich ist sie fast so hoch wie die Konsolen dieser Zeit, normalerweise 256 x 224.  Eine etwas niedrigere Aufl√∂sung, aber ich konnte weitere Funktionen hinzuf√ºgen, die das System in einem Frame berechnen kann. </p><br><p>  Wie in fr√ºheren Zeiten verf√ºgt die PPU √ºber eine eigene starre Mechanik, die Sie verwenden k√∂nnen m√ºssen.  Der Hintergrund (Backing) wird aus 8x8-Pixel-Zeichen gerendert, die auch als Kacheln bezeichnet werden.  Es stellt sich heraus, dass die Gr√∂√üe des Hintergrunds 28x24 Kacheln betr√§gt. </p><br><p>  Damit der Hintergrund Pixel f√ºr Pixel reibungslos gescrollt werden kann, habe ich 4 virtuelle Bildschirme mit jeweils 28 x 24 Kacheln erstellt, die nacheinander im Speicher abgelegt und umeinander gewickelt werden. Auf dem Bild ist dies klarer. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/666/41c/c14/66641cc14e799a0e4269d4b130490465.png" alt="imageBackground"></p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/500/971/e16/500971e169f1364520eb5004529cca3e.png" alt="imageVirtueller Hintergrund"></p><br><p>  √úber dem Hintergrund kann die PPU 64 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sprites</a> rendern, die 8 oder 16 Pixel hoch oder breit sein k√∂nnen, dh 1, 2 oder 4 Kacheln, und die auch horizontal und / oder vertikal gespiegelt werden k√∂nnen. </p><br><p>  Oben auf der R√ºckseite k√∂nnen Sie auch eine √úberlagerung mit einem Puffer von 28 x 6 Kacheln rendern. Dies war zum Rendern von HUDs und Scores gedacht, um die Haupt-Sprites und das Scrollen der R√ºckseite nicht zu beeintr√§chtigen. </p><br><p>  Eine ‚Äûerweiterte‚Äú Funktion ist, dass der Hintergrund nicht vollst√§ndig, sondern jede Zeile einzeln gescrollt werden kann, was alle m√∂glichen interessanten Effekte wie geteilte Bildschirme oder nahezu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Parallaxe erm√∂glicht</a> . </p><br><p>  Es gibt auch eine Attributtabelle, in der Sie jede Kachel auf einen Wert von 0 bis 3 setzen k√∂nnen. Anschlie√üend k√∂nnen Sie eine Kachelseite f√ºr alle Kacheln mit einem Attribut angeben oder ihren symbolischen Wert erh√∂hen.  Dies ist praktisch, wenn Teile der Sicherung regelm√§√üig ge√§ndert werden m√ºssen und die CPU nicht jede Kachel einzeln berechnen muss. Es reicht aus, nur Folgendes zu sagen: "Alle Kacheln mit Attribut 1 erh√∂hen den numerischen Wert Ihres Zeichens um 2". √Ñhnliche Dinge k√∂nnen mit verschiedenen Techniken implementiert werden Beobachten Sie zum Beispiel in Blockpl√§ttchen in Mario, in denen das Fragezeichen animiert ist, oder in Spielen, in denen es einen Wasserfall gibt, in dem sich alle Pl√§ttchen st√§ndig √§ndern, wodurch der Effekt von fallendem Wasser entsteht. </p><br><h2 id="cpu">  CPU </h2><br><p>  Als meine Grafikkarte funktionierte, begann ich mit der CPU als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zilog 80</a> f√ºr meine Set-Top-Box zu arbeiten. </p><br><p>  Einer der Gr√ºnde, warum der Z80 ausgew√§hlt wurde, ist neben der Tatsache, dass es sich um eine coole Retro-CPU handelt, seine F√§higkeit, zwei 16-Bit-Speicherpl√§tze zu adressieren, einen f√ºr den Speicher und einen f√ºr E / A-Ports, nicht weniger als den legend√§ren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">6502</a> Es kann nur 16-Bit-Speicherplatz adressieren und muss dem Speicher sowie verschiedenen externen Ger√§ten, Video, Audio, Joysticks, Hardware-Zufallszahlengenerator usw. zugeordnet werden.  Es ist bequemer, zwei Adressr√§ume zu haben, von denen einer bis zu 64 Kilobyte Code und Daten vollst√§ndig speichert und der zweite f√ºr den Zugriff auf externe Ger√§te. </p><br><p>  Zuerst habe ich die CPU mit dem EEPROM verbunden, in dem sich mein Testprogramm befand, und sie √ºber den E / A-Bereich mit dem von mir installierten Mikrocontroller verbunden, damit ich √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RS232</a> mit meinem Computer kommunizieren und √ºberwachen konnte, wie die CPU und alles andere funktionierten.  Ich nenne diesen Atmega324-Mikrocontroller, der mit 20 MHz arbeitet, die E / A-MCU - eine Eingangs- / Ausgangs-Mikrocontrollereinheit, die f√ºr die Steuerung des Zugriffs auf Gamecontroller (Joysticks), einen SD-Kartenleser, eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PS / 2-</a> Tastatur und einen Kommunikator √ºber RS232 verantwortlich ist. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/0e9/3fa/89a/0e93fa89aa467f7d400b032ba4932c1c.jpg" alt="imageCPU Board 1"></p><br><p>  Die CPU ist mit einem 128-Kilobyte-Speicherchip verbunden, von dem nur 56 Kilobyte verf√ºgbar sind. Das ist nat√ºrlich Unsinn, aber ich k√∂nnte nur 128 oder 32 Kilobyte-Chips bekommen.  Es stellte sich heraus, dass der Speicher aus 8 Kilobyte ROM und 56 Kilobyte RAM besteht. </p><br><p>  Danach habe ich die IO-MCU-Firmware mithilfe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieser Bibliothek</a> aktualisiert und Unterst√ºtzung f√ºr SD-Kartenleser erhalten. </p><br><p>  Jetzt konnte die CPU die Verzeichnisse durchsuchen, sehen, was darin enthalten ist, Dateien √∂ffnen und lesen.  All dies erfolgt durch Schreiben und Lesen an bestimmte Adressen im E / A-Bereich. </p><br><h2 id="podklyuchenie-cpu-k-ppu">  CPU an PPU anschlie√üen </h2><br><p>  Das n√§chste, was ich getan habe, ist die Verbindung zwischen der CPU und der PPU.  Zu diesem Zweck habe ich eine "einfache L√∂sung" angewendet, die darin bestand, Dual-Port-RAM zu kaufen. Dies ist ein solcher RAM-Chip, der direkt an zwei verschiedene Busse angeschlossen werden kann.  Dies erm√∂glicht es ihm, zus√§tzliche Chips wie Leitungsselektoren loszuwerden und dar√ºber hinaus von beiden Chips aus fast gleichzeitig auf den Speicher zuzugreifen.  Eine andere PPU kann in jedem Frame direkt auf die CPU zugreifen, indem sie ihre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nicht maskierbaren Interrupts</a> aktiviert.  Es stellt sich heraus, dass die CPU in jedem Frame einen Interrupt empf√§ngt, der f√ºr verschiedene Timing-Aufgaben und zum Verst√§ndnis, wann es Zeit ist, ein Grafik-Update durchzuf√ºhren, n√ºtzlich ist. </p><br><p>  Jeder Interaktionsrahmen der CPU, PPU und VPU erfolgt nach folgendem Schema: </p><br><ol><li>  Die PPU kopiert Informationen aus dem PPU-Speicher in den internen Speicher. </li><li>  Die PPU sendet ein Interrupt-Signal an die CPU. </li><li>  Zur gleichen Zeit: <br><ul><li>  Die CPU springt zur Interrupt-Funktion und aktualisiert den PPU-Speicher mit einem neuen Grafikstatus.  Das Programm muss vom Interrupt bis zum n√§chsten Block zur√ºckkehren. </li><li>  Die PPU rendert ein Bild basierend auf Informationen, die zuvor in einen VRAM kopiert wurden. </li><li>  VPU sendet ein Bild von einem anderen VRAM an den TV-Ausgang. </li></ul></li></ol><br><p>  Etwa zur gleichen Zeit begann ich, Gamecontroller zu unterst√ºtzen. Zuerst wollte ich Nintendo-Controller verwenden, aber ihre Sockel sind propriet√§r und im Allgemeinen schwer zu finden. Deshalb habe ich mich f√ºr 6-Tasten-Controller entschieden, die mit Mega Drive / Genesis kompatibel sind. Sie haben Standard-DB-9-Sockel die sind √ºberall. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/9ed/e06/12a/9ede0612a51808d0d5e92c5765e9f4fd.jpg" alt="imageJoint Board 1"></p><br><h2 id="napisanie-pervoy-nastoyaschey-igry">  Das erste richtige Spiel schreiben </h2><br><p>  Zu diesem Zeitpunkt hatte ich bereits eine CPU, die in der Lage war, die PPU zu steuern, mit Joysticks zu arbeiten, SD-Karten zu lesen ... es war Zeit <a href="">, das erste Spiel</a> zu <a href="">schreiben</a> , nat√ºrlich in Z80 Assembler, es dauerte mehrere Tage aus der Freizeit. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/2Pcrg1fesBk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="dobavlyaem-dinamicheskuyu-grafiku">  F√ºgen Sie dynamische Grafiken hinzu </h2><br><p>  Alles war super, ich hatte meine eigene Spielekonsole, aber das war nicht genug f√ºr mich, weil ich im Spiel Grafiken verwenden musste, die in den PPU-Speicher gestickt waren, und es unm√∂glich war, Kacheln f√ºr ein bestimmtes Spiel zu zeichnen, und es konnte nur durch erneutes Flashen des ROM ge√§ndert werden.  Ich begann dar√ºber nachzudenken, wie man mehr Speicher hinzuf√ºgt, damit die CPU Zeichen f√ºr die Kacheln darin laden kann, und dann k√∂nnte die PPU alles von dort lesen und wie man es einfacher macht, weil sich das Pr√§fix bereits als kompliziert und gro√ü herausstellte. </p><br><p>  Und ich habe mir Folgendes ausgedacht: Nur die PPU hat Zugriff auf diesen neuen Speicher, und die CPU l√§dt dort Daten √ºber die PPU. W√§hrend dieses Ladevorgangs kann dieser Speicher nicht zum Zeichnen verwendet werden, es kann jedoch zu diesem Zeitpunkt aus dem ROM gezogen werden. </p><br><p>  Nach dem Ende des Ladevorgangs schaltet die CPU den internen ROM-Speicher auf diesen neuen Speicher um, den ich als Zeichen-RAM (CHR-RAM) bezeichnet habe. In diesem Modus beginnt die PPU mit dem Zeichnen dynamischer Grafiken. Dies ist wahrscheinlich nicht die beste L√∂sung, funktioniert jedoch.  Infolgedessen wurde ein neuer Speicher mit 128 Kilobyte installiert, der 1024 Zeichen mit jeweils 8 x 8 Pixel f√ºr den Hintergrund und die gleiche Anzahl von Zeichen f√ºr Sprites speichern kann. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ff8/47a/b6b/ff847ab6b2ae65bd21c0426283d2c6a7.jpg" alt="imageJoint Board 2"></p><br><h2 id="i-nakonec-zvuk">  Und zum Schluss der Sound </h2><br><p>  Die H√§nde erreichten zuletzt den Ton.  Zuerst wollte ich einen Sound wie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Uzebox</a> , das hei√üt, der Mikrocontroller erzeugt 4 Kan√§le PWM-Sound. </p><br><p>  Es stellte sich jedoch heraus, dass ich die Vintage-Chips leicht bekommen kann und ich bestellte mehrere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FM-Synthese-</a> Chips YM3438, diese Typen sind voll kompatibel mit dem in Mega Drive / Genesis verwendeten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">YM2612</a> .  Durch die Installation erhalten Sie hochwertige Musik, Mega Drive und vom Mikrocontroller erzeugte Soundeffekte. </p><br><p>  Ich habe einen anderen Mikrocontroller installiert und ihn SPU (Sound Processor Unit) genannt. Er steuert den YM3438 und kann selbst Sounds erzeugen.  Die CPU steuert es √ºber einen Dual-Port-Speicher, diesmal sind es nur 2 Kilobyte. </p><br><p>  Wie bei der Grafikeinheit verf√ºgt die Soundeinheit √ºber 128 Kilobyte Speicher zum Speichern von PCM-Samples und Soundpatches. Die CPU l√§dt Daten in diesen Speicher, indem sie auf die SPU zugreift.  Es stellte sich heraus, dass die CPU die SPU entweder anweist, Befehle aus diesem Speicher auszuf√ºhren, oder die Befehle f√ºr die SPU in jedem Frame aktualisiert. </p><br><p>  Die CPU steuert vier PWM-Kan√§le √ºber vier kreisf√∂rmige Puffer im SPU-Speicher.  Die SPU durchl√§uft diese Puffer und f√ºhrt die in sie geschriebenen Befehle aus.  Es gibt auch einen solchen Puffer f√ºr den FM-Synthesechip. </p><br><p>  Insgesamt verl√§uft die Interaktion zwischen CPU und SPU wie in der Grafik nach dem Schema: </p><br><ol><li>  Die SPU kopiert Daten von der SPU in den internen Speicher. </li><li>  Die SPU wartet auf einen Interrupt von der PPU (dies dient zur Synchronisation). </li><li>  Zur gleichen Zeit <br><ul><li>  Die CPU aktualisiert die PWM-Kanalpuffer und die FM-Synthesizer-Puffer. </li><li>  Die SPU f√ºhrt Befehle in Puffern gem√§√ü den Daten im internen Speicher aus. </li><li>  Zusammen mit all dem aktualisiert die SPU PWM-Sounds mit einer Frequenz von 16 Kilohertz. </li></ul></li></ol><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d83/946/43e/d8394643e24f2c0771493bfbe1081157.jpg" alt="imageSound Board 1"></p><br><h1 id="chto-vyshlo-v-itoge">  Was am Ende herauskam </h1><br><p>  Nachdem alle Bl√∂cke fertig waren, gingen einige zum Steckbrett. <br>  F√ºr den CPU-Block konnte ich eine benutzerdefinierte Leiterplatte entwickeln und bestellen. Ich wei√ü nicht, ob es sich f√ºr die anderen Module lohnt. Ich hatte wirklich Gl√ºck, dass meine Leiterplatte sofort funktioniert hat. </p><br><p>  Auf dem Steckbrett ist jetzt (bisher) nur Ton zu h√∂ren. <br>  So sieht es heute aus: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/5b1/41e/828/5b141e82873999d9ce5a327d77770133.jpg" alt="imageConsole 1"></p><br><h2 id="arhitektura">  Architektur </h2><br><p>  Das Diagramm zeigt die Komponenten in jedem Block und wie sie miteinander interagieren.  Das einzige, was nicht angezeigt wird, ist das Signal von der PPU an die CPU in jedem Frame als Interrupt und das gleiche Signal, das an die SPU geht. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/4cb/b3a/9d1/4cbb3a9d121465d904518aceaee47045.png" alt="imageArchitecture"></p><br><ul><li>  CPU: Zilog Z80 bei 10 MHz </li><li>  CPU-ROM: 8 KB EEPROM, enth√§lt Bootloader-Code </li><li>  CPU-RAM: 128 KB RAM (56 KB verf√ºgbar), Code und Daten f√ºr Programme / Spiele </li><li>  IO-MCU: Atmega324 ist die Schnittstelle zwischen CPU und RS232, der PS / 2-Tastatur, den Joysticks und dem SD-Kartendateisystem </li><li>  PPU-RAM: 4 Kilobyte Dual-Port-Speicher, Zwischenspeicher zwischen CPU und PPU </li><li>  CHR-RAM: 128 KB RAM, speichert dynamische Kacheln f√ºr Backing (Substrat) und Sprites (in Zeichen von 8 x 8 Pixel). </li><li>  VRAM1, VRAM2: 128 KB RAM (43008 ist wirklich verf√ºgbar), sie werden f√ºr den Framebuffer verwendet, sie schreiben PPU und lesen VPU von ihnen. </li><li>  PPU (Picture Processing Unit): Atmega1284 zeichnet einen Frame in den Framebuffer. </li><li>  VPU (Video Processing Unit): Atmega324, liest den Framebuffer und generiert RGB- und PAL-Signal und Synchronisation. </li><li>  SPU-RAM: 2 KB Dual-Port-RAM, dient als Schnittstelle zwischen CPU und SPU. </li><li>  SNDRAM: 128 KB RAM, speichert PWM-Patches, PCM-Samples und Befehlsbl√∂cke f√ºr den FM-Synthesizer. </li><li>  YM3438: YM3438, FM-Synthesechip. </li><li>  SPU (Sound Processing Unit): Atmega644 erzeugt T√∂ne nach dem Prinzip der Pulsweitenmodulation (PWM) und steuert den YM3438. </li></ul><br><h2 id="okonchatelnye-specifikacii">  Endg√ºltige Spezifikationen </h2><br><p>  <strong>CPU:</strong> </p><br><ul><li>  8-Bit-CPU Zilog Z80 mit einer Frequenz von 10 MHz. </li><li>  8 KB ROM f√ºr den Bootloader. </li><li>  56 KB RAM. </li></ul><br><p>  <strong>IO:</strong> </p><br><ul><li>  Lesen von Daten vom SD-Kartenleser FAT16 / FAT32. </li><li>  Lesen / Schreiben auf den RS232-Port. </li><li>  2 MegaDrive / Genesis-kompatible Gamecontroller. </li><li>  Tastatur PS2. </li></ul><br><p>  <strong>Video:</strong> </p><br><ul><li>  Aufl√∂sung 224x192 Pixel. </li><li>  25 Bilder pro Sekunde (halbe FPS von PAL). </li><li>  256 Farben (RGB332). </li><li>  2x2 virtueller Hintergrund (448x384 Pixel) mit bidirektionalem pixelbasiertem Scrollen, basierend auf vier Vollbildseiten. </li><li>  64 Sprites mit einer Breite und H√∂he von 8 oder 16 Pixel mit der M√∂glichkeit des vertikalen und horizontalen Flip. </li><li>  Der Hintergrund und die Sprites bestehen aus Zeichen mit jeweils 8 x 8 Pixel. </li><li>  Symbolischer Videospeicher mit 1024 Zeichen f√ºr den Hintergrund und 1024 f√ºr Sprites. </li><li>  64 unabh√§ngiges horizontales Scrollen entlang festgelegter Linien </li><li>  8 unabh√§ngiges vertikales Scrollen entlang festgelegter Linien </li><li>  224x48 Pixel Overlay mit optionaler Farbschl√ºsseltransparenz. </li><li>  Hintergrundattributtabelle. </li><li>  RGB und Composite PAL √ºber SCART-Anschluss. </li></ul><br><p>  <strong>Ton:</strong> </p><br><ul><li>  PWM f√ºr 8 Bit und 4 Kan√§le mit integrierten Wellenformen: Quadrat, Sinus, S√§ge, Rauschen usw. </li><li>  8-Bit-8-kHz-Samples in einem der PWM-Kan√§le. </li><li>  FM-Synthesechip YM3438 mit Anweisungen mit einer Frequenz von 50 Hertz geladen. </li></ul><br><h1 id="razrabotka-dlya-pristavki">  Entwicklung f√ºr die Konsole </h1><br><p>  F√ºr die Konsole wurde ein Bootloader geschrieben.  Der Bootloader befindet sich in der ROM-CPU und kann bis zu 8 Kilobyte aufnehmen.  Es verwendet die ersten 256 Bytes RAM.  Der Loader ist das erste, was die CPU ausf√ºhrt.  Es wird ben√∂tigt, um die Programme auf der SD-Karte anzuzeigen. </p><br><p>  Diese Programme befinden sich in Dateien, die kompilierten Code enthalten und m√∂glicherweise auch Grafiken und Sound enthalten. </p><br><p>  Nach Auswahl eines Programms wird es in den CPU-Speicher, den CHR-Speicher und den SPU-Speicher geladen.  Danach wird der Programmcode ausgef√ºhrt.  Die maximale Gr√∂√üe des in die Konsole geladenen Codes betr√§gt zus√§tzlich zu den ersten 256 Byte 56 Kilobyte. Nat√ºrlich m√ºssen Sie den Speicherplatz f√ºr den Stapel und die Daten ber√ºcksichtigen. <br>  Dieser Bootloader und andere Programme, die f√ºr diese Konsole geschrieben wurden, wurden auf die unten beschriebene Weise erstellt. </p><br><h2 id="memoryio-mapping">  Speicher- / E / A-Zuordnung </h2><br><p>  Bei der Entwicklung f√ºr dieses Pr√§fix ist es wichtig zu ber√ºcksichtigen, wie die CPU auf die verschiedenen Bl√∂cke zugreift, und den Adressraum f√ºr die Eingabe und den Speicheradressraum korrekt zuzuweisen. </p><br><p>  Die CPU greift √ºber den Adressraum des Speichers auf den Direktzugriffsspeicher des Bootloaders zu. </p><br><p>  Speicheradressraum <br><img src="https://habrastorage.org/getpro/habr/post_images/f37/a98/86a/f37a9886acd53a6204b02a3f11b190b6.png" alt="imageMemory-Zuordnung"></p><br><p>  Und zu PPU-RAM, SPU-RAM und IO-MCU √ºber den E / A-Adressraum. </p><br><p>  E / A-Adressraum <br><img src="https://habrastorage.org/getpro/habr/post_images/799/634/0c0/7996340c05682ff9eb4d060e6cc361c1.png" alt="imageIO-Zuordnung"></p><br><p>  Wie Sie der Tabelle entnehmen k√∂nnen, werden Adressen f√ºr alle Ger√§te, E / A-MCU, PPU und SPU im E / A-Adressraum zugewiesen. </p><br><h2 id="upravlenie-ppu">  PPU-Verwaltung </h2><br><p>  Aus den Informationen in der Tabelle ist ersichtlich, dass f√ºr die PPU-Steuerung in den PPU-Speicher geschrieben werden muss, der unter den Adressen 1000h-1FFFh im E / A-Adressraum verf√ºgbar ist. </p><br><p>  Zuweisung des PPU-Adressraums </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ab3/304/1ca/ab33041ca0ac1a8d427cae75dcb736ff.png" alt="imagePPU-Zuordnung"></p><br><p>  Der PPU-Status kann folgende Werte annehmen: </p><br><ol><li>  Eingebetteter Grafikmodus </li><li>  Dynamischer Grafikmodus (CHR-RAM) </li><li>  Aufnahmemodus im CHR-Speicher </li><li>  Die Aufzeichnung ist abgeschlossen und wartet auf die Best√§tigung des Modus durch die CPU </li></ol><br><p>  Hier zum Beispiel, wie Sie mit Sprites arbeiten k√∂nnen: <br>  Das Pr√§fix kann 64 Sprites gleichzeitig zeichnen.      CPU    -   1004h-1143h (320 ),     5   (5 * 64 = 320): </p><br><ol><li>   ,     : Active, Flipped_X, Flipped_Y, PageBit0, PageBit1, AboveOverlay, Width16, Height16. </li><li>  ,     (  ). </li><li>    (    ‚Äî ) </li><li>   X </li><li>   Y </li></ol><br><p> ,   ,    Active  1,    X  Y   ,  32/32       ,        . </p><br><p>         . </p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn wir beispielsweise die Sprite-Nummer 10 anzeigen m√ºssen, lautet die Adresse 4145 (1004h + (5 x 9)), schreiben Sie den Wert 1 f√ºr die Aktivierung und die Koordinaten, z. B. x = 100 und y = 120, schreiben Sie den Wert 100 an die Adresse 4148 und Adresse 4149 Wert 120. </font></font></p><br><h2 id="ispolzuem-assembler"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Assembler verwenden </font></font></h2><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eine der Programmiermethoden f√ºr die Konsole ist Assembler. </font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hier ist ein Beispiel, wie ein Sprite angezeigt und animiert wird, sodass es sich bewegt und von den R√§ndern des Bildschirms entfernt wird. </font></font></p><br><pre><code class="plaintext hljs">ORG 2100h PPU_SPRITES: EQU $1004 SPRITE_CHR: EQU 72 SPRITE_COLORKEY: EQU $1F SPRITE_INIT_POS_X: EQU 140 SPRITE_INIT_POS_Y: EQU 124 jp main DS $2166-$ nmi: ;    (NMI) ld bc, PPU_SPRITES + 3 ld a, (sprite_dir) and a, 1 jr z, subX in a, (c) ;  X inc a out (c), a cp 248 jr nz, updateY ld a, (sprite_dir) xor a, 1 ld (sprite_dir), a jp updateY subX: in a, (c) ;  X dec a out (c), a cp 32 jr nz, updateY ld a, (sprite_dir) xor a, 1 ld (sprite_dir), a updateY: inc bc ld a, (sprite_dir) and a, 2 jr z, subY in a, (c) ;  Y inc a out (c), a cp 216 jr nz, moveEnd ld a, (sprite_dir) xor a, 2 ld (sprite_dir), a jp moveEnd subY: in a, (c) ;  Y dec a out (c), a cp 32 jr nz, moveEnd ld a, (sprite_dir) xor a, 2 ld (sprite_dir), a moveEnd: ret main: ld bc, PPU_SPRITES ld a, 1 out (c), a ;   0 inc bc ld a, SPRITE_CHR out (c), a ;    0 inc bc ld a, SPRITE_COLORKEY out (c), a ;     0 inc bc ld a, SPRITE_INIT_POS_X out (c), a ;     0 inc bc ld a, SPRITE_INIT_POS_Y out (c), a ;   Y  0 mainLoop: jp mainLoop sprite_dir: DB 0</code> </pre> <br><p>  <strong><em>C-Sprache verwenden</em></strong> </p><br><p>  Sie k√∂nnen auch die Sprache C verwenden. Dazu ben√∂tigen wir den SDCC-Compiler und einige zus√§tzliche Dienstprogramme. </p><br><p>  C-Code ist zwar langsamer, aber das Schreiben ist schneller und einfacher. </p><br><p>  Hier ist ein Beispiel f√ºr Code, der mit dem obigen Assembler-Code identisch ist. Er verwendet eine Bibliothek, mit deren Hilfe PPU aufgerufen werden kann: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;console.h&gt; #define SPRITE_CHR 72 #define SPRITE_COLORKEY 0x1F #define SPRITE_INIT_POS_X 140 #define SPRITE_INIT_POS_Y 124 struct s_sprite sprite = { 1, SPRITE_CHR, SPRITE_COLORKEY, SPRITE_INIT_POS_X, SPRITE_INIT_POS_Y }; uint8_t sprite_dir = 0; void nmi() { if (sprite_dir &amp; 1) { sprite.x++; if (sprite.x == 248) { sprite_dir ^= 1; } } else { sprite.x--; if (sprite.x == 32) { sprite_dir ^= 1; } } if (sprite_dir &amp; 2) { sprite.y++; if (sprite.y == 216) { sprite_dir ^= 2; } } else { sprite.y--; if (sprite.x == 32) { sprite_dir ^= 2; } } set_sprite(0, sprite); } void main() { while(1) { } }</span></span></span></span></code> </pre> <br><h2 id="dinamicheskaya-grafika">  Dynamische Grafik </h2><br><p>  (In den originalen benutzerdefinierten Grafiken. Ca. Per.) </p><br><p>  Im Pr√§fix-ROM sind 1 Seite mit Kacheln zum Sichern und eine weitere Seite mit vorgefertigten Sprites vern√§ht. Standardm√§√üig k√∂nnen Sie nur diese festen Grafiken verwenden, aber Sie k√∂nnen zu dynamisch wechseln. </p><br><p>  Mein Ziel war es, dass alle notwendigen Grafiken in bin√§rer Form sofort in den CHR-RAM geladen wurden und der Code im Bootloader aus dem ROM dies kann.  Zu diesem Zweck habe ich mehrere Bilder in der richtigen Gr√∂√üe mit verschiedenen n√ºtzlichen Symbolen erstellt: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ed7/636/39c/ed763639cda1cf8ba163c3c30d2f0ec7.png" alt="imageSample-Kachel Kontakte"></p><br><p>  Da der Speicher f√ºr dynamische Grafiken aus 4 Seiten mit 256 Zeichen zu je 8 x 8 Pixel und 4 Seiten mit denselben Zeichen f√ºr Sprites besteht, habe ich die Bilder in das PNG-Format konvertiert und doppelte gel√∂scht: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/052/39d/5e9/05239d5e93c3578b8b720eedbc1c9169.png" alt="imageSample Zeichenblatt"></p><br><p>  Und dann √ºbersetzte er alles mit einem selbstgeschriebenen Tool in ein bin√§res RGB332-Format mit 8x8-Bl√∂cken. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a4c/8e7/4c6/a4c8e74c68c44e8f0f122002ebb021da.png" alt="imageGraphics-Befehlszeile"></p><br><p>  Als Ergebnis haben wir Dateien mit Zeichen, in denen alle Zeichen nacheinander ablaufen und jeweils 64 Bytes ben√∂tigen. </p><br><h2 id="zvuk">  Ton </h2><br><p>  Wave-RAW-Samples werden in 8-Bit-8-Kilohertz-PCM-Samples konvertiert. </p><br><p>  Patches f√ºr Soundeffekte auf PWM und Musik werden mit speziellen Anweisungen geschrieben. </p><br><p>  F√ºr den FM-Synthesechip YM3438 von Yamaha habe ich ein Programm namens DefleMask gefunden, das PAL-synchronisierte Musik f√ºr den Genesis YM2612-Chip erzeugt, der mit dem YM3438 kompatibel ist. </p><br><p>  DefleMask exportiert Musik im VGM-Format und ich konvertiere sie mit einem anderen propriet√§ren Dienstprogramm in mein eigenes Bin√§rformat. </p><br><p>  Alle Bin√§rdateien aller drei Soundtypen werden zu einer Bin√§rdatei zusammengefasst, die mein Bootloader lesen und in den SDN-RAM-Soundspeicher laden kann. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/aee/fb5/fd5/aeefb5fd5918b0653557889b2b00972a.png" alt="imageSound-Befehlszeile"></p><br><h2 id="linkovka-okonchatelnogo-fayla">  Link zur endg√ºltigen Datei </h2><br><p>  Bin√§rer ausf√ºhrbarer Code, Grafiken und Sound werden in einer PRG-Datei kombiniert.  Die PRG-Datei hat einen Header, in dem alles beschrieben wird, ob Audio- und Grafikdaten vorhanden sind, wie viel sie belegen und welche Daten selbst vorhanden sind. </p><br><p>  Eine solche Datei kann auf eine SD-Karte geschrieben werden, und der Konsolen-Bootloader ber√ºcksichtigt sie und l√§dt alles an die entsprechenden Stellen herunter und startet den ausf√ºhrbaren Programmcode. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/465/33e/43c/46533e43c8bca14c9cf9c36247b154eb.png" alt="imagePRG-Befehlszeile"></p><br><h2 id="emulyator">  Emulator </h2><br><p>  Ich habe mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wxWidgets</a> einen Emulator meiner Konsole in C ++ geschrieben, um die Entwicklung zu vereinfachen. </p><br><p>  Die CPU wird von der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">libz80-</a> Bibliothek emuliert. </p><br><p>  Dem Emulator wurden Funktionen zum Debuggen hinzugef√ºgt. Ich kann ihn jederzeit stoppen und den Assembler schrittweise debuggen. Wenn diese Sprache f√ºr das Spiel verwendet wurde, erfolgt eine Zuordnung zum Quellcode in C. </p><br><p>  Laut Grafik kann ich in den Videospeicher, in die Symboltabellen und in den CHR-Speicher selbst schauen. </p><br><p>  Hier ist ein Beispiel f√ºr ein Programm, das auf einem Emulator mit aktivierten Debugging-Tools ausgef√ºhrt wird. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/090/b54/70d/090b5470d7476d47c7212452716e9d11.gif" alt="imageEmulator Demo"></p><br><h1 id="demka-programmirovaniya">  Demo programmieren </h1><br><p>  Diese Videos wurden mit einer Smartphone-Kamera aufgenommen, die auf den CRT-Bildschirm des Fernsehger√§ts gerichtet ist. Ich entschuldige mich f√ºr die unvollst√§ndige Bildqualit√§t. </p><br><p>  Der √ºber die PS / 2-Tastatur programmierbare BASIC-Interpreter zeigt nach dem ersten Programm, wie durch Aktivieren und Verschieben des Sprites direkt √ºber den E / A-Adressraum in den PPU-Speicher geschrieben wird: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/2UNjKx4uZGY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Eine Demo von Grafiken in diesem Video l√§dt programmgesteuert 64 16x16-Sprites vor dem Hintergrund eines Hintergrunds mit dynamischem Bildlauf und einer √úberlagerung herunter, die sich unter und √ºber den Sprites bewegt: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/OA0q3_Krgxc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Die Sound-Demo zeigt die Funktionen von YM3438- und PWM-Sound. Die Sounddaten dieser Demo sowie FM-Musik und PWM-Sounds belegen zusammen fast alle verf√ºgbaren 128 Kilobyte Soundspeicher. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/xDsTGmqxLzM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Tetris, fast ausschlie√ülich die Hintergrundfunktionen, Musik auf dem YM3438, Soundeffekte auf PWM-Patches wurden f√ºr Grafiken verwendet. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/E77XZUwKd54" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h1 id="zaklyuchenie">  Fazit </h1><br><p>  Dieses Projekt ist wirklich ein wahr gewordener Traum. Ich arbeite seit mehreren Jahren daran. Mit Unterbrechungen und Blick auf meine Freizeit h√§tte ich nie gedacht, dass ich bei der Erstellung meiner eigenen Retro-Videospielkonsole so weit gehen w√ºrde.  Nat√ºrlich ist es nicht perfekt, ich bin sicherlich kein Experte f√ºr Elektronik, es gab offensichtlich zu viele Elemente in der Set-Top-Box, und zweifellos k√∂nnte es besser gemacht werden, und wahrscheinlich denkt einer der Leser nur dar√ºber nach. </p><br><p>  Trotzdem habe ich bei der Arbeit an diesem Projekt viel √ºber Elektronik, Spielekonsolen und Computerdesign, Assemblersprache und andere interessante Dinge gelernt, und vor allem war ich sehr zufrieden mit Spielen, die ich selbst auf von mir selbst entwickelter Hardware geschrieben habe und gesammelt. </p><br><p>  Ich habe Pl√§ne, Konsolen / Computer und mehr zu machen.  Eigentlich mache ich bereits eine neue Set-Top-Box, sie ist fast fertig und es handelt sich um eine vereinfachte Retro-Set-Top-Box, die auf einer FPGA-Karte und mehreren zus√§tzlichen Komponenten basiert (sicherlich in einer viel geringeren Menge als in diesem Projekt). Die Idee ist, viel billiger und wiederholbarer zu sein. </p><br><p>  Obwohl ich hier viel √ºber dieses Projekt geschrieben habe, kann zweifellos noch viel mehr besprochen werden. Ich habe kaum erw√§hnt, wie die Sound-Engine funktioniert, wie die CPU mit ihr interagiert und wie viel mehr √ºber das Grafiksystem und andere Ein- / Ausg√§nge und die gesamte Konsole getan werden kann w√§re zu erz√§hlen. </p><br><p>  Wenn ich mir die Reaktion der Leser anschaue, kann ich weitere Artikel schreiben, die sich auf Aktualisierungen, Details zu einzelnen Pr√§fixbl√∂cken oder andere Projekte konzentrieren. </p><br><h2 id="proekty-sayty-kanaly-youtube-kotorye-vdohnovlyali-menya-i-pomogali-mne-s-tehnicheskimi-znaniyami">  Projekte, Websites, Youtube-Kan√§le, die mich inspiriert und mir mit technischem Wissen geholfen haben: </h2><br><p>  Diese Websites / Kan√§le haben mich nicht nur inspiriert, sondern mir auch geholfen, L√∂sungen f√ºr komplexe Probleme zu finden, die w√§hrend der Arbeit an diesem Projekt entstanden sind. </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Uzebox</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ben Ryves</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Retroleum</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Z80.info</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">EEVBlog</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Retro Spielmechanik</a> </li></ul><br><p>  Vielen Dank f√ºr das Lesen bis hierher.  :) :) </p><br><p>  Wenn Sie Fragen oder Feedback haben, schreiben Sie bitte in die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kommentare unten</a> (Originalartikel in englischer Sprache auf Github. Ca. Per.) </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de444006/">https://habr.com/ru/post/de444006/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de443996/index.html">Ank√ºndigung von TypeScript 3.4 RC</a></li>
<li><a href="../de443998/index.html">Neuer Weltrekord f√ºr die Berechnung der Anzahl der pi: 31,4 Billionen Zeichen</a></li>
<li><a href="../de444000/index.html">Wo soll ich anfangen, wenn ich zum ersten Mal Personal anheuere?</a></li>
<li><a href="../de444002/index.html">Der weltweit erste ‚Äûgeschlechtsneutrale‚Äú Sprachassistent, der auf dem SXSW IT Festival vorgestellt wurde</a></li>
<li><a href="../de444004/index.html">CLRium # 5: Alles √ºber GC und mehr. Peter und Moskau</a></li>
<li><a href="../de444010/index.html">.NET Core Container-Images jetzt in der Microsoft Container Registry ver√∂ffentlicht</a></li>
<li><a href="../de444014/index.html">Microsoft er√∂ffnet die Business School, um KI-Strategien, Kultur und Verantwortung zu lernen</a></li>
<li><a href="../de444016/index.html">Erreichen Sie mehr mit Microsoft Game Stack</a></li>
<li><a href="../de444018/index.html">Wie eine √Ñnderung der PostgreSQL-Konfiguration die Leistung langsamer Abfragen 50-mal verbessert</a></li>
<li><a href="../de444020/index.html">Karting in der UdSSR: Wie das Hobby amerikanischer Piloten zu einem massiven DIY-Hobby in der Sowjetunion wurde</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>