<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üÉè üå¶Ô∏è üë©üèæ‚Äç‚öñÔ∏è Wir entwickeln das NIOS II-Prozessormodul f√ºr IDA Pro üìç ‚òòÔ∏è ‚òØÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Screenshot der IDA Pro Disassembler-Schnittstelle 

 IDA Pro ist ein ber√ºhmter Disassembler, der seit vielen Jahren von Informationssicherheitsforsche...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir entwickeln das NIOS II-Prozessormodul f√ºr IDA Pro</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pt/blog/424085/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/141/008/5b2/1410085b245c7ef6a18074b47dda1b6b.gif" alt="Bild"></a> <br><br>  <i>Screenshot der IDA Pro Disassembler-Schnittstelle</i> <br><br>  IDA Pro ist ein ber√ºhmter Disassembler, der seit vielen Jahren von Informationssicherheitsforschern auf der ganzen Welt eingesetzt wird.  Wir bei Positive Technologies verwenden dieses Tool ebenfalls.  Dar√ºber hinaus konnten wir ein eigenes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Disassembler-Prozessormodul f√ºr die NIOS II-Mikroprozessorarchitektur entwickeln</a> , das die Geschwindigkeit und den Komfort der Codeanalyse erh√∂ht. <br><br>  Heute werde ich √ºber die Geschichte dieses Projekts erz√§hlen und zeigen, was am Ende passiert ist. <a name="habracut"></a><br><br><h2>  Hintergrund </h2><br>  Alles begann im Jahr 2016, als wir unser eigenes Prozessormodul entwickeln mussten, um die Firmware in einer Aufgabe zu analysieren.  Die Entwicklung wurde von Grund auf anhand des Handbuchs <a href="">Nios II Classic Processor Reference Guide durchgef√ºhrt</a> , das damals am relevantesten war.  Insgesamt dauerte diese Arbeit etwa zwei Wochen. <br><br>  Das Prozessormodul wurde f√ºr die Version IDA 6.9 entwickelt.  Aus Gr√ºnden der Geschwindigkeit wurde IDA Python ausgew√§hlt.  An der Stelle, an der sich die Prozessormodule befinden - dem Unterverzeichnis procs im IDA Pro-Installationsverzeichnis - befinden sich drei Python-Module: msp430, ebc, spu.  In ihnen k√∂nnen Sie sehen, wie das Modul angeordnet ist und wie die grundlegenden Demontagefunktionen implementiert werden k√∂nnen: <br><br><ul><li>  Analyseanweisungen und Operanden, </li><li>  ihre Vereinfachung und Darstellung, </li><li>  Erstellen von Offsets, Querverweisen sowie des Codes und der Daten, auf die sie sich beziehen </li><li>  Verarbeitung von Schalterkonstruktionen, </li><li>  Umgang mit Manipulationen mit dem Stack und den Stack-Variablen. </li></ul><br>  Ungef√§hr diese Funktionalit√§t wurde zu dieser Zeit implementiert.  Gl√ºcklicherweise war das Tool n√ºtzlich, um an einer anderen Aufgabe zu arbeiten, bei der es ein Jahr sp√§ter aktiv genutzt und verfeinert wurde. <br><br>  Ich beschloss, die Erfahrungen mit der Erstellung des Prozessormoduls bei den PHDays 8 mit der Community zu teilen. Die Pr√§sentation erregte Interesse (der Videobericht wurde auf der PHDays-Website ver√∂ffentlicht), sogar der Sch√∂pfer von IDA Pro Ilfak Gilfanov war anwesend.  Eine seiner Fragen war, ob die Unterst√ºtzung f√ºr IDA Pro Version 7 implementiert wurde. Zu diesem Zeitpunkt war sie nicht vorhanden, aber nach der Auff√ºhrung versprach ich, eine entsprechende Version des Moduls zu ver√∂ffentlichen.  Hier begann der Spa√ü. <br><br>  Jetzt das neueste <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Handbuch von Intel</a> , mit dem Fehler √ºberpr√ºft und √ºberpr√ºft wurden.  Ich habe das Modul erheblich √ºberarbeitet und eine Reihe neuer Funktionen hinzugef√ºgt, darunter die L√∂sung der Probleme, die zuvor nicht behoben werden konnten.  Nat√ºrlich habe ich Unterst√ºtzung f√ºr die 7. Version von IDA Pro hinzugef√ºgt.  Folgendes ist passiert. <br><br><h2>  NIOS II-Softwaremodell </h2><br>  NIOS II ist ein Softwareprozessor, der f√ºr Altera-FPGAs (jetzt Teil von Intel) entwickelt wurde.  Aus Sicht der Programme weist es die folgenden Merkmale auf: Bytereihenfolge des Little Endian, 32-Bit-Adressraum, 32-Bit-Befehlssatz, dh 4 Bytes, 32 allgemeine und 32 Spezialregister werden zum Codieren jedes Befehls verwendet. <br><br><h2>  Demontage- und Code-Referenzen </h2><br>  Deshalb haben wir in IDA Pro eine neue Datei mit Firmware f√ºr den NIOS II-Prozessor ge√∂ffnet.  Nach der Installation des Moduls wird es in der Liste der IDA Pro-Prozessoren angezeigt.  Die Wahl des Prozessors ist in der Abbildung dargestellt. <br><br><img src="https://habrastorage.org/webt/9x/wd/ni/9xwdnil54uqjf3wru4nqcc0fkr8.png"><br><br>  Angenommen, das Modul hat noch nicht einmal eine grundlegende Analyse von Befehlen implementiert.  Da jeder Befehl 4 Bytes ben√∂tigt, gruppieren wir die Bytes in vier, dann sieht alles ungef√§hr so ‚Äã‚Äãaus. <br><br><img src="https://habrastorage.org/webt/be/v9/_j/bev9_jokezmrwfxgr5gtscagrma.png"><br><br>  Nachdem die Grundfunktionen zum Decodieren von Anweisungen und Operanden implementiert, auf dem Bildschirm angezeigt und Steuer√ºbertragungsanweisungen analysiert wurden, wird der im obigen Beispiel festgelegte Bytesatz in den folgenden Code konvertiert. <br><br><img src="https://habrastorage.org/webt/w6/zm/5c/w6zm5c7rzp0ee0qec2twmkzdnxe.png"><br><br>  Wie aus dem Beispiel ersichtlich ist, werden Querverweise auch aus Steuer√ºbertragungsbefehlen generiert (in diesem Fall sehen Sie den bedingten Sprung und den Prozeduraufruf). <br><br>  Eine der n√ºtzlichen Eigenschaften, die in Prozessormodulen implementiert werden k√∂nnen, sind Befehlskommentare.  Wenn Sie die Ausgabe von Bytewerten deaktivieren und die Ausgabe von Kommentaren aktivieren, sieht derselbe Codeabschnitt bereits so aus. <br><br><img src="https://habrastorage.org/webt/gu/ia/u0/guiau0csjjbidgimzewinug4pvq.png"><br><br>  Wenn Sie hier zum ersten Mal auf den Assembler-Code einer neuen Architektur gesto√üen sind, k√∂nnen Sie anhand von Kommentaren verstehen, was passiert.  Dar√ºber hinaus haben die Codebeispiele dieselbe Form - mit Kommentaren, um nicht das NIOS II-Handbuch zu lesen, sondern sofort zu verstehen, was im Codeabschnitt geschieht, der als Beispiel angegeben ist. <br><br><h2>  Pseudoanweisungen und Vereinfachung von Befehlen </h2><br>  Einige NIOS II-Befehle sind Pseudobefehle.  F√ºr solche Teams gibt es keine separaten Opcodes, und sie selbst werden als Sonderf√§lle anderer Teams modelliert.  Beim Zerlegen wird eine Vereinfachung der Anweisungen durchgef√ºhrt - das Ersetzen bestimmter Kombinationen durch Pseudobefehle.  Pseudoanweisungen in NIOS II k√∂nnen allgemein in vier Typen unterteilt werden: <br><br><ul><li>  wenn eine der Quellen Null ist (r0) und aus der Betrachtung entfernt werden kann, </li><li>  wenn das Team einen negativen Wert hat und das Team durch das Gegenteil ersetzt wird, </li><li>  wenn der Zustand umgekehrt ist, </li><li>  Wenn der 32-Bit-Offset in zwei Teams in Teilen (dem j√ºngsten und dem √§ltesten) eingegeben wird und dieser durch einen Befehl ersetzt wird. </li></ul><br>  Die ersten beiden Typen wurden implementiert, da das Ersetzen der Bedingung nichts Besonderes ergibt und 32-Bit-Offsets mehr Optionen bieten als im Handbuch dargestellt. <br><br>  Betrachten Sie beispielsweise f√ºr die erste Ansicht den Code. <br><br><img src="https://habrastorage.org/webt/ix/if/kt/ixifktzau98plchui3ypjf0qn6c.png"><br><br>  Es ist ersichtlich, dass hier h√§ufig die Verwendung des Nullregisters in Berechnungen gefunden wird.  Wenn Sie sich dieses Beispiel genau ansehen, werden Sie feststellen, dass alle Befehle au√üer der √úbertragung der Steuerung Optionen zum einfachen Eingeben von Werten in bestimmte Register sind. <br><br>  Nachdem wir die Verarbeitung von Pseudobefehlen implementiert haben, erhalten wir denselben Codeabschnitt, aber jetzt sieht er besser lesbar aus, und anstelle von Variationen der Befehle oder und add erhalten wir Variationen des Befehls mov. <br><br><img src="https://habrastorage.org/webt/ka/4j/_q/ka4j_qwz2elzmsmccfrewbtn9cc.png"><br><br><h2>  Stapelvariablen </h2><br>  Die NIOS II-Architektur unterst√ºtzt den Stapel, und zus√§tzlich zum Stapelzeiger sp gibt es auch einen Zeiger auf den fp-Stapelrahmen.  Betrachten Sie ein Beispiel f√ºr eine kleine Prozedur, die einen Stapel verwendet. <br><br><img src="https://habrastorage.org/webt/82/_o/1v/82_o1v_n-ojrlgtveqtfjln2vve.png"><br><br>  Offensichtlich ist Platz f√ºr lokale Variablen auf dem Stapel reserviert.  Es kann davon ausgegangen werden, dass das Register ra in der Stapelvariablen gespeichert und daraus wiederhergestellt wird. <br><br>  Nach dem Hinzuf√ºgen von Funktionen zum Modul, die √Ñnderungen im Stapelzeiger verfolgen und Stapelvariablen erstellen, sieht dasselbe Beispiel folgenderma√üen aus. <br><br><img src="https://habrastorage.org/webt/zg/pk/fx/zgpkfxblezz4cp78gfqswegbjza.png"><br><br>  Jetzt sieht der Code etwas klarer aus, und Sie k√∂nnen die Stapelvariablen bereits benennen und ihren Zweck analysieren, indem Sie den Querverweisen folgen.  Die Funktion im Beispiel ist vom Typ __fastcall und ihre Argumente in den Registern r4 und r5 werden auf den Stapel geschoben, um eine Unterprozedur vom Typ _stdcall aufzurufen. <br><br><h2>  32-Bit-Zahlen und Offsets </h2><br>  Die Besonderheit von NIOS II besteht darin, dass in einer Operation, dh wenn ein einzelner Befehl ausgef√ºhrt wird, h√∂chstens ein direkter Wert von 2 Bytes (16 Bit) registriert werden kann.  Andererseits sind die Prozessorregister und der Adressraum 32-Bit, dh zum Adressieren m√ºssen 4 Bytes in das Register eingegeben werden. <br><br>  Um dieses Problem zu l√∂sen, werden zweiteilige Verschiebungen verwendet.  Ein √§hnlicher Mechanismus wird in Prozessoren in PowerPC verwendet: Der Offset besteht aus zwei Teilen, dem √§ltesten und dem j√ºngsten, und wird durch zwei Befehle in das Register eingegeben.  In PowerPC ist dies wie folgt. <br><br><img src="https://habrastorage.org/webt/n8/qm/5z/n8qm5zedw9ffnckmjclzmhfwkh8.png"><br><br>  Bei diesem Ansatz werden aus beiden Teams Querverbindungen gebildet, obwohl die Adresse tats√§chlich im zweiten Befehl konfiguriert wird.  Dies kann manchmal st√∂rend sein, wenn die Anzahl der Querverweise gez√§hlt wird. <br><br>  Die Offset-Eigenschaften f√ºr das √§ltere Teil verwenden den nicht standardm√§√üigen Typ HIGHA16, manchmal wird der Typ HIGH16 f√ºr das j√ºngere Teil verwendet - LOW16. <br><br><img src="https://habrastorage.org/webt/l-/u3/6r/l-u36riq53_ejmry2mwdv7qewp4.png"><br><br>  Die Berechnung von zweiteiligen 32-Bit-Zahlen ist nicht kompliziert.  Schwierigkeiten ergeben sich bei der Bildung von Operanden als Offsets f√ºr zwei separate Teams.  All diese Verarbeitung f√§llt auf das Prozessormodul.  Es gibt keine Beispiele daf√ºr, wie dies (insbesondere in Python) im IDA SDK implementiert werden kann. <br><br>  In dem Bericht √ºber PHDays waren Vorurteile ein ungel√∂stes Problem.  Um das Problem zu l√∂sen, haben wir betrogen: 32-Bit-Offset nur vom j√ºngsten Teil - auf der Basis.  Die Basis wird als √§ltester Teil berechnet und um 16 Bit nach links verschoben. <br><br><img src="https://habrastorage.org/webt/ip/lc/60/iplc60jwuylhovnugr8qgyxorbq.png"><br><br>  Bei diesem Ansatz wird ein Querverweis nur mit dem Befehl zum Eingeben des unteren Teils des 32-Bit-Offsets gebildet. <br><br>  Die Basis ist in den Offset-Eigenschaften sichtbar und die Eigenschaft ist markiert, um sie als Zahl zu betrachten, so dass keine gro√üe Anzahl von Querverweisen auf die Adresse selbst gebildet wird, die wir als Basis nehmen. <br><br><img src="https://habrastorage.org/webt/_3/ui/wy/_3uiwyr9jt0lpipfsounaz07q3c.png"><br><br>  Im Code f√ºr NIOS II wird der folgende Mechanismus zum Eingeben von 32-Bit-Zahlen in das Register gefunden.  Zun√§chst wird der √§lteste Teil des Offsets mit dem Befehl movhi in das Register eingetragen.  Dann schlie√üt sich der j√ºngere Teil an.  Dies kann auf drei Arten (durch Befehle) erfolgen: Hinzuf√ºgen von Addi, Subtrahieren von Subi, logisches ODER-Ori. <br><br>  Beispielsweise werden im n√§chsten Codeabschnitt die Register auf 32-Bit-Zahlen gesetzt, die dann vor dem Aufruf der Funktion in Register - Argumente - eingegeben werden. <br><br><img src="https://habrastorage.org/webt/rs/4l/ms/rs4lmsgotpjsjrb92qh6gkk9s-y.png"><br><br>  Nach dem Hinzuf√ºgen der Offsetberechnung erhalten wir die folgende Darstellung dieses Codeblocks. <br><br><img src="https://habrastorage.org/webt/sg/3c/i_/sg3ci__0-wvfkj-5j40xuemubva.png"><br><br>  Der resultierende 32-Bit-Offset wird neben dem Befehl zur Eingabe des unteren Teils angezeigt.  Dieses Beispiel ist sehr anschaulich, und wir k√∂nnten sogar alle 32-Bit-Zahlen im Kopf leicht berechnen, indem wir einfach die kleinen und h√∂chsten Teile hinzuf√ºgen.  Nach den Werten zu urteilen, sind sie h√∂chstwahrscheinlich keine Vorurteile. <br><br>  Betrachten Sie den Fall, wenn beim Betreten des j√ºngeren Teils die Subtraktion verwendet wird.  In diesem Beispiel ist es nicht m√∂glich, die endg√ºltigen 32-Bit-Zahlen (Offsets) unterwegs zu ermitteln. <br><br><img src="https://habrastorage.org/webt/i-/8x/yt/i-8xyto-q5iqeiffz3hua-d29ew.png"><br><br>  Nach der Berechnung der 32-Bit-Zahlen erhalten wir das folgende Formular. <br><br><img src="https://habrastorage.org/webt/tf/da/8-/tfda8-uw3xkthiqqe930jut8ovs.png"><br><br>  Hier sehen wir, dass jetzt, wenn sich die Adresse im Adressraum befindet, ein Versatz darauf gebildet wird und der Wert, der als Ergebnis der Verbindung der Neben- und Oberteile gebildet wurde, nicht mehr in der N√§he angezeigt wird.  Hier erhielten sie einen Versatz durch die Zeile ‚Äû22.10.08‚Äú.  Damit der Rest der Offsets auf g√ºltige Adressen verweist, erh√∂hen wir das Segment ein wenig. <br><br><img src="https://habrastorage.org/webt/0i/qq/fh/0iqqfhcomre0yd3siixym3vt0o8.png"><br><br>  Nach dem Erh√∂hen des Segments erhalten wir, dass jetzt alle berechneten 32-Bit-Zahlen Offsets sind und g√ºltige Adressen angeben. <br><br>  Es wurde oben erw√§hnt, dass es eine andere Option zum Berechnen von Offsets gibt, wenn ein logischer ODER-Befehl verwendet wird.  Hier ist ein Beispielcode, in dem zwei Offsets auf diese Weise berechnet werden. <br><br><img src="https://habrastorage.org/webt/xr/or/am/xroramzy4_lj_g3po7yxo-m0sxy.png"><br><br>  Derjenige, der im r8-Register ausgewertet wird, wird dann auf den Stapel geschoben. <br><br>  Nach der Konvertierung ist ersichtlich, dass in diesem Fall die Register auf die Adressen des Beginns der Prozeduren konfiguriert sind, dh die Adresse der Prozedur wird auf den Stapel geschoben. <br><br><img src="https://habrastorage.org/webt/wr/au/qm/wrauqmfpotzlhjdiz4_i8mnghri.png"><br><br><h2>  Lesen und Schreiben relativ zur Basis </h2><br>  Zuvor haben wir F√§lle betrachtet, in denen eine 32-Bit-Zahl, die mit zwei Befehlen eingegeben wurde, nur eine Zahl und auch ein Versatz sein kann.  Im folgenden Beispiel wird die Basis in den oberen Teil des Registers eingegeben, und das Lesen oder Schreiben erfolgt relativ dazu. <br><br><img src="https://habrastorage.org/webt/ho/2v/ve/ho2vvexmp7367xll5prt5xwpc8m.png"><br><br>  Nach der Verarbeitung solcher Situationen erhalten wir den Offset zu den Variablen aus den Lese- und Schreibbefehlen selbst.  Dar√ºber hinaus wird abh√§ngig von der Dimension der Operation die Gr√∂√üe der Variablen selbst festgelegt. <br><br><img src="https://habrastorage.org/webt/cl/pi/g-/clpig-mgt5xtsshbvp67wh9rrdg.png"><br><br><h2>  Konstruktionen wechseln </h2><br>  Die in Bin√§rdateien gefundenen Schalterkonstrukte k√∂nnen die Analyse erleichtern.  Anhand der Anzahl der Auswahlf√§lle innerhalb des Switch-Konstrukts k√∂nnen Sie beispielsweise den Switch lokalisieren, der f√ºr die Verarbeitung eines bestimmten Protokolls oder Befehlssystems verantwortlich ist.  Daher besteht die Aufgabe darin, den Schalter selbst und seine Parameter zu erkennen.  Betrachten Sie den folgenden Codeabschnitt. <br><br><img src="https://habrastorage.org/webt/g9/t7/7u/g9t77ugtkercggcjphfq9xfam_0.png"><br><br>  Der Ausf√ºhrungsthread stoppt beim √úbergang des Registers jmp r2.  Ferner gibt es Codebl√∂cke, zu denen Links von den Daten bestehen, und am Ende jedes Blocks gibt es einen Sprung zu derselben Bezeichnung.  Offensichtlich ist dies ein Schalterkonstrukt, und diese einzelnen Bl√∂cke behandeln bestimmte F√§lle daraus.  Oben sehen Sie auch die √úberpr√ºfung der Anzahl der F√§lle und den Standardsprung. <br><br>  Nach dem Hinzuf√ºgen der Switch-Verarbeitung sieht dieser Code folgenderma√üen aus. <br><br><img src="https://habrastorage.org/webt/rm/qj/hw/rmqjhwhrknmc_cycqu5d57kjpmq.png"><br><br>  Nun wird der Sprung selbst angezeigt, die Adresse der Tabelle mit Offsets, die Anzahl der F√§lle sowie jeder Fall mit der entsprechenden Anzahl. <br><br>  Die Tabelle selbst mit Offsets zu den Optionen lautet wie folgt.  Um Platz zu sparen, werden die ersten f√ºnf Elemente angegeben. <br><br><img src="https://habrastorage.org/webt/9b/ke/x9/9bkex9oxlk_vv4nrpdya3nckv3m.png"><br><br>  Tats√§chlich besteht die Verarbeitung des Schalters darin, den Code erneut durchzugehen und nach allen seinen Komponenten zu suchen.  Das hei√üt, ein Switch-Organisationsschema wird beschrieben.  Manchmal kann es Ausnahmen in den Schemata geben.  Dies kann der Grund f√ºr F√§lle sein, in denen die scheinbar klaren Schalter in vorhandenen Prozessormodulen nicht erkannt werden.  Es stellt sich heraus, dass der reale Switch einfach nicht unter das im Prozessormodul definierte Schema f√§llt.  Es gibt immer noch m√∂gliche Optionen, wenn die Rennstrecke vorhanden zu sein scheint, aber es gibt andere Teams in der Rennstrecke, die nicht an der Rennstrecke beteiligt sind, oder die Hauptteams werden neu angeordnet oder sie werden durch √úberg√§nge unterbrochen. <br><br>  Das NIOS II-Prozessormodul erkennt einen Schalter mit solchen "fremden" Anweisungen zwischen den Hauptbefehlen sowie mit den neu angeordneten Stellen der Hauptbefehle und mit Unterbrechungen, die die Schaltung unterbrechen.  Entlang des Ausf√ºhrungspfads wird ein R√ºckweg verwendet, der m√∂gliche √úberg√§nge ber√ºcksichtigt, die die Schaltung unterbrechen, und interne Variablen installiert, die unterschiedliche Zust√§nde des Erkenners signalisieren.  Infolgedessen werden ungef√§hr 10 verschiedene Switch-Organisationsoptionen in der Firmware erkannt. <br><br><h2>  Benutzerdefinierte Anweisung </h2><br>  In der NIOS II-Architektur gibt es eine interessante Funktion - die benutzerdefinierte Anweisung.  Es bietet Zugriff auf 256 benutzerdefinierte Anweisungen, die in der NIOS II-Architektur m√∂glich sind.  In seiner Arbeit kann der benutzerdefinierte Befehl zus√§tzlich zu Allzweckregistern auf einen speziellen Satz von 32 benutzerdefinierten Registern zugreifen.  Nach der Implementierung der Logik zum Parsen des benutzerdefinierten Befehls erhalten wir das folgende Formular. <br><br><img src="https://habrastorage.org/webt/ws/8d/zo/ws8dzozz7aext7buc0g3re8kwno.png"><br><br>  M√∂glicherweise stellen Sie fest, dass die letzten beiden Anweisungen dieselbe Anweisungsnummer haben und dieselben Aktionen ausf√ºhren. <br><br>  Gem√§√ü den benutzerdefinierten Anweisungen gibt es ein <a href="">separates Handbuch</a> .  Ihm zufolge ist eine der umfassendsten und aktuellsten Optionen f√ºr den benutzerdefinierten Befehlssatz der Befehlssatz NIOS II Floating Point Hardware 2 Component (FPH2) f√ºr die Arbeit mit dem Gleitkomma.  Nach der Implementierung des Parsens von FPH2-Befehlen sieht das Beispiel folgenderma√üen aus. <br><br><img src="https://habrastorage.org/webt/ex/-q/1g/ex-q1g9sszau_hhllau3_xrvgdw.png"><br><br>  Aus den Mnemoniken der letzten beiden Teams geht hervor, dass sie wirklich dieselbe Aktion ausf√ºhren - den Befehl fadds. <br><br><h2>  √úberg√§nge nach Registerwert </h2><br>  In der untersuchten Firmware tritt h√§ufig eine Situation auf, wenn ein Sprung gem√§√ü dem Wert des Registers ausgef√ºhrt wird, in den zuvor ein 32-Bit-Offset eingegeben wird, der den Ort des Sprungs bestimmt. <br><br>  Betrachten Sie einen Code. <br><br><img src="https://habrastorage.org/webt/sj/ej/ys/sjejysq65hywye8w6usdbshkc60.png"><br><br>  In der letzten Zeile gibt es einen Sprung im Wert des Registers, w√§hrend klar ist, dass die Prozeduradresse, die in der ersten Zeile des Beispiels beginnt, zuerst in das Register eingegeben wird.  In diesem Fall ist es offensichtlich, dass der Sprung zu seinem Anfang gemacht wird. <br><br>  Nach dem Hinzuf√ºgen der Erkennungsfunktionalit√§t von Spr√ºngen wird die folgende Form erhalten. <br><br><img src="https://habrastorage.org/webt/ov/tm/j2/ovtmj2lcb_8lrx8qmxvekuul0lw.png"><br><br>  Neben dem Befehl jmp r8 wird die Adresse angezeigt, an der der Sprung erfolgt, wenn eine Berechnung m√∂glich war.  Ein Querverweis wird auch zwischen dem Team und der Adresse gebildet, an der der Sprung stattfindet.  In diesem Fall ist der Link in der ersten Zeile sichtbar, der Sprung selbst wird von der letzten Zeile ausgef√ºhrt. <br><br><h2>  GP-Registerwert (globaler Zeiger), speichern und laden </h2><br>  Es ist √ºblich, einen globalen Zeiger zu verwenden, der f√ºr eine bestimmte Adresse konfiguriert ist, und Variablen werden relativ dazu adressiert.  NIOS II verwendet das Register gp (Global Pointer), um den globalen Zeiger zu speichern.  Irgendwann wird in der Regel bei den Initialisierungsprozeduren der Firmware der Adresswert in das GP-Register eingetragen.  Das Prozessormodul behandelt diese Situation.  Um dies zu veranschaulichen, sind im Folgenden Codebeispiele und das IDA Pro-Ausgabefenster aufgef√ºhrt, wenn Debugging-Meldungen im Prozessormodul aktiviert sind. <br><br>  In diesem Beispiel findet und berechnet das Prozessormodul den Wert des GP-Registers in der neuen Datenbank.  Beim Schlie√üen der IDB-Datenbank wird der GP-Wert in der Datenbank gespeichert. <br><br><img src="https://habrastorage.org/webt/cx/ll/hk/cxllhko-hugm77k68idqqam4wzm.png"><br><br>  Wenn eine vorhandene IDB-Datenbank geladen wird und der GP-Wert bereits gefunden wurde, wird er aus der Datenbank geladen, wie in der Debug-Meldung im folgenden Beispiel gezeigt. <br><br><img src="https://habrastorage.org/webt/-y/z7/1u/-yz71u_odhytnmobj0dlfb73v-k.png"><br><br><h2>  Lesen und Schreiben zu gp </h2><br>  √úbliche Operationen sind Lesen und Schreiben mit einem Versatz relativ zum GP-Register.  Im folgenden Beispiel werden beispielsweise drei Lesevorg√§nge und ein Datensatz dieser Art ausgef√ºhrt. <br><br><img src="https://habrastorage.org/webt/6b/0l/-b/6b0l-bqxv1qiuw5nvh3i08vvstk.png"><br><br>  Da wir bereits den Wert der Adresse erhalten haben, die im GP-Register gespeichert ist, k√∂nnen wir diese Art des Lesens und Schreibens adressieren. <br><br>  Nachdem wir die Verarbeitung f√ºr Lese- und Schreibsituationen relativ zum GP-Register hinzugef√ºgt haben, erhalten wir ein bequemeres Bild. <br><br><img src="https://habrastorage.org/webt/wx/st/c1/wxstc1auiw0z0gvfzwmcooocooq.png"><br><br>  Hier k√∂nnen Sie sehen, auf welche Variablen zugegriffen wird, ihre Verwendung verfolgen und ihren Zweck identifizieren. <br><br><h2>  Adressierung relativ zu gp </h2><br>  Es gibt eine andere Verwendung des gp-Registers zum Adressieren von Variablen. <br><br><img src="https://habrastorage.org/webt/ng/nn/oc/ngnnocz7scbya0x41l7gagf4bew.png"><br><br>  Hier sehen wir zum Beispiel, dass die Register relativ zum GP-Register f√ºr einige Variablen oder Datenbereiche konfiguriert sind. <br><br>  Nach dem Hinzuf√ºgen von Funktionen, die solche Situationen erkennen, in Offsets konvertieren und Querverweise hinzuf√ºgen, erhalten wir das folgende Formular. <br><br><img src="https://habrastorage.org/webt/sm/0d/nd/sm0dndgvrmn2xwivnfux3ol-t1e.png"><br><br>  Hier k√∂nnen Sie bereits sehen, welche Bereiche in Bezug auf GP-Register konfiguriert sind, und es wird klarer, was passiert. <br><br><h2>  Adressierung relativ zu sp </h2><br>  In √§hnlicher Weise werden im folgenden Beispiel die Register auf einige Speicherbereiche abgestimmt, diesmal relativ zum Register sp - Zeiger auf den Stapel. <br><br><img src="https://habrastorage.org/webt/p1/nv/k7/p1nvk7gox_d3cwi1gof80k_oizq.png"><br><br>  Offensichtlich sind die Register auf einige lokale Variablen abgestimmt.  Solche Situationen - das Setzen von Argumenten auf lokale Puffer vor Prozeduraufrufen - sind h√§ufig genug. <br><br>  Nach dem Hinzuf√ºgen der Verarbeitung (Konvertieren direkter Werte in Offsets) erhalten wir das folgende Formular. <br><br><img src="https://habrastorage.org/webt/mg/8s/ps/mg8spswm9tq-_zjj-80s0s6lbnk.png"><br><br>  Nun wird klar, dass nach dem Prozeduraufruf die Werte aus den Variablen geladen werden, deren Adressen vor dem Funktionsaufruf als Parameter √ºbergeben wurden. <br><br><h2>  Querverweise von Code zu Strukturfeldern </h2><br>  Das Definieren und Verwenden von Strukturen in IDA Pro kann die Codeanalyse erleichtern. <br><br><img src="https://habrastorage.org/webt/l6/4u/8u/l64u8ubhx9-ypg1vo914_fa8vta.png"><br><br>  Wenn wir uns diesen Teil des Codes ansehen, k√∂nnen wir verstehen, dass das Feld field_8 inkrementiert und m√∂glicherweise ein Z√§hler f√ºr das Auftreten eines Ereignisses ist.  Wenn Lese- und Schreibfelder im Code in gro√üer Entfernung voneinander getrennt sind, kann ein Querverweis hilfreich sein. <br><br>  Betrachten Sie die Struktur selbst. <br><br><img src="https://habrastorage.org/webt/px/zf/lt/pxzflte9x7kmxfrnipa_yjerstc.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl der Zugriff auf die Felder von Strukturen, wie wir sehen, keine Querverweise vom Code zu den Elementen von Strukturen gibt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem solche Situationen verarbeitet wurden, sieht in unserem Fall alles wie folgt aus. </font></font><br><br><img src="https://habrastorage.org/webt/k_/7t/zu/k_7tzupju7tyyje9r-i6ed6ra08.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt gibt es Querverweise auf Strukturfelder von bestimmten Teams, die mit diesen Feldern arbeiten. </font><font style="vertical-align: inherit;">Vorw√§rts- und R√ºckw√§rtsquerverweise werden erstellt, und Sie k√∂nnen nach verschiedenen Verfahren verfolgen, wo die Werte der Strukturfelder gelesen und wo sie eingegeben werden.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Diskrepanzen zwischen Handbuch und Realit√§t </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Handbuch m√ºssen beim Decodieren einiger Befehle bestimmte Bits streng definierte Werte annehmen. </font><font style="vertical-align: inherit;">F√ºr einen R√ºckgabebefehl von einer eret-Ausnahme sollten die Bits 22‚Äì26 beispielsweise 0x1E sein. </font></font><br><br><img src="https://habrastorage.org/webt/6r/o4/ys/6ro4ys-mrzuck_-stdnjctilwq8.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier ist ein Beispiel f√ºr diesen Befehl aus einer Firmware. </font></font><br><br><img src="https://habrastorage.org/webt/te/lv/at/telvatwfv4tmdjpaurhickredpo.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir eine andere Firmware an einem Ort mit einem √§hnlichen Kontext √∂ffnen, sto√üen wir auf eine andere Situation. </font></font><br><br><img src="https://habrastorage.org/webt/ss/p3/qg/ssp3qgrbyu4stqyfht6mmzitgmi.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Bytes wurden nicht automatisch in einen Befehl konvertiert, obwohl alle Befehle verarbeitet werden. </font><font style="vertical-align: inherit;">Gemessen an der Umgebung und sogar einer √§hnlichen Adresse sollte dies dasselbe Team sein. </font><font style="vertical-align: inherit;">Schauen wir uns die Bytes genau an. </font><font style="vertical-align: inherit;">Dies ist der gleiche Befehl zum L√∂schen, mit der Ausnahme, dass die Bits 22‚Äì26 nicht gleich 0x1E, sondern gleich Null sind. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir m√ºssen die Analyse dieses Befehls etwas korrigieren. </font><font style="vertical-align: inherit;">Jetzt entspricht es nicht ganz dem Handbuch, aber es entspricht der Realit√§t.</font></font><br><br><img src="https://habrastorage.org/webt/as/fn/nl/asfnnlau91zf6y1aan-f3l__wz0.png"><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IDA 7-Unterst√ºtzung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ab IDA 7.0 hat sich die von Python IDA f√ºr regul√§re Skripte bereitgestellte API erheblich ge√§ndert. Bei den Prozessormodulen sind die √Ñnderungen enorm. Trotzdem konnte das NIOS II-Prozessormodul f√ºr Version 7 neu erstellt werden und funktionierte erfolgreich darin. </font></font><br><br><img src="https://habrastorage.org/webt/-w/zh/z_/-wzhz_lzuq_ad226tgx_0abl3ke.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der einzige unverst√§ndliche Moment: Beim Laden einer neuen Bin√§rdatei unter NIOS II in IDA 7 findet die erste automatische Analyse in IDA 6.9 nicht statt.</font></font><br><br><h2>  Fazit </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zus√§tzlich zu den grundlegenden Demontagefunktionen, von denen Beispiele im SDK enthalten sind, implementiert das Prozessormodul viele verschiedene Funktionen, die die Arbeit des Code-Explorers erleichtern. </font><font style="vertical-align: inherit;">Es ist klar, dass dies alles manuell erfolgen kann, aber wenn zum Beispiel Tausende und Zehntausende von Offsets unterschiedlichen Typs in einer Bin√§rdatei mit einer Firmware von einigen Megabyte vorhanden sind, warum sollte man Zeit damit verbringen? </font><font style="vertical-align: inherit;">Lassen Sie das Prozessormodul dies f√ºr uns tun. </font><font style="vertical-align: inherit;">Wie sind die angenehmen Eigenschaften einer schnellen Navigation durch den untersuchten Code unter Verwendung von Querverweisen? </font><font style="vertical-align: inherit;">Dies macht IDA zu einem so bequemen und unterhaltsamen Tool, wie wir es kennen. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gepostet von</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anton Dorfman, Positive Technologies</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de424085/">https://habr.com/ru/post/de424085/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de424071/index.html">Theorie des Gl√ºcks. Thermodynamik der Klassenungleichheit</a></li>
<li><a href="../de424073/index.html">Remotecodeausf√ºhrung in Microsoft JET Database Engine</a></li>
<li><a href="../de424077/index.html">Frankreich fordert, das ‚ÄûRecht auf Vergessen‚Äú global zu machen - was es beeinflussen kann</a></li>
<li><a href="../de424081/index.html">RESS - Neue Architektur f√ºr mobile Anwendungen</a></li>
<li><a href="../de424083/index.html">Einem Handelsdienst an der Robinhood-B√∂rse wurde vorgeworfen, Daten zu Benutzeranwendungen an Hochfrequenzh√§ndler verkauft zu haben</a></li>
<li><a href="../de424087/index.html">Arduino-gesteuertes Bluetooth-gesteuertes Android-Ger√§t - vollst√§ndiger Zyklus (Teil 1)</a></li>
<li><a href="../de424089/index.html">Konferenzen sind b√∂se. Oder gut?</a></li>
<li><a href="../de424091/index.html">WiX.Py: Wir sammeln das MSI-Paket "in drei Zeilen"</a></li>
<li><a href="../de424093/index.html">Vom antiken Radio bis zum DIY-Lautsprecher: 12 YouTube-Kan√§le f√ºr ein akustisches Ger√§t</a></li>
<li><a href="../de424099/index.html">Bestimmen der Reife einer Wassermelone mithilfe von Keras: ein vollst√§ndiger Zyklus von einer Idee bis zu einem Programm bei Google Play</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>