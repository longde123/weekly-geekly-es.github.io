<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥕 🎖️ 🍐 Log di Kubernetes (dan tidak hanya) hari ini: harapan dan kenyataan 🧡 🧔🏿 👋🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Itu 2019, dan kami masih belum memiliki solusi standar untuk agregasi log di Kubernetes. Dalam artikel ini, kami ingin, menggunakan contoh dari prakti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Log di Kubernetes (dan tidak hanya) hari ini: harapan dan kenyataan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/480946/"><img src="https://habrastorage.org/webt/b1/zh/it/b1zhitohqlji21qhzypqn8k_n2s.png"><br><br>  Itu 2019, dan kami masih belum memiliki solusi standar untuk agregasi log di Kubernetes.  Dalam artikel ini, kami ingin, menggunakan contoh dari praktik nyata, untuk membagikan penelusuran kami, masalah yang dihadapi, dan solusinya. <br><br>  Namun, untuk memulainya, saya akan membuat reservasi agar pelanggan yang berbeda memahami hal yang sangat berbeda dengan mengumpulkan log: <br><br><ul><li>  seseorang ingin melihat log keamanan dan audit; </li><li>  seseorang - logging terpusat dari seluruh infrastruktur; </li><li>  dan bagi seseorang cukup mengumpulkan hanya log aplikasi, tidak termasuk, misalnya penyeimbang. </li></ul><br>  Tentang bagaimana kami menerapkan berbagai "Wishlist" dan kesulitan apa yang kami temui, di bawah cut. <a name="habracut"></a><br><br><h2>  Teori: Tentang Alat Pencatatan </h2><br><h3>  Latar belakang pada komponen sistem logging </h3><br>  Penebangan telah berlangsung lama, sebagai akibatnya kami telah mengembangkan metodologi untuk mengumpulkan dan menganalisis log, yang kami gunakan saat ini.  Kembali pada 1950-an, Fortran memperkenalkan analog standar I / O stream yang membantu programmer men-debug programnya.  Ini adalah log komputer pertama yang membuat hidup lebih mudah bagi programmer pada masa itu.  Hari ini kita melihat di dalamnya komponen pertama dari sistem logging - <b>sumber atau “penghasil” log</b> . <br><br>  Ilmu komputer tidak diam: jaringan komputer muncul, kelompok pertama ... Sistem kompleks yang terdiri dari beberapa komputer mulai berfungsi.  Sekarang administrator sistem dipaksa untuk mengumpulkan log dari beberapa mesin, dan dalam kasus khusus mereka dapat menambahkan pesan-pesan kernel OS jika mereka perlu menyelidiki kegagalan sistem.  Untuk menggambarkan sistem pengumpulan log terpusat, <a href="https://tools.ietf.org/html/rfc3164">RFC 3164</a> keluar pada awal 2000-an, yang distandarisasi remote_syslog.  Jadi komponen penting lainnya muncul: <b>pengumpul (pengumpul) log</b> dan penyimpanannya. <br><br>  Dengan peningkatan volume log dan adopsi luas teknologi web, muncul pertanyaan tentang log mana yang harus ditunjukkan kepada pengguna.  Alat konsol sederhana (awk / sed / grep) digantikan oleh <b>pemirsa log yang</b> lebih canggih - komponen ketiga. <br><br>  Sehubungan dengan peningkatan volume log, hal lain menjadi jelas: log dibutuhkan, tetapi tidak semua.  Dan log yang berbeda membutuhkan tingkat keamanan yang berbeda: beberapa dapat hilang setiap hari, sementara yang lain perlu disimpan selama 5 tahun.  Jadi, komponen penyaringan dan perutean untuk aliran data telah ditambahkan ke sistem pencatatan - sebut saja <b>filter</b> . <br><br>  Repositori juga membuat lompatan besar: mereka beralih dari file biasa ke database relasional, dan kemudian ke repositori berorientasi dokumen (misalnya, Elasticsearch).  Jadi penyimpanan dipisahkan dari kolektor. <br><br>  Pada akhirnya, konsep log itu sendiri telah meluas ke beberapa aliran abstrak peristiwa yang ingin kita pertahankan untuk sejarah.  Lebih tepatnya, dalam kasus ketika perlu untuk melakukan investigasi atau menyusun laporan analitis ... <br><br>  Akibatnya, dalam periode waktu yang relatif singkat, pengumpulan log telah berkembang menjadi subsistem penting, yang dapat disebut sebagai salah satu subbagian dalam Big Data. <br><br><img src="https://habrastorage.org/webt/ld/ax/r6/ldaxr6rvel45_k3jyu3d1eddcgw.png"><br>  <i>Jika dulunya cetakan biasa cukup untuk "sistem logging", sekarang situasinya telah banyak berubah.</i> <br><br><h3>  Kubernet dan Log </h3><br>  Ketika Kubernetes datang ke infrastruktur, masalah yang ada saat mengumpulkan kayu bulat tidak lewat begitu saja.  Dalam beberapa hal, ini menjadi semakin menyakitkan: pengelolaan platform infrastruktur tidak hanya disederhanakan, tetapi juga rumit.  Banyak layanan lama mulai bermigrasi ke trek layanan-mikro.  Dalam konteks log, ini menghasilkan semakin banyak sumber log, siklus hidup khusus mereka, dan kebutuhan untuk melacak log interkoneksi semua komponen sistem ... <br><br>  Ke depan, saya dapat mengatakan bahwa sekarang, sayangnya, tidak ada opsi logging standar untuk Kubernet yang akan berbeda dari yang lain.  Skema yang paling populer di komunitas adalah sebagai berikut: <br><br><ul><li>  seseorang sedang menyebarkan tumpukan <b>EFK</b> (Elasticsearch, Fluentd, Kibana); </li><li>  seseorang sedang mencoba <a href="https://grafana.com/oss/loki/"><b>Loki yang</b></a> baru dirilis atau menggunakan <a href="https://banzaicloud.com/products/logging-operator/"><b>operator Logging</b></a> ; </li><li>  kami <i>(dan mungkin bukan hanya kami? ..)</i> sebagian besar puas dengan pengembangan kami sendiri - <a href="https://github.com/flant/loghouse"><b>loghouse</b></a> ... </li></ul><br>  Sebagai aturan, kami menggunakan bundel seperti itu di kluster K8 (untuk solusi yang di-host-sendiri): <br><br><ul><li>  <a href="https://github.com/kiwigrid/helm-charts/tree/master/charts/fluentd-elasticsearch">Fluentd + Elasticsearch + Kibana</a> ; </li><li>  <a href="https://github.com/flant/loghouse">Fluentd + ClickHouse + loghouse</a> . </li></ul><br>  Namun, saya tidak akan memikirkan petunjuk untuk pemasangan dan konfigurasi mereka.  Sebagai gantinya, saya akan fokus pada kekurangan mereka dan lebih banyak kesimpulan global tentang situasi dengan log pada umumnya. <br><br><h2>  Berlatih dengan log di K8s </h2><br><img src="https://habrastorage.org/webt/zv/p8/lj/zvp8ljnjmqen_8c0svhhh2kezyc.jpeg" align="left"><br><h3>  "Log sehari-hari", berapa banyak dari Anda? .. </h3><br>  Pengumpulan log terpusat dengan infrastruktur yang cukup besar membutuhkan sumber daya yang cukup besar yang akan dihabiskan untuk mengumpulkan, menyimpan, dan memproses log.  Selama pengoperasian berbagai proyek, kami dihadapkan dengan berbagai persyaratan dan masalah operasional yang timbul. <br><br><h4>  Mari kita coba ClickHouse </h4><br>  Mari kita lihat repositori terpusat pada sebuah proyek dengan aplikasi yang menghasilkan cukup banyak log: lebih dari 5000 baris per detik.  Mari kita mulai bekerja dengan log-nya, menambahkannya ke ClickHouse. <br><br>  Segera setelah realtime maksimum diperlukan, server ClickHouse 4-inti sudah kelebihan beban pada subsistem disk: <br><br><img src="https://habrastorage.org/webt/i4/zy/i6/i4zyi6fxq4175ljs3slazm9rgxc.png"><br><br>  Jenis unduhan ini disebabkan oleh kenyataan bahwa kami mencoba menulis ke ClickHouse secepat mungkin.  Dan database merespons hal ini dengan peningkatan disk, yang dapat menyebabkan kesalahan berikut: <br><br> <code>DB::Exception: Too many parts (300). Merges are processing significantly slower than inserts</code> <br> <br>  Faktanya adalah bahwa <a href="https://clickhouse.yandex/docs/en/operations/table_engines/mergetree/">tabel MergeTree</a> di ClickHouse (mengandung data log) memiliki kesulitan sendiri selama operasi penulisan.  Data yang dimasukkan ke dalamnya menghasilkan partisi sementara, yang kemudian bergabung dengan tabel utama.  Akibatnya, rekaman sangat menuntut pada disk, dan juga memiliki batasan, pemberitahuan yang kami terima di atas: tidak lebih dari 300 subpartisi dapat bergabung dalam 1 detik (sebenarnya, ini adalah 300 insert'ov per detik). <br><br>  Untuk menghindari perilaku ini, Anda <a href="https://github.com/ClickHouse/ClickHouse/issues/3174">harus menulis di ClickHouse</a> sebanyak mungkin dan tidak lebih dari 1 kali dalam 2 detik.  Namun, menulis dalam jumlah besar menunjukkan bahwa kita sebaiknya jarang menulis di ClickHouse.  Hal ini, pada gilirannya, dapat menyebabkan buffer overflows dan hilangnya log.  Solusinya adalah meningkatkan buffer Fluentd, tetapi kemudian konsumsi memori akan meningkat. <br><br>  <i><b>Catatan</b> : Masalah lain dengan solusi ClickHouse kami adalah bahwa partisi dalam kasus kami (loghouse) diimplementasikan melalui tabel eksternal yang ditautkan oleh <a href="https://clickhouse.yandex/docs/ru/operations/table_engines/merge/">tabel Merge</a> .</i>  <i>Ini mengarah pada fakta bahwa ketika mengambil sampel interval waktu yang besar, RAM yang berlebihan diperlukan, karena metatable melewati semua partisi - bahkan partisi yang jelas tidak mengandung data yang diperlukan.</i>  <i>Namun, sekarang pendekatan ini dapat dengan aman dinyatakan usang untuk versi ClickHouse saat ini (sejak <a href="">18.16</a> ).</i> <br><br>  Akibatnya, menjadi jelas bahwa ClickHouse tidak memiliki sumber daya yang cukup untuk setiap proyek untuk mengumpulkan log secara real time (lebih tepatnya, distribusinya tidak akan bijaksana).  Selain itu, Anda harus menggunakan <b>baterai</b> , yang akan kami kembalikan.  Kasus yang dijelaskan di atas adalah nyata.  Dan pada saat itu kami tidak dapat menawarkan solusi yang andal dan stabil yang sesuai untuk pelanggan dan memungkinkan untuk mengumpulkan kayu dengan penundaan minimum ... <br><br><h4>  Bagaimana dengan Elasticsearch? </h4><br>  Elasticsearch dikenal menangani banyak hal.  Mari kita coba di proyek yang sama.  Sekarang bebannya adalah sebagai berikut: <br><br><img src="https://habrastorage.org/webt/jh/we/7o/jhwe7ok8_l0alrlv5j72p5lgha0.png"><br><br>  Elasticsearch mampu mencerna aliran data, namun, menulis volume seperti itu sangat memanfaatkan CPU.  Ini diputuskan oleh organisasi cluster.  Secara teknis murni, ini bukan masalah, tetapi ternyata hanya untuk pengoperasian sistem pengumpulan log kita sudah menggunakan sekitar 8 core dan memiliki komponen tambahan yang sangat dimuat dalam sistem ... <br><br>  Intinya: opsi ini dapat dibenarkan, tetapi hanya jika proyek besar dan manajemennya siap untuk menghabiskan sumber daya yang signifikan pada sistem logging terpusat. <br><br>  Kemudian muncul pertanyaan logis: <br><br><h3>  Log apa yang benar-benar dibutuhkan? </h3><br><img src="https://habrastorage.org/webt/hl/3h/ei/hl3heiig0t7nluwc_bvorqrrndk.jpeg" align="left">  Mari kita coba untuk mengubah pendekatan itu sendiri: log harus informatif sekaligus, dan tidak mencakup <i>setiap</i> peristiwa dalam sistem. <br><br>  Katakanlah kita memiliki toko online yang makmur.  Log mana yang penting?  Mengumpulkan sebanyak mungkin informasi, misalnya, dari gateway pembayaran adalah ide bagus.  Tetapi dari layanan pengiris gambar dalam katalog produk, tidak semua log penting bagi kami: hanya kesalahan dan pemantauan lanjutan yang cukup (misalnya, persentase 500 kesalahan yang dihasilkan komponen ini). <br><br>  Jadi kami sampai pada <b>kesimpulan</b> bahwa <b>penebangan terpusat jauh dari selalu dibenarkan</b> .  Sangat sering, klien ingin mengumpulkan semua log di satu tempat, walaupun sebenarnya hanya 5% dari pesan yang penting untuk bisnis diperlukan dari seluruh log: <br><br><ul><li>  Terkadang cukup untuk mengkonfigurasi, katakanlah, hanya ukuran log kontainer dan pengumpul kesalahan (misalnya, Sentry). </li><li>  Untuk menyelidiki insiden, peringatan kesalahan dan log lokal besar itu sendiri seringkali cukup. </li><li>  Kami memiliki proyek yang sepenuhnya biaya hanya tes fungsional dan sistem pengumpulan kesalahan.  Pengembang tidak memerlukan log seperti itu - mereka melihat semuanya pada jejak kesalahan. </li></ul><br><h4>  Ilustrasi kehidupan </h4><br>  Contoh yang baik adalah cerita lain.  Kami menerima permintaan dari tim keamanan salah satu klien yang sudah memiliki solusi komersial yang dikembangkan jauh sebelum penerapan Kubernetes. <br><br>  Butuh "berteman" dengan sistem pengumpulan log terpusat dengan sensor perusahaan untuk mendeteksi masalah - QRadar.  Sistem ini dapat menerima log menggunakan protokol syslog, untuk mengambilnya dari FTP.  Namun, mengintegrasikannya dengan plugin remote_syslog untuk fluentd tidak langsung berfungsi <i>(ternyata, <a href="https://developer.ibm.com/answers/questions/429729/using-fluentd-to-streamfilter-data-to-qradar/">kami bukan satu-satunya</a> )</i> .  Masalah dengan mengonfigurasi QRadar ada di sisi tim keamanan klien. <br><br>  Akibatnya, sebagian log yang penting untuk bisnis diunggah ke FTP QRadar, dan bagian lainnya dialihkan melalui syslog jarak jauh langsung dari node.  Untuk melakukan ini, kami bahkan menulis <a href="https://github.com/flant/examples/tree/master/2019/10-remote-syslog">bagan sederhana</a> - mungkin ini akan membantu seseorang memecahkan masalah yang sama ... Berkat skema yang dihasilkan, klien sendiri menerima dan menganalisis log kritis (menggunakan alat favoritnya), dan kami dapat mengurangi biaya sistem logging, hanya mempertahankan yang terakhir bulan. <br><br>  Contoh lain cukup menunjukkan bagaimana tidak melakukannya.  Salah satu klien kami untuk menangani <i>setiap</i> peristiwa yang datang dari pengguna, melakukan multiline <i>output</i> informasi yang <i>tidak terstruktur</i> ke log.  Seperti yang Anda tebak, log seperti itu sangat tidak nyaman untuk dibaca dan disimpan. <br><br><h3>  Kriteria untuk Log </h3><br>  Contoh-contoh tersebut mengarah pada kesimpulan bahwa, selain memilih sistem untuk mengumpulkan log, Anda juga harus <i>merancang log itu sendiri</i> !  Apa persyaratannya di sini? <br><br><ul><li>  Log harus dalam format yang dapat dibaca mesin (mis. JSON). </li><li>  Log harus kompak dan dengan kemampuan untuk mengubah tingkat logging untuk men-debug masalah yang mungkin terjadi.  Pada saat yang sama, di lingkungan produksi, Anda harus menjalankan sistem dengan tingkat pencatatan seperti <i>Peringatan</i> atau <i>Kesalahan</i> . </li><li>  Log harus dinormalisasi, yaitu, dalam objek log, semua baris harus memiliki tipe bidang yang sama. </li></ul><br>  Log yang tidak terstruktur dapat menyebabkan masalah dengan memuat log ke dalam repositori dan menghentikan pemrosesan mereka sepenuhnya.  Sebagai ilustrasi, berikut adalah contoh dengan kesalahan 400, yang pasti banyak ditemui dalam log fluentd: <br><br> <code>2019-10-29 13:10:43 +0000 [warn]: dump an error event: error_class=Fluent::Plugin::ElasticsearchErrorHandler::ElasticsearchError error="400 - Rejected by Elasticsearch"</code> <br> <br>  Kesalahan berarti bahwa Anda mengirim bidang yang tipenya tidak stabil ke indeks dengan pemetaan siap.  Contoh paling sederhana adalah bidang dalam log nginx dengan variabel <code>$upstream_status</code> .  Itu dapat memiliki nomor atau string.  Sebagai contoh: <br><br> <code>{ "ip": "1.2.3.4", "http_user": "-", "request_id": "17ee8a579e833b5ab9843a0aca10b941", "time": "29/Oct/2019:16:18:57 +0300", "method": "GET", "uri": "/staffs/265.png", "protocol": "HTTP/1.1", "status": "200", "body_size": "906", "referrer": "https://example.com/staff", "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.70 Safari/537.36", "request_time": "0.001", "cache_status": "-", "upstream_response_time": "0.001, 0.007", "upstream_addr": "127.0.0.1:9000", "upstream_status": "200", "upstream_response_length": "906", "location": "staff"} <br> { "ip": "1.2.3.4", "http_user": "-", "request_id": "47fe42807f2a7d8d5467511d7d553a1b", "time": "29/Oct/2019:16:18:57 +0300", "method": "GET", "uri": "/staff", "protocol": "HTTP/1.1", "status": "200", "body_size": "2984", "referrer": "-", "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.70 Safari/537.36", "request_time": "0.010", "cache_status": "-", "upstream_response_time": "0.001, 0.007", "upstream_addr": "10.100.0.10:9000, 10.100.0.11:9000", "upstream_status": "404, 200", "upstream_response_length": "0, 2984", "location": "staff"}</code> <br> <br>  Log menunjukkan bahwa server 10.100.0.10 merespons dengan kesalahan 404 dan permintaan pergi ke penyimpanan konten lain.  Akibatnya, dalam log, artinya menjadi seperti ini: <br><br> <code>"upstream_response_time": "0.001, 0.007"</code> <br> <br>  Situasi ini begitu luas sehingga bahkan memenangkan <a href="https://github.com/uken/fluent-plugin-elasticsearch">penyebutan</a> terpisah <a href="https://github.com/uken/fluent-plugin-elasticsearch">dalam dokumentasi</a> . <br><br><h4>  Dan bagaimana dengan keandalan? </h4><br>  Ada kalanya semua log vital tanpa kecuali.  Dan dengan ini, skema pengumpulan log untuk K8 yang diusulkan / dibahas di atas memiliki masalah. <br><br>  Misalnya, fluentd tidak dapat mengumpulkan kayu dari wadah yang berumur pendek.  Di salah satu proyek kami, wadah dengan migrasi basis data hidup kurang dari 4 detik, dan kemudian dihapus - sesuai dengan anotasi yang sesuai: <br><br> <code>"helm.sh/hook-delete-policy": hook-succeeded</code> <br> <br>  Karena itu, log migrasi tidak masuk ke repositori.  Kebijakan <code>before-hook-creation</code> dapat membantu dalam kasus ini. <br><br>  Contoh lain adalah rotasi log Docker.  Misalkan ada aplikasi yang aktif menulis ke log.  Dalam kondisi normal, kami berhasil memproses semua log, tetapi segera setelah masalah muncul - misalnya, seperti dijelaskan di atas dengan format yang salah - pemrosesan berhenti, dan Docker memutar file.  Intinya - log bisnis-kritis dapat hilang. <br><br>  Itulah mengapa <b>penting untuk memisahkan aliran kayu</b> , menanamkan pengiriman yang paling berharga langsung ke dalam aplikasi untuk memastikan keamanannya.  Selain itu, tidak akan berlebihan untuk membuat semacam <b>"akumulator" log</b> yang dapat bertahan dari tidak tersedianya penyimpanan sementara mempertahankan pesan penting. <br><br>  Akhirnya, jangan lupa bahwa <b>penting untuk memantau setiap subsistem dengan cara yang berkualitas</b> .  Kalau tidak, mudah untuk menghadapi situasi di mana fluentd berada dalam keadaan <code>CrashLoopBackOff</code> dan tidak mengirim apa pun, dan ini menjanjikan hilangnya informasi penting. <br><br><h2>  Kesimpulan </h2><br>  Pada artikel ini, kami tidak mempertimbangkan solusi SaaS seperti Datadog.  Banyak masalah yang dijelaskan di sini telah diselesaikan dengan satu atau lain cara oleh perusahaan komersial yang berspesialisasi dalam mengumpulkan kayu bulat, tetapi tidak semua orang dapat menggunakan SaaS karena berbagai alasan <i>(yang utama adalah biaya dan kepatuhan terhadap 152--)</i> . <br><br>  Pengumpulan log terpusat pada awalnya terlihat seperti tugas sederhana, tetapi tidak sama sekali.  Penting untuk diingat bahwa: <br><br><ul><li>  Detail masuk hanya komponen penting, dan untuk sistem lain, Anda dapat mengonfigurasi pemantauan dan pengumpulan kesalahan. </li><li>  Log dalam produksi harus diminimalkan agar tidak memberi beban tambahan. </li><li>  Log harus dapat dibaca mesin, dinormalisasi, memiliki format yang ketat. </li><li>  Log yang benar-benar kritis harus dikirim dalam aliran terpisah, yang harus dipisahkan dari yang utama. </li><li>  Perlu mempertimbangkan baterai log, yang dapat menghemat dari semburan muatan tinggi dan membuat beban pada penyimpanan lebih seragam. </li></ul><br><img src="https://habrastorage.org/webt/ss/hd/9f/sshd9fqiav2abndbb_uqo0mdjke.jpeg" align="left"><br>  Aturan sederhana ini, jika diterapkan di mana-mana, akan memungkinkan sirkuit yang dijelaskan di atas berfungsi - meskipun mereka tidak memiliki komponen penting (baterai).  Jika Anda tidak mematuhi prinsip-prinsip tersebut, tugas tersebut akan dengan mudah membawa Anda dan infrastruktur ke komponen sistem yang sangat sarat muatan (dan pada saat yang sama tidak efektif). <br><br><h2>  PS </h2><br>  Baca juga di blog kami: <br><br><ul><li>  " <a href="https://habr.com/ru/company/flant/blog/341386/">Memperkenalkan loghouse - sistem open source untuk bekerja dengan log di Kubernetes</a> "; </li><li>  " <a href="https://m.habr.com/ru/news/t/476966/">Rilis untuk ekosistem Kubernetes dengan KubeCon'19: JFrog Container Registry, Kui dari IBM, Loki 1.0.0 ...</a> "; </li><li>  " <a href="https://habr.com/ru/company/flant/blog/412901/">Monitoring dan Kubernetes (review dan laporan video)</a> ." </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id480946/">https://habr.com/ru/post/id480946/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id480930/index.html">Ketikkan semuanya</a></li>
<li><a href="../id480936/index.html">IntelliJ IDEA konversi cepat UPPER_CASE ke camelCase</a></li>
<li><a href="../id480938/index.html">Cryptocurrency melalui mata para hakim Rusia</a></li>
<li><a href="../id480940/index.html">Jalankan uji UI lintas-browser dengan Mentimun dan Selenoid di Gitlab CI dengan laporan Allure</a></li>
<li><a href="../id480944/index.html">5 Tren Teratas dalam Pemasaran Email pada tahun 2020</a></li>
<li><a href="../id480948/index.html">Pemasaran mitap dan PR di Ivanovo</a></li>
<li><a href="../id480950/index.html">Analisis kuis Android dari stand hh.ru di Mobius 2019 Moscow</a></li>
<li><a href="../id480954/index.html">Tugas nomor 1. Cari tahu jenis kelamin dan tingkat hubungan</a></li>
<li><a href="../id480956/index.html">Bagaimana saya menemukan cara untuk melacak semua driver Citimobil</a></li>
<li><a href="../id480958/index.html">Koneksi satelit. Tinjauan perusahaan operator dan sedikit tentang peringkat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>