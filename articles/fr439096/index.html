<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤙🏾 👨🏿‍💻 ⛔️ Buildbot: un conte avec des exemples d'un autre système d'intégration continue 🏼 🚘 👨🏻‍🏭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="(photo du site officiel ) 

 Buildbot, comme son nom l'indique, est un système d'intégration continue (ci). Il y avait déjà plusieurs articles à son s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Buildbot: un conte avec des exemples d'un autre système d'intégration continue</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439096/"><img src="https://habrastorage.org/webt/so/qs/u1/soqsu1skae_0xuktzdemfv-n3yq.png"><br>  <i><font color="#aaaaaa">(photo du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">site officiel</a> )</font></i> <br><br>  Buildbot, comme son nom l'indique, est un système d'intégration continue (ci).  Il y avait déjà <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plusieurs</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">articles</a> à son sujet sur le Habré, mais, de mon point de vue, les avantages de cet outil ne sont pas très clairs chez eux.  De plus, ils n'ont presque aucun exemple, ce qui rend difficile de voir toute la puissance du programme.  Dans mon article, je vais essayer de combler ces lacunes, parler du périphérique interne Buildbot'a et donner des exemples de plusieurs scripts non standard. <br><a name="habracut"></a><br><h3>  Mots communs </h3><br>  Actuellement, il existe un grand nombre de systèmes d'intégration continue, et quand il s'agit de l'un d'entre eux, des questions assez logiques se posent dans l'esprit de "Pourquoi est-il nécessaire si vous avez déjà un &lt;nom_programme&gt; et que tout le monde l'utilise?"  Je vais essayer de répondre à une telle question sur Buildbot.  Certaines informations seront dupliquées avec des articles existants, d'autres sont décrites dans la documentation officielle, mais cela est nécessaire pour la cohérence du récit. <br><br>  La principale différence avec les autres systèmes d'intégration continue est que Buildbot est un framework Python pour écrire ci, pas une solution prête à l'emploi.  Cela signifie que pour connecter un projet à Buildbot, vous devez d'abord écrire un programme python distinct en utilisant le framework Buildbot qui implémente la fonctionnalité d'intégration continue dont votre projet a besoin.  Cette approche offre une grande flexibilité, vous permettant de mettre en œuvre des scénarios de test difficiles qui sont impossibles pour les solutions prêtes à l'emploi en raison de limitations architecturales. <br><br>  De plus, Buildbot n'est pas un service, et vous devez donc le déployer honnêtement sur votre infrastructure.  Ici, je note que le cadre est très fidèle aux ressources du système.  Ce n'est certainement pas du C ou du C ++, mais python gagne contre ses concurrents Java.  Ici, par exemple, en comparant la consommation de mémoire avec GoCD (et oui, malgré le nom, il s'agit d'un système Java): <br><br>  Buildbot: <br><br><img src="https://habrastorage.org/webt/q1/tg/wu/q1tgwuy-ef8bl6au-s7lc07da-c.png"><br><br>  GoCD: <br><br><img src="https://habrastorage.org/webt/lg/ci/bk/lgcibk9si78bjzf_gfqrgktcgug.png"><br><br>  Déployer et écrire vous-même un programme de test séparé peut vous rendre triste à l'idée de la configuration initiale.  Cependant, l'écriture de scripts est grandement simplifiée par le grand nombre de classes intégrées.  Ces classes couvrent de nombreuses opérations standard, qu'il s'agisse d'obtenir des modifications du référentiel github ou de construire le projet avec CMake.  En conséquence, les scripts standard pour les petits projets ne seront pas plus compliqués que les fichiers YML pour certains travis-ci.  Je n'écrirai pas sur le déploiement, ceci est couvert en détail dans les articles existants et il n'y a rien de compliqué non plus. <br><br>  La prochaine fonctionnalité de Buildbot, je note que par défaut la logique de test est implémentée du côté du ci-serveur.  Cela contredit l'approche désormais populaire du «pipeline en tant que code», dans laquelle la logique de test est décrite dans un fichier (comme .travis.yml) se trouvant dans le référentiel avec le code source du projet, et le ci-server ne lit que ce fichier et exécute ce qu'il dit.  Encore une fois, ce n'est que le comportement par défaut.  Les capacités du framework Buildbot vous permettent d'implémenter l'approche décrite avec le stockage du script de test dans le référentiel.  Il existe même une solution toute faite - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bb-travis</a> , qui essaie de tirer le meilleur parti de Buildbot et travis-ci.  En outre, plus loin dans cet article, je décrirai moi-même comment implémenter quelque chose de similaire à ce comportement. <br><br>  Buildbot collecte par défaut chaque commit lors de la poussée.  Cela peut sembler être une petite fonctionnalité inutile, mais pour moi, au contraire, elle est devenue l'un des principaux avantages.  De nombreuses solutions populaires prêtes à l'emploi (travis-ci, gitlab-ci) ne fournissent pas du tout une telle opportunité, ne fonctionnant qu'avec le dernier commit de la branche.  Imaginez que pendant le développement, vous devez souvent choisir les commits.  Il sera désagréable de prendre un commit non fonctionnel, qui n'a pas été vérifié par le système de build en raison du fait qu'il a été lancé avec un tas de commits d'en haut.  Bien sûr, dans Buildbot, vous ne pouvez générer que le dernier commit, et cela se fait en définissant un seul paramètre. <br><br>  Le cadre a une assez bonne documentation, qui décrit tout en détail de l'architecture générale aux directives pour étendre les classes intégrées.  Cependant, même avec une telle documentation, vous devrez peut-être regarder certaines choses dans le code source.  Il est entièrement ouvert sous la licence GPL v2 et est facile à lire.  Parmi les inconvénients - la documentation est disponible uniquement en anglais, en russe, il y a très peu d'informations sur le réseau.  L'outil n'est pas apparu hier, avec son aide <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">python</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Wireshark</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LLVM</a> et de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nombreux autres</a> projets bien connus sont assemblés.  Des mises à jour arrivent, le projet est soutenu par de nombreux développeurs, nous pouvons donc parler de fiabilité et de stabilité. <br><br><img src="https://habrastorage.org/webt/22/we/zg/22wezgyvqnccjmk2sl_ehs954bg.png"><br>  <i><font color="#aaaaaa">(Page d'accueil de Python Buildbot)</font></i> <br><br><h3>  Theormin </h3><br>  Cette partie est essentiellement une traduction gratuite du chapitre de la documentation officielle sur l'architecture du framework.  Il montre la chaîne complète d'actions depuis la réception des modifications par le ci-système jusqu'à l'envoi des notifications du résultat aux utilisateurs.  Ainsi, vous avez apporté des modifications au code source du projet et les avez envoyées au référentiel distant.  Ce qui se passe ensuite est schématisé dans l'image: <br><br><img src="https://habrastorage.org/webt/hq/ue/na/hquenaedpe7hdlulfnmctiew2b8.png"><br>  <i><font color="#aaaaaa">(photo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la documentation officielle</a> )</font></i> <br><br>  Tout d'abord, Buildbot devrait en quelque sorte découvrir qu'il y a eu des changements dans le référentiel.  Il existe deux façons principales - les webhooks et les sondages, bien que personne n'interdise de proposer quelque chose de plus sophistiqué.  Dans le premier cas, dans Buildbot, les classes descendantes BaseHookHandler en sont responsables.  Il existe de nombreuses solutions prêtes à l'emploi, par exemple, <i>GitHubHandler</i> ou <i>GitoriusHandler</i> .  La méthode clé de ces classes est <b>getChanges ()</b> .  Sa logique est extrêmement simple: il doit convertir la requête HTTP en une liste d'objets de modification. <br><br>  Pour le deuxième cas, vous avez besoin des <i>classes</i> descendantes <i>PollingChangeSource</i> .  Encore une fois, il existe des solutions toutes faites, telles que <i>GitPoller</i> ou <i>HgPoller</i> .  La méthode clé est <b>poll ()</b> .  Il est appelé avec une certaine fréquence et doit en quelque sorte créer une liste de modifications dans le référentiel.  Dans le cas d'un git, cela pourrait être un appel à git fetch et une comparaison avec l'état enregistré précédent.  Si les capacités intégrées ne sont pas suffisantes, créez simplement votre propre classe héritière et surchargez la méthode.  Un exemple d'utilisation de l'interrogation: <br><br><pre><code class="python hljs">c[<span class="hljs-string"><span class="hljs-string">'change_source'</span></span>] = [changes.GitPoller( repourl = <span class="hljs-string"><span class="hljs-string">'git@git.example.com:project'</span></span>, project = <span class="hljs-string"><span class="hljs-string">'My Project'</span></span>, branches = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, <span class="hljs-comment"><span class="hljs-comment">#      pollInterval = 60 )]</span></span></code> </pre> <br>  Webhook est encore plus simple à utiliser, l'essentiel est de ne pas oublier de le configurer côté git-server.  Ceci est juste une ligne dans le fichier de configuration: <br><br><pre> <code class="python hljs">c[<span class="hljs-string"><span class="hljs-string">'www'</span></span>][<span class="hljs-string"><span class="hljs-string">'change_hook_dialects'</span></span>] = { <span class="hljs-string"><span class="hljs-string">'github'</span></span>: {} }</code> </pre> <br>  À l'étape suivante, les objets de modification sont entrés dans les objets du planificateur ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">planificateurs</a> ).  Exemples de planificateurs <i>intégrés</i> : <i>AnyBranchScheduler</i> , <i>NightlyScheduler</i> , <i>ForceScheduler</i> , etc.  Chaque ordonnanceur reçoit tous les objets de modification en entrée, mais ne sélectionne que ceux qui passent le filtre.  Le filtre est transmis au planificateur dans le constructeur via l'argument <i>change_filter</i> .  En sortie, les planificateurs créent des demandes de génération.  Le planificateur sélectionne les générateurs en fonction de l'argument constructeurs. <br><br>  Certains planificateurs ont un argument délicat appelé <i>treeStableTimer</i> .  Cela fonctionne comme suit: lorsqu'une modification est reçue, le planificateur ne crée pas immédiatement une nouvelle demande de génération, mais démarre une minuterie.  Si de nouveaux changements arrivent et que le minuteur n'a pas expiré, l'ancien changement est remplacé par un nouveau et le minuteur est mis à jour.  À la fin du temporisateur, le planificateur crée une seule demande de génération à partir de la dernière modification enregistrée. <br><br>  Ainsi, la logique de n'assembler que le dernier commit lors du push est implémentée.  Exemple de configuration du planificateur: <br><br><pre> <code class="python hljs">c[<span class="hljs-string"><span class="hljs-string">'schedulers'</span></span>] = [schedulers.AnyBranchScheduler( name = <span class="hljs-string"><span class="hljs-string">'My Scheduler'</span></span>, treeStableTimer = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, change_filter = util.ChangeFilter(project = <span class="hljs-string"><span class="hljs-string">'My Project'</span></span>), builderNames = [<span class="hljs-string"><span class="hljs-string">'My Builder'</span></span>] )]</code> </pre> <br>  Les demandes de build, aussi étranges que cela puisse paraître, sont transmises à l'entrée des constructeurs.  La tâche du collecteur est d'exécuter l'assemblage sur un «travailleur» accessible.  Worker est un environnement de génération, tel que stretch64 ou ubuntu1804x64.  La liste des travailleurs passe par l'argument des <i>travailleurs</i> .  Tous les travailleurs de la liste doivent être les mêmes (c'est-à-dire que les noms sont naturellement différents, mais l'environnement à l'intérieur est le même), car le collecteur est libre de choisir n'importe lequel des disponibles.  La définition de plusieurs valeurs ici permet d'équilibrer la charge et non de construire dans des environnements différents.  À l'aide de l'argument <i>facteur</i> y, le collecteur reçoit une séquence d'étapes pour générer le projet.  J'écrirai à ce sujet en détail ci-dessous. <br><br>  Un exemple de configuration du collecteur: <br><br><pre> <code class="python hljs">c[<span class="hljs-string"><span class="hljs-string">'builders'</span></span>] = [util.BuilderConfig( name = <span class="hljs-string"><span class="hljs-string">'My Builder'</span></span>, workernames = [<span class="hljs-string"><span class="hljs-string">'stretch32'</span></span>], factory = factory )]</code> </pre> <br>  Donc, le projet est prêt.  La dernière étape de Buildbot consiste à notifier la génération.  Les classes de reporter en sont responsables.  Un exemple classique est la classe <i>MailNotifier</i> , qui envoie un e-mail avec les résultats de la construction.  <i>Exemple de</i> connexion <i>MailNotifier</i> : <br><br><pre> <code class="python hljs">c[<span class="hljs-string"><span class="hljs-string">'services'</span></span>] = [reporters.MailNotifier( fromaddr = <span class="hljs-string"><span class="hljs-string">'buildbot@example.com'</span></span>, relayhost = <span class="hljs-string"><span class="hljs-string">'mail.example.com'</span></span>, smtpPort = <span class="hljs-number"><span class="hljs-number">25</span></span>, extraRecipients = [<span class="hljs-string"><span class="hljs-string">'devel@example.com'</span></span>], sendToInterestedUsers = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> )]</code> </pre> <br>  Eh bien, il est temps de passer à des exemples à part entière.  Je note que Buildbot lui-même a été écrit en utilisant le framework Twisted, et donc sa connaissance facilitera grandement l'écriture et la compréhension des scripts Buildbot.  Nous aurons un garçon à fouetter pour un projet appelé Pet Project.  Laissez-le être écrit en C ++, assemblé à l'aide de CMake, et le code source se trouve dans le référentiel git.  Nous n'étions pas trop paresseux et avons écrit pour lui des tests dirigés par l'équipe ctest.  Plus récemment, nous avons lu cet article et réalisé que nous voulons appliquer les connaissances fraîchement acquises à notre projet. <br><br><h3>  Exemple un: pour que cela fonctionne </h3><br>  En fait, le fichier de configuration: <br><br><div class="spoiler">  <b class="spoiler_title">100 lignes de code python</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> buildbot.plugins <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-comment"><span class="hljs-comment"># shortcut c = BuildmasterConfig = {} # create workers c['workers'] = [worker.Worker('stretch32', 'example_password')] # general settings c['title'] = 'Buildbot: test' c['titleURL'] = 'https://buildbot.example.com/' c['buildbotURL'] = 'https://buildbot.example.com/' # setup database c['db'] = { 'db_url': 'sqlite:///state.sqlite' } # port to communicate with workers c['protocols'] = { 'pb': { 'port': 9989 } } # make buildbot developers a little bit happier c['buildbotNetUsageData'] = 'basic' # webserver setup c['www'] = dict(plugins = dict(waterfall_view={}, console_view={}, grid_view={})) c['www']['authz'] = util.Authz( allowRules = [util.AnyEndpointMatcher(role = 'admins')], roleMatchers = [util.RolesFromUsername(roles = ['admins'], usernames = ['root'])] ) c['www']['auth'] = util.UserPasswordAuth([('root', 'root_password')]) # mail notification c['services'] = [reporters.MailNotifier( fromaddr = 'buildbot@example.com', relayhost = 'mail.example.com', smtpPort = 25, extraRecipients = ['devel@example.com'], sendToInterestedUsers = False )] c['change_source'] = [changes.GitPoller( repourl = 'git@git.example.com:pet-project', project = 'Pet Project', branches = True, pollInterval = 60 )] c['schedulers'] = [schedulers.AnyBranchScheduler( name = 'Pet Project Scheduler', treeStableTimer = None, change_filter = util.ChangeFilter(project = 'Pet Project'), builderNames = ['Pet Project Builder'] )] factory = util.BuildFactory() factory.addStep(steps.Git( repourl = util.Property('repository'), workdir = 'sources', haltOnFailure = True, submodules = True, progress = True) ) factory.addStep(steps.ShellSequence( name = 'create builddir', haltOnFailure = True, hideStepIf = lambda results, s: results == util.SUCCESS, commands = [ util.ShellArg(command = ['rm', '-rf', 'build']), util.ShellArg(command = ['mkdir', 'build']) ]) ) factory.addStep(steps.CMake( workdir = 'build', path = '../sources', haltOnFailure = True) ) factory.addStep(steps.Compile( name = 'build project', workdir = 'build', haltOnFailure = True, warnOnWarnings = True, command = ['make']) ) factory.addStep(steps.ShellCommand( name = 'run tests', workdir = 'build', haltOnFailure = True, command = ['ctest']) ) c['builders'] = [util.BuilderConfig( name = 'Pet Project Builder', workernames = ['stretch32'], factory = factory )]</span></span></code> </pre> <br></div></div><br>  En écrivant ces lignes, nous obtenons un assemblage automatique lors de la poussée vers le référentiel, une belle face Web, des notifications par e-mail et d'autres attributs de tout ci qui se respecte.  La plupart de cela doit être clair: les paramètres des planificateurs, des collecteurs et d'autres objets sont rendus similaires aux exemples donnés précédemment, la valeur de la plupart des paramètres est intuitive.  En détail, je me concentrerai uniquement sur la création d'une usine, ce que j'ai promis de faire plus tôt. <br><br>  L'usine se compose des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">étapes</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">construction</a> que Buildbot doit effectuer pour le projet.  Comme pour les autres classes, il existe de nombreuses solutions toutes faites.  Notre usine se compose de cinq étapes.  En règle générale, la première étape consiste à obtenir l'état actuel du référentiel, et ici nous ne ferons pas d'exception.  Pour ce faire, nous utilisons la classe <i>Git</i> standard: <br><br><div class="spoiler">  <b class="spoiler_title">Première étape</b> <div class="spoiler_text"><pre> <code class="python hljs">factory = util.BuildFactory() factory.addStep(steps.Git( repourl = util.Property(<span class="hljs-string"><span class="hljs-string">'repository'</span></span>), workdir = <span class="hljs-string"><span class="hljs-string">'sources'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, submodules = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, progress = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) )</code> </pre> <br></div></div><br>  Ensuite, nous devons créer un répertoire dans lequel le projet sera assemblé - nous allons faire une compilation complète à partir des sources.  Avant cela, vous devez vous rappeler de supprimer le répertoire s'il existe déjà.  Ainsi, nous devons exécuter deux commandes.  La classe <i>ShellSequence</i> nous aidera avec ceci: <br><br><div class="spoiler">  <b class="spoiler_title">Deuxième étape</b> <div class="spoiler_text"><pre> <code class="python hljs">factory.addStep(steps.ShellSequence( name = <span class="hljs-string"><span class="hljs-string">'create builddir'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, hideStepIf = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> results, s: results == util.SUCCESS, commands = [ util.ShellArg(command = [<span class="hljs-string"><span class="hljs-string">'rm'</span></span>, <span class="hljs-string"><span class="hljs-string">'-rf'</span></span>, <span class="hljs-string"><span class="hljs-string">'build'</span></span>]), util.ShellArg(command = [<span class="hljs-string"><span class="hljs-string">'mkdir'</span></span>, <span class="hljs-string"><span class="hljs-string">'build'</span></span>]) ]) )</code> </pre> <br></div></div><br>  Vous devez maintenant démarrer CMake.  Pour ce faire, il est logique d'utiliser l'une des deux classes - <i>ShellCommand</i> ou <i>CMake</i> .  Nous utiliserons ce dernier, mais les différences sont minimes: il s'agit d'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">simple wrapper</a> sur la première classe, ce qui rend un peu plus pratique le passage d'arguments spécifiques à CMake. <br><br><div class="spoiler">  <b class="spoiler_title">Troisième étape</b> <div class="spoiler_text"><pre> <code class="python hljs">factory.addStep(steps.CMake( workdir = <span class="hljs-string"><span class="hljs-string">'build'</span></span>, path = <span class="hljs-string"><span class="hljs-string">'../sources'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) )</code> </pre> <br></div></div><br>  Il est temps de compiler le projet.  Comme dans le cas précédent, vous pouvez utiliser <i>ShellCommand</i> .  De même, il existe une classe <i>Compile</i> qui est un wrapper sur <i>ShellCommand</i> .  Néanmoins, c'est un wrapper plus délicat: la classe <i>Compile</i> surveille les avertissements pendant la compilation et les affiche avec précision dans un journal séparé.  C'est pourquoi nous utiliserons la classe <i>Compile</i> : <br><br><div class="spoiler">  <b class="spoiler_title">Quatrième étape</b> <div class="spoiler_text"><pre> <code class="python hljs">factory.addStep(steps.Compile( name = <span class="hljs-string"><span class="hljs-string">'build project'</span></span>, workdir = <span class="hljs-string"><span class="hljs-string">'build'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, warnOnWarnings = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, command = [<span class="hljs-string"><span class="hljs-string">'make'</span></span>]) )</code> </pre> <br></div></div><br>  Enfin, exécutez nos tests.  Ici, nous utiliserons la classe <i>ShellCommand</i> mentionnée précédemment: <br><br><div class="spoiler">  <b class="spoiler_title">Cinquième étape</b> <div class="spoiler_text"><pre> <code class="python hljs">factory.addStep(steps.ShellCommand( name = <span class="hljs-string"><span class="hljs-string">'run tests'</span></span>, workdir = <span class="hljs-string"><span class="hljs-string">'build'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, command = [<span class="hljs-string"><span class="hljs-string">'ctest'</span></span>]) )</code> </pre> <br></div></div><br><h3>  Exemple 2: pipeline en tant que code </h3><br>  Ici, je vais montrer comment implémenter une option budgétaire pour stocker la logique de test avec le code source du projet, et non dans le fichier de configuration ci-server.  Pour ce faire, placez le fichier <i>.buildbot</i> dans le référentiel avec le code, dans lequel chaque ligne se compose de mots, le premier étant interprété comme un répertoire pour la commande à exécuter et le reste comme une commande avec ses arguments.  Pour notre projet pour animaux de compagnie, le fichier <i>.buildbot</i> ressemblera à ceci: <br><br><div class="spoiler">  <b class="spoiler_title">Fichier .Buildbot avec commandes</b> <div class="spoiler_text"> <code>. rm -rf build <br> . mkdir build <br> build cmake ../sources <br> build make <br> build ctest</code> <br> </div></div><br>  Nous devons maintenant modifier le fichier de configuration de Buildbot.  Pour analyser le fichier <i>.buildbot</i> , nous devrons écrire une classe de notre propre étape.  Cette étape lira le fichier <i>.buildbot</i> , après quoi, pour chaque ligne, ajoutez l'étape <i>ShellCommand</i> avec les arguments nécessaires.  Pour ajouter des étapes de manière dynamique, nous utiliserons la méthode <b>build.addStepsAfterCurrentStep ()</b> .  Ça n'a pas l'air effrayant du tout: <br><br><div class="spoiler">  <b class="spoiler_title">Classe AnalyseStep</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnalyseStep</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(ShellMixin, BuildStep)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, workdir, **kwargs)</span></span></span><span class="hljs-function">:</span></span> kwargs = self.setupShellMixin(kwargs, prohibitArgs = [<span class="hljs-string"><span class="hljs-string">'command'</span></span>, <span class="hljs-string"><span class="hljs-string">'workdir'</span></span>, <span class="hljs-string"><span class="hljs-string">'want_stdout'</span></span>]) BuildStep.__init__(self, **kwargs) self.workdir = workdir @defer.inlineCallbacks <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.stdio_log = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> self.addLog(<span class="hljs-string"><span class="hljs-string">'stdio'</span></span>) cmd = RemoteShellCommand( command = [<span class="hljs-string"><span class="hljs-string">'cat'</span></span>, <span class="hljs-string"><span class="hljs-string">'.buildbot'</span></span>], workdir = self.workdir, want_stdout = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, want_stderr = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, collectStdout = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> ) cmd.useLog(self.stdio_log) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> self.runCommand(cmd) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cmd.didFail(): defer.returnValue(util.FAILURE) results = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> row <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cmd.stdout.splitlines(): lst = row.split() dirname = lst.pop(<span class="hljs-number"><span class="hljs-number">0</span></span>) results.append(steps.ShellCommand( name = lst[<span class="hljs-number"><span class="hljs-number">0</span></span>], command = lst, workdir = dirname ) ) self.build.addStepsAfterCurrentStep(results) defer.returnValue(util.SUCCESS)</code> </pre> <br></div></div><br>  Grâce à cette approche, l'usine du collectionneur est devenue plus simple et plus polyvalente: <br><br><div class="spoiler">  <b class="spoiler_title">Usine pour analyser le fichier .buildbot</b> <div class="spoiler_text"><pre> <code class="python hljs">factory = util.BuildFactory() factory.addStep(steps.Git( repourl = util.Property(<span class="hljs-string"><span class="hljs-string">'repository'</span></span>), workdir = <span class="hljs-string"><span class="hljs-string">'sources'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, submodules = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, progress = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, mode = <span class="hljs-string"><span class="hljs-string">'incremental'</span></span>) ) factory.addStep(AnalyseStep( name = <span class="hljs-string"><span class="hljs-string">'Analyse .buildbot file'</span></span>, workdir = <span class="hljs-string"><span class="hljs-string">'sources'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, hideStepIf = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> results, s: results == util.SUCCESS) )</code> </pre> <br></div></div><br><h3>  Exemple trois: travailleur comme code </h3><br>  Imaginez maintenant qu'à côté du code du projet, nous devons déterminer non pas la séquence de commandes, mais l'environnement de l'assembly.  En fait, nous définissons travailleur.  <i>Le</i> fichier <i>.buildbot</i> pourrait ressembler à ceci: <br><br><div class="spoiler">  <b class="spoiler_title">Fichier d'environnement .Buildbot</b> <div class="spoiler_text"> <code>{ <br> "workers": ["stretch32", "wheezy32"] <br> }</code> <br> </div></div><br>  Le fichier de configuration de Buildbot dans ce cas deviendra plus compliqué, car nous voulons que les assemblys sur différents environnements soient interconnectés (si au moins un environnement échoue, la validation entière était considérée comme inopérante).  Deux niveaux nous aident à résoudre le problème.  Nous aurons un travailleur local qui analyse le fichier <i>.buildbot</i> et exécute les builds sur les travailleurs souhaités.  Tout d'abord, comme dans l'exemple précédent, nous allons écrire notre étape pour analyser le fichier <i>.buildbot</i> .  Pour démarrer l'assemblage sur un travailleur spécifique, un ensemble de l'étape <i>Déclencheur</i> et un type spécial de planificateurs <i>TriggerableScheduler</i> sont <i>utilisés</i> .  Notre démarche est devenue un peu plus compliquée, mais assez compréhensible: <br><br><div class="spoiler">  <b class="spoiler_title">Classe AnalyseStep</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnalyseStep</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(ShellMixin, BuildStep)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, workdir, **kwargs)</span></span></span><span class="hljs-function">:</span></span> kwargs = self.setupShellMixin(kwargs, prohibitArgs = [<span class="hljs-string"><span class="hljs-string">'command'</span></span>, <span class="hljs-string"><span class="hljs-string">'workdir'</span></span>, <span class="hljs-string"><span class="hljs-string">'want_stdout'</span></span>]) BuildStep.__init__(self, **kwargs) self.workdir = workdir @defer.inlineCallbacks <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_getWorkerList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> cmd = RemoteShellCommand( command = [<span class="hljs-string"><span class="hljs-string">'cat'</span></span>, <span class="hljs-string"><span class="hljs-string">'.buildbot'</span></span>], workdir = self.workdir, want_stdout = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, want_stderr = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, collectStdout = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> ) cmd.useLog(self.stdio_log) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> self.runCommand(cmd) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cmd.didFail(): defer.returnValue([]) <span class="hljs-comment"><span class="hljs-comment"># parse JSON try: payload = json.loads(cmd.stdout) workers = payload.get('workers', []) except json.decoder.JSONDecodeError as e: raise ValueError('Error loading JSON from .buildbot file: {}' .format(str(e))) defer.returnValue(workers) @defer.inlineCallbacks def run(self): self.stdio_log = yield self.addLog('stdio') try: workers = yield self._getWorkerList() except ValueError as e: yield self.stdio_log.addStdout(str(e)) defer.returnValue(util.FAILURE) results = [] for worker in workers: results.append(steps.Trigger( name = 'check on worker "{}"'.format(worker), schedulerNames = ['Pet Project ({}) Scheduler'.format(worker)], waitForFinish = True, haltOnFailure = True, warnOnWarnings = True, updateSourceStamp = False, alwaysUseLatest = False ) ) self.build.addStepsAfterCurrentStep(results) defer.returnValue(util.SUCCESS)</span></span></code> </pre> <br></div></div><br>  Nous utiliserons cette étape sur le travailleur local.  Veuillez noter que nous avons défini la balise sur notre collecteur «Pet Project Builder».  Avec lui, nous pouvons filtrer <i>MailNotifier</i> , lui disant que les lettres ne doivent être envoyées qu'à certains collectionneurs.  Si ce filtrage n'est pas effectué, lors de la construction de la validation sur deux environnements, nous recevrons trois lettres. <br><br><div class="spoiler">  <b class="spoiler_title">Collectionneur général</b> <div class="spoiler_text"><pre> <code class="python hljs">factory = util.BuildFactory() factory.addStep(steps.Git( repourl = util.Property(<span class="hljs-string"><span class="hljs-string">'repository'</span></span>), workdir = <span class="hljs-string"><span class="hljs-string">'sources'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, submodules = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, progress = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, mode = <span class="hljs-string"><span class="hljs-string">'incremental'</span></span>) ) factory.addStep(AnalyseStep( name = <span class="hljs-string"><span class="hljs-string">'Analyse .buildbot file'</span></span>, workdir = <span class="hljs-string"><span class="hljs-string">'sources'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, hideStepIf = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> results, s: results == util.SUCCESS) ) c[<span class="hljs-string"><span class="hljs-string">'builders'</span></span>] = [util.BuilderConfig( name = <span class="hljs-string"><span class="hljs-string">'Pet Project Builder'</span></span>, tags = [<span class="hljs-string"><span class="hljs-string">'generic_builder'</span></span>], workernames = [<span class="hljs-string"><span class="hljs-string">'local'</span></span>], factory = factory )]</code> </pre> <br></div></div><br>  Il nous reste à ajouter les collecteurs et les mêmes programmateurs déclencheurs pour tous nos vrais travailleurs: <br><br><div class="spoiler">  <b class="spoiler_title">Des collectionneurs dans le bon environnement</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> worker <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> allWorkers: c[<span class="hljs-string"><span class="hljs-string">'schedulers'</span></span>].append(schedulers.Triggerable( name = <span class="hljs-string"><span class="hljs-string">'Pet Project ({}) Scheduler'</span></span>.format(worker), builderNames = [<span class="hljs-string"><span class="hljs-string">'Pet Project ({}) Builder'</span></span>.format(worker)]) ) c[<span class="hljs-string"><span class="hljs-string">'builders'</span></span>].append(util.BuilderConfig( name = <span class="hljs-string"><span class="hljs-string">'Pet Project ({}) Builder'</span></span>.format(worker), workernames = [worker], factory = specific_factory) )</code> </pre> <br></div></div><br><img src="https://habrastorage.org/webt/iq/_n/n4/iq_nn4nhvj07vcina32c2244o6a.png"><br>  <i><font color="#aaaaaa">(construire la page de notre projet dans deux environnements)</font></i> <br><br><h3>  Exemple quatre: une lettre pour plusieurs validations </h3><br>  Si vous utilisez l'un des exemples ci-dessus, vous pouvez remarquer une caractéristique désagréable.  Puisqu'une lettre est créée pour chaque validation, lorsque nous poussons la branche avec 20 nouvelles validations, nous recevrons 20 lettres.  En évitant cela, comme dans l'exemple précédent, nous aiderons à deux niveaux.  Nous devons également modifier la classe pour obtenir les modifications.  Au lieu de créer de nombreux objets de modification, nous ne créerons qu'un seul de ces objets, dans les propriétés desquels une liste de tous les commits est transmise.  En toute hâte, cela peut être fait comme ceci: <br><br><div class="spoiler">  <b class="spoiler_title">Classe MultiGitHubHandler</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MultiGitHubHandler</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(GitHubHandler)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getChanges</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, request)</span></span></span><span class="hljs-function">:</span></span> new_changes = GitHubHandler.getChanges(self, request) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> new_changes: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ([], <span class="hljs-string"><span class="hljs-string">'git'</span></span>) change = new_changes[<span class="hljs-number"><span class="hljs-number">-1</span></span>] change[<span class="hljs-string"><span class="hljs-string">'revision'</span></span>] = <span class="hljs-string"><span class="hljs-string">'{}..{}'</span></span>.format( new_changes[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-string"><span class="hljs-string">'revision'</span></span>], new_changes[<span class="hljs-number"><span class="hljs-number">-1</span></span>][<span class="hljs-string"><span class="hljs-string">'revision'</span></span>]) commits = [c[<span class="hljs-string"><span class="hljs-string">'revision'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> new_changes] change[<span class="hljs-string"><span class="hljs-string">'properties'</span></span>][<span class="hljs-string"><span class="hljs-string">'commits'</span></span>] = commits <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ([change], <span class="hljs-string"><span class="hljs-string">'git'</span></span>) c[<span class="hljs-string"><span class="hljs-string">'www'</span></span>][<span class="hljs-string"><span class="hljs-string">'change_hook_dialects'</span></span>] = { <span class="hljs-string"><span class="hljs-string">'base'</span></span>: { <span class="hljs-string"><span class="hljs-string">'custom_class'</span></span>: MultiGitHubHandler } }</code> </pre> <br></div></div><br>  Pour travailler avec un objet de changement aussi inhabituel, nous avons besoin de notre propre étape spéciale, qui crée dynamiquement des étapes qui collectent un commit spécifique: <br><br><div class="spoiler">  <b class="spoiler_title">Classe GenerateCommitSteps</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GenerateCommitSteps</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(BuildStep)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> commits = self.getProperty(<span class="hljs-string"><span class="hljs-string">'commits'</span></span>) results = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> commit <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> commits: results.append(steps.Trigger( name = <span class="hljs-string"><span class="hljs-string">'Checking commit {}'</span></span>.format(commit), schedulerNames = [<span class="hljs-string"><span class="hljs-string">'Pet Project Commits Scheduler'</span></span>], waitForFinish = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, warnOnWarnings = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, sourceStamp = { <span class="hljs-string"><span class="hljs-string">'branch'</span></span>: util.Property(<span class="hljs-string"><span class="hljs-string">'branch'</span></span>), <span class="hljs-string"><span class="hljs-string">'revision'</span></span>: commit, <span class="hljs-string"><span class="hljs-string">'codebase'</span></span>: util.Property(<span class="hljs-string"><span class="hljs-string">'codebase'</span></span>), <span class="hljs-string"><span class="hljs-string">'repository'</span></span>: util.Property(<span class="hljs-string"><span class="hljs-string">'repository'</span></span>), <span class="hljs-string"><span class="hljs-string">'project'</span></span>: util.Property(<span class="hljs-string"><span class="hljs-string">'project'</span></span>) } ) ) self.build.addStepsAfterCurrentStep(results) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> util.SUCCESS</code> </pre> <br></div></div><br>  Ajoutez notre collecteur commun, qui n'est impliqué que dans l'exécution des assemblys de commits individuels.  Il doit être balisé afin de filtrer ensuite l'envoi de lettres par ce tag lui-même. <br><br><div class="spoiler">  <b class="spoiler_title">Récupérateur de courrier général</b> <div class="spoiler_text"><pre> <code class="python hljs">c[<span class="hljs-string"><span class="hljs-string">'schedulers'</span></span>] = [schedulers.AnyBranchScheduler( name = <span class="hljs-string"><span class="hljs-string">'Pet Project Branches Scheduler'</span></span>, treeStableTimer = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, change_filter = util.ChangeFilter(project = <span class="hljs-string"><span class="hljs-string">'Pet Project'</span></span>), builderNames = [<span class="hljs-string"><span class="hljs-string">'Pet Project Branches Builder'</span></span>] )] branches_factory = util.BuildFactory() branches_factory.addStep(GenerateCommitSteps( name = <span class="hljs-string"><span class="hljs-string">'Generate commit steps'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, hideStepIf = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> results, s: results == util.SUCCESS) ) c[<span class="hljs-string"><span class="hljs-string">'builders'</span></span>] = [util.BuilderConfig( name = <span class="hljs-string"><span class="hljs-string">'Pet Project Branches Builder'</span></span>, tags = [<span class="hljs-string"><span class="hljs-string">'branch_builder'</span></span>], workernames = [<span class="hljs-string"><span class="hljs-string">'local'</span></span>], factory = branches_factory )]</code> </pre> <br></div></div><br>  Il reste à ajouter uniquement le collecteur pour les validations individuelles.  Nous ne marquons simplement pas ce collecteur avec une balise, et par conséquent, aucune lettre ne sera créée pour lui. <br><br><div class="spoiler">  <b class="spoiler_title">Récupérateur de courrier général</b> <div class="spoiler_text"><pre> <code class="python hljs">c[<span class="hljs-string"><span class="hljs-string">'schedulers'</span></span>].append(schedulers.Triggerable( name = <span class="hljs-string"><span class="hljs-string">'Pet Project Commits Scheduler'</span></span>, builderNames = [<span class="hljs-string"><span class="hljs-string">'Pet Project Commits Builder'</span></span>]) ) c[<span class="hljs-string"><span class="hljs-string">'builders'</span></span>].append(util.BuilderConfig( name = <span class="hljs-string"><span class="hljs-string">'Pet Project Commits Builder'</span></span>, workernames = [<span class="hljs-string"><span class="hljs-string">'stretch32'</span></span>], factory = specific_factory) )</code> </pre> <br></div></div><br><h3>  Les derniers mots </h3><br>  Cet article ne remplace en aucun cas la lecture de la documentation officielle, donc si vous êtes intéressé par Buildbot, alors votre prochaine étape devrait être de le lire.  Les versions complètes des fichiers de configuration de tous les exemples sont disponibles sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github</a> .  Liens connexes, à partir desquels la plupart des éléments de l'article ont été extraits: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Documentation officielle</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Code source du projet</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr439096/">https://habr.com/ru/post/fr439096/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr439080/index.html">Le RabbitMQ non évident dans Yii2 ou pourquoi RabbitMQ écrit dans toutes les files d'attente à la fois</a></li>
<li><a href="../fr439082/index.html">Wish Factory Walk</a></li>
<li><a href="../fr439086/index.html">Causes de l'ANR et comment l'éviter</a></li>
<li><a href="../fr439090/index.html">L'IBM 5150. Où le monopole a commencé</a></li>
<li><a href="../fr439094/index.html">Les scientifiques ont trouvé le plus vieux vertébré vivant sur Terre</a></li>
<li><a href="../fr439098/index.html">Sasha Memus, Chatfuel: Comment construire une carrière dans les produits après avoir consulté, est-il dangereux de méditer et comment changer de comportement</a></li>
<li><a href="../fr439100/index.html">Comment adapter UX / UI sous les autorisations</a></li>
<li><a href="../fr439102/index.html">Les Russes sont 20% plus susceptibles de subir des insultes sur Internet</a></li>
<li><a href="../fr439104/index.html">Redux Simple comme un râteau</a></li>
<li><a href="../fr439108/index.html">Mesures radioamateur: quand il n'y a pas de fréquencemètre</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>