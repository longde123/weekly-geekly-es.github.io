<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêã üë©üèø‚Äçüöí üèß Distribution statique des objets FreeRTOS üí¢ üîÉ üíñ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Par d√©faut, tous les objets du syst√®me FreeRTOS sont distribu√©s dynamiquement - files d'attente, s√©maphores, temporisateurs, t√¢ches (threads) et mutex...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Distribution statique des objets FreeRTOS</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459086/">  Par d√©faut, tous les objets du syst√®me FreeRTOS sont distribu√©s dynamiquement - files d'attente, s√©maphores, temporisateurs, t√¢ches (threads) et mutex.  Le programmeur ne voit que le "tas" - la zone o√π la m√©moire est allou√©e dynamiquement √† la demande d'un programme ou d'un syst√®me, et ce qui se passe √† l'int√©rieur n'est pas clair.  Combien reste-t-il?  Inconnu  Est-ce que quelque chose prend plus que ce dont vous avez besoin?  Qui sait?  Personnellement, je pr√©f√®re r√©soudre les probl√®mes d'organisation de la m√©moire m√™me au stade de l'√©criture du firmware, sans apporter d'erreurs d'ex√©cution lorsque la m√©moire s'est termin√©e de fa√ßon inattendue. <br><br>  Cet article est une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">suite</a> logique <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d'hier</a> sur la distribution statique des objets dans la m√©moire du microcontr√¥leur, uniquement maintenant par rapport aux objets FreeRTOS.  Aujourd'hui, nous apprendrons √† placer des objets FreeRTOS de mani√®re statique, ce qui nous permettra de comprendre plus clairement ce qui se passe dans la RAM du microcontr√¥leur, comment exactement nos objets sont situ√©s et combien ils occupent. <br><br>  Mais simplement prendre et commencer √† placer des objets FreeRTOS statiquement ne n√©cessite pas beaucoup d'intelligence - √† partir de la version 9.0, FreeRTOS fournit des fonctions pour cr√©er des objets plac√©s statiquement.  Ces fonctions ont un suffixe statique dans le nom et ces fonctions ont une excellente documentation avec des exemples.  Nous √©crirons des wrappers C ++ pratiques et beaux sur les fonctions FreeRTOS qui non seulement placeront les objets statiquement, mais cacheront √©galement tous les abats, ainsi que fourniront une interface plus pratique. <br><br>  Cet article est destin√© aux programmeurs d√©butants, mais qui connaissent d√©j√† les bases de FreeRTOS et les primitives de synchronisation des programmes multithread.  Allons-y. <br><a name="habracut"></a><br>  FreeRTOS est un syst√®me d'exploitation pour microcontr√¥leurs.  Eh bien, pas un syst√®me d'exploitation complet, mais une biblioth√®que qui vous permet d'ex√©cuter plusieurs t√¢ches en parall√®le.  FreeRTOS permet √©galement aux t√¢ches d'√©changer des messages via des files d'attente de messages, d'utiliser des minuteries et de synchroniser les t√¢ches √† l'aide de s√©maphores et de mutex. <br><br>  √Ä mon avis, tout micrologiciel o√π vous devez effectuer simultan√©ment deux t√¢ches (ou plus) peut √™tre r√©solu beaucoup plus facilement et plus √©l√©gamment si vous utilisez FreeRTOS.  Par exemple, lisez les lectures des capteurs lents et servez l'affichage en m√™me temps.  Seulement pour que sans freins, pendant la lecture des capteurs.  En g√©n√©ral, doit avoir!  Je recommande fortement pour l'√©tude. <br><br>  Comme je l'ai dit et √©crit dans un article pr√©c√©dent, je n'aime pas vraiment l'approche de cr√©ation dynamique d'objets si nous connaissons leur nombre et leur taille au stade de la compilation.  Si de tels objets sont plac√©s statiquement, alors nous pouvons obtenir une image plus claire et plus compr√©hensible de l'allocation de m√©moire dans le microcontr√¥leur, et donc √©viter les surprises lorsque la m√©moire s'est soudainement termin√©e. <br><br>  Nous consid√©rerons les probl√®mes d'organisation de la m√©moire FreeRTOS en utilisant la carte BluePill sur le microcontr√¥leur STM32F103C8T6 comme exemple.  Afin de ne pas vous soucier du compilateur et du syst√®me de construction, nous travaillerons dans l'environnement ArduinoIDE, en installant le support pour cette carte.  Il existe plusieurs impl√©mentations d'Arduino pour STM32 - en principe, tout le monde le fera.  J'ai install√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">stm32duino</a> conform√©ment aux instructions du projet Readme.md, un chargeur de d√©marrage tel que mentionn√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans cet article</a> .  FreeRTOS version 10.0 est install√© via le gestionnaire de biblioth√®que ArduinoIDE.  Compilateur - gcc 8.2 <br><br>  Nous proposerons une petite t√¢che exp√©rimentale.  Il peut ne pas y avoir beaucoup de sens pratique dans cette t√¢che, mais toutes les primitives de synchronisation qui sont dans FreeRTOS seront utilis√©es.  Quelque chose comme √ßa: <br><br><ul><li>  2 t√¢ches (threads) fonctionnent en parall√®le </li><li>  une minuterie fonctionne √©galement, qui envoie de temps en temps une notification √† la premi√®re t√¢che √† l'aide d'un s√©maphore <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">en mode signal-attente</a> </li><li>  la premi√®re t√¢che, apr√®s avoir re√ßu une notification du temporisateur, envoie un message (nombre al√©atoire) √† la deuxi√®me t√¢che via la file d'attente </li><li>  le second, ayant re√ßu le message, l'imprime sur la console </li><li>  laissez la premi√®re t√¢che imprime √©galement quelque chose sur la console, et afin qu'ils ne combattent pas, la console sera prot√©g√©e par le mutex. </li><li>  la taille de la file d'attente pourrait √™tre limit√©e √† un √©l√©ment, mais pour le rendre plus int√©ressant, nous avons mis 1000 </li></ul><br>  L'impl√©mentation standard (selon la documentation et les tutoriels) peut ressembler √† ceci. <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;STM32FreeRTOS.h&gt; TimerHandle_t xTimer; xSemaphoreHandle xSemaphore; xSemaphoreHandle xMutex; xQueueHandle xQueue; void vTimerCallback(TimerHandle_t pxTimer) { xSemaphoreGive(xSemaphore); } void vTask1(void *) { while(1) { xSemaphoreTake(xSemaphore, portMAX_DELAY); int value = random(1000); xQueueSend(xQueue, &amp;value, portMAX_DELAY); xSemaphoreTake(xMutex, portMAX_DELAY); Serial.println("Test"); xSemaphoreGive(xMutex); } } void vTask2(void *) { while(1) { int value; xQueueReceive(xQueue, &amp;value, portMAX_DELAY); xSemaphoreTake(xMutex, portMAX_DELAY); Serial.println(value); xSemaphoreGive(xMutex); } } void setup() { Serial.begin(9600); vSemaphoreCreateBinary(xSemaphore); xQueue = xQueueCreate(1000, sizeof(int)); xMutex = xSemaphoreCreateMutex(); xTimer = xTimerCreate("Timer", 1000, pdTRUE, NULL, vTimerCallback); xTimerStart(xTimer, 0); xTaskCreate(vTask1, "Task 1", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL); xTaskCreate(vTask2, "Task 2", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL); vTaskStartScheduler(); } void loop() {}</span></span></span></span></code> </pre> <br>  Voyons ce qui se passe dans la m√©moire du microcontr√¥leur, si vous compilez un tel code.  Par d√©faut, tous les objets FreeRTOS sont plac√©s dans la m√©moire dynamique.  FreeRTOS fournit jusqu'√† 5 impl√©mentations de gestionnaires de m√©moire qui sont difficiles √† impl√©menter, mais en g√©n√©ral, ils ont la m√™me t√¢che - couper des morceaux de m√©moire pour les besoins de FreeRTOS et de l'utilisateur.  Les morceaux sont coup√©s soit dans le tas g√©n√©ral du microcontr√¥leur (√† l'aide de malloc), soit dans leur propre tas s√©par√©.  Le type de tas utilis√© pour nous n'est pas important - de toute fa√ßon, nous ne pouvons pas regarder √† l'int√©rieur du tas. <br><br>  Par exemple, pour un tas du nom FreeRTOS, il ressemblera √† ceci (sortie de l'utilitaire objdump) <br><br><pre> <code class="plaintext hljs">... 200009dc l O .bss 00002000 ucHeap ...</code> </pre><br>  C'est-√†-dire  nous voyons une grande pi√®ce, √† l'int√©rieur de laquelle tous les objets FreeRTOS sont coup√©s - s√©maphores, mutex, temporisateurs, files d'attente et m√™me les t√¢ches elles-m√™mes.  Les 2 derniers points sont tr√®s importants.  En fonction du nombre d'√©l√©ments, la file d'attente peut √™tre assez grande et les t√¢ches sont assur√©es de prendre beaucoup d'espace en raison de la pile, qui est √©galement allou√©e avec la t√¢che. <br><br>  Oui, c'est moins le multit√¢che - chaque t√¢che aura sa propre pile.  De plus, la pile doit √™tre suffisamment grande pour contenir non seulement les appels et les variables locales de la t√¢che elle-m√™me, mais √©galement la pile d'interruption, si cela se produit.  Eh bien, comme une interruption peut survenir √† tout moment, chaque t√¢che doit avoir une r√©serve sur la pile en cas d'interruption.  De plus, les microcontr√¥leurs CortexM peuvent avoir des interruptions imbriqu√©es, donc la pile doit √™tre suffisamment grande pour accueillir toutes les interruptions si elles se produisent simultan√©ment. <br><br>  La taille de la pile de t√¢ches est d√©finie lorsque la t√¢che est cr√©√©e par le param√®tre de la fonction xTaskCreate.  La taille de la pile ne peut pas √™tre inf√©rieure au param√®tre configMINIMAL_STACK_SIZE (sp√©cifi√© dans le fichier de configuration FreeRTOSConfig.h) - il s'agit de la m√™me r√©serve pour les interruptions.  La taille du segment de m√©moire est d√©finie par le param√®tre configTOTAL_HEAP_SIZE et dans ce cas est de 8 Ko. <br><br><div class="spoiler">  <b class="spoiler_title">Essayez maintenant de deviner si tous nos objets tiendront dans un tas de 8 Ko?</b>  <b class="spoiler_title">Et quelques objets?</b>  <b class="spoiler_title">Et quelques t√¢ches suppl√©mentaires?</b> <div class="spoiler_text">  Avec certains param√®tres FreeRTOS, tous les objets ne tenaient pas dans le tas.  Et cela ressemble √† ceci: le programme ne fonctionne tout simplement pas.  C'est-√†-dire  tout est compil√©, vers√©, mais le microcontr√¥leur se bloque et c'est tout.  Et devinez que le probl√®me est exactement la taille du tas.  J'ai d√ª augmenter un groupe √† 12 Ko. <br></div></div><br>  Arr√™tez, quelles sont les variables xTimer, xQueue, xSemaphore et xMutex?  Ne d√©crivent-ils pas les objets dont nous avons besoin?  Non, ce ne sont que des poign√©es - pointeurs vers une certaine structure (opaque), qui d√©crit les objets de synchronisation eux-m√™mes <br><br><pre> <code class="plaintext hljs">200009cc g O .bss 00000004 xTimer 200009d0 g O .bss 00000004 xSemaphore 200009cc g O .bss 00000004 xQueue 200009d4 g O .bss 00000004 xMutex</code> </pre><br>  Comme je l'ai d√©j√† mentionn√©, je propose de r√©parer tout ce d√©sordre de la m√™me mani√®re que dans l'article pr√©c√©dent - nous distribuerons tous nos objets statiquement au stade de la compilation.  Les fonctions de distribution statiques deviennent disponibles si le param√®tre configSUPPORT_STATIC_ALLOCATION est d√©fini sur 1 dans le fichier de configuration FreeRTOS. <br><br>  Commen√ßons par les lignes.  Voici comment la documentation sur FreeRTOS propose d'allouer des files d'attente <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AMessage</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ucMessageID; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ucData[ <span class="hljs-number"><span class="hljs-number">20</span></span> ]; }; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> QUEUE_LENGTH 10 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ITEM_SIZE sizeof( uint32_t ) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// xQueueBuffer will hold the queue structure. StaticQueue_t xQueueBuffer; // ucQueueStorage will hold the items posted to the queue. Must be at least // [(queue length) * ( queue item size)] bytes long. uint8_t ucQueueStorage[ QUEUE_LENGTH * ITEM_SIZE ]; void vATask( void *pvParameters ) { QueueHandle_t xQueue1; // Create a queue capable of containing 10 uint32_t values. xQueue1 = xQueueCreate( QUEUE_LENGTH, // The number of items the queue can hold. ITEM_SIZE // The size of each item in the queue &amp;( ucQueueStorage[ 0 ] ), // The buffer that will hold the items in the queue. &amp;xQueueBuffer ); // The buffer that will hold the queue structure. // The queue is guaranteed to be created successfully as no dynamic memory // allocation is used. Therefore xQueue1 is now a handle to a valid queue. // ... Rest of task code. }</span></span></span></span></code> </pre> <br>  Dans cet exemple, la file d'attente est d√©crite par trois variables: <br><br><ul><li>  Le tableau ucQueueStorage est l'endroit o√π les √©l√©ments de file d'attente seront plac√©s.  La taille de la file d'attente est d√©finie par l'utilisateur pour chaque file d'attente individuellement. </li><li>  La structure xQueueBuffer - ici vit la description et l'√©tat de la file d'attente, la taille actuelle, les listes des t√¢ches en attente, ainsi que d'autres attributs et champs n√©cessaires √† FreeRTOS pour travailler avec la file d'attente.  Le nom de la variable, √† mon avis, n'est pas enti√®rement r√©ussi, dans FreeRTOS lui-m√™me, cette chose est appel√©e QueueDefinition (description de la file d'attente). </li><li>  La variable xQueue1 est l'identifiant de la file d'attente (handle).  Toutes les fonctions de gestion de file d'attente, ainsi que certaines autres (par exemple, les fonctions internes pour travailler avec des temporisateurs, des s√©maphores et des mutex) acceptent une telle poign√©e.  En fait, ce n'est qu'un pointeur vers QueueDefinition, mais nous ne le savons pas (pour ainsi dire), et donc la poign√©e devra √™tre tir√©e s√©par√©ment. </li></ul><br>  Faire comme dans l'exemple, bien s√ªr, ne sera pas un probl√®me.  Mais personnellement, je n'aime pas avoir jusqu'√† 3 variables par entit√©.  Une classe qui peut l'encapsuler le demande d√©j√†.  Un seul probl√®me - la taille de chaque file d'attente peut varier.  Dans un endroit, vous avez besoin d'une file d'attente plus grande, dans un autre, quelques √©l√©ments suffisent.  Puisque nous voulons faire la queue statiquement, nous devons en quelque sorte sp√©cifier cette taille au moment de la compilation.  Vous pouvez utiliser le mod√®le pour cela. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">size_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">size</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Queue</span></span></span><span class="hljs-class"> {</span></span> QueueHandle_t xHandle; StaticQueue_t x QueueDefinition; T xStorage[size]; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Queue() { xHandle = xQueueCreateStatic(size, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T), <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*&gt;(xStorage), &amp;xQueueDefinition); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T * val, TickType_t xTicksToWait = portMAX_DELAY)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xQueueReceive(xHandle, val, xTicksToWait); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T &amp; val, TickType_t xTicksToWait = portMAX_DELAY)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xQueueSend(xHandle, &amp;val, xTicksToWait); } };</code> </pre> <br>  Dans le m√™me temps, les fonctions d'envoi et de r√©ception de messages, qui nous √©taient imm√©diatement pratiques, se sont √©galement install√©es dans cette classe. <br><br>  La file d'attente sera d√©clar√©e comme une variable globale, quelque chose comme ceci <br><br><pre> <code class="cpp hljs">Queue&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>&gt; xQueue;</code> </pre> <br>  Envoi de message <br><br><pre> <code class="cpp hljs"> xQueue.send(value);</code> </pre> <br>  Recevoir un message <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; xQueue.receive(&amp;value);</code> </pre><br>  Voyons maintenant les s√©maphores.  Et bien que techniquement (√† l'int√©rieur de FreeRTOS) les s√©maphores et les mutex soient impl√©ment√©s via des files d'attente, s√©mantiquement ce sont 3 primitives diff√©rentes.  Par cons√©quent, nous les impl√©menterons dans des classes distinctes. <br><br>  L'impl√©mentation de la classe s√©maphore sera assez triviale - elle stocke simplement plusieurs variables et d√©clare plusieurs fonctions. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sema</span></span></span><span class="hljs-class"> {</span></span> SemaphoreHandle_t xSema; StaticSemaphore_t xSemaControlBlock; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Sema() { xSema = xSemaphoreCreateBinaryStatic(&amp;xSemaControlBlock); } <span class="hljs-function"><span class="hljs-function">BaseType_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">give</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xSemaphoreGive(xSema); } <span class="hljs-function"><span class="hljs-function">BaseType_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">take</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TickType_t xTicksToWait = portMAX_DELAY)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xSemaphoreTake(xSema, xTicksToWait); } };</code> </pre> <br>  D√©claration du s√©maphore <br><br><pre> <code class="cpp hljs">Sema xSema;</code> </pre> <br>  Capture de s√©maphore <br><br><pre> <code class="cpp hljs"> xSema.take();</code> </pre> <br>  Sortie du s√©maphore <br><br><pre> <code class="cpp hljs"> xSema.give();</code> </pre> <br>  Maintenant mutex <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mutex</span></span></span><span class="hljs-class"> {</span></span> SemaphoreHandle_t xMutex; StaticSemaphore_t xMutexControlBlock; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Mutex() { xMutex = xSemaphoreCreateMutexStatic(&amp;xSemaControlBlock); } <span class="hljs-function"><span class="hljs-function">BaseType_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TickType_t xTicksToWait = portMAX_DELAY)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xSemaphoreTake(xMutex, xTicksToWait); } <span class="hljs-function"><span class="hljs-function">BaseType_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xSemaphoreGive(xMutex); } };</code> </pre> <br>  Comme vous pouvez le voir, la classe mutex est presque identique √† la classe s√©maphore.  Mais comme je l'ai dit s√©mantiquement, ce sont des entit√©s diff√©rentes.  De plus, les interfaces de ces classes ne sont pas compl√®tes et elles se d√©velopperont dans des directions compl√®tement diff√©rentes.  Ainsi, les m√©thodes giveFromISR () et takeFromISR () peuvent √™tre ajout√©es au s√©maphore pour fonctionner avec le s√©maphore dans l'interruption, tandis que le mutex n'a que la m√©thode tryLock () ajout√©e - il n'a aucune autre op√©ration s√©mantiquement. <br><br><div class="spoiler">  <b class="spoiler_title">J'esp√®re que vous connaissez la diff√©rence entre un s√©maphore binaire et un mutex.</b> <div class="spoiler_text">  Je pose toujours cette question lors des entretiens et, malheureusement, 90% des candidats ne comprennent pas cette diff√©rence.  En fait, un s√©maphore peut √™tre captur√© et lib√©r√© √† partir de diff√©rents threads.  Ci-dessus, j'ai mentionn√© le mode s√©maphore signal-attente lorsqu'un thread envoie un signal (appels give ()), et l'autre attend un signal (avec la fonction take ()). <br><br>  Mutex, au contraire, ne peut √™tre lib√©r√© qu'√† partir du m√™me flux (t√¢che) qui l'a captur√©.  Je ne suis pas s√ªr que FreeRTOS surveille cela, mais certains syst√®mes d'exploitation (par exemple, Linux) le suivent assez strictement. </div></div><br>  Mutex peut √™tre utilis√© dans le style C, c'est-√†-dire  appeler directement lock () / unlock ().  Mais puisque nous √©crivons en C ++, nous pouvons profiter des charmes de RAII et √©crire un wrapper plus pratique qui capturera et lib√©rera le mutex lui-m√™me. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MutexLocker</span></span></span><span class="hljs-class"> {</span></span> Mutex &amp; mtx; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: MutexLocker(Mutex &amp; mutex) : mtx(mutex) { mtx.lock(); } ~MutexLocker() { mtx.unlock(); } };</code> </pre> <br>  En quittant la port√©e, le mutex sera automatiquement lib√©r√©. <br><br>  Cela est particuli√®rement pratique s'il existe plusieurs sorties de la fonction et que vous n'avez pas besoin de vous rappeler constamment la n√©cessit√© de lib√©rer des ressources. <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-function">MutexLocker </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xMutex)</span></span></span></span>; Serial.println(value); } <span class="hljs-comment"><span class="hljs-comment">// mutex will be unlocked here</span></span></code> </pre> <br>  C'est maintenant au tour des minuteries. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Timer</span></span></span><span class="hljs-class"> {</span></span> TimerHandle_t xTimer; StaticTimer_t xTimerControlBlock; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Timer(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pcTimerName, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TickType_t xTimerPeriodInTicks, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UBaseType_t uxAutoReload, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pvTimerID, TimerCallbackFunction_t pxCallbackFunction) { xTimer = xTimerCreateStatic(pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, &amp;xTimerControlBlock); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TickType_t xTicksToWait = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ xTimerStart(xTimer, xTicksToWait); } };</code> </pre> <br>  En g√©n√©ral, tout ici est similaire aux classes pr√©c√©dentes, je ne m'attarderai pas sur les d√©tails.  Peut-√™tre que l'API laisse beaucoup √† d√©sirer, ou du moins n√©cessite une expansion.  Mais mon objectif est de montrer le principe, et non de le mettre en √©tat de production pr√™t. <br><br>  Et enfin, les t√¢ches.  Chaque t√¢che a une pile et doit √™tre plac√©e en m√©moire √† l'avance.  Nous utiliserons la m√™me technique qu'avec les files d'attente - nous √©crirons une classe mod√®le <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ulStackDepth&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: StaticTask_t xTaskControlBlock; StackType_t xStack[ ulStackDepth ]; TaskHandle_t xTask; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Task(TaskFunction_t pxTaskCode, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pcName, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pvParameters, UBaseType_t uxPriority) { xTask = xTaskCreateStatic(pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, xStack, &amp;xTaskControlBlock); } };</code> </pre> <br>  Puisque les objets de t√¢che sont maintenant d√©clar√©s comme variables globales, ils seront initialis√©s en tant que variables globales - avant d'appeler main ().  Cela signifie que les param√®tres qui sont transf√©r√©s aux t√¢ches doivent √©galement √™tre connus √† ce stade.  Cette nuance doit √™tre prise en compte si dans votre cas quelque chose est pass√© qui doit √™tre calcul√© avant de cr√©er la t√¢che (j'ai juste NULL l√†).  Si cela ne vous convient toujours pas, envisagez l'option avec des variables statiques locales <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">de l'article pr√©c√©dent</a> . <br><br>  Compilez et obtenez l'erreur: <br><br><pre> <code class="plaintext hljs">tasks.c:(.text.vTaskStartScheduler+0x10): undefined reference to `vApplicationGetIdleTaskMemory' timers.c:(.text.xTimerCreateTimerTask+0x1a): undefined reference to `vApplicationGetTimerTaskMemory'</code> </pre> <br>  Voici le truc.  Chaque syst√®me d'exploitation a une t√¢che sp√©ciale - T√¢che inactive (la t√¢che par d√©faut, la t√¢che de ne rien faire).  Le syst√®me d'exploitation effectue cette t√¢che si toutes les autres t√¢ches ne peuvent pas √™tre effectu√©es (par exemple, dormir ou attendre quelque chose).  En g√©n√©ral, c'est la t√¢che la plus courante, uniquement avec la priorit√© la plus faible.  Mais ici, il est cr√©√© √† l'int√©rieur du noyau FreeRTOS et nous ne pouvons pas influencer sa cr√©ation.  Mais depuis que nous avons commenc√© √† placer des t√¢ches statiquement, nous devons en quelque sorte dire au syst√®me d'exploitation o√π vous souhaitez placer l'unit√© de contr√¥le et la pile de cette t√¢che.  C'est √† cela que sert FreeRTOS et nous demande de d√©finir une fonction sp√©ciale vApplicationGetIdleTaskMemory (). <br><br>  Une situation similaire est avec la t√¢che des minuteries.  Les temporisateurs du syst√®me FreeRTOS ne vivent pas seuls - une t√¢che sp√©ciale tourne dans le syst√®me d'exploitation, qui sert ces temporisateurs.  Et cette t√¢che n√©cessite √©galement un bloc de contr√¥le et une pile.  Et juste comme √ßa, le syst√®me d'exploitation nous demande d'indiquer o√π ils utilisent la fonction vApplicationGetTimerTaskMemory (). <br><br>  Les fonctions elles-m√™mes sont triviales et renvoient simplement les pointeurs correspondants aux objets allou√©s statiquement. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vApplicationGetIdleTaskMemory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pulIdleTaskStackSize)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> StaticTask_t Idle_TCB; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> StackType_t Idle_Stack[configMINIMAL_STACK_SIZE]; *ppxIdleTaskTCBBuffer = &amp;Idle_TCB; *ppxIdleTaskStackBuffer = Idle_Stack; *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE; } <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vApplicationGetTimerTaskMemory</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pulTimerTaskStackSize)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> StaticTask_t Timer_TCB; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> StackType_t Timer_Stack[configTIMER_TASK_STACK_DEPTH]; *ppxTimerTaskTCBBuffer = &amp;Timer_TCB; *ppxTimerTaskStackBuffer = Timer_Stack; *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH; }</code> </pre> <br>  Voyons ce que nous avons. <br><br><div class="spoiler">  <b class="spoiler_title">Je vais cacher le code des aides sous le spoiler, tu viens de le voir</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">size_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">size</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Queue</span></span></span><span class="hljs-class"> {</span></span> QueueHandle_t xHandle; StaticQueue_t xQueueDefinition; T xStorage[size]; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Queue() { xHandle = xQueueCreateStatic(size, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T), <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*&gt;(xStorage), &amp;xQueueDefinition); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T * val, TickType_t xTicksToWait = portMAX_DELAY)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xQueueReceive(xHandle, val, xTicksToWait); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T &amp; val, TickType_t xTicksToWait = portMAX_DELAY)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xQueueSend(xHandle, &amp;val, xTicksToWait); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sema</span></span></span><span class="hljs-class"> {</span></span> SemaphoreHandle_t xSema; StaticSemaphore_t xSemaControlBlock; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Sema() { xSema = xSemaphoreCreateBinaryStatic(&amp;xSemaControlBlock); } <span class="hljs-function"><span class="hljs-function">BaseType_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">give</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xSemaphoreGive(xSema); } <span class="hljs-function"><span class="hljs-function">BaseType_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">take</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TickType_t xTicksToWait = portMAX_DELAY)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xSemaphoreTake(xSema, xTicksToWait); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mutex</span></span></span><span class="hljs-class"> {</span></span> SemaphoreHandle_t xMutex; StaticSemaphore_t xMutexControlBlock; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Mutex() { xMutex = xSemaphoreCreateMutexStatic(&amp;xMutexControlBlock); } <span class="hljs-function"><span class="hljs-function">BaseType_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TickType_t xTicksToWait = portMAX_DELAY)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xSemaphoreTake(xMutex, xTicksToWait); } <span class="hljs-function"><span class="hljs-function">BaseType_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xSemaphoreGive(xMutex); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MutexLocker</span></span></span><span class="hljs-class"> {</span></span> Mutex &amp; mtx; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: MutexLocker(Mutex &amp; mutex) : mtx(mutex) { mtx.lock(); } ~MutexLocker() { mtx.unlock(); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Timer</span></span></span><span class="hljs-class"> {</span></span> TimerHandle_t xTimer; StaticTimer_t xTimerControlBlock; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Timer(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pcTimerName, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TickType_t xTimerPeriodInTicks, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UBaseType_t uxAutoReload, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pvTimerID, TimerCallbackFunction_t pxCallbackFunction) { xTimer = xTimerCreateStatic(pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, &amp;xTimerControlBlock); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TickType_t xTicksToWait = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ xTimerStart(xTimer, xTicksToWait); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ulStackDepth&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: StaticTask_t xTaskControlBlock; StackType_t xStack[ ulStackDepth ]; TaskHandle_t xTask; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Task(TaskFunction_t pxTaskCode, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pcName, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pvParameters, UBaseType_t uxPriority) { xTask = xTaskCreateStatic(pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, xStack, &amp;xTaskControlBlock); } }; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vApplicationGetIdleTaskMemory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pulIdleTaskStackSize)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> StaticTask_t Idle_TCB; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> StackType_t Idle_Stack[configMINIMAL_STACK_SIZE]; *ppxIdleTaskTCBBuffer = &amp;Idle_TCB; *ppxIdleTaskStackBuffer = Idle_Stack; *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE; } <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vApplicationGetTimerTaskMemory</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pulTimerTaskStackSize)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> StaticTask_t Timer_TCB; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> StackType_t Timer_Stack[configTIMER_TASK_STACK_DEPTH]; *ppxTimerTaskTCBBuffer = &amp;Timer_TCB; *ppxTimerTaskStackBuffer = Timer_Stack; *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH; }</code> </pre> </div></div><br><br>  Le code de l'ensemble du programme. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Timer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xTimer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"Timer"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1000</span></span></span></span><span class="hljs-function"><span class="hljs-params">, pdTRUE, </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">NULL</span></span></span></span><span class="hljs-function"><span class="hljs-params">, vTimerCallback)</span></span></span></span>; Sema xSema; Mutex xMutex; Queue&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>&gt; xQueue; Task&lt;configMINIMAL_STACK_SIZE&gt; task1(vTask1, <span class="hljs-string"><span class="hljs-string">"Task 1"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, tskIDLE_PRIORITY); Task&lt;configMINIMAL_STACK_SIZE&gt; task2(vTask2, <span class="hljs-string"><span class="hljs-string">"Task 2"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, tskIDLE_PRIORITY); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vTimerCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TimerHandle_t pxTimer)</span></span></span><span class="hljs-function"> </span></span>{ xSema.give(); <span class="hljs-function"><span class="hljs-function">MutexLocker </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xMutex)</span></span></span></span>; Serial.println(<span class="hljs-string"><span class="hljs-string">"Test"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vTask1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) { xSema.take(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = random(<span class="hljs-number"><span class="hljs-number">1000</span></span>); xQueue.send(value); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vTask2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; xQueue.receive(&amp;value); <span class="hljs-function"><span class="hljs-function">MutexLocker </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xMutex)</span></span></span></span>; Serial.println(value); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Serial.begin(<span class="hljs-number"><span class="hljs-number">9600</span></span>); xTimer.start(); vTaskStartScheduler(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{}</code> </pre> <br>  Vous pouvez d√©monter le binaire r√©sultant et voir quoi et comment il se trouve (la sortie de objdump est l√©g√®rement teint√©e pour une meilleure lisibilit√©): <br><br><pre> <code class="plaintext hljs">0x200000b0 .bss 512 vApplicationGetIdleTaskMemory::Idle_Stack 0x200002b0 .bss 92 vApplicationGetIdleTaskMemory::Idle_TCB 0x2000030c .bss 1024 vApplicationGetTimerTaskMemory::Timer_Stack 0x2000070c .bss 92 vApplicationGetTimerTaskMemory::Timer_TCB 0x200009c8 .bss 608 task1 0x20000c28 .bss 608 task2 0x20000e88 .bss 84 xMutex 0x20000edc .bss 4084 xQueue 0x20001ed0 .bss 84 xSema 0x20001f24 .bss 48 xTimer</code> </pre> <br>  L'objectif est atteint - maintenant tout est bien en vue.  Chaque objet est visible et sa taille est compr√©hensible (enfin, sauf que les objets compos√©s du type T√¢che consid√®rent toutes leurs pi√®ces de rechange en une seule pi√®ce).  Les statistiques du compilateur sont √©galement extr√™mement pr√©cises et cette fois tr√®s utiles. <br><br><pre> <code class="plaintext hljs">Sketch uses 20,800 bytes (15%) of program storage space. Maximum is 131,072 bytes. Global variables use 9,332 bytes (45%) of dynamic memory, leaving 11,148 bytes for local variables. Maximum is 20,480 bytes.</code> </pre> <br><h2>  Conclusion </h2><br>  Bien que FreeRTOS vous permette de cr√©er et de supprimer des t√¢ches, des files d'attente, des s√©maphores et des mutex √† la vol√©e, dans de nombreux cas, cela n'est pas n√©cessaire.  En r√®gle g√©n√©rale, il suffit de cr√©er tous les objets au d√©marrage une fois et ils fonctionneront jusqu'au prochain red√©marrage.  Et c'est une bonne raison de distribuer de tels objets statiquement au stade de la compilation.  En cons√©quence, nous obtenons une compr√©hension claire de la m√©moire occup√©e par nos objets, o√π se trouvent et combien de m√©moire libre reste. <br><br>  Il est √©vident que la m√©thode propos√©e ne convient que pour placer des objets dont la dur√©e de vie est comparable √† la dur√©e de vie de l'ensemble de l'application.  Sinon, vous devez utiliser la m√©moire dynamique. <br><br>  En plus du placement statique des objets FreeRTOS, nous avons √©galement √©crit des wrappers pratiques sur les primitives FreeRTOS, ce qui nous a permis de simplifier quelque peu le code client et d'encapsuler <br><br>  L'interface peut √™tre simplifi√©e si n√©cessaire (par exemple, ne pas v√©rifier le code retour, ou ne pas utiliser de timeouts).  Il convient √©galement de noter que l'impl√©mentation est incompl√®te - je n'ai pas pris la peine de mettre en ≈ìuvre toutes les m√©thodes possibles d'envoi et de r√©ception de messages via la file d'attente (par exemple, √† partir d'une interruption, envoi au d√©but ou √† la fin de la file d'attente), je n'ai pas impl√©ment√© de primitives de synchronisation √† partir des interruptions, comptage des s√©maphores (non binaires), et bien plus. <br><br>  J'√©tais trop paresseux pour amener ce code √† l'√©tat "prendre et utiliser", je voulais juste montrer l'id√©e.  Mais qui a besoin d'une biblioth√®que pr√™te √† l'emploi, je suis juste tomb√© sur la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">biblioth√®que frt</a> .  Tout y est pratiquement le m√™me, seulement rappel√©.  Eh bien, l'interface est un peu diff√©rente. <br><br>  Un exemple de l'article est <a href="">ici</a> . <br><br>  Merci √† tous d'avoir lu cet article jusqu'au bout.  Je me ferai un plaisir de formuler des critiques constructives.  Il sera √©galement int√©ressant pour moi de discuter des nuances dans les commentaires. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr459086/">https://habr.com/ru/post/fr459086/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr459074/index.html">Petite petite joie # 7: trois pour le prix d'un - animation sur console, algorithmes et d√©bogage</a></li>
<li><a href="../fr459078/index.html">Le CERN passe aux logiciels open source - pourquoi?</a></li>
<li><a href="../fr459080/index.html">Caract√©ristiques HttpUrlConnection de java.net</a></li>
<li><a href="../fr459082/index.html">Qui sont l'eid√©tique, comment fonctionnent les faux souvenirs et trois mythes populaires sur la m√©moire</a></li>
<li><a href="../fr459084/index.html">Un peu sur Google Home Hub, ou comment j'ai achet√© un cadre photo pour 130 euros</a></li>
<li><a href="../fr459088/index.html">M√©thodes de segmentation ponctuelle dans les nuages ‚Äã‚Äãde points</a></li>
<li><a href="../fr459090/index.html">Faites passer votre exp√©rience de d√©veloppement Linux sous Windows au niveau sup√©rieur avec WSL et Visual Studio Code Remote</a></li>
<li><a href="../fr459092/index.html">X.Spectator - surveillance de l'√©tat dans .NET</a></li>
<li><a href="../fr459094/index.html">C # ou Java? TypeScript ou JavaScript? Classification bas√©e sur l'apprentissage automatique des langages de programmation</a></li>
<li><a href="../fr459098/index.html">Le registre des packages GitHub prend en charge les packages Swift</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>