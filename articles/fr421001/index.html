<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôéüèº üë®‚Äçüéì üï≥Ô∏è RPC - une occasion d'essayer de nouveaux en C ++ 14/17 üïû üå´Ô∏è üÜë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il y a plusieurs ann√©es, les d√©veloppeurs C ++ ont re√ßu la norme C ++ 11 tant attendue, qui a apport√© beaucoup de nouvelles choses. Et j'avais int√©r√™t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RPC - une occasion d'essayer de nouveaux en C ++ 14/17</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421001/"><img src="https://habrastorage.org/webt/r5/fg/-w/r5fg-wsld9ujbwxghq54s-kpaso.jpeg" width="250" height="180" align="left">  Il y a plusieurs ann√©es, les d√©veloppeurs C ++ ont re√ßu la norme C ++ 11 tant attendue, qui a apport√© beaucoup de nouvelles choses.  Et j'avais int√©r√™t √† passer rapidement √† son utilisation dans les t√¢ches quotidiennes.  Allez en C ++ 14 et 17 ce n'√©tait pas le cas.  Il semblait qu'il n'existait aucun ensemble de caract√©ristiques susceptibles d'√™tre int√©ressantes.  Au printemps, j'ai d√©cid√© de regarder les innovations de la langue et d'essayer quelque chose.  Pour exp√©rimenter les innovations, vous deviez trouver une t√¢che pour vous-m√™me.  Je n'ai pas eu √† r√©fl√©chir longtemps.  Il a √©t√© d√©cid√© d'√©crire votre RPC avec des structures de donn√©es personnalis√©es en tant que param√®tres et sans utiliser de macros et de g√©n√©ration de code - le tout en C ++.  Cela a √©t√© possible gr√¢ce aux nouvelles fonctionnalit√©s du langage. <br><br>  L'id√©e, l'impl√©mentation, le feedback avec Reddit, les am√©liorations - tout est apparu au printemps, au d√©but de l'√©t√©.  √Ä la fin, ils ont r√©ussi √† terminer le poste sur Habr. <br><br>  Avez-vous pens√© √† votre propre RPC?  Peut-√™tre que le mat√©riel du message vous aidera √† d√©terminer l'objectif, les m√©thodes, les moyens et √† d√©cider en faveur de celui qui est termin√© ou √† mettre en ≈ìuvre quelque chose vous-m√™me ... <br><a name="habracut"></a><br><h1>  Pr√©sentation </h1><br>  RPC (appel de proc√©dure distante) n'est pas un nouveau sujet.  Il existe de nombreuses impl√©mentations dans diff√©rents langages de programmation.  Les impl√©mentations utilisent diff√©rents formats de donn√©es et modes de transport.  Tout cela peut se refl√©ter en quelques points: <br><br><ul><li>  S√©rialisation / d√©s√©rialisation </li><li>  Le transport </li><li>  Ex√©cution de m√©thode √† distance </li><li>  R√©sultat de retour </li></ul><br>  La mise en ≈ìuvre est d√©termin√©e par l'objectif souhait√©.  Par exemple, vous pouvez vous fixer l'objectif d'assurer une vitesse √©lev√©e d'appel d'une m√©thode √† distance et de sacrifier la convivialit√©, ou vice versa, pour fournir un confort maximum pour l'√©criture de code, en perdant √©ventuellement un peu de performance.  Les objectifs et les outils sont diff√©rents ... Je voulais du confort et des performances acceptables. <br><br><h1>  Impl√©mentation </h1><br>  Voici quelques √©tapes pour impl√©menter RPC en C ++ 14/17, et l'accent est mis sur certaines des innovations de langage qui ont fait appara√Ætre ce mat√©riel. <br><br>  Le mat√©riel est destin√© √† ceux qui, pour une raison quelconque, sont int√©ress√©s par leur RPC et, peut-√™tre, jusqu'√† pr√©sent, ont besoin d'informations suppl√©mentaires.  Dans les commentaires, il serait int√©ressant de voir une description de l'exp√©rience d'autres d√©veloppeurs confront√©s √† des t√¢ches similaires. <br><br><h2>  S√©rialisation </h2><br>  Avant de commencer √† √©crire du code, je vais former une t√¢che: <br><br><ul><li>  Tous les param√®tres de m√©thode et le r√©sultat renvoy√© sont transmis via le tuple. </li><li>  Les m√©thodes appel√©es elles-m√™mes ne sont pas oblig√©es d'accepter et de renvoyer des tuples. </li><li>  Le r√©sultat de l'empaquetage d'un tuple devrait √™tre un tampon dont le format n'est pas fixe </li></ul><br>  Voici un code de s√©rialiseur de cha√Æne simplifi√©. <br><br><div class="spoiler">  <b class="spoiler_title">string_serializer</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> rpc::type { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> buffer = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;; } <span class="hljs-comment"><span class="hljs-comment">// namespace rpc::type namespace rpc::packer { class string_serializer final { public: template &lt;typename ... T&gt; type::buffer save(std::tuple&lt;T ... &gt; const &amp;tuple) const { auto str = to_string(tuple, std::make_index_sequence&lt;sizeof ... (T)&gt;{}); return {begin(str), end(str)}; } template &lt;typename ... T&gt; void load(type::buffer const &amp;buffer, std::tuple&lt;T ... &gt; &amp;tuple) const { std::string str{begin(buffer), end(buffer)}; from_string(std::move(str), tuple, std::make_index_sequence&lt;sizeof ... (T)&gt;{}); } private: template &lt;typename T, std::size_t ... I&gt; std::string to_string(T const &amp;tuple, std::index_sequence&lt;I ... &gt;) const { std::stringstream stream; auto put_item = [&amp;stream] (auto const &amp;i) { if constexpr (std::is_same_v&lt;std::decay_t&lt;decltype(i)&gt;, std::string&gt;) stream &lt;&lt; std::quoted(i) &lt;&lt; ' '; else stream &lt;&lt; i &lt;&lt; ' '; }; (put_item(std::get&lt;I&gt;(tuple)), ... ); return std::move(stream.str()); } template &lt;typename T, std::size_t ... I&gt; void from_string(std::string str, T &amp;tuple, std::index_sequence&lt;I ... &gt;) const { std::istringstream stream{std::move(str)}; auto get_item = [&amp;stream] (auto &amp;i) { if constexpr (std::is_same_v&lt;std::decay_t&lt;decltype(i)&gt;, std::string&gt;) stream &gt;&gt; std::quoted(i); else stream &gt;&gt; i; }; (get_item(std::get&lt;I&gt;(tuple)), ... ); } }; } // namespace rpc::packer</span></span></code> </pre> </div></div><br>  Et le code de fonction principal d√©montrant le fonctionnement du s√©rialiseur. <br><br><div class="spoiler">  <b class="spoiler_title">Fonction principale</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple args{<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>{<span class="hljs-string"><span class="hljs-string">"Test string !!!"</span></span>}, <span class="hljs-number"><span class="hljs-number">3.14</span></span>}; rpc::packer::string_serializer serializer; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pack = serializer.save(args); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Pack data: "</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>{begin(pack), end(pack)} &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(args) params; serializer.load(pack, params); <span class="hljs-comment"><span class="hljs-comment">// For test { auto pack = serializer.save(params); std::cout &lt;&lt; "Deserialized pack: " &lt;&lt; std::string{begin(pack), end(pack)} &lt;&lt; std::endl; } } catch (std::exception const &amp;e) { std::cerr &lt;&lt; "Error: " &lt;&lt; e.what() &lt;&lt; std::endl; return EXIT_FAILURE; } return EXIT_SUCCESS; }</span></span></code> </pre></div></div><br>  <b>Accents accr√©dit√©s</b> <br><br>  Tout d'abord, vous devez d√©terminer le tampon avec lequel l'ensemble de l'√©change de donn√©es sera effectu√©: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> rpc::type { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> buffer = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;; } <span class="hljs-comment"><span class="hljs-comment">// namespace rpc::type</span></span></code> </pre><br>  Le s√©rialiseur dispose de m√©thodes pour enregistrer un tuple dans le tampon (enregistrer) et le charger √† partir du tampon (charger) <br><br>  La m√©thode save prend un tuple et retourne un tampon. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... T&gt; type::<span class="hljs-function"><span class="hljs-function">buffer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::tuple&lt;T ... &gt; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;tuple)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> str = to_string(tuple, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_index_sequence&lt;<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> ... (T)&gt;{}); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {begin(str), end(str)}; }</code> </pre><br>  Un tuple est un mod√®le avec un nombre variable de param√®tres.  Ces mod√®les sont apparus en C ++ 11 et ont bien fonctionn√©.  Ici, vous devez en quelque sorte parcourir tous les √©l√©ments d'un tel mod√®le.  Il peut y avoir plusieurs options.  J'utiliserai l'une des fonctionnalit√©s de C ++ 14 - une s√©quence d'entiers (indices).  Le type make_index_sequence est apparu dans la biblioth√®que standard, ce qui permet d'obtenir la s√©quence suivante: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ints</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">integer_sequence</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">N</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">make_integer_sequence</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:integer_sequence&lt;T, <span class="hljs-comment"><span class="hljs-comment">/* a sequence 0, 1, 2, ..., N-1 */</span></span> &gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> make_index_sequence = make_integer_sequence&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>, N&gt;;</code> </pre><br>  Un similaire peut √™tre impl√©ment√© en C ++ 11, puis le transporter de projet en projet. <br><br>  Une telle s√©quence d'indices permet de "parcourir" le tuple: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ... I&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_string</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;tuple, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::index_sequence&lt;I ... &gt;)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">stringstream</span></span> stream; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> put_item = [&amp;stream] (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same_v&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">decay_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(i)&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;) stream &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::quoted(i) &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> stream &lt;&lt; i &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; }; (put_item(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;I&gt;(tuple)), ... ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(stream.str()); }</code> </pre><br>  La m√©thode to_string utilise plusieurs fonctionnalit√©s des derni√®res normes C ++. <br><br>  <b>Accents accr√©dit√©s</b> <br><br>  En C ++ 14, il est devenu possible d'utiliser auto comme param√®tres pour les fonctions lambda.  Cela n'√©tait souvent pas suffisant, par exemple, lorsque l'on travaillait avec les algorithmes de la biblioth√®que standard. <br><br>  Une <b>convolution</b> est apparue en C ++ 17, qui vous permet d'√©crire du code tel que: <br><br><pre> <code class="cpp hljs">(put_item(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;I&gt;(tuple)), ... );</code> </pre><br>  Dans le fragment donn√©, la fonction lambda put_item est appel√©e pour chacun des √©l√©ments du tuple transf√©r√©.  Cela garantit une s√©quence ind√©pendante de la plateforme et du compilateur.  Quelque chose de similaire pourrait √™tre √©crit en C ++ 11. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ‚Ä¶ T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unused</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T &amp;&amp; ‚Ä¶ )</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-comment"><span class="hljs-comment">// ... unused(put_item(std::get&lt;I&gt;(tuple)) ... );</span></span></code> </pre><br>  Mais dans quel ordre les √©l√©ments seraient stock√©s d√©pendrait du compilateur. <br><br>  De nombreux alias sont apparus dans la biblioth√®que standard C ++ 17, par exemple decay_t, ce qui a r√©duit les enregistrements du formulaire: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> decay&lt;T&gt;::type</code> </pre><br>  Le d√©sir d'√©crire des constructions plus courtes a sa place.  La conception du mod√®le, o√π quelques noms de caract√®res et mod√®les se trouvent sur une seule ligne, s√©par√©s par des deux-points et des crochets, semble effrayante.  Comment pouvez-vous effrayer certains de vos coll√®gues.  √Ä l'avenir, ils promettent de r√©duire le nombre d'endroits o√π vous devez √©crire le mod√®le, le nom de type. <br><br>  Le d√©sir de concision a donn√© une autre construction int√©ressante du langage ¬´si constexpr¬ª, √©vite d'√©crire de nombreuses sp√©cialisations priv√©es de mod√®les. <br><br>  Il y a un point int√©ressant.  Beaucoup ont appris que le commutateur et les constructions similaires ne sont pas tr√®s bons en termes d'√©volutivit√© du code.  Il est pr√©f√©rable d'utiliser le polymorphisme d'ex√©cution / compilation et la surcharge avec des arguments en faveur du ¬´bon choix¬ª.  Et puis ¬´si constexpr¬ª ... La possibilit√© de compacit√© ne laisse pas tout le monde indiff√©rent.  La possibilit√© de la langue ne signifie pas la n√©cessit√© de l'utiliser. <br><br>  Il √©tait n√©cessaire d'√©crire une s√©rialisation distincte pour le type de cha√Æne.  Pour un travail pratique avec des cha√Ænes, par exemple, lors de l'enregistrement dans un flux et de sa lecture, la fonction std :: quoted est apparue.  Il vous permet de filtrer les cha√Ænes et permet d'enregistrer dans un flux et de charger des dates √† partir de celui-ci sans penser au d√©limiteur. <br><br>  Vous pouvez vous arr√™ter √† la description de la s√©rialisation pour l'instant.  La d√©s√©rialisation (charge) est impl√©ment√©e de mani√®re similaire. <br><br><h2>  Le transport </h2><br>  Le transport est simple.  Il s'agit d'une fonction qui re√ßoit et renvoie un tampon. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> rpc::type { <span class="hljs-comment"><span class="hljs-comment">// ... using executor = std::function&lt;buffer (buffer)&gt;; } // namespace rpc::type</span></span></code> </pre><br>  En formant un tel ¬´ex√©cuteur¬ª d'objet √† l'aide de std :: bind, des fonctions lambda, etc., vous pouvez utiliser n'importe laquelle de vos impl√©mentations de transport.  Les d√©tails de la mise en ≈ìuvre du transport dans ce poste ne seront pas pris en compte.  Vous pouvez jeter un ≈ìil √† l'impl√©mentation RPC termin√©e, un lien vers lequel sera donn√© √† la fin. <br><br><h2>  Client </h2><br>  Voici un code client de test.  Le client g√©n√®re des requ√™tes et les envoie au serveur, en tenant compte du transport s√©lectionn√©.  Dans le code de test ci-dessous, toutes les demandes des clients sont affich√©es sur la console.  Et √† la prochaine √©tape de mise en ≈ìuvre, le client communiquera d√©j√† directement avec le serveur. <br><br><div class="spoiler">  <b class="spoiler_title">Client</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> rpc { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> TPacker&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">client</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">result</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: client(type::executor executor) : executor_{executor} { } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... TArgs&gt; <span class="hljs-function"><span class="hljs-function">result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;func_name, TArgs &amp;&amp; ... args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> request = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple(func_name, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;TArgs&gt;(args) ... ); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pack = packer_.save(request); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> responce = executor_(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(pack)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {responce}; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> packer_type = TPacker; packer_type packer_; type::executor executor_; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">result</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: result(type::buffer buffer) : buffer_{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(buffer)} { } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">decay_t</span></span>&lt;T&gt;&gt; tuple; packer_.load(buffer_, tuple); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(tuple)); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: packer_type packer_; type::buffer buffer_; }; }; } <span class="hljs-comment"><span class="hljs-comment">// namespace rpc</span></span></code> </pre></div></div><br>  Le client est impl√©ment√© en tant que classe de mod√®le.  Le param√®tre de mod√®le est un s√©rialiseur.  Si n√©cessaire, la classe peut √™tre refaite pas dans celle du mod√®le et pass√©e au constructeur un objet qui impl√©mente le s√©rialiseur. <br><br>  Dans l'impl√©mentation actuelle, le constructeur de classe accepte un objet en cours d'ex√©cution.  L'entrepreneur cache sous lui-m√™me la mise en ≈ìuvre du transport, et permet √† ce stade du code de ne pas penser aux m√©thodes d'√©change de donn√©es entre processus.  Dans le cas de test, l'impl√©mentation de transport affiche les demandes √† la console. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> executor = [] (rpc::type::buffer buffer) { <span class="hljs-comment"><span class="hljs-comment">// Print request data std::cout &lt;&lt; "Request pack: " &lt;&lt; std::string{begin(buffer), end(buffer)} &lt;&lt; std::endl; return buffer; };</span></span></code> </pre><br>  Le code personnalis√© n'a pas encore essay√© de tirer parti du r√©sultat du travail du client, car il n'y a aucun endroit o√π l'obtenir. <br><br>  <b>M√©thode d'appel client:</b> <br><br><ul><li>  l'utilisation du s√©rialiseur contient le nom de la m√©thode appel√©e et ses param√®tres </li><li>  l'utilisation de l'objet d'ex√©cution envoie une demande au serveur et re√ßoit une r√©ponse </li><li>  transmet la r√©ponse re√ßue √† une classe qui extrait le r√©sultat </li></ul><br>  L'impl√©mentation client de base est pr√™te.  Il reste quelque chose d'autre.  Plus d'informations √† ce sujet plus tard. <br><br><h2>  Serveur </h2><br>  Avant de commencer √† consid√©rer les d√©tails d'impl√©mentation c√¥t√© serveur, je sugg√®re un rapide coup d'≈ìil en diagonale sur l'exemple complet d'interaction client-serveur. <br><br>  Par souci de simplicit√©, la d√©monstration se fait en un seul processus.  L'impl√©mentation de transport est une fonction lambda qui passe un tampon entre le client et le serveur. <br><br><div class="spoiler">  <b class="spoiler_title">Interaction client-serveur.</b>  <b class="spoiler_title">Cas de test</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstdint&gt; #include &lt;cstdlib&gt; #include &lt;functional&gt; #include &lt;iomanip&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;sstream&gt; #include &lt;string&gt; #include &lt;tuple&gt; #include &lt;vector&gt; #include &lt;utility&gt; namespace rpc::type { using buffer = std::vector&lt;char&gt;; using executor = std::function&lt;buffer (buffer)&gt;; } // namespace rpc::type namespace rpc::detail { template &lt;typename&gt; struct function_meta; template &lt;typename TRes, typename ... TArgs&gt; struct function_meta&lt;std::function&lt;TRes (TArgs ... )&gt;&gt; { using result_type = std::decay_t&lt;TRes&gt;; using args_type = std::tuple&lt;std::decay_t&lt;TArgs&gt; ... &gt;; using request_type = std::tuple&lt;std::string, std::decay_t&lt;TArgs&gt; ... &gt;; }; } // namespace rpc::detail namespace rpc::packer { class string_serializer final { public: template &lt;typename ... T&gt; type::buffer save(std::tuple&lt;T ... &gt; const const &amp;tuple) const { auto str = to_string(tuple, std::make_index_sequence&lt;sizeof ... (T)&gt;{}); return {begin(str), end(str)}; } template &lt;typename ... T&gt; void load(type::buffer const &amp;buffer, std::tuple&lt;T ... &gt; &amp;tuple) const { std::string str{begin(buffer), end(buffer)}; from_string(std::move(str), tuple, std::make_index_sequence&lt;sizeof ... (T)&gt;{}); } private: template &lt;typename T, std::size_t ... I&gt; std::string to_string(T const &amp;tuple, std::index_sequence&lt;I ... &gt;) const { std::stringstream stream; auto put_item = [&amp;stream] (auto const &amp;i) { if constexpr (std::is_same_v&lt;std::decay_t&lt;decltype(i)&gt;, std::string&gt;) stream &lt;&lt; std::quoted(i) &lt;&lt; ' '; else stream &lt;&lt; i &lt;&lt; ' '; }; (put_item(std::get&lt;I&gt;(tuple)), ... ); return std::move(stream.str()); } template &lt;typename T, std::size_t ... I&gt; void from_string(std::string str, T &amp;tuple, std::index_sequence&lt;I ... &gt;) const { std::istringstream stream{std::move(str)}; auto get_item = [&amp;stream] (auto &amp;i) { if constexpr (std::is_same_v&lt;std::decay_t&lt;decltype(i)&gt;, std::string&gt;) stream &gt;&gt; std::quoted(i); else stream &gt;&gt; i; }; (get_item(std::get&lt;I&gt;(tuple)), ... ); } }; } // namespace rpc::packer namespace rpc { template &lt;typename TPacker&gt; class client final { private: class result; public: client(type::executor executor) : executor_{executor} { } template &lt;typename ... TArgs&gt; result call(std::string const &amp;func_name, TArgs &amp;&amp; ... args) { auto request = std::make_tuple(func_name, std::forward&lt;TArgs&gt;(args) ... ); auto pack = packer_.save(request); auto responce = executor_(std::move(pack)); return {responce}; } private: using packer_type = TPacker; packer_type packer_; type::executor executor_; class result final { public: result(type::buffer buffer) : buffer_{std::move(buffer)} { } template &lt;typename T&gt; auto as() const { std::tuple&lt;std::decay_t&lt;T&gt;&gt; tuple; packer_.load(buffer_, tuple); return std::move(std::get&lt;0&gt;(tuple)); } private: packer_type packer_; type::buffer buffer_; }; }; template &lt;typename TPacker&gt; class server final { public: template &lt;typename ... THandler&gt; server(std::pair&lt;char const *, THandler&gt; const &amp; ... handlers) { auto make_executor = [&amp;packer = packer_] (auto const &amp;handler) { auto executor = [&amp;packer, function = std::function{handler}] (type::buffer buffer) { using meta = detail::function_meta&lt;std::decay_t&lt;decltype(function)&gt;&gt;; typename meta::request_type request; packer.load(buffer, request); auto response = std::apply([&amp;function] (std::string const &amp;, auto &amp;&amp; ... args) { return function(std::forward&lt;decltype(args)&gt;(args) ... ); }, std::move(request) ); return packer.save(std::make_tuple(std::move(response))); }; return executor; }; (handlers_.emplace(handlers.first, make_executor(handlers.second)), ... ); } type::buffer execute(type::buffer buffer) { std::tuple&lt;std::string&gt; pack; packer_.load(buffer, pack); auto func_name = std::move(std::get&lt;0&gt;(pack)); auto const iter = handlers_.find(func_name); if (iter == end(handlers_)) throw std::runtime_error{"Function \"" + func_name + "\" not found."}; return iter-&gt;second(std::move(buffer)); } private: using packer_type = TPacker; packer_type packer_; using handlers_type = std::map&lt;std::string, type::executor&gt;; handlers_type handlers_; }; } // namespace rpc int main() { try { using packer_type = rpc::packer::string_serializer; rpc::server&lt;packer_type&gt; server{ std::pair{"hello", [] (std::string const &amp;s) { std::cout &lt;&lt; "Func: \"hello\". Inpur string: " &lt;&lt; s &lt;&lt; std::endl; return "Hello " + s + "!"; }}, std::pair{"to_int", [] (std::string const &amp;s) { std::cout &lt;&lt; "Func: \"to_int\". Inpur string: " &lt;&lt; s &lt;&lt; std::endl; return std::stoi(s); }} }; auto executor = [&amp;server] (rpc::type::buffer buffer) { return server.execute(std::move(buffer)); }; rpc::client&lt;packer_type&gt; client{std::move(executor)}; std::cout &lt;&lt; client.call("hello", std::string{"world"}).as&lt;std::string&gt;() &lt;&lt; std::endl; std::cout &lt;&lt; "Convert to int: " &lt;&lt; client.call("to_int", std::string{"100500"}).as&lt;int&gt;() &lt;&lt; std::endl; } catch (std::exception const &amp;e) { std::cerr &lt;&lt; "Error: " &lt;&lt; e.what() &lt;&lt; std::endl; return EXIT_FAILURE; } return EXIT_SUCCESS; }</span></span></span></span></code> </pre></div></div><br>  Dans l'impl√©mentation ci-dessus de la classe serveur, la chose la plus int√©ressante est son constructeur et la m√©thode execute. <br><br>  <b>Constructeur de classe de serveur</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... THandler&gt; server(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> *, THandler&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp; ... handlers) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> make_executor = [&amp;packer = packer_] (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;handler) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> executor = [&amp;packer, function = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function{handler}] (type::buffer buffer) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> meta = detail::function_meta&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">decay_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(function)&gt;&gt;; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> meta::request_type request; packer.load(buffer, request); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> response = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::apply([&amp;function] (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;, <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp; ... args) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> function(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(args)&gt;(args) ... ); }, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(request) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> packer.save(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(response))); }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> executor; }; (handlers_.emplace(handlers.first, make_executor(handlers.second)), ... ); }</code> </pre><br>  Le constructeur de la classe est passe-partout.  Il accepte une liste de paires en entr√©e  Chaque paire est un nom de m√©thode et un gestionnaire.  Et puisque le constructeur est un mod√®le avec un nombre variable de param√®tres, lors de la cr√©ation de l'objet serveur, tous les gestionnaires disponibles sur le serveur sont enregistr√©s imm√©diatement.  Cela permettra de ne pas faire de m√©thodes d'enregistrement suppl√©mentaires appel√©es sur les gestionnaires de serveur.  Et, √† son tour, lib√®re quelqu'un de la question de savoir si l'objet de classe de serveur sera utilis√© dans un environnement multithread et si la synchronisation est n√©cessaire. <br><br>  <b>Un fragment du constructeur de la classe serveur</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... THandler&gt; server(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> *, THandler&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp; ... handlers) { <span class="hljs-comment"><span class="hljs-comment">// ‚Ä¶ (handlers_.emplace(handlers.first, make_executor(handlers.second)), ... ); }</span></span></code> </pre><br>  Place un grand nombre de gestionnaires h√©t√©rog√®nes pass√©s dans la carte des fonctions du m√™me type.  Pour cela, la convolution est √©galement utilis√©e, ce qui permet de mettre facilement dans le std :: map l'ensemble des gestionnaires pass√©s sur une seule ligne sans boucles ni algorithmes <br><br><pre> <code class="cpp hljs">(handlers_.emplace(handlers.first, make_executor(handlers.second)), ... );</code> </pre><br>  Les fonctions Lambda qui permettent d'utiliser auto comme param√®tres ont facilit√© l'impl√©mentation du m√™me type de wrapper sur les gestionnaires.  Les enveloppements du m√™me type sont enregistr√©s dans la carte des m√©thodes disponibles sur le serveur (std :: map).  Lors du traitement des demandes, une recherche est effectu√©e sur une telle carte et le m√™me gestionnaire appelle le gestionnaire trouv√©, quels que soient les param√®tres re√ßus et le r√©sultat renvoy√©.  La fonction std :: apply qui est apparue dans la biblioth√®que standard appelle la fonction qui lui est pass√©e avec les param√®tres pass√©s en tant que tuple.  La fonction std :: apply peut √©galement √™tre impl√©ment√©e en C ++ 11.  Maintenant, il est disponible ¬´pr√™t √† l'emploi¬ª et il n'est pas n√©cessaire de le transf√©rer d'un projet √† l'autre. <br><br>  <b>Ex√©cuter la m√©thode</b> <br><br><pre> <code class="cpp hljs">type::<span class="hljs-function"><span class="hljs-function">buffer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(type::buffer buffer)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; pack; packer_.load(buffer, pack); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> func_name = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(pack)); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> iter = handlers_.find(func_name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (iter == end(handlers_)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error{<span class="hljs-string"><span class="hljs-string">"Function \""</span></span> + func_name + <span class="hljs-string"><span class="hljs-string">"\" not found."</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iter-&gt;second(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(buffer)); }</code> </pre><br>  R√©cup√®re le nom de la fonction appel√©e, recherche la m√©thode dans la carte des gestionnaires enregistr√©s, appelle le gestionnaire et renvoie le r√©sultat.  Tous int√©ressants dans les wrappers pr√©par√©s dans le constructeur de la classe serveur.  Quelqu'un a peut-√™tre remarqu√© l'exception et peut-√™tre la question s'est-elle pos√©e: "Les exceptions sont-elles g√©r√©es d'une mani√®re ou d'une autre?"  Oui, dans l'impl√©mentation compl√®te, qui sera donn√©e par r√©f√©rence √† la fin, un marshaling d'exception est fourni.  Pour simplifier le mat√©riel, aucune exception n'est transmise entre le client et le serveur. <br><br>  Jetez un autre regard sur la fonction <br><br><div class="spoiler">  <b class="spoiler_title">principal</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> packer_type = rpc::packer::string_serializer; rpc::server&lt;packer_type&gt; server{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair{<span class="hljs-string"><span class="hljs-string">"hello"</span></span>, [] (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;s) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Func: \"hello\". Inpur string: "</span></span> &lt;&lt; s &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Hello "</span></span> + s + <span class="hljs-string"><span class="hljs-string">"!"</span></span>; }}, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair{<span class="hljs-string"><span class="hljs-string">"to_int"</span></span>, [] (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;s) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Func: \"to_int\". Inpur string: "</span></span> &lt;&lt; s &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::stoi(s); }} }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> executor = [&amp;server] (rpc::type::buffer buffer) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> server.execute(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(buffer)); }; rpc::client&lt;packer_type&gt; client{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(executor)}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; client.call(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>{<span class="hljs-string"><span class="hljs-string">"world"</span></span>}).as&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Convert to int: "</span></span> &lt;&lt; client.call(<span class="hljs-string"><span class="hljs-string">"to_int"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>{<span class="hljs-string"><span class="hljs-string">"100500"</span></span>}).as&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;e) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Error: "</span></span> &lt;&lt; e.what() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EXIT_FAILURE; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EXIT_SUCCESS; }</code> </pre></div></div><br>  Il impl√©mente une interaction client-serveur √† part enti√®re.  Afin de ne pas compliquer le mat√©riel, le client et le serveur travaillent en un seul processus.  En rempla√ßant l'impl√©mentation de l'ex√©cuteur, vous pouvez utiliser le transport n√©cessaire. <br><br>  Dans la norme C ++ 17, il est parfois possible de ne pas sp√©cifier de param√®tres de mod√®le lors de l'instanciation.  Dans la fonction principale ci-dessus, ceci est utilis√© lors de l'enregistrement des gestionnaires de serveur (std :: pair sans param√®tres de mod√®le) et rend le code plus simple. <br><br>  L'impl√©mentation RPC de base est pr√™te.  Il reste √† ajouter la capacit√© promise de passer des structures de donn√©es personnalis√©es en tant que param√®tres et de renvoyer des r√©sultats. <br><br><h2>  Structures de donn√©es personnalis√©es </h2><br>  Pour transf√©rer des donn√©es √† travers la fronti√®re du processus, elles doivent √™tre s√©rialis√©es en quelque chose.  Par exemple, vous pouvez tout exporter vers un flux standard.  Beaucoup sera pris en charge hors de la bo√Æte.  Pour les structures de donn√©es personnalis√©es, vous devrez impl√©menter vous-m√™me les op√©rateurs de sortie.  Chaque structure a besoin de son propre op√©rateur de sortie.  Parfois, vous ne voulez pas faire √ßa.  Pour trier tous les champs de la structure et sortir chaque champ dans le flux, vous avez besoin d'une m√©thode g√©n√©ralis√©e.  La r√©flexion pourrait bien y aider.  Ce n'est pas encore en C ++.  Vous pouvez recourir √† la g√©n√©ration de code et √† l'utilisation d'un m√©lange de macros et de mod√®les.  Mais l'id√©e √©tait de faire l'interface de la biblioth√®que en C ++ pur. <br><br>  Il n'y a pas encore de r√©flexion compl√®te en C ++.  Par cons√©quent, la solution ci-dessous peut √™tre utilis√©e avec certaines limitations. <br><br>  La solution est bas√©e sur l'utilisation de la nouvelle fonctionnalit√© ¬´liaisons structur√©es¬ª C ++ 17.  Souvent, dans les dialogues, vous pouvez trouver beaucoup de jargon, j'ai donc refus√© toute option pour le nom de cette fonctionnalit√© en russe. <br><br>  Vous trouverez ci-dessous une solution qui vous permet de transf√©rer les champs de la structure de donn√©es transf√©r√©e vers le tuple. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_tuple</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T &amp;&amp;value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">decay_t</span></span>&lt;T&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(is_braces_constructible_v&lt;type, dummy_type, dummy_type, dummy_type&gt;)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp;[f1, f2, f3] = value; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple(f1, f2, f3); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> (is_braces_constructible_v&lt;type, dummy_type, dummy_type&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp;[f1, f2] = value; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple(f1, f2); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> (is_braces_constructible_v&lt;type, dummy_type&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp;[f1] = value; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple(f1); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple(); } }</code> </pre><br>  Sur Internet, vous pouvez trouver de nombreuses solutions similaires. <br><br>  Une grande partie de ce qui a √©t√© utilis√© ici a √©t√© dit ci-dessus, √† l'exception des liaisons structur√©es.  La fonction to_tuple accepte un type personnalis√©, d√©termine le nombre de champs et, √† l'aide de liaisons structur√©es, "transf√®re" les champs de structure √† un tuple.  Et ¬´si constexpr¬ª vous permet de s√©lectionner la branche d'impl√©mentation souhait√©e.  Comme il n'y a pas de r√©flexion en C ++, une solution compl√®te qui prend en compte tous les aspects du type ne peut pas √™tre construite.  Il existe des restrictions sur les types utilis√©s.  L'un d'eux - le type doit √™tre sans constructeur personnalis√©. <br><br>  To_tuple utilise is_braces_constructible_v.  Ce type vous permet de d√©terminer la capacit√© d'initialiser la structure transf√©r√©e √† l'aide d'accolades et de d√©terminer le nombre de champs. <br><br><div class="spoiler">  <b class="spoiler_title">is_braces_constructible_v</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dummy_type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> *&gt;(<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... TArgs&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">(T{</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::declval&lt;TArgs&gt;() ... }), </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::declval&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::true_type&gt;())</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_braces_constructible</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... &gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">false_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_braces_constructible</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... TArgs&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_braces_constructible_v = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">decay_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(is_braces_constructible&lt;T, TArgs ... &gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>))&gt;::value;</code> </pre></div></div><br>  La fonction to_tuple ci-dessus peut transformer des structures de donn√©es utilisateur ne contenant pas plus de trois champs en tuples.  Pour augmenter le nombre possible de champs ¬´d√©cal√©s¬ª de la structure, vous pouvez soit copier les branches ¬´if constexpr¬ª avec une petite inclusion de l'esprit, soit recourir √† la biblioth√®que boost.preprocessor la plus simple.  Si vous s√©lectionnez la deuxi√®me option, le code deviendra difficile √† lire et permettra d'utiliser des structures avec un grand nombre de champs. <br><br><div class="spoiler">  <b class="spoiler_title">Impl√©mentation de to_tuple avec boost.preprocessor</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_tuple</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T &amp;&amp;value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">decay_t</span></span>&lt;T&gt;; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NANORPC_TO_TUPLE_LIMIT_FIELDS 64 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// you can try to use BOOST_PP_LIMIT_REPEAT #define NANORPC_TO_TUPLE_DUMMY_TYPE_N(_, n, data) \ BOOST_PP_COMMA_IF(n) data #define NANORPC_TO_TUPLE_PARAM_N(_, n, data) \ BOOST_PP_COMMA_IF(n) data ## n #define NANORPC_TO_TUPLE_ITEM_N(_, n, __) \ if constexpr (is_braces_constructible_v&lt;type, \ BOOST_PP_REPEAT_FROM_TO(0, BOOST_PP_SUB(NANORPC_TO_TUPLE_LIMIT_FIELDS, n), NANORPC_TO_TUPLE_DUMMY_TYPE_N, dummy_type) \ &gt;) { auto &amp;&amp;[ \ BOOST_PP_REPEAT_FROM_TO(0, BOOST_PP_SUB(NANORPC_TO_TUPLE_LIMIT_FIELDS, n), NANORPC_TO_TUPLE_PARAM_N, f) \ ] = value; return std::make_tuple( \ BOOST_PP_REPEAT_FROM_TO(0, BOOST_PP_SUB(NANORPC_TO_TUPLE_LIMIT_FIELDS, n), NANORPC_TO_TUPLE_PARAM_N, f) \ ); } else #define NANORPC_TO_TUPLE_ITEMS(n) \ BOOST_PP_REPEAT_FROM_TO(0, n, NANORPC_TO_TUPLE_ITEM_N, nil) NANORPC_TO_TUPLE_ITEMS(NANORPC_TO_TUPLE_LIMIT_FIELDS) { return std::make_tuple(); } #undef NANORPC_TO_TUPLE_ITEMS #undef NANORPC_TO_TUPLE_ITEM_N #undef NANORPC_TO_TUPLE_PARAM_N #undef NANORPC_TO_TUPLE_DUMMY_TYPE_N #undef NANORPC_TO_TUPLE_LIMIT_FIELDS }</span></span></span></span></code> </pre></div></div><br>  Si vous avez d√©j√† essay√© de faire quelque chose comme boost.bind pour C ++ 03, o√π vous avez d√ª faire de nombreuses impl√©mentations avec un nombre diff√©rent de param√®tres, alors l'impl√©mentation de to_tuple en utilisant boost.preprocessor ne semble ni √©trange ni compliqu√©e. <br><br>  Et si la prise en charge de tuple est ajout√©e au s√©rialiseur, la fonction to_tuple permettra la s√©rialisation des structures de donn√©es utilisateur.  Et il devient possible de les trahir en tant que param√®tres et de renvoyer des r√©sultats dans votre RPC. <br><br>  En plus des structures de donn√©es d√©finies par l'utilisateur, C ++ a d'autres types int√©gr√©s pour lesquels la sortie vers le flux standard n'est pas impl√©ment√©e.  Le d√©sir de r√©duire le nombre d'op√©rateurs de sortie surcharg√©s dans le flux conduit √† un code g√©n√©ralis√© qui permet √† une m√©thode de traiter la plupart des conteneurs C ++, tels que std :: list, std :: vector, std :: map.  Sans oublier SFINAE et std :: enable_if_t, vous pouvez continuer √† √©tendre le s√©rialiseur.  Dans ce cas, il sera n√©cessaire de d√©terminer indirectement les propri√©t√©s de type d'une mani√®re ou d'une autre, similaire √† ce qui est fait dans l'impl√©mentation de is_braces_constructible_v. <br><br><h1>  Conclusion </h1><br>  Hors de la port√©e de la publication, l'exception de marshaling, le transport, la s√©rialisation des conteneurs stl et bien plus encore.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Afin de ne pas compliquer consid√©rablement la publication, seuls des principes g√©n√©raux ont √©t√© donn√©s sur lesquels j'ai pu cr√©er ma biblioth√®que RPC et r√©soudre moi-m√™me l'ensemble de t√¢ches d'origine - pour essayer de nouvelles fonctionnalit√©s C ++ 14/17. contient des exemples d'utilisation assez d√©taill√©s. </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">Code de</font></a></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> biblioth√®que </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NanoRPC sur GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br>  Merci de votre attention! <br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr421001/">https://habr.com/ru/post/fr421001/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es436938/index.html">Guix es el sistema operativo m√°s avanzado.</a></li>
<li><a href="../fr420993/index.html">5 √©tapes simples pour cr√©er un serveur pour tester les demandes Android REST</a></li>
<li><a href="../fr420995/index.html">Nous s√©lectionnons le mot de passe pour le TIN indien en deux secondes, ou pourquoi les math√©matiques de force brute</a></li>
<li><a href="../fr420997/index.html">KDD 2018, Day Four, Nobel Laureate Performs</a></li>
<li><a href="../fr420999/index.html">Kivy. Xamarin React Native. Trois cadres - une exp√©rience (partie 2)</a></li>
<li><a href="../fr421005/index.html">Assur√© REST: Conseils utiles</a></li>
<li><a href="../fr421007/index.html">Magn√©tophone - un outil pour enregistrer les autotests</a></li>
<li><a href="../fr421009/index.html">25 et 26 ao√ªt: conf√©rence en ligne sur la gestion op√©rationnelle</a></li>
<li><a href="../fr421011/index.html">Questions √† l'entrevue que vous pensez stupides. Mais pas vraiment</a></li>
<li><a href="../fr421015/index.html">Enqu√™te de durabilit√© 2018 des segments Internet nationaux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>