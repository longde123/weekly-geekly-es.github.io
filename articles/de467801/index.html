<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêß üÜö üí† Automatisierung f√ºr die Kleinsten. Teil 1.1. Grundlagen der Virtualisierung üë©üèª‚Äç‚úàÔ∏è ü§∂üèΩ üéì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der vorherige Artikel befasste sich mit der Architektur eines virtualisierten Netzwerks, Underlay-Overlay, dem Paketpfad zwischen VMs und mehr. 
 Roma...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Automatisierung f√ºr die Kleinsten. Teil 1.1. Grundlagen der Virtualisierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467801/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der vorherige Artikel</a> befasste sich mit der Architektur eines virtualisierten Netzwerks, Underlay-Overlay, dem Paketpfad zwischen VMs und mehr. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Roman Gorge lie√ü</a> sich von ihr inspirieren und beschloss, ein Review-Thema zur Virtualisierung im Allgemeinen zu schreiben. <br><br>  In diesem Artikel werden wir uns mit den Fragen befassen (oder versuchen, sie zu ber√ºhren): Wie erfolgt die Virtualisierung von Netzwerkfunktionen tats√§chlich, wie wird das Backend der Hauptprodukte zum Starten und Verwalten von VMs implementiert und wie funktioniert das virtuelle Switching (OVS- und Linux-Bridge)? <br><br>  Das Thema Virtualisierung ist breit und tief, es ist unm√∂glich, alle Details der Arbeit des Hypervisors zu erkl√§ren (und es ist nicht notwendig).  Wir beschr√§nken uns auf das Mindestma√ü an Wissen, das erforderlich ist, um den Betrieb einer virtualisierten L√∂sung zu verstehen, nicht unbedingt auf Telco. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/6a7/8ec/aa6/6a78ecaa6f26c867f0a37f010511ef7a.png" width="800"></a> <br><br><h1>  Inhalt </h1><br><ul><li>  <b>Einf√ºhrung und eine kurze Geschichte der Virtualisierung</b> </li><li>  <b>Arten von virtuellen Ressourcen - Rechnen, Speichern, Netzwerk</b> </li><li>  <b>Virtuelles Schalten</b> </li><li>  <b>Virtualisierungstools - libvirt, virsh und mehr</b> </li><li>  <b>Fazit</b> </li></ul><br><hr><br><br><a name="habracut"></a><br><br><h1>  Einf√ºhrung und eine kurze Geschichte der Virtualisierung </h1><br><br>  Die Geschichte der modernen Virtualisierungstechnologien reicht bis ins Jahr 1999 zur√ºck, als das junge Unternehmen VMware ein Produkt namens VMware Workstation herausbrachte.  Dies war ein Virtualisierungsprodukt f√ºr Desktop- / Client-Anwendungen.  Die serverseitige Virtualisierung erfolgte etwas sp√§ter in Form des ESX Server-Produkts, das sich sp√§ter zu ESXi entwickelte (i bedeutet integriert). Dies ist das gleiche Produkt, das sowohl in der IT als auch in Telco als Hypervisor f√ºr Serveranwendungen universell verwendet wird. <br><br>  Auf der Opensource-Seite haben zwei gro√üe Projekte die Virtualisierung auf Linux gebracht: <br><ul><li>  KVM (Kernel-based Virtual Machine) ist ein Linux-Kernelmodul, mit dem der Kernel als Hypervisor arbeiten kann (erstellt die erforderliche Infrastruktur zum Starten und Verwalten von VMs).  Es wurde 2007 in der Kernel-Version 2.6.20 hinzugef√ºgt. </li><li>  QEMU (Quick Emulator) - emuliert direkt Hardware f√ºr eine virtuelle Maschine (CPU, Festplatte, RAM, alles einschlie√ülich eines USB-Anschlusses) und wird in Verbindung mit KVM verwendet, um eine nahezu "native" Leistung zu erzielen. </li></ul><br><br><blockquote>  Tats√§chlich ist derzeit die gesamte Funktionalit√§t von KVM in QEMU verf√ºgbar, dies ist jedoch nicht wichtig, da die meisten Linux-Virtualisierungsbenutzer KVM / QEMU nicht direkt verwenden, sondern √ºber mindestens eine Abstraktionsebene auf sie zugreifen, aber dazu sp√§ter mehr. <br></blockquote><br><br>  Heute sind VMware ESXi und Linux QEMU / KVM die beiden wichtigsten Hypervisoren, die den Markt dominieren.  Sie sind auch Vertreter von zwei verschiedenen Arten von Hypervisoren: <br><ul><li>  Typ 1 - Der Hypervisor l√§uft direkt auf der Hardware (Bare-Metal).  Dies ist VMware ESXi, Linux KVM, Hyper-V </li><li>  Typ 2 - Der Hypervisor wird im Host-Betriebssystem (Betriebssystem) gestartet.  Dies ist VMware Workstation oder Oracle VirtualBox. </li></ul><br><br>  Eine Diskussion dar√ºber, was besser und was schlechter ist, w√ºrde den Rahmen dieses Artikels sprengen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d74/dfe/fa6/d74dfefa6a9c07a43bca6f4a07db1a3d.gif" width="600"><br><br>  Die Eisenproduzenten mussten ebenfalls ihren Beitrag leisten, um eine akzeptable Leistung sicherzustellen. <br><br>  Das vielleicht wichtigste und am weitesten verbreitete ist Intel VT (Virtualization Technology) - eine Reihe von Erweiterungen, die von Intel f√ºr seine x86-Prozessoren entwickelt wurden und f√ºr den effektiven Betrieb des Hypervisors verwendet werden (und in einigen F√§llen beispielsweise erforderlich sind, funktioniert KVM beispielsweise ohne eingeschaltetes VT nicht -x und ohne es ist der Hypervisor gezwungen, eine reine Softwareemulation ohne Hardwarebeschleunigung durchzuf√ºhren). <br>  Zwei dieser Erweiterungen sind am bekanntesten - VT-x und VT-d.  Der erste ist wichtig f√ºr die Verbesserung der CPU-Leistung w√§hrend der Virtualisierung, da er Hardware-Unterst√ºtzung f√ºr einige seiner Funktionen bietet (mit VT-x 99,9% wird der Code des Gastbetriebssystems direkt auf dem physischen Prozessor ausgef√ºhrt, sodass die Emulation nur in den notwendigsten F√§llen ausgegeben wird), der zweite dient zum direkten Verbinden physischer Ger√§te an eine virtuelle Maschine (f√ºr Forward Virtual Functions (VF) SRIOV muss beispielsweise VT-d <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aktiviert sein</a> ). <br><br>  Das n√§chste wichtige Konzept ist der Unterschied zwischen vollst√§ndiger Virtualisierung und Paravirtualisierung. <br>  Die vollst√§ndige Virtualisierung ist gut. Sie erm√∂glicht die Ausf√ºhrung jedes Betriebssystems auf jedem Prozessor. Sie ist jedoch √§u√üerst ineffizient und f√ºr hoch ausgelastete Systeme absolut nicht geeignet. <br>  Kurz gesagt, Paravirtualisierung ist, wenn das Gastbetriebssystem versteht, dass es in einer virtuellen Umgebung ausgef√ºhrt wird, und mit dem Hypervisor zusammenarbeitet, um eine h√∂here Effizienz zu erzielen.  Das hei√üt, die Gast-Hypervisor-Oberfl√§che wird angezeigt. <br>  Die √ºberwiegende Mehrheit der heute verwendeten Betriebssysteme unterst√ºtzt die Paravirtualisierung - im Linux-Kernel ist dies seit der Kernel-Version 2.6.20 der Fall. <br><br>  Damit eine virtuelle Maschine funktioniert, sind nicht nur ein virtueller Prozessor (vCPU) und ein virtueller Speicher (RAM) erforderlich, sondern auch die Emulation von PCI-Ger√§ten.  Das hei√üt, tats√§chlich ist eine Reihe von Treibern erforderlich, um virtuelle Netzwerkschnittstellen, Festplatten usw. zu verwalten. <br>  Im Linux KVM-Hypervisor wurde diese Aufgabe durch die Implementierung von <b>virtio</b> gel√∂st, einem Framework f√ºr die Entwicklung und Verwendung virtualisierter E / A-Ger√§te. <br>  Virtio ist eine zus√§tzliche Abstraktionsebene, mit der Sie verschiedene E / A-Ger√§te in einem paravirtualisierten Hypervisor emulieren k√∂nnen und eine einheitliche und standardisierte Schnittstelle zur Seite der virtuellen Maschine bereitstellen.  Auf diese Weise k√∂nnen Sie den virtio-Treibercode f√ºr verschiedene inh√§rente Ger√§te wiederverwenden.  Virtio besteht aus: <br><ul><li>  Front-End-Treiber - Was ist in der virtuellen Maschine </li><li>  Backend-Treiber - was ist im Hypervisor </li><li>  Transportfahrer - was verbindet das Backend und das Frontend </li></ul><br>  Diese Modularit√§t erm√∂glicht es Ihnen, die im Hypervisor verwendeten Technologien zu √§ndern, ohne die Treiber in der virtuellen Maschine zu beeinflussen (dieser Moment ist f√ºr Netzwerkbeschleunigungstechnologien und Cloud-L√∂sungen im Allgemeinen sehr wichtig, aber dazu sp√§ter mehr). <br>  Das hei√üt, es besteht eine Gast-Hypervisor-Verbindung, wenn das Gastbetriebssystem ‚Äûwei√ü‚Äú, dass es in einer virtuellen Umgebung ausgef√ºhrt wird. <br><blockquote>  Wenn Sie jemals eine Frage in RFP geschrieben oder eine Frage in RFP beantwortet haben: "Wird virtio in Ihrem Produkt unterst√ºtzt?"  Es ging nur darum, den Front-End-Virtio-Treiber zu unterst√ºtzen. <br></blockquote><br><br><h1>  Arten von virtuellen Ressourcen - Rechnen, Speichern, Netzwerk </h1><br>  Woraus besteht eine virtuelle Maschine? <br>  Es gibt drei Haupttypen von virtuellen Ressourcen: <br><br><ul><li>  Rechenprozessor und RAM </li><li>  Speicher - Systemfestplatte und Blockspeicher der virtuellen Maschine </li><li>  Netzwerk - Netzwerkkarten und Ein- / Ausgabeger√§te </li></ul><br><br><hr><br><br><h1>  Berechnen </h1><br><br><h2>  CPU </h2><br>  Theoretisch ist QEMU in der Lage, jeden Prozessortyp und die entsprechenden Flags und Funktionen zu emulieren. In der Praxis verwenden sie entweder das Host-Modell und deaktivieren die Flags punktweise, bevor sie an das Gastbetriebssystem √ºbertragen werden, oder sie nehmen das benannte Modell und aktivieren und deaktivieren die Flags punktweise. <br><br>  Standardm√§√üig emuliert QEMU einen Prozessor, den das Gastbetriebssystem als virtuelle QEMU-CPU erkennt.  Dies ist nicht der optimalste Prozessortyp, insbesondere wenn eine Anwendung, die in einer virtuellen Maschine ausgef√ºhrt wird, CPU-Flags f√ºr ihre Arbeit verwendet.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erfahren Sie mehr √ºber die verschiedenen CPU-Modelle in QEMU</a> . <br><br>  Mit QEMU / KVM k√∂nnen Sie auch die Prozessortopologie, die Anzahl der Threads, die Cache-Gr√∂√üe, die Bindung von vCPU an den physischen Kern und vieles mehr steuern. <br><br>  Ob dies f√ºr eine virtuelle Maschine erforderlich ist oder nicht, h√§ngt von der Art der Anwendung ab, die unter dem Gastbetriebssystem ausgef√ºhrt wird.  Es ist beispielsweise bekannt, dass es f√ºr Anwendungen, die Pakete mit hohem PPS verarbeiten, wichtig ist, <b>CPU-Pinning durchzuf√ºhren</b> , <b>dh</b> nicht zuzulassen, dass der physische Prozessor auf andere virtuelle Maschinen √ºbertragen wird. <br><br><h2>  Speicher </h2><br>  Als n√§chstes kommt RAM.  Aus Sicht des Host-Betriebssystems unterscheidet sich eine mit QEMU / KVM gestartete virtuelle Maschine nicht von anderen Prozessen, die im Benutzerbereich des Betriebssystems ausgef√ºhrt werden.  Dementsprechend wird der Prozess zum Zuweisen von Speicher zu einer virtuellen Maschine durch dieselben Aufrufe im Kernel-Host-Betriebssystem ausgef√ºhrt, als ob Sie beispielsweise einen Chrome-Browser gestartet h√§tten. <br><br><blockquote>  Bevor Sie die Geschichte des Arbeitsspeichers in virtuellen Maschinen fortsetzen, m√ºssen Sie den Begriff <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NUMA</a></b> - Non-Uniform Memory Access abschweifen und erl√§utern. <br>  Die Architektur moderner physischer Server umfasst das Vorhandensein von zwei oder mehr Prozessoren (CPU) und den damit verbundenen Direktzugriffsspeicher (RAM).  Ein solcher B√ºndel von Prozessor + Speicher wird als Knoten oder Knoten bezeichnet.  Die Kommunikation zwischen verschiedenen NUMA-Knoten erfolgt √ºber einen speziellen Bus - <b>QPI</b> (QuickPath Interconnect). <br><br>  Der lokale NUMA-Knoten wird zugewiesen - wenn der im Betriebssystem ausgef√ºhrte Prozess den Prozessor und den RAM verwendet, die sich im selben NUMA-Knoten befinden, und der entfernte NUMA-Knoten - wenn der im Betriebssystem ausgef√ºhrte Prozess den Prozessor und den RAM verwendet, die sich in verschiedenen NUMA-Knoten befinden. Das hei√üt, f√ºr das Zusammenspiel von Prozessor und Speicher ist eine Daten√ºbertragung √ºber den QPI-Bus erforderlich. <br></blockquote><br><br><img src="https://habrastorage.org/getpro/habr/post_images/ea3/360/7e9/ea33607e91282db8bda346d7f63cf9fd.png" width="600"><br><br>  Aus Sicht der virtuellen Maschine wurde ihr bereits zum Zeitpunkt des Starts Speicher zugewiesen, in Wirklichkeit ist dies jedoch nicht der Fall, und das Kernel-Host-Betriebssystem weist dem QEMU / KVM-Prozess neue Speicherabschnitte zu, da die Anwendung im Gastbetriebssystem zus√§tzlichen Speicher anfordert (obwohl dies m√∂glicherweise auch der Fall ist) eine Ausnahme, wenn Sie QEMU / KVM direkt angeben, um den gesamten Speicher direkt beim Start der virtuellen Maschine zuzuweisen). <br><br>  Der Speicher wird nicht byteweise zugewiesen, sondern durch eine bestimmte <b>Seitengr√∂√üe</b> .  Die Seitengr√∂√üe ist konfigurierbar und kann theoretisch beliebig sein. In der Praxis betr√§gt die Gr√∂√üe jedoch 4 KB (Standard), 2 MB und 1 GB.  Die letzten beiden Gr√∂√üen werden als <b>HugePages bezeichnet</b> und h√§ufig zum <b>Zuweisen von</b> Speicher f√ºr speicherintensive virtuelle Maschinen verwendet.  Der Grund f√ºr die Verwendung von HugePages bei der Suche nach einer √úbereinstimmung zwischen der virtuellen Seitenadresse und dem physischen Speicher im <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TLB</a></b> ( <b>Translation Lookaside Buffer</b> ), der wiederum begrenzt ist und nur Informationen zu den zuletzt verwendeten Seiten speichert.  Wenn keine Informationen √ºber die gew√ºnschte Seite im TLB vorhanden sind, tritt ein Prozess namens <b>Miss TLB</b> auf, und Sie m√ºssen den Host-Betriebssystemprozessor verwenden, um die physische Speicherzelle zu finden, die der gew√ºnschten Seite entspricht. <br><br>  Dieser Prozess ist ineffizient und langsam, sodass weniger gr√∂√üere Seiten verwendet werden. <br>  Mit QEMU / KVM k√∂nnen Sie auch verschiedene NUMA-Topologien f√ºr das Gastbetriebssystem emulieren, Speicher f√ºr eine virtuelle Maschine nur von einem bestimmten NUMA-Knoten-Host-Betriebssystem abrufen und so weiter.  Am h√§ufigsten wird Speicher f√ºr eine virtuelle Maschine von einem lokalen NUMA-Knoten f√ºr die der virtuellen Maschine zugewiesenen Prozessoren verwendet.  Der Grund ist der Wunsch, eine unn√∂tige Belastung des <b>QPI-</b> Busses zu vermeiden, der die CPU-Sockel des physischen Servers verbindet (dies ist nat√ºrlich logisch, wenn Ihr Server √ºber zwei oder mehr Sockel verf√ºgt). <br><br><hr><br><br><h1>  Lagerung </h1><br>  Wie Sie wissen, wird RAM als Betriebsspeicher bezeichnet, da sein Inhalt beim Ausschalten oder Neustarten des Betriebssystems verschwindet.  Zum Speichern von Informationen ben√∂tigen Sie ein persistentes Speicherger√§t (ROM) oder einen <b>persistenten Speicher</b> . <br>  Es gibt zwei Haupttypen von persistentem Speicher: <br><ul><li>  Blockspeicher - Ein Block Speicherplatz, mit dem das Dateisystem installiert und Partitionen erstellt werden k√∂nnen.  Wenn es unh√∂flich ist, k√∂nnen Sie es als normale Festplatte verwenden. </li><li>  Objektspeicherung - Informationen k√∂nnen nur als Objekt (Datei) gespeichert werden, auf das √ºber HTTP / HTTPS zugegriffen werden kann.  Typische Beispiele f√ºr die Objektspeicherung sind AWS S3 oder Dropbox. </li></ul><br><br>  Die virtuelle Maschine ben√∂tigt <b>dauerhaften Speicher</b> . Wie geht das, wenn die virtuelle Maschine im RAM des Host-Betriebssystems "lebt"?  Kurz gesagt, jeder Gastbetriebssystemaufruf an den Controller der virtuellen Festplatte wird von QEMU / KVM abgefangen und in einen Datensatz auf der physischen Festplatte des Hostbetriebssystems umgewandelt.  Diese Methode ist ineffizient, und daher wird hier wie auch f√ºr Netzwerkger√§te der virtio-Treiber verwendet, anstatt ein IDE- oder iSCSI-Ger√§t vollst√§ndig zu emulieren.  Lesen Sie hier mehr dar√ºber.  Somit greift die virtuelle Maschine √ºber einen virtio-Treiber auf ihre virtuelle Festplatte zu, und dann schreibt QEMU / KVM die √ºbertragenen Informationen auf die physische Festplatte.  Es ist wichtig zu verstehen, dass in Host OS ein Festplatten-Backend als CEPH-, NFS- oder iSCSI-Shelf implementiert werden kann. <br><br>  Der einfachste Weg, persistenten Speicher zu emulieren, besteht darin, die Datei in einem Verzeichnis des Host-Betriebssystems als Speicherplatz einer virtuellen Maschine zu verwenden.  QEMU / KVM unterst√ºtzt viele verschiedene Formate dieser Art von Dateien - raw, vdi, vmdk und andere.  Das am h√§ufigsten verwendete Format ist jedoch <b>qcow2</b> (QEMU Copy-on-Write-Version 2).  Im Allgemeinen ist qcow2 in gewisser Weise eine strukturierte Datei ohne Betriebssystem.  Eine gro√üe Anzahl virtueller Maschinen wird in Form von qcow2-Images (Images) verteilt und ist eine Kopie der Systemfestplatte einer virtuellen Maschine, die im qcow2-Format gepackt ist.  Dies hat mehrere Vorteile: Die qcow2-Codierung ben√∂tigt viel weniger Speicherplatz als eine Rohkopie einer Byte-zu-Byte-Festplatte. QEMU / KVM kann die Gr√∂√üe einer qcow2-Datei √§ndern. Dies bedeutet, dass die Gr√∂√üe der Festplatte einer virtuellen Maschine ge√§ndert werden kann. Die AES-qcow2-Verschl√ºsselung wird ebenfalls unterst√ºtzt (Dies ist sinnvoll, da das Image einer virtuellen Maschine geistiges Eigentum enthalten kann.) <br><br>  Wenn die virtuelle Maschine gestartet wird, verwendet QEMU / KVM die qcow2-Datei als Systemfestplatte (ich lasse das Laden der virtuellen Maschine hier weg, obwohl dies auch eine interessante Aufgabe ist), und die virtuelle Maschine kann Daten √ºber virtio in die qcow2-Datei lesen / schreiben Fahrer.  Somit funktioniert das Aufnehmen von Images von virtuellen Maschinen, da die qcow2-Datei jederzeit eine vollst√§ndige Kopie der Systemfestplatte der virtuellen Maschine enth√§lt und das Image zum Sichern, √úbertragen auf einen anderen Host usw. verwendet werden kann. <br><br>  Im Allgemeinen wird diese qcow2-Datei im Gastbetriebssystem als <i>/ dev / vda-Ger√§t definiert</i> , und das Gastbetriebssystem partitioniert den Speicherplatz in Partitionen und installiert das Dateisystem.  In √§hnlicher Weise k√∂nnen die folgenden qcow2-Dateien, die √ºber QEMU / KVM als <i>/ dev / vdX-</i> Ger√§te verbunden sind, als <b>Blockspeicher</b> in einer virtuellen Maschine zum Speichern von Informationen verwendet werden (genau so funktioniert die Openstack Cinder-Komponente). <br><hr><br><br><h1>  Netzwerk </h1><br>  Als letztes auf unserer Liste der virtuellen Ressourcen stehen Netzwerkkarten und E / A-Ger√§te.  Eine virtuelle Maschine ben√∂tigt wie ein physischer Host einen <b>PCI / PCIe-Bus</b> , um E / A-Ger√§te anzuschlie√üen.  QEMU / KVM kann verschiedene Arten von Chips√§tzen emulieren - q35 oder i440fx (der erste unterst√ºtzt PCIe, der zweite unterst√ºtzt √§ltere PCI) sowie verschiedene PCI-Topologien erstellen beispielsweise separate PCI-Busse (PCI-Expander-Bus) f√ºr NUMA-Knoten. Gastbetriebssystem. <br><br>  Nach dem Erstellen des PCI / PCIe-Busses m√ºssen Sie ein E / A-Ger√§t daran anschlie√üen.  Im Allgemeinen kann es sich um eine Netzwerkkarte oder eine physische GPU handeln.  Und nat√ºrlich eine Netzwerkkarte, die sowohl vollst√§ndig virtualisiert (z. B. vollst√§ndig virtualisierte e1000-Schnittstelle) als auch paravirtualisiert (z. B. virtio) oder eine physische Netzwerkkarte ist.  Die letzte Option wird f√ºr virtuelle Maschinen auf Datenebene verwendet, bei denen Sie Paketraten mit Leitungsrate abrufen m√ºssen - Router, Firewalls usw. <br><br>  Hier gibt es zwei Hauptans√§tze: <b>PCI-Passthrough</b> und <b>SR-IOV</b> .  Der Hauptunterschied zwischen ihnen besteht darin, dass f√ºr PCI-PT der Treiber nur innerhalb des Gastbetriebssystems verwendet wird und f√ºr SRIOV der Treiber f√ºr das Host-Betriebssystem (zum Erstellen von <b>VF - Virtuelle Funktionen</b> ) und der Treiber f√ºr das Gastbetriebssystem zur Steuerung von SR-IOV VF verwendet werden.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Juniper hat</a> hervorragende Details zu PCI-PT und SRIOV geschrieben. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ff1/380/fb7/ff1380fb7061d5294514b79b4a368cfb.png" width="600"><br><br><blockquote>  Zur Verdeutlichung ist anzumerken, dass PCI-Passthrough und SR-IOV komplement√§re Technologien sind.  SR-IOV zerlegt eine physische Funktion in virtuelle Funktionen.  Dies erfolgt auf der Ebene des Host-Betriebssystems.  Gleichzeitig sieht das Host-Betriebssystem virtuelle Funktionen als ein anderes PCI / PCIe-Ger√§t.  Was er als n√§chstes mit ihnen macht, ist nicht wichtig. <br><br>  Und PCI-PT ist ein Mechanismus zum Weiterleiten eines beliebigen Host-Betriebssystem-PCI-Ger√§ts im Gastbetriebssystem, einschlie√ülich der vom SR-IOV-Ger√§t erstellten virtuellen Funktion <br></blockquote><br><br>  Daher haben wir die Haupttypen virtueller Ressourcen untersucht. Der n√§chste Schritt besteht darin, zu verstehen, wie die virtuelle Maschine √ºber ein Netzwerk mit der Au√üenwelt kommuniziert. <br><hr><br><br><h1>  Virtuelles Schalten </h1><br><br>  Wenn es eine virtuelle Maschine und eine virtuelle Schnittstelle gibt, tritt offensichtlich das Problem auf, ein Paket von einer VM auf eine andere zu √ºbertragen.  In Linux-basierten Hypervisoren (z. B. KVM) kann dieses Problem mithilfe der Linux-Br√ºcke gel√∂st werden. Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Open vSwitch</a> (OVS) -Projekt hat jedoch breite Akzeptanz gefunden. <br>  Es gibt mehrere Kernfunktionen, die es OVS erm√∂glicht haben, sich weit zu verbreiten und die de facto prim√§re Paketvermittlungsmethode zu werden, die in vielen Cloud-Computing-Plattformen (wie Openstack) und virtualisierten L√∂sungen verwendet wird. <br><ul><li>  Netzwerkstatus√ºbertragung - Bei der Migration einer VM zwischen Hypervisoren besteht die Aufgabe darin, ACLs, QoSs, L2 / L3-Weiterleitungstabellen und mehr zu √ºbertragen.  Und OVS kann es schaffen. </li><li>  Implementierung des Paket√ºbertragungsmechanismus (Datenpfad) sowohl im Kernel als auch im Benutzerbereich </li><li>  CUPS-Architektur (Control / User-Plane Separation) - Erm√∂glicht die √úbertragung der Funktionalit√§t der Paketverarbeitung auf einen speziellen Chipsatz (Broadcom- und Marvell-Chipsatz k√∂nnen dies beispielsweise tun) und steuert diese √ºber die OVS der Steuerebene. </li><li>  Unterst√ºtzung f√ºr Remote-Verkehrssteuerungsmethoden - OpenFlow-Protokoll (hi, SDN). </li></ul><br><br>  Die OVS-Architektur sieht auf den ersten Blick ziemlich be√§ngstigend aus, ist aber nur auf den ersten Blick. <br><img src="https://habrastorage.org/getpro/habr/post_images/e1e/18f/4fa/e1e18f4fa99d66a99a4da3c06e1df33a.png" width="600"><br><br>  Um mit OVS arbeiten zu k√∂nnen, m√ºssen Sie Folgendes verstehen: <br><ul><li>  <b>Datenpfad</b> - Pakete werden hier verarbeitet.  Die Analogie ist die Schalterstruktur eines Eisenschalters.  Datapath umfasst das Empfangen von Paketen, das Verarbeiten von Headern und das √úbereinstimmen von √úbereinstimmungen in der Flusstabelle, die bereits in Datapath programmiert ist.  Wenn OVS im Kernel ausgef√ºhrt wird, wird es als Kernelmodul implementiert.  Wenn OVS im User-Space ausgef√ºhrt wird, ist dies ein Prozess im User-Space-Linux. </li><li>  <b>vswitchd</b> und <b>ovsdb</b> sind D√§monen im User-Space, die die Funktionalit√§t des Switches direkt implementieren, die Konfiguration speichern, den Flow auf den Datenpfad setzen und ihn programmieren. </li><li>  Eine Reihe von Tools zur Konfiguration und Fehlerbehebung von OVS - <b>ovs-vsctl, ovs-dpctl, ovs-ofctl, ovs-appctl</b> .  Alles, was ben√∂tigt wird, um die Portkonfiguration in ovsdb zu registrieren, zu registrieren, auf welchen Fluss umgeschaltet werden soll, Statistiken zu sammeln und so weiter.  Gute Leute <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">haben einen Artikel</a> dar√ºber geschrieben. </li></ul><br><br>  <b>Wie landet das Netzwerkger√§t einer virtuellen Maschine in OVS?</b> <br><br>  Um dieses Problem zu l√∂sen, m√ºssen wir die im Benutzerbereich des Betriebssystems befindliche virtuelle Schnittstelle irgendwie mit dem im Kernel befindlichen Datenpfad-OVS verbinden. <br><br>  Im Linux-Betriebssystem werden Pakete zwischen dem Kernel und den User-Space-Prozessen √ºber zwei spezielle Schnittstellen √ºbertragen.    /  /       user-space-  kernel   ‚Äî file descriptor (FD) (       ,  datapath OVS   kernel ‚Äî    /  FD) <br><br><ul><li> <b>TUN</b> (tunnel) ‚Äî ,   L3    /  IP  / FD. </li><li> <b>TAP</b> (network tap) ‚Äî   ,   tun  +     Ethernet-, ..    L2. </li></ul><br><br><img src="https://habrastorage.org/getpro/habr/post_images/5a2/3fc/fc8/5a23fcfc86e0c6cbfdf8dc80cc562bbf.png" width="800"><br><br>        Host OS    TAP-  <i>ip link</i>  <i>ifconfig</i> ‚Äî  ¬´¬ª  virtio,  ¬´¬ª  kernel Host OS.    ,  TAP-    MAC-   virtio-   . <br><br> TAP-     OVS    <i>ovs-vsctl</i> ‚Äî   ,  OVS  TAP-,       file descriptor. <br><br><blockquote>          , ..    OVS bridge,      ,    OVS,    . <br></blockquote><br><br> ,             ,     ,     OVS bridge     TAP-    ovs-vsctl.        . <br><br>      OVS bridges, ,   Openstack Neutron,         namespace   multi-tenancy. <br><br> <b>       OVS bridges?</b> <br><br>        ‚Äî <b>veth pair</b> . Veth pair       ,   ‚Äî  ,  ¬´¬ª   , ¬´¬ª  . Veth pair       OVS bridges  Linux bridges.      veth pair     namespace Linux OS,   veth pair       namespace     . <br><br><h1>   ‚Äî libvirt, virsh   </h1><br><br>        ,       ,            KVM-. <br>     ,   90      : <br><br><ul><li> libvirt </li><li> virsh CLI </li><li> virt-install </li></ul><br><br><blockquote> ,      CLI-,    , ,     qemu_system_x86_64    virt manager,    .      Cloud-, Openstack, ,    libvirt. <br></blockquote><br><br><h2> libvirt </h2><br> libvirt ‚Äî   open-source ,          .     QEMU/KVM,   ESXi, LXC    . <br>     ‚Äî        XML-     API.    libvirt      ,       <b></b> ,     ,  . <br><br>  , libvirt  -     .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   </a> ,   libvirt. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b6f/115/f2f/b6f115f2f06f3fe06ee4727ec121c865.png" width="700"><br><br>    libvirt ‚Äî           Host OS ‚Äî Ubuntu, CentOS  RHEL, ,  ,       libvirt   .         (apt, yum   ). <br><br>      libvirt    Linux bridge virbr0    . <br><br><blockquote>     Ubuntu Server, ,      ifconfig Linux bridge virbr0 ‚Äî     libvirtd <br></blockquote><br><br>  Linux bridge        , ,          . Libvirt       OVS, ,       OVS bridges    OVS-. <br><br>   ,      (compute, network, storage)      libvirt.           XML-. <br><br>             ,          libvirt: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vernetzung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lagerung</a> </li></ul><br><br>       PCI-   libvirt  domain.   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  libvirt</a> ,    XML-. <br><br>  XML-  ,  ,       ‚Äî  , ,  ,   .   XML-  libvirt XML  dump XML. <br>    ,     libvirt XML, ,    ,   . <br><br>   , libvirt XML  Ubuntu Desktop Guest OS    ‚Äî 40-50 .        libvirt XML (NUMA-, CPU-, CPU pinning  ),    libvirt XML         .    ,        ,    libvirt XML. <br><br><h2> virsh CLI </h2><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Dienstprogramm virsh ist eine "native" Befehlszeile zum Verwalten von libvirt. </font><font style="vertical-align: inherit;">Der Hauptzweck besteht darin, libvirt-Objekte zu verwalten, die als XML-Dateien bezeichnet werden. </font><font style="vertical-align: inherit;">Typische Beispiele sind Starten, Stoppen, Definieren, Zerst√∂ren usw. </font><font style="vertical-align: inherit;">Das hei√üt, der Lebenszyklus von Objekten - Lebenszyklusmanagement. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Beschreibung aller virsh-Befehle und -Flaggen finden Sie auch in der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libvirt-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dokumentation </font><font style="vertical-align: inherit;">.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> virt-install </font></font></h2><br><br>   ,      libvirt.     ‚Äî     XML-,    ,   virsh-install.    ‚Äî      . <br><br>        ,        libvirt,        . <br><hr><br><br><h1>  Fazit </h1><br><br>         ,       .         ,         ,         ¬´step-by-step guide¬ª.    -    ,      . <br><hr><br><br><h1>  N√ºtzliche Links </h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Understanding QEMU Devices</a> . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">KVM/SR-IOV</a> . </li></ul><br><hr><br><br><h1>  </h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> ‚Äî         .    . </li><li>   ‚Äî           . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467801/">https://habr.com/ru/post/de467801/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467789/index.html">Java 13 ist gerade eingetroffen. ZGC hat begonnen, Speicher gemeinsam zu nutzen, CDS selbst erinnert sich an Klassen und andere technische Wunder</a></li>
<li><a href="../de467791/index.html">Analyse des Bildlaufs in Google Data Studio</a></li>
<li><a href="../de467793/index.html">Langweiliger Technologie-Stack eines Ein-Mann-Internetunternehmens</a></li>
<li><a href="../de467795/index.html">Hinweis zu Kryptow√§hrungen und staatlicher Regulierung</a></li>
<li><a href="../de467797/index.html">"Um der Sache willen lachen": Warum ben√∂tigen Sie m√∂glicherweise Software-Tools, die keine "Kampf" -Anwendung haben?</a></li>
<li><a href="../de467803/index.html">Elementare Simulation der benutzerdefinierten physischen Interaktion in Python + Matplotlib</a></li>
<li><a href="../de467807/index.html">Kauf und Verkauf von Kryptow√§hrungen in Russland: Methoden, Legalisierung, Risiken</a></li>
<li><a href="../de467811/index.html">Architektur und Programmierung Fairchild Channel F.</a></li>
<li><a href="../de467813/index.html">√úberpr√ºfung der √Ñnderungen in der 17. Ordnung der FSTEC</a></li>
<li><a href="../de467815/index.html">Die Medien l√∂sten eine Panik aus, dass "IP-Adressen in Russland ausgehen". Wie wirklich?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>