<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕳️ ℹ️ ⏭️ Analisis statis kode PHP menggunakan PHPStan, Phan dan Mazmur sebagai contoh 🤮 👩🏻‍🌾 👨🏿‍⚖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Badoo telah ada selama lebih dari 12 tahun. Kami memiliki banyak kode PHP (jutaan baris) dan bahkan mungkin baris yang ditulis 12 tahun yang lalu dipe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analisis statis kode PHP menggunakan PHPStan, Phan dan Mazmur sebagai contoh</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/426605/"><img src="https://habrastorage.org/webt/yj/nq/4_/yjnq4_9tdzj0noyiimybxjpoctk.jpeg"><br><br>  Badoo telah ada selama lebih dari 12 tahun.  Kami memiliki banyak kode PHP (jutaan baris) dan bahkan mungkin baris yang ditulis 12 tahun yang lalu dipertahankan.  Kami memiliki kode yang ditulis kembali pada hari-hari PHP 4 dan PHP 5. Kami memposting kode dua kali sehari, dan setiap tata letak berisi sekitar 10-20 tugas.  Selain itu, programmer dapat memposting tambalan mendesak - perubahan kecil.  Dan pada hari tambalan seperti itu, kita mendapatkan beberapa lusin.  Secara umum, kode kami berubah sangat aktif. <br><br>  Kami terus mencari peluang untuk mempercepat pengembangan, dan meningkatkan kualitas kode.  Jadi suatu hari kami memutuskan untuk menerapkan analisis kode statis.  Apa yang terjadi, baca di bawah potongan. <br><a name="habracut"></a><br><h1>  Jenis yang ketat: mengapa kita belum menggunakannya </h1><br>  Suatu kali, diskusi dimulai di obrolan PHP perusahaan kami.  Salah satu karyawan baru memberi tahu bagaimana di tempat kerja sebelumnya mereka memperkenalkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">petunjuk jenis</a> skalar strict_types + wajib untuk seluruh kode - dan ini secara signifikan mengurangi jumlah bug pada produksi. <br><br>  Kebanyakan obrolan orang tua menentang inovasi semacam itu.  Alasan utama adalah bahwa PHP tidak memiliki kompiler yang memeriksa semua jenis dalam kode pada waktu kompilasi, dan jika Anda tidak memiliki cakupan 100% dari kode dengan tes, maka selalu ada risiko bahwa kesalahan akan muncul pada produksi, yang kami tidak lakukan ingin mengizinkan. <br><br>  Tentu saja, strict_types akan menemukan persentase bug tertentu yang disebabkan oleh ketidakcocokan jenis dan bagaimana PHP "diam-diam" mengonversi jenis.  Tetapi banyak programmer PHP yang berpengalaman sudah tahu bagaimana sistem tipe dalam PHP bekerja, dengan apa jenis konversi aturan terjadi, dan dalam kebanyakan kasus mereka menulis kode kerja yang benar. <br><br>  Tetapi gagasan memiliki sistem tertentu yang menunjukkan di mana dalam kode ada jenis ketidakcocokan, kami suka.  Kami memikirkan alternatif untuk strict_types. <br><br>  Awalnya kami bahkan ingin menambal PHP.  Kami ingin bahwa jika fungsi mengambil beberapa jenis skalar (katakanlah int), dan tipe skalar lain (seperti float) masuk, maka TypeError (yang merupakan pengecualian dalam dirinya sendiri) tidak akan dibuang, tetapi konversi jenis akan terjadi, serta mencatat acara ini di error.log.  Ini akan memungkinkan kami untuk menemukan semua tempat di mana asumsi kami tentang jenis tidak benar.  Tapi tambalan seperti itu tampaknya berisiko bagi kami, dan bahkan mungkin ada masalah dengan ketergantungan eksternal, tidak siap untuk perilaku seperti itu. <br><br>  Kami meninggalkan ide menambal PHP, tetapi seiring waktu semuanya bertepatan dengan rilis pertama dari penganalisis statis Phan, komitmen pertama yang dibuat oleh Rasmus Lerdorf sendiri.  Jadi kami datang dengan ide mencoba penganalisa kode statis. <br><br><h1>  Apa itu analisis kode statis? </h1><br>  Penganalisa kode statis hanya membaca kode dan mencoba untuk menemukan kesalahan di dalamnya.  Mereka dapat melakukan pemeriksaan yang sangat sederhana dan jelas (misalnya, untuk keberadaan kelas, metode dan fungsi, dan yang lebih rumit (misalnya, mencari ketidakcocokan jenis, kondisi ras atau kerentanan dalam kode). Kuncinya adalah bahwa penganalisa tidak mengeksekusi kode - mereka menganalisis teks program dan memeriksa kesalahan khas (dan tidak demikian). <br><br>  Contoh paling jelas dari penganalisa kode PHP statis adalah inspeksi di PHPStorm: ketika Anda menulis kode, ini menyoroti panggilan yang salah ke fungsi, metode, ketidakcocokan jenis parameter, dll. Namun, PHPStorm tidak menjalankan kode PHP Anda - hanya menganalisisnya. <br><br>  Saya perhatikan bahwa dalam artikel ini kita berbicara tentang penganalisa yang mencari kesalahan dalam kode.  Ada kelas analisis lain - mereka memeriksa gaya penulisan kode, kompleksitas siklomatik, ukuran metode, panjang garis, dll. Kami tidak mempertimbangkan analisis tersebut di sini. <br><br>  Meskipun tidak semua yang ditemukan oleh analis yang kami temukan ternyata adalah kesalahan.  Secara tidak sengaja, maksud saya kode yang akan dibuat Fatal pada produksi.  Sangat sering, apa yang ditemukan oleh para analis lebih cenderung tidak akurat.  Misalnya, tipe parameter yang salah dapat ditentukan dalam PHPDoc.  Ketidaktepatan ini tidak mempengaruhi operasi kode, tetapi kemudian kode akan berkembang - programmer lain dapat membuat kesalahan. <br><br><h1>  Analisis Kode PHP yang ada </h1><br>  Ada tiga penganalisa kode PHP populer: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PHPStan</a> . <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mazmur</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Phan</a> . <br></li></ol><br>  Dan ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Exakat</a> , yang belum kita coba. <br><br>  Di sisi pengguna, ketiga analisis itu sama: Anda menginstalnya (kemungkinan besar melalui Komposer), mengonfigurasinya, setelah itu Anda dapat memulai analisis seluruh proyek atau grup file.  Sebagai aturan, alat analisa dapat dengan indah menampilkan hasil di konsol.  Anda juga dapat menampilkan hasilnya dalam format JSON dan menggunakannya dalam CI. <br><br>  Ketiga proyek tersebut sekarang sedang aktif dikembangkan.  Pemelihara mereka sangat aktif dalam menanggapi masalah di GitHub.  Seringkali pada hari pertama setelah membuat tiket mereka bereaksi setidaknya (komentar atau beri tag seperti bug / peningkatan).  Banyak bug yang kami temukan diperbaiki dalam beberapa hari.  Tapi saya terutama menyukai kenyataan bahwa pengelola proyek secara aktif berkomunikasi satu sama lain, melaporkan bug satu sama lain, dan mengirim permintaan tarikan. <br><br>  Kami telah menerapkan dan menggunakan ketiga analisanya.  Masing-masing memiliki nuansa sendiri, bug sendiri.  Tetapi menggunakan tiga analisis pada saat yang sama memfasilitasi pemahaman tentang di mana masalah sebenarnya dan di mana positif palsu. <br><br><h2>  Apa yang bisa dilakukan analis </h2><br>  Analisis memiliki banyak fitur umum, jadi pertama-tama kita akan melihat apa yang dapat mereka semua lakukan, dan kemudian beralih ke fitur masing-masing. <br><br><h3>  Pemeriksaan Standar </h3><br>  Tentu saja, analis melakukan semua pemeriksaan kode standar untuk fakta bahwa: <br><br><ul><li>  Kode tidak mengandung kesalahan sintaksis; <br></li><li>  semua kelas, metode, fungsi, konstanta ada; <br></li><li>  variabel ada; <br></li><li>  di PHPDoc, petunjuknya benar. <br></li></ul><br>  Selain itu, parser memeriksa kode untuk argumen dan variabel yang tidak digunakan.  Banyak dari kesalahan-kesalahan ini mengarah ke fatamorgana nyata dalam kode. <br><br>  Pada pandangan pertama, sepertinya programmer yang baik tidak membuat kesalahan seperti itu, tetapi kadang-kadang kita sedang terburu-buru, kadang-kadang copy-paste, kadang-kadang kita hanya lalai.  Dan dalam kasus seperti itu, cek ini menghemat banyak. <br><br><h3>  Pemeriksaan Tipe Data </h3><br>  Tentu saja, analisa statis juga melakukan pemeriksaan standar mengenai tipe data.  Jika ditulis dalam kode yang menerima fungsi, katakanlah, int, maka penganalisa akan memeriksa apakah ada tempat di mana objek dilewatkan ke fungsi ini.  Untuk sebagian besar analisis, Anda dapat mengonfigurasi tingkat keparahan tes dan mensimulasikan strict_types: verifikasi bahwa tidak ada string atau Boolean yang diteruskan ke fungsi ini. <br><br>  Selain pemeriksaan standar, analis masih harus melakukan banyak hal. <br><br>  <b>Jenis serikat</b> <br><br>  Semua analis mendukung konsep tipe Union.  Misalkan Anda memiliki fungsi seperti: <br><br><pre><code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> string|int|bool $yes_or_no */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isYes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($yes_or_no)</span></span></span><span class="hljs-function"> :</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (\is_bool($yes_or_no)) {         <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $yes_or_no;     } <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> (is_numeric($yes_or_no)) {         <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $yes_or_no &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>;     } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {         <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> strtoupper($yes_or_no) == <span class="hljs-string"><span class="hljs-string">'YES'</span></span>;     } }</code> </pre> <br>  Isinya tidak terlalu penting - jenis <code>string|int|bool</code> parameter input <code>string|int|bool</code> penting.  Yaitu, variabel <code>$yes_or_no</code> adalah string, atau integer, atau <code>Boolean</code> . <br><br>  Menggunakan PHP, jenis parameter fungsi ini tidak dapat dijelaskan.  Tetapi dalam PHPDoc, ini mungkin, dan banyak editor (seperti PHPStorm) memahaminya. <br><br>  Dalam analisis statis, tipe ini disebut <b>tipe union</b> , dan mereka sangat baik dalam memeriksa tipe data tersebut.  Misalnya, jika kita menulis fungsi di atas seperti ini (tanpa memeriksa <code>Boolean</code> ): <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> string|int|bool $yes_or_no */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isYes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($yes_or_no)</span></span></span><span class="hljs-function"> :</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_numeric($yes_or_no)) {        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $yes_or_no &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>;    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> strtoupper($yes_or_no) == <span class="hljs-string"><span class="hljs-string">'YES'</span></span>;    } }</code> </pre> <br>  analisanya akan melihat bahwa string atau Boolean bisa datang ke strtoupper, dan mengembalikan kesalahan - Anda tidak bisa meneruskan Boolean ke strtoupper. <br><br>  Jenis pemeriksaan ini membantu programmer menangani kesalahan atau situasi dengan benar ketika suatu fungsi tidak dapat mengembalikan data.  Kami sering menulis fungsi yang dapat mengembalikan beberapa data atau <code>null</code> : <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// load()  null   \User $User = UserLoader::load($user_id); $User-&gt;getName();</span></span></code> </pre> <br>  Dalam kasus kode semacam itu, penganalisa akan memberi tahu Anda bahwa variabel <code>$User</code> sini bisa <code>null</code> dan kode ini bisa berakibat fatal. <br><br>  <b>Ketik salah</b> <br><br>  Dalam bahasa PHP itu sendiri, ada beberapa fungsi yang dapat mengembalikan nilai atau salah.  Jika kita menulis fungsi seperti itu, bagaimana kita mendokumentasikan jenisnya? <br><br><pre> <code class="php hljs">         <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> resource|bool */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fopen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function"> </span></span>{       … }</code> </pre> <br>  Secara formal, semuanya tampaknya benar di sini: fopen mengembalikan sumber daya atau <code>false</code> (yang merupakan tipe <code>Boolean</code> ).  Tetapi ketika kita mengatakan bahwa suatu fungsi mengembalikan beberapa jenis tipe data, itu berarti ia dapat mengembalikan nilai <b>apa pun</b> dari set yang termasuk dalam tipe data ini.  Dalam contoh kami, untuk penganalisa, ini berarti bahwa <code>fopen()</code> dapat mengembalikan <code>true</code> .  Dan, misalnya, dalam hal kode seperti itu: <br><br><pre> <code class="php hljs">$fp = fopen(<span class="hljs-string"><span class="hljs-string">'some.file'</span></span>,<span class="hljs-string"><span class="hljs-string">'r'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($fp === <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) {     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } fwrite($fp, <span class="hljs-string"><span class="hljs-string">"some string"</span></span>);</code> </pre> <br>  analisa akan mengeluh bahwa <code>fwrite</code> menerima sumber daya parameter pertama, dan kami memberikan <code>bool</code> (karena analis melihat bahwa opsi yang benar adalah mungkin).  Untuk alasan ini, semua analis memahami tipe data "buatan" seperti <code>false</code> , dan dalam contoh kita, kita dapat menulis <code>@return false|resource</code> .  PHPStorm juga memahami deskripsi tipe ini. <br><br>  <b>Bentuk array</b> <br><br>  Seringkali, array dalam PHP digunakan sebagai tipe <code>record</code> - suatu struktur dengan daftar bidang yang jelas, di mana setiap bidang memiliki jenisnya sendiri.  Tentu saja, banyak programmer sudah menggunakan kelas untuk ini.  Tetapi kami memiliki banyak kode lawas di Badoo, dan array secara aktif digunakan di sana.  Dan itu juga terjadi bahwa programmer terlalu malas untuk membuat kelas yang terpisah untuk beberapa struktur satu kali, dan di tempat seperti itu array juga sering digunakan. <br><br>  Masalah dengan array tersebut adalah bahwa tidak ada deskripsi yang jelas tentang struktur ini (daftar bidang dan tipenya) dalam kode.  Pemrogram dapat membuat kesalahan ketika bekerja dengan struktur seperti itu: lupakan bidang yang diperlukan atau tambahkan kunci "kiri", lebih lanjut membingungkan kode. <br><br>  Analisis memungkinkan Anda untuk memasukkan deskripsi struktur seperti itu: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> array{scheme:string,host:string,path:string} $parsed_url */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showUrl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $parsed_url)</span></span></span><span class="hljs-function"> </span></span>{ … }</code> </pre> <br>  Dalam contoh ini, kami menggambarkan array dengan tiga bidang string: <code>scheme, host</code> dan <code>path</code> .  Jika di dalam fungsi kita beralih ke bidang lain, alat analisa akan menunjukkan kesalahan. <br><br>  Jika Anda tidak mendeskripsikan jenisnya, maka alat analisis akan mencoba untuk "menebak" struktur array, tetapi, seperti yang ditunjukkan oleh praktik, mereka tidak benar-benar berhasil dengan kode kami.  :) <br><br>  Pendekatan ini memiliki satu kelemahan.  Misalkan Anda memiliki struktur yang aktif digunakan dalam kode.  Anda tidak dapat mendeklarasikan pseudotype di satu tempat dan kemudian menggunakannya di mana-mana.  Anda harus mendaftarkan PHPDoc dengan deskripsi array di mana-mana dalam kode, yang sangat merepotkan, terutama jika ada banyak bidang dalam array.  Juga akan bermasalah untuk mengedit tipe ini nanti (tambah dan hapus bidang). <br><br>  <b>Deskripsi tipe kunci array</b> <br><br>  Di PHP, kunci array bisa berupa bilangan bulat dan string.  Jenis terkadang penting untuk analisis statis (dan juga untuk programmer).  Analisis statis memungkinkan Anda untuk menggambarkan kunci array di PHPDoc: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> array&lt;int, \User&gt; $users */</span></span> $users = UserLoaders::loadUsers($user_ids);</code> </pre> <br>  Dalam contoh ini, menggunakan PHPDoc, kami menambahkan petunjuk bahwa dalam array <code>$users</code> kunci integer ints, dan nilainya adalah objek dari kelas <code>\User</code> .  Kita bisa menggambarkan tipe sebagai \ Pengguna [].  Ini akan memberi tahu penganalisa bahwa ada objek di kelas <code>\User</code> dalam array, tetapi tidak akan memberi tahu kami apa pun tentang jenis kunci. <br><br>  PHPStorm mendukung format ini untuk menjelaskan array yang dimulai dengan versi 2018.3. <br><br>  <b>Namespace Anda di PHPDoc</b> <br><br>  PHPStorm (dan editor lainnya) dan analisis statis dapat memahami PHPDoc secara berbeda.  Misalnya, penganalisis mendukung format ini: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> array{scheme:string,host:string,path:string} $parsed_url */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showUrl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($parsed_url)</span></span></span><span class="hljs-function"> </span></span>{ … }</code> </pre> <br>  Tapi PHPStorm tidak memahaminya.  Tapi kita bisa menulis seperti ini: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> array $parsed_url * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@phan</span></span></span><span class="hljs-comment">-param array{scheme:string,host:string,path:string} $parsed_url * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@psalm</span></span></span><span class="hljs-comment">-param array{scheme:string,host:string,path:string} $parsed_url */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showUrl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($parsed_url)</span></span></span><span class="hljs-function"> </span></span>{ … }</code> </pre> <br>  Dalam hal ini, analis dan PHPStorm akan puas.  PHPStorm akan menggunakan <code>@param</code> , dan penganalisa akan menggunakan tag PHPDoc mereka sendiri. <br><br><h3>  Fitur PHP Memeriksa </h3><br>  Jenis tes ini paling baik digambarkan dengan contoh. <br><br>  Apakah kita semua tahu apa fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">explode ()</a> dapat kembali?  Jika Anda melirik ke dokumentasi, sepertinya mengembalikan array.  Tetapi jika Anda memeriksanya lebih hati-hati, kita akan melihat bahwa itu juga dapat mengembalikan false.  Bahkan, itu bisa mengembalikan nol dan kesalahan jika Anda memberikannya tipe yang salah, tetapi memberikan nilai yang salah dengan tipe data yang salah sudah merupakan kesalahan, jadi opsi ini tidak menarik bagi kami sekarang. <br><br>  Secara formal, dari sudut pandang penganalisa, jika suatu fungsi dapat mengembalikan false atau array, maka kemungkinan besar, maka kode harus memeriksa false.  Tetapi fungsi explode () mengembalikan false hanya jika pembatas (parameter pertama) sama dengan string kosong.  Seringkali, secara eksplisit ditulis dalam kode, dan analis dapat memverifikasi bahwa itu tidak kosong, yang berarti bahwa di tempat ini fungsi explode () secara akurat mengembalikan array dan pemeriksaan palsu tidak diperlukan. <br><br>  PHP memiliki beberapa fitur.  Analisis secara bertahap menambahkan pemeriksaan yang sesuai atau memperbaikinya, dan kami, programmer, tidak perlu lagi mengingat semua fitur ini. <br><br>  Kami beralih ke deskripsi alat analisis tertentu. <br><br><h2>  PHPStan </h2><br>  Pengembangan Ondřej Mirtes tertentu dari Republik Ceko.  Aktif dikembangkan sejak akhir 2016. <br><br>  Untuk mulai menggunakan PHPStan, Anda perlu: <br><br><ol><li>  Instal (cara termudah untuk melakukannya adalah melalui Komposer). <br></li><li>  (opsional) Konfigurasikan. <br></li><li>  Dalam kasus paling sederhana, jalankan saja: <br></li></ol><br> <code>vendor/bin/phpstan analyse ./src</code> <br> <br>  (bukan <code>src</code> mungkin ada daftar file tertentu yang ingin Anda periksa). <br><br>  PHPStan akan membaca kode PHP dari file yang ditransfer.  Jika dia menemukan kelas yang tidak dikenal, dia akan mencoba memuatnya dengan autoload dan melalui refleksi untuk memahami antarmuka mereka.  Anda juga dapat mentransfer jalur ke file <code>Bootstrap</code> tempat Anda mengkonfigurasi autoload, dan melampirkan beberapa file tambahan untuk menyederhanakan analisis PHPStan. <br><br>  Fitur Utama: <br><br><ol><li>  Dimungkinkan untuk menganalisis bukan seluruh basis kode, tetapi hanya bagian - kelas yang tidak diketahui PHPStan akan mencoba memuat autoload. <br></li><li>  Jika karena alasan tertentu beberapa kelas Anda tidak ada dalam autoload, PHPStan tidak akan dapat menemukannya dan akan memberikan kesalahan. <br></li><li>  Jika Anda aktif menggunakan metode sulap melalui <code>__call / __get / __set</code> , maka Anda dapat menulis plugin untuk PHPStan.  Plugin untuk Symfony, Doctrine, Laravel, Mockery, dll sudah ada. <br></li><li>  Faktanya, PHPStan melakukan autoload tidak hanya untuk kelas yang tidak diketahui, tetapi secara umum untuk semua orang.  Kami memiliki banyak kode lama yang ditulis sebelum munculnya kelas anonim, ketika kami membuat kelas dalam satu file, dan kemudian langsung instantiate dan, mungkin, bahkan memanggil beberapa metode.  Muat otomatis ( <code>include</code> ) file tersebut menyebabkan kesalahan, karena kode ini tidak dijalankan di lingkungan normal. <br></li><li>  Konfigurasi dalam format <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">neon</a> (saya tidak pernah mendengar bahwa format seperti itu digunakan di tempat lain). <br></li><li>  Tidak ada dukungan untuk tag PHPDoc mereka seperti <code>@phpstan-var, @phpstan-return</code> , dll. <br></li></ol><br>  Fitur lainnya adalah kesalahan memiliki teks, tetapi tidak ada jenis.  Yaitu, teks kesalahan dikembalikan kepada Anda, misalnya: <br><br><ul><li> <code>Method \SomeClass::getAge() should return int but returns int|null</code> <br> </li><li> <code>Method \SomeOtherClass::getName() should return string but returns string|null</code> <br> </li></ul><br>  Dalam contoh ini, kedua kesalahan pada dasarnya tentang hal yang sama: metode harus mengembalikan satu jenis, tetapi pada kenyataannya ia mengembalikan yang lain.  Namun teks kesalahannya berbeda, meski serupa.  Karena itu, jika Anda ingin memfilter kesalahan apa pun di PHPStan, lakukan hanya melalui ekspresi reguler. <br><br>  Sebagai perbandingan, di penganalisa lain, kesalahan memiliki tipe.  Misalnya, di Phan, kesalahan seperti itu adalah tipe <code>PhanPossiblyNullTypeReturn</code> , dan Anda bisa menentukan dalam konfigurasi bahwa Anda tidak perlu memeriksa kesalahan tersebut.  Juga, memiliki jenis kesalahan, dimungkinkan, misalnya, untuk dengan mudah mengumpulkan statistik tentang kesalahan. <br><br>  Karena kita tidak menggunakan Laravel, Symfony, Doctrine dan solusi serupa, dan kita jarang menggunakan metode ajaib dalam kode kita, fitur utama PHPStan ternyata tidak diklaim oleh kita.  ; (Selain itu, karena fakta bahwa PHPStan memasukkan-itu <b>semua</b> kelas yang diperiksa, terkadang analisisnya tidak bekerja pada basis kode kami. <br><br>  Namun, PHPStan tetap bermanfaat bagi kami: <br><br><ul><li>  Jika Anda perlu memeriksa beberapa file, PHPStan terasa lebih cepat dari Phan dan sedikit (20-50%) lebih cepat dari Mazmur. <br></li><li>  Laporan PHPStan memudahkan untuk menemukan <code>false-positive</code> di analisis lain.  Biasanya, jika ada beberapa <code>fatal</code> eksplisit dalam kode, ini ditunjukkan oleh semua analis (atau setidaknya dua dari tiga). <br></li></ul><br><br>  <b>Perbarui:</b> <br>  Penulis PHPStan Ondřej Mirtes juga membaca artikel kami dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memberi tahu</a> kami bahwa PhpStan, seperti Psalm, memiliki situs web dengan "kotak pasir": <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://phpstan.org/</a> .  Ini sangat nyaman untuk laporan bug: Anda mereproduksi kesalahan dan memberikan tautan di GitHub. <br><br><h2>  Phan </h2><br>  Dikembangkan oleh Etsy.  Komitmen pertama dari Rasmus Lerdorf. <br><br>  Dari ketiga pertanyaan tersebut, Phan adalah satu-satunya penganalisa statis <b>nyata</b> (dalam arti bahwa itu tidak mengeksekusi file Anda - itu mem-parsing <b>seluruh</b> basis kode Anda, dan kemudian menganalisis apa yang Anda katakan).  Bahkan untuk menganalisis beberapa file dalam basis kode kami, diperlukan sekitar 6 GB RAM, dan proses ini memakan waktu empat hingga lima menit.  Tetapi kemudian analisis lengkap dari seluruh basis kode membutuhkan waktu sekitar enam hingga tujuh menit.  Sebagai perbandingan, Mazmur menganalisisnya dalam beberapa puluh menit.  Dan dari PHPStan kami tidak dapat mencapai analisis lengkap dari seluruh basis kode sama sekali karena termasuk kelas yang disertakan. <br><br>  Pengalaman Phan ada dua.  Di satu sisi, ini adalah penganalisis paling berkualitas dan stabil, ia menemukan banyak dan ada sedikit masalah dengan itu ketika perlu untuk menganalisis seluruh basis kode.  Di sisi lain, ia memiliki dua fitur yang tidak menyenangkan. <br><br>  Di bawah tenda, Phan menggunakan ekstensi php-ast.  Rupanya, ini adalah salah satu alasan mengapa analisis seluruh basis kode relatif cepat.  Tetapi php-ast menunjukkan representasi internal dari pohon AST seperti yang muncul dalam PHP itu sendiri.  Dan dalam PHP itu sendiri, pohon AST tidak mengandung informasi tentang komentar yang terletak di dalam fungsi.  Yaitu, jika Anda menulis sesuatu seperti: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> int $type */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($type)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> \My\Object $obj **/</span></span>   $obj = MyFactory::createObjectByType($type);   … }</code> </pre> <br>  kemudian di dalam pohon AST terdapat informasi tentang PHPDoc eksternal untuk fungsi <code>doSomething()</code> , tetapi tidak ada informasi bantuan PHPDoc di dalam fungsi tersebut.  Dan, karenanya, Phan juga tidak tahu apa-apa tentangnya.  Ini adalah penyebab paling umum dari <code>false-positive</code> di Phan.  Ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">beberapa rekomendasi</a> tentang cara memasukkan tooltips (melalui string atau assert-s), tetapi, sayangnya, mereka sangat berbeda dari yang biasa digunakan oleh programmer kami.  Sebagian, kami memecahkan masalah ini dengan menulis plugin untuk Phan.  Tetapi plugin akan dibahas di bawah ini. <br><br>  Fitur kedua yang tidak menyenangkan adalah bahwa Phan tidak menganalisis properti objek dengan baik.  Berikut ini sebuah contoh: <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> string|null */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $a; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $a = null)</span></span></span><span class="hljs-function"> </span></span>{      <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;a = $a; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;a &amp;&amp; strpos(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;a, <span class="hljs-string"><span class="hljs-string">'a'</span></span>) === <span class="hljs-number"><span class="hljs-number">0</span></span>) {          var_dump(<span class="hljs-string"><span class="hljs-string">"test1"</span></span>);      } } }</code> </pre> <br>  Dalam contoh ini, Phan akan memberi tahu Anda bahwa dalam strpos Anda dapat melewati nol.  Anda dapat mempelajari lebih lanjut tentang masalah ini di sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/phan/phan/issues/204</a> . <br><br>  Ringkasan  Meskipun ada beberapa kesulitan, Phan adalah perkembangan yang sangat keren dan bermanfaat.  Selain dua jenis <code>false-positive</code> , ia hampir tidak membuat kesalahan, atau membuat kesalahan, tetapi pada beberapa kode yang benar-benar kompleks.  Kami juga menyukai konfigurasi ini dalam file PHP - ini memberikan fleksibilitas.  Phan juga tahu cara bekerja sebagai server bahasa, tetapi kami tidak menggunakan fitur ini, karena PHPStorm sudah cukup bagi kami. <br><br><h3>  Plugin </h3><br>  Phan memiliki API pengembangan plugin yang dikembangkan dengan baik.  Anda dapat menambahkan cek Anda sendiri, meningkatkan inferensi jenis untuk kode Anda.  API ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memiliki dokumentasi</a> , tetapi khususnya keren bahwa ada plugin yang berfungsi di dalamnya yang dapat digunakan sebagai contoh. <br><br>  Kami berhasil menulis dua plugin.  Yang pertama dimaksudkan untuk pemeriksaan satu kali.  Kami ingin mengevaluasi seberapa siap kode kami untuk PHP 7.3 (khususnya, untuk mengetahui apakah ia memiliki konstanta <code>case-insensitive</code> ).  Kami hampir yakin bahwa tidak ada konstanta seperti itu, tetapi apa pun bisa terjadi dalam 12 tahun - itu harus diperiksa.  Dan kami menulis sebuah plugin untuk Phan yang akan bersumpah jika parameter ketiga digunakan dalam <code>define()</code> . <br><br><div class="spoiler">  <b class="spoiler_title">Plugin ini sangat sederhana</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span>(strict_types=<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Phan</span></span>\<span class="hljs-title"><span class="hljs-title">AST</span></span>\<span class="hljs-title"><span class="hljs-title">ContextNode</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Phan</span></span>\<span class="hljs-title"><span class="hljs-title">CodeBase</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Phan</span></span>\<span class="hljs-title"><span class="hljs-title">Language</span></span>\<span class="hljs-title"><span class="hljs-title">Context</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Phan</span></span>\<span class="hljs-title"><span class="hljs-title">Language</span></span>\<span class="hljs-title"><span class="hljs-title">Element</span></span>\<span class="hljs-title"><span class="hljs-title">Func</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Phan</span></span>\<span class="hljs-title"><span class="hljs-title">PluginV2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Phan</span></span>\<span class="hljs-title"><span class="hljs-title">PluginV2</span></span>\<span class="hljs-title"><span class="hljs-title">AnalyzeFunctionCallCapability</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">ast</span></span>\<span class="hljs-title"><span class="hljs-title">Node</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DefineThirdParamTrue</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PluginV2</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnalyzeFunctionCallCapability</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAnalyzeFunctionCallClosures</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CodeBase $code_base)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{   $define_callback = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(       CodeBase $code_base,                  Context $context,                  Func $function,                  array $args    )</span></span></span><span class="hljs-function"> </span></span>{      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (\count($args) &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) {         <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;      }       <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;emitIssue(       $code_base,      $context,      <span class="hljs-string"><span class="hljs-string">'PhanDefineCaseInsensitiv'</span></span>,      <span class="hljs-string"><span class="hljs-string">'Define with 3 arguments'</span></span>,      []      );    };    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [          <span class="hljs-string"><span class="hljs-string">'define'</span></span> =&gt; $define_callback,    ]; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DefineThirdParamTrue();</code> </pre> <br></div></div><br><br>  Di Phan, berbagai plugin dapat digantung pada acara yang berbeda.  Khususnya, plugin dengan antarmuka <code>AnalyzeFunctionCallCapability</code> dipicu ketika panggilan fungsi diuraikan.  Di plugin ini, kami membuatnya sehingga ketika kami memanggil fungsi <code>define()</code> , fungsi anonim kami dipanggil, yang memeriksa yang <code>define()</code> tidak <code>define()</code> lebih dari dua argumen.  Kemudian kami baru saja memulai Phan, menemukan semua tempat di mana <code>define()</code> dipanggil dengan tiga argumen, dan memastikan bahwa kami tidak memiliki <code>case-insensitive-</code> . <br><br>  Menggunakan plugin, kami juga sebagian menyelesaikan masalah <code>false-positive</code> ketika Phan tidak melihat petunjuk PHPDoc di dalam kode. <br><br>  Kita sering menggunakan metode pabrik yang mengambil konstanta sebagai input dan membuat objek darinya.  Seringkali kode terlihat seperti ini: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> \Objects\Controllers\My $Object */</span></span> $Object = \Objects\Factory::create(\Objects\Config::MY_CONTROLLER);</code> </pre> <br>  Phan tidak mengerti petunjuk PHPDoc tersebut, tetapi dalam kode ini kelas objek dapat diperoleh dari nama konstanta yang diteruskan ke metode <code>create()</code> .  Phan memungkinkan Anda untuk menulis sebuah plugin yang menyala ketika menganalisis nilai kembali suatu fungsi.  Dan dengan plugin ini, Anda dapat memberi tahu penganalisa jenis fungsi yang dikembalikan dalam panggilan ini. <br><br>  Contoh dari plugin ini lebih kompleks.  Tetapi ada contoh yang baik dalam kode Phan di <code>vendor/phan/phan/src/Phan/Plugin/Internal/DependentReturnTypeOverridePlugin.php.</code> <br><br>  Secara keseluruhan, kami sangat senang dengan alat analisa Phan.  <code>false-positive</code> tercantum di atas kami pelajari sebagian (dalam kasus sederhana, dengan kode sederhana) untuk difilter.  Setelah itu, Phan menjadi penganalisis referensi.  Namun, kebutuhan untuk segera menguraikan seluruh basis kode (waktu dan banyak memori) masih mempersulit proses implementasinya. <br><br><h2>  Mazmur </h2><br>  Mazmur adalah pengembangan oleh Vimeo.  Jujur, saya bahkan tidak tahu bahwa Vimeo menggunakan PHP sampai saya melihat Mazmur. <br><br>  Penganalisa ini adalah yang termuda dari tiga kami.  Ketika saya membaca berita bahwa Vimeo merilis Mazmur, saya bingung: "Mengapa berinvestasi dalam Mazmur jika Anda sudah memiliki Phan dan PHPStan?"  Tetapi ternyata Mazmur memiliki fitur-fiturnya sendiri yang bermanfaat. <br><br>  Mazmur mengikuti jejak PHPStan: Anda juga dapat memberikan daftar file untuk dianalisis, dan itu akan menganalisisnya, dan menghubungkan kelas-kelas yang tidak ditemukan dengan memuat-otomatis.  Pada saat yang sama, itu <b>hanya</b> menghubungkan kelas yang tidak ditemukan, dan file yang kami minta analisis tidak akan dimasukkan (ini berbeda dari PHPStan).  Konfigurasi disimpan dalam file XML (bagi kami, ini lebih cenderung minus, tetapi tidak terlalu kritis). <br><br>  Mazmur memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs</a> berpasir di mana Anda dapat menulis kode PHP dan menganalisisnya.  Ini sangat nyaman untuk laporan bug: Anda mereproduksi kesalahan di situs dan memberikan tautan di GitHub.  Dan omong-omong, situs ini menjelaskan semua jenis kesalahan yang mungkin terjadi.  Sebagai perbandingan: di PHPStan kesalahan tidak memiliki tipe, dan di Phan ada kesalahan, tetapi tidak ada daftar tunggal yang dapat ditemukan. <br><br>  Kami juga menyukai itu ketika menghasilkan kesalahan, Mazmur segera menunjukkan baris kode di mana mereka ditemukan.  Ini <b>sangat</b> menyederhanakan membaca laporan. <br><br>  Tetapi mungkin fitur yang paling menarik dari Mazmur adalah tag PHPDoc khusus, yang memungkinkan Anda untuk meningkatkan analisis (terutama definisi jenis).  Kami daftar yang paling menarik dari mereka. <br><br><h3>  @ mazmur-abaikan-nullable-return </h3><br>  Itu terjadi bahwa secara formal suatu metode dapat mengembalikan <code>null</code> , tetapi kode sudah diatur sedemikian rupa sehingga ini tidak pernah terjadi.  Dalam hal ini sangat nyaman bahwa Anda dapat menambahkan petunjuk PHPDoc seperti itu ke metode / fungsi - dan Mazmur akan menganggap bahwa <code>null</code> tidak dikembalikan. <br><br>  Petunjuk serupa ada untuk false: <code>@psalm-ignore-falsable-return</code> . <br><br><h3>  Jenis untuk penutupan </h3><br>  Jika Anda pernah tertarik pada pemrograman fungsional, Anda mungkin telah memperhatikan bahwa seringkali suatu fungsi dapat mengembalikan fungsi lain atau mengambil beberapa fungsi sebagai parameter.  Dalam PHP, gaya ini bisa sangat membingungkan bagi kolega Anda, dan salah satu alasannya adalah PHP tidak memiliki standar untuk mendokumentasikan fungsi tersebut.  Sebagai contoh: <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_filter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $ar, \Closure $func)</span></span></span><span class="hljs-function"> </span></span>{ … }</code> </pre> <br>  Bagaimana seorang programmer dapat memahami antarmuka yang memiliki fungsi dalam parameter kedua?  Parameter apa yang harus diambil?  Apa yang harus dia kembalikan? <br><br>  Mazmur mendukung sintaks untuk menggambarkan fungsi dalam PHPDoc: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> array $ar * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@psalm</span></span></span><span class="hljs-comment">-param Closure(int):bool $func */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_filter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $ar, \Closure $func)</span></span></span><span class="hljs-function"> </span></span>{ … }</code> </pre> <br>  Dengan deskripsi seperti itu, sudah jelas bahwa Anda harus meneruskan fungsi anonim ke <code>my_filter</code> , yang akan menerima int dan mengembalikan bool.  Dan, tentu saja, Mazmur akan memverifikasi bahwa Anda memiliki fungsi seperti itu yang diteruskan dalam kode Anda. <br><br><h3>  Enum </h3><br>  Misalkan Anda memiliki fungsi yang mengambil parameter string, dan Anda hanya dapat melewatkan string tertentu di sana: <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isYes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $yes_or_no)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-function"> </span></span>{     $yes_or_no = strtolower($yes_or_no)     <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>($yes_or_no)  {           <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'yes'</span></span>:                 <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>;          <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'no'</span></span>:                 <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>;           <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>:                <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \InvalidArgumentException(…);     } }</code> </pre><br>  Mazmur memungkinkan Anda untuk menggambarkan parameter fungsi ini seperti ini: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@psalm</span></span></span><span class="hljs-comment">-param 'Yes'|'No' $yes_or_no **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isYes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $yes_or_no)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-function"> </span></span>{ … }</code> </pre> <br>  Dalam hal ini, Mazmur akan mencoba memahami nilai spesifik apa yang diteruskan ke fungsi ini, dan melempar kesalahan jika ada nilai selain <code>Yes</code> dan <code>No</code> <br><br>  Baca lebih lanjut tentang enum di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><h3>  Ketik alias </h3><br>  Sebelumnya dalam deskripsi <code>array shapes</code> saya menyebutkan bahwa meskipun analisis memungkinkan Anda untuk menggambarkan struktur array, itu sangat tidak nyaman untuk menggunakannya, karena deskripsi array harus disalin di tempat yang berbeda.  Solusi yang benar, tentu saja, adalah menggunakan kelas daripada array.  Tetapi dalam kasus warisan bertahun-tahun, ini tidak selalu mungkin. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Faktanya, masalah muncul tidak hanya dengan array, tetapi dengan tipe apa pun yang bukan kelas: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sebuah array; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> penutupan; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jenis serikat (misalnya, beberapa kelas atau kelas dan jenis lainnya); </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> enum. </font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setiap tipe seperti itu, jika digunakan di beberapa tempat, perlu diduplikasi dalam PHPDoc dan, jika diubah, karenanya, diperbaiki di mana-mana. </font><font style="vertical-align: inherit;">Karena itu, Mazmur memiliki sedikit perbaikan dalam hal ini. </font><font style="vertical-align: inherit;">Anda dapat mendeklarasikan alias untuk suatu jenis dan kemudian menggunakan yang ini di PHPDoc </font></font><code>alias</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sayangnya, ada batasan: ini berfungsi dalam kerangka file PHP tunggal. </font><font style="vertical-align: inherit;">Tapi ini sudah menyederhanakan deskripsi tipe. </font><font style="vertical-align: inherit;">Benar, hanya untuk Mazmur.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Templat alias generik </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertimbangkan kesempatan ini sebagai contoh. </font><font style="vertical-align: inherit;">Katakanlah Anda memiliki fungsi seperti ini:</font></font><br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">identity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $x; }</code> </pre> <br>     ?      ?   ? <br><br> , ,    , — <code>mixed</code> ,             . <br><br>     <code>mixed</code> —  .  ,            .    ,   <code>identity()</code>  /  ,    :     ,   .       -.  ,   : <br><br><pre> <code class="php hljs">$i = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">// int $y = identity($i);</span></span></code> </pre> <br>       <code>(int)</code> ,  ,      <code>$y</code> ( <code>int</code> ). <br><br>       ?  Psalm     PHPDoc-: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@template</span></span></span><span class="hljs-comment"> T * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@psalm</span></span></span><span class="hljs-comment">-param T $x * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@psalm</span></span></span><span class="hljs-comment">-return T */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">identity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($x)</span></span></span><span class="hljs-function"> </span></span>{ $return $x; }</code> </pre> <br>   templates   Psalm   ,  /     . <br><br>  Psalm      templates: <br><br> — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">vendor/vimeo/psalm/src/Psalm/Stubs/CoreGenericFunctions.php</a> ; <br> — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">vendor/vimeo/psalm/src/Psalm/Stubs/CoreGenericClasses.php</a> . <br><br>      Phan,      : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/phan/phan/wiki/Generic-Types</a> . <br><br>  ,  Psalm  . ,    «»              .   ,  Psalm    ,    ,       Phan  PHPStan.     . <br><br><h2>    PHPStorm </h2><br>      :          ,   .    ,      ,    . <br><br>             .     Phan,    language server.    PHPStorm, ,   . <br><br> ,  ,  PHPStorm     ( ),       .         — Php Inspections (EA Extended).     —   ,   ,         .  ,      . ,      scopes     -   scopes. <br><br>     ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">deep-assoc-completion</a> .         . <br><br><h1>    Badoo </h1><br>     ? <br><br>       ,         . <br><br>     ,   .  ,     ,    <code>git diff</code>      / ,       ,     () .       ,    . <br><br> ,     :      -    <code>git diff</code> .     .             ,    .         . , ,  ,          ,    . <br><br>     ,     ,       : <br><br><img src="https://habrastorage.org/webt/zj/e2/rt/zje2rtxhy1nkwsamex4umguv4yw.png"><br><br>           <code>false-positive</code> . ,  ,   Phan        ,   ,     . ,   -    Phan      ,     ,      . <br><br><h1>     QA </h1><br>        : <br><br><ul><li>     ; <br></li><li>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">code review</a> ; <br></li><li>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> . <br></li></ul><br><br>   — ,  ,      ,     .      : <br><br><ul><li>    100%  (   ,        ); <br></li><li>     ,      code review; <br></li><li>      ,        . <br></li></ul><br>         <code>strict types</code> .          ,  <code>strict types</code> ,    : <br><br><ul><li>     ,     <code>strict types</code> ,   ; <br></li><li>     ,     (,    ,        ); <br></li><li>        ,    PHP (,   <code>union types</code> ,    PHP); <br></li><li>       <code>strict types</code> ,        . <br></li></ul><br><h1>  :   </h1><br>  ,        .   . <br><br> -,     , ,      -  ,    . <br><br> -,     ,     —  , ,     PHPDoc.        —   . <br><br> -,     .  ,     -  ,            PHPDoc.  :) <br><br>  ,  ,     .    ,      . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id426605/">https://habr.com/ru/post/id426605/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id426591/index.html">Master Postur: Tetap Hidup</a></li>
<li><a href="../id426593/index.html">DJI Phantom 4 RTK: Pemetaan Generasi Selanjutnya</a></li>
<li><a href="../id426595/index.html">Richard Hamming "Bab tidak ada": Seperti yang kita tahu apa yang kita ketahui (1-10 menit dari 40)</a></li>
<li><a href="../id426597/index.html">Madrobots di IFA 2018. Bagian 2 - Proyektor Cerdas: Dari XGIMI ke Anker</a></li>
<li><a href="../id426603/index.html">Spiral berputar: matematika dan halusinasi</a></li>
<li><a href="../id426609/index.html">Office 365 dan produk MS lainnya akan menambahkan suara I / O untuk penderita disleksia</a></li>
<li><a href="../id426611/index.html">Integrasi dengan SAP ERP, menggunakan Django-python sebagai contoh, menggunakan protokol oData (rest)</a></li>
<li><a href="../id426613/index.html">Jangan biarkan printer 3D menjadi malas</a></li>
<li><a href="../id426615/index.html">Menulis CLI di NodeJS</a></li>
<li><a href="../id426617/index.html">Lisensi untuk mengendarai mobil, atau mengapa aplikasi harus Single-Activity</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>