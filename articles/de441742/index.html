<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍬 📞 🎅🏻 Ausdruckskategorien in C ++ 👩🏼‍🤝‍👩🏻 🚬 👩🏽‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kategorien von Ausdrücken wie lvalue und rvalue beziehen sich mehr auf die grundlegenden theoretischen Konzepte der C ++ - Sprache als auf die praktis...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ausdruckskategorien in C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441742/"><p>  Kategorien von Ausdrücken wie <strong>lvalue</strong> und <strong>rvalue</strong> beziehen sich mehr auf die grundlegenden theoretischen Konzepte der C ++ - Sprache als auf die praktischen Aspekte ihrer Verwendung.  Aus diesem Grund haben viele sogar erfahrene Programmierer eine vage Vorstellung davon, was sie bedeuten.  In diesem Artikel werde ich versuchen, die Bedeutung dieser Begriffe so einfach wie möglich zu erklären und die Theorie mit praktischen Beispielen zu verwässern.  Ich werde sofort eine Reservierung vornehmen: Der Artikel gibt nicht vor, die vollständigste und strengste Beschreibung der Kategorien von Ausdrücken zu liefern. Für Details empfehle ich, sich direkt an die Quelle zu wenden: C ++ - Sprachstandard. </p><a name="habracut"></a><br><blockquote>  Der Artikel wird ziemlich viele englischsprachige Begriffe enthalten. Dies liegt an der Tatsache, dass einige von ihnen schwer ins Russische zu übersetzen sind, während andere auf unterschiedliche Weise in verschiedene Quellen übersetzt werden.  Daher werde ich häufig englische Begriffe angeben und sie <em>kursiv</em> hervorheben. </blockquote><br><h2 id="nemnogo-istorii">  Ein bisschen Geschichte </h2><br><p>  Die Begriffe <strong>lvalue</strong> und <strong>rvalue</strong> tauchten bereits in C auf. Es ist erwähnenswert, dass die Verwirrung ursprünglich in der Terminologie lag, da sie sich auf Ausdrücke und nicht auf Werte beziehen.  Historisch gesehen kann ein <strong>l-Wert</strong> vom Zuweisungsoperator übrig bleiben, und ein <strong>r-Wert</strong> kann nur <em>richtig sein</em> . </p><br><pre><code class="plaintext hljs">lvalue = rvalue;</code> </pre> <br><p>  Eine solche Definition vereinfacht und verzerrt jedoch das Wesentliche etwas.  Der C89-Standard definierte <strong>lvalue</strong> als <strong>Objektlokalisator</strong> , d.h.  Ein Objekt mit einem identifizierbaren Speicherort.  Dementsprechend wurde alles, was nicht zu dieser Definition passte, in die Kategorie <strong>rvalue</strong> aufgenommen. </p><br><h2 id="byarn-speshit-na-pomosch">  Bjarn eilt zur Rettung </h2><br><p>  In C ++ hat sich die Terminologie der Ausdruckskategorien ziemlich stark weiterentwickelt, insbesondere nach der Einführung des C ++ 11-Standards, in dem die Konzepte von <strong>rvalue-</strong> Links und <em>Verschiebungssemantik</em> eingeführt wurden.  Die Geschichte der Entstehung neuer Terminologie wird interessanterweise in Straustrups Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Neue“ Werteterminologie beschrieben</a> . </p><br><p>  Die neue, strengere Terminologie basiert auf zwei Eigenschaften: </p><br><ul><li>  das Vorhandensein von Identität ( <em>Identität</em> ) - das heißt, ein Parameter, anhand dessen verstanden werden kann, ob sich zwei Ausdrücke auf dieselbe Entität beziehen oder nicht (z. B. eine Adresse im Speicher); </li><li>  Die Fähigkeit, sich zu bewegen ( <em>kann verschoben werden</em> ) - unterstützt die Semantik der Bewegung. </li></ul><br><p>  Identitätsausdrückende Ausdrücke werden unter dem Begriff <strong>glvalue</strong> ( <em>verallgemeinerte Werte</em> ) <em>verallgemeinert</em> , Roaming-Ausdrücke werden <strong>rvalue genannt</strong> .  Kombinationen dieser beiden Eigenschaften haben 3 Hauptkategorien von Ausdrücken identifiziert: </p><br><table><thead><tr><th></th><th>  Habe eine Identität </th><th>  Ohne Identität </th></tr></thead><tbody><tr><td>  <strong>Kann nicht verschoben werden</strong> </td><td>  lWert </td><td>  - - </td></tr><tr><td>  <strong>Kann bewegt werden</strong> </td><td>  xvalue </td><td>  Wert </td></tr></tbody></table><br><p>  Tatsächlich führte der C ++ 17-Standard das Konzept der <em>Kopierelision ein</em> - formalisierende Situationen, in denen der Compiler das Kopieren und Verschieben von Objekten vermeiden kann und sollte.  In dieser Hinsicht muss der <strong>Wert</strong> nicht unbedingt verschoben werden.  Details und Beispiele finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Dies hat jedoch keinen Einfluss auf das Verständnis des allgemeinen Schemas der Kategorien von Ausdrücken. </p><br><p>  Im modernen C ++ Standard wird die Kategoriestruktur in Form eines solchen Schemas dargestellt: </p><br><p><img src="https://habrastorage.org/webt/2r/ut/w5/2rutw544jnidqrhi4cgwnc848xg.png" alt="Bild"></p><br><p>  Lassen Sie uns allgemein die Eigenschaften von Kategorien sowie die Sprachausdrücke untersuchen, die in jeder der Kategorien enthalten sind.  Ich stelle sofort fest, dass die unten aufgeführten Listen von Ausdrücken für jede Kategorie nicht als vollständig angesehen werden können. Für genauere und detailliertere Informationen sollten Sie sich direkt an den C ++ - Standard wenden. </p><br><h2 id="glvalue">  glvalue </h2><br><p>  Ausdrücke in der Kategorie <strong>glvalue</strong> haben folgende Eigenschaften: </p><br><ul><li>  kann implizit in <strong>prvalue</strong> konvertiert <strong>werden</strong> ; </li><li>  kann polymorph sein, das heißt, für sie sind die Konzepte eines statischen und dynamischen Typs sinnvoll; </li><li>  kann nicht vom Typ <strong>void sein</strong> - dies folgt direkt aus der Eigenschaft, eine Identität zu haben, da es für Ausdrücke vom Typ <strong>void</strong> keinen solchen Parameter gibt, der sie voneinander unterscheiden würde; </li><li>  kann einen <em>unvollständigen Typ haben</em> , z. B. in Form einer <em>Vorwärtsdeklaration</em> (sofern dies für einen bestimmten Ausdruck zulässig ist). </li></ul><br><h2 id="rvalue">  rWert </h2><br><p>  Ausdrücke in der Kategorie <strong>rvalue</strong> haben die folgenden Eigenschaften: </p><br><ul><li>  Sie können die <strong>r-Wert-</strong> Adresse nicht im Speicher <strong>abrufen</strong> - dies ergibt sich direkt aus dem Fehlen der Identitätseigenschaft. </li><li>  darf sich nicht auf der linken Seite einer Zuweisung oder einer zusammengesetzten Zuweisungsanweisung befinden; </li><li>  kann verwendet werden, um eine konstante <strong>lvalue-</strong> Verknüpfung oder <strong>rvalue-</strong> Verknüpfung zu initialisieren, während sich die Lebensdauer des Objekts auf die Lebensdauer der Verknüpfung erstreckt; </li><li>  Wenn beim Aufrufen einer Funktion mit zwei überladenen Versionen ein Argument verwendet wird: Eine akzeptiert eine konstante <strong>l-Wert-</strong> Referenz und die andere eine <strong>r-Wert-</strong> Referenz. Dann wird die Version ausgewählt, die die <strong>r-Wert-</strong> Referenz akzeptiert.  Mit dieser Eigenschaft wird die <em>Verschiebungssemantik</em> implementiert: </li></ul><br><pre> <code class="plaintext hljs">class A { public: A() = default; A(const A&amp;) { std::cout &lt;&lt; "A::A(const A&amp;)\n"; } A(A&amp;&amp;) { std::cout &lt;&lt; "A::A(A&amp;&amp;)\n"; } }; ......... A a; A b(a); //  A(const A&amp;) A c(std::move(a)); //  A(A&amp;&amp;)</code> </pre> <br><blockquote>  Technisch gesehen ist A &amp;&amp; ein <strong>r-Wert</strong> und kann verwendet werden, um sowohl eine konstante <strong>l-Wert-</strong> Referenz als auch eine <strong>r-</strong> <strong>Wert-</strong> Referenz zu initialisieren.  Dank dieser Eigenschaft besteht jedoch keine Mehrdeutigkeit. Es wird eine Konstruktoroption akzeptiert, die eine <strong>r-Wert-</strong> Referenz akzeptiert. </blockquote><br><h2 id="lvalue">  lWert </h2><br><p>  Eigenschaften: </p><br><ul><li>  alle <strong>glvalue-</strong> Eigenschaften (siehe oben); </li><li>  Sie können die Adresse übernehmen (mit dem integrierten unären Operator <code>&amp;</code> ); </li><li>  modifizierbare l-Werte können sich auf der linken Seite des Zuweisungsoperators oder der zusammengesetzten Zuweisungsoperatoren befinden; </li><li>  kann verwendet werden, um eine Referenz auf einen <strong>l-Wert</strong> (sowohl konstant als auch nicht konstant) zu initialisieren. </li></ul><br><p>  Die folgenden Ausdrücke gehören zur Kategorie <strong>lvalue</strong> : </p><br><ul><li>  Der Name einer Variablen, Funktion oder eines Klassenfelds eines beliebigen Typs.  Selbst wenn die Variable eine <strong>rWertreferenz ist</strong> , ist der Name dieser Variablen im Ausdruck ein <strong>lWert</strong> ; </li></ul><br><pre> <code class="plaintext hljs">void func() {} ......... auto* func_ptr = &amp;func; // :     auto&amp; func_ref = func; // :     int&amp;&amp; rrn = int(123); auto* pn = &amp;rrn; // :    auto&amp; rn = rrn; // :  lvalue-</code> </pre> <br><ul><li>  Aufrufen einer Funktion oder eines überladenen Operators, der eine <strong>lWertreferenz</strong> oder einen Ausdruck der Konvertierung in den Typ einer <strong>lWertreferenz zurückgibt</strong> ; </li><li>  integrierte Zuweisungsoperatoren, zusammengesetzte Zuweisungsoperatoren ( <code>=</code> , <code>+=</code> , <code>/=</code> usw.), integriertes <code>--b</code> und <code>--b</code> ( <code>++a</code> , <code>--b</code> ), integrierter Zeiger-Dereferenzierungsoperator ( <code>*p</code> ); </li><li>  eingebauter Operator für den Zugriff über den Index ( <code>a[n]</code> oder <code>n[a]</code> ), wenn einer der Operanden ein <strong>lvalue-</strong> Array ist; </li><li>  Aufrufen einer Funktion oder einer überladenen Anweisung, die einen <strong>r-Wert-</strong> Verweis auf eine Funktion zurückgibt; </li><li>  String-Literal wie <code>"Hello, world!"</code>  . </li></ul><br><blockquote>  Ein String-Literal unterscheidet sich von allen anderen Literalen in C ++ genau dadurch, dass es ein <strong>l-Wert ist</strong> (wenn auch unveränderlich).  Zum Beispiel können Sie seine Adresse erhalten: </blockquote><br><pre> <code class="plaintext hljs">auto* p = &amp;”Hello, world!”; //   ,   </code> </pre> <br><h2 id="prvalue">  Wert </h2><br><p>  Eigenschaften: </p><br><ul><li>  alle <strong>rvalue-</strong> Eigenschaften (siehe oben); </li><li>  kann nicht polymorph sein: statische und dynamische Ausdruckstypen fallen immer zusammen; </li><li>  kann nicht von einem unvollständigen Typ sein (mit Ausnahme des <strong>Leertyps</strong> wird dies unten diskutiert); </li><li>  kann keinen abstrakten Typ haben oder ein Array von Elementen eines abstrakten Typs sein. </li></ul><br><p>  Die folgenden Ausdrücke gehören zur Kategorie <strong>prvalue</strong> : </p><br><ul><li>  Literal (außer Zeichenfolge), zum Beispiel <code>42</code> , <code>true</code> oder <code>nullptr</code> ; </li><li>  Ein Funktionsaufruf oder ein überladener Operator, der eine <code>str.substr(1, 2)</code> ( <code>str.substr(1, 2)</code> , <code>str1 + str2</code> , <code>it++</code> ) oder einen Konvertierungsausdruck in einen <code>str1 + str2</code> (z. B. <code>static_cast&lt;double&gt;(x)</code> , <code>std::string{}</code> , <code>(int)42</code> ); </li><li>  <code>b--</code> und <code>b--</code> ( <code>a++</code> , <code>b--</code> ), eingebaute mathematische Operationen ( <code>a + b</code> , <code>a % b</code> , <code>a &amp; b</code> , <code>a &lt;&lt; b</code> usw.), eingebaute logische Operationen ( <code>a &amp;&amp; b</code> , <code>a || b</code> <code>!a</code> usw.), Vergleichsoperationen ( <code>a &lt; b</code> , <code>a == b</code> , <code>a &gt;= b</code> usw.), die eingebaute Operation zum Aufnehmen der Adresse ( <code>&amp;a</code> ); </li><li>  <strong>dieser</strong> Zeiger; </li><li>  Auflistung Artikel; </li><li>  atypischer Vorlagenparameter, wenn es sich nicht um eine Klasse handelt; </li><li>  Lambda-Ausdruck, zum Beispiel <code>[](int x){ return x * x; }</code>  <code>[](int x){ return x * x; }</code> . </li></ul><br><h2 id="xvalue">  xvalue </h2><br><p>  Eigenschaften: </p><br><ul><li>  alle <strong>rvalue-</strong> Eigenschaften (siehe oben); </li><li>  alle <strong>glvalue-</strong> Eigenschaften (siehe oben). </li></ul><br><p>  Beispiele für <strong>xvalue-</strong> Ausdrücke: </p><br><ul><li>  Aufrufen einer Funktion oder eines integrierten Operators, der eine <strong>r-Wert-</strong> Referenz <strong>zurückgibt</strong> , z. B. <em>std :: move (x)</em> ; </li></ul><br><blockquote>  Tatsächlich können Sie für das Ergebnis des Aufrufs von <em>std :: move ()</em> keine Adresse im Speicher abrufen oder eine Verknüpfung dazu initialisieren, aber gleichzeitig kann dieser Ausdruck polymorph sein: </blockquote><br><pre> <code class="plaintext hljs">struct XA { virtual void f() { std::cout &lt;&lt; "XA::f()\n"; } }; struct XB : public XA { virtual void f() { std::cout &lt;&lt; "XB::f()\n"; } }; XA&amp;&amp; xa = XB(); auto* p = &amp;std::move(xa); //  auto&amp; r = std::move(xa); //  std::move(xa).f(); //  “XB::f()”</code> </pre> <br><ul><li>  <strong>Eingebauter</strong> Operator für den Zugriff nach Index ( <code>a[n]</code> oder <code>n[a]</code> ), wenn einer der Operanden ein <strong>rvalue-</strong> Array ist. </li></ul><br><h2 id="nekotorye-osobye-sluchai">  Einige Sonderfälle </h2><br><h3 id="operator-zapyataya">  Komma-Operator </h3><br><p>  Für den integrierten Kommaoperator stimmt die Ausdruckskategorie immer mit der Ausdruckskategorie des zweiten Operanden überein. </p><br><pre> <code class="plaintext hljs">int n = 0; auto* pn = &amp;(1, n); // lvalue auto&amp; rn = (1, n); // lvalue 1, n = 2; // lvalue auto* pt = &amp;(1, int(123)); // , rvalue auto&amp; rt = (1, int(123)); // , rvalue</code> </pre> <br><h2 id="vyrazheniya-tipa-void">  Leere Ausdrücke </h2><br><p>  Aufrufe von Funktionen, die <strong>void zurückgeben</strong> , Konvertierungsausdrücke in <strong>void</strong> <strong>umwandeln</strong> und Ausnahmen <strong>auslösen</strong> , werden als <strong>prvalue-</strong> Ausdrücke betrachtet, können jedoch nicht zum Initialisieren von Referenzen oder als Argumente für Funktionen verwendet werden. </p><br><h2 id="ternarnyy-operator-sravneniya">  Ternärer Vergleichsoperator </h2><br><p>  Definition der Ausdruckskategorie <code>a ? b : c</code>  <code>a ? b : c</code> - der Fall ist nicht trivial, alles hängt von den Kategorien des zweiten und dritten Arguments ab ( <code>b</code> und <code>c</code> ): </p><br><ul><li>  Wenn <code>b</code> oder <code>c</code> vom Typ <strong>void sind</strong> , entsprechen die Kategorie und der Typ des gesamten Ausdrucks der Kategorie und dem Typ des anderen Arguments.  Wenn beide Argumente vom Typ <strong>void sind</strong> , ist das Ergebnis ein <strong>Wert vom</strong> Typ <strong>void</strong> . </li><li>  Wenn <code>b</code> und <code>c</code> <strong>Gl-Werte</strong> desselben Typs sind, ist das Ergebnis ein <strong>Gl-Wert</strong> desselben Typs. </li><li>  In anderen Fällen ist das Ergebnis ein Wert. </li></ul><br><p>  Für den ternären Operator wird eine Reihe von Regeln definiert, nach denen implizite Konvertierungen auf die Argumente b und c angewendet werden können. Dies geht jedoch etwas über den <strong><em>Rahmen des Artikels hinaus. Wenn</em></strong> Sie interessiert sind, empfehle ich, <strong><em>auf den</em></strong> Abschnitt <strong><em>Bedingter Operator [Ausdruck]</em></strong> des Standards zu <strong><em>verweisen</em></strong> . </p><br><pre> <code class="plaintext hljs">int n = 1; int v = (1 &gt; 2) ? throw 1 : n; // lvalue, .. throw   void,    n ((1 &lt; 2) ? n : v) = 2; //  lvalue,  ,   ((1 &lt; 2) ? n : int(123)) = 2; //   , ..    prvalue</code> </pre> <br><h2 id="obrascheniya-k-polyam-i-metodam-klassov-i-struktur">  Verweise auf Felder und Methoden von Klassen und Strukturen </h2><br><p>  Für Ausdrücke der Form <code>am</code> und <code>p-&gt;m</code> (hier geht es um den eingebauten Operator <code>-&gt;</code> ) gelten folgende Regeln: </p><br><ul><li>  Wenn <code>m</code> ein Aufzählungselement oder eine nicht statische Klassenmethode ist, wird der gesamte Ausdruck als <strong>prvalue betrachtet</strong> (obwohl die Verknüpfung mit einem solchen Ausdruck nicht initialisiert werden kann). </li><li>  Wenn <code>a</code> ein <strong>rWert</strong> und <code>m</code> ein nicht statisches Feld eines <strong>Nichtreferenztyps</strong> ist, gehört der gesamte Ausdruck zur Kategorie <strong>xWert</strong> . </li><li>  sonst ist es ein <strong>Wert</strong> . </li></ul><br><p>  Für Zeiger auf Klassenmitglieder ( <code>a.*mp</code> und <code>p-&gt;*mp</code> ) gelten folgende Regeln: </p><br><ul><li>  Wenn <code>mp</code> ein Zeiger auf eine Klassenmethode ist, wird der gesamte Ausdruck als <strong>prvalue betrachtet</strong> . </li><li>  Wenn <code>a</code> ein <strong>r-Wert</strong> ist und <code>mp</code> ein Zeiger auf ein Datenfeld ist, bezieht sich der gesamte Ausdruck auf <strong>x-Wert</strong> . </li><li>  sonst ist es ein <strong>Wert</strong> . </li></ul><br><h2 id="bitovye-polya">  Bitfelder </h2><br><p>  Bitfelder sind ein praktisches Werkzeug für die Programmierung auf niedriger Ebene, ihre Implementierung liegt jedoch etwas außerhalb der allgemeinen Struktur von Ausdruckskategorien.  Beispielsweise scheint ein Aufruf eines <strong>Bitfelds</strong> ein <strong>Wert zu sein</strong> , <strong>da er</strong> möglicherweise auf der linken Seite des Zuweisungsoperators vorhanden ist.  Gleichzeitig funktioniert es nicht, die Adresse des Bitfelds zu übernehmen oder eine nicht konstante Verbindung durch diese zu initialisieren.  Sie können einen konstanten Verweis auf ein Bitfeld initialisieren, es wird jedoch eine temporäre Kopie des Objekts erstellt: </p><br><blockquote>  <strong><em>Bitfelder [class.bit]</em></strong> <br>  <em>Wenn der Initialisierer für eine Referenz vom Typ const T &amp; ein Wert ist, der sich auf ein Bitfeld bezieht, ist die Referenz an eine temporäre Initialisierung gebunden, die den Wert des Bitfelds enthält.</em>  <em>Die Referenz ist nicht direkt an das Bitfeld gebunden.</em> </blockquote><br><pre> <code class="plaintext hljs">struct BF { int f:3; }; BF b; bf = 1; // OK auto* pb = &amp;b.f; //  auto&amp; rb = bf; // </code> </pre> <br><h2 id="vmesto-zaklyucheniya">  Anstelle einer Schlussfolgerung </h2><br><p>  Wie ich in der Einleitung erwähnt habe, erhebt die obige Beschreibung keinen Anspruch auf Vollständigkeit, sondern gibt nur einen allgemeinen Überblick über die Kategorien von Ausdrücken.  Diese Ansicht bietet ein etwas besseres Verständnis der Absätze des Standards und der Compiler-Fehlermeldungen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de441742/">https://habr.com/ru/post/de441742/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de441728/index.html">Zusammenfassung des Online-Wettbewerbs für das Spiel Blotto</a></li>
<li><a href="../de441732/index.html">Notizen des Bioroboters</a></li>
<li><a href="../de441736/index.html">Automatisieren Sie die Konvertierung von Word-Dateien in andere Formate</a></li>
<li><a href="../de441738/index.html">Thermoakustische Grundlagen</a></li>
<li><a href="../de441740/index.html">Habra Megarating: Die besten Artikel und Statistiken von Habr seit 12 Jahren. Teil 1/2</a></li>
<li><a href="../de441744/index.html">Abrufen von Links zu Vk-Profilen aus SearchFace-Ergebnissen mit Python (dies ist jedoch nicht korrekt)</a></li>
<li><a href="../de441750/index.html">Projekte auf CodeFest: Wie kann ein Manager in einer sich ständig verändernden Welt überleben?</a></li>
<li><a href="../de441752/index.html">ZTE zeigte eine Smartphoneuhr α</a></li>
<li><a href="../de441754/index.html">Kubernetes Erfolgsgeschichten in der Produktion. Teil 10: Reddit</a></li>
<li><a href="../de441756/index.html">Für die russische Plattform von Industrie-PCs nahmen sie die Baikal-T1-Prozessoren und das Alt-Betriebssystem</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>