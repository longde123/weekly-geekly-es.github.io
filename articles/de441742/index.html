<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç¨ üìû üéÖüèª Ausdruckskategorien in C ++ üë©üèº‚Äçü§ù‚Äçüë©üèª üö¨ üë©üèΩ‚ÄçüöÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kategorien von Ausdr√ºcken wie lvalue und rvalue beziehen sich mehr auf die grundlegenden theoretischen Konzepte der C ++ - Sprache als auf die praktis...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ausdruckskategorien in C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441742/"><p>  Kategorien von Ausdr√ºcken wie <strong>lvalue</strong> und <strong>rvalue</strong> beziehen sich mehr auf die grundlegenden theoretischen Konzepte der C ++ - Sprache als auf die praktischen Aspekte ihrer Verwendung.  Aus diesem Grund haben viele sogar erfahrene Programmierer eine vage Vorstellung davon, was sie bedeuten.  In diesem Artikel werde ich versuchen, die Bedeutung dieser Begriffe so einfach wie m√∂glich zu erkl√§ren und die Theorie mit praktischen Beispielen zu verw√§ssern.  Ich werde sofort eine Reservierung vornehmen: Der Artikel gibt nicht vor, die vollst√§ndigste und strengste Beschreibung der Kategorien von Ausdr√ºcken zu liefern. F√ºr Details empfehle ich, sich direkt an die Quelle zu wenden: C ++ - Sprachstandard. </p><a name="habracut"></a><br><blockquote>  Der Artikel wird ziemlich viele englischsprachige Begriffe enthalten. Dies liegt an der Tatsache, dass einige von ihnen schwer ins Russische zu √ºbersetzen sind, w√§hrend andere auf unterschiedliche Weise in verschiedene Quellen √ºbersetzt werden.  Daher werde ich h√§ufig englische Begriffe angeben und sie <em>kursiv</em> hervorheben. </blockquote><br><h2 id="nemnogo-istorii">  Ein bisschen Geschichte </h2><br><p>  Die Begriffe <strong>lvalue</strong> und <strong>rvalue</strong> tauchten bereits in C auf. Es ist erw√§hnenswert, dass die Verwirrung urspr√ºnglich in der Terminologie lag, da sie sich auf Ausdr√ºcke und nicht auf Werte beziehen.  Historisch gesehen kann ein <strong>l-Wert</strong> vom Zuweisungsoperator √ºbrig bleiben, und ein <strong>r-Wert</strong> kann nur <em>richtig sein</em> . </p><br><pre><code class="plaintext hljs">lvalue = rvalue;</code> </pre> <br><p>  Eine solche Definition vereinfacht und verzerrt jedoch das Wesentliche etwas.  Der C89-Standard definierte <strong>lvalue</strong> als <strong>Objektlokalisator</strong> , d.h.  Ein Objekt mit einem identifizierbaren Speicherort.  Dementsprechend wurde alles, was nicht zu dieser Definition passte, in die Kategorie <strong>rvalue</strong> aufgenommen. </p><br><h2 id="byarn-speshit-na-pomosch">  Bjarn eilt zur Rettung </h2><br><p>  In C ++ hat sich die Terminologie der Ausdruckskategorien ziemlich stark weiterentwickelt, insbesondere nach der Einf√ºhrung des C ++ 11-Standards, in dem die Konzepte von <strong>rvalue-</strong> Links und <em>Verschiebungssemantik</em> eingef√ºhrt wurden.  Die Geschichte der Entstehung neuer Terminologie wird interessanterweise in Straustrups Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûNeue‚Äú Werteterminologie beschrieben</a> . </p><br><p>  Die neue, strengere Terminologie basiert auf zwei Eigenschaften: </p><br><ul><li>  das Vorhandensein von Identit√§t ( <em>Identit√§t</em> ) - das hei√üt, ein Parameter, anhand dessen verstanden werden kann, ob sich zwei Ausdr√ºcke auf dieselbe Entit√§t beziehen oder nicht (z. B. eine Adresse im Speicher); </li><li>  Die F√§higkeit, sich zu bewegen ( <em>kann verschoben werden</em> ) - unterst√ºtzt die Semantik der Bewegung. </li></ul><br><p>  Identit√§tsausdr√ºckende Ausdr√ºcke werden unter dem Begriff <strong>glvalue</strong> ( <em>verallgemeinerte Werte</em> ) <em>verallgemeinert</em> , Roaming-Ausdr√ºcke werden <strong>rvalue genannt</strong> .  Kombinationen dieser beiden Eigenschaften haben 3 Hauptkategorien von Ausdr√ºcken identifiziert: </p><br><table><thead><tr><th></th><th>  Habe eine Identit√§t </th><th>  Ohne Identit√§t </th></tr></thead><tbody><tr><td>  <strong>Kann nicht verschoben werden</strong> </td><td>  lWert </td><td>  - - </td></tr><tr><td>  <strong>Kann bewegt werden</strong> </td><td>  xvalue </td><td>  Wert </td></tr></tbody></table><br><p>  Tats√§chlich f√ºhrte der C ++ 17-Standard das Konzept der <em>Kopierelision ein</em> - formalisierende Situationen, in denen der Compiler das Kopieren und Verschieben von Objekten vermeiden kann und sollte.  In dieser Hinsicht muss der <strong>Wert</strong> nicht unbedingt verschoben werden.  Details und Beispiele finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Dies hat jedoch keinen Einfluss auf das Verst√§ndnis des allgemeinen Schemas der Kategorien von Ausdr√ºcken. </p><br><p>  Im modernen C ++ Standard wird die Kategoriestruktur in Form eines solchen Schemas dargestellt: </p><br><p><img src="https://habrastorage.org/webt/2r/ut/w5/2rutw544jnidqrhi4cgwnc848xg.png" alt="Bild"></p><br><p>  Lassen Sie uns allgemein die Eigenschaften von Kategorien sowie die Sprachausdr√ºcke untersuchen, die in jeder der Kategorien enthalten sind.  Ich stelle sofort fest, dass die unten aufgef√ºhrten Listen von Ausdr√ºcken f√ºr jede Kategorie nicht als vollst√§ndig angesehen werden k√∂nnen. F√ºr genauere und detailliertere Informationen sollten Sie sich direkt an den C ++ - Standard wenden. </p><br><h2 id="glvalue">  glvalue </h2><br><p>  Ausdr√ºcke in der Kategorie <strong>glvalue</strong> haben folgende Eigenschaften: </p><br><ul><li>  kann implizit in <strong>prvalue</strong> konvertiert <strong>werden</strong> ; </li><li>  kann polymorph sein, das hei√üt, f√ºr sie sind die Konzepte eines statischen und dynamischen Typs sinnvoll; </li><li>  kann nicht vom Typ <strong>void sein</strong> - dies folgt direkt aus der Eigenschaft, eine Identit√§t zu haben, da es f√ºr Ausdr√ºcke vom Typ <strong>void</strong> keinen solchen Parameter gibt, der sie voneinander unterscheiden w√ºrde; </li><li>  kann einen <em>unvollst√§ndigen Typ haben</em> , z. B. in Form einer <em>Vorw√§rtsdeklaration</em> (sofern dies f√ºr einen bestimmten Ausdruck zul√§ssig ist). </li></ul><br><h2 id="rvalue">  rWert </h2><br><p>  Ausdr√ºcke in der Kategorie <strong>rvalue</strong> haben die folgenden Eigenschaften: </p><br><ul><li>  Sie k√∂nnen die <strong>r-Wert-</strong> Adresse nicht im Speicher <strong>abrufen</strong> - dies ergibt sich direkt aus dem Fehlen der Identit√§tseigenschaft. </li><li>  darf sich nicht auf der linken Seite einer Zuweisung oder einer zusammengesetzten Zuweisungsanweisung befinden; </li><li>  kann verwendet werden, um eine konstante <strong>lvalue-</strong> Verkn√ºpfung oder <strong>rvalue-</strong> Verkn√ºpfung zu initialisieren, w√§hrend sich die Lebensdauer des Objekts auf die Lebensdauer der Verkn√ºpfung erstreckt; </li><li>  Wenn beim Aufrufen einer Funktion mit zwei √ºberladenen Versionen ein Argument verwendet wird: Eine akzeptiert eine konstante <strong>l-Wert-</strong> Referenz und die andere eine <strong>r-Wert-</strong> Referenz. Dann wird die Version ausgew√§hlt, die die <strong>r-Wert-</strong> Referenz akzeptiert.  Mit dieser Eigenschaft wird die <em>Verschiebungssemantik</em> implementiert: </li></ul><br><pre> <code class="plaintext hljs">class A { public: A() = default; A(const A&amp;) { std::cout &lt;&lt; "A::A(const A&amp;)\n"; } A(A&amp;&amp;) { std::cout &lt;&lt; "A::A(A&amp;&amp;)\n"; } }; ......... A a; A b(a); //  A(const A&amp;) A c(std::move(a)); //  A(A&amp;&amp;)</code> </pre> <br><blockquote>  Technisch gesehen ist A &amp;&amp; ein <strong>r-Wert</strong> und kann verwendet werden, um sowohl eine konstante <strong>l-Wert-</strong> Referenz als auch eine <strong>r-</strong> <strong>Wert-</strong> Referenz zu initialisieren.  Dank dieser Eigenschaft besteht jedoch keine Mehrdeutigkeit. Es wird eine Konstruktoroption akzeptiert, die eine <strong>r-Wert-</strong> Referenz akzeptiert. </blockquote><br><h2 id="lvalue">  lWert </h2><br><p>  Eigenschaften: </p><br><ul><li>  alle <strong>glvalue-</strong> Eigenschaften (siehe oben); </li><li>  Sie k√∂nnen die Adresse √ºbernehmen (mit dem integrierten un√§ren Operator <code>&amp;</code> ); </li><li>  modifizierbare l-Werte k√∂nnen sich auf der linken Seite des Zuweisungsoperators oder der zusammengesetzten Zuweisungsoperatoren befinden; </li><li>  kann verwendet werden, um eine Referenz auf einen <strong>l-Wert</strong> (sowohl konstant als auch nicht konstant) zu initialisieren. </li></ul><br><p>  Die folgenden Ausdr√ºcke geh√∂ren zur Kategorie <strong>lvalue</strong> : </p><br><ul><li>  Der Name einer Variablen, Funktion oder eines Klassenfelds eines beliebigen Typs.  Selbst wenn die Variable eine <strong>rWertreferenz ist</strong> , ist der Name dieser Variablen im Ausdruck ein <strong>lWert</strong> ; </li></ul><br><pre> <code class="plaintext hljs">void func() {} ......... auto* func_ptr = &amp;func; // :     auto&amp; func_ref = func; // :     int&amp;&amp; rrn = int(123); auto* pn = &amp;rrn; // :    auto&amp; rn = rrn; // :  lvalue-</code> </pre> <br><ul><li>  Aufrufen einer Funktion oder eines √ºberladenen Operators, der eine <strong>lWertreferenz</strong> oder einen Ausdruck der Konvertierung in den Typ einer <strong>lWertreferenz zur√ºckgibt</strong> ; </li><li>  integrierte Zuweisungsoperatoren, zusammengesetzte Zuweisungsoperatoren ( <code>=</code> , <code>+=</code> , <code>/=</code> usw.), integriertes <code>--b</code> und <code>--b</code> ( <code>++a</code> , <code>--b</code> ), integrierter Zeiger-Dereferenzierungsoperator ( <code>*p</code> ); </li><li>  eingebauter Operator f√ºr den Zugriff √ºber den Index ( <code>a[n]</code> oder <code>n[a]</code> ), wenn einer der Operanden ein <strong>lvalue-</strong> Array ist; </li><li>  Aufrufen einer Funktion oder einer √ºberladenen Anweisung, die einen <strong>r-Wert-</strong> Verweis auf eine Funktion zur√ºckgibt; </li><li>  String-Literal wie <code>"Hello, world!"</code>  . </li></ul><br><blockquote>  Ein String-Literal unterscheidet sich von allen anderen Literalen in C ++ genau dadurch, dass es ein <strong>l-Wert ist</strong> (wenn auch unver√§nderlich).  Zum Beispiel k√∂nnen Sie seine Adresse erhalten: </blockquote><br><pre> <code class="plaintext hljs">auto* p = &amp;‚ÄùHello, world!‚Äù; //   ,   </code> </pre> <br><h2 id="prvalue">  Wert </h2><br><p>  Eigenschaften: </p><br><ul><li>  alle <strong>rvalue-</strong> Eigenschaften (siehe oben); </li><li>  kann nicht polymorph sein: statische und dynamische Ausdruckstypen fallen immer zusammen; </li><li>  kann nicht von einem unvollst√§ndigen Typ sein (mit Ausnahme des <strong>Leertyps</strong> wird dies unten diskutiert); </li><li>  kann keinen abstrakten Typ haben oder ein Array von Elementen eines abstrakten Typs sein. </li></ul><br><p>  Die folgenden Ausdr√ºcke geh√∂ren zur Kategorie <strong>prvalue</strong> : </p><br><ul><li>  Literal (au√üer Zeichenfolge), zum Beispiel <code>42</code> , <code>true</code> oder <code>nullptr</code> ; </li><li>  Ein Funktionsaufruf oder ein √ºberladener Operator, der eine <code>str.substr(1, 2)</code> ( <code>str.substr(1, 2)</code> , <code>str1 + str2</code> , <code>it++</code> ) oder einen Konvertierungsausdruck in einen <code>str1 + str2</code> (z. B. <code>static_cast&lt;double&gt;(x)</code> , <code>std::string{}</code> , <code>(int)42</code> ); </li><li>  <code>b--</code> und <code>b--</code> ( <code>a++</code> , <code>b--</code> ), eingebaute mathematische Operationen ( <code>a + b</code> , <code>a % b</code> , <code>a &amp; b</code> , <code>a &lt;&lt; b</code> usw.), eingebaute logische Operationen ( <code>a &amp;&amp; b</code> , <code>a || b</code> <code>!a</code> usw.), Vergleichsoperationen ( <code>a &lt; b</code> , <code>a == b</code> , <code>a &gt;= b</code> usw.), die eingebaute Operation zum Aufnehmen der Adresse ( <code>&amp;a</code> ); </li><li>  <strong>dieser</strong> Zeiger; </li><li>  Auflistung Artikel; </li><li>  atypischer Vorlagenparameter, wenn es sich nicht um eine Klasse handelt; </li><li>  Lambda-Ausdruck, zum Beispiel <code>[](int x){ return x * x; }</code>  <code>[](int x){ return x * x; }</code> . </li></ul><br><h2 id="xvalue">  xvalue </h2><br><p>  Eigenschaften: </p><br><ul><li>  alle <strong>rvalue-</strong> Eigenschaften (siehe oben); </li><li>  alle <strong>glvalue-</strong> Eigenschaften (siehe oben). </li></ul><br><p>  Beispiele f√ºr <strong>xvalue-</strong> Ausdr√ºcke: </p><br><ul><li>  Aufrufen einer Funktion oder eines integrierten Operators, der eine <strong>r-Wert-</strong> Referenz <strong>zur√ºckgibt</strong> , z. B. <em>std :: move (x)</em> ; </li></ul><br><blockquote>  Tats√§chlich k√∂nnen Sie f√ºr das Ergebnis des Aufrufs von <em>std :: move ()</em> keine Adresse im Speicher abrufen oder eine Verkn√ºpfung dazu initialisieren, aber gleichzeitig kann dieser Ausdruck polymorph sein: </blockquote><br><pre> <code class="plaintext hljs">struct XA { virtual void f() { std::cout &lt;&lt; "XA::f()\n"; } }; struct XB : public XA { virtual void f() { std::cout &lt;&lt; "XB::f()\n"; } }; XA&amp;&amp; xa = XB(); auto* p = &amp;std::move(xa); //  auto&amp; r = std::move(xa); //  std::move(xa).f(); //  ‚ÄúXB::f()‚Äù</code> </pre> <br><ul><li>  <strong>Eingebauter</strong> Operator f√ºr den Zugriff nach Index ( <code>a[n]</code> oder <code>n[a]</code> ), wenn einer der Operanden ein <strong>rvalue-</strong> Array ist. </li></ul><br><h2 id="nekotorye-osobye-sluchai">  Einige Sonderf√§lle </h2><br><h3 id="operator-zapyataya">  Komma-Operator </h3><br><p>  F√ºr den integrierten Kommaoperator stimmt die Ausdruckskategorie immer mit der Ausdruckskategorie des zweiten Operanden √ºberein. </p><br><pre> <code class="plaintext hljs">int n = 0; auto* pn = &amp;(1, n); // lvalue auto&amp; rn = (1, n); // lvalue 1, n = 2; // lvalue auto* pt = &amp;(1, int(123)); // , rvalue auto&amp; rt = (1, int(123)); // , rvalue</code> </pre> <br><h2 id="vyrazheniya-tipa-void">  Leere Ausdr√ºcke </h2><br><p>  Aufrufe von Funktionen, die <strong>void zur√ºckgeben</strong> , Konvertierungsausdr√ºcke in <strong>void</strong> <strong>umwandeln</strong> und Ausnahmen <strong>ausl√∂sen</strong> , werden als <strong>prvalue-</strong> Ausdr√ºcke betrachtet, k√∂nnen jedoch nicht zum Initialisieren von Referenzen oder als Argumente f√ºr Funktionen verwendet werden. </p><br><h2 id="ternarnyy-operator-sravneniya">  Tern√§rer Vergleichsoperator </h2><br><p>  Definition der Ausdruckskategorie <code>a ? b : c</code>  <code>a ? b : c</code> - der Fall ist nicht trivial, alles h√§ngt von den Kategorien des zweiten und dritten Arguments ab ( <code>b</code> und <code>c</code> ): </p><br><ul><li>  Wenn <code>b</code> oder <code>c</code> vom Typ <strong>void sind</strong> , entsprechen die Kategorie und der Typ des gesamten Ausdrucks der Kategorie und dem Typ des anderen Arguments.  Wenn beide Argumente vom Typ <strong>void sind</strong> , ist das Ergebnis ein <strong>Wert vom</strong> Typ <strong>void</strong> . </li><li>  Wenn <code>b</code> und <code>c</code> <strong>Gl-Werte</strong> desselben Typs sind, ist das Ergebnis ein <strong>Gl-Wert</strong> desselben Typs. </li><li>  In anderen F√§llen ist das Ergebnis ein Wert. </li></ul><br><p>  F√ºr den tern√§ren Operator wird eine Reihe von Regeln definiert, nach denen implizite Konvertierungen auf die Argumente b und c angewendet werden k√∂nnen. Dies geht jedoch etwas √ºber den <strong><em>Rahmen des Artikels hinaus. Wenn</em></strong> Sie interessiert sind, empfehle ich, <strong><em>auf den</em></strong> Abschnitt <strong><em>Bedingter Operator [Ausdruck]</em></strong> des Standards zu <strong><em>verweisen</em></strong> . </p><br><pre> <code class="plaintext hljs">int n = 1; int v = (1 &gt; 2) ? throw 1 : n; // lvalue, .. throw   void,    n ((1 &lt; 2) ? n : v) = 2; //  lvalue,  ,   ((1 &lt; 2) ? n : int(123)) = 2; //   , ..    prvalue</code> </pre> <br><h2 id="obrascheniya-k-polyam-i-metodam-klassov-i-struktur">  Verweise auf Felder und Methoden von Klassen und Strukturen </h2><br><p>  F√ºr Ausdr√ºcke der Form <code>am</code> und <code>p-&gt;m</code> (hier geht es um den eingebauten Operator <code>-&gt;</code> ) gelten folgende Regeln: </p><br><ul><li>  Wenn <code>m</code> ein Aufz√§hlungselement oder eine nicht statische Klassenmethode ist, wird der gesamte Ausdruck als <strong>prvalue betrachtet</strong> (obwohl die Verkn√ºpfung mit einem solchen Ausdruck nicht initialisiert werden kann). </li><li>  Wenn <code>a</code> ein <strong>rWert</strong> und <code>m</code> ein nicht statisches Feld eines <strong>Nichtreferenztyps</strong> ist, geh√∂rt der gesamte Ausdruck zur Kategorie <strong>xWert</strong> . </li><li>  sonst ist es ein <strong>Wert</strong> . </li></ul><br><p>  F√ºr Zeiger auf Klassenmitglieder ( <code>a.*mp</code> und <code>p-&gt;*mp</code> ) gelten folgende Regeln: </p><br><ul><li>  Wenn <code>mp</code> ein Zeiger auf eine Klassenmethode ist, wird der gesamte Ausdruck als <strong>prvalue betrachtet</strong> . </li><li>  Wenn <code>a</code> ein <strong>r-Wert</strong> ist und <code>mp</code> ein Zeiger auf ein Datenfeld ist, bezieht sich der gesamte Ausdruck auf <strong>x-Wert</strong> . </li><li>  sonst ist es ein <strong>Wert</strong> . </li></ul><br><h2 id="bitovye-polya">  Bitfelder </h2><br><p>  Bitfelder sind ein praktisches Werkzeug f√ºr die Programmierung auf niedriger Ebene, ihre Implementierung liegt jedoch etwas au√üerhalb der allgemeinen Struktur von Ausdruckskategorien.  Beispielsweise scheint ein Aufruf eines <strong>Bitfelds</strong> ein <strong>Wert zu sein</strong> , <strong>da er</strong> m√∂glicherweise auf der linken Seite des Zuweisungsoperators vorhanden ist.  Gleichzeitig funktioniert es nicht, die Adresse des Bitfelds zu √ºbernehmen oder eine nicht konstante Verbindung durch diese zu initialisieren.  Sie k√∂nnen einen konstanten Verweis auf ein Bitfeld initialisieren, es wird jedoch eine tempor√§re Kopie des Objekts erstellt: </p><br><blockquote>  <strong><em>Bitfelder [class.bit]</em></strong> <br>  <em>Wenn der Initialisierer f√ºr eine Referenz vom Typ const T &amp; ein Wert ist, der sich auf ein Bitfeld bezieht, ist die Referenz an eine tempor√§re Initialisierung gebunden, die den Wert des Bitfelds enth√§lt.</em>  <em>Die Referenz ist nicht direkt an das Bitfeld gebunden.</em> </blockquote><br><pre> <code class="plaintext hljs">struct BF { int f:3; }; BF b; bf = 1; // OK auto* pb = &amp;b.f; //  auto&amp; rb = bf; // </code> </pre> <br><h2 id="vmesto-zaklyucheniya">  Anstelle einer Schlussfolgerung </h2><br><p>  Wie ich in der Einleitung erw√§hnt habe, erhebt die obige Beschreibung keinen Anspruch auf Vollst√§ndigkeit, sondern gibt nur einen allgemeinen √úberblick √ºber die Kategorien von Ausdr√ºcken.  Diese Ansicht bietet ein etwas besseres Verst√§ndnis der Abs√§tze des Standards und der Compiler-Fehlermeldungen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de441742/">https://habr.com/ru/post/de441742/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de441728/index.html">Zusammenfassung des Online-Wettbewerbs f√ºr das Spiel Blotto</a></li>
<li><a href="../de441732/index.html">Notizen des Bioroboters</a></li>
<li><a href="../de441736/index.html">Automatisieren Sie die Konvertierung von Word-Dateien in andere Formate</a></li>
<li><a href="../de441738/index.html">Thermoakustische Grundlagen</a></li>
<li><a href="../de441740/index.html">Habra Megarating: Die besten Artikel und Statistiken von Habr seit 12 Jahren. Teil 1/2</a></li>
<li><a href="../de441744/index.html">Abrufen von Links zu Vk-Profilen aus SearchFace-Ergebnissen mit Python (dies ist jedoch nicht korrekt)</a></li>
<li><a href="../de441750/index.html">Projekte auf CodeFest: Wie kann ein Manager in einer sich st√§ndig ver√§ndernden Welt √ºberleben?</a></li>
<li><a href="../de441752/index.html">ZTE zeigte eine Smartphoneuhr Œ±</a></li>
<li><a href="../de441754/index.html">Kubernetes Erfolgsgeschichten in der Produktion. Teil 10: Reddit</a></li>
<li><a href="../de441756/index.html">F√ºr die russische Plattform von Industrie-PCs nahmen sie die Baikal-T1-Prozessoren und das Alt-Betriebssystem</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>