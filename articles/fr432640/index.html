<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🈶 🤾🏿 🌬️ Version Rust 1.31 et Rust 2018 📱 🛏️ 👨‍👨‍👧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'équipe de développement de Rust est heureuse d'annoncer la sortie d'une nouvelle version de Rust, 1.31.0, ainsi que "Rust 2018". Rust est un langage...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Version Rust 1.31 et Rust 2018</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432640/"><p>  L'équipe de développement de Rust est heureuse d'annoncer la sortie d'une nouvelle version de Rust, 1.31.0, ainsi que "Rust 2018".  Rust est un langage de programmation qui permet à chacun de créer des logiciels fiables et efficaces. </p><br><p> Si vous avez une version précédente de Rust installée à l'aide de <code>rustup</code> , alors pour mettre à niveau Rust vers la version 1.31.0, il vous suffit de faire: </p><br><pre> <code class="bash hljs">$ rustup update stable</code> </pre> <br><p>  Si vous n'avez pas encore installé <code>rustup</code> , vous pouvez l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">installer à</a> partir de la page correspondante de notre site Web.  <a href="">Des notes de version détaillées pour Rust 1.31.0</a> sont disponibles sur GitHub. </p><br><h2 id="chto-voshlo-v-stabilnuyu-versiyu-1310">  Ce qui est inclus dans la version stable 1.31.0 </h2><br><p>  Rust 1.31 est sans doute la version la plus importante depuis Rust 1.0!  La première itération de «Rust 2018» est incluse dans cette version, mais ce n'est pas la seule innovation!  L'examen des améliorations sera long, voici donc la table des matières: </p><br><ul><li>  <strong>Rouille 2018</strong> <br><ul><li>  <strong>Temps de vie non lexicaux</strong> </li><li>  <strong>Modifications du système des modules</strong> </li></ul></li><li>  <strong>Règles supplémentaires pour l'affichage des durées de vie</strong> </li><li> <strong><code>const fn</code></strong> </li> <li>  <strong>De nouveaux outils</strong> </li><li>  <strong>Contrôles de qualité du code instrumental</strong> </li><li>  <strong>La documentation</strong> </li><li>  <strong>Groupes de travail thématiques</strong> </li><li>  <strong>Nouveau site web</strong> </li><li>  <strong>Stabilisation de la bibliothèque standard</strong> </li><li>  <strong>Améliorations du fret</strong> </li><li>  <strong>Développeurs de versions</strong> </li></ul><a name="habracut"></a><br><h3 id="rust-2018">  Rouille 2018 </h3><br><p>  Nous avons écrit sur Rust 2018 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pour la première fois en mars</a> , puis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">en juillet</a> .  Pour plus de détails sur les <em>raisons pour lesquelles vous avez</em> besoin de Rust 2018, reportez-vous à ces publications.  Dans cette revue, il y a tellement de choses à nous dire, nous allons donc nous concentrer uniquement sur ce qu'est Rust 2018. Vous pouvez également lire à ce sujet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans un article sur Mozilla Hacks</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">traduction</a> ). </p><br><p>  En bref, Rust 2018 est une opportunité d'intégrer tout le travail que nous avons accompli au cours des trois dernières années dans un ensemble cohérent.  Rust 2018 est bien plus qu'un tas d'améliorations linguistiques.  En plus d'eux, il comprend: </p><br><ul><li>  Toolkit (support dans IDE, <code>rustfmt</code> , Clippy) </li><li>  La documentation </li><li>  Groupes de travail thématiques </li><li>  Nouveau site web </li></ul><br><p>  Plus loin, nous parlerons de tout cela plus en détail et d'autres innovations. </p><br><p>  Créons un nouveau projet en utilisant Cargo: </p><br><pre> <code class="plaintext hljs">$ cargo new foo</code> </pre> <br><p>  Voici le contenu de <code>Cargo.toml</code> : </p><br><pre> <code class="plaintext hljs">[package] name = "foo" version = "0.1.0" authors = ["Your Name &lt;you@example.com&gt;"] edition = "2018" [dependencies]</code> </pre> <br><p>  Une nouvelle clé a été ajoutée à la section <code>[package]</code> : <code>edition</code> .  Veuillez noter qu'il est installé en <code>2018</code> .  Vous pouvez également l'installer en <code>2015</code> - cette valeur sera définie par défaut si la clé est manquante. </p><br><p>  L'utilisation de Rust 2018 débloquera de nouvelles fonctionnalités qui ne sont pas autorisées dans Rust 2015. </p><br><p>  Il est important de noter que chaque package peut être en mode 2015 ou 2018 et fonctionnera ensemble.  Votre projet de l'édition 2018 peut utiliser les dépendances de l'édition 2015 et le projet de l'édition 2015 peut utiliser les dépendances de l'édition 2018.  Cela garantit l'intégrité de l'écosystème et que toutes les nouvelles fonctionnalités seront facultatives, tout en conservant la compatibilité avec le code existant.  En outre, lorsque vous décidez de porter le code de Rust 2015 sur Rust 2018, des modifications peuvent être apportées automatiquement via la <code>cargo fix</code> . </p><br><p>  Vous pouvez vous demander: qu'en est-il des nouvelles fonctionnalités elles-mêmes?  Premièrement, ils sont également ajoutés dans Rust 2015, s'ils sont compatibles avec les fonctionnalités de cette édition.  Ainsi, la plupart de la langue reste la même partout.  Vous pouvez consulter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le manuel éditorial</a> pour connaître la version minimale de <code>rustc</code> pour chaque nouvelle fonctionnalité et ses autres exigences.  Cependant, il existe plusieurs grandes innovations qui doivent être mentionnées séparément: les durées de vie non lexicales et certains changements dans le système de modules. </p><br><h4 id="neleksicheskie-vremena-zhizni">  Temps de vie non lexicaux </h4><br><p>  Si vous suivez Rust au cours des dernières années, vous pouvez parfois rencontrer le terme «NLL» ou «durées de vie non lexicales».  C'est du jargon qui, en termes simples, signifie: l'emprunteur est devenu plus intelligent et accepte maintenant un code correct, qu'il a rejeté auparavant.  Prenons un exemple: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> x = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y = &amp;x; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> z = &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> x; }</code> </pre> <br><p>  Rust utilisé pour lancer une erreur de compilation: </p><br><pre> <code class="plaintext hljs">error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable --&gt; src/main.rs:5:18 | 4 | let y = &amp;x; | - immutable borrow occurs here 5 | 6 | let z = &amp;mut x; | ^ mutable borrow occurs here 7 | } | - immutable borrow ends here</code> </pre> <br><p>  En effet, le domaine de vie des liens a été défini «lexicalement»;  c'est-à-dire que l'emprunt de <code>y</code> était considéré comme actif jusqu'à ce que <code>y</code> sorte du champ à la fin du <code>main</code> , même si nous n'utilisons plus jamais <code>y</code> dans le champ.  Tout va bien avec le code ci-dessus, mais l'analyseur de dépendances ne pouvait pas comprendre cela. </p><br><p>  Maintenant, ce code se compile très bien. </p><br><p>  Et si on utilisait <code>y</code> ?  Par exemple, comme ceci: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> x = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y = &amp;x; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> z = &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> x; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"y: {}"</span></span>, y); }</code> </pre> <br><p>  La rouille vous donnait cette erreur: </p><br><pre> <code class="plaintext hljs">error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable --&gt; src/main.rs:5:18 | 4 | let y = &amp;x; | - immutable borrow occurs here 5 | let z = &amp;mut x; | ^ mutable borrow occurs here ... 8 | } | - immutable borrow ends here</code> </pre> <br><p>  Dans Rust 2018, ce message d'erreur s'est amélioré: </p><br><pre> <code class="plaintext hljs">error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable --&gt; src/main.rs:5:13 | 4 | let y = &amp;x; | -- immutable borrow occurs here 5 | let z = &amp;mut x; | ^^^^^^ mutable borrow occurs here 6 | 7 | println!("y: {}", y); | - borrow later used here</code> </pre> <br><p>  Au lieu d'indiquer où <code>y</code> sort du domaine, il montre où se produisent les emprunts conflictuels.  Cela simplifie considérablement les erreurs de débogage de ce type. </p><br><p>  Dans Rust 1.31, il s'agit d'une amélioration exclusivement pour Rust 2018. Nous prévoyons de l'ajouter à Rust 2015 plus tard. </p><br><h4 id="izmeneniya-sistemy-moduley">  Modifications du système des modules </h4><br><p>  Le système de modules peut être difficile pour les personnes qui apprennent Rust pour la première fois.  Bien sûr, il y a toujours quelque chose qui prend du temps à maîtriser.  Mais la raison principale pour laquelle les modules sont si embarrassants pour beaucoup est que malgré les règles simples et cohérentes qui définissent le système des modules, les conséquences de leur utilisation peuvent sembler contradictoires, mystérieuses et contre nature. </p><br><p>  Par conséquent, l'édition 2018 apporte quelques modifications au fonctionnement des chemins, simplifiant le système de modules et le rendant plus compréhensible. </p><br><p>  Voici un bref résumé: </p><br><ul><li>  <code>extern crate</code> n'est plus requise presque partout ailleurs. </li><li>  Vous pouvez importer des macros à l'aide de <code>use</code> , au lieu d'utiliser l'attribut <code>#[macro_use]</code> . </li><li>  Les chemins absolus commencent par le nom du conteneur, où le mot clé <code>crate</code> fait référence au conteneur actuel. </li><li>  <code>foo.rs</code> et le sous <code>foo/</code> répertoire <code>foo/</code> peuvent coexister;  <code>mod.rs</code> n'est plus requis lors du placement de sous-modules dans un sous-répertoire. </li></ul><br><p>  Cela ressemble à un ensemble arbitraire de règles, mais en général, le modèle mental a maintenant été considérablement simplifié. </p><br><p>  Il y a encore <em>beaucoup de</em> détails, veuillez vous référer au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">manuel éditorial</a> pour tous les détails. </p><br><h3 id="dopolnitelnye-pravila-vyvoda-vremen-zhizni">  Règles supplémentaires pour l'affichage des durées de vie </h3><br><p>  Parlons de l'amélioration disponible dans les deux éditions: nous avons ajouté quelques règles d'inférence supplémentaires pour les blocs <code>impl</code> et les définitions de fonctions.  Code comme celui-ci: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; Reader <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> BufReader&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre> <br><p>  peut maintenant être écrit comme ceci: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Reader <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> BufReader&lt;<span class="hljs-symbol"><span class="hljs-symbol">'_</span></span>&gt; { <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre> <br><p>  Lifetime <code>'_</code> montre toujours que <code>BufReader</code> prend comme paramètre, mais nous n'avons plus besoin de lui donner de nom. </p><br><p>  Les durées de vie doivent encore être définies dans les structures.  Cependant, nous n'avons plus besoin d'écrire autant de code passe-partout qu'auparavant: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// Rust 2015 struct Ref&lt;'a, T: 'a&gt; { field: &amp;'a T } // Rust 2018 struct Ref&lt;'a, T&gt; { field: &amp;'a T }</span></span></code> </pre> <br><p>  Dépendance <code>: 'a</code> sera affiché.  Vous pouvez toujours le spécifier explicitement si vous le souhaitez.  Nous envisageons d'autres possibilités de retrait dans de tels endroits pour l'avenir, mais jusqu'à présent, nous n'avons aucun plan concret. </p><br><h3 id="const-fn"> <code>const fn</code> </h3> <br><p>  Rust a plusieurs façons de déclarer une fonction: <code>fn</code> pour les fonctions ordinaires, <code>unsafe fn</code> dangereux pour les fonctions dangereuses et <code>extern fn</code> pour les fonctions externes.  Cette version ajoute une nouvelle façon de déclarer une fonction: <code>const fn</code> .  Il est utilisé comme ceci: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> { x + <span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre> <br><p>  Une fonction constante peut être appelée comme une fonction normale, mais en plus, elle peut être utilisée dans n'importe quel contexte constant.  Cependant, il sera exécuté au moment de la compilation et non pendant l'exécution du programme.  Par exemple: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SIX: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> = foo(<span class="hljs-number"><span class="hljs-number">5</span></span>);</code> </pre> <br><p>  La fonction <code>foo</code> s'exécutera au moment de la compilation et <code>SIX</code> sera défini sur <code>6</code> . </p><br><p>  Les fonctions constantes ne peuvent pas faire tout ce que les fonctions normales peuvent faire: elles doivent avoir un résultat déterministe.  Ceci est important pour des raisons de fiabilité.  Dans la forme actuelle, les fonctions constantes peuvent effectuer un sous-ensemble minimal d'opérations.  Voici quelques exemples de ce que vous pouvez y faire: </p><br><ul><li>  Utiliser des opérations d'arithmétique et de comparaison entières </li><li>  Utilisez toutes les opérations logiques sauf <code>&amp;&amp;</code> et <code>||</code> </li><li>  Concevoir des tableaux, des structures, des énumérations et des tuples </li><li>  Appeler d'autres fonctions constantes </li><li>  Accès par index dans des tableaux et des tranches </li><li>  Accéder aux domaines des structures et des tuples </li><li>  Utilisez des constantes (mais pas des valeurs statiques, ni même des références à celles-ci) </li><li>  Utiliser les liens <code>&amp;</code> et <code>*</code> </li><li>  Types de transtypage sauf le pointeur brut transtypé en valeur entière </li></ul><br><p>  Nous allons étendre les capacités des fonctions constantes, mais l'ensemble ci-dessus est déjà suffisant pour utiliser <code>const fn</code> en pratique. </p><br><p>  Voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le manuel pour</a> plus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">de</a> détails. </p><br><h3 id="novye-instrumenty">  De nouveaux outils </h3><br><p>  L'édition 2018 marque le début d'un nouveau niveau de maturité pour l'écosystème d'outils Rust.  Cargo, Rustdoc et Rustup sont les principaux outils depuis la version 1.0;  Avec l'édition 2018, une nouvelle génération d'outils arrive que tout le monde peut désormais utiliser: Clippy, Rustfmt et le support IDE. </p><br><p>  L'analyseur de code statique <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>clippy</code></a> est maintenant disponible dans Rust stable.  Vous pouvez l'installer via le <code>rustup component add clippy</code> et l'exécuter avec la <code>cargo clippy</code> .  Clippy a maintenant reçu la version 1.0 et a les mêmes garanties de stabilité pour les contrôles statiques que rustc.  De nouveaux contrôles peuvent être ajoutés ou la fonctionnalité des anciens peut être étendue, mais les anciens ne peuvent pas être supprimés (ils peuvent uniquement être marqués comme obsolètes).  Cela signifie que le code qui compile avec clippy continuera de compiler avec clippy (en supposant qu'aucune vérification n'est définie pour générer <br>  erreur via <code>deny</code> ), mais peut générer de nouveaux avertissements. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rustfmt</a> est un outil de formatage de code dans Rust.  Le formatage automatique du code vous fera gagner du temps, en plus, il rapprochera votre code du <a href="">style officiel de Rust</a> .  Vous pouvez l'installer via le <code>rustup component add rustfmt</code> et utiliser la commande <code>cargo fmt</code> . </p><br><p>  La version actuelle comprend Rustfmt 1.0.  Désormais, nous garantissons la compatibilité descendante de Rustfmt: si vous formatez votre code aujourd'hui, le formatage ne changera pas à l'avenir (uniquement pour les paramètres par défaut).  La compatibilité descendante signifie qu'il est désormais pratique d'exécuter Rustfmt sur votre CI (utilisez <code>cargo fmt --check</code> ).  Essayez ceci avec «formatage lors de l'enregistrement» dans l'éditeur, et votre flux de travail sera révolutionné. </p><br><p>  Le support IDE est l'une des fonctionnalités les plus demandées pour Rust.  Il existe maintenant plusieurs solutions de haute qualité: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Code Visual Studio</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IntelliJ</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Atome</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Texte sublime 3</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Eclipse</a> </li></ul><br><p>  Le travail de support dans l'IDE n'est pas terminé.  En particulier, la complétion de code dans les éditeurs basés sur RLS n'est pas à la hauteur.  Cependant, si vous souhaitez principalement prendre en charge les types, la documentation et la «transition vers la définition», vous serez satisfait. </p><br><h3 id="instrumentalnye-proverki-kachestva-koda-tool-lints">  Contrôles de qualité du code instrumental (lints d'outils) </h3><br><p>  Dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rust 1.30,</a> nous avons stabilisé les "attributs instrumentaux" tels que <code>#[rustfmt::skip]</code> .  Dans Rust 1.31, nous avons stabilisé quelque chose comme ceci: "tool lints" comme <code>#[allow(clippy::bool_comparison)]</code> .  Cela vous permet de spécifier des espaces de noms pour les vérifications afin de clarifier les outils dont ils proviennent. </p><br><p>  Si vous avez déjà utilisé des contrôles Clippy, vous pouvez migrer comme suit: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//  #![cfg_attr(feature = "cargo-clippy", allow(bool_comparison))] //  #![allow(clippy::bool_comparison)]</span></span></code> </pre> <br><p>  Vous n'avez plus besoin de <code>cfg_attr</code> !  Vous recevrez également des avertissements qui vous aideront à passer à l'utilisation du nouveau style. </p><br><h3 id="dokumentaciya">  La documentation </h3><br><p>  Cette année, Rustdoc a connu plusieurs améliorations et le livre entièrement réécrit, The Rust Programming Language, a été publié.  Vous pouvez acheter une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">copie papier de No Starch Press</a> ! </p><br><p>  Il s'appelait auparavant la «deuxième édition» du livre, mais depuis qu'il est devenu la première édition imprimée, cela a semé la confusion.  Après tout, l'édition imprimée devrait être mise à jour périodiquement.  En fin de compte, après de nombreuses discussions avec No Starch, il a été décidé de mettre à jour le livre sur le site Web avec chaque version, et No Starch reprendrait périodiquement les modifications et les imprimerait.  Le livre se vend assez bien et recueille des fonds pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Black Girls Code</a> . </p><br><p>  Vous pouvez trouver la nouvelle version du livre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </p><br><h3 id="predmetnye-rabochie-gruppy">  Groupes de travail thématiques </h3><br><p>  Cette année, nous avons annoncé la création de quatre groupes de travail: </p><br><ul><li>  Services réseau </li><li>  Applications en ligne de commande </li><li>  Webassembly </li><li>  Appareils embarqués </li></ul><br><p>  Les groupes ont travaillé très dur pour améliorer Rust dans chacun de ces domaines.  Voici quelques réalisations: </p><br><ul><li>  Les services réseau ont repensé l'interface pour Futures, et en plus async / wait.  Ces améliorations n'ont pas encore été publiées, mais nous en sommes déjà proches! </li><li>  L'équipe CLI a travaillé sur les bibliothèques et la documentation pour améliorer les applications en ligne de commande. </li><li>  WebAssembly a publié de nombreux outils de classe mondiale pour utiliser Rust avec wasm. </li><li>  Pour les appareils embarqués, il est devenu possible de développer ARM sur une Rust stable! </li></ul><br><p>  Vous pouvez en savoir plus sur tout cela sur notre nouveau site! </p><br><h3 id="novyy-veb-sayt">  Nouveau site web </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La semaine dernière,</a> nous avons annoncé une nouvelle version de notre site Web.  Maintenant, c'est devenu la version officielle de rust-lang.org! </p><br><p>  Pour le créer, il a fallu un an de travail à de nombreuses personnes.  Bien qu'il reste encore beaucoup à faire avant son achèvement, nous sommes fiers du travail accompli. </p><br><h3 id="stabilizaciya-standartnoy-biblioteki">  Stabilisation de la bibliothèque standard </h3><br><p>  <code>From</code> nouvelles implémentations <code>From</code> ont été ajoutées: </p><br><ul><li>  <code>u8</code> implémente désormais <code>From&lt;NonZeroU8&gt;</code> , de même pour les autres types numériques et leurs équivalents non <code>NonZero</code> </li><li>  <code>Option&lt;&amp;T&gt;</code> implémente <code>From&lt;&amp;Option&lt;T&gt;&gt;</code> , de manière similaire à <code>&amp;mut</code> </li></ul><br><p>  Les fonctions suivantes ont également été stabilisées: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>slice::align_to</code></a> et son homologue mutable </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>slice::chunks_exact</code></a> , ainsi que ses homologues mutables et <code>r</code> (tels que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>slice::rchunks_exact_mut</code></a> ) dans toutes les combinaisons </li></ul><br><p>  Voir <a href="">les notes de version pour plus de</a> détails. </p><br><h3 id="uluchsheniya-v-cargo">  Améliorations du fret </h3><br><p>  Cargo chargera désormais les colis en parallèle à l'aide de HTTP / 2. </p><br><p>  De plus, comme la <code>extern crate</code> désormais facultative, il serait frustrant d'écrire la <code>extern crate foo as bar;</code>  pour renommer la dépendance.  Par conséquent, vous pouvez le faire dans <code>Cargo.toml</code> cette façon: </p><br><pre> <code class="plaintext hljs">[dependencies] baz = { version = "0.1", package = "foo" }</code> </pre> <br><p>  ou, de manière équivalente: </p><br><pre> <code class="plaintext hljs">[dependencies.baz] version = "0.1" package = "foo"</code> </pre> <br><p>  Le paquet <code>foo</code> est maintenant disponible en tant que <code>baz</code> pour une utilisation dans votre code. </p><br><p>  Voir <a href="">les notes de version pour plus de</a> détails. </p><br><h2 id="razrabotchiki-1310">  Développeurs 1.31.0 </h2><br><p>  Habituellement, à la fin de la revue, nous remercions les <a href="">personnes qui ont contribué à la publication</a> .  Mais cette fois, contrairement au passé, cette liste ne couvre pas entièrement toutes les personnes qui ont aidé, ni toute la quantité de travail qui a été fait.  Chaque version régulière est le résultat de six semaines de travail, mais cette version est l'aboutissement de trois années d'efforts, reflétées dans la myriade de référentiels créés par un grand nombre de personnes.  Nous avons été ravis de travailler avec vous tous et nous sommes impatients de poursuivre le développement de Rust au cours des trois prochaines années. </p><br><p>  <em>De la part d'un traducteur: Je remercie tout particulièrement les membres de la communauté Rustycrate et personnellement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@dashadee</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">ozkriff</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">humbug</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">mvlabat</a> pour leur aide avec la traduction et la relecture.</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr432640/">https://habr.com/ru/post/fr432640/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr432630/index.html">Tout ce que vous vouliez savoir sur le traitement des requêtes, mais vous avez hésité à demander</a></li>
<li><a href="../fr432632/index.html">L'histoire de Lenny, le troll de téléphone spam préféré d'Internet Troll</a></li>
<li><a href="../fr432634/index.html">Présentation de cinq bibliothèques de développement Web HTTP</a></li>
<li><a href="../fr432636/index.html">Tutoriel React Partie 1: Présentation du cours, React, ReactDOM et JSX Raisons de la popularité</a></li>
<li><a href="../fr432638/index.html">Nouveautés d'Upsource 2018.2</a></li>
<li><a href="../fr432642/index.html">Utilisation de DeviceLock DLP et Citrix Xen pour contrôler les e-mails sur les appareils mobiles</a></li>
<li><a href="../fr432644/index.html">Imprimante 3D haute température Intamsys FUNMAT HT en un coup d'œil</a></li>
<li><a href="../fr432646/index.html">Fusion équilibrée de haut en bas et de bas en haut</a></li>
<li><a href="../fr432648/index.html">Comment nous sommes entrés sur le marché des fournisseurs de cloud et sommes tombés amoureux du B2B. Case MCS</a></li>
<li><a href="../fr432650/index.html">Collection d'exigences pour un projet logiciel - sans coupures</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>