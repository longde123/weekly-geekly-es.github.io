<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§≥üèΩ ü•í üíä Nous cr√©ons un jeu de plateforme portable sur le microcontr√¥leur Cortex M0 + üçÖ ‚èÆÔ∏è üåò</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√©sentation 
 (Des liens vers le code source et le projet KiCAD sont fournis √† la fin de l'article.) 

 Bien que nous soyons n√©s √† l'√®re 8 bits, notr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous cr√©ons un jeu de plateforme portable sur le microcontr√¥leur Cortex M0 +</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466323/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/mg/8v/j_/mg8vj_mlkkh99th0jwxuun5mudk.png"></div><br><h2>  Pr√©sentation </h2><br>  <em>(Des liens vers le code source et le projet KiCAD sont fournis √† la fin de l'article.)</em> <br><br>  Bien que nous soyons n√©s √† l'√®re 8 bits, notre premier ordinateur √©tait l'Amiga 500. Il s'agit d'une excellente machine 16 bits avec des graphismes et un son incroyables, ce qui la rend id√©ale pour les jeux.  La plateforme est devenue un genre de jeu tr√®s populaire sur cet ordinateur.  Beaucoup d'entre eux √©taient tr√®s color√©s et avaient un d√©filement de parallaxe tr√®s lisse.  Cela a √©t√© rendu possible gr√¢ce √† des programmeurs talentueux qui ont ing√©nieusement utilis√© des coprocesseurs Amiga pour augmenter le nombre de couleurs d'√©cran.  Jetez un ≈ìil √† LionHeart par exemple! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/567/0f4/c54/5670f4c541f76158b62e57d951a0f83f.png"></div><br>  <i>C≈ìur de Lion sur Amiga.</i>  <i>Cette image statique ne transmet pas la beaut√© des graphiques.</i> <br><br>  Depuis les ann√©es 90, l'√©lectronique a beaucoup chang√© et maintenant il existe de nombreux petits microcontr√¥leurs qui vous permettent de cr√©er des choses incroyables. <br><br>  Nous avons toujours aim√© les jeux de plate-forme et aujourd'hui, pour seulement quelques dollars, vous pouvez acheter Raspberry Zero, installer Linux et ¬´assez facile¬ª √©crire un jeu de plate-forme color√©. <br><br>  Mais cette t√¢che n'est pas pour nous - nous ne voulons pas tirer sur des moineaux avec un canon! <br><br>  Nous voulons utiliser des microcontr√¥leurs avec une m√©moire limit√©e, et non un syst√®me puissant sur une puce avec un GPU int√©gr√©!  En d'autres termes, nous voulons des difficult√©s! <br><a name="habracut"></a><br>  Soit dit en passant, sur les possibilit√©s de la vid√©o: certaines personnes parviennent √† extraire tous les jus du microcontr√¥leur AVR dans leurs projets (par exemple, dans le projet Uzebox ou Craft du d√©veloppeur lft).  Cependant, pour y parvenir, les microcontr√¥leurs AVR nous obligent √† √©crire en assembleur, et m√™me si certains jeux sont tr√®s bons, vous rencontrerez de s√©rieuses limitations qui ne vous permettent pas de cr√©er un jeu en style 16 bits. <br><br>  Par cons√©quent, nous avons d√©cid√© d'utiliser un microcontr√¥leur / carte plus √©quilibr√©, ce qui nous permet d'√©crire du code compl√®tement en C. <br><br>  Il n'est pas aussi puissant que Arduino Due, mais pas aussi faible que Arduino Uno.  Fait int√©ressant, ¬´d√ª¬ª signifie ¬´deux¬ª et ¬´Uno¬ª signifie ¬´un¬ª.  Microsoft nous a appris √† compter correctement (1, 2, 3, 95, 98, ME, 2000, XP, Vista, 7, 8, 10), et Arduino a √©galement suivi cette voie!  Nous utiliserons l'Arduino Zero, qui se situe entre 1 et 2! <br><br>  Oui, selon Arduino, 1 &lt;0 &lt;2. <br><br>  En particulier, nous ne nous int√©ressons pas √† la carte elle-m√™me, mais √† sa s√©rie de processeurs.  L'Arduino Zero poss√®de un microcontr√¥leur de la s√©rie ATSAMD21 avec Cortex M0 + (48 MHz), 256 Ko de m√©moire flash et 32 ‚Äã‚ÄãKo de RAM. <br><br>  Bien que le Cortex M0 + √† 48 MHz surpasse consid√©rablement les performances de l'ancien MC68000 √† 7 MHz, l'Amiga 500 avait 512 Ko de RAM, des sprites mat√©riels, une double carte de jeu int√©gr√©e, Blitter (un moteur de transfert de blocs d'images bas√© sur DMA avec un syst√®me int√©gr√© de reconnaissance des collisions avec pr√©cision au pixel pr√®s). et la transparence) et Copper (un coprocesseur raster qui vous permet d'effectuer des op√©rations avec des registres bas√©s sur la position de balayage pour cr√©er de nombreux tr√®s beaux effets).  SAMD21 n'a pas tout ce mat√©riel (√† l'exception d'un mat√©riel assez simple par rapport √† Blitter DMA), donc beaucoup seront rendus par programmation. <br><br>  Nous voulons atteindre les param√®tres suivants: <br><br><ul><li>  R√©solution 160 x 128 pixels sur un √©cran SPI de 1,8 pouces. </li><li>  Graphiques avec 16 bits par pixel; </li><li>  La fr√©quence d'images la plus √©lev√©e.  Au moins 25 fps √† 12 MHz SPI, ou 40 fps √† 24 MHz; </li><li>  double terrain de jeu avec d√©filement parallaxe; </li><li>  tout est √©crit en C. Pas de code assembleur; </li><li>  Reconnaissance au pixel pr√®s des collisions; </li><li>  superposition d'√©cran. </li></ul><br>  Il semble que la r√©alisation de ces objectifs soit assez difficile.  √áa l'est, surtout si on refuse le code sur asm! <br><br>  Par exemple, avec une couleur 16 bits, une taille d'√©cran de 160 √ó 128 pixels n√©cessitera 40 Ko pour le tampon d'√©cran, mais nous n'avons que 32 Ko de RAM!  Et nous avons encore besoin du d√©filement de parallaxe sur un double terrain de jeu et bien plus encore, avec une fr√©quence d'au moins 25/40 ips! <br><br>  Mais rien n'est impossible pour nous, non? <br><br>  Nous utilisons des astuces et des fonctions int√©gr√©es de ATSAMD21!  En tant que "mat√©riel", nous prenons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">uChip</a> , qui peut √™tre achet√© dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">magasin Itaca</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ff/e77/4aa/9ffe774aac84e2df3534d9ac2f16724b.jpg"></div><br>  <i>uChip: le c≈ìur de notre projet!</i> <br><br>  Il a les m√™mes caract√©ristiques que l'Arduino Zero, mais est beaucoup plus petit et aussi moins cher que l'Arduino Zero d'origine (oui, vous pouvez acheter un faux Arduino Zero pour 10 $ sur AliExpress ... mais nous voulons construire sur l'original).  Cela nous permettra de cr√©er une petite console portable.  Vous pouvez adapter ce projet pour Arduino Zero presque sans effort, seul le r√©sultat sera assez encombrant. <br><br>  Nous avons √©galement cr√©√© une petite carte de test qui impl√©mente une console portable pour les pauvres.  D√©tails ci-dessous! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a8a/c34/04e/a8ac3404e35351c6e02368763ef985a5.jpg"></div><br>  Nous n'utiliserons pas le framework Arduino.  Il n'est pas bien adapt√© √† l'optimisation et la gestion des √©quipements.  (Et ne parlons pas de l'IDE!) <br><br>  Dans cet article, nous allons d√©crire comment nous sommes arriv√©s √† la version finale du jeu, d√©crire toutes les optimisations et crit√®res utilis√©s.  Le jeu lui-m√™me n'est pas encore termin√©, il manque de son, de niveaux, etc.  Cependant, il peut √™tre utilis√© comme point de d√©part pour de nombreux types de jeux diff√©rents! <br><br>  De plus, il existe de nombreuses autres options d'optimisation, m√™me sans assembleur! <br><br>  Commen√ßons donc notre voyage! <br><br><h2>  Des difficult√©s </h2><br>  En fait, le projet comporte deux aspects complexes: les horaires et la m√©moire (√† la fois RAM et stockage). <br><br><h3>  La m√©moire </h3><br>  Commen√ßons par la m√©moire.  Tout d'abord, au lieu de stocker une image de grand niveau, nous utilisons des tuiles.  En fait, si vous analysez attentivement la plupart des plateformes, vous remarquerez qu'elles sont cr√©√©es √† partir d'un petit nombre d'√©l√©ments graphiques (tuiles) qui sont r√©p√©t√©s plusieurs fois. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f36/950/80a/f3695080a0bfe4d7f1ce6809c8efe275.png"></div><br>  <i>Turrican 2 sur Amiga.</i>  <i>L'un des meilleurs jeux de plateforme de tous les temps.</i>  <i>Vous pouvez facilement voir les tuiles dedans!</i> <br><br>  Le monde / niveau semble diversifi√© gr√¢ce √† diff√©rentes combinaisons de tuiles.  Cela √©conomise beaucoup de m√©moire sur le lecteur, mais ne r√©sout pas le probl√®me d'un √©norme tampon de trame. <br><br>  La deuxi√®me astuce que nous utilisons est possible en raison de la puissance de calcul assez importante de uC et de la pr√©sence de DMA!  Au lieu de stocker toutes les donn√©es d'image dans la RAM (et pourquoi est-ce n√©cessaire?) Nous allons cr√©er une sc√®ne dans chaque image √† partir de z√©ro.  En particulier, nous continuerons √† utiliser des tampons, mais de mani√®re √† ce qu'ils tiennent dans un bloc horizontal de graphiques de donn√©es d'une hauteur de 16 pixels. <br><br><h3>  Timings - CPU </h3><br>  Lorsqu'un ing√©nieur doit cr√©er quelque chose, il v√©rifie d'abord si cela est possible.  Bien s√ªr, au tout d√©but, nous avons effectu√© ce test! <br><br>  Il nous faut donc au moins 25 ips sur un √©cran de 160 √ó 128 pixels.  Cela repr√©sente 512 000 pixels / s.  √âtant donn√© que le microcontr√¥leur fonctionne √† une fr√©quence de 48 MHz, nous avons au moins 93 cycles d'horloge par pixel.  Cette valeur tombe √† 58 cycles si nous visons 40 fps. <br><br>  En fait, notre microcontr√¥leur est capable de traiter jusqu'√† 2 pixels √† la fois, car chaque pixel prend 16 bits, et l'ATSAMD21 poss√®de un bus interne 32 bits, c'est-√†-dire que les performances seront encore meilleures! <br><br>  Une valeur de 93 cycles d'horloge nous indique que la t√¢che est compl√®tement r√©alisable!  En fait, nous pouvons conclure que le CPU seul peut g√©rer toutes les t√¢ches de rendu sans DMA.  Cela est tr√®s probablement vrai, surtout lorsque vous travaillez avec un assembleur.  Cependant, le code sera tr√®s difficile √† g√©rer.  Et en C √ßa doit √™tre tr√®s optimis√©!  En fait, Cortex M0 + n'est pas aussi convivial pour C que Cortex M3, et il manque beaucoup d'instructions (il ne charge m√™me pas / enregistre avec l'incr√©mentation / d√©cr√©mentation suivante / pr√©liminaire!), Qui doit √™tre impl√©ment√© avec deux ou plusieurs instructions simples. <br><br>  Voyons ce que nous devons faire pour dessiner deux terrains de jeu (en supposant que nous connaissons d√©j√† les coordonn√©es x et y, etc.). <br><br><ul><li>  Calculez l'emplacement du pixel de premier plan dans la m√©moire flash. </li><li>  Obtenez la valeur en pixels. </li><li>  S'il est transparent, calculez la position du pixel d'arri√®re-plan dans le flash. </li><li>  Obtenez la valeur en pixels. </li><li>  Calculez l'emplacement cible. </li><li>  Enregistrez le pixel dans la m√©moire tampon. </li></ul><br>  De plus, pour chaque image-objet pouvant entrer dans le tampon, les op√©rations suivantes doivent √™tre effectu√©es: <br><br><ul><li>  Calculez la position d'un pixel sprite dans la m√©moire flash. </li><li>  Obtention de la valeur en pixels. </li><li>  S'il n'est pas transparent, calculez l'emplacement du tampon de destination. </li><li>  Enregistrement d'un pixel dans le tampon. </li></ul><br>  Non seulement toutes ces op√©rations ne sont pas impl√©ment√©es comme une seule instruction ASM, mais chaque instruction ASM n√©cessite deux cycles lors de l'acc√®s √† la m√©moire RAM / flash. <br><br>  De plus, nous n'avons toujours pas de logique de jeu (qui, heureusement, prend un peu de temps, car il est calcul√© une fois par image), la reconnaissance des collisions, le traitement du tampon et les instructions n√©cessaires pour envoyer des donn√©es via SPI. <br><br>  Par exemple, voici le pseudo-code de ce que nous devons faire (pour l'instant, nous supposons que le jeu n'a pas de d√©filement et que le terrain de jeu a un fond de couleur constant!) Uniquement pour le premier plan. <br><br>  Soit cameraY et cameraX les coordonn√©es du coin sup√©rieur gauche de l'√©cran dans le monde du jeu. <br><br>  Soit xTilepos et yTilepos la position de la tuile actuelle sur la carte. <br><br><pre><code class="cpp hljs">xTilepos = cameraX / <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-comment"><span class="hljs-comment">// this is a rightward shift of 4 bits. yTilepos = cameraY / 16; destBufferAddress = &amp;buffer[0][0]; for tile = 0...9 nTile = gameMap[yTilepos][xTilepos]; tileDataAddress = &amp;tileData[nTile]; xTilepos = xTilepos + 1; for y = 0‚Ä¶15 for x = 0‚Ä¶15 pixel = *tileDataAddress; tileDataAddress = tileDataAddress + 1; *destBufferAddress = pixel; destBufferAddress = destBufferAddress + 1; next destBufferAddress = destBufferAddress + 144; // point to next row next destBufferAddress = destBufferAddress ‚Äì ( 160 * 16 - 16); // now point to the position where the next tile will be saved. next</span></span></code> </pre> <br>  Le nombre d'instructions pour 2560 pixels (160 x 16) est d'environ 16k, soit  6 par pixel.  En fait, vous pouvez dessiner deux pixels √† la fois.  Cela divise par deux le nombre r√©el d'instructions par pixel, c'est-√†-dire que le nombre d'instructions de haut niveau par pixel est d'environ 3. Cependant, certaines de ces instructions de haut niveau seront soit divis√©es en deux instructions d'assembleur ou plus, soit n√©cessiteront au moins deux cycles pour √™tre ex√©cut√©es car √† la m√©moire.  De plus, nous n'avons pas envisag√© de r√©initialiser le pipeline du processeur en raison de sauts et des √©tats d'attente pour la m√©moire flash.  Oui, nous sommes encore loin des cycles 58-93 √† notre disposition, mais nous devons encore prendre en compte le contexte du terrain de jeu et les sprites. <br><br>  Bien que nous constations que le probl√®me peut √™tre r√©solu sur un seul processeur, le DMA sera beaucoup plus rapide.  L'acc√®s direct √† la m√©moire laisse encore plus de place aux sprites d'√©cran ou √† de meilleurs effets graphiques (par exemple, nous pouvons impl√©menter le m√©lange alpha). <br><br>  Nous verrons que pour configurer le DMA pour chaque tuile, nous avons besoin de moins de 100 instructions C, soit moins de 0,5 par pixel!  Bien s√ªr, DMA devra toujours effectuer le m√™me nombre de transferts en m√©moire, mais l'incr√©mentation et la transmission d'adresse sont effectu√©es sans l'intervention du CPU, ce qui peut faire autre chose (par exemple, calculer et rendre des sprites). <br><br>  En utilisant la minuterie SysTick, nous avons d√©couvert que le temps n√©cessaire pour pr√©parer le DMA pour le bloc entier, puis pour terminer le DMA, est d'environ 12k cycles d'horloge.  Remarque: les cycles d'horloge!  Pas d'instructions de haut niveau!  Le nombre de cycles est assez √©lev√© pour seulement 2560 pixels, soit  1280 mots 32 bits.  En fait, nous obtenons environ 10 cycles par mot de 32 bits.  Cependant, vous devez tenir compte du temps requis pour pr√©parer le DMA, ainsi que du temps n√©cessaire au DMA pour charger les descripteurs de transfert √† partir de la RAM (qui contiennent essentiellement des pointeurs et le nombre d'octets transf√©r√©s).  De plus, il y a toujours une sorte de changement de bus m√©moire (pour que le CPU ne reste pas inactif sans donn√©es), et la m√©moire flash n√©cessite au moins un √©tat d'attente. <br><br><h3>  Horaires - SPI </h3><br>  Un autre goulot d'√©tranglement est SPI.  Est-ce que 12 MHz suffit pour 25 fps?  La r√©ponse est oui: 12 MHz correspond √† environ 36 images par seconde.  Si nous utilisons 24 MHz, la limite doublera! <br><br>  Soit dit en passant, les sp√©cifications de l'√©cran et du microcontr√¥leur indiquent que la vitesse SPI maximale est respectivement de 15 et 12 MHz.  Nous avons test√© et veill√© √† ce qu'elle puisse √™tre port√©e √† 24 MHz sans probl√®me, au moins dans la ¬´direction¬ª dont nous avons besoin (le microcontr√¥leur √©crit sur l'√©cran). <br><br>  Nous utiliserons le populaire √©cran SPI de 1,8 pouces.  Nous nous sommes assur√©s que ILI9163 et ST7735 fonctionnent normalement avec une fr√©quence de 12 MHz (au moins avec 12 MHz. Il est v√©rifi√© que le ST7735 fonctionne avec une fr√©quence allant jusqu'√† 24 MHz).  Si vous souhaitez utiliser le m√™me affichage que dans le didacticiel ¬´Comment lire des vid√©os sur Arduino Uno¬ª, nous vous recommandons de le modifier au cas o√π vous souhaiteriez ajouter la prise en charge SD √† l'avenir.  Nous utilisons la version de la carte SD afin d'avoir beaucoup d'espace pour d'autres √©l√©ments, tels que le son ou des niveaux suppl√©mentaires. <br><br><h2>  Graphisme </h2><br>  Comme d√©j√† mentionn√©, le jeu utilise des tuiles.  Chaque niveau sera compos√© de tuiles se r√©p√©tant selon le tableau, que nous avons appel√© "gameMap".  Quelle sera la taille de chaque tuile?  La taille de chaque tuile affecte consid√©rablement la consommation de m√©moire, les d√©tails et la flexibilit√© (et, comme nous le verrons plus tard, la vitesse aussi).  Des tuiles trop grandes n√©cessiteront la cr√©ation d'une nouvelle tuile pour chaque petite variation dont nous avons besoin.  Cela prendra beaucoup d'espace sur le disque. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a96/a66/32a/a96a6632abfec9bef7341e42bed6cf45.png" width="580" height="165"></div><br>  <i>Deux carreaux de 32 √ó 32 pixels (gauche et centre), qui diff√®rent dans une petite partie (la partie sup√©rieure droite du pixel est de 16 √ó 16).</i>  <i>Par cons√©quent, nous devons stocker deux tuiles diff√©rentes avec une taille de 32 √ó 32 pixels.</i>  <i>Si nous utilisons une tuile 16 √ó 16 pixels (√† droite), nous devons stocker uniquement deux tuiles 16 √ó 16 (une tuile enti√®rement blanche et une tuile √† droite).</i>  <i>Cependant, lorsque vous utilisez des tuiles 16 √ó 16, nous obtenons 4 √©l√©ments de carte.</i> <br><br>  Cependant, moins de tuiles par √©cran sont n√©cessaires, ce qui augmente la vitesse (voir ci-dessous) et r√©duit la taille de la carte (c'est-√†-dire le nombre de lignes et de colonnes dans le tableau) de chaque niveau.  Des tuiles trop petites cr√©ent le probl√®me inverse.  Les tables de cartes s'agrandissent et la vitesse ralentit.  Bien s√ªr, nous ne prendrons pas de d√©cisions stupides.  par exemple, s√©lectionnez des carreaux d'une taille de 17 √ó 31 pixels.  Notre fid√®le ami - deux degr√©s!  Le format 16 √ó 16 est presque la ¬´r√®gle d'or¬ª, il est utilis√© dans de nombreux jeux, et nous le choisirons! <br><br>  Notre √©cran a une taille de 160 √ó 128.  En d'autres termes, nous avons besoin de 10 √ó 8 tuiles par √©cran, c'est-√†-dire  80 entr√©es dans le tableau.  Pour un grand niveau d'√©crans 10 √ó 10 (ou 100 √ó 1 √©crans), seuls 8 000 enregistrements seront n√©cessaires (16 Ko si nous utilisons 16 bits pour l'enregistrement. Plus tard, nous montrerons pourquoi nous avons d√©cid√© de choisir 16 bits pour l'enregistrement). <br><br>  Comparez cela avec la quantit√© de m√©moire susceptible d'√™tre occup√©e par une grande image sur tout l'√©cran: 40 Ko * 100 = 4 Mo!  C'est fou! <br><br>  Parlons du syst√®me de rendu. <br><br>  Chaque cadre doit contenir (dans l'ordre des dessins): <br><br><ul><li>  graphiques d'arri√®re-plan (terrain de jeu arri√®re) </li><li>  le graphique de niveau lui-m√™me (premier plan). </li><li>  sprites </li><li>  texte / superposition sup√©rieure. </li></ul><br>  En particulier, nous effectuerons s√©quentiellement les op√©rations suivantes: <br><br><ol><li>  Arri√®re-plan du dessin + premier plan (tuiles) </li><li>  dessin de carreaux translucides + sprites + superposition sup√©rieure </li><li>  envoi de donn√©es par SPI. </li></ol><br>  Le fond et les carreaux enti√®rement opaques seront dessin√©s par DMA.  Une tuile enti√®rement opaque est une tuile dans laquelle il n'y a pas de pixels transparents. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2da/1dd/417/2da1dd41756746a4b387988c191ca673.png"></div><br>  <i>Carreau partiellement transparent (gauche) et compl√®tement opaque (droite).</i>  <i>Dans une tuile partiellement transparente, certains pixels (en bas √† gauche) sont transparents, et donc un arri√®re-plan est visible √† travers cette zone.</i> <br><br>  Les tuiles, les sprites et les superpositions partiellement transparents ne peuvent pas √™tre rendus efficacement par DMA.  En fait, le syst√®me DMA de la puce ATSAMD21 copie simplement les donn√©es et, contrairement au Blitter de l'ordinateur Amiga, il ne v√©rifie pas la transparence (d√©finie par la valeur de couleur).  Tous les √©l√©ments partiellement transparents sont dessin√©s par le CPU. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bb/8a2/950/7bb8a29500f57268d62dae5b1de2a9ea.png"></div><br>  Les donn√©es sont ensuite transmises √† l'√©cran √† l'aide de DMA. <br><br><h3>  Cr√©ation d'un pipeline </h3><br>  Comme vous pouvez le voir, si nous effectuons ces op√©rations s√©quentiellement dans un seul tampon, cela prendra beaucoup de temps.  En fait, pendant que le DMA est en cours d'ex√©cution, le CPU ne sera pas occup√©, sauf en attendant que le DMA se termine!  C'est une mauvaise fa√ßon d'impl√©menter un moteur graphique.  De plus, lorsque DMA envoie des donn√©es √† un appareil SPI, il n'utilise pas sa pleine bande passante.  En fait, m√™me lorsque SPI fonctionne √† une fr√©quence de 24 MHz, les donn√©es ne sont transmises qu'√† une fr√©quence de 3 MHz, ce qui est assez petit.  En d'autres termes, le DMA n'est pas utilis√© √† son plein potentiel: le DMA peut effectuer d'autres t√¢ches sans vraiment perdre les performances. <br><br>  C'est pourquoi nous avons impl√©ment√© le pipeline, qui est le d√©veloppement de l'id√©e de double tampon (nous utilisons trois tampons!).  Bien s√ªr, au final, les op√©rations sont toujours effectu√©es de mani√®re s√©quentielle.  Mais le CPU et le DMA effectuent simultan√©ment des t√¢ches diff√©rentes, sans (surtout) s'influencer mutuellement. <br><br>  Voici ce qui se passe simultan√©ment: <br><br><ul><li>  Le tampon est utilis√© pour dessiner des donn√©es d'arri√®re-plan en utilisant le canal DMA 1; </li><li>  Dans un autre tampon (qui √©tait auparavant rempli de donn√©es d'arri√®re-plan), le CPU dessine des sprites et des tuiles partiellement transparentes; </li><li>  Ensuite, un autre tampon (qui contient un bloc de donn√©es horizontal complet) est utilis√© pour envoyer des donn√©es √† l'affichage via SPI en utilisant le canal DMA 0. Bien s√ªr, le tampon utilis√© pour envoyer des donn√©es via SPI a √©t√© pr√©c√©demment rempli de sprites tandis que le SPI a envoy√© le bloc pr√©c√©dent et tandis qu'un autre tampon rempli de tuiles. </li></ul><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a75/56e/a95/a7556ea9572df04f967fae2035275c01.png"></div><br><h3>  DMA </h3><br>  Le syst√®me DMA √† puce ATSAMD21 n'est pas comparable √† Blitter, mais il a n√©anmoins ses propres fonctionnalit√©s utiles.  Gr√¢ce au DMA, nous pouvons fournir un taux de rafra√Æchissement tr√®s √©lev√©, malgr√© un double terrain de jeu. <br><br>  La configuration du transfert DMA est stock√©e dans la RAM, dans des ¬´descripteurs DMA¬ª, indiquant au DMA comment et o√π il doit effectuer le transfert en cours.  Ces descripteurs peuvent √™tre r√©unis: s'il y a une connexion (c'est-√†-dire qu'il n'y a pas de pointeur nul), puis une fois le transfert termin√©, le DMA recevra automatiquement le descripteur suivant.  Gr√¢ce √† l'utilisation de descripteurs multiples, le DMA peut effectuer des ¬´transferts complexes¬ª, qui sont utiles lorsque, par exemple, le tampon source est une s√©quence de segments non contigus d'octets contigus.  Cependant, il faut du temps pour obtenir et √©crire des descripteurs, car vous devez enregistrer / charger 16 octets de descripteur √† partir de la RAM. <br><br>  Le DMA peut fonctionner avec des donn√©es de diff√©rentes longueurs: octets, demi-mots (16 bits) et mots (32 bits).  Dans la sp√©cification, cette longueur est appel√©e ¬´taille de battement¬ª.  Pour SPI, nous sommes oblig√©s d'utiliser le transfert d'octets (bien que la sp√©cification REVD actuelle stipule que les puces SERCOM ATSAMD21 ont FIFO, qui, selon Microchip, peut accepter des donn√©es 32 bits, en fait, il semble qu'elles n'aient pas FIFO. La sp√©cification REVD mentionne √©galement Registre SERCOM CTRLC, qui est absent √† la fois dans les fichiers d'en-t√™te et dans la section de description du registre.Heureusement, contrairement √† AVR, ATSAMD21 a au moins un registre de donn√©es de transmission tamponn√©, il n'y aura donc pas de pause dans la transmission!).  Pour dessiner des tuiles, nous utilisons bien s√ªr 32 bits.  Cela vous permet de copier deux pixels par battement.  La puce DMA ATSAMD21 permet √©galement √† chaque battement source d'augmenter l'adresse source ou de destination d'un nombre fixe de tailles de battement. <br><br>  Ces deux aspects sont tr√®s importants et d√©terminent la fa√ßon dont nous dessinons les tuiles. <br><br>  Premi√®rement, si nous rendions un pixel par battement (16 bits), nous diviserions par deux le d√©bit de notre syst√®me.  Nous ne pouvons pas refuser la pleine bande passante! <br><br>  Cependant, si nous dessinons deux pixels par battement, le champ de jeu ne pourra faire d√©filer qu'un nombre pair de pixels, ce qui provoquera un mouvement fluide.  Pour g√©rer cela, vous pouvez utiliser un tampon plus grand de deux pixels ou plus.  Lors de l'envoi de donn√©es √† l'√©cran, nous utiliserons le d√©calage correct (0 ou 1 pixel), selon que nous devons d√©placer la ¬´cam√©ra¬ª d'un nombre pair ou impair de pixels. <br><br>  Cependant, par souci de simplicit√©, nous r√©servons de l'espace pour 11 carreaux complets (160 + 16 pixels), et non pour 160 + 2 pixels.  Cette approche pr√©sente un gros avantage: nous n'avons pas √† calculer et √† mettre √† jour l'adresse du destinataire de chaque descripteur DMA (cela n√©cessiterait plusieurs instructions, ce qui pourrait entra√Æner trop de calculs par mosa√Øque).  Bien s√ªr, nous ne dessinerons que le nombre minimum de pixels, c'est-√†-dire pas plus de 162. Oui, au final, nous d√©penserons un peu de m√©moire suppl√©mentaire (en tenant compte de trois tampons, cela fait environ 1500 octets) pour la vitesse et la simplicit√©.  Vous pouvez √©galement effectuer d'autres optimisations. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/061/899/2ee/0618992eedba5d01c4d00da2aceec886.gif"></div><br>  Tous les tampons de bloc de 16 lignes (sans descripteurs) sont visibles dans cette animation GIF.  √Ä droite, ce qui est r√©ellement affich√©.  Les 32 premi√®res images sont affich√©es en GIF, sur lequel nous d√©pla√ßons 1 pixel vers la droite dans chaque image.  La zone noire du tampon est la partie qui n'est pas mise √† jour et son contenu reste simplement des op√©rations pr√©c√©dentes.  Lorsque l'√©cran fait d√©filer un nombre impair d'images, une zone de 162 pixels de large est dessin√©e dans le tampon.  Cependant, leur premi√®re et derni√®re colonne (qui sont mises en surbrillance dans l'animation) sont supprim√©es.  Lorsque la valeur de d√©filement est un multiple de 16 pixels, les op√©rations de dessin dans le tampon commencent √† partir de la premi√®re colonne (x = 0). <br><br>  Et le d√©filement vertical? <br><br>  Nous nous en occuperons apr√®s avoir montr√© une m√©thode de stockage des tuiles dans la m√©moire flash. <br><br><h3>  Comment stocker les carreaux </h3><br>  Une approche na√Øve (qui nous conviendrait si nous rendions uniquement via le CPU) serait de stocker les tuiles dans la m√©moire flash sous la forme d'une s√©quence de couleurs de pixels.  Le premier pixel de la premi√®re ligne, le second, et ainsi de suite, jusqu'au seizi√®me.  Ensuite, nous enregistrons le premier pixel de la deuxi√®me ligne, le second, etc. <br><br>  Pourquoi une telle d√©cision est-elle na√Øve?  Parce que dans ce cas, DMA ne peut rendre que 16 pixels par descripteur DMA!  Par cons√©quent, nous aurons besoin de 16 descripteurs, dont chacun a besoin de 4 + 4 op√©rations d'acc√®s √† la m√©moire (c'est-√†-dire, pour transf√©rer 32 octets - 8 op√©rations de lecture en m√©moire + 8 op√©rations d'√©criture en m√©moire - DMA doit effectuer 4 lectures suppl√©mentaires + 4 √©critures).  C'est assez inefficace! <br><br>  En fait, pour chaque descripteur, DMA ne peut incr√©menter les adresses source et destination que d'un nombre fixe de mots.  Apr√®s avoir copi√© la premi√®re ligne de la tuile dans le tampon, l'adresse du destinataire ne doit pas √™tre augment√©e d'un mot, mais d'une valeur telle qu'elle pointe vers la ligne suivante du tampon.  Cela n'est pas possible car chaque descripteur de transmission indique uniquement l'incr√©ment de transmission de battement, qui ne peut pas √™tre modifi√©. <br><br>  Il sera beaucoup plus intelligent d'envoyer les deux premiers pixels de chaque ligne de la tuile s√©quentiellement, c'est-√†-dire les pixels 0 et 1 de la ligne 0, les pixels 0 et 1 de la ligne 1, etc., aux pixels 0 et 1 de la ligne 15. Ensuite, nous envoyons les pixels 2 et 3 de la ligne 0, etc. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fee/f1a/2ee/feef1a2eea76233cd37000f8643f098f.png"></div><br>  <i>Comment une tuile est-elle stock√©e?</i> <br><br>  Dans la figure ci-dessus, chaque nombre indique l'ordre dans lequel le pixel 16 bits est stock√© dans le r√©seau de tuiles. <br><br>  Cela peut √™tre fait avec un descripteur, mais nous avons besoin de deux choses: <br><br><ul><li>  Les mosa√Øques doivent √™tre stock√©es de sorte que lors de l'incr√©mentation de la source d'un mot, nous indiquions toujours les positions de pixels correctes.  En d'autres termes, si (r, c) est un pixel dans la ligne r et la colonne c, alors nous devons enregistrer les pixels (0,0) (0,1) (1,0) (1,1) (2,0) s√©quentiellement (2,1) ... (15,0) (15,1) (0,2) (0,3) (1,2) (1,3) ... </li><li>  Le tampon doit avoir une largeur de 256 pixels (pas 160) </li></ul><br>  Le premier objectif est tr√®s facile √† atteindre: il suffit de changer l'ordre des donn√©es, vous pouvez le faire lors de l'exportation de graphiques vers un fichier c (voir image ci-dessus). <br><br>  Le deuxi√®me probl√®me peut √™tre r√©solu car DMA vous permet d'augmenter l'adresse du destinataire apr√®s chaque battement de 512 octets.  Cela a deux cons√©quences: <br><br><ul><li>  Nous ne pouvons pas envoyer de donn√©es √† l'aide d'un seul descripteur sur un bloc SPI.  Ce n'est pas un probl√®me tr√®s grave, car au final nous lisons un descripteur sur 160 pixels.  L'impact sur les performances sera minime. </li><li>  Le bloc doit avoir une taille de 256 * 2 * 16 octets = 8 Ko, et il y aura beaucoup "d'espace inutilis√©" dedans. </li></ul><br>  Cependant, cet espace peut toujours √™tre utilis√©, par exemple, pour des descripteurs. <br><br>  En fait, chaque descripteur a une taille de 16 octets.  Nous avons besoin d'au moins 10 * 8 (et en fait 11 * 8!) Descripteurs pour les tuiles et 16 descripteurs pour SPI. <br><br>  C'est pourquoi plus il y a de tuiles, plus la vitesse est √©lev√©e.  En fait, si nous utilisions, par exemple, une tuile 32 x 32, nous aurions alors besoin de moins de descripteurs par √©cran (320 au lieu de 640).  Cela r√©duirait le gaspillage de ressources. <br><br><h3>  Afficher le bloc de donn√©es </h3><br>  Le tampon de bloc, les descripteurs et les autres donn√©es sont stock√©s dans un type de structure, que nous avons appel√© displayBlock_t. <br><br>  displayBlock est un tableau de 16 √©l√©ments displayLineData_t.  Les donn√©es DisplayLine contiennent 176 pixels plus 80 mots.  Dans ces 80 mots, nous stockons des descripteurs d'affichage ou d'autres donn√©es d'affichage utiles (en utilisant l'union). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/817/4cc/f0b/8174ccf0b746674367693a5c6bcd47a5.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a2/539/677/0a2539677818cc593c80aba690af6679.png"></div><br>  Comme nous avons 16 lignes, chaque mosa√Øque √† la position X utilise les 8 premiers descripteurs DMA (0 √† 7) des lignes X. Comme nous avons un maximum de 11 mosa√Øques (la ligne d'affichage fait 176 pixels de large), les mosa√Øques n'utilisent que les premiers descripteurs DMA 11 lignes de donn√©es.  Les descripteurs 8 √† 9 de toutes les lignes et les descripteurs 0 √† 9 des lignes 11 √† 15 sont libres. <br><br>  Parmi ceux-ci, les descripteurs 8 et 9 des lignes 0 √† 7 seront utilis√©s pour SPI. <br><br>  Les descripteurs 0..9 lignes 11-15 (jusqu'√† 50 descripteurs, bien que nous n'en utiliserons que 48) seront utilis√©s pour le terrain de jeu en arri√®re-plan. <br><br>  La figure ci-dessous montre leur structure. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e38/017/7c0/e380177c03a9a6ca50538e438bb0552f.png"></div><br><h3>  Terrain de jeu d'arri√®re-plan </h3><br>  Le terrain de jeu en arri√®re-plan est g√©r√© diff√©remment.  Premi√®rement, si nous avons besoin d'un d√©filement fluide, nous devrons revenir au format √† deux pixels, car le premier plan et l'arri√®re-plan d√©fileront √† des vitesses diff√©rentes.  Par cons√©quent, le rythme sera √† mi-parcours.  Bien qu'il s'agisse d'un inconv√©nient en termes de vitesse, cette approche facilite l'int√©gration.  Il ne nous reste qu'un petit nombre de descripteurs, donc les petites tuiles ne peuvent pas √™tre utilis√©es.  De plus, pour simplifier le travail et ajouter rapidement la parallaxe, nous utiliserons de longs ¬´secteurs¬ª. <br><br>  L'arri√®re-plan n'est dessin√© que s'il y a au moins un pixel partiellement transparent.  Cela signifie que s'il n'y a qu'une seule tuile transparente, l'arri√®re-plan sera dessin√©.  Bien s√ªr, c'est un gaspillage de bande passante, mais cela simplifie tout. <br><br>  Comparez l'arri√®re-plan et les terrains de jeu avant: <br><br><ul><li>  En arri√®re-plan, des secteurs sont utilis√©s, qui sont de longues tuiles stock√©es de mani√®re "na√Øve". </li><li>  L'arri√®re-plan a sa propre carte, mais horizontalement il se r√©p√®te.  Gr√¢ce √† cela, moins de m√©moire est utilis√©e. </li><li>  Le fond a une parallaxe pour chaque secteur. </li></ul><br><h3>  Terrain de jeu avant </h3><br>  Comme il a √©t√© dit, dans chaque bloc, nous avons jusqu'√† 11 tuiles (10 tuiles compl√®tes, ou 9 tuiles compl√®tes et 2 fichiers partiels).  Chacune de ces tuiles, si elle n'est pas marqu√©e comme transparente, DMA est dessin√©e.  S'il n'est pas compl√®tement opaque, il est ajout√© √† la liste, qui sera analys√©e plus tard, lors du rendu des sprites. <br><br><h3>  Nous connectons ensemble deux terrains de jeu </h3><br>  Les descripteurs du terrain de jeu d'arri√®re-plan (qui sont toujours calcul√©s) et du terrain de jeu avant forment une tr√®s longue liste cha√Æn√©e.  La premi√®re partie dessine un terrain de jeu d'arri√®re-plan.  La deuxi√®me partie dessine des tuiles sur le fond.  La longueur de la deuxi√®me partie peut √™tre variable, car les descripteurs DMA des tuiles partiellement transparentes sont exclus de la liste.  Si le bloc ne contient que des tuiles opaques, le DMA est configur√© comme suit.  pour d√©marrer directement √† partir du premier descripteur de la premi√®re tuile. <br><br><h3>  Sprites et tuiles avec transparence </h3><br>  Les carreaux avec transparence et sprites sont trait√©s de la m√™me mani√®re.  L'analyse des pixels de tuile / sprite est effectu√©e.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S'il est noir, il est transparent, et par cons√©quent, la vignette d'arri√®re-plan ne change pas. </font><font style="vertical-align: inherit;">S'il n'est pas noir, le pixel d'arri√®re-plan est remplac√© par un pixel sprite / tuile.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> D√©filement vertical </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque vous travaillez avec le d√©filement horizontal, nous dessinons jusqu'√† 11 tuiles, m√™me si lors du dessin de 11 tuiles, la premi√®re et la derni√®re ne sont que partiellement dessin√©es. </font><font style="vertical-align: inherit;">Un tel rendu partiel est possible du fait que chaque descripteur dessine deux colonnes de la tuile, afin que nous puissions facilement d√©finir le d√©but et la fin de la liste li√©e. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque vous travaillez avec le d√©filement vertical, nous devons calculer √† la fois le registre du r√©cepteur et le volume de transmission. </font><font style="vertical-align: inherit;">Ils doivent √™tre d√©finis plusieurs fois par image. </font><font style="vertical-align: inherit;">Pour √©viter cette agitation, nous pouvons simplement dessiner jusqu'√† 9 blocs complets par image (8 si le d√©filement est un multiple de 16).</font></font><br><br><h2>  √âquipement </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme nous l'avons dit, le c≈ìur du syst√®me est uChip. </font><font style="vertical-align: inherit;">Et le reste? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voici un sch√©ma! </font><font style="vertical-align: inherit;">Certains aspects m√©ritent d'√™tre mentionn√©s.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb1/b94/910/bb1b94910b94dc1289cc67f4f3e0022d.png"></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cl√©s </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour optimiser l'utilisation des E / S, nous utilisons une petite astuce. </font><font style="vertical-align: inherit;">Nous aurons 4 bus de capteurs L1-L4 et un fil LC commun. </font><font style="vertical-align: inherit;">1 et 0 sont appliqu√©s alternativement sur le fil commun. En cons√©quence, les bus de capteurs seront alternativement abaiss√©s ou relev√©s √† l'aide de r√©sistances de rappel internes. </font><font style="vertical-align: inherit;">Deux cl√©s sont connect√©es entre chacun des bus de cl√©s et un bus commun. </font><font style="vertical-align: inherit;">Une diode est ins√©r√©e en s√©rie avec ces deux touches. </font><font style="vertical-align: inherit;">Chacune de ces diodes est commut√©e dans le sens oppos√©, de sorte qu'√† chaque fois une seule touche est "lue".</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puisqu'il n'y a pas de contr√¥leur de clavier int√©gr√© (et qu'aucun contr√¥leur de clavier int√©gr√© n'utilise cette m√©thode int√©ressante), huit touches sont rapidement interrog√©es au d√©but de chaque image. Puisque les entr√©es doivent √™tre tir√©es vers le haut et vers le bas, nous ne pouvons pas (et ne voulons pas) utiliser des r√©sistances externes, nous devons donc utiliser des r√©sistances int√©gr√©es, qui peuvent avoir une r√©sistance assez √©lev√©e (60 kOhm). Cela signifie que lorsque le bus commun change d'√©tat et que les bus de donn√©es changent leur √©tat de traction haut / bas, vous devez ins√©rer un certain d√©lai pour que la r√©sistance de traction haut / bas int√©gr√©e modifie le contrat et r√®gle la capacit√© parasite au niveau souhait√©. Mais nous ne voulons pas attendre! Par cons√©quent, nous mettons le bus commun dans un √©tat de haute imp√©dance (afin qu'il n'y ait pas de d√©saccord), et passons d'abord les bus de capteur aux valeurs logiques 1 ou 0,en les configurant temporairement en sortie. Plus tard, ils sont configur√©s en entr√©e en tirant vers le haut ou vers le bas. La r√©sistance de sortie √©tant de l'ordre de dizaines d'Ohms, l'√©tat change en quelques nanosecondes, c'est-√†-dire que lorsque le bus du capteur repasse en entr√©e, il sera d√©j√† dans l'√©tat souhait√©. Apr√®s cela, le bus commun passe √† la sortie avec la polarit√© oppos√©e.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cela am√©liore consid√©rablement la vitesse de num√©risation et √©limine le besoin de retard / instructions nop. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Connexion SPI </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons connect√© le SD et l'√©cran afin qu'ils communiquent entre eux sans transf√©rer de donn√©es vers l'ATSAMD21. </font><font style="vertical-align: inherit;">Cela peut √™tre utile si vous souhaitez lire la vid√©o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les r√©sistances reliant MISO et MOSI doivent √™tre faibles. </font><font style="vertical-align: inherit;">S'ils sont trop grands, le SPI ne fonctionnera pas, car le signal sera trop faible.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Optimisation et d√©veloppement ult√©rieur </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'un des plus gros probl√®mes est l'utilisation de la RAM. Trois blocs occupent chacun 8 Ko, ne laissant que 8 Ko par pile et autres variables. Pour le moment, nous n'avons que 1,3 Ko de RAM libre + 4 Ko de pile (4 Ko par pile - c'est beaucoup, peut-√™tre allons-nous le r√©duire). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, vous pouvez utiliser des blocs d'une hauteur non pas de 16, mais de 8 pixels. Cela augmentera le gaspillage de ressources sur les descripteurs DMA, mais r√©duira presque de moiti√© la quantit√© de m√©moire occup√©e par le tampon de bloc (notez que le nombre de descripteurs ne changera pas si nous continuons √† utiliser des tuiles 16 √ó 16, nous devrons donc changer la structure du bloc). Cela peut lib√©rer environ 7,5 Ko de RAM, ce qui sera tr√®s utile pour impl√©menter des fonctions telles qu'une carte modifiable avec des secrets ou ajouter du son (bien que le son puisse √™tre ajout√© m√™me avec 1 Ko de RAM).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un autre probl√®me est le sprite, mais cette modification est beaucoup plus simple √† effectuer et vous n'avez besoin que de la fonction createNextFrameScene (). En fait, nous cr√©ons en RAM un √©norme tableau avec l'√©tat de tous les sprites. Ensuite, pour chaque image-objet, nous calculons si sa position se situe dans la zone de l'√©cran, puis l'animons et l'ajoutons √† la liste de rendu.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au lieu de cela, vous pouvez effectuer une optimisation. Par exemple, dans gameMap, vous pouvez stocker non seulement la valeur de la tuile, mais √©galement un indicateur indiquant la transparence de la tuile, d√©fini dans l'√©diteur. Cela nous permettra de v√©rifier rapidement si la tuile doit √™tre rendue: DMA ou CPU. C'est pourquoi nous avons utilis√© des enregistrements 16 bits pour la carte de tuiles. Si nous supposons que nous avons un ensemble de 256 tuiles (pour le moment, nous avons moins de 128 tuiles, mais qu'il y a suffisamment d'espace sur la m√©moire flash pour en ajouter de nouvelles), alors il y a 7 bits libres qui peuvent √™tre utilis√©s √† d'autres fins. Trois de ces sept bits peuvent √™tre utilis√©s pour indiquer si une image-objet / objet est stock√©e.</font></font> Par exemple: <br><br> <code>0b000 =    <br> 0b001 =  <br> 0b010 =  <br> 0b011 =  <br> 0b100 =  <br> 0b101 =  <br> 0b110 =  <br> 0b111 =    , ,   .</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, vous pouvez cr√©er une table de bits dans la RAM dans laquelle chaque bit signifie si (par exemple, un ennemi) est d√©tect√© / si (par exemple, un bonus) est ramass√© / si un certain objet est activ√© (commutateur). </font><font style="vertical-align: inherit;">Au niveau des √©crans 10 √ó 10, cela n√©cessitera 8000 bits, soit </font><font style="vertical-align: inherit;">1 Ko de RAM. </font><font style="vertical-align: inherit;">Le bit est r√©initialis√© lorsqu'un ennemi est d√©tect√© ou qu'un bonus est r√©cup√©r√©. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans createNextFrameScene (), nous devons v√©rifier les bits correspondant aux tuiles dans la zone visible actuelle. </font><font style="vertical-align: inherit;">S'ils ont une valeur de 1:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> S'il s'agit d'un bonus, ajoutez-le simplement √† la liste des sprites pour le rendu. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S'il s'agit d'un ennemi, cr√©ez un sprite dynamique et r√©initialisez le drapeau. </font><font style="vertical-align: inherit;">Dans l'image suivante, la sc√®ne contiendra un sprite dynamique jusqu'√† ce que l'ennemi quitte l'√©cran ou soit tu√©.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cette approche pr√©sente des inconv√©nients. </font></font><br><br><ol><li> -,           (       ).      . </li><li> -,       80  ,  ,    .      ,            32 .          ,   ¬´/¬ª (      ¬´¬ª, ..        0!).           ¬´¬ª,          ¬´¬ª (           ). </li><li> -,      .       (    ),     .  ,      . </li><li> -,   ,   ,    ,     .     ,       ,     .          ,     ,   ,     ,   ! </li><li>     ,          (,    Unreal Tournament   ,        ). </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√©anmoins, de cette mani√®re, nous pouvons stocker et traiter les sprites √† un niveau beaucoup plus efficace. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, cette technique est plus pertinente pour la "logique du jeu" que pour le moteur graphique du jeu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peut-√™tre qu'√† l'avenir, nous mettrons en ≈ìuvre cette fonction.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour r√©sumer </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous esp√©rons que vous avez appr√©ci√© cet article d'introduction. Nous devons expliquer de nombreux autres aspects qui feront l'objet de futurs articles. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En attendant, vous pouvez t√©l√©charger le code source complet du jeu! Si vous l'aimez, vous pouvez soutenir financi√®rement l'artiste </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ansimuz</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui a dessin√© tous les graphiques et les a donn√©s au monde gratuitement. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous acceptons √©galement les dons</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le jeu n'est pas encore termin√©. Nous voulons ajouter du son, de nombreux niveaux, des objets avec lesquels vous pouvez interagir et autres. Vous pouvez cr√©er vos propres modifications! Nous esp√©rons voir de nouveaux jeux avec de nouveaux graphismes et niveaux! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bient√¥t, nous publierons un √©diteur de carte, mais pour l'instant il est trop rudimentaire pour le montrer √† la communaut√©!</font></font><br><br><h2>  Vid√©o </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Remarque: en raison d'un mauvais √©clairage, la vid√©o a √©t√© enregistr√©e √† une fr√©quence d'images beaucoup plus faible! Bient√¥t, nous mettrons √† jour la vid√©o afin que vous puissiez estimer la vitesse maximale √† 40 ips!) </font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/1ekTeCCWKNI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Gratitude </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les graphismes du jeu (et les tuiles montr√©es sur certaines images) sont tir√©s de l' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">actif gratuit ¬´Sunny Land¬ª cr√©√© par ansimuz</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Documents t√©l√©chargeables </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le code source du projet est dans le domaine public, c'est-√†-dire qu'il est fourni gratuitement. </font><font style="vertical-align: inherit;">Nous le partageons dans l'espoir qu'il sera utile √† quelqu'un. </font><font style="vertical-align: inherit;">Nous ne garantissons pas qu'en raison d'un bug / erreur dans le code, il n'y aura pas de probl√®mes! </font></font><br><br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diagramme sch√©matique </font></font></a> <font style="vertical-align: inherit;"><a href=""><font style="vertical-align: inherit;">Projet </font></a></font><br><br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KiCad </font></font></a> <br><br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Projet Atmel Studio 7 (source)</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr466323/">https://habr.com/ru/post/fr466323/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr466307/index.html">Comment concevoir SCS</a></li>
<li><a href="../fr466311/index.html">Atelier SLS 6 septembre</a></li>
<li><a href="../fr466315/index.html">@Pythonetc compilation, ao√ªt 2019</a></li>
<li><a href="../fr466317/index.html">Trucs et astuces de ma cha√Æne Telegram @pythonetc, ao√ªt 2019</a></li>
<li><a href="../fr466319/index.html">Deal: VMware ach√®te une startup bas√©e sur le cloud</a></li>
<li><a href="../fr466329/index.html">Carte √©lectronique de la vinification en Russie. Conception et contenu</a></li>
<li><a href="../fr466333/index.html">Comment organiser un lieu de travail pour vous</a></li>
<li><a href="../fr466335/index.html">Cr√©ation d'une application Slack √† l'aide des fonctionnalit√©s 8base</a></li>
<li><a href="../fr466337/index.html">De quelle couleur est ta fonction?</a></li>
<li><a href="../fr466339/index.html">Comment dans Microsoft SQL Server pour obtenir des donn√©es de Google Analytics en utilisant R</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>