<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòì üôéüèΩ üê™ Tests ou types? - Version rouille üó∫Ô∏è üçâ üåΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il y a quelques jours, 0xd34df00d a publi√© ici une traduction d'un article qui d√©crit ce que vous pouvez apprendre sur une fonction dans diff√©rents la...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tests ou types? - Version rouille</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468145/"><p> Il y a quelques jours, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">0xd34df00d a</a> publi√© ici une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">traduction d'un</a> article qui d√©crit ce que vous pouvez apprendre sur une fonction dans diff√©rents langages, si vous la consid√©rez comme une "bo√Æte noire" sans utiliser d'informations sur son impl√©mentation (mais, bien s√ªr, sans l'emp√™cher d'utiliser le compilateur).  Bien s√ªr, les informations re√ßues d√©pendent beaucoup de la langue - quatre exemples ont √©t√© pris en compte dans l'article d'origine: </p><br><ul><li>  Python - typ√© dynamiquement, informations minimales, seuls les tests donnent des indices; </li><li>  C - faiblement typ√© statiquement, pas beaucoup plus d'informations; </li><li>  Haskell - fortement typ√© statiquement, avec des fonctions pures, beaucoup plus d'informations; </li><li>  Idris est un langage avec des types d√©pendants, il y a suffisamment d'informations pour prouver l'exactitude de la fonction lors de la compilation. </li></ul><br><p>  "Il y a C, il y a Haskell, mais o√π est Rust?!"  - aussit√¥t la question a √©t√© pos√©e.  La r√©ponse est sous la coupe. </p><a name="habracut"></a><br><p>  Rappelez-vous l'√©tat du probl√®me: </p><br><blockquote>  Qu'une liste et un sens soient donn√©s.  Il est n√©cessaire de renvoyer l'index de cette valeur dans la liste ou d'indiquer que cette valeur n'est pas dans la liste. </blockquote><p>  Pour les impatients - toutes les options discut√©es ci-dessous peuvent √™tre vues dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cour de r√©cr√©ation de Rust</a> . <br>  C'est parti! </p><br><h4 id="prostoy-poisk">  Recherche simple </h4><br><p>  Nous commencerons par une signature presque na√Øve, qui, en fait, ne diff√®re du code C que par certains √©l√©ments idiomatiques: </p><br><pre><code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(x: &amp;[<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>], y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; { <span class="hljs-comment"><span class="hljs-comment">// 10000    }</span></span></code> </pre> <br><p>  Que savons-nous de cette fonctionnalit√©?  Enfin ... pas vraiment, en fait.  Bien s√ªr, avoir <code>Option&lt;usize&gt;</code> dans les valeurs de retour est bien mieux que ce que C nous a fourni, mais nous n'avons toujours aucune information sur la s√©mantique de la fonction.  En particulier, rien ne garantit qu'il n'y aura pas d'effets secondaires, ni aucun moyen de v√©rifier le comportement attendu. </p><br><p>  Un test correctement √©crit peut-il corriger la situation?  Nous regardons: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(foo(&amp;[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(foo(&amp;[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-literal"><span class="hljs-literal">None</span></span>); }</code> </pre> <br><p>  En g√©n√©ral, nous n'avons rien obtenu de nouveau - toutes les m√™mes v√©rifications que nous pourrions facilement faire avec Python (et, √† l'avenir, les tests ne donneront pratiquement rien √† l'avenir). </p><br><h4 id="use-the-generics-luke">  Utilisez les g√©n√©riques, Luke! </h4><br><p>  Mais est-ce vraiment bien que nous soyons oblig√©s d'utiliser uniquement des num√©ros 32 bits sign√©s?  Le d√©sordre.  Nous r√©parons: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;El&gt;(x: &amp;[El], y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">PartialEq</span></span>, { <span class="hljs-comment"><span class="hljs-comment">// 10000    }</span></span></code> </pre> <br><p>  Ouais!  C'est d√©j√† quelque chose.  Maintenant, nous pouvons prendre des tranches, constitu√©es de tous les √©l√©ments que nous pouvons comparer pour l'√©galit√©.  Le polymorphisme explicite est presque toujours meilleur qu'implicite et presque toujours meilleur que rien, n'est-ce pas? </p><br><p>  Cependant, une telle fonction peut passer inopin√©ment le test suivant pour nous: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refl</span></span></span></span>&lt;El: <span class="hljs-built_in"><span class="hljs-built_in">PartialEq</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">Copy</span></span>&gt;(el: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; { foo(&amp;[el], el) <span class="hljs-comment"><span class="hljs-comment">// should always return Some(0), right? } #[test] fn dont_find_nan() { assert_eq!(refl(std::f64::NAN), None); }</span></span></code> </pre> <br><p>  Cela indique imm√©diatement une faille de notre part, car selon la sp√©cification d'origine, un tel appel devrait renvoyer <code>Some(0)</code> .  Bien s√ªr, le probl√®me ici est d√ª √† la sp√©cificit√© des types avec une comparaison partiellement d√©finie en g√©n√©ral et des flottants en particulier. <br>  Supposons maintenant que nous voulons nous d√©barrasser d'un tel probl√®me - pour cela, nous resserrons simplement les exigences pour le type El: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;El&gt;(x: &amp;[El], y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>, { <span class="hljs-comment"><span class="hljs-comment">// 10000    }</span></span></code> </pre> <br><p>  Maintenant, nous exigeons non seulement la possibilit√© d'une comparaison pour l'√©galit√© - nous exigeons que cette comparaison soit une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">relation d'√©quivalence</a> .  Cela r√©tr√©cit quelque peu la gamme des param√®tres possibles, mais maintenant, les types et les tests sugg√®rent (quoique pas explicitement) que le comportement attendu devrait vraiment entrer dans la sp√©cification. </p><br><div class="spoiler">  <b class="spoiler_title">Digression: on veut aller PLUS g√©n√©rique!</b> <div class="spoiler_text"><p>  Cette option n'est pas li√©e √† la t√¢che initiale, mais, √† mon avis, est une bonne illustration du principe: "√™tre lib√©ral dans ce que vous acceptez, √™tre conservateur dans ce que vous faites".  En d'autres termes: s'il existe une opportunit√©, sans compromettre l'ergonomie et les performances, de rendre le type de valeurs accept√©es plus g√©n√©ral - il est logique de le faire. </p><br><p>  Consid√©rez cette option: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, El: <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(x: <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">IntoIterator</span></span>&lt;Item = &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> El&gt;, y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>, { <span class="hljs-comment"><span class="hljs-comment">// 10000    }</span></span></code> </pre> <br><p>  Que savons-nous de cette fonction maintenant?  Tout est le m√™me, seulement maintenant il n'accepte pas une liste ou une tranche en entr√©e, mais un objet arbitraire, qui peut √™tre fait pour donner alternativement des liens vers des objets de type El et les comparer avec celui recherch√©: l'analogue en Java, si je me souviens bien, √©tait serait une fonction qui prend un <code>Iterable&lt;Comparable&gt;</code> . </p></div></div><br><h4 id="kak-ranshe-tolko-strozhe">  Comme auparavant, seulement plus strict </h4><br><p>  Cependant, par exemple, les garanties offertes par le compilateur √† des √©tapes d√©j√† connues ne nous suffisent pas.  Ou, disons, nous ne voulons pas (pour une raison ou une autre) entrer dans un tas, mais voulons travailler sur la pile, ce qui signifie que nous avons besoin d'un tableau au lieu d'un vecteur, mais en m√™me temps, nous voulons que notre code soit g√©n√©ralis√© √† diff√©rentes tailles du tableau .  Ou nous voulons que la fonction soit optimis√©e autant que possible pour chaque taille sp√©cifique de la liste d'entr√©e. <br><br>  En bref, nous avons besoin d'un tableau g√©n√©rique - et Rust a d√©j√† un package qui le fournit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">textuellement</a> . </p><br><p>  Nous avons maintenant √† notre disposition le code suivant: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> generic_array::{GenericArray, ArrayLength}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;El, Size&gt;(x: GenericArray&lt;El, Size&gt;, y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>, Size: ArrayLength&lt;El&gt;, { <span class="hljs-comment"><span class="hljs-comment">// 10000    }</span></span></code> </pre> <br><p>  Que savons-nous de ce code?  Que la fonction prend un tableau d'une certaine taille fixe, refl√©t√©e dans son type (et compil√©e ind√©pendamment pour chacune de ces tailles).  Jusqu'√† pr√©sent, cela ne change pas grand-chose - au final, exactement les m√™mes garanties, non seulement au stade de la monomorphisation, mais au moment de l'ex√©cution, √† condition que la version pr√©c√©dente soit coup√©e. </p><br><p>  Mais nous pouvons aller encore plus loin. </p><br><h4 id="arifmetika-urovnya-tipov">  Type Arithm√©tique de niveau </h4><br><p>  L'article original mentionnait plusieurs garanties que nous avons re√ßues d'Idris et que nous ne pouvions obtenir de personne d'autre.  L'un d'eux - et peut-√™tre le plus simple, car pour cela vous n'avez m√™me pas besoin d'√©crire une preuve √† part enti√®re ou un test √† part enti√®re, mais seulement pour sp√©cifier un peu le type - il dit que la valeur de retour, si elle existe (c'est-√†-dire si ce n'est pas <code>Nothing</code> ), ne doit pas d√©passer la longueur de la liste d'entr√©e. <br><br>  Il semblerait que la condition n√©cessaire pour une telle garantie soit la pr√©sence de types d√©pendants, enfin, ou au moins une sorte de similitude, et il serait √©trange d'attendre quelque chose comme √ßa de Rust, non? </p><br><p>  Rencontre - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">typenum</a> .  Avec lui, notre fonction peut √™tre repr√©sent√©e comme ceci: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> generic_array::{ArrayLength, GenericArray}; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> typenum::{IsLess, Unsigned, B1}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnsignedLessThan</span></span></span></span>&lt;T&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_usize</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;Less, More&gt; UnsignedLessThan&lt;More&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Less <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> Less: IsLess&lt;More, Output = B1&gt;, Less: Unsigned, { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_usize</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> { &lt;<span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Unsigned&gt;::USIZE } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;El, Size&gt;(x: GenericArray&lt;El, Size&gt;, y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;dyn UnsignedLessThan&lt;Size&gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>, Size: ArrayLength&lt;El&gt;, { <span class="hljs-comment"><span class="hljs-comment">// 10000    }</span></span></code> </pre> <br><p>  "Qu'est-ce que c'est que cette magie noire?!"  - demandez-vous.  Et vous aurez certainement raison: le typenum est cette magie noire, et les tentatives pour l'utiliser au moins d'une mani√®re ou d'une autre sont doublement. <br><br>  N√©anmoins, la signature de cette fonction est assez claire. </p><br><ul><li>  La fonction accepte un tableau d'√©l√©ments El de longueur Size et un √©l√©ment de type El. </li><li>  La fonction renvoie une valeur Option qui, si elle est Some, <br><ul><li>  Il s'agit d'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">objet trait</a> bas√© sur le type <code>UnsignedLessThan&lt;T&gt;</code> , qui accepte le type Size comme param√®tre; </li><li>  √† son tour, le <code>IsLess&lt;T&gt;</code> <code>UnsignedLessThan&lt;T&gt;</code> <code>IsLess&lt;T&gt;</code> impl√©ment√© pour tous les types qui impl√©mentent <code>Unsigned</code> et <code>IsLess&lt;T&gt;</code> pour lesquels <code>IsLess&lt;T&gt;</code> renvoie B1, c'est-√†-dire  vrai </li></ul></li></ul><br><p>  En d'autres termes, de cette mani√®re, nous avons √©crit une fonction qui est <em>garantie de</em> renvoyer un nombre non n√©gatif (non sign√©) <em>plus petit</em> que la taille d'origine du tableau (ou plut√¥t, bien s√ªr, elle retourne ce m√™me objet trait, √† partir duquel nous devrons appeler plus tard la m√©thode <code>as_usize</code> , garantie de renvoyer un tel nombre) . </p><br><p>  Il y a exactement deux astuces dans cette approche: </p><br><ol><li>  Nous pouvons sensiblement perdre en performance.  Si soudain, pour une raison quelconque, une telle fonction se trouve dans la partie "chaude" du programme, le besoin constant d'appels dynamiques peut √™tre l'une des op√©rations les plus lentes.  Cependant, cet inconv√©nient n'est peut-√™tre pas aussi important qu'il y para√Æt, mais il y en a un second: </li><li>  Pour que cette fonction soit compil√©e correctement, nous devrons soit √©crire r√©ellement √† l'int√©rieur la preuve de l'exactitude de son travail, soit ¬´tromper¬ª le syst√®me de <code>unsafe</code> travers <code>unsafe</code> .  Le premier est trop compliqu√© pour l'article du vendredi, mais le second n'est qu'une arnaque. </li></ol><br><h4 id="zaklyuchenie">  Conclusion </h4><br><p>  Bien s√ªr, dans la pratique, dans de tels cas, soit la deuxi√®me impl√©mentation (r√©ception d'une tranche de type arbitraire) soit l'impl√©mentation sous un spoiler (r√©ception d'un objet it√©rable) sera utilis√©e.  Tous les arguments ult√©rieurs n'ont presque certainement aucun int√©r√™t pratique et servent uniquement d'exercice pour travailler avec un syst√®me de type. </p><br><p>  N√©anmoins, le fait que le syst√®me de type Rust puisse √™tre en mesure d'√©muler l'une des caract√©ristiques du syst√®me de type Idris manifestement plus fort est, √† mon avis, tout √† fait indicatif. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr468145/">https://habr.com/ru/post/fr468145/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr468125/index.html">Animation dans Asymptote</a></li>
<li><a href="../fr468127/index.html">Evolution CMS 2.0 sur les composants Laravel 6.0 - l'√©volution naturelle de MODX Evolution</a></li>
<li><a href="../fr468135/index.html">Top 10 des rapports JPoint 2019</a></li>
<li><a href="../fr468139/index.html">√âcouteurs de natation Aftershokz Xtrainerz avec son √† conduction osseuse - Cool</a></li>
<li><a href="../fr468141/index.html">T√¢che: extraire des expressions cl√©s du texte en russe. Python NLP</a></li>
<li><a href="../fr468147/index.html">Invitation au spectacle de lumi√®re ¬´Circle of Light¬ª 2019 √† Moscou et un petit initi√© de l'un des sites</a></li>
<li><a href="../fr468151/index.html">Vuln√©rabilit√©s GeekBrains: Pourquoi payer de l'argent pour les cours si vous pouvez simplement les t√©l√©charger?</a></li>
<li><a href="../fr468155/index.html">Tendances des nouveaux produits</a></li>
<li><a href="../fr468157/index.html">Point de vue d'EcmaScript sur la th√©orie g√©n√©rale de la POO</a></li>
<li><a href="../fr468163/index.html">Oracle VM Server for SPARC for Dummies (How-to)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>