<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ§¦ ğŸ’Ÿ ğŸ‘¨ğŸ¼â€ğŸ”§ O passado, presente e futuro do Docker e outros tempos de execuÃ§Ã£o de contÃªineres em Kubernetes ğŸ§™ğŸ¼ ğŸš ğŸˆ¯ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nota perev. : JÃ¡ escrevemos mais de uma publicaÃ§Ã£o (consulte os links no final do artigo) sobre tempos de execuÃ§Ã£o do contÃªiner (tempos de execuÃ§Ã£o do...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>O passado, presente e futuro do Docker e outros tempos de execuÃ§Ã£o de contÃªineres em Kubernetes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/429952/">  <i><b>Nota</b></i>  <i><b>perev.</b></i>  <i>: JÃ¡ escrevemos mais de uma publicaÃ§Ã£o (consulte os links no final do artigo) sobre tempos de execuÃ§Ã£o do contÃªiner (tempos de execuÃ§Ã£o do contÃªiner) - como regra geral, eles sÃ£o discutidos no contexto do Kubernetes.</i>  <i>No entanto, muitas vezes esses materiais suscitaram perguntas dos leitores, indicando uma falta de entendimento de onde o prÃ³ximo projeto veio, como ele estÃ¡ conectado com outros e o que estÃ¡ acontecendo em todo esse â€œzoolÃ³gicoâ€ de contÃªineres.</i> <br><br><img src="https://habrastorage.org/webt/cy/td/t5/cytdt5jmmufxrtz_b41os56vneg.png"><br><br>  <i>Um artigo recente de Phil Estes, diretor tÃ©cnico de arquitetura de contÃªineres e arquitetura Linux da IBM Watson &amp; Cloud Platform, fornece uma excelente retrospectiva sobre como navegar e obter uma compreensÃ£o mais ampla de quem perdeu (ou nunca capturou) o encadeamento de eventos.</i>  <i>Sendo um dos mantenedores dos projetos Moby e container, um membro dos comitÃªs tÃ©cnicos da Open Container Initiative (OCI) e da Moby, e tambÃ©m com o status de Docker Captain, o autor escreve sobre o passado, presente e futuro do novo mundo maravilhoso dos tempos de execuÃ§Ã£o de contÃªineres.</i>  <i>E para os mais preguiÃ§osos, o material comeÃ§a com um TL; DR compacto sobre o assunto ...</i> <a name="habracut"></a><br><br><h2>  Principais conclusÃµes </h2><br><ul><li>  Com o tempo, a escolha entre tempos de execuÃ§Ã£o de contÃªineres aumentou, oferecendo mais opÃ§Ãµes do que o popular mecanismo Docker. </li><li>  A Open Container Initiative (OCI) padronizou com sucesso o conceito de imagem de contÃªiner e contÃªiner para garantir a interoperabilidade <i>(â€œinteroperabilidadeâ€ - aprox. Transl.)</i> Entre ambientes de tempo de execuÃ§Ã£o. </li><li>  O Kubernetes adicionou a Interface de Tempo de ExecuÃ§Ã£o do ContÃªiner (CRI), que permite que os contÃªineres se conectem aos ambientes de tempo de execuÃ§Ã£o com a camada de orquestraÃ§Ã£o subjacente no K8s. </li><li>  As inovaÃ§Ãµes nessa Ã¡rea permitem que os contÃªineres aproveitem a virtualizaÃ§Ã£o leve e outras tÃ©cnicas exclusivas de isolamento para aumentar os requisitos de seguranÃ§a. </li><li>  Com o OCI e o CRI, a interoperabilidade e a escolha se tornaram realidade no ecossistema de ambientes de contÃªiner e orquestraÃ§Ã£o de tempo de execuÃ§Ã£o. </li></ul><br>  A tecnologia de conteinerizaÃ§Ã£o existe hÃ¡ algum tempo no mundo dos sistemas operacionais Linux - as primeiras idÃ©ias sobre espaÃ§os para nome separados para sistemas e processos de arquivos surgiram hÃ¡ mais de uma dÃ©cada.  E em um passado relativamente recente, o LXC apareceu e se tornou a maneira padrÃ£o para os usuÃ¡rios do Linux interagirem com a poderosa tecnologia de isolamento escondida no kernel do Linux. <br><br>  No entanto, apesar das tentativas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">do LXC de</a> ocultar a complexidade de combinar vÃ¡rios "interiores" tecnolÃ³gicos do que hoje chamamos de contÃªiner atualmente, os contÃªineres continuaram sendo uma espÃ©cie de mÃ¡gica e se tornaram mais fortes apenas no mundo daqueles com conhecimento especial e nÃ£o obtiveram ampla distribuiÃ§Ã£o entre as massas. <br><br>  Tudo mudou em 2014 com o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Docker</a> , quando um novo invÃ³lucro de desenvolvedor para a mesma tecnologia de kernel Linux que o LXC tinha em serviÃ§o apareceu - afinal, as versÃµes anteriores do Docker â€œnos bastidoresâ€ usavam o LXC e os contÃªineres se tornaram - um fenÃ´meno de massa real, pois os desenvolvedores estavam imbuÃ­dos da simplicidade e das possibilidades de reutilizar imagens de contÃªineres do Docker e comandos simples para trabalhar com eles. <br><br>  Ã‰ claro que a Docker nÃ£o foi a Ãºnica pessoa que queria ganhar uma participaÃ§Ã£o no mercado de contÃªineres quando o hype que os acompanhou nÃ£o pensou em diminuir apÃ³s o primeiro interesse explosivo em 2014.  Ao longo dos anos, surgiram vÃ¡rias idÃ©ias alternativas para ambientes de contÃªineres executÃ¡veis â€‹â€‹do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CoreOS (rkt)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Intel Clear Containers</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">hyper.sh</a> (virtualizaÃ§Ã£o leve baseada em contÃªiner) e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Singularidade</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mudanÃ§a</a> no mundo da pesquisa em computaÃ§Ã£o de alto desempenho (HPC). <br><br>  O mercado continuou a crescer e amadurecer e, com a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Open Container Initiative (OCI),</a> veio o esforÃ§o de padronizar as idÃ©ias iniciais promovidas pela Docker.  Atualmente, muitos ambientes executÃ¡veis â€‹â€‹de contÃªineres jÃ¡ sÃ£o compatÃ­veis com a OCI ou estÃ£o a caminho disso, oferecendo aos fabricantes condiÃ§Ãµes iguais para promover seus recursos e capacidades focados em um aplicativo especÃ­fico. <br><br><h2>  Popularidade de Kubernetes </h2><br>  O prÃ³ximo estÃ¡gio na evoluÃ§Ã£o dos contÃªineres foi combinar contÃªineres de computaÃ§Ã£o distribuÃ­dos Ã  microsserviÃ§os com contÃªineres - e tudo isso no novo mundo de iteraÃ§Ãµes rÃ¡pidas de desenvolvimento e implantaÃ§Ã£o (podemos dizer que o DevOps), que estava ganhando impulso ativamente junto com a popularidade do Docker. <br><br>  Embora o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Apache Mesos</a> e outras plataformas de orquestraÃ§Ã£o de software existissem antes do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Kubernetes</a> dominar, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">K8s decolou</a> rapidamente de um pequeno projeto de cÃ³digo aberto do Google para o projeto principal da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CNC Native (Cloud Native Computing Foundation)</a> . <br><br>  <i><b>Nota</b></i>  <i><b>perev.</b></i>  <i>: VocÃª sabia que o CNCF <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">apareceu</a> em 2015 por ocasiÃ£o do lanÃ§amento do Kubernetes 1.0?</i>  <i>Ao mesmo tempo, o projeto foi transferido pelo Google para uma nova organizaÃ§Ã£o independente que se tornou parte da Linux Foundation.</i> <br><br><img src="https://habrastorage.org/webt/hu/_u/em/hu_uemcx44qdursrnr_nsc04gie.png"><br>  <i>Evento de lanÃ§amento do K8s 1.0 patrocinado por, entre outros, Mesosfera, CoreOS, Mirantis, OpenStack, Bitnami</i> <br><img src="https://habrastorage.org/webt/lq/rf/ab/lqrfabydpe9_lbh9zv5x8titb48.png"><br>  <i>Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">notÃ­cias</a> sobre o lanÃ§amento do Kubernetes 1.0 no ZDNet</i> <br><br>  Mesmo depois que o Docker lanÃ§ou a plataforma de orquestraÃ§Ã£o rival, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Swarm</a> , incorporada ao Docker e apresentando simplicidade no Docker e foco na configuraÃ§Ã£o padrÃ£o de cluster seguro, isso nÃ£o era mais suficiente para conter o crescente interesse no Kubernetes. <br><br>  No entanto, muitas partes interessadas fora das comunidades nativas da nuvem em rÃ¡pido crescimento estavam confusas.  Um observador comum nÃ£o conseguia descobrir o que estava acontecendo: os Kubernetes brigam com o Docker ou com a cooperaÃ§Ã£o deles.  Como o Kubernetes era apenas uma plataforma de orquestraÃ§Ã£o, era necessÃ¡rio um ambiente de contÃªiner executÃ¡vel que iniciasse diretamente contÃªineres orquestrados no Kubernetes.  Desde o inÃ­cio, o Kubernetes usou o mecanismo do Docker e, apesar da tensÃ£o competitiva entre o Swarm e o Kubernetes, o Docker ainda era o tempo de execuÃ§Ã£o padrÃ£o e era necessÃ¡rio para o cluster Kubernetes funcionar. <br><br>  Com um pequeno nÃºmero de tempos de execuÃ§Ã£o de contÃªiner alÃ©m do Docker, parecia claro que o tempo de execuÃ§Ã£o do emparelhamento com o Kubernetes exigiria uma interface especialmente escrita - shim - para cada tempo de execuÃ§Ã£o.  A falta de uma interface clara para implementar os tempos de execuÃ§Ã£o do contÃªiner dificultava a adiÃ§Ã£o de suporte para novos tempos de execuÃ§Ã£o no Kubernetes. <br><br><h2>  Interface de Tempo de ExecuÃ§Ã£o do ContÃªiner (CRI) </h2><br>  Para resolver a crescente complexidade da implementaÃ§Ã£o de tempos de execuÃ§Ã£o no Kubernetes, a comunidade definiu uma funÃ§Ã£o especÃ­fica da interface que o tempo de execuÃ§Ã£o do contÃªiner deveria implementar no Kubernetes - nomeando-a <a href="">Interface de Tempo de ExecuÃ§Ã£o do Container (CRI)</a> <i>(que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">apareceu</a> no Kubernetes 1.5 - traduÃ§Ã£o aproximada).</i> .  Esse evento nÃ£o apenas ajudou o problema do crescente nÃºmero de fragmentos da base de cÃ³digo Kubernetes que afetava o uso de tempos de execuÃ§Ã£o do contÃªiner, mas tambÃ©m ajudou a entender quais funÃ§Ãµes deveriam ser suportadas por tempos de execuÃ§Ã£o em potencial, se eles quisessem cumprir o CRI. <br><br>  Como vocÃª pode imaginar, o CRI espera coisas muito simples do tempo de execuÃ§Ã£o.  Esse ambiente deve poder iniciar e parar pods, manipular todas as operaÃ§Ãµes com contÃªineres no contexto de pods (iniciar, parar, pausar, eliminar, excluir) e tambÃ©m oferecer suporte ao gerenciamento de imagens de contÃªineres usando o registro.  TambÃ©m existem funÃ§Ãµes auxiliares para coletar logs, mÃ©tricas etc. <br><br>  Quando novos recursos aparecem no Kubernetes, se eles dependem da camada do tempo de execuÃ§Ã£o do contÃªiner, essas alteraÃ§Ãµes sÃ£o feitas na API CRI com versÃ£o.  Por sua vez, isso cria uma nova dependÃªncia funcional do Kubernetes e requer o lanÃ§amento de versÃµes mais recentes dos tempos de execuÃ§Ã£o que suportam novos recursos (um exemplo recente sÃ£o os espaÃ§os de nome de usuÃ¡rio). <br><br><h2>  CenÃ¡rio atual do CRI </h2><br>  A partir de 2018, existem vÃ¡rias opÃ§Ãµes para uso como tempos de execuÃ§Ã£o de contÃªineres no Kubernetes.  Conforme mostrado na ilustraÃ§Ã£o abaixo, uma das opÃ§Ãµes reais ainda Ã© o Docker, com seu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dockershim</a> que implementa a API do CRI.  De fato, na maioria das instalaÃ§Ãµes do Kubernetes atualmente, Ã© ele, Docker, quem permanece o tempo de execuÃ§Ã£o padrÃ£o. <br><br><img src="https://habrastorage.org/webt/p6/9q/0h/p69q0hpabyujabund9bgicx12q4.jpeg"><br><br>  Uma das conseqÃ¼Ãªncias interessantes da tensÃ£o entre a estratÃ©gia de orquestraÃ§Ã£o do Docker com o Swarm e a comunidade Kubernetes foi um projeto conjunto, que tomou a base do tempo de execuÃ§Ã£o do Docker e reuniu um novo projeto de cÃ³digo aberto desenvolvido em conjunto - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">contemerd</a> .  Com o tempo, o containererd foi transferido para o CNCF, a mesma organizaÃ§Ã£o que gerencia e Ã© dona do projeto Kubernetes.  <i>( <b>Nota</b> : traduzimos a aparÃªncia de container em mais detalhes em um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo separado</a> .)</i> <br><br><img src="https://habrastorage.org/webt/yr/o1/wx/yro1wxcji1jh-xettnzp-jiyiu8.png"><br>  <i>A partir do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">anÃºncio de</a> containsererd no blog Docker</i> <br><br>  O Containerd, sendo uma implementaÃ§Ã£o simples, bÃ¡sica e <i>independente da</i> empresa <i>(nÃ£o opinativa)</i> do tempo de execuÃ§Ã£o para o Docker e o Kubernetes (via CRI), comeÃ§ou a ganhar popularidade como um substituto potencial para o Docker em muitas instalaÃ§Ãµes do Kubernetes.  AtÃ© o momento, o IBM Cloud e o Google Cloud possuem clusters baseados emerd no modo beta / acesso antecipado.  O Microsoft Azure tambÃ©m prometeu mudar para oerderd no futuro, e a Amazon ainda estÃ¡ considerando vÃ¡rias opÃ§Ãµes de tempos de execuÃ§Ã£o para suas soluÃ§Ãµes de contÃªiner (ECS e EKS), enquanto continua usando o Docker. <br><br>  A Red Hat entrou no espaÃ§o de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tempo de execuÃ§Ã£o</a> do contÃªiner criando uma implementaÃ§Ã£o simples de CRI chamada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cri-o com</a> base na implementaÃ§Ã£o de referÃªncia da OCI, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">runc</a> .  O Docker e oerderd tambÃ©m sÃ£o baseados em runc, mas os criadores do cri-o afirmam que seus tempos de execuÃ§Ã£o sÃ£o "apenas o suficiente" para o Kubernetes e nÃ£o precisam de mais - apenas adicionaram as funÃ§Ãµes mais necessÃ¡rias para implementar o Kubernetes CRI sobre o binÃ¡rio bÃ¡sico do runc.  <i>( <b>ObservaÃ§Ã£o</b> : escrevemos mais sobre o projeto CRI-O <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste artigo</a> e aqui sobre seu desenvolvimento na forma de podman.)</i> <br><br>  Projetos leves de virtualizaÃ§Ã£o: Intel Clear Containers e hyper.sh - apareceram nos bastidores da OpenStack Foundation, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">contÃªineres Kata</a> e oferecem sua visÃ£o de contÃªineres virtualizados para isolamento adicional usando uma implementaÃ§Ã£o de CRI chamada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">frakti</a> .  Cri-o e container tambÃ©m funcionam com contÃªineres Kata, portanto, seu tempo de execuÃ§Ã£o compatÃ­vel com OCI pode ser selecionado como uma opÃ§Ã£o conectÃ¡vel. <br><br><h2>  Prevendo o futuro </h2><br>  Dizer que vocÃª sabe que o futuro geralmente nÃ£o Ã© muito sÃ¡bio, mas podemos pelo menos corrigir algumas tendÃªncias emergentes Ã  medida que o ecossistema de contÃªineres se move do entusiasmo e do hype para um estÃ¡gio mais maduro da nossa existÃªncia. <br><br>  Havia temores iniciais de que o ecossistema de contÃªineres formaria um ambiente fragmentado, cujos diferentes participantes apresentariam idÃ©ias diferentes e incompatÃ­veis sobre o que Ã© um contÃªiner.  GraÃ§as ao trabalho da OCI e Ã s aÃ§Ãµes responsÃ¡veis â€‹â€‹dos principais fornecedores e participantes, vimos um ambiente saudÃ¡vel no setor entre as ofertas de software que preferiam a compatibilidade com a OCI. <br><br>  Mesmo em ambientes mais recentes, onde o padrÃ£o de uso do Docker encontrou menos resistÃªncia devido Ã s restriÃ§Ãµes existentes - por exemplo, no HPC - todas as tentativas de criar ambientes de contÃªineres nÃ£o baseados no Docker tambÃ©m chamaram a atenÃ§Ã£o para o OCI.  EstÃ£o em andamento discussÃµes sobre se a OCI pode ser uma soluÃ§Ã£o viÃ¡vel para as necessidades especÃ­ficas das comunidades de cientistas e pesquisadores. <br><br>  Adicionando a isso a padronizaÃ§Ã£o dos tempos de execuÃ§Ã£o do contÃªiner de plug-in no Kubernetes usando o CRI, podemos imaginar um mundo em que desenvolvedores e administradores podem escolher as ferramentas e pilhas de software certas para suas tarefas, aguardando e observando a interoperabilidade em todo o ecossistema do contÃªiner. <br><br>  Considere um exemplo especÃ­fico para entender melhor este mundo: <br><br><ul><li>  Um desenvolvedor com um MacBook usa o Docker para Mac para desenvolver seu aplicativo e atÃ© usa o suporte Kubernetes interno (o Docker aqui funciona como tempo de execuÃ§Ã£o CRI) para tentar implantar um novo aplicativo nos pods do K8s. </li><li>  O aplicativo passa pelo CI / CD no software do fornecedor, que usa cÃ³digo runc e especial (gravado pelo fornecedor) para empacotar a imagem OCI e carregÃ¡-la no registro corporativo de contÃªineres para teste. </li><li>  A instalaÃ§Ã£o local do cluster Kubernetes, trabalhando com o container como um tempo de execuÃ§Ã£o CRI, executa um conjunto de testes para o aplicativo. </li><li>  Por alguma razÃ£o, essa empresa escolheu os contÃªineres Kata para determinadas cargas de trabalho na produÃ§Ã£o; portanto, quando vocÃª implanta o aplicativo, ele inicia nos pods com o container configurado para usar os contÃªineres Kata como tempo de execuÃ§Ã£o em vez de runc. </li></ul><br>  Todo o cenÃ¡rio descrito funciona maravilhosamente devido Ã  compatibilidade com a especificaÃ§Ã£o OCI para ambientes e imagens de tempo de execuÃ§Ã£o e o fato de o CRI fornecer flexibilidade na escolha do tempo de execuÃ§Ã£o. <br><br>  Essa possÃ­vel flexibilidade e escolha tornam o ecossistema de contÃªineres verdadeiramente notÃ¡vel e tambÃ©m Ã© uma condiÃ§Ã£o muito importante para a maturidade da indÃºstria, que cresce tÃ£o rapidamente desde 2014.  No limiar de 2019 e nos anos seguintes, vejo um futuro brilhante com inovaÃ§Ãµes e flexibilidade contÃ­nuas para quem usa e cria plataformas baseadas em contÃªineres. <br><br>  Mais informaÃ§Ãµes sobre esse tÃ³pico podem ser encontradas em uma recente conversa de Phil Estes no QCon NY: â€œ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mergulho profundo</a> nos tempos de execuÃ§Ã£o do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CRI: quem estÃ¡ executando meu pod de Kubernetes!?</a>  " <br><br><h2>  PS do tradutor </h2><br>  Leia tambÃ©m em nosso blog: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Red Hat substitui o Docker pelo Podman</a> "; </li><li>  â€œA <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">integraÃ§Ã£o do container com o Kubernetes, substituindo o Docker, estÃ¡ pronta para produÃ§Ã£o</a> â€; </li><li>  â€œ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CRI-O - uma alternativa ao Docker para lanÃ§amento de contÃªineres no Kubernetes</a> â€; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O que e por que o Docker estÃ¡ fazendo o Moby para se integrar ao Kubernetes?"</a>  " </li><li>  â€œ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">EntÃ£o, o que Ã© um pod em Kubernetes?</a>  " </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt429952/">https://habr.com/ru/post/pt429952/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt429940/index.html">Por que as plantas precisam de aprendizado de mÃ¡quina</a></li>
<li><a href="../pt429942/index.html">Obter mÃºsica VK atravÃ©s de uma API de terceiros</a></li>
<li><a href="../pt429946/index.html">Loucura e sucesso do cÃ³digo do banco de dados Oracle</a></li>
<li><a href="../pt429948/index.html">Por que os gerentes de produto da fintech sÃ£o necessÃ¡rios</a></li>
<li><a href="../pt429950/index.html">Como manter hÃ¡bitos saudÃ¡veis â€‹â€‹de comunicaÃ§Ã£o de equipes remotas</a></li>
<li><a href="../pt429954/index.html">O programador das casas de apostas irlandesas</a></li>
<li><a href="../pt429956/index.html">IntegraÃ§Ã£o contÃ­nua no Yandex. Parte 2</a></li>
<li><a href="../pt429958/index.html">Cinco regras de depuraÃ§Ã£o fÃ¡ceis para iniciantes</a></li>
<li><a href="../pt429960/index.html">10 razÃµes pelas quais os clientes estÃ£o cancelando a assinatura de um produto</a></li>
<li><a href="../pt429964/index.html">U> X> I> P ... ou "Como os nomes das profissÃµes se destacam"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>