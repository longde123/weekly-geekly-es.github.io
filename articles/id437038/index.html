<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛋️ 👨‍👩‍👦 🌦️ Panduan Terjemahan Aliran Benjamin Winterberg Stream ⛱️ 🎖️ 🌑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Saya hadir untuk Anda terjemahan artikel " Java 8 Stream Tutorial ". 

 Tutorial berbasis kode ini memberikan tinjauan komprehensif aliran...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Panduan Terjemahan Aliran Benjamin Winterberg Stream</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437038/">  Halo, Habr!  Saya hadir untuk Anda terjemahan artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Java 8 Stream Tutorial</a> ". <br><br>  Tutorial berbasis kode ini memberikan tinjauan komprehensif aliran di Jawa 8. Ketika saya pertama kali memperkenalkan API Stream, saya bingung dengan namanya karena sangat konsisten dengan InputStream dan OutputStream dari paket java.io;  Namun, utas di Java 8 adalah sesuatu yang sangat berbeda. <a name="habracut"></a>  Thread adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">monad</a> yang memainkan peran penting dalam pengembangan pemrograman fungsional di Jawa. <br><blockquote>  Dalam pemrograman fungsional, monad adalah struktur yang mewakili perhitungan dalam bentuk rangkaian langkah-langkah yang berurutan.  Jenis dan struktur monad menentukan rantai operasi, dalam kasus kami, urutan metode dengan fungsi bawaan dari jenis yang diberikan. </blockquote>  Tutorial ini akan mengajarkan Anda cara bekerja dengan stream dan menunjukkan cara menangani berbagai metode yang tersedia di Stream API.  Kami akan menganalisis urutan operasi dan melihat bagaimana urutan metode dalam rantai mempengaruhi kinerja.  <code>flatMap</code> metode Stream API yang kuat seperti <code>reduce</code> , <code>collect</code> dan <code>flatMap</code> .  Di akhir manual, kami akan memperhatikan pekerjaan paralel dengan stream. <br><br>  Jika Anda tidak merasa bebas untuk bekerja dengan ekspresi lambda, antarmuka fungsional, dan metode referensi, akan berguna bagi Anda untuk membiasakan diri dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">panduan saya untuk inovasi di Java 8</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terjemahan</a> dalam Habré), dan setelah itu kembali mempelajari aliran. <br><br><h3>  Cara kerja utas </h3><br>  Aliran mewakili urutan elemen dan menyediakan berbagai metode untuk melakukan perhitungan pada elemen ini: <br><br><pre> <code class="java hljs">List&lt;String&gt; myList = Arrays.asList(<span class="hljs-string"><span class="hljs-string">"a1"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"c2"</span></span>, <span class="hljs-string"><span class="hljs-string">"c1"</span></span>); myList .stream() .filter(s -&gt; s.startsWith(<span class="hljs-string"><span class="hljs-string">"c"</span></span>)) .map(String::toUpperCase) .sorted() .forEach(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// C1 // C2</span></span></code> </pre> <br>  Metode aliran adalah <i>perantara</i> (intermediate) dan <i>terminal</i> (terminal).  Metode menengah mengembalikan aliran, yang memungkinkan banyak metode ini disebut secara berurutan.  Metode terminal tidak mengembalikan nilai (batal) atau mengembalikan hasil dari jenis selain aliran.  Dalam contoh di atas, <code>filter</code> , <code>map</code> dan <code>sorted</code> bersifat menengah, dan <code>forEach</code> adalah terminal.  Untuk daftar lengkap metode aliran yang tersedia, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> .  Rantai operasi aliran semacam itu juga dikenal sebagai pipa operasi. <br><br>  Sebagian besar metode dari Stream API menerima sebagai ekspresi parameter lambda, antarmuka fungsional yang menggambarkan perilaku spesifik metode.  Sebagian besar dari mereka harus secara bersamaan tidak mencampuri dan berkewarganegaraan.  Apa artinya ini? <br><br>  Metode tidak mengganggu jika tidak mengubah data dasar yang mendasari aliran.  Misalnya, dalam contoh di atas, tidak ada ekspresi lambda memodifikasi daftar array daftar. <br><br>  Metode stateless jika urutan operasi dilakukan ditentukan.  Misalnya, tidak satu pun ekspresi lambda dari contoh tergantung pada variabel yang bisa berubah atau keadaan ruang eksternal yang dapat berubah pada saat dijalankan. <br><br><h3>  Berbagai jenis utas </h3><br>  Streaming dapat dibuat dari berbagai sumber data, terutama dari koleksi.  Daftar dan Set mendukung metode <code>stream()</code> baru <code>stream()</code> dan <code>parllelStream()</code> untuk membuat stream berurutan dan paralel.  Utas paralel dapat bekerja dalam mode multi-utas (pada banyak utas) dan akan dibahas pada akhir manual.  Sementara itu, pertimbangkan utas berurutan: <br><br><pre> <code class="java hljs">Arrays.asList(<span class="hljs-string"><span class="hljs-string">"a1"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a3"</span></span>) .stream() .findFirst() .ifPresent(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// a1</span></span></code> </pre><br>  Di sini, memanggil metode <code>stream()</code> pada daftar mengembalikan objek stream normal. <br>  Namun, untuk bekerja dengan aliran, sama sekali tidak perlu membuat koleksi: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"a1"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a3"</span></span>) .findFirst() .ifPresent(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// a1</span></span></code> </pre><br>  Cukup gunakan <code>Stream.of()</code> untuk membuat aliran dari beberapa referensi objek. <br><br>  Selain aliran objek biasa, Java 8 memiliki jenis aliran khusus untuk bekerja dengan tipe primitif: int, panjang, ganda.  Seperti yang Anda duga, ini adalah <code>IntStream</code> , <code>LongStream</code> , <code>DoubleStream</code> . <br><br>  Aliran IntStream dapat menggantikan reguler untuk (;;) <code>IntStream.range()</code> menggunakan <code>IntStream.range()</code> : <br><br><pre> <code class="java hljs">IntStream.range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) .forEach(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// 1 // 2 // 3</span></span></code> </pre><br>  Semua aliran ini untuk bekerja dengan tipe primitif bekerja seperti aliran objek biasa, kecuali untuk yang berikut: <br><br><ul><li>  Streaming primitif menggunakan ekspresi lambda khusus.  Misalnya, IntFunction alih-alih Function, atau IntPredicate alih-alih Predicate. </li><li>  Streaming primitif mendukung metode terminal tambahan: <code>sum()</code> dan <code>average()</code> - <code>average()</code> <br><br><pre> <code class="java hljs">Arrays.stream(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}) .map(n -&gt; <span class="hljs-number"><span class="hljs-number">2</span></span> * n + <span class="hljs-number"><span class="hljs-number">1</span></span>) .average() .ifPresent(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// 5.0</span></span></code> </pre><br></li></ul><br>  Terkadang berguna untuk mengubah aliran objek menjadi aliran primitif atau sebaliknya.  Untuk tujuan ini, aliran objek mendukung metode khusus: <code>mapToInt()</code> , <code>mapToLong()</code> , <code>mapToDouble()</code> : <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"a1"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a3"</span></span>) .map(s -&gt; s.substring(<span class="hljs-number"><span class="hljs-number">1</span></span>)) .mapToInt(Integer::parseInt) .max() .ifPresent(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// 3</span></span></code> </pre><br>  Streaming primitif dapat dikonversi menjadi stream objek dengan memanggil <code>mapToObj()</code> : <br><br><pre> <code class="java hljs">IntStream.range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) .mapToObj(i -&gt; <span class="hljs-string"><span class="hljs-string">"a"</span></span> + i) .forEach(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// a1 // a2 // a3</span></span></code> </pre><br>  Dalam contoh berikut, aliran angka floating-point dipetakan ke aliran bilangan bulat dan kemudian dipetakan ke aliran objek: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">2.0</span></span>, <span class="hljs-number"><span class="hljs-number">3.0</span></span>) .mapToInt(Double::intValue) .mapToObj(i -&gt; <span class="hljs-string"><span class="hljs-string">"a"</span></span> + i) .forEach(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// a1 // a2 // a3</span></span></code> </pre><br><h3>  Perintah eksekusi </h3><br>  Sekarang kami telah belajar cara membuat berbagai aliran dan cara bekerja dengannya, kami akan menyelam lebih dalam dan mempertimbangkan bagaimana operasi streaming terlihat di bawah tenda. <br><br>  Karakteristik penting dari metode perantara adalah <i>kemalasan</i> mereka.  Tidak ada metode terminal dalam contoh ini: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .filter(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"filter: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; });</code> </pre><br>  Ketika potongan kode ini dieksekusi, tidak ada yang akan ditampilkan ke konsol.  Dan semua karena metode antara dijalankan hanya jika ada metode terminal.  Mari kita memperluas contoh dengan menambahkan metode terminal <code>forEach</code> : <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .filter(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"filter: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }) .forEach(s -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"forEach: "</span></span> + s));</code> </pre><br>  Eksekusi fragmen kode ini mengarah ke output ke konsol hasil berikut: <br><br><pre> <code class="java hljs">filter: d2 forEach: d2 filter: a2 forEach: a2 filter: b1 forEach: b1 filter: b3 forEach: b3 filter: c forEach: c</code> </pre><br>  Urutan pengaturan hasil mungkin mengejutkan.  Seseorang dengan naif dapat berharap bahwa metode akan dieksekusi "secara horizontal": satu demi satu untuk semua elemen aliran.  Namun, sebaliknya, elemen bergerak di sepanjang rantai "secara vertikal".  Pertama, baris pertama "d2" melewati metode <code>filter</code> , kemudian melalui <code>forEach</code> dan hanya kemudian, setelah melewati elemen pertama melalui seluruh rantai metode, elemen berikutnya mulai diproses. <br><br>  Dengan perilaku ini, Anda dapat mengurangi jumlah operasi aktual: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .map(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"map: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .anyMatch(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"anyMatch: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.startsWith(<span class="hljs-string"><span class="hljs-string">"A"</span></span>); }); <span class="hljs-comment"><span class="hljs-comment">// map: d2 // anyMatch: D2 // map: a2 // anyMatch: A2</span></span></code> </pre><br>  Metode <code>anyMatch</code> akan mengembalikan <i>true</i> segera setelah predikat diterapkan ke elemen yang masuk.  Dalam hal ini, ini adalah elemen kedua dari urutan - "A2".  Dengan demikian, karena eksekusi "vertikal" dari rantai utas, <code>map</code> akan dipanggil hanya dua kali.  Jadi, alih-alih menampilkan semua elemen aliran, <code>map</code> akan dipanggil sesering mungkin. <br><br><h3>  Mengapa urutan itu penting </h3><br>  Contoh berikut terdiri dari dua metode menengah <code>map</code> dan <code>filter</code> dan metode terminal untuk masing-masing.  Pertimbangkan bagaimana metode ini dilakukan: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .map(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"map: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .filter(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"filter: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.startsWith(<span class="hljs-string"><span class="hljs-string">"A"</span></span>); }) .forEach(s -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"forEach: "</span></span> + s)); <span class="hljs-comment"><span class="hljs-comment">// map: d2 // filter: D2 // map: a2 // filter: A2 // forEach: A2 // map: b1 // filter: B1 // map: b3 // filter: B3 // map: c // filter: C</span></span></code> </pre> <br>  Sangat mudah untuk menebak bahwa kedua metode <code>map</code> dan <code>filter</code> disebut 5 kali saat runtime - satu kali untuk setiap elemen koleksi sumber, sedangkan <code>forEach</code> disebut hanya sekali - untuk elemen yang melewati filter. <br><br>  Anda dapat secara signifikan mengurangi jumlah operasi dengan mengubah urutan panggilan metode dengan menempatkan <code>filter</code> di tempat pertama: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .filter(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"filter: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.startsWith(<span class="hljs-string"><span class="hljs-string">"a"</span></span>); }) .map(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"map: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .forEach(s -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"forEach: "</span></span> + s)); <span class="hljs-comment"><span class="hljs-comment">// filter: d2 // filter: a2 // map: a2 // forEach: A2 // filter: b1 // filter: b3 // filter: c</span></span></code> </pre><br>  Sekarang peta hanya dipanggil sekali.  Dengan sejumlah besar elemen input, kami akan mengamati peningkatan nyata dalam produktivitas.  Ingatlah hal ini ketika menyusun rantai metode yang kompleks. <br><br>  Kami memperluas contoh di atas dengan menambahkan operasi pengurutan tambahan - metode yang diurutkan: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .sorted((s1, s2) -&gt; { System.out.printf(<span class="hljs-string"><span class="hljs-string">"sort: %s; %s\n"</span></span>, s1, s2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s1.compareTo(s2); }) .filter(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"filter: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.startsWith(<span class="hljs-string"><span class="hljs-string">"a"</span></span>); }) .map(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"map: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .forEach(s -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"forEach: "</span></span> + s));</code> </pre><br>  Penyortiran adalah jenis khusus dari operasi perantara.  Ini adalah operasi yang disebut stateful, karena untuk mengurutkan koleksi, kondisinya harus diperhitungkan selama operasi. <br><br>  Sebagai hasil dari eksekusi kode ini, kami mendapatkan output berikut ke konsol: <br><br><pre> <code class="java hljs">sort: a2; d2 sort: b1; a2 sort: b1; d2 sort: b1; a2 sort: b3; b1 sort: b3; d2 sort: c; b3 sort: c; d2 filter: a2 map: a2 forEach: A2 filter: b1 filter: b3 filter: c filter: d2</code> </pre><br>  Pertama, seluruh koleksi diurutkan.  Dengan kata lain, metode yang <code>sorted</code> berjalan secara horizontal.  Dalam hal ini, <code>sorted</code> disebut 8 kali untuk beberapa kombinasi elemen dalam koleksi yang masuk. <br><br>  Sekali lagi, kami mengoptimalkan eksekusi kode ini dengan mengubah urutan pemanggilan metode dalam rantai: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .filter(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"filter: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.startsWith(<span class="hljs-string"><span class="hljs-string">"a"</span></span>); }) .sorted((s1, s2) -&gt; { System.out.printf(<span class="hljs-string"><span class="hljs-string">"sort: %s; %s\n"</span></span>, s1, s2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s1.compareTo(s2); }) .map(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"map: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .forEach(s -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"forEach: "</span></span> + s)); <span class="hljs-comment"><span class="hljs-comment">// filter: d2 // filter: a2 // filter: b1 // filter: b3 // filter: c // map: a2 // forEach: A2</span></span></code> </pre><br>  Dalam contoh ini, <code>sorted</code> tidak dipanggil sama sekali.  <code>filter</code> mengurangi pengumpulan input ke satu elemen.  Dalam hal data input besar, kinerja akan mendapat manfaat secara signifikan. <br><br><h3>  Gunakan kembali aliran </h3><br>  Di Java 8, utas tidak dapat digunakan kembali.  Setelah memanggil metode terminal apa pun, utas berakhir: <br><br><pre> <code class="java hljs">Stream&lt;String&gt; stream = Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .filter(s -&gt; s.startsWith(<span class="hljs-string"><span class="hljs-string">"a"</span></span>)); stream.anyMatch(s -&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ok stream.noneMatch(s -&gt; true); // exception</span></span></code> </pre><br>  Memanggil <code>noneMatch</code> setelah <code>anyMatch</code> dalam satu thread menghasilkan pengecualian berikut: <br><br><pre> <code class="java hljs">java.lang.IllegalStateException: stream has already been operated upon or closed at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:<span class="hljs-number"><span class="hljs-number">229</span></span>) at java.util.stream.ReferencePipeline.noneMatch(ReferencePipeline.java:<span class="hljs-number"><span class="hljs-number">459</span></span>) at com.winterbe.java8.Streams5.test7(Streams5.java:<span class="hljs-number"><span class="hljs-number">38</span></span>) at com.winterbe.java8.Streams5.main(Streams5.java:<span class="hljs-number"><span class="hljs-number">28</span></span>)</code> </pre><br>  Untuk mengatasi batasan ini, utas baru harus dibuat untuk setiap metode terminal. <br><br>  Misalnya, Anda dapat membuat <i>pemasok</i> untuk konstruktor utas baru di mana semua metode perantara akan dipasang: <br><br><pre> <code class="java hljs">Supplier&lt;Stream&lt;String&gt;&gt; streamSupplier = () -&gt; Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .filter(s -&gt; s.startsWith(<span class="hljs-string"><span class="hljs-string">"a"</span></span>)); streamSupplier.get().anyMatch(s -&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ok streamSupplier.get().noneMatch(s -&gt; true); // ok</span></span></code> </pre><br>  Setiap panggilan ke metode <code>get</code> membuat thread baru di mana Anda dapat dengan aman memanggil metode terminal yang diinginkan. <br><br><h3>  Metode lanjutan </h3><br>  Utas mendukung sejumlah besar metode berbeda.  Kami telah membiasakan diri dengan metode yang paling penting.  Untuk membiasakan diri dengan sisanya, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> .  Dan sekarang menyelam lebih dalam ke metode yang lebih kompleks: <code>collect</code> , <code>flatMap</code> , dan <code>reduce</code> . <br><br>  Sebagian besar contoh kode di bagian ini merujuk ke cuplikan kode berikut untuk menunjukkan operasi: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ String name; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> age; Person(String name, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> age) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.age = age; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name; } } List&lt;Person&gt; persons = Arrays.asList( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Max"</span></span>, <span class="hljs-number"><span class="hljs-number">18</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Peter"</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Pamela"</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"David"</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>));</code> </pre><br><h4>  Kumpulkan </h4><br>  <code>Collect</code> metode terminal yang sangat berguna, yang digunakan untuk mengonversi elemen aliran ke hasil dari jenis yang berbeda, misalnya, Daftar, Setel atau Peta. <br><br>  <code>Collect</code> menerima <code>Collector</code> yang berisi empat metode berbeda: pemasok.  akumulator, combiner, finisher.  Pada pandangan pertama, ini terlihat sangat rumit, tetapi Java 8 mendukung berbagai kolektor bawaan melalui kelas <code>Collectors</code> , di mana metode yang paling banyak digunakan diimplementasikan. <br><br>  Kasus populer: <br><br><pre> <code class="java hljs">List&lt;Person&gt; filtered = persons .stream() .filter(p -&gt; p.name.startsWith(<span class="hljs-string"><span class="hljs-string">"P"</span></span>)) .collect(Collectors.toList()); System.out.println(filtered); <span class="hljs-comment"><span class="hljs-comment">// [Peter, Pamela]</span></span></code> </pre> <br>  Seperti yang Anda lihat, membuat daftar dari item aliran sangat sederhana.  Tidak perlu daftar tapi banyak?  Gunakan <code>Collectors.toSet()</code> . <br><br>  Dalam contoh berikut, orang dikelompokkan berdasarkan usia: <br><br><pre> <code class="java hljs">Map&lt;Integer, List&lt;Person&gt;&gt; personsByAge = persons .stream() .collect(Collectors.groupingBy(p -&gt; p.age)); personsByAge .forEach((age, p) -&gt; System.out.format(<span class="hljs-string"><span class="hljs-string">"age %s: %s\n"</span></span>, age, p)); <span class="hljs-comment"><span class="hljs-comment">// age 18: [Max] // age 23: [Peter, Pamela] // age 12: [David]</span></span></code> </pre><br>  Kolektor sangat beragam.  Anda juga dapat mengagregasi elemen koleksi, misalnya, menentukan usia rata-rata: <br><br><pre> <code class="java hljs">Double averageAge = persons .stream() .collect(Collectors.averagingInt(p -&gt; p.age)); System.out.println(averageAge); <span class="hljs-comment"><span class="hljs-comment">// 19.0</span></span></code> </pre><br>  Untuk mendapatkan statistik yang lebih komprehensif, kami menggunakan pengumpul ringkasan yang mengembalikan objek khusus dengan informasi: nilai minimum, maksimum dan rata-rata, jumlah nilai dan jumlah elemen: <br><br><pre> <code class="java hljs">IntSummaryStatistics ageSummary = persons .stream() .collect(Collectors.summarizingInt(p -&gt; p.age)); System.out.println(ageSummary); <span class="hljs-comment"><span class="hljs-comment">// IntSummaryStatistics{count=4, sum=76, min=12, average=19.000000, max=23}</span></span></code> </pre><br>  Contoh berikut menggabungkan semua nama dalam satu baris: <br><br><pre> <code class="java hljs">String phrase = persons .stream() .filter(p -&gt; p.age &gt;= <span class="hljs-number"><span class="hljs-number">18</span></span>) .map(p -&gt; p.name) .collect(Collectors.joining(<span class="hljs-string"><span class="hljs-string">" and "</span></span>, <span class="hljs-string"><span class="hljs-string">"In Germany "</span></span>, <span class="hljs-string"><span class="hljs-string">" are of legal age."</span></span>)); System.out.println(phrase); <span class="hljs-comment"><span class="hljs-comment">// In Germany Max and Peter and Pamela are of legal age.</span></span></code> </pre><br>  Kolektor penghubung menerima pemisah, serta awalan dan sufiks opsional. <br><br>  Untuk mengubah elemen aliran menjadi tampilan, Anda harus menentukan bagaimana kunci dan nilai harus ditampilkan.  Ingat bahwa kunci dalam pemetaan harus unik.  Kalau tidak, kami mendapatkan <code>IllegalStateException</code> .  Anda bisa menambahkan fungsi gabungan untuk memotong pengecualian: <br><br><pre> <code class="java hljs">Map&lt;Integer, String&gt; map = persons .stream() .collect(Collectors.toMap( p -&gt; p.age, p -&gt; p.name, (name1, name2) -&gt; name1 + <span class="hljs-string"><span class="hljs-string">";"</span></span> + name2)); System.out.println(map); <span class="hljs-comment"><span class="hljs-comment">// {18=Max, 23=Peter;Pamela, 12=David}</span></span></code> </pre><br>  Jadi, kami berkenalan dengan beberapa kolektor bawaan paling kuat.  Ayo coba buat sendiri.  Kami ingin mengonversi semua elemen aliran menjadi satu baris, yang terdiri atas nama huruf besar yang dipisahkan oleh bilah vertikal |.  Untuk melakukan ini, buat kolektor baru menggunakan <code>Collector.of()</code> .  Kami membutuhkan empat komponen kolektor kami: pemasok, baterai, konektor, finisher. <br><br><pre> <code class="java hljs">Collector&lt;Person, StringJoiner, String&gt; personNameCollector = Collector.of( () -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringJoiner(<span class="hljs-string"><span class="hljs-string">" | "</span></span>), <span class="hljs-comment"><span class="hljs-comment">// supplier (j, p) -&gt; j.add(p.name.toUpperCase()), // accumulator (j1, j2) -&gt; j1.merge(j2), // combiner StringJoiner::toString); // finisher String names = persons .stream() .collect(personNameCollector); System.out.println(names); // MAX | PETER | PAMELA | DAVID</span></span></code> </pre> <br>  Karena string di Java tidak dapat diubah, kita membutuhkan kelas helper seperti <code>StringJoiner</code> yang memungkinkan kolektor untuk membangun string untuk kita.  Pada langkah pertama, penyedia membangun <code>StringJoiner</code> dengan pembatas yang ditugaskan.  Baterai digunakan untuk menambahkan setiap nama ke <code>StringJoiner</code> . <br><br>  Konektor tahu bagaimana menghubungkan dua <code>StringJoiner</code> menjadi satu.  Dan pada akhirnya, finisher membangun string yang diinginkan dari <code>StringJoiner</code> . <br><br><h4>  Flatmap </h4><br>  Jadi, kami belajar cara mengubah objek aliran menjadi jenis objek lain menggunakan metode <code>map</code> .  <code>Map</code> adalah semacam metode terbatas, karena setiap objek hanya dapat dipetakan ke satu objek lainnya.  Tetapi bagaimana jika Anda ingin memetakan satu objek ke banyak objek lainnya, atau tidak menampilkannya sama sekali?  Di sinilah metode <code>flatMap</code> membantu.  <code>FlatMap</code> mengubah setiap aliran objek menjadi aliran objek lain.  Isi utas ini kemudian dikemas ke dalam aliran balik metode <code>flatMap</code> . <br><br>  Untuk melihat <code>flatMap</code> dalam aksi, mari kita buat hierarki tipe yang cocok untuk contoh: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ String name; List&lt;Bar&gt; bars = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); Foo(String name) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ String name; Bar(String name) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } }</code> </pre><br>  Mari kita membuat beberapa objek: <br><br><pre> <code class="java hljs">List&lt;Foo&gt; foos = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-comment"><span class="hljs-comment">// create foos IntStream .range(1, 4) .forEach(i -&gt; foos.add(new Foo("Foo" + i))); // create bars foos.forEach(f -&gt; IntStream .range(1, 4) .forEach(i -&gt; f.bars.add(new Bar("Bar" + i + " &lt;- " + f.name))));</span></span></code> </pre><br>  Sekarang kami memiliki daftar tiga <i>foo</i> , yang masing-masing berisi tiga <i>bilah</i> . <br><br>  <code>FlatMap</code> menerima fungsi yang harus mengembalikan aliran objek.  Jadi, untuk mengakses objek <i>bar</i> dari setiap <i>foo</i> , kita hanya perlu menemukan fungsi yang sesuai: <br><br><pre> <code class="java hljs">foos.stream() .flatMap(f -&gt; f.bars.stream()) .forEach(b -&gt; System.out.println(b.name)); <span class="hljs-comment"><span class="hljs-comment">// Bar1 &lt;- Foo1 // Bar2 &lt;- Foo1 // Bar3 &lt;- Foo1 // Bar1 &lt;- Foo2 // Bar2 &lt;- Foo2 // Bar3 &lt;- Foo2 // Bar1 &lt;- Foo3 // Bar2 &lt;- Foo3 // Bar3 &lt;- Foo3</span></span></code> </pre><br>  Jadi, kami telah berhasil mengubah aliran tiga objek <i>foo</i> menjadi aliran 9 objek <i>bar</i> . <br><br>  Akhirnya, semua kode di atas dapat direduksi menjadi pipeline operasi sederhana: <br><br><pre> <code class="java hljs">IntStream.range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) .mapToObj(i -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo(<span class="hljs-string"><span class="hljs-string">"Foo"</span></span> + i)) .peek(f -&gt; IntStream.range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) .mapToObj(i -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-string"><span class="hljs-string">"Bar"</span></span> + i + <span class="hljs-string"><span class="hljs-string">" &lt;- "</span></span> f.name)) .forEach(f.bars::add)) .flatMap(f -&gt; f.bars.stream()) .forEach(b -&gt; System.out.println(b.name));</code> </pre><br>  <code>FlatMap</code> juga tersedia di kelas <code>Optional</code> diperkenalkan di Java 8. <code>FlatMap</code> dari kelas <code>Optional</code> mengembalikan objek opsional dari kelas lain.  Ini dapat digunakan untuk menghindari banyak cek <code>null</code> . <br><br>  Bayangkan sebuah struktur hierarkis seperti ini: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer</span></span></span><span class="hljs-class"> </span></span>{ Nested nested; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Nested</span></span></span><span class="hljs-class"> </span></span>{ Inner inner; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Inner</span></span></span><span class="hljs-class"> </span></span>{ String foo; }</code> </pre><br>  Untuk mendapatkan <i>foo</i> string bersarang dari objek eksternal, Anda perlu menambahkan beberapa pemeriksaan <code>null</code> untuk menghindari <code>NullPointException</code> : <br><br><pre> <code class="java hljs">Outer outer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Outer(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (outer != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; outer.nested != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; outer.nested.inner != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { System.out.println(outer.nested.inner.foo); }</code> </pre><br>  Hal yang sama dapat dicapai dengan menggunakan flatMap dari kelas opsional: <br><br><pre> <code class="java hljs">Optional.of(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Outer()) .flatMap(o -&gt; Optional.ofNullable(o.nested)) .flatMap(n -&gt; Optional.ofNullable(n.inner)) .flatMap(i -&gt; Optional.ofNullable(i.foo)) .ifPresent(System.out::println);</code> </pre><br>  Setiap panggilan ke <code>flatMap</code> mengembalikan bungkus <code>Optional</code> untuk objek yang diinginkan, jika ada, atau <code>null</code> jika objek hilang. <br><br><h4>  Kurangi </h4><br>  Operasi penyederhanaan menggabungkan semua elemen aliran ke dalam satu hasil.  Java 8 mendukung tiga jenis metode pengurangan. <br><br>  Yang pertama mengurangi aliran elemen ke elemen aliran tunggal.  Kami menggunakan metode ini untuk menentukan elemen dengan usia terbesar: <br><br><pre> <code class="java hljs">persons .stream() .reduce((p1, p2) -&gt; p1.age &gt; p2.age ? p1 : p2) .ifPresent(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// Pamela</span></span></code> </pre> <br>  Metode <code>reduce</code> mengambil fungsi akumulasi dengan <i>operator biner</i> (BinaryOperator).  Reduksi di sini adalah <i>fungsi</i> ganda (BiFunction), di mana kedua argumen memiliki tipe yang sama.  Dalam kasus kami, untuk tipe <i>Person</i> .  Dua fungsi hampir sama dengan <code></code> , tetapi dibutuhkan 2 argumen.  Dalam contoh kami, fungsi membandingkan usia dua orang dan mengembalikan elemen dengan usia yang lebih besar. <br><br>  Bentuk berikutnya dari metode <code>reduce</code> mengambil nilai awal dan baterai dengan operator biner.  Metode ini dapat digunakan untuk membuat item baru.  Kami memiliki - <i>Orang</i> dengan nama dan usia, yang terdiri dari penambahan semua nama dan jumlah tahun yang dijalani: <br><br><pre> <code class="java hljs">Person result = persons .stream() .reduce(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), (p1, p2) -&gt; { p1.age += p2.age; p1.name += p2.name; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p1; }); System.out.format(<span class="hljs-string"><span class="hljs-string">"name=%s; age=%s"</span></span>, result.name, result.age); <span class="hljs-comment"><span class="hljs-comment">// name=MaxPeterPamelaDavid; age=76</span></span></code> </pre><br>  Metode <code>reduce</code> ketiga mengambil tiga parameter: nilai awal, akumulator dengan fungsi ganda, dan fungsi kombinasi seperti operator biner.  Karena nilai awal dari tipe ini tidak terbatas pada tipe Person, Anda dapat menggunakan pengurangan untuk menentukan tahun total setiap orang: <br><br><pre> <code class="java hljs">Integer ageSum = persons .stream() .reduce(<span class="hljs-number"><span class="hljs-number">0</span></span>, (sum, p) -&gt; sum += p.age, (sum1, sum2) -&gt; sum1 + sum2); System.out.println(ageSum); <span class="hljs-comment"><span class="hljs-comment">// 76</span></span></code> </pre><br>  Seperti yang Anda lihat, kami mendapat hasil 76, tetapi apa yang sebenarnya terjadi di bawah tenda? <br><br>  Kami memperluas fragmen kode di atas dengan output teks untuk debug: <br><br><pre> <code class="java hljs">Integer ageSum = persons .stream() .reduce(<span class="hljs-number"><span class="hljs-number">0</span></span>, (sum, p) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"accumulator: sum=%s; person=%s\n"</span></span>, sum, p); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum += p.age; }, (sum1, sum2) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"combiner: sum1=%s; sum2=%s\n"</span></span>, sum1, sum2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum1 + sum2; }); <span class="hljs-comment"><span class="hljs-comment">// accumulator: sum=0; person=Max // accumulator: sum=18; person=Peter // accumulator: sum=41; person=Pamela // accumulator: sum=64; person=David</span></span></code> </pre><br>  Seperti yang Anda lihat, fungsi akumulasi melakukan semua pekerjaan.  Ini pertama kali disebut dengan nilai awal 0 dan Max orang pertama.  Dalam tiga langkah berikutnya, jumlah terus meningkat berdasarkan usia orang tersebut dari langkah terakhir hingga mencapai usia 76 tahun. <br><br>  Jadi apa selanjutnya?  Apakah combiner tidak pernah dipanggil?  Pertimbangkan eksekusi paralel utas ini: <br><br><pre> <code class="java hljs">Integer ageSum = persons .parallelStream() .reduce(<span class="hljs-number"><span class="hljs-number">0</span></span>, (sum, p) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"accumulator: sum=%s; person=%s\n"</span></span>, sum, p); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum += p.age; }, (sum1, sum2) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"combiner: sum1=%s; sum2=%s\n"</span></span>, sum1, sum2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum1 + sum2; }); <span class="hljs-comment"><span class="hljs-comment">// accumulator: sum=0; person=Pamela // accumulator: sum=0; person=David // accumulator: sum=0; person=Max // accumulator: sum=0; person=Peter // combiner: sum1=18; sum2=23 // combiner: sum1=23; sum2=12 // combiner: sum1=41; sum2=35</span></span></code> </pre><br>  Dengan eksekusi paralel, kami mendapatkan output konsol yang sama sekali berbeda.  Sekarang combiner benar-benar dipanggil.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena baterai disebut secara paralel, penggabung harus meringkas nilai yang disimpan secara terpisah. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada bab selanjutnya, kita akan memeriksa secara lebih rinci eksekusi paralel dari utas.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Utas paralel </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thread dapat berjalan secara paralel untuk meningkatkan kinerja saat berhadapan dengan sejumlah besar elemen yang masuk. </font><font style="vertical-align: inherit;">Utas paralel menggunakan yang biasa </font></font><code>ForkJoinPool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tersedia melalui panggilan ke metode statis </font></font><code>ForkJoinPool.commonPool()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ukuran kumpulan utas utama dapat mencapai 5 utas eksekusi - jumlah pastinya tergantung pada jumlah inti prosesor fisik yang tersedia.</font></font><br><br><pre> <code class="java hljs">ForkJoinPool commonPool = ForkJoinPool.commonPool(); System.out.println(commonPool.getParallelism()); <span class="hljs-comment"><span class="hljs-comment">// 3</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di komputer saya, kumpulan utas biasa diinisialisasi secara default dengan paralelisasi menjadi 3 utas. </font><font style="vertical-align: inherit;">Nilai ini dapat ditingkatkan atau dikurangi dengan menetapkan parameter JVM berikut:</font></font><br><br><pre> <code class="bash hljs">-Djava.util.concurrent.ForkJoinPool.common.parallelism=5</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Koleksi mendukung metode </font></font><code>parallelStream()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk membuat aliran data paralel. </font><font style="vertical-align: inherit;">Anda juga dapat memanggil metode perantara </font></font><code>parallel()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk mengubah aliran serial menjadi paralel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk memahami perilaku utas dalam eksekusi paralel, contoh berikut ini mencetak informasi tentang setiap utas saat ini (utas) untuk </font></font><code>System.out</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="java hljs">Arrays.asList(<span class="hljs-string"><span class="hljs-string">"a1"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"c2"</span></span>, <span class="hljs-string"><span class="hljs-string">"c1"</span></span>) .parallelStream() .filter(s -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"filter: %s [%s]\n"</span></span>, s, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }) .map(s -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"map: %s [%s]\n"</span></span>, s, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .forEach(s -&gt; System.out.format(<span class="hljs-string"><span class="hljs-string">"forEach: %s [%s]\n"</span></span>, s, Thread.currentThread().getName()));</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pertimbangkan kesimpulan dengan entri debug untuk lebih memahami utas mana yang digunakan untuk menjalankan metode aliran tertentu: </font></font><br><br><pre> <code class="java hljs">filter: b1 [main] filter: a2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] map: a2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] filter: c2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] map: c2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] filter: c1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] map: c1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] forEach: C2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] forEach: A2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] map: b1 [main] forEach: B1 [main] filter: a1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] map: a1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] forEach: A1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] forEach: C1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>]</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti yang Anda lihat, dalam eksekusi paralel dari aliran data, semua utas yang tersedia saat ini digunakan </font></font><code>ForkJoinPool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Urutan output mungkin berbeda, karena urutan eksekusi dari setiap utas tertentu tidak ditentukan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita memperluas contoh dengan menambahkan metode </font></font><code>sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="java hljs">Arrays.asList(<span class="hljs-string"><span class="hljs-string">"a1"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"c2"</span></span>, <span class="hljs-string"><span class="hljs-string">"c1"</span></span>) .parallelStream() .filter(s -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"filter: %s [%s]\n"</span></span>, s, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }) .map(s -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"map: %s [%s]\n"</span></span>, s, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .sorted((s1, s2) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"sort: %s &lt;&gt; %s [%s]\n"</span></span>, s1, s2, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s1.compareTo(s2); }) .forEach(s -&gt; System.out.format(<span class="hljs-string"><span class="hljs-string">"forEach: %s [%s]\n"</span></span>, s, Thread.currentThread().getName()));</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sekilas, hasilnya mungkin aneh: </font></font><br><br><pre> <code class="java hljs">filter: c2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] filter: c1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] map: c1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] filter: a2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] map: a2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] filter: b1 [main] map: b1 [main] filter: a1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] map: a1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] map: c2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] sort: A2 &lt;&gt; A1 [main] sort: B1 &lt;&gt; A2 [main] sort: C2 &lt;&gt; B1 [main] sort: C1 &lt;&gt; C2 [main] sort: C1 &lt;&gt; B1 [main] sort: C1 &lt;&gt; C2 [main] forEach: A1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] forEach: C2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] forEach: B1 [main] forEach: A2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] forEach: C1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>]</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tampaknya </font></font><code>sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dijalankan secara berurutan dan hanya di utas </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utama</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Bahkan, ketika aliran dieksekusi secara paralel di bawah kap metode </font></font><code>sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dari Stream API </font></font><code>Arrays</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font><font style="vertical-align: inherit;">metode penyortiran kelas </font><font style="vertical-align: inherit;">, ditambahkan di Java 8, </font><font style="vertical-align: inherit;">disembunyikan </font></font><code>Arrays.parallelSort()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Seperti ditunjukkan dalam dokumentasi, metode ini, berdasarkan pada panjang koleksi yang masuk, menentukan bagaimana ia akan diurutkan secara paralel atau berurutan:</font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jika panjang array tertentu kurang dari "butir" minimum, pengurutan dilakukan dengan mengeksekusi metode Array.sort. </font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita kembali ke contoh dengan metode </font></font><code>reduce</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dari bab sebelumnya. </font><font style="vertical-align: inherit;">Kami telah menemukan bahwa fungsi pemersatu dipanggil hanya ketika bekerja dengan utas secara paralel. </font><font style="vertical-align: inherit;">Pertimbangkan utas mana yang terlibat:</font></font><br><br><pre> <code class="java hljs">List&lt;Person&gt; persons = Arrays.asList( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Max"</span></span>, <span class="hljs-number"><span class="hljs-number">18</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Peter"</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Pamela"</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"David"</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>)); persons .parallelStream() .reduce(<span class="hljs-number"><span class="hljs-number">0</span></span>, (sum, p) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"accumulator: sum=%s; person=%s [%s]\n"</span></span>, sum, p, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum += p.age; }, (sum1, sum2) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"combiner: sum1=%s; sum2=%s [%s]\n"</span></span>, sum1, sum2, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum1 + sum2; });</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Keluaran konsol menunjukkan bahwa kedua fungsi: terakumulasi dan digabungkan, dilakukan secara paralel, menggunakan semua kemungkinan aliran: </font></font><br><br><pre> <code class="java hljs">accumulator: sum=<span class="hljs-number"><span class="hljs-number">0</span></span>; person=Pamela; [main] accumulator: sum=<span class="hljs-number"><span class="hljs-number">0</span></span>; person=Max; [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] accumulator: sum=<span class="hljs-number"><span class="hljs-number">0</span></span>; person=David; [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] accumulator: sum=<span class="hljs-number"><span class="hljs-number">0</span></span>; person=Peter; [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] combiner: sum1=<span class="hljs-number"><span class="hljs-number">18</span></span>; sum2=<span class="hljs-number"><span class="hljs-number">23</span></span>; [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] combiner: sum1=<span class="hljs-number"><span class="hljs-number">23</span></span>; sum2=<span class="hljs-number"><span class="hljs-number">12</span></span>; [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] combiner: sum1=<span class="hljs-number"><span class="hljs-number">41</span></span>; sum2=<span class="hljs-number"><span class="hljs-number">35</span></span>; [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>]</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dapat dikatakan bahwa eksekusi paralel dari aliran berkontribusi pada peningkatan efisiensi yang signifikan ketika bekerja dengan sejumlah besar elemen yang masuk. </font><font style="vertical-align: inherit;">Namun, harus diingat bahwa beberapa metode dalam eksekusi paralel memerlukan perhitungan tambahan (menggabungkan operasi), yang tidak diperlukan dalam eksekusi berurutan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain itu, untuk eksekusi paralel dari thread, yang sama </font></font><code>ForkJoinPool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang digunakan secara luas di JVM, digunakan. </font><font style="vertical-align: inherit;">Jadi penggunaan metode pemblokiran lambat dari aliran dapat mempengaruhi kinerja seluruh program secara negatif, karena pemblokiran benang yang digunakan untuk memproses dalam tugas-tugas lain.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Itu semua </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tutorial saya tentang menggunakan utas di Java 8 sudah berakhir. Untuk studi yang lebih rinci tentang bekerja dengan stream, Anda dapat merujuk ke </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dokumentasi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Jika Anda ingin lebih dalam dan mempelajari lebih lanjut tentang mekanisme yang mendasari utas, Anda mungkin tertarik membaca artikel oleh Martin Fowler </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Collection Pipelines</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda juga tertarik dengan JavaScript, Anda mungkin ingin melihat </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stream.js</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - implementasi JavaScript dari Java 8 Streams API. Anda mungkin juga ingin membaca artikel saya tentang </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tutorial Java 8</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terjemahan bahasa Rusia</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tentang Habré) dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tutorial Java 8 Nashorn</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya harap panduan ini bermanfaat dan menarik bagi Anda, dan Anda menikmati proses membaca. </font><font style="vertical-align: inherit;">Kode lengkap </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">disimpan di GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Jangan ragu untuk membuat cabang di repositori.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id437038/">https://habr.com/ru/post/id437038/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id437026/index.html">Google di Prancis mendenda € 50 juta untuk GDPR karena penyalahgunaan data pribadi</a></li>
<li><a href="../id437030/index.html">Otomasi infrastruktur satu kantor mewah: tampilannya</a></li>
<li><a href="../id437032/index.html">Petunjuk Instalasi Modsecurity NGINX</a></li>
<li><a href="../id437034/index.html">Universal Whistles: Tinjauan Dongle USB Snom A230 dan A210</a></li>
<li><a href="../id437036/index.html">SAPUI5 untuk boneka bagian 2: Latihan selangkah demi selangkah yang lengkap</a></li>
<li><a href="../id437040/index.html">Di Rusia, mulai menguji antarmuka saraf domestik "Neurochat"</a></li>
<li><a href="../id437044/index.html">Cara mengalahkan naga: tulis ulang program Anda di Golang</a></li>
<li><a href="../id437050/index.html">Buku "Python. Tentu saja ekspres. Edisi ke-3.</a></li>
<li><a href="../id437052/index.html">Jangan ketinggalan untuk belajar: Apakah seorang spesialis IT universitas perlu</a></li>
<li><a href="../id437054/index.html">Intel 9th ​​Generation Processors Baru: Core minus GPU</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>