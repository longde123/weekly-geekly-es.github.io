<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ˜ ğŸ‘¶ğŸ¿ ğŸ‰‘ PHP dan persamaan reguler: dasar-dasar untuk pemula ğŸŠ ğŸ‘› ğŸ¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Untuk mengantisipasi dimulainya utas baru pada kursus "Backend-developer in PHP" , serta kursus terkait "Framework Laravel" , kami ingin berbagi artik...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PHP dan persamaan reguler: dasar-dasar untuk pemula</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/484048/">  <i>Untuk mengantisipasi dimulainya utas baru pada kursus <a href="https://otus.pw/vMHA/">"Backend-developer in PHP"</a> , serta kursus terkait <a href="https://otus.pw/vS2d/">"Framework Laravel"</a> , kami ingin berbagi artikel yang disiapkan oleh penulis lepas kami.</i> <i><br><br></i>  <i><b>Perhatian!</b></i>  <i>Artikel ini <b>tidak relevan dengan program kursus</b> dan hanya akan bermanfaat <b>bagi pemula</b> .</i>  <i>Untuk pengetahuan yang lebih mendalam, kami mengundang Anda untuk mengunjungi <b><a href="https://otus.pw/vMHA/">intensif online dua-hari gratis dengan topik: "Membuat bot Telegram untuk memesan kopi di suatu institusi dan membayar online</a></b> . <b><a href="https://otus.pw/vMHA/">"</a></b></i>  <i>Hari kedua yang intens akan diadakan di <a href="https://otus.pw/cl2i/">sini</a> .</i> <i><br></i> <br><img src="https://habrastorage.org/webt/94/4h/6y/944h6y1qgyysdz1bigypwmh2kgc.png"><br><hr><br>  Halo semuanya!  Semua dengan <code>[20]{2,}0</code> tahun mendatang.  Hari ini saya ingin menyentuh pada topik yang kadang menjadi topik lelucon dari "Mengapa Anda perlu mempelajari semua ini jika Anda sudah memiliki solusi siap pakai" untuk "Anda juga dapat mempelajari semua Perl?"  Namun, seiring berjalannya waktu, banyak programmer mulai menguasai ekspresi reguler, dan pada HabrÃ© tidak ada artikel baru ( <i>walaupun ekspresi reguler tidak banyak berubah belakangan ini</i> ) tentang topik ini.  Saatnya menulis yang lain! <br><a name="habracut"></a><br><br><h3>  Ekspresi reguler dalam isolasi dari implementasi spesifik mereka </h3><br>  Ekspresi reguler (dilambangkan dalam bahasa Inggris sebagai <i>RegEx</i> atau sebagai <i>regex</i> ) adalah alat yang digunakan untuk berbagai opsi untuk mempelajari dan memproses teks: mencari, memeriksa, mencari dan mengganti elemen yang terdiri dari huruf atau angka (atau karakter lain dalam termasuk karakter khusus dan karakter tanda baca).  Awalnya, ekspresi reguler datang ke dunia pemrograman dari lingkungan penelitian ilmiah, yang dilakukan pada 50-an di bidang matematika. <br><br>  Beberapa dekade kemudian, prinsip-prinsip dan ide-ide dipindahkan ke lingkungan sistem operasi UNIX (khususnya, mereka dimasukkan dalam utilitas <code>grep</code> ) dan diimplementasikan dalam bahasa pemrograman Perl, yang pada awal Internet digunakan secara luas pada backend (dan hingga hari ini digunakan, tetapi sudah kurang) untuk tugas seperti itu. seperti validasi formulir. <br><br><img src="https://habrastorage.org/webt/qc/ar/2n/qcar2n7t2d3mfadvtvfhnapw8by.png"><br><br><h5>  Jika mereka tampak sederhana, lalu mengapa mereka begitu menakutkan pada pandangan pertama? </h5><br>  Bahkan, ekspresi apa pun bisa "biasa" dan dapat digunakan untuk memeriksa atau mencari karakter apa pun.  Misalnya, kata-kata <em>Pavel</em> atau <em>example@mail.ru</em> juga dapat digunakan sebagai pelanggan tetap, hanya saja, dengan kunci yang agak sempit.  Untuk menguji kinerja ekspresi reguler di lingkungan PHP tanpa memulai server atau hosting Anda, Anda dapat menggunakan <a href="https://regex101.com/">layanan</a> online berikut (itu hanya tidak berfungsi dengan memproses karakter Rusia di dalamnya).  Sebagai permulaan, kami hanya menggunakan <em>Pavel</em> sebagai ekspresi reguler. <br><br>  Misalkan kita memiliki teks berikut: <br><br>  <b>Pavel</b> tahu terlalu banyak.  <b>Pavel</b> menggunakan nginx dan dia bukan rambler. <br><br>  Sekarang ekspresi reguler telah menemukan kedua kemunculan kata Pavel.  Ini hebat, tetapi itu tidak terdengar sangat berguna (kecuali karena alasan tertentu Anda mencoba menganalisis sesuatu seperti jumlah kata yang disebutkan dalam Perang dan Damai melalui Vim dan Python, tetapi kemudian saya tidak memiliki pertanyaan untuk Anda). <br><br><h5>  Variabilitas ekspresi </h5><br>  Jika ekspresi reguler Anda adalah variabel (misalnya, Anda hanya tahu bagian tertentu dan perlu mencari jumlah kemunculan tahun, mulai dari 2000 dan berakhir dengan 2099), maka kita dapat menggunakan ekspresi reguler berikut: <em>20 ..</em> <br><br>  <i>Teks: Penulis muda menulis banyak hal.</i>  <i>Sebagai contoh, seorang penulis yang lahir pada tahun <b>2002</b> sangat berbeda dari tahun <b>2008</b> dan <b>2012.</b></i> <br><br>  Di sini, dengan bantuan ekspresi reguler, kita dapat menemukan semua tahun, tetapi sejauh ini tidak masuk akal.  Kemungkinan besar, kita tidak perlu bertahun-tahun setelah 2012 (walaupun penulis muda di bawah 8 tahun mungkin tersinggung, tetapi tidak tentang itu sekarang).  Ada baiknya mempelajari rangkaian karakter, tetapi lebih lanjut tentang itu nanti, karena sekarang kita akan berbicara tentang bagian penting lain dari ekspresi reguler: keluar dari karakter meta. <br><br>  Bayangkan kita perlu menemukan jumlah kemunculan file dengan ekstensi <code>.doc</code> (misalkan kita hanya mengekspor file tertentu yang diunggah ke basis data kita).  Tetapi apakah sebuah titik berarti karakter apa saja?  Jadi apa yang harus dilakukan? <br>  Di sini, melarikan karakter meta dengan backslash datang ke bantuan kami.  Sekarang ekspresi <code>\.doc</code> akan cukup berhasil untuk mencari teks yang disebutkan dengan ekstensi <code>.doc</code> : <br><br>  Ekspresi reguler: <code>\.doc</code> <br><br>  Teks: kursach <b>.doc</b> , <code>nepodozritelneyfail.exe</code> , kerja <b>.doc</b> , <code>shaprgalka.rtf doc</code> <br><br>  Seperti yang Anda lihat, kita dapat berhasil menemukan jumlah file dengan ekstensi <code>.doc</code> dalam daftar.  Namun, kami tidak dapat mengeluarkan nama file lengkap menggunakan ekspresi reguler ini, misalnya, ke dalam array.  Saatnya untuk melihat set karakter. <br><br><h5>  Cocokkan seluruh rangkaian karakter </h5><br>  Dalam ekspresi reguler, pencocokan dengan set disediakan menggunakan metacharacters - tanda kurung <code>[ ]</code> .  Dua karakter ASII apa pun dapat ditentukan sebagai awal dan akhir rentang.  Untuk implementasi sederhana, misalkan kita ingin menemukan semua file bernomor dari 0 hingga 9 dengan ekstensi <code>.jpg</code> . <br><br>  Ekspresi reguler: <code>[0-9]\.jpg</code> <br><br>  Teks: <b>1.jpg</b> , <b>2.jpg</b> , <b>3.jpg</b> , photo.jpg, anime.jpg, <b>8.jpg</b> , jkl.jpg <br><br>  Perlu dicatat bahwa nama file lebih dari 1 digit tidak akan tercakup oleh ekspresi reguler kami.  Tentang pilihan ganda akan sedikit lebih rendah, tetapi untuk sekarang bayangkan bahwa kita tiba-tiba diperlukan untuk mencapai hasil yang berlawanan.  Tambahkan metacharacter <code>^</code> (yang, sebaliknya, memiliki sebanyak dua fungsi dalam ekspresi reguler).  Untuk menggunakannya sebagai pengecualian, Anda harus menambahkannya ke set kami: <br><br>  Ekspresi reguler: <code>[^0-9]\.jpg</code> <br><br>  Teks: 1.jpg, 2.jpg, 3.jpg, phot <b>o.jpg</b> , anim <b>e.jpg</b> , 8.jpg, jk <b>l.jpg</b> <br><br>  Tetapi tanpa pilihan ganda, ini tentu saja ekspresi yang lebih rendah. <br><br><h5>  Tabel Berguna </h5><br>  Berikut ini adalah tabel karakter: <br><br><div class="scrollable-table"><table><tbody><tr><td>  \ </td><td>  lepaskan metacharacter sebagai karakter biasa </td></tr><tr><td>  ^ </td><td>  cari karakter tertentu di awal baris (tetapi hanya jika Anda mengecualikannya dari set []) </td></tr><tr><td>  $ </td><td>  ujung garis </td></tr><tr><td>  | </td><td>  alternatif </td></tr><tr><td>  () </td><td>  pengelompokan </td></tr><tr><td>  \ w </td><td>  semua karakter alfanumerik (karena alasan tertentu, banyak manual tidak menyetujui karakter digital) </td></tr><tr><td>  \ W </td><td>  hal yang sama, justru sebaliknya </td></tr><tr><td>  \ s </td><td>  spasi putih </td></tr><tr><td>  \ S </td><td>  setiap TIDAK spasi putih </td></tr></tbody></table></div><br><br>  Tabel putih metakarakter ruang <br><div class="scrollable-table"><table><tbody><tr><td>  [\ b] </td><td>  kembali karakter tunggal </td></tr><tr><td>  \ f </td><td>  terjemahan halaman </td></tr><tr><td>  \ n </td><td>  umpan baris </td></tr><tr><td>  \ r </td><td>  carriage return </td></tr><tr><td>  \ t </td><td>  tabulasi </td></tr><tr><td>  \ v </td><td>  tab vertikal </td></tr></tbody></table></div><br><br><h3>  Pilihan Ganda: Membuat Validasi Sederhana </h3><br>  Berbekal pengetahuan yang diperoleh, kami akan mencoba membuat ekspresi reguler yang menemukan, misalnya, kata-kata yang lebih pendek dari 3 huruf (tugas standar untuk anti-spam).  Jika kami mencoba menggunakan ekspresi reguler berikut - <code>\w{1,3}</code> (di mana metacharacter <code>\w</code> menunjukkan karakter apa pun, dan tanda kurung keriting menunjukkan jumlah karakter dari berapa banyak hingga berapa banyak, maka kami akan menyorot semua karakter secara berturut-turut - Anda perlu menunjuk entah bagaimana awal dan akhir kata dalam teks, untuk ini kita perlu metacharacter <code>\b</code> . <br><br>  Ekspresi reguler: <code>\b\w{1,3}\b:</code> <br><br>  Teks: kata yang bagus <br>  <b>tidak</b> <br>  <b>telur</b> <br><br>  Tidak buruk!  Sekarang kata-kata yang lebih pendek dari tiga huruf tidak akan dapat masuk ke database kami.  Mari kita lihat validasi alamat surat: <br><br>  Ekspresi reguler: <code>\w+@\w+\.\w+</code> <br><br>  Persyaratan: di email di awal harus berupa karakter apa saja (angka atau huruf, karena email, yang hanya terdiri dari angka di awal, sangat umum).  Kemudian muncul simbol <code>@</code> , lalu sebanyak karakter yang Anda suka, diikuti oleh titik yang diloloskan (mis. Hanya satu titik) dan domain tingkat pertama. <br><br><h5>  Pertimbangkan pengulangan karakter secara lebih rinci. </h5><br>  Sekarang mari kita lihat lebih dekat bagaimana mengulangi karakter dalam ekspresi reguler.  Misalnya, Anda ingin menemukan kombinasi angka dari 2-6 dalam teks: <br><br>  Ekspresi Reguler: <code>[2-6]+</code> <br><br>  Teks: Berikut 89 89 <b>234</b> angka <b>24</b> . <br><br>  Biarkan saya memberi Anda tabel dari semua penjelas metacharacter: <br><br><div class="scrollable-table"><table><tbody><tr><td>  * </td><td>  karakter ulangi 0 dan tak terhingga iklan </td></tr><tr><td>  + </td><td>  diulang dari 1 hingga tak terbatas </td></tr><tr><td>  {n} </td><td>  ulangi persis n kali </td></tr><tr><td>  {n,} </td><td>  dari n hingga tak terbatas </td></tr><tr><td>  {n1, n2} </td><td>  dari n1 ke n2 kali tepatnya </td></tr><tr><td>  ? </td><td>  0 atau 1 karakter, tidak lebih </td></tr></tbody></table></div><br><br>  Tidak ada yang rumit dalam menerapkan penjumlahan.  Kecuali untuk satu peringatan: quantifier serakah dan malas.  Ini tabelnya: <br><br><div class="scrollable-table"><table><tbody><tr><td>  * </td><td>  *? </td></tr><tr><td>  + </td><td>  +? </td></tr><tr><td>  {n,} </td><td>  {n,}? </td></tr></tbody></table></div><br><br>  Kuantitas malas berbeda dari serakah karena mereka mengambil jumlah karakter minimum, bukan maksimum.  Bayangkan bahwa kita memiliki tugas untuk menemukan semua tag tajuk h1-h6 dan kontennya, dan teks lainnya tidak boleh terpengaruh (saya sengaja memasukkan tag h7 yang tidak ada agar tidak tersiksa karena lolos dari tag Habra): <br><br>  Ekspresi reguler: &lt;h [1-7]&gt;. *? &lt;\ / H [1-7]&gt; <br><br>  Teks: <b><code>&lt;</code> <code>h7</code> <code>&gt;</code> halo <code>&lt;/</code> <code>h7</code> <code>&gt;</code></b> lorem ipsum avada kedavra <b><code>&lt;</code> <code>h7</code> &gt; beli <code>&lt;</code> <code>/h7</code> <code>&gt;</code></b> <br><br>  Semuanya bekerja dengan sukses, tetapi hanya berkat kuantifier malas.  Dalam hal menggunakan quantifier serakah, semua teks di antara tag akan menonjol (saya pikir ini tidak perlu ilustrasi). <br><br><h5>  Perbatasan String Karakter </h5><br>  Batas-batas string karakter yang telah kita gunakan di atas.  Ini adalah tabel yang lebih detail: <br><br><div class="scrollable-table"><table><tbody><tr><td>  \ b </td><td>  batas kata </td></tr><tr><td>  \ B </td><td>  bukan batas kata </td></tr><tr><td>  \ A </td><td>  mulai dari garis </td></tr><tr><td>  \ Z </td><td>  ujung garis </td></tr><tr><td>  \ G </td><td>  akhir dari tindakan </td></tr></tbody></table></div><br><br><h5>  Bekerja dengan subekspresi </h5><br>  Subekspresi dalam ekspresi reguler dilakukan menggunakan grup metacharacter <code>()</code> . <br>  Berikut adalah contoh ekspresi reguler yang secara universal dapat menemukan berbagai variasi alamat IP. <br><br>  Ekspresi reguler: (((25 [0-5]) | (2 [0-4] \ d) | (1 \ d {2}) | (\ d {1,2})) \.) {3} (((25 [0-5] | (2 [0-4] \ d) | (1 \ d {2}) | (\ d {1,2}))))) <br><br>  Teks: <b>255.255.255.255</b> hanyalah sebuah alamat <br>  <b>191.198.174.192</b> wikipedia <br>  <b>87.240.190.67</b> vk <br>  <b>31.13.72.36</b> facebook <br><br>  Ini menggunakan operator logis <code>|</code>  (atau) yang memungkinkan kami untuk membuat ekspresi reguler yang cocok dengan aturan yang digunakan untuk mengkompilasi alamat IP.  Alamat IP harus berisi dari 1 hingga 3 digit, di mana sejumlah tiga angka dapat dimulai dengan 1, dengan 2 (atau kemudian digit kedua harus antara 0 dan 4), atau mulai dengan 25, dan kemudian 3 digit ternyata antara 0 dan 5. Juga, harus ada titik di antara setiap kombinasi angka.  Dengan menggunakan tabel di atas, cobalah untuk menguraikan ekspresi reguler di atas.  Ekspresi reguler di awal menakut-nakuti Anda dengan panjang, tetapi panjang tidak berarti kompleks. <br><br><h5>  Lihat ke depan </h5><br>  Untuk melihat ekspresi kombinasi karakter tertentu, sebuah pola ditunjukkan dengan kecocokan yang terdeteksi, tetapi tidak dikembalikan.  Pada dasarnya, melihat ke depan mendefinisikan subekspresi dan oleh karena itu dibentuk sesuai.  Pola sintaksis untuk melihat ke depan terdiri dari subekspresi yang didahului oleh? =, Dan kemudian teks yang akan dicocokkan diikuti dengan sama. <br><br>  Ini adalah tugas khusus: ada kata sandi yang harus terdiri dari setidaknya 7 karakter dan harus menyertakan setidaknya satu huruf besar dan angka.  Di sini semuanya akan menjadi sedikit lebih rumit, karena pengguna harus dapat meletakkan huruf besar baik di awal dan di tengah kalimat (dan hal yang sama harus diulang dengan huruf). <br><br>  Karena itu, kita perlu melihat ke depan ungkapan itu.  Selain itu, kita perlu memecah tanda menjadi kelompok.  Dan saya ingin membatasi ukurannya dari 8 hingga 22 karakter: <br><br>  Ekspresi reguler: <code>/^(?=.*[az])(?=.*[AZ])(?=.*\d)[a-zA-Z\d]{8,}$/</code> <br><br>  Teks: <b>Qwerty123</b> <br>  <b>Im789098</b> <br>  kata sandi lemah <br><br><h3>  Fitur kerja ekspresi reguler di PHP </h3><br>  Untuk mempelajari cara kerja ekspresi reguler dalam PHP, lihat fungsi dalam dokumentasi PCRE resmi (Perl Kompatibel dengan Ekspresi Reguler), yang tersedia di situs web resmi.  Ekspresi harus dilampirkan dalam pembatas, misalnya, dalam garis miring ke depan. <br><br>  Karakter sewenang-wenang dapat menjadi pembatas, kecuali alfanumerik, garis miring terbalik '\' dan byte nol.  Jika karakter pembatas muncul dalam pola, itu harus lolos \.  Sebagai pemisah, kombinasi berasal dari Perl: (), {}, []. <br><br>  Fungsi apa yang digunakan dalam php?  Paket PCRE menyediakan fitur berikut untuk mendukung ekspresi reguler: <br><br><ul><li>  <em>preg_grep ()</em> - Melakukan pencarian dan mengembalikan array yang cocok. </li><li>  <em>preg_match ()</em> - mencari kecocokan pertama menggunakan ekspresi reguler </li><li>  <em>preg_match_all ()</em> - Melakukan pencarian global menggunakan ekspresi reguler </li><li>  <em>preg_quote ()</em> - mengambil templat dan mengembalikan versinya yang lolos </li><li>  <em>preg_replace ()</em> - melakukan pencarian dan mengganti operasi </li><li>  <em>preg_replace_callback ()</em> - juga melakukan pencarian dan mengganti operasi, tetapi mereka menggunakan panggilan balik - suatu fungsi untuk setiap penggantian spesifik </li><li>  <em>preg_split ()</em> - membagi string karakter ke dalam substring </li></ul><br><br>  Pengubah <code>i</code> untuk mengatur kecocokan tanpa sensitivitas case. <br>  Dengan menggunakan pengubah <code>m</code> , Anda dapat mengaktifkan mode pemrosesan teks multiline. <br><br>  Mengganti string dapat dihitung sebagai kode PHP.  Untuk mengaktifkan mode ini, gunakan pengubah <em>e</em> . <br><br>  Semua <code>preg_split()</code> <code>preg_replace()</code> , <code>preg_replace_callback()</code> dan <code>preg_split()</code> mendukung argumen tambahan, yang memperkenalkan batasan jumlah maksimum penggantian atau partisi. <br><br>  Tautan balik dapat ditunjukkan dengan tanda $ (misalnya, $ 1), dan di versi sebelumnya, tanda-tanda \\ digunakan sebagai ganti tanda $. <br>  Metakarakter \ E, \ l, \ L, \ u dan \ U tidak digunakan (oleh karena itu, mereka tidak disebutkan dalam artikel ini). <br><br>  Artikel kami tidak akan lengkap tanpa kelas karakter POSIX, yang juga berfungsi dalam PHP (dan secara umum dapat meningkatkan keterbacaan pelanggan tetap Anda, tetapi tidak semua dari mereka terburu-buru untuk belajar, karena mereka sering mematahkan logika ekspresi). <br><br><div class="scrollable-table"><table><tbody><tr><td>  [[: alnum:]] </td><td>  Setiap huruf alfabet atau angka bahasa Inggris </td></tr><tr><td>  [[: alpha:]] </td><td>  Huruf apa pun ([a-zA-Z]) </td></tr><tr><td>  [[: kosong:]] </td><td>  Spasi putih atau kode karakter 0 dan 255 </td></tr><tr><td>  [[: digit:]] </td><td>  Digit apa pun ([0-9]) </td></tr><tr><td>  [[: lebih rendah:]] </td><td>  Huruf kecil apa pun dari alfabet bahasa Inggris ([az]) </td></tr><tr><td>  [[: atas:]] </td><td>  Huruf besar alfabet bahasa Inggris ([AZ]) </td></tr><tr><td>  [[: punct:]] </td><td>  Tanda baca apa pun </td></tr><tr><td>  [[: spasi:]] </td><td>  Setiap spasi putih </td></tr><tr><td>  [[: xdigit:]] </td><td>  Digit heksadesimal apa pun ([0-9a-fA-F]) </td></tr></tbody></table></div><br><br>  Pada akhirnya saya akan memberikan contoh implementasi konkret dari ekspresi reguler di PHP, menggunakan implementasi yang disebutkan di atas.  Saya juga menambahkan validasi nama pengguna sehingga ia tidak bisa memasukkan kombinasi huruf terlalu pendek (well, anggap ini adalah nama panggilan, bukan nama, nama lebih pendek dari dua huruf): <br><br><pre> <code class="php hljs"> $pattern_name = <span class="hljs-string"><span class="hljs-string">'/\w{3,}/'</span></span>; $pattern_mail = <span class="hljs-string"><span class="hljs-string">'/\w+@\w+\.\w+/'</span></span>; $pattern_password = <span class="hljs-string"><span class="hljs-string">'/^(?=.*[az])(?=.*[AZ])(?=.*\d)[a-zA-Z\d]{8,}$/'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (preg_match($pattern_name, $name) &amp;&amp; preg_match($pattern_mail, $mail) &amp;&amp; preg_match($pattern_password, $_POST[<span class="hljs-string"><span class="hljs-string">'password'</span></span>])) { <span class="hljs-comment"><span class="hljs-comment">#  ,  ,   ,   ,      }</span></span></code> </pre><br><br>  Terima kasih atas perhatian Anda!  Tentu saja, hari ini kita hanya menyentuh sebagian dari ekspresi reguler dan beberapa artikel lagi dapat ditulis tentangnya.  Misalnya, kami tidak membicarakan implementasi pencarian pengulangan kata-kata yang identik dalam teks.  Tetapi saya berharap bahwa pengetahuan yang diperoleh cukup untuk secara bermakna menulis validasi formulir pertama saya dan baru kemudian beralih ke hal-hal yang lebih ganas. <br><br>  <b>Secara tradisi, beberapa tautan bermanfaat:</b> <br><br>  <a href="http://web.mit.edu/hackl/www/lab/turkshop/slides/regex-cheatsheet.pdf">Lembar Curang</a> Ekspresi Reguler MIT <br>  Bagian resmi dari <a href="https://www.php.net/manual/ru/pcre.pattern.php">dokumentasi</a> regex php. <br><br>  <b>Itu saja.</b>  <b>Sampai jumpa di <a href="https://otus.pw/vMHA/">intensif</a> !</b> <br>  <b>Hari kedua yang intens <a href="https://otus.pw/cl2i/">akan diadakan di sini</a></b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id484048/">https://habr.com/ru/post/id484048/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id484026/index.html">Bagian 6: Porting MemTest86 + ke RISC-V</a></li>
<li><a href="../id484028/index.html">Horseshoe Bend - tablet konversi dengan layar lipat</a></li>
<li><a href="../id484034/index.html">Implementasi skema kerja penyimpanan target barang berdasarkan unit akuntansi gudang 1C Otomasi Terpadu 2</a></li>
<li><a href="../id484036/index.html">Grup industri baru menciptakan standar universal untuk rumah pintar</a></li>
<li><a href="../id484046/index.html">Memeriksa Emby dengan PVS-Studio</a></li>
<li><a href="../id484050/index.html">Analisis kode sumber Emby dengan penganalisa PVS-Studio</a></li>
<li><a href="../id484052/index.html">Tugas untuk basis lunar</a></li>
<li><a href="../id484056/index.html">Apakah proyek Anda benar-benar membutuhkan tes?</a></li>
<li><a href="../id484062/index.html">Belajar Bahasa Inggris oleh MEMASICS</a></li>
<li><a href="../id484064/index.html">Bagaimana Cara Menyiapkan Game untuk Pelokalan? 10 Aturan Dasar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>