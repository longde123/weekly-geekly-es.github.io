<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙀 🏇🏼 🚣🏻 Lernen Sie die Windows Pseudo Console (ConPTY) kennen 🤜🏿 🌒 🦓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel veröffentlicht am 2. August 2018 

 Dies ist der zweite Artikel über die Windows-Befehlszeile, in dem wir die neuen Infrastruktur- und Program...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lernen Sie die Windows Pseudo Console (ConPTY) kennen</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420853/">  <font color="gray">Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">veröffentlicht</a> am 2. August 2018</font> <br><br>  Dies ist der zweite Artikel über die Windows-Befehlszeile, in dem wir die neuen Infrastruktur- und Programmierschnittstellen der Windows-Pseudokonsole, dh der Windows-Pseudokonsole (ConPTY), erläutern: Warum wir sie entwickelt haben, warum sie benötigt wird, wie sie funktioniert, wie sie verwendet wird und vieles mehr. <br><br>  Im letzten Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Das schwere Erbe der Vergangenheit.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Windows-Befehlszeilenprobleme “</a> Wir sprachen über die Voraussetzungen für die Entstehung des Terminals und die Entwicklung der Befehlszeile in Windows und begannen auch, die interne Struktur der Windows-Konsole und der Windows-Befehlszeileninfrastruktur zu untersuchen.  Wir haben auch die vielen Vor- und Nachteile der Windows-Konsole erörtert. <br><br>  Einer der Nachteile ist, dass Windows versucht, "nützlich" zu sein, aber Entwickler von alternativen Konsolen und Konsolen von Drittanbietern, Serviceentwickler usw. stört.  Beim Erstellen einer Konsole oder eines Dienstes müssen Entwickler Zugriff auf Kommunikationskanäle haben, über die ihr Terminal / Dienst Daten mit Befehlszeilenanwendungen austauscht, oder Zugriff darauf gewähren.  In der * NIX-Welt ist dies kein Problem, da * NIX eine Pseudo-Terminal-Infrastruktur (PTY) bereitstellt, mit der auf einfache Weise Kommunikationskanäle für eine Konsole oder einen Dienst erstellt werden können.  Aber unter Windows war es nicht ... <br><br>  <i><b>… bis heute!</b></i> <br><a name="habracut"></a><br><h1>  Von TTY zu PTY </h1><br>  Bevor wir detailliert auf unsere Entwicklung eingehen, kehren wir kurz zur Entwicklung von Terminals zurück. <br><br><h2>  Am Anfang war TTY </h2><br>  Wie in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">früheren Artikel</a> erläutert, steuerten Benutzer in den frühen Tagen des Rechnens Computer mithilfe elektromechanischer Teletypen (TTYs), die über einen seriellen Kommunikationskanal (normalerweise über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine 20-mA-Stromschleife</a> ) mit einem Computer verbunden waren. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f7b/e47/7fa/f7be477fac4e46cc71e70df23b26bef6.jpg"><br>  <font color="gray"><i>Ken Thompson und Dennis Ritchie (stehend) arbeiten am DEC PDP-11-Teletyp (Nachrichten ohne elektronische Anzeige)</i></font> <br><br><h3>  Terminalverteilung </h3><br>  Teletypen wurden durch Computerterminals mit elektronischen Anzeigen (normalerweise CRT-Bildschirme) ersetzt.  In der Regel handelt es sich bei Terminals um sehr einfache Geräte (daher der Begriff "dummes Terminal"), die nur die Elektronik und die Verarbeitungsleistung enthalten, die für die folgenden Aufgaben benötigt werden: <br><br><ol><li>  Empfang von Texteingaben über die Tastatur. </li><li>  Pufferung des eingegebenen Textes in einer Zeile (einschließlich lokaler Bearbeitung vor dem Senden). </li><li>  Senden / Empfangen von Text auf einem seriellen Kanal (normalerweise über die einst allgegenwärtige <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RS-232-Schnittstelle</a> ). </li><li>  Anzeige des empfangenen Textes auf dem Terminal-Display. </li></ol><br>  Trotz ihrer Einfachheit (oder vielleicht auch dank dessen) wurden Terminals schnell zum Hauptmittel für die Verwaltung von Minicomputern, Mainframes und Servern: Die meisten Dateneingabebetreiber, Computerbetreiber, Systemadministratoren, Wissenschaftler, Forscher, Softwareentwickler und Branchengrößen arbeiteten an DEC-Terminals. IBM, Wyse und viele andere. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/929/e3f/fd0/929e3ffd0e281600c9ef115f61b8b23a.jpg"><br>  <i><font color="gray">Admiral Grace Hopper in seinem Büro mit einem DEC VT220-Terminal auf seinem Schreibtisch</font></i> <br><br><h3>  Verteilung von Software-Terminals </h3><br>  Seit Mitte der 1980er Jahre werden nach und nach Allzweckcomputer anstelle von Spezialterminals eingesetzt, die erschwinglicher, beliebter und leistungsfähiger geworden sind.  Viele frühe PCs und andere Computer der 80er Jahre hatten Terminalanwendungen, die die RS-232-Verbindung zum PC öffneten und Daten mit anderen am anderen Ende der Verbindung austauschten. <br><br>  Als Allzweckcomputer immer ausgefeilter wurden, erschienen eine grafische Benutzeroberfläche (GUI) und eine völlig neue Welt gleichzeitiger Anwendungen, einschließlich Terminalanwendungen. <br><br>  Es gab jedoch ein Problem: Wie kann eine Terminalanwendung mit einer anderen Befehlszeilenanwendung interagieren, die auf demselben Computer ausgeführt wird?  Und wie kann man ein serielles Kabel physisch zwischen zwei Anwendungen verbinden, die auf demselben Computer ausgeführt werden? <br><br><h2>  Pseudo-Terminal-Darstellung (PTY) </h2><br>  In der * NIX-Welt wurde das Problem durch die Einführung eines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pseudo-Terminals (PTY)</a> gelöst. <br><br>  PTY emuliert serielle Telekommunikationsgeräte in einem Computer, indem Master- und Slave-Pseudogeräte („Master“ und „Slave“) verfügbar gemacht werden: Terminalanwendungen stellen eine Verbindung zum Master-Pseudogerät her, und Befehlszeilenanwendungen (z. B. Shells wie cmd, PowerShell und bash) stellen eine Verbindung zum Slave-Pseudogerät her.  Wenn ein Terminal-Client Text- und / oder Steuerbefehle (als Text codiert) an das Master-Pseudogerät sendet, wird der Text in den ihm zugeordneten Slave übersetzt.  Der Text aus der Anwendung wird an das Slave-Pseudogerät, dann zurück an den Master und damit an das Terminal gesendet.  Daten werden immer asynchron gesendet / empfangen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a42/2ba/b58/a422bab5816acdd43dd7b1c562d65caf.png"><br>  <i><font color="gray">Pseudo-Terminal-Anwendung / Shell</font></i> <br><br>  Es ist wichtig zu beachten, dass das Pseudo-Slave-Gerät das Verhalten des physischen Terminals emuliert und Befehlszeichen in POSIX-Signale konvertiert.  Wenn der Benutzer beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">STRG + C</a> in das Terminal eingibt, wird der ASCII-Wert für STRG + C (0x03) über den Master gesendet.  Beim Empfang auf einem Slave-Pseudogerät wird der Wert 0x03 aus dem Eingangsstrom entfernt und ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SIGINT-Signal</a> erzeugt. <br><br>  Eine solche PTY-Infrastruktur wird häufig von * NIX-Terminalanwendungen, Textfeldmanagern (z. B. Bildschirm, tmux) usw. verwendet.  Diese Anwendungen rufen <code>openpty()</code> , das ein Paar Dateideskriptoren (fd) für den PTY-Master und <code>openpty()</code> zurückgibt.  Dann kann die Anwendung eine untergeordnete Befehlszeilenanwendung (z. B. bash) verzweigen / ausführen, die ihre fd-Slaves verwendet, um Text abzuhören und an das verbundene Terminal zurückzugeben. <br><br>  Dieser Mechanismus ermöglicht es Terminalanwendungen, direkt mit lokal ausgeführten Befehlszeilenanwendungen zu „kommunizieren“, so wie ein Terminal über eine serielle / Netzwerkverbindung mit einem Remotecomputer kommunizieren würde. <br><br><h2>  Was, kein Pseudokonsolen-Windows? </h2><br>  Wie bereits im vorherigen Artikel erläutert, ähnelt die Windows-Konsole zwar konzeptionell dem herkömmlichen * NIX-Terminal, unterscheidet sich jedoch in mehreren wesentlichen Punkten, insbesondere auf den untersten Ebenen, was für Entwickler von Windows-Befehlszeilenanwendungen, Terminals / Konsolen von Drittanbietern und Servern zu Problemen führen kann Anwendungen: <br><br><ol><li>  <b>Unter Windows gibt es keine PTY-Infrastruktur</b> : Wenn ein Benutzer eine Befehlszeilenanwendung startet (z. B. Cmd, PowerShell, wsl, ipconfig usw.), verbindet Windows selbst eine neue oder vorhandene Instanz der Konsole mit der Anwendung. </li><li>  <b>Windows stört Konsolen und Serveranwendungen von Drittanbietern</b> : Windows bietet Terminals (derzeit) keine Möglichkeit, Kommunikationskanäle bereitzustellen, über die sie mit einer Befehlszeilenanwendung interagieren möchten.  Terminals von Drittanbietern müssen Konsolen außerhalb des Bildschirms erstellen, vom Benutzer eingegebene Daten dorthin senden und die Ausgabe verschrotten, indem sie auf dem eigenen Display der Konsole von Drittanbietern neu gezeichnet werden! </li><li>  <b>Nur Windows verfügt über die Konsolen-API</b> : Windows-Befehlszeilenanwendungen basieren auf der Win32- <b>Konsolen</b> -API, wodurch die Code-Portabilität verringert wird, da alle anderen Plattformen Text / VT unterstützen, nicht die API. </li><li>  <b>Nicht standardmäßiger Remotezugriff</b> : Die Abhängigkeit von Befehlszeilenanwendungen von der Consol-API erschwert die Interaktions- und Remotezugriffsskripts erheblich. </li></ol><br><h2>  Was zu tun ist? </h2><br>  Viele, <b>viele</b> Entwickler forderten häufig einen PTY-ähnlichen Mechanismus unter Windows an, insbesondere diejenigen, die mit den Tools ConEmu / Cmder, Console2 / ConsoleZ, Hyper, VSCode, Visual Studio, WSL, Docker und OpenSSH arbeiten. <br><br>  Sogar Peter Bright, der Technologie-Editor von Ars Technica, bat mich einige Tage später, den PTY-Mechanismus zu implementieren, als ich anfing, im Konsolenteam zu arbeiten: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2dd/799/ebf/2dd799ebf0c14f418ae7d68d9a26acaa.png"><br><br>  Und vor kurzem wieder: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4d1/c1e/c00/4d1c1ec00ffe5ad5e6f019d1a33198c8.png"><br><br>  Nun, wir haben es endlich <b>geschafft</b> : <b>Wir haben eine Pseudokonsole für Windows erstellt</b> : <br><br><h1>  Willkommen in der Windows Pseudo Console (ConPTY) </h1><br>  Seit der Gründung des Konsolenteams vor etwa vier Jahren hat die Gruppe die Windows-Konsole und die internen Mechanismen der Befehlszeile überarbeitet.  Gleichzeitig haben wir die oben beschriebenen Probleme und viele andere damit zusammenhängende Probleme regelmäßig und sorgfältig geprüft.  Aber die Infrastruktur und der Code waren noch nicht bereit, die Veröffentlichung der Pseudokonsole zu ermöglichen ... bis jetzt! <br><br>  Die neue Windows-Pseudokonsoleninfrastruktur (ConPTY), die API und einige andere damit verbundene Änderungen werden eine ganze <b>Reihe</b> von Problemen beseitigen / lindern ... <b>ohne die Abwärtskompatibilität mit vorhandenen Befehlszeilenanwendungen zu beeinträchtigen</b> ! <br><br><blockquote>  Die neue Win32 ConPTY-API (offizielle Dokumentation wird in Kürze veröffentlicht) ist jetzt in den neuesten Insider-Builds von Windows 10 und dem entsprechenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Windows 10 Insider Preview SDK</a> verfügbar.  Sie werden in der nächsten Hauptversion von Windows 10 (irgendwann im Herbst / Winter 2018) erscheinen. </blockquote><br><h2>  Konsolen- / ConHost-Architektur </h2><br>  Um ConPTY zu verstehen, müssen Sie die Architektur der Windows-Konsole studieren, oder besser ... ConHost! <br><br>  Es ist wichtig zu verstehen, dass ConHost zwar alles implementiert, was Sie als Windows-Konsolenanwendung sehen und wissen, ConHost jedoch auch den größten Teil der Windows-Befehlszeileninfrastruktur enthält und implementiert!  Von nun an wird <b>ConHost zu einem echten "Konsolenknoten"</b> , der alle Befehlszeilenanwendungen und / oder GUI-Anwendungen unterstützt, die mit Befehlszeilenanwendungen interagieren! <br><br>  <b>Wie?</b>  <b>Warum?</b>  <b>Was?</b>  Schauen wir uns das genauer an. <br><br>  Hier ist eine allgemeine Ansicht der internen Konsolenarchitektur / ConHost: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/331/1bd/54d/3311bd54dbe80dc699ff243a4812b58a.png"><br><br>  Im Vergleich zur Architektur aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen Artikel</a> enthält ConHost jetzt mehrere zusätzliche Module für die VT-Verarbeitung und das neue ConPTY-Modul, das offene APIs implementiert: <br><br><ul><li>  <b>ConPTY-API</b> : Die neuen Win32-ConPTY-APIs bieten einen ähnlichen Mechanismus wie das POSIX PTY-Modell, jedoch unter Windows-Refraktion. </li><li>  <b>VT-Interaktivität</b> : Empfängt Eingabetext in UTF-8-Codierung, konvertiert jedes angezeigte Textzeichen in den entsprechenden <code>INPUT_RECORD</code> Datensatz und speichert ihn im Eingabepuffer.  Es verarbeitet auch Escape-Sequenzen wie 0x03 (STRG + C) und konvertiert sie in <code>KEY_EVENT_RECORDS</code> , die die entsprechende Escape-Aktion erzeugen. </li><li>  <b>VT-Renderer</b> : Erzeugt VT-Sequenzen, die zum Bewegen des Cursors und zum Rendern von Text und Stil in Bereichen des Ausgabepuffers erforderlich sind, die sich gegenüber dem vorherigen Frame geändert haben. </li></ul><br>  OK, aber was bedeutet das wirklich? <br><br><h2>  Wie funktionieren Windows-Befehlszeilenanwendungen? </h2><br>  Um die Auswirkungen der neuen ConPTY-Infrastruktur besser zu verstehen, schauen wir uns an, wie Windows-Konsolen- und Befehlszeilenanwendungen bisher funktioniert haben. <br><br>  Wenn ein Benutzer eine Befehlszeilenanwendung wie Cmd, PowerShell oder ssh startet, erstellt Windows einen neuen Win32-Prozess, in den die ausführbare Binärdatei der Anwendung und alle Abhängigkeiten (Ressourcen oder Bibliotheken) geladen werden. <br><br>  Ein neu erstellter Prozess erbt normalerweise die Deskriptoren stdin und stdout von seinem übergeordneten Prozess.  Wenn der übergeordnete Prozess ein Windows-GUI-Prozess war, fehlen die Deskriptoren stdin und stdout, sodass Windows die neue Anwendung bereitstellt und an die neue Konsoleninstanz anfügt.  Die Kommunikation zwischen Befehlszeilenanwendungen und ihrer Konsole wird über ConDrv übertragen. <br><br>  Wenn Sie beispielsweise von einer PowerShell-Instanz ohne erhöhte Berechtigungen ausgeführt werden, erbt der neue Anwendungsprozess die übergeordneten Deskriptoren stdin / stdout und empfängt daher Eingabedaten und gibt die Ausgabe an dieselbe Konsole wie die übergeordnete aus. <br><br><blockquote>  Hier müssen wir eine Reservierung vornehmen, da in einigen Fällen Befehlszeilenanwendungen gestartet werden, die an eine <i>neue</i> Instanz der Konsole angehängt sind, insbesondere aus Sicherheitsgründen, aber die obige Beschreibung ist normalerweise wahr. </blockquote><br>  Wenn die Befehlszeilen- / Shell-Anwendung gestartet wird, verbindet Windows sie letztendlich über ConDrv mit der Konsoleninstanz (ConHost.exe): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fc3/4c8/d37/fc34c8d37f6f31c843422193bd5d01a6.png"><br><br><h2>  Wie funktioniert ConHost? </h2><br>  Immer wenn eine Befehlszeilenanwendung ausgeführt wird, verbindet Windows die Anwendung mit einer neuen oder vorhandenen Instanz von ConHost.  Die Anwendung und ihre Konsoleninstanz sind über den Kernelmodus-Konsolentreiber (ConDrv) verbunden, der IOCTL-Nachrichten sendet / empfängt, die serialisierte API-Aufrufanforderungen und / oder Textdaten enthalten. <br><br>  Historisch gesehen ist die Arbeit von ConHost, wie in einem früheren Artikel erwähnt, heute relativ einfach: <br><br><ul><li>  Der Benutzer generiert Eingaben über Tastatur / Maus / Stift / Touchpad, die in <code>KEY_EVENT_RECORD</code> oder <code>MOUSE_EVENT_RECORD</code> und im Eingabepuffer gespeichert werden. </li><li>  Der Eingabepuffer wird jeweils für einen Datensatz geleert und führt die angeforderten Eingabeaktionen aus, z. B. Anzeigen von Text auf dem Bildschirm, Bewegen des Cursors, Kopieren / Einfügen von Text usw.  Viele dieser Aktionen ändern den Inhalt des Ausgabepuffers.  Diese geänderten Bereiche werden von der ConHost-Status-Engine aufgezeichnet. </li><li>  In jedem Frame zeigt die Konsole die geänderten Bereiche des Ausgabepuffers an. </li></ul><br>  Wenn die Befehlszeilenanwendung die Windows-Konsolen-API aufruft, werden die API-Aufrufe in IOCTL-Nachrichten serialisiert und über den ConDrv-Treiber gesendet.  Anschließend werden IOCTL-Nachrichten an die angeschlossene Konsole gesendet, die den angeforderten API-Aufruf dekodiert und ausführt.  Die zurückgegebenen / ausgegebenen Werte werden zurück in die IOCTL-Nachricht serialisiert und über ConDrv an die Anwendung zurückgesendet. <br><br><h2>  ConHost: Beitrag zur Vergangenheit für die Zukunft </h2><br>  Microsoft ist bestrebt, die Abwärtskompatibilität mit vorhandenen Anwendungen und Tools nach Möglichkeit aufrechtzuerhalten.  Speziell für die Kommandozeile.  Tatsächlich können 32-Bit-Versionen von Windows 10 immer noch viele / die meisten 16-Bit-Win16-Anwendungen und ausführbaren Dateien ausführen! <br><br>  Wie oben erwähnt, besteht eine der Schlüsselrollen von ConHost darin, Dienste für seine Befehlszeilenanwendungen bereitzustellen, insbesondere für Legacy-Anwendungen, die die Win32-Konsolen-API aufrufen und sich darauf verlassen.  Jetzt bietet ConHost neue Dienste an: <br><br><ul><li>  Nahtlose PTY-ähnliche Infrastruktur für die Kommunikation mit modernen Konsolen und Terminals </li><li>  Aktualisieren älterer / traditioneller Befehlszeilenanwendungen <br><ul><li>  Empfangen und Konvertieren von UTF-8-Text / VT in Eingabedatensätze (als ob vom Benutzer eingegeben) </li><li>  Die Konsolen-API ruft die gehostete Anwendung auf und aktualisiert ihren Ausgabepuffer entsprechend </li><li>  Zeigen Sie geänderte Bereiche des Ausgabepuffers in UTF-8-Codierung, Text / VT an </li></ul></li></ul><br>  Das folgende Beispiel zeigt, wie eine moderne Konsolenanwendung über ConPTY ConHost mit einer Befehlszeilenanwendung kommuniziert. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d72/7db/35e/d727db35e65b2e0eec45d0d535b4de83.png"><br><br>  In diesem neuen Modell: <br><br><ol><li>  Konsole: <br><ol><li>  Erstellt eigene Kommunikationskanäle </li><li>  Ruft die ConPTY-API auf, um ConPTY zu erstellen, und zwingt Windows, eine Instanz von ConHost auszuführen, die mit dem anderen Ende der Kanäle verbunden ist </li><li>  Erstellt wie gewohnt eine Instanz einer Befehlszeilenanwendung (z. B. PowerShell), die mit ConHost verbunden ist </li></ol></li><li>  Conhost: <br><ol><li>  Liest UTF-8-Text / VT am Eingang und konvertiert ihn in <code>INPUT_RECORD</code> Datensätze, die an die Befehlszeilenanwendung gesendet werden </li><li>  Führen Sie API-Aufrufe von einer Befehlszeilenanwendung aus, die den Inhalt des Ausgabepuffers ändern kann </li><li>  Zeigt Änderungen im Ausgabepuffer in UTF-8-Codierung (Text / VT) an und sendet den empfangenen Text an die Konsole </li></ol></li><li>  Befehlszeilenanwendung: <br><ol><li>  Es funktioniert wie gewohnt, liest die Eingabe und ruft die Konsolen-API auf, ohne zu ahnen, dass sein ConPTY ConHost die Eingabe und Ausgabe von / nach UTF-8 übersetzt! </li></ol></li></ol><br>  Der letzte Moment ist wichtig!  Wenn die alte Befehlszeilenanwendung Aufrufe an die Konsolen-API wie <code>WriteConsoleOutput(...)</code> , wird der angegebene Text in den entsprechenden ConHost-Ausgabepuffer geschrieben.  In regelmäßigen Abständen zeigt ConHost die geänderten Bereiche des Ausgabepuffers als Text / VT an, der über stdout an die Konsole zurückgesendet wird. <br><br>  Letztendlich „sprechen“ sogar herkömmliche Befehlszeilenanwendungen von außen den Text / die VT <b>ohne Änderungen</b> ! <br><br>  Mithilfe der neuen ConPTY-Infrastruktur können Konsolen von Drittanbietern jetzt direkt mit modernen und traditionellen Befehlszeilenanwendungen interagieren und alle in Text / VT austauschen. <br><br><h2>  Remote-Interaktion mit Windows-Befehlszeilenanwendungen </h2><br>  Der oben beschriebene Mechanismus funktioniert auf einem Computer einwandfrei, hilft aber auch bei der Interaktion, z. B. mit einer PowerShell-Instanz auf einem Windows-Remotecomputer oder in einem Container. <br><br>  Beim Remote-Starten einer Befehlszeilenanwendung (d. H. Auf Remotecomputern, Servern oder Containern) tritt ein Problem auf.  Tatsache ist, dass Befehlszeilenanwendungen auf Remotecomputern mit der lokalen ConHost-Instanz kommunizieren, da IOCTL-Nachrichten nicht für die Übertragung über das Netzwerk ausgelegt sind.  Wie übertrage ich Eingaben von der lokalen Konsole auf den Remotecomputer und wie erhalte ich die Ausgabe von der dort ausgeführten Anwendung?  Was tun mit Mac- und Linux-Computern, bei denen es Terminals, aber keine Windows-kompatiblen Konsolen gibt? <br><br>  Um den Windows-Computer fernsteuern zu können, benötigen wir eine Art Kommunikationsbroker, der Daten über das Netzwerk transparent serialisieren, die Lebensdauer der Anwendungsinstanz verwalten usw. kann. <br><br>  Vielleicht so etwas wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ssh</a> ? <br><br>  Glücklicherweise wurde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenSSH</a> kürzlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf Windows portiert</a> und als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zusätzliche Option zu Windows 10</a> hinzugefügt.  PowerShell Core verwendet ssh auch als eines der unterstützten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PowerShell Core Remoting-Remoting-</a> Protokolle.  Für Benutzer von Windows PowerShell ist das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Remoting von Windows PowerShell Remoting</a> weiterhin eine akzeptable Option. <br><br>  Lassen Sie uns sehen, wie Sie mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenSSH für Windows jetzt Windows-</a> Shells und Befehlszeilenanwendungen fernsteuern können: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/30e/7fc/eeb/30e7fceebcbcea167c2d50d448c975a4.png"><br><br>  OpenSSH enthält derzeit einige unerwünschte Komplikationen: <br><br><ol><li>  Benutzer: <br><ol><li>  Startet den SSH-Client und Windows verbindet die Konsoleninstanz wie gewohnt </li><li>  Gibt Text in die Konsole ein, der Tastenanschläge an den ssh-Client sendet </li></ol></li><li>  SSH-Client: <br><ol><li>  Liest die Eingabe als Bytes von Textdaten </li><li>  Sendet Textdaten über das Netzwerk an den sshd-Abhördienst </li></ol></li><li>  Der sshd-Dienst durchläuft mehrere Phasen: <br><ol><li>  Startet die Standard-Shell (z. B. Cmd), die Windows zwingt, eine neue Instanz der Konsole zu erstellen und zu verbinden </li><li>  Findet die Konsole der Cmd-Instanz und stellt eine Verbindung zu ihr her </li><li>  Verschiebt die Konsole vom Bildschirm (und / oder verbirgt sie) </li><li>  Sendet vom SSH-Client empfangene Eingaben als Eingabe an die Konsole außerhalb des Bildschirms </li></ol></li><li>  Die cmd-Instanz funktioniert wie immer: <br><ol><li>  Sammelt Eingaben vom sshd-Dienst </li><li>  Macht die Arbeit </li><li>  Ruft die Konsolen-API auf, um Text zu rendern / zu formatieren, den Cursor zu bewegen usw. </li></ol></li><li>  Angehängte [Off-Screen] -Konsole: <br><ol><li>  Führen Sie API-Aufrufe durch, indem Sie den Ausgabepuffer aktualisieren. </li></ol></li><li>  Sshd-Dienst: <br><ol><li>  Verschrottet den Ausgabepuffer der Off-Screen-Konsole, findet die Unterschiede, codiert sie in Text / VT und sendet ... </li></ol></li><li>  Ein SSH-Client, der Text sendet ... </li><li>  Konsole, die Text anzeigt </li></ol><br>  <b>Spaß, richtig?</b>  <b>Überhaupt nicht!</b>  In dieser Situation kann vieles schief gehen, insbesondere beim Simulieren und Senden von Benutzereingaben und beim Leeren des Ausgabepuffers einer Off-Screen-Konsole.  Dies führt zu Instabilität, Abstürzen, Datenkorruption, übermäßigem Energieverbrauch usw.  Darüber hinaus entfernen nicht alle Anwendungen nicht nur den Text selbst, sondern auch seine Eigenschaften, weshalb Formatierung und Farbe verloren gehen! <br><br><h3>  Fernarbeit mit modernem ConHost und ConPTY </h3><br>  <b>Sicher können wir die Situation verbessern?</b>  Ja, natürlich können wir - nehmen wir einige architektonische Änderungen vor und wenden unser neues ConPTY an: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5e8/677/f1d/5e8677f1da3a8abcf2951f4e539c6470.png"><br><br>  Das Diagramm zeigt, dass sich die Schaltung wie folgt geändert hat: <br><br><ol><li>  Benutzer: <br><ol><li>  Startet den SSH-Client und Windows verbindet die Konsoleninstanz wie gewohnt </li><li>  Gibt Text in die Konsole ein, der Tastenanschläge an den ssh-Client sendet </li></ol></li><li>  SSH-Client: <br><ol><li>  Liest die Eingabe als Bytes von Textdaten </li><li>  Sendet Textdaten über das Netzwerk an den sshd-Abhördienst </li></ol></li><li>  Sshd-Dienst: <br><ol><li>  Erstellt stdin / stdout-Kanäle </li><li>  Ruft die ConPTY-API auf, um ConPTY zu initiieren </li><li>  Startet eine Cmd-Instanz, die mit dem anderen Ende von ConPTY verbunden ist.  Windows initiiert und stellt eine neue Instanz von ConHost bereit </li></ol></li><li>  Die cmd-Instanz funktioniert wie immer: <br><ol><li>  Sammelt Eingaben vom sshd-Dienst </li><li>  Macht die Arbeit </li><li>  Ruft die Konsolen-API auf, um Text zu rendern / zu formatieren, den Cursor zu bewegen usw. </li></ol></li><li>  Instanz ConPTY ConHost: <br><ol><li>  Führen Sie API-Aufrufe durch, indem Sie den Ausgabepuffer aktualisieren. </li><li>  Zeigt die geänderten Bereiche des Ausgabepuffers als UTF-8-codierten Text / VT an, der über ssh an die Konsole / das Terminal zurückgesendet wird </li></ol></li></ol><br>  Dieser Ansatz mit ConPTY ist für den sshd-Dienst eindeutig sauberer und einfacher.  Die Aufrufe der Windows-Konsolen-API erfolgen vollständig in der ConHost-Instanz der Befehlszeilenanwendung, die alle sichtbaren Änderungen in Text / VT konvertiert.  Wer sich mit ConHost verbindet, muss nicht wissen, dass die dortige Anwendung die Konsolen-API aufruft und keinen Text / VT generiert! <br><br>  Stimmen Sie zu, dass dieser neue ConPTY-Remoting-Mechanismus zu einer eleganten, konsistenten und einfachen Architektur führt.  In Kombination mit den leistungsstarken Funktionen von ConHost, der Unterstützung älterer Anwendungen und der Anzeige von Änderungen von Anwendungen, die die Konsolen-Konsolen-APIs als Text / VT aufrufen, hilft uns die neue ConHost- und ConPTY-Infrastruktur, die Vergangenheit in die Zukunft zu verschieben. <br><br><h1>  ConPTY API und wie man es benutzt </h1><br><blockquote>  Die ConPTY-API ist in der aktuellen Version des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Windows 10 Insider Preview SDK</a> verfügbar. </blockquote><br>  Ich bin mir sicher, dass Sie es kaum erwarten können, Code zu sehen;) <br><br>  Schauen Sie sich die API-Deklarationen an: <br><br><pre> <code class="hljs pgsql">// Creates a "Pseudo Console" (ConPTY). HRESULT WINAPI CreatePseudoConsole( _In_ COORD size, // ConPty Dimensions _In_ HANDLE hInput, // ConPty <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> _In_ HANDLE hOutput, // ConPty Output _In_ DWORD dwFlags, // ConPty Flags _Out_ HPCON* phPC); // ConPty Reference // Resizes the given ConPTY <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the specified size, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> characters. HRESULT WINAPI ResizePseudoConsole(_In_ HPCON hPC, _In_ COORD size); // Closes the ConPTY <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> associated handles. Client applications attached // <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the ConPTY will <span class="hljs-keyword"><span class="hljs-keyword">also</span></span> terminated. <span class="hljs-type"><span class="hljs-type">VOID</span></span> WINAPI ClosePseudoConsole(_In_ HPCON hPC);</code> </pre> <br>  Die obige API ConPTY stellt im Wesentlichen drei neue Funktionen zur Verfügung: <br><br><ul><li> <b><code>CreatePseudoConsole(size, hInput, hOutput, dwFlags, phPC)</code></b> <br> <ul><li>  Erstellt pty mit einer Dimension in <code>w</code> Spalten und <code>h</code> Zeilen unter Verwendung der vom Aufrufer erstellten Kanäle: <br><ul><li>  <code>size</code> : Breite und Höhe (in Zeichen) des ConPTY-Puffers </li><li>  <code>hInput</code> : Zum Schreiben von Eingabedaten in PTY als Text- / VT-Sequenzen in UTF-8-Codierung </li><li>  <code>hOutput</code> : Zum Lesen der Ausgabe von PTY als Text- / VT-Sequenzen in UTF-8-Codierung </li><li>  <code>dwFlags</code> : Mögliche Werte: <br><ul><li>  <code>PSEUDOCONSOLE_INHERIT_CURSOR</code> : Erstelltes ConPTY versucht, die Cursorposition der übergeordneten Terminalanwendung zu erben </li></ul></li><li>  <code>phPC</code> : Konsolenhandle für von ConPty generiert </li></ul></li><li>  <b>Rückgabe</b> : Erfolg / Misserfolg.  Bei Erfolg enthält phPC das Handle für die neue ConPty </li></ul><br> <b><code>ResizePseudoConsole(hPC, size)</code></b> <br> <ul><li>  Ändert die Größe des internen ConPTY-Puffers, um eine bestimmte Breite und Höhe anzuzeigen </li></ul><br> <b><code>ClosePseudoConsole (hPC)</code></b> <br> <ul><li>  ConPTY    .  ,   ConPTY,  ,        ,   </li></ul><br><h2>  ConPTY API </h2><br>       ConPTY API           ConPTY. <br><br><blockquote> :      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  GitHub</a> </blockquote><br><pre> <code class="hljs ruby"> /<span class="hljs-regexp"><span class="hljs-regexp">/ Note: Most error checking removed for brevity. /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ... /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Initializes the specified startup info struct with the required properties and /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ updates its thread attribute list with the specified ConPTY handle HRESULT InitializeStartupInfoAttachedToConPTY(STARTUPINFOEX* siEx, HPCON hPC) { HRESULT hr = E_UNEXPECTED; size_t size; siEx-&gt;StartupInfo.cb = sizeof(STARTUPINFOEX); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Create the appropriately sized thread attribute list InitializeProcThreadAttributeList(NULL, 1, 0, &amp;size); std::unique_ptr&lt;BYTE[]&gt; attrList = std::make_unique&lt;BYTE[]&gt;(size); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Set startup info's attribute list &amp; initialize it siEx-&gt;lpAttributeList = reinterpret_cast&lt;PPROC_THREAD_ATTRIBUTE_LIST&gt;( attrList.get()); bool fSuccess = InitializeProcThreadAttributeList( siEx-&gt;lpAttributeList, 1, 0, (PSIZE_T)&amp;size); if (fSuccess) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Set thread attribute list's Pseudo Console to the specified ConPTY fSuccess = UpdateProcThreadAttribute( lpAttributeList, 0, PROC_THREAD_ATTRIBUTE_PSEUDOCONSOLE, hPC, sizeof(HPCON), NULL, NULL); return fSuccess ? S_OK : HRESULT_FROM_WIN32(GetLastError()); } else { hr = HRESULT_FROM_WIN32(GetLastError()); } return hr; } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ... HANDLE hOut, hIn; HANDLE outPipeOurSide, inPipeOurSide; HANDLE outPipePseudoConsoleSide, inPipePseudoConsoleSide; HPCON hPC = 0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Create the in/out</span></span> <span class="hljs-symbol"><span class="hljs-symbol">pipes:</span></span> CreatePipe(&amp;inPipePseudoConsoleSide, &amp;inPipeOurSide, NULL, <span class="hljs-number"><span class="hljs-number">0</span></span>); CreatePipe(&amp;outPipeOurSide, &amp;outPipePseudoConsoleSide, NULL, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Create the Pseudo Console, using the pipes CreatePseudoConsole( {<span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>}, inPipePseudoConsoleSide, outPipePseudoConsoleSide, <span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;hPC); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Prepare the StartupInfoEx structure attached to the ConPTY. STARTUPINFOEX siEx{}; InitializeStartupInfoAttachedToConPTY(&amp;siEx, hPC); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Create the client application, using startup info containing ConPTY info wchar_t* commandline = L<span class="hljs-string"><span class="hljs-string">"c:\\windows\\system32\\cmd.exe"</span></span>; PROCESS_INFORMATION piClient{}; fSuccess = CreateProcessW( nullptr, commandline, nullptr, nullptr, TRUE, EXTENDED_STARTUPINFO_PRESENT, nullptr, nullptr, &amp;siEx-&gt;StartupInfo, &amp;piClient); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ...</code> </pre> <br>  cmd.exe    ConPTY,  <code>CreatePseudoConsole()</code> .       ConPTY     /  Cmd.      <code>ResizePseudoConsole()</code> ,   —   <code>ClosePseudoConsole()</code> . <br><br><h3>    </h3><br>     ConPTY  : <br><br><pre> <code class="hljs pgsql">// <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> "echo Hello, World!", press enter <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> have cmd process the command, // <span class="hljs-keyword"><span class="hljs-keyword">input</span></span> an up arrow (<span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> the previous command), <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> enter again <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">execute</span></span>. std::string helloWorld = "echo Hello, World!\n\x1b[A\n"; DWORD dwWritten; WriteFile(hIn, helloWorld.c_str(), (DWORD)helloWorld.length(), &amp;dwWritten, nullptr);</code> </pre> <br><h3>    </h3><br>   ,    ConPTY: <br><br><pre> <code class="hljs pgsql">// Suppose <span class="hljs-keyword"><span class="hljs-keyword">some</span></span> other async callback triggered us <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> resize. // This <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> will <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> the Terminal <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> the size we received. HRESULT hr = ResizePseudoConsole(hPC, {<span class="hljs-number"><span class="hljs-number">120</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>});</code> </pre> <br><h3>   </h3><br>     ConPTY: <br><br><pre> <code class="hljs lisp">ClosePseudoConsole(<span class="hljs-name"><span class="hljs-name">hPC</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br> :  ConPTY   ConHost    . <br><br><h1>   ! </h1><br>  ConPTY API — ,       ,     Windows   …   <i></i> ! <br><br>     ConPTY API   Microsoft,        Microsoft ( Windows  Linux (WSL),  Windows Containers, VSCode, Visual Studio  .),      ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@ConEmuMaximus5</a> —    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ConEmu</a>  Windows. <br><br> <b>    </b> ,        ConPTY API. <br><br><h2>     </h2><br>       ,        : ConHost     .           Console API.     ,          ,    . <br><br>   ,      VT, ,    —  . <br><br>   ,     <b></b>    Windows,      /VT   UTF-8    Console API:  «  VT»     ,      Console API (, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> 16M RGB True Color</a> ). <br><br><h2>   / </h2><br>       /     ,             ConPTY API:         ,  ,    ,   ,   . <br><br><blockquote>     VSCode      ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub #45693</a> )   ,     Windows. </blockquote><br><h2>  ConPTY API </h2><br>  ConPTY API     Windows 10 / 2018 . <br><br>      Windows, ,    ,     ConPTY.     Win32 API,     API    Runtime Dynamic Linking   <code>LoadLibrary()</code>  <code>GetProcAddress()</code> . <br><br>    Windows  ConPTY,        API ConPTY.  ,     ,    . <br><br><h1> ,    ? </h1><br>    …   !  ,       , <b></b> !  : D. <br><br>       ,   , <i></i>    ,   <i></i>  .   —            ,          Windows  ,   . <br><br>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  </a> .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> Windows Console  GitHub</a> .    , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">    </a> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de420853/">https://habr.com/ru/post/de420853/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de420837/index.html">Testen von Software-RAID-Arrays für NVMe-Geräte mithilfe der SNIA-Methode</a></li>
<li><a href="../de420841/index.html">Hotfix vor dem Krankenhaus oder „Hey Swagger! Wo sind meine Fehler? "</a></li>
<li><a href="../de420843/index.html">7. September, Jekaterinburg - ein Treffen für .NET-Entwickler</a></li>
<li><a href="../de420845/index.html">Die Zähmung des Hartnäckigen mit einer Krücke: das Loch des WLAN-Adapters WF2190 (Realtek8812AU Wireless LAN 802.11ac USB)</a></li>
<li><a href="../de420847/index.html">Einführung in die Shader-Programmierung für Layouts</a></li>
<li><a href="../de420857/index.html">Nahtloses Wi-Fi-Roaming: Theorie in der Praxis</a></li>
<li><a href="../de420859/index.html">Zur Frage von Wirth und Ketten</a></li>
<li><a href="../de420861/index.html">Vorbereitungen für C ++ 20. Coroutines TS Real Fallstudie</a></li>
<li><a href="../de420863/index.html">Als wir das erste russische Smartphone machten, ging es weiter</a></li>
<li><a href="../de420865/index.html">Das Prinzip der geringsten Aktion. Teil 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>