<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôÄ üèáüèº üö£üèª Lernen Sie die Windows Pseudo Console (ConPTY) kennen ü§úüèø üåí ü¶ì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ver√∂ffentlicht am 2. August 2018 

 Dies ist der zweite Artikel √ºber die Windows-Befehlszeile, in dem wir die neuen Infrastruktur- und Program...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lernen Sie die Windows Pseudo Console (ConPTY) kennen</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420853/">  <font color="gray">Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ver√∂ffentlicht</a> am 2. August 2018</font> <br><br>  Dies ist der zweite Artikel √ºber die Windows-Befehlszeile, in dem wir die neuen Infrastruktur- und Programmierschnittstellen der Windows-Pseudokonsole, dh der Windows-Pseudokonsole (ConPTY), erl√§utern: Warum wir sie entwickelt haben, warum sie ben√∂tigt wird, wie sie funktioniert, wie sie verwendet wird und vieles mehr. <br><br>  Im letzten Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûDas schwere Erbe der Vergangenheit.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Windows-Befehlszeilenprobleme ‚Äú</a> Wir sprachen √ºber die Voraussetzungen f√ºr die Entstehung des Terminals und die Entwicklung der Befehlszeile in Windows und begannen auch, die interne Struktur der Windows-Konsole und der Windows-Befehlszeileninfrastruktur zu untersuchen.  Wir haben auch die vielen Vor- und Nachteile der Windows-Konsole er√∂rtert. <br><br>  Einer der Nachteile ist, dass Windows versucht, "n√ºtzlich" zu sein, aber Entwickler von alternativen Konsolen und Konsolen von Drittanbietern, Serviceentwickler usw. st√∂rt.  Beim Erstellen einer Konsole oder eines Dienstes m√ºssen Entwickler Zugriff auf Kommunikationskan√§le haben, √ºber die ihr Terminal / Dienst Daten mit Befehlszeilenanwendungen austauscht, oder Zugriff darauf gew√§hren.  In der * NIX-Welt ist dies kein Problem, da * NIX eine Pseudo-Terminal-Infrastruktur (PTY) bereitstellt, mit der auf einfache Weise Kommunikationskan√§le f√ºr eine Konsole oder einen Dienst erstellt werden k√∂nnen.  Aber unter Windows war es nicht ... <br><br>  <i><b>‚Ä¶ bis heute!</b></i> <br><a name="habracut"></a><br><h1>  Von TTY zu PTY </h1><br>  Bevor wir detailliert auf unsere Entwicklung eingehen, kehren wir kurz zur Entwicklung von Terminals zur√ºck. <br><br><h2>  Am Anfang war TTY </h2><br>  Wie in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fr√ºheren Artikel</a> erl√§utert, steuerten Benutzer in den fr√ºhen Tagen des Rechnens Computer mithilfe elektromechanischer Teletypen (TTYs), die √ºber einen seriellen Kommunikationskanal (normalerweise √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine 20-mA-Stromschleife</a> ) mit einem Computer verbunden waren. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f7b/e47/7fa/f7be477fac4e46cc71e70df23b26bef6.jpg"><br>  <font color="gray"><i>Ken Thompson und Dennis Ritchie (stehend) arbeiten am DEC PDP-11-Teletyp (Nachrichten ohne elektronische Anzeige)</i></font> <br><br><h3>  Terminalverteilung </h3><br>  Teletypen wurden durch Computerterminals mit elektronischen Anzeigen (normalerweise CRT-Bildschirme) ersetzt.  In der Regel handelt es sich bei Terminals um sehr einfache Ger√§te (daher der Begriff "dummes Terminal"), die nur die Elektronik und die Verarbeitungsleistung enthalten, die f√ºr die folgenden Aufgaben ben√∂tigt werden: <br><br><ol><li>  Empfang von Texteingaben √ºber die Tastatur. </li><li>  Pufferung des eingegebenen Textes in einer Zeile (einschlie√ülich lokaler Bearbeitung vor dem Senden). </li><li>  Senden / Empfangen von Text auf einem seriellen Kanal (normalerweise √ºber die einst allgegenw√§rtige <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RS-232-Schnittstelle</a> ). </li><li>  Anzeige des empfangenen Textes auf dem Terminal-Display. </li></ol><br>  Trotz ihrer Einfachheit (oder vielleicht auch dank dessen) wurden Terminals schnell zum Hauptmittel f√ºr die Verwaltung von Minicomputern, Mainframes und Servern: Die meisten Dateneingabebetreiber, Computerbetreiber, Systemadministratoren, Wissenschaftler, Forscher, Softwareentwickler und Branchengr√∂√üen arbeiteten an DEC-Terminals. IBM, Wyse und viele andere. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/929/e3f/fd0/929e3ffd0e281600c9ef115f61b8b23a.jpg"><br>  <i><font color="gray">Admiral Grace Hopper in seinem B√ºro mit einem DEC VT220-Terminal auf seinem Schreibtisch</font></i> <br><br><h3>  Verteilung von Software-Terminals </h3><br>  Seit Mitte der 1980er Jahre werden nach und nach Allzweckcomputer anstelle von Spezialterminals eingesetzt, die erschwinglicher, beliebter und leistungsf√§higer geworden sind.  Viele fr√ºhe PCs und andere Computer der 80er Jahre hatten Terminalanwendungen, die die RS-232-Verbindung zum PC √∂ffneten und Daten mit anderen am anderen Ende der Verbindung austauschten. <br><br>  Als Allzweckcomputer immer ausgefeilter wurden, erschienen eine grafische Benutzeroberfl√§che (GUI) und eine v√∂llig neue Welt gleichzeitiger Anwendungen, einschlie√ülich Terminalanwendungen. <br><br>  Es gab jedoch ein Problem: Wie kann eine Terminalanwendung mit einer anderen Befehlszeilenanwendung interagieren, die auf demselben Computer ausgef√ºhrt wird?  Und wie kann man ein serielles Kabel physisch zwischen zwei Anwendungen verbinden, die auf demselben Computer ausgef√ºhrt werden? <br><br><h2>  Pseudo-Terminal-Darstellung (PTY) </h2><br>  In der * NIX-Welt wurde das Problem durch die Einf√ºhrung eines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pseudo-Terminals (PTY)</a> gel√∂st. <br><br>  PTY emuliert serielle Telekommunikationsger√§te in einem Computer, indem Master- und Slave-Pseudoger√§te (‚ÄûMaster‚Äú und ‚ÄûSlave‚Äú) verf√ºgbar gemacht werden: Terminalanwendungen stellen eine Verbindung zum Master-Pseudoger√§t her, und Befehlszeilenanwendungen (z. B. Shells wie cmd, PowerShell und bash) stellen eine Verbindung zum Slave-Pseudoger√§t her.  Wenn ein Terminal-Client Text- und / oder Steuerbefehle (als Text codiert) an das Master-Pseudoger√§t sendet, wird der Text in den ihm zugeordneten Slave √ºbersetzt.  Der Text aus der Anwendung wird an das Slave-Pseudoger√§t, dann zur√ºck an den Master und damit an das Terminal gesendet.  Daten werden immer asynchron gesendet / empfangen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a42/2ba/b58/a422bab5816acdd43dd7b1c562d65caf.png"><br>  <i><font color="gray">Pseudo-Terminal-Anwendung / Shell</font></i> <br><br>  Es ist wichtig zu beachten, dass das Pseudo-Slave-Ger√§t das Verhalten des physischen Terminals emuliert und Befehlszeichen in POSIX-Signale konvertiert.  Wenn der Benutzer beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">STRG + C</a> in das Terminal eingibt, wird der ASCII-Wert f√ºr STRG + C (0x03) √ºber den Master gesendet.  Beim Empfang auf einem Slave-Pseudoger√§t wird der Wert 0x03 aus dem Eingangsstrom entfernt und ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SIGINT-Signal</a> erzeugt. <br><br>  Eine solche PTY-Infrastruktur wird h√§ufig von * NIX-Terminalanwendungen, Textfeldmanagern (z. B. Bildschirm, tmux) usw. verwendet.  Diese Anwendungen rufen <code>openpty()</code> , das ein Paar Dateideskriptoren (fd) f√ºr den PTY-Master und <code>openpty()</code> zur√ºckgibt.  Dann kann die Anwendung eine untergeordnete Befehlszeilenanwendung (z. B. bash) verzweigen / ausf√ºhren, die ihre fd-Slaves verwendet, um Text abzuh√∂ren und an das verbundene Terminal zur√ºckzugeben. <br><br>  Dieser Mechanismus erm√∂glicht es Terminalanwendungen, direkt mit lokal ausgef√ºhrten Befehlszeilenanwendungen zu ‚Äûkommunizieren‚Äú, so wie ein Terminal √ºber eine serielle / Netzwerkverbindung mit einem Remotecomputer kommunizieren w√ºrde. <br><br><h2>  Was, kein Pseudokonsolen-Windows? </h2><br>  Wie bereits im vorherigen Artikel erl√§utert, √§hnelt die Windows-Konsole zwar konzeptionell dem herk√∂mmlichen * NIX-Terminal, unterscheidet sich jedoch in mehreren wesentlichen Punkten, insbesondere auf den untersten Ebenen, was f√ºr Entwickler von Windows-Befehlszeilenanwendungen, Terminals / Konsolen von Drittanbietern und Servern zu Problemen f√ºhren kann Anwendungen: <br><br><ol><li>  <b>Unter Windows gibt es keine PTY-Infrastruktur</b> : Wenn ein Benutzer eine Befehlszeilenanwendung startet (z. B. Cmd, PowerShell, wsl, ipconfig usw.), verbindet Windows selbst eine neue oder vorhandene Instanz der Konsole mit der Anwendung. </li><li>  <b>Windows st√∂rt Konsolen und Serveranwendungen von Drittanbietern</b> : Windows bietet Terminals (derzeit) keine M√∂glichkeit, Kommunikationskan√§le bereitzustellen, √ºber die sie mit einer Befehlszeilenanwendung interagieren m√∂chten.  Terminals von Drittanbietern m√ºssen Konsolen au√üerhalb des Bildschirms erstellen, vom Benutzer eingegebene Daten dorthin senden und die Ausgabe verschrotten, indem sie auf dem eigenen Display der Konsole von Drittanbietern neu gezeichnet werden! </li><li>  <b>Nur Windows verf√ºgt √ºber die Konsolen-API</b> : Windows-Befehlszeilenanwendungen basieren auf der Win32- <b>Konsolen</b> -API, wodurch die Code-Portabilit√§t verringert wird, da alle anderen Plattformen Text / VT unterst√ºtzen, nicht die API. </li><li>  <b>Nicht standardm√§√üiger Remotezugriff</b> : Die Abh√§ngigkeit von Befehlszeilenanwendungen von der Consol-API erschwert die Interaktions- und Remotezugriffsskripts erheblich. </li></ol><br><h2>  Was zu tun ist? </h2><br>  Viele, <b>viele</b> Entwickler forderten h√§ufig einen PTY-√§hnlichen Mechanismus unter Windows an, insbesondere diejenigen, die mit den Tools ConEmu / Cmder, Console2 / ConsoleZ, Hyper, VSCode, Visual Studio, WSL, Docker und OpenSSH arbeiten. <br><br>  Sogar Peter Bright, der Technologie-Editor von Ars Technica, bat mich einige Tage sp√§ter, den PTY-Mechanismus zu implementieren, als ich anfing, im Konsolenteam zu arbeiten: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2dd/799/ebf/2dd799ebf0c14f418ae7d68d9a26acaa.png"><br><br>  Und vor kurzem wieder: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4d1/c1e/c00/4d1c1ec00ffe5ad5e6f019d1a33198c8.png"><br><br>  Nun, wir haben es endlich <b>geschafft</b> : <b>Wir haben eine Pseudokonsole f√ºr Windows erstellt</b> : <br><br><h1>  Willkommen in der Windows Pseudo Console (ConPTY) </h1><br>  Seit der Gr√ºndung des Konsolenteams vor etwa vier Jahren hat die Gruppe die Windows-Konsole und die internen Mechanismen der Befehlszeile √ºberarbeitet.  Gleichzeitig haben wir die oben beschriebenen Probleme und viele andere damit zusammenh√§ngende Probleme regelm√§√üig und sorgf√§ltig gepr√ºft.  Aber die Infrastruktur und der Code waren noch nicht bereit, die Ver√∂ffentlichung der Pseudokonsole zu erm√∂glichen ... bis jetzt! <br><br>  Die neue Windows-Pseudokonsoleninfrastruktur (ConPTY), die API und einige andere damit verbundene √Ñnderungen werden eine ganze <b>Reihe</b> von Problemen beseitigen / lindern ... <b>ohne die Abw√§rtskompatibilit√§t mit vorhandenen Befehlszeilenanwendungen zu beeintr√§chtigen</b> ! <br><br><blockquote>  Die neue Win32 ConPTY-API (offizielle Dokumentation wird in K√ºrze ver√∂ffentlicht) ist jetzt in den neuesten Insider-Builds von Windows 10 und dem entsprechenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Windows 10 Insider Preview SDK</a> verf√ºgbar.  Sie werden in der n√§chsten Hauptversion von Windows 10 (irgendwann im Herbst / Winter 2018) erscheinen. </blockquote><br><h2>  Konsolen- / ConHost-Architektur </h2><br>  Um ConPTY zu verstehen, m√ºssen Sie die Architektur der Windows-Konsole studieren, oder besser ... ConHost! <br><br>  Es ist wichtig zu verstehen, dass ConHost zwar alles implementiert, was Sie als Windows-Konsolenanwendung sehen und wissen, ConHost jedoch auch den gr√∂√üten Teil der Windows-Befehlszeileninfrastruktur enth√§lt und implementiert!  Von nun an wird <b>ConHost zu einem echten "Konsolenknoten"</b> , der alle Befehlszeilenanwendungen und / oder GUI-Anwendungen unterst√ºtzt, die mit Befehlszeilenanwendungen interagieren! <br><br>  <b>Wie?</b>  <b>Warum?</b>  <b>Was?</b>  Schauen wir uns das genauer an. <br><br>  Hier ist eine allgemeine Ansicht der internen Konsolenarchitektur / ConHost: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/331/1bd/54d/3311bd54dbe80dc699ff243a4812b58a.png"><br><br>  Im Vergleich zur Architektur aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen Artikel</a> enth√§lt ConHost jetzt mehrere zus√§tzliche Module f√ºr die VT-Verarbeitung und das neue ConPTY-Modul, das offene APIs implementiert: <br><br><ul><li>  <b>ConPTY-API</b> : Die neuen Win32-ConPTY-APIs bieten einen √§hnlichen Mechanismus wie das POSIX PTY-Modell, jedoch unter Windows-Refraktion. </li><li>  <b>VT-Interaktivit√§t</b> : Empf√§ngt Eingabetext in UTF-8-Codierung, konvertiert jedes angezeigte Textzeichen in den entsprechenden <code>INPUT_RECORD</code> Datensatz und speichert ihn im Eingabepuffer.  Es verarbeitet auch Escape-Sequenzen wie 0x03 (STRG + C) und konvertiert sie in <code>KEY_EVENT_RECORDS</code> , die die entsprechende Escape-Aktion erzeugen. </li><li>  <b>VT-Renderer</b> : Erzeugt VT-Sequenzen, die zum Bewegen des Cursors und zum Rendern von Text und Stil in Bereichen des Ausgabepuffers erforderlich sind, die sich gegen√ºber dem vorherigen Frame ge√§ndert haben. </li></ul><br>  OK, aber was bedeutet das wirklich? <br><br><h2>  Wie funktionieren Windows-Befehlszeilenanwendungen? </h2><br>  Um die Auswirkungen der neuen ConPTY-Infrastruktur besser zu verstehen, schauen wir uns an, wie Windows-Konsolen- und Befehlszeilenanwendungen bisher funktioniert haben. <br><br>  Wenn ein Benutzer eine Befehlszeilenanwendung wie Cmd, PowerShell oder ssh startet, erstellt Windows einen neuen Win32-Prozess, in den die ausf√ºhrbare Bin√§rdatei der Anwendung und alle Abh√§ngigkeiten (Ressourcen oder Bibliotheken) geladen werden. <br><br>  Ein neu erstellter Prozess erbt normalerweise die Deskriptoren stdin und stdout von seinem √ºbergeordneten Prozess.  Wenn der √ºbergeordnete Prozess ein Windows-GUI-Prozess war, fehlen die Deskriptoren stdin und stdout, sodass Windows die neue Anwendung bereitstellt und an die neue Konsoleninstanz anf√ºgt.  Die Kommunikation zwischen Befehlszeilenanwendungen und ihrer Konsole wird √ºber ConDrv √ºbertragen. <br><br>  Wenn Sie beispielsweise von einer PowerShell-Instanz ohne erh√∂hte Berechtigungen ausgef√ºhrt werden, erbt der neue Anwendungsprozess die √ºbergeordneten Deskriptoren stdin / stdout und empf√§ngt daher Eingabedaten und gibt die Ausgabe an dieselbe Konsole wie die √ºbergeordnete aus. <br><br><blockquote>  Hier m√ºssen wir eine Reservierung vornehmen, da in einigen F√§llen Befehlszeilenanwendungen gestartet werden, die an eine <i>neue</i> Instanz der Konsole angeh√§ngt sind, insbesondere aus Sicherheitsgr√ºnden, aber die obige Beschreibung ist normalerweise wahr. </blockquote><br>  Wenn die Befehlszeilen- / Shell-Anwendung gestartet wird, verbindet Windows sie letztendlich √ºber ConDrv mit der Konsoleninstanz (ConHost.exe): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fc3/4c8/d37/fc34c8d37f6f31c843422193bd5d01a6.png"><br><br><h2>  Wie funktioniert ConHost? </h2><br>  Immer wenn eine Befehlszeilenanwendung ausgef√ºhrt wird, verbindet Windows die Anwendung mit einer neuen oder vorhandenen Instanz von ConHost.  Die Anwendung und ihre Konsoleninstanz sind √ºber den Kernelmodus-Konsolentreiber (ConDrv) verbunden, der IOCTL-Nachrichten sendet / empf√§ngt, die serialisierte API-Aufrufanforderungen und / oder Textdaten enthalten. <br><br>  Historisch gesehen ist die Arbeit von ConHost, wie in einem fr√ºheren Artikel erw√§hnt, heute relativ einfach: <br><br><ul><li>  Der Benutzer generiert Eingaben √ºber Tastatur / Maus / Stift / Touchpad, die in <code>KEY_EVENT_RECORD</code> oder <code>MOUSE_EVENT_RECORD</code> und im Eingabepuffer gespeichert werden. </li><li>  Der Eingabepuffer wird jeweils f√ºr einen Datensatz geleert und f√ºhrt die angeforderten Eingabeaktionen aus, z. B. Anzeigen von Text auf dem Bildschirm, Bewegen des Cursors, Kopieren / Einf√ºgen von Text usw.  Viele dieser Aktionen √§ndern den Inhalt des Ausgabepuffers.  Diese ge√§nderten Bereiche werden von der ConHost-Status-Engine aufgezeichnet. </li><li>  In jedem Frame zeigt die Konsole die ge√§nderten Bereiche des Ausgabepuffers an. </li></ul><br>  Wenn die Befehlszeilenanwendung die Windows-Konsolen-API aufruft, werden die API-Aufrufe in IOCTL-Nachrichten serialisiert und √ºber den ConDrv-Treiber gesendet.  Anschlie√üend werden IOCTL-Nachrichten an die angeschlossene Konsole gesendet, die den angeforderten API-Aufruf dekodiert und ausf√ºhrt.  Die zur√ºckgegebenen / ausgegebenen Werte werden zur√ºck in die IOCTL-Nachricht serialisiert und √ºber ConDrv an die Anwendung zur√ºckgesendet. <br><br><h2>  ConHost: Beitrag zur Vergangenheit f√ºr die Zukunft </h2><br>  Microsoft ist bestrebt, die Abw√§rtskompatibilit√§t mit vorhandenen Anwendungen und Tools nach M√∂glichkeit aufrechtzuerhalten.  Speziell f√ºr die Kommandozeile.  Tats√§chlich k√∂nnen 32-Bit-Versionen von Windows 10 immer noch viele / die meisten 16-Bit-Win16-Anwendungen und ausf√ºhrbaren Dateien ausf√ºhren! <br><br>  Wie oben erw√§hnt, besteht eine der Schl√ºsselrollen von ConHost darin, Dienste f√ºr seine Befehlszeilenanwendungen bereitzustellen, insbesondere f√ºr Legacy-Anwendungen, die die Win32-Konsolen-API aufrufen und sich darauf verlassen.  Jetzt bietet ConHost neue Dienste an: <br><br><ul><li>  Nahtlose PTY-√§hnliche Infrastruktur f√ºr die Kommunikation mit modernen Konsolen und Terminals </li><li>  Aktualisieren √§lterer / traditioneller Befehlszeilenanwendungen <br><ul><li>  Empfangen und Konvertieren von UTF-8-Text / VT in Eingabedatens√§tze (als ob vom Benutzer eingegeben) </li><li>  Die Konsolen-API ruft die gehostete Anwendung auf und aktualisiert ihren Ausgabepuffer entsprechend </li><li>  Zeigen Sie ge√§nderte Bereiche des Ausgabepuffers in UTF-8-Codierung, Text / VT an </li></ul></li></ul><br>  Das folgende Beispiel zeigt, wie eine moderne Konsolenanwendung √ºber ConPTY ConHost mit einer Befehlszeilenanwendung kommuniziert. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d72/7db/35e/d727db35e65b2e0eec45d0d535b4de83.png"><br><br>  In diesem neuen Modell: <br><br><ol><li>  Konsole: <br><ol><li>  Erstellt eigene Kommunikationskan√§le </li><li>  Ruft die ConPTY-API auf, um ConPTY zu erstellen, und zwingt Windows, eine Instanz von ConHost auszuf√ºhren, die mit dem anderen Ende der Kan√§le verbunden ist </li><li>  Erstellt wie gewohnt eine Instanz einer Befehlszeilenanwendung (z. B. PowerShell), die mit ConHost verbunden ist </li></ol></li><li>  Conhost: <br><ol><li>  Liest UTF-8-Text / VT am Eingang und konvertiert ihn in <code>INPUT_RECORD</code> Datens√§tze, die an die Befehlszeilenanwendung gesendet werden </li><li>  F√ºhren Sie API-Aufrufe von einer Befehlszeilenanwendung aus, die den Inhalt des Ausgabepuffers √§ndern kann </li><li>  Zeigt √Ñnderungen im Ausgabepuffer in UTF-8-Codierung (Text / VT) an und sendet den empfangenen Text an die Konsole </li></ol></li><li>  Befehlszeilenanwendung: <br><ol><li>  Es funktioniert wie gewohnt, liest die Eingabe und ruft die Konsolen-API auf, ohne zu ahnen, dass sein ConPTY ConHost die Eingabe und Ausgabe von / nach UTF-8 √ºbersetzt! </li></ol></li></ol><br>  Der letzte Moment ist wichtig!  Wenn die alte Befehlszeilenanwendung Aufrufe an die Konsolen-API wie <code>WriteConsoleOutput(...)</code> , wird der angegebene Text in den entsprechenden ConHost-Ausgabepuffer geschrieben.  In regelm√§√üigen Abst√§nden zeigt ConHost die ge√§nderten Bereiche des Ausgabepuffers als Text / VT an, der √ºber stdout an die Konsole zur√ºckgesendet wird. <br><br>  Letztendlich ‚Äûsprechen‚Äú sogar herk√∂mmliche Befehlszeilenanwendungen von au√üen den Text / die VT <b>ohne √Ñnderungen</b> ! <br><br>  Mithilfe der neuen ConPTY-Infrastruktur k√∂nnen Konsolen von Drittanbietern jetzt direkt mit modernen und traditionellen Befehlszeilenanwendungen interagieren und alle in Text / VT austauschen. <br><br><h2>  Remote-Interaktion mit Windows-Befehlszeilenanwendungen </h2><br>  Der oben beschriebene Mechanismus funktioniert auf einem Computer einwandfrei, hilft aber auch bei der Interaktion, z. B. mit einer PowerShell-Instanz auf einem Windows-Remotecomputer oder in einem Container. <br><br>  Beim Remote-Starten einer Befehlszeilenanwendung (d. H. Auf Remotecomputern, Servern oder Containern) tritt ein Problem auf.  Tatsache ist, dass Befehlszeilenanwendungen auf Remotecomputern mit der lokalen ConHost-Instanz kommunizieren, da IOCTL-Nachrichten nicht f√ºr die √úbertragung √ºber das Netzwerk ausgelegt sind.  Wie √ºbertrage ich Eingaben von der lokalen Konsole auf den Remotecomputer und wie erhalte ich die Ausgabe von der dort ausgef√ºhrten Anwendung?  Was tun mit Mac- und Linux-Computern, bei denen es Terminals, aber keine Windows-kompatiblen Konsolen gibt? <br><br>  Um den Windows-Computer fernsteuern zu k√∂nnen, ben√∂tigen wir eine Art Kommunikationsbroker, der Daten √ºber das Netzwerk transparent serialisieren, die Lebensdauer der Anwendungsinstanz verwalten usw. kann. <br><br>  Vielleicht so etwas wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ssh</a> ? <br><br>  Gl√ºcklicherweise wurde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenSSH</a> k√ºrzlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf Windows portiert</a> und als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zus√§tzliche Option zu Windows 10</a> hinzugef√ºgt.  PowerShell Core verwendet ssh auch als eines der unterst√ºtzten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PowerShell Core Remoting-Remoting-</a> Protokolle.  F√ºr Benutzer von Windows PowerShell ist das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Remoting von Windows PowerShell Remoting</a> weiterhin eine akzeptable Option. <br><br>  Lassen Sie uns sehen, wie Sie mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenSSH f√ºr Windows jetzt Windows-</a> Shells und Befehlszeilenanwendungen fernsteuern k√∂nnen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/30e/7fc/eeb/30e7fceebcbcea167c2d50d448c975a4.png"><br><br>  OpenSSH enth√§lt derzeit einige unerw√ºnschte Komplikationen: <br><br><ol><li>  Benutzer: <br><ol><li>  Startet den SSH-Client und Windows verbindet die Konsoleninstanz wie gewohnt </li><li>  Gibt Text in die Konsole ein, der Tastenanschl√§ge an den ssh-Client sendet </li></ol></li><li>  SSH-Client: <br><ol><li>  Liest die Eingabe als Bytes von Textdaten </li><li>  Sendet Textdaten √ºber das Netzwerk an den sshd-Abh√∂rdienst </li></ol></li><li>  Der sshd-Dienst durchl√§uft mehrere Phasen: <br><ol><li>  Startet die Standard-Shell (z. B. Cmd), die Windows zwingt, eine neue Instanz der Konsole zu erstellen und zu verbinden </li><li>  Findet die Konsole der Cmd-Instanz und stellt eine Verbindung zu ihr her </li><li>  Verschiebt die Konsole vom Bildschirm (und / oder verbirgt sie) </li><li>  Sendet vom SSH-Client empfangene Eingaben als Eingabe an die Konsole au√üerhalb des Bildschirms </li></ol></li><li>  Die cmd-Instanz funktioniert wie immer: <br><ol><li>  Sammelt Eingaben vom sshd-Dienst </li><li>  Macht die Arbeit </li><li>  Ruft die Konsolen-API auf, um Text zu rendern / zu formatieren, den Cursor zu bewegen usw. </li></ol></li><li>  Angeh√§ngte [Off-Screen] -Konsole: <br><ol><li>  F√ºhren Sie API-Aufrufe durch, indem Sie den Ausgabepuffer aktualisieren. </li></ol></li><li>  Sshd-Dienst: <br><ol><li>  Verschrottet den Ausgabepuffer der Off-Screen-Konsole, findet die Unterschiede, codiert sie in Text / VT und sendet ... </li></ol></li><li>  Ein SSH-Client, der Text sendet ... </li><li>  Konsole, die Text anzeigt </li></ol><br>  <b>Spa√ü, richtig?</b>  <b>√úberhaupt nicht!</b>  In dieser Situation kann vieles schief gehen, insbesondere beim Simulieren und Senden von Benutzereingaben und beim Leeren des Ausgabepuffers einer Off-Screen-Konsole.  Dies f√ºhrt zu Instabilit√§t, Abst√ºrzen, Datenkorruption, √ºberm√§√üigem Energieverbrauch usw.  Dar√ºber hinaus entfernen nicht alle Anwendungen nicht nur den Text selbst, sondern auch seine Eigenschaften, weshalb Formatierung und Farbe verloren gehen! <br><br><h3>  Fernarbeit mit modernem ConHost und ConPTY </h3><br>  <b>Sicher k√∂nnen wir die Situation verbessern?</b>  Ja, nat√ºrlich k√∂nnen wir - nehmen wir einige architektonische √Ñnderungen vor und wenden unser neues ConPTY an: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5e8/677/f1d/5e8677f1da3a8abcf2951f4e539c6470.png"><br><br>  Das Diagramm zeigt, dass sich die Schaltung wie folgt ge√§ndert hat: <br><br><ol><li>  Benutzer: <br><ol><li>  Startet den SSH-Client und Windows verbindet die Konsoleninstanz wie gewohnt </li><li>  Gibt Text in die Konsole ein, der Tastenanschl√§ge an den ssh-Client sendet </li></ol></li><li>  SSH-Client: <br><ol><li>  Liest die Eingabe als Bytes von Textdaten </li><li>  Sendet Textdaten √ºber das Netzwerk an den sshd-Abh√∂rdienst </li></ol></li><li>  Sshd-Dienst: <br><ol><li>  Erstellt stdin / stdout-Kan√§le </li><li>  Ruft die ConPTY-API auf, um ConPTY zu initiieren </li><li>  Startet eine Cmd-Instanz, die mit dem anderen Ende von ConPTY verbunden ist.  Windows initiiert und stellt eine neue Instanz von ConHost bereit </li></ol></li><li>  Die cmd-Instanz funktioniert wie immer: <br><ol><li>  Sammelt Eingaben vom sshd-Dienst </li><li>  Macht die Arbeit </li><li>  Ruft die Konsolen-API auf, um Text zu rendern / zu formatieren, den Cursor zu bewegen usw. </li></ol></li><li>  Instanz ConPTY ConHost: <br><ol><li>  F√ºhren Sie API-Aufrufe durch, indem Sie den Ausgabepuffer aktualisieren. </li><li>  Zeigt die ge√§nderten Bereiche des Ausgabepuffers als UTF-8-codierten Text / VT an, der √ºber ssh an die Konsole / das Terminal zur√ºckgesendet wird </li></ol></li></ol><br>  Dieser Ansatz mit ConPTY ist f√ºr den sshd-Dienst eindeutig sauberer und einfacher.  Die Aufrufe der Windows-Konsolen-API erfolgen vollst√§ndig in der ConHost-Instanz der Befehlszeilenanwendung, die alle sichtbaren √Ñnderungen in Text / VT konvertiert.  Wer sich mit ConHost verbindet, muss nicht wissen, dass die dortige Anwendung die Konsolen-API aufruft und keinen Text / VT generiert! <br><br>  Stimmen Sie zu, dass dieser neue ConPTY-Remoting-Mechanismus zu einer eleganten, konsistenten und einfachen Architektur f√ºhrt.  In Kombination mit den leistungsstarken Funktionen von ConHost, der Unterst√ºtzung √§lterer Anwendungen und der Anzeige von √Ñnderungen von Anwendungen, die die Konsolen-Konsolen-APIs als Text / VT aufrufen, hilft uns die neue ConHost- und ConPTY-Infrastruktur, die Vergangenheit in die Zukunft zu verschieben. <br><br><h1>  ConPTY API und wie man es benutzt </h1><br><blockquote>  Die ConPTY-API ist in der aktuellen Version des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Windows 10 Insider Preview SDK</a> verf√ºgbar. </blockquote><br>  Ich bin mir sicher, dass Sie es kaum erwarten k√∂nnen, Code zu sehen;) <br><br>  Schauen Sie sich die API-Deklarationen an: <br><br><pre> <code class="hljs pgsql">// Creates a "Pseudo Console" (ConPTY). HRESULT WINAPI CreatePseudoConsole( _In_ COORD size, // ConPty Dimensions _In_ HANDLE hInput, // ConPty <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> _In_ HANDLE hOutput, // ConPty Output _In_ DWORD dwFlags, // ConPty Flags _Out_ HPCON* phPC); // ConPty Reference // Resizes the given ConPTY <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the specified size, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> characters. HRESULT WINAPI ResizePseudoConsole(_In_ HPCON hPC, _In_ COORD size); // Closes the ConPTY <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> associated handles. Client applications attached // <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the ConPTY will <span class="hljs-keyword"><span class="hljs-keyword">also</span></span> terminated. <span class="hljs-type"><span class="hljs-type">VOID</span></span> WINAPI ClosePseudoConsole(_In_ HPCON hPC);</code> </pre> <br>  Die obige API ConPTY stellt im Wesentlichen drei neue Funktionen zur Verf√ºgung: <br><br><ul><li> <b><code>CreatePseudoConsole(size, hInput, hOutput, dwFlags, phPC)</code></b> <br> <ul><li>  Erstellt pty mit einer Dimension in <code>w</code> Spalten und <code>h</code> Zeilen unter Verwendung der vom Aufrufer erstellten Kan√§le: <br><ul><li>  <code>size</code> : Breite und H√∂he (in Zeichen) des ConPTY-Puffers </li><li>  <code>hInput</code> : Zum Schreiben von Eingabedaten in PTY als Text- / VT-Sequenzen in UTF-8-Codierung </li><li>  <code>hOutput</code> : Zum Lesen der Ausgabe von PTY als Text- / VT-Sequenzen in UTF-8-Codierung </li><li>  <code>dwFlags</code> : M√∂gliche Werte: <br><ul><li>  <code>PSEUDOCONSOLE_INHERIT_CURSOR</code> : Erstelltes ConPTY versucht, die Cursorposition der √ºbergeordneten Terminalanwendung zu erben </li></ul></li><li>  <code>phPC</code> : Konsolenhandle f√ºr von ConPty generiert </li></ul></li><li>  <b>R√ºckgabe</b> : Erfolg / Misserfolg.  Bei Erfolg enth√§lt phPC das Handle f√ºr die neue ConPty </li></ul><br> <b><code>ResizePseudoConsole(hPC, size)</code></b> <br> <ul><li>  √Ñndert die Gr√∂√üe des internen ConPTY-Puffers, um eine bestimmte Breite und H√∂he anzuzeigen </li></ul><br> <b><code>ClosePseudoConsole (hPC)</code></b> <br> <ul><li>  ConPTY    .  ,   ConPTY,  ,        ,   </li></ul><br><h2>  ConPTY API </h2><br>       ConPTY API           ConPTY. <br><br><blockquote> :      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  GitHub</a> </blockquote><br><pre> <code class="hljs ruby"> /<span class="hljs-regexp"><span class="hljs-regexp">/ Note: Most error checking removed for brevity. /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ... /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Initializes the specified startup info struct with the required properties and /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ updates its thread attribute list with the specified ConPTY handle HRESULT InitializeStartupInfoAttachedToConPTY(STARTUPINFOEX* siEx, HPCON hPC) { HRESULT hr = E_UNEXPECTED; size_t size; siEx-&gt;StartupInfo.cb = sizeof(STARTUPINFOEX); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Create the appropriately sized thread attribute list InitializeProcThreadAttributeList(NULL, 1, 0, &amp;size); std::unique_ptr&lt;BYTE[]&gt; attrList = std::make_unique&lt;BYTE[]&gt;(size); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Set startup info's attribute list &amp; initialize it siEx-&gt;lpAttributeList = reinterpret_cast&lt;PPROC_THREAD_ATTRIBUTE_LIST&gt;( attrList.get()); bool fSuccess = InitializeProcThreadAttributeList( siEx-&gt;lpAttributeList, 1, 0, (PSIZE_T)&amp;size); if (fSuccess) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Set thread attribute list's Pseudo Console to the specified ConPTY fSuccess = UpdateProcThreadAttribute( lpAttributeList, 0, PROC_THREAD_ATTRIBUTE_PSEUDOCONSOLE, hPC, sizeof(HPCON), NULL, NULL); return fSuccess ? S_OK : HRESULT_FROM_WIN32(GetLastError()); } else { hr = HRESULT_FROM_WIN32(GetLastError()); } return hr; } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ... HANDLE hOut, hIn; HANDLE outPipeOurSide, inPipeOurSide; HANDLE outPipePseudoConsoleSide, inPipePseudoConsoleSide; HPCON hPC = 0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Create the in/out</span></span> <span class="hljs-symbol"><span class="hljs-symbol">pipes:</span></span> CreatePipe(&amp;inPipePseudoConsoleSide, &amp;inPipeOurSide, NULL, <span class="hljs-number"><span class="hljs-number">0</span></span>); CreatePipe(&amp;outPipeOurSide, &amp;outPipePseudoConsoleSide, NULL, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Create the Pseudo Console, using the pipes CreatePseudoConsole( {<span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>}, inPipePseudoConsoleSide, outPipePseudoConsoleSide, <span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;hPC); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Prepare the StartupInfoEx structure attached to the ConPTY. STARTUPINFOEX siEx{}; InitializeStartupInfoAttachedToConPTY(&amp;siEx, hPC); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Create the client application, using startup info containing ConPTY info wchar_t* commandline = L<span class="hljs-string"><span class="hljs-string">"c:\\windows\\system32\\cmd.exe"</span></span>; PROCESS_INFORMATION piClient{}; fSuccess = CreateProcessW( nullptr, commandline, nullptr, nullptr, TRUE, EXTENDED_STARTUPINFO_PRESENT, nullptr, nullptr, &amp;siEx-&gt;StartupInfo, &amp;piClient); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ...</code> </pre> <br>  cmd.exe    ConPTY,  <code>CreatePseudoConsole()</code> .       ConPTY     /  Cmd.      <code>ResizePseudoConsole()</code> ,   ‚Äî   <code>ClosePseudoConsole()</code> . <br><br><h3>    </h3><br>     ConPTY  : <br><br><pre> <code class="hljs pgsql">// <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> "echo Hello, World!", press enter <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> have cmd process the command, // <span class="hljs-keyword"><span class="hljs-keyword">input</span></span> an up arrow (<span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> the previous command), <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> enter again <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">execute</span></span>. std::string helloWorld = "echo Hello, World!\n\x1b[A\n"; DWORD dwWritten; WriteFile(hIn, helloWorld.c_str(), (DWORD)helloWorld.length(), &amp;dwWritten, nullptr);</code> </pre> <br><h3>    </h3><br>   ,    ConPTY: <br><br><pre> <code class="hljs pgsql">// Suppose <span class="hljs-keyword"><span class="hljs-keyword">some</span></span> other async callback triggered us <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> resize. // This <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> will <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> the Terminal <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> the size we received. HRESULT hr = ResizePseudoConsole(hPC, {<span class="hljs-number"><span class="hljs-number">120</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>});</code> </pre> <br><h3>   </h3><br>     ConPTY: <br><br><pre> <code class="hljs lisp">ClosePseudoConsole(<span class="hljs-name"><span class="hljs-name">hPC</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br> :  ConPTY   ConHost    . <br><br><h1>   ! </h1><br>  ConPTY API ‚Äî ,       ,     Windows   ‚Ä¶   <i></i> ! <br><br>     ConPTY API   Microsoft,        Microsoft ( Windows  Linux (WSL),  Windows Containers, VSCode, Visual Studio  .),      ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@ConEmuMaximus5</a> ‚Äî    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ConEmu</a>  Windows. <br><br> <b>    </b> ,        ConPTY API. <br><br><h2>     </h2><br>       ,        : ConHost     .           Console API.     ,          ,    . <br><br>   ,      VT, ,    ‚Äî  . <br><br>   ,     <b></b>    Windows,      /VT   UTF-8    Console API:  ¬´  VT¬ª     ,      Console API (, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> 16M RGB True Color</a> ). <br><br><h2>   / </h2><br>       /     ,             ConPTY API:         ,  ,    ,   ,   . <br><br><blockquote>     VSCode      ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub #45693</a> )   ,     Windows. </blockquote><br><h2>  ConPTY API </h2><br>  ConPTY API     Windows 10 / 2018 . <br><br>      Windows, ,    ,     ConPTY.     Win32 API,     API    Runtime Dynamic Linking   <code>LoadLibrary()</code>  <code>GetProcAddress()</code> . <br><br>    Windows  ConPTY,        API ConPTY.  ,     ,    . <br><br><h1> ,    ? </h1><br>    ‚Ä¶   !  ,       , <b></b> !  : D. <br><br>       ,   , <i></i>    ,   <i></i>  .   ‚Äî            ,          Windows  ,   . <br><br>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  </a> .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> Windows Console  GitHub</a> .    , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">    </a> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de420853/">https://habr.com/ru/post/de420853/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de420837/index.html">Testen von Software-RAID-Arrays f√ºr NVMe-Ger√§te mithilfe der SNIA-Methode</a></li>
<li><a href="../de420841/index.html">Hotfix vor dem Krankenhaus oder ‚ÄûHey Swagger! Wo sind meine Fehler? "</a></li>
<li><a href="../de420843/index.html">7. September, Jekaterinburg - ein Treffen f√ºr .NET-Entwickler</a></li>
<li><a href="../de420845/index.html">Die Z√§hmung des Hartn√§ckigen mit einer Kr√ºcke: das Loch des WLAN-Adapters WF2190 (Realtek8812AU Wireless LAN 802.11ac USB)</a></li>
<li><a href="../de420847/index.html">Einf√ºhrung in die Shader-Programmierung f√ºr Layouts</a></li>
<li><a href="../de420857/index.html">Nahtloses Wi-Fi-Roaming: Theorie in der Praxis</a></li>
<li><a href="../de420859/index.html">Zur Frage von Wirth und Ketten</a></li>
<li><a href="../de420861/index.html">Vorbereitungen f√ºr C ++ 20. Coroutines TS Real Fallstudie</a></li>
<li><a href="../de420863/index.html">Als wir das erste russische Smartphone machten, ging es weiter</a></li>
<li><a href="../de420865/index.html">Das Prinzip der geringsten Aktion. Teil 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>