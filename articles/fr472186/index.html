<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï£ üî∫ üîØ Principe ouvert-ferm√© üë©‚Äçüé® üõí üë¥üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Voici une traduction d'un article de Robert Martin du principe Open-Closed qu'il a publi√© en janvier 1996. L'article, pour le moins, n'...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Principe ouvert-ferm√©</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/472186/"><p>  Bonjour, Habr!  Voici une traduction d'un article de Robert Martin du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://web.archive.org/web/20060822033314/">principe Open-Closed</a> qu'il a publi√© en janvier 1996.  L'article, pour le moins, n'est pas le dernier.  Mais dans RuNet, les articles d'oncle Bob sur SOLID ne sont racont√©s que sous une forme tronqu√©e, j'ai donc pens√© qu'une traduction compl√®te ne serait pas superflue. </p><br><p><img src="https://habrastorage.org/webt/yt/xn/-q/ytxn-qjuk7_t4wyyna-6nr4xvsc.png"></p><br><p>  J'ai d√©cid√© de commencer par la lettre O, car le principe d'ouverture-fermeture, en fait, est central.  Entre autres choses, il existe de nombreuses subtilit√©s importantes qui m√©ritent une attention particuli√®re: </p><br><ul><li>  Aucun programme ne peut √™tre "ferm√©" √† 100%. </li><li>  La programmation orient√©e objet (POO) ne fonctionne pas avec des objets physiques du monde r√©el, mais avec des concepts - par exemple, le concept de "commande". <a name="habracut"></a></li></ul><br><p>  Ceci est le premier article de ma colonne <em>Notes d'ing√©nieur</em> pour <em>le rapport C ++</em> .  Les articles publi√©s dans cette colonne se concentreront sur l'utilisation de C ++ et OOP et aborderont les difficult√©s du d√©veloppement logiciel.  Je vais essayer de rendre les mat√©riaux pragmatiques et utiles pour les ing√©nieurs en exercice.  Pour la documentation de la conception orient√©e objet dans ces articles, j'utiliserai la notation de Buch. </p><br><p>  Il existe de nombreuses heuristiques associ√©es √† la programmation orient√©e objet.  Par exemple, ¬´toutes les variables membres doivent √™tre priv√©es¬ª, ou ¬´les variables globales doivent √™tre √©vit√©es¬ª ou ¬´la d√©termination du type lors de l'ex√©cution est dangereuse¬ª.  Quelle est la raison de ces heuristiques?  Pourquoi sont-ils vrais?  Sont-ils <em>toujours</em> vrais?  Cette colonne explore le principe de conception qui sous-tend ces heuristiques - le principe d'ouverture-fermeture. <br>  Ivar Jacobson a d√©clar√©: ¬´Tous les syst√®mes changent au cours du cycle de vie.  Cela doit √™tre pris en compte lors de la conception d'un syst√®me pour lequel plusieurs versions sont attendues. ¬ª  Comment concevoir un syst√®me pour qu'il soit stable face au changement et que plus d'une version soit attendue?  Bertrand Meyer nous en a parl√© en 1988, lorsque le d√©sormais c√©l√®bre principe d'ouverture-proximit√© a √©t√© formul√©: </p><br><p>  <strong>Les entit√©s de programme (classes, modules, fonctions, etc.) doivent √™tre ouvertes pour l'expansion et ferm√©es pour les modifications.</strong> </p><br><p>  Si un changement dans le programme entra√Æne une cascade de changements dans les modules d√©pendants, alors le programme affiche des signes ind√©sirables d'une ¬´mauvaise¬ª conception. </p><br><p>  Le programme devient fragile, inflexible, impr√©visible et inutilis√©.  Le principe d'ouverture-ouverture r√©sout ces probl√®mes de mani√®re tr√®s simple.  Il dit qu'il faut concevoir des modules qui ne <em>changent</em> jamais.  Lorsque les exigences changent, vous devez √©tendre le comportement de ces modules en ajoutant du nouveau code, plut√¥t qu'en changeant l'ancien code d√©j√† fonctionnel. </p><br><h1>  La description </h1><br><p>  Les modules qui r√©pondent au principe d'ouverture-proximit√© ont deux caract√©ristiques principales: </p><br><ol><li>  <strong>Ouvert pour expansion.</strong>  Cela signifie que le comportement du module peut √™tre √©tendu.  Autrement dit, nous pouvons ajouter un nouveau comportement au module en fonction des exigences changeantes de l'application ou pour r√©pondre aux besoins de nouvelles applications. </li><li> <strong>Ferm√© pour changement.</strong>  Le code source d'un tel module est intouchable.  Personne n'a le droit d'y apporter des modifications. </li></ol><br><p>  Il semble que ces deux signes ne s'embo√Ætent pas.  La mani√®re standard d'√©tendre le comportement d'un module consiste √† y apporter des modifications.  Un module qui ne peut pas √™tre modifi√© est g√©n√©ralement consid√©r√© comme un module √† comportement fixe.  Comment ces deux conditions oppos√©es peuvent-elles √™tre remplies? </p><br><h1>  La cl√© de la solution est l'abstraction. </h1><br><p>  En C ++, en utilisant les principes de la conception orient√©e objet, il est possible de cr√©er des abstractions fixes qui peuvent repr√©senter un ensemble illimit√© de comportements possibles. </p><br><p>  Les abstractions sont des classes de base abstraites et un ensemble illimit√© de comportements possibles est repr√©sent√© par toutes les classes successives possibles.  Un module peut manipuler l'abstraction.  Un tel module est ferm√© pour modifications, car il d√©pend d'une abstraction fixe.  De plus, le comportement du module peut √™tre √©tendu en cr√©ant de nouveaux descendants d'abstraction. </p><br><p> Le diagramme ci-dessous montre une option de conception simple qui ne r√©pond pas au principe d'ouverture-proximit√©.  Les deux classes, <code>Client</code> et <code>Server</code> , ne sont pas abstraites.  Il n'y a aucune garantie que les fonctions qui sont membres de la classe <code>Server</code> sont virtuelles.  La classe <code>Client</code> utilise la classe <code>Server</code> .  Si nous voulons que l'objet de classe <code>Client</code> utilise un autre objet serveur, nous devons changer la classe <code>Client</code> pour faire r√©f√©rence √† la nouvelle classe de serveur. </p><br><p><img src="https://habrastorage.org/webt/ee/0b/3d/ee0b3dy_mdhs48fzsk2cz9qm6tu.png" alt="image"><br>  <em>Client ferm√©</em> </p><br><p>  Et le diagramme suivant montre l'option de conception correspondante, qui r√©pond au principe d'ouverture-proximit√©.  Dans ce cas, la classe <code>AbstractServer</code> est une classe abstraite, dont toutes les fonctions membres sont virtuelles.  La classe <code>Client</code> utilise l'abstraction.  Cependant, les objets de la classe <code>Client</code> utiliseront des objets de la classe successeur <code>Server</code> .  Si nous voulons que les objets de la classe <code>Client</code> utilisent une classe de serveur diff√©rente, nous introduirons un nouveau descendant de la classe <code>AbstractServer</code> .  La classe <code>Client</code> restera inchang√©e. </p><br><p><img src="https://habrastorage.org/webt/k6/ea/y_/k6eay_lv4u4q7rsu7z37pimqtme.png" alt="image"><br>  <em>Client ouvert</em> </p><br><h1>  <code>Shape</code> abstraite </h1><br><p>  Prenons une application qui devrait dessiner des cercles et des carr√©s dans une interface graphique standard.  Les cercles et les carr√©s doivent √™tre dessin√©s dans un ordre sp√©cifique.  Dans l'ordre correspondant, une liste de cercles et de carr√©s sera compil√©e, le programme devrait parcourir cette liste dans l'ordre et dessiner chaque cercle ou carr√©. </p><br><p>  En C, en utilisant des techniques de programmation proc√©durale qui ne respectent pas le principe d'ouverture-fermeture, nous pourrions r√©soudre ce probl√®me comme le montre le listing 1. Ici, nous voyons de nombreuses structures de donn√©es avec le m√™me premier √©l√©ment.  Cet √©l√©ment est un code de type qui identifie la structure de donn√©es comme un cercle ou un carr√©.  La fonction <code>DrawAllShapes</code> passe par un tableau de pointeurs vers ces structures de donn√©es, reconnaissant le code de type et appelant ensuite la fonction correspondante ( <code>DrawCircle</code> ou <code>DrawSquare</code> ). </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 //  /    enum ShapeType {circle, square} struct Shape { ShapeType itsType; }; struct Circle { ShapeType itsType; double itsRadius; Point itsCenter; }; struct Square { ShapeType itsType; double itsSide; Point itsTopLeft; }; // //     // void DrawSquare(struct Square*) void DrawCircle(struct Circle*); typedef struct Shape *ShapePointer; void DrawAllShapes(ShapePointer list[], int n) { int i; for (i=0; i&lt;n; i++) { struct Shape* s = list[i]; switch (s-&gt;itsType) { case square: DrawSquare((struct Square*)s); break; case circle: DrawCircle((struct Circle*)s); break; } } }</span></span></code> </pre> <br><p>  La fonction <code>DrawAllShapes</code> r√©pond pas au principe d'ouverture-fermeture, car elle ne peut pas √™tre ¬´ferm√©e¬ª √† partir de nouveaux types de formes.  Si je voulais √©tendre cette fonction avec la possibilit√© de dessiner des formes √† partir d'une liste qui comprend des triangles, alors je devrais changer la fonction.  En fait, je dois changer la fonction pour chaque nouveau type de forme que je dois dessiner. </p><br><p>  Bien s√ªr, ce programme n'est qu'un exemple.  Dans la vie r√©elle, l'op√©rateur de <code>switch</code> de la fonction <code>DrawAllShapes</code> serait r√©p√©t√© maintes et maintes fois dans diverses fonctions de l'application, et chacun ferait quelque chose de diff√©rent.  Ajouter de nouvelles formes √† une telle application signifie trouver tous les endroits o√π de telles <code>switch</code> (ou cha√Ænes <code>if/else</code> ) sont utilis√©es, et ajouter une nouvelle forme √† chacune d'elles.  De plus, il est tr√®s peu probable que toutes les <code>switch</code> et les cha√Ænes <code>if/else</code> soient aussi bien structur√©es que dans <code>DrawAllShapes</code> .  Il est beaucoup plus probable que les pr√©dicats dans le <code>if</code> soient combin√©es avec des op√©rateurs logiques, ou que les blocs de <code>switch</code> soient combin√©s de mani√®re √† ¬´simplifier¬ª une place particuli√®re dans le code.  Par cons√©quent, le probl√®me de trouver et de comprendre tous les endroits o√π vous devez ajouter une nouvelle figure peut √™tre non trivial. </p><br><p>  Dans le Listing 2, je montrerai du code qui illustre une solution carr√©e / circulaire qui r√©pond au principe d'ouverture-fermeture.  Une classe <code>Shape</code> abstraite est introduite.  Cette classe abstraite contient une fonction de <code>Draw</code> virtuel pur.  Les classes <code>Circle</code> et <code>Square</code> sont des descendants de la classe <code>Shape</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 2 //  /  - class Shape { public: virtual void Draw() const = 0; }; class Square : public Shape { public: virtual void Draw() const; }; class Circle : public Shape { public: virtual void Draw() const; }; void DrawAllShapes(Set&lt;Shape*&gt;&amp; list) { for (Iterator&lt;Shape*&gt;i(list); i; i++) (*i)-&gt;Draw(); }</span></span></code> </pre> <br><p>  Notez que si nous voulons √©tendre le comportement de la fonction <code>DrawAllShapes</code> du Listing 2 pour dessiner un nouveau type de forme, tout ce que nous devons faire est d'ajouter un nouveau descendant de la classe <code>Shape</code> .  Pas besoin de changer la fonction <code>DrawAllShapes</code> .  Par cons√©quent, <code>DrawAllShapes</code> r√©pond au principe d'ouverture-proximit√©.  Son comportement peut √™tre √©tendu sans changer la fonction elle-m√™me. </p><br><p>  Dans le monde r√©el, la classe <code>Shape</code> contiendrait de nombreuses autres m√©thodes.  Et pourtant, ajouter une nouvelle forme √† l'application est toujours tr√®s simple, car il vous suffit de saisir un nouvel h√©ritier et de mettre en ≈ìuvre ces fonctions.  Pas besoin de parcourir toute l'application √† la recherche de lieux √† changer. </p><br><p>  Par cons√©quent, les programmes qui respectent le principe d'ouverture-proximit√© sont modifi√©s en ajoutant un nouveau code, et non en changeant le code existant; ils ne r√©percutent pas en cascade les changements caract√©ristiques des programmes qui ne correspondent pas √† ce principe. </p><br><h1>  Strat√©gie d'entr√©e ferm√©e </h1><br><p>  De toute √©vidence, aucun programme ne peut √™tre ferm√© √† 100%.  Par exemple, <code>DrawAllShapes</code> il de la fonction <code>DrawAllShapes</code> dans le listing 2 si nous d√©cidons que les cercles puis les carr√©s doivent √™tre dessin√©s en premier?  La fonction <code>DrawAllShapes</code> pas ferm√©e de ce type de modification.  En g√©n√©ral, peu importe √† quel point le module est ¬´ferm√©¬ª, il y a toujours un certain type de changement dont il n'est pas ferm√©. </p><br><p>  La fermeture ne pouvant √™tre compl√®te, elle doit √™tre introduite de mani√®re strat√©gique.  Autrement dit, le concepteur doit choisir les types de modifications √† partir desquelles le programme sera ferm√©.  Cela n√©cessite une certaine exp√©rience.  Un d√©veloppeur exp√©riment√© conna√Æt suffisamment les utilisateurs et l'industrie pour calculer la probabilit√© de divers changements.  Il s'assure ensuite que le principe d'ouverture-proximit√© est respect√© pour les changements les plus probables. </p><br><h2>  Utilisation de l'abstraction pour obtenir une proximit√© suppl√©mentaire </h2><br><p>  Comment fermer la fonction <code>DrawAllShapes</code> des modifications de l'ordre de dessin?  N'oubliez pas que la fermeture est bas√©e sur l'abstraction.  Par cons√©quent, pour fermer <code>DrawAllShapes</code> de la commande, nous avons besoin d'une sorte d'abstraction de commande.  Un cas particulier de commande, pr√©sent√© ci-dessus, est le dessin de figures d'un type devant des figures d'un autre type. </p><br><p>  La politique de commande implique qu'avec deux objets, vous pouvez d√©terminer lequel doit √™tre dessin√© en premier.  Par cons√©quent, nous pouvons d√©finir une m√©thode pour la classe <code>Shape</code> appel√©e <code>Precedes</code> , qui prend un autre objet <code>Shape</code> comme argument et renvoie une valeur bool√©enne <code>true</code> si l'objet <code>Shape</code> qui a re√ßu ce message doit √™tre tri√© avant l'objet <code>Shape</code> qui √©tait pass√© en argument. </p><br><p>  En C ++, cette fonction peut √™tre repr√©sent√©e comme une surcharge de l'op√©rateur "&lt;".  Le listing 3 montre la classe <code>Shape</code> avec des m√©thodes de tri. </p><br><p>  Maintenant que nous avons un moyen de d√©terminer l'ordre des objets de la classe <code>Shape</code> , nous pouvons les trier puis les dessiner.  Le listing 4 montre le code C ++ correspondant.  Il utilise les classes <code>Set</code> , <code>OrderedSet</code> et <code>Iterator</code> de la cat√©gorie <code>Components</code> d√©velopp√©e dans mon livre (Designing Object Oriented C ++ Applications using the Booch Method, Robert C. Martin, Prentice Hall, 1995). </p><br><p>  Nous avons donc impl√©ment√© l'ordre des objets de la classe <code>Shape</code> et les dessiner dans l'ordre appropri√©.  Mais nous n'avons toujours pas de mise en ≈ìuvre de l'abstraction de la commande.  De toute √©vidence, chaque objet <code>Shape</code> doit remplacer la m√©thode <code>Precedes</code> pour d√©terminer l'ordre.  Comment cela peut-il fonctionner?  Quel code doit √™tre √©crit dans <code>Circle::Precedes</code> pour que les cercles soient dessin√©s en carr√©s?  Faites attention √† la liste 5. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 3 //  Shape    . class Shape { public: virtual void Draw() const = 0; virtual bool Precedes(const Shape&amp;) const = 0; bool operator&lt;(const Shape&amp; s) {return Precedes(s);} };</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 4 // DrawAllShapes   void DrawAllShapes(Set&lt;Shape*&gt;&amp; list) { //    OrderedSet  . OrderedSet&lt;Shape*&gt; orderedList = list; orderedList.Sort(); for (Iterator&lt;Shape*&gt; i(orderedList); i; i++) (*i)-&gt;Draw(); }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 5 //    bool Circle::Precedes(const Shape&amp; s) const { if (dynamic_cast&lt;Square*&gt;(s)) return true; else return false; }</span></span></code> </pre> <br><p>  Il est clair que cette fonction ne r√©pond pas au principe d'ouverture-proximit√©.  Il n'y a aucun moyen de le fermer aux nouveaux descendants de la classe <code>Shape</code> .  Chaque fois qu'un nouveau descendant de la classe <code>Shape</code> appara√Æt, cette fonction doit √™tre modifi√©e. </p><br><h2>  Utilisation d'une approche bas√©e sur les donn√©es pour r√©aliser la fermeture </h2><br><p>  La proximit√© des h√©ritiers de la classe <code>Shape</code> peut √™tre obtenue en utilisant une approche tabulaire qui ne provoque pas de changements dans chaque classe h√©rit√©e.  Un exemple de cette approche est illustr√© dans le Listing 6. </p><br><p>  En utilisant cette approche, nous avons r√©ussi √† fermer la fonction <code>DrawAllShapes</code> des changements li√©s √† l'ordre et √† chaque descendant de la classe <code>Shape</code> - de l'introduction d'un nouveau descendant ou d'un changement dans la politique de classement des objets de la classe <code>Shape</code> fonction de leur type (par exemple, de sorte que les objets de la classe <code>Squares</code> doivent √™tre tir√© en premier). </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 6 //     #include &lt;typeinfo.h&gt; #include &lt;string.h&gt; enum {false, true}; typedef int bool; class Shape { public: virtual void Draw() const = 0; virtual bool Precedes(const Shape&amp;) const; bool operator&lt;(const Shape&amp; s) const {return Precedes(s);} private: static char* typeOrderTable[]; }; char* Shape::typeOrderTable[] = { "Circle", "Square", 0 }; //      . //   ,    //  . ,    , //      bool Shape::Precedes(const Shape&amp; s) const { const char* thisType = typeid(*this).name(); const char* argType = typeid(s).name(); bool done = false; int thisOrd = -1; int argOrd = -1; for (int i=0; !done; i++) { const char* tableEntry = typeOrderTable[i]; if (tableEntry != 0) { if (strcmp(tableEntry, thisType) == 0) thisOrd = i; if (strcmp(tableEntry, argType) == 0) argOrd = i; if ((argOrd &gt; 0) &amp;&amp; (thisOrd &gt; 0)) done = true; } else // table entry == 0 done = true; } return thisOrd &lt; argOrd; }</span></span></code> </pre> <br><p>  Le seul √©l√©ment qui n'est pas emp√™ch√© de changer l'ordre des formes de dessin est un tableau.  La table peut √™tre plac√©e dans un module s√©par√©, s√©par√© de tous les autres modules, et donc ses modifications n'affecteront pas les autres modules. </p><br><h2>  Fermeture suppl√©mentaire </h2><br><p>  Ce n'est pas la fin de l'histoire.  Nous avons ferm√© la hi√©rarchie de la classe <code>Shape</code> et de la fonction <code>DrawAllShapes</code> de la modification de la strat√©gie de <code>DrawAllShapes</code> fonction du type de formes.  Cependant, les descendants de la classe <code>Shape</code> ne sont pas ferm√©s aux r√®gles de classement qui ne sont pas associ√©es aux types de <code>Shape</code> .  Il semble que nous devons organiser le dessin des formes selon une structure de niveau sup√©rieur.  Une √©tude compl√®te de ces probl√®mes d√©passe le cadre de cet article;  cependant, un lecteur int√©ress√© pourrait penser comment r√©soudre ce probl√®me en utilisant la classe abstraite <code>OrderedObject</code> contenue dans la classe <code>OrderedShape</code> , qui h√©rite des <code>OrderedObject</code> <code>Shape</code> et <code>OrderedObject</code> . </p><br><h1>  Heuristique et conventions </h1><br><p>  Comme mentionn√© au d√©but de l'article, le principe d'ouverture-proximit√© est la motivation cl√© derri√®re de nombreuses heuristiques et conventions qui ont √©merg√© au cours des ann√©es de d√©veloppement du paradigme OOP.  Voici les plus importants. </p><br><h2>  Rendre toutes les variables membres priv√©es </h2><br><p>  Il s'agit de l'une des conventions les plus durables de l'OLP.  Les variables membres ne doivent √™tre connues que des m√©thodes de la classe dans laquelle elles sont d√©finies.  Les membres variables ne doivent √™tre connus d'aucune autre classe, y compris les classes d√©riv√©es.  Par cons√©quent, ils doivent √™tre d√©clar√©s avec un modificateur d'acc√®s <code>private</code> , non <code>public</code> ou <code>protected</code> . <br>  √Ä la lumi√®re du principe d'ouverture-proximit√©, la raison d'une telle convention est compr√©hensible.  Lorsque des variables de membre de classe changent, chaque fonction qui en d√©pend doit changer.  Autrement dit, la fonction n'est pas ferm√©e aux modifications de ces variables. </p><br><p>  En POO, nous nous attendons √† ce que les m√©thodes d'une classe ne soient pas ferm√©es aux modifications des variables qui sont membres de cette classe.  Cependant, nous nous attendons √† ce que toute autre classe, y compris les sous-classes, soit ferm√©e aux modifications de ces variables.  C'est ce qu'on appelle l'encapsulation. </p><br><p>  Mais que faire si vous avez une variable dont vous √™tes s√ªr qu'elle ne changera jamais?  Est-il judicieux de le rendre <code>private</code> ?  Par exemple, le Listing 7 montre la classe <code>Device</code> qui contient le <code>bool status</code> membre variable.  Il stocke l'√©tat de la derni√®re op√©ration.  Si l'op√©ration a r√©ussi, la valeur de la variable d' <code>status</code> sera <code>true</code> , sinon <code>false</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 7 //   class Device { public: bool status; };</span></span></code> </pre> <br><p>  Nous savons que le type ou la signification de cette variable ne changera jamais.  Alors pourquoi ne pas le rendre <code>public</code> et lui donner un acc√®s direct?  Si la variable ne change jamais vraiment, si tous les clients suivent les r√®gles et ne lisent qu'√† partir de cette variable, alors il n'y a rien de mal √† ce que la variable soit publique.  Cependant, r√©fl√©chissez √† ce qui se passera si l'un des clients saisit l'occasion d'√©crire dans cette variable et de modifier sa valeur. </p><br><p>  Du coup, ce client peut affecter le fonctionnement de tout autre client de la classe <code>Device</code> .  Cela signifie qu'il est impossible de fermer les clients de la classe <code>Device</code> des modifications apport√©es √† ce module incorrect.  C'est trop de risque. </p><br><p>  Par contre, supposons que nous ayons la classe <code>Time</code> , montr√©e dans l'extrait 8. Quel est le danger de la publicit√© des variables qui sont membres de cette classe?  Il est tr√®s peu probable qu'ils changent.  De plus, peu importe que les modules clients modifient ou non les valeurs de ces variables, car un changement dans ces variables est suppos√©.  Il est √©galement tr√®s peu probable que les classes h√©rit√©es puissent d√©pendre de la valeur d'une variable membre particuli√®re.  Y a-t-il donc un probl√®me? </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 8 class Time { public: int hours, minutes, seconds; Time&amp; operator-=(int seconds); Time&amp; operator+=(int seconds); bool operator&lt; (const Time&amp;); bool operator&gt; (const Time&amp;); bool operator==(const Time&amp;); bool operator!=(const Time&amp;); };</span></span></code> </pre> <br><p>  La seule plainte que je pourrais faire au code du Listing 8 est que le changement d'heure n'est pas atomique.  Autrement dit, le client peut modifier la valeur de la variable <code>minutes</code> sans modifier la valeur de la variable <code>hours</code> .  Cela peut entra√Æner un objet de la classe <code>Time</code> √† contenir des donn√©es incoh√©rentes.  Je pr√©f√©rerais introduire une seule fonction pour r√©gler l'heure, ce qui prendrait trois arguments, ce qui ferait de r√©gler l'heure une op√©ration atomique.  Mais c'est un argument faible. </p><br><p>  Il est facile de trouver d'autres conditions dans lesquelles la publicit√© de ces variables peut entra√Æner des probl√®mes.  En fin de compte, cependant, il n'y a aucune raison convaincante de les rendre <code>private</code> .  Je pense toujours que rendre ces variables publiques est un mauvais style, mais ce n'est peut-√™tre pas une mauvaise conception.  Je pense que c'est un mauvais style, car il ne co√ªte presque rien pour entrer dans les fonctions appropri√©es pour acc√©der √† ces membres, et cela vaut vraiment la peine de vous prot√©ger du petit risque associ√© √† la survenue √©ventuelle de probl√®mes de fermeture. </p><br><p>  Par cons√©quent, dans de tels cas rares, lorsque le principe d'ouverture-fermeture n'est pas viol√©, l'interdiction des variables <code>public</code> - et <code>protected</code> d√©pend davantage du style et non du contenu. </p><br><h2>  Pas de variables globales ... du tout! </h2><br><p>  L'argument contre les variables globales est le m√™me que l'argument contre les variables de membre public.  Aucun module qui d√©pend d'une variable globale ne peut √™tre ferm√© √† partir d'un module qui peut y √©crire.  Tout module qui utilise cette variable d'une mani√®re non pr√©vue par d'autres modules cassera ces modules.  Il est trop risqu√© d'avoir plusieurs modules, selon les caprices d'un seul module malveillant. <br>  D'un autre c√¥t√©, dans les cas o√π les variables globales ont un petit nombre de modules qui en d√©pendent ou ne peuvent pas √™tre utilis√©es de mani√®re incorrecte, elles ne nuisent pas.  Le concepteur doit √©valuer combien d'intimit√© est sacrifi√©e et d√©terminer si la commodit√© fournie par la variable globale en vaut la peine. </p><br><p>  L√† encore, des probl√®mes de style entrent en jeu.  Les alternatives √† l'utilisation de variables globales sont g√©n√©ralement peu co√ªteuses.  Dans de tels cas, l'utilisation d'une technique qui introduit, bien que faible, mais un risque de fermeture au lieu d'une technique qui √©limine compl√®tement un tel risque, est un signe de mauvais style.  Cependant, l'utilisation de variables globales est parfois tr√®s pratique.  Un exemple typique est les variables globales cout et cin.  Dans de tels cas, si le principe d'ouverture-proximit√© n'est pas viol√©, vous pouvez sacrifier le style pour des raisons de commodit√©. </p><br><h2>  RTTI est dangereux </h2><br><p>  Une autre interdiction courante est l'utilisation de <code>dynamic_cast</code> .  Tr√®s souvent, <code>dynamic_cast</code> ou toute autre forme de d√©termination du type d'ex√©cution (RTTI) est accus√© d'√™tre une technique extr√™mement dangereuse et doit donc √™tre √©vit√©e.  Dans le m√™me temps, ils donnent souvent un exemple de l'extrait 9, qui viole manifestement le principe d'ouverture et de proximit√©.  Cependant, le Listing 10 montre un exemple d'un programme similaire qui utilise <code>dynamic_cast</code> sans violer le principe d'ouverture-fermeture. </p><br><p>  La diff√©rence entre eux est que dans le premier cas, illustr√© dans l'extrait 9, le code doit √™tre chang√© √† chaque fois qu'un nouveau descendant de la classe <code>Shape</code> appara√Æt (sans mentionner que c'est une solution absolument ridicule).  Cependant, dans le listing 10, aucune modification n'est requise dans ce cas.  Par cons√©quent, le code du Listing 10 ne viole pas le principe d'ouverture-fermeture. <br>  Dans ce cas, la r√®gle de base est que RTTI peut √™tre utilis√© si le principe d'ouverture-fermeture n'est pas viol√©. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 9 //RTTI,   -. class Shape {}; class Square : public Shape { private: Point itsTopLeft; double itsSide; friend DrawSquare(Square*); }; class Circle : public Shape { private: Point itsCenter; double itsRadius; friend DrawCircle(Circle*); }; void DrawAllShapes(Set&lt;Shape*&gt;&amp; ss) { for (Iterator&lt;Shape*&gt;i(ss); i; i++) { Circle* c = dynamic_cast&lt;Circle*&gt;(*i); Square* s = dynamic_cast&lt;Square*&gt;(*i); if (c) DrawCircle(c); else if (s) DrawSquare(s); } }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 10 //RTTI,    -. class Shape { public: virtual void Draw() cont = 0; }; class Square : public Shape { // . }; void DrawSquaresOnly(Set&lt;Shape*&gt;&amp; ss) { for (Iterator&lt;Shape*&gt;i(ss); i; i++) { Square* s = dynamic_cast&lt;Square*&gt;(*i); if (s) s-&gt;Draw(); } }</span></span></code> </pre> <br><h1>  Conclusion </h1><br><p>  Je pourrais parler longtemps du principe d'ouverture-proximit√©.  √Ä bien des √©gards, ce principe est le plus important pour la programmation orient√©e objet.  Le respect de ce principe particulier offre les principaux avantages de la technologie orient√©e objet, √† savoir la r√©utilisation et le support. </p><br><p>    ,   -        -.      ,   ,   ,  ,    ,      . <br></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr472186/">https://habr.com/ru/post/fr472186/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr472174/index.html">Personnalit√© et son: Paul Voight - ¬´Sennheiser 30s¬ª, le p√®re du haut d√©bit, d'un crossover m√©canique et des lignes de transmission</a></li>
<li><a href="../fr472176/index.html">Mus√©e virtuel Pouchkine</a></li>
<li><a href="../fr472178/index.html">Holivar. Histoire de Runet. Partie 7. YouTube: com√©diens, couinements et Silicon Valley</a></li>
<li><a href="../fr472182/index.html">Annonce de l'aper√ßu 1 de .NET Core 3.1</a></li>
<li><a href="../fr472184/index.html">SSH √† distance: trucs et astuces</a></li>
<li><a href="../fr472188/index.html">Ce que vous devez savoir sur la v√©rification des ch√®ques sur l'App Store (re√ßu de l'App Store)</a></li>
<li><a href="../fr472190/index.html">Ex√©cutez des scripts PHP via php-fpm sans serveur Web. Ou votre client FastCGI (sous le capot)</a></li>
<li><a href="../fr472196/index.html">Du ¬´sucre¬ª fait maison pour un projet Android ou ¬´Comment ne pas le faire¬ª</a></li>
<li><a href="../fr472198/index.html">Localisation des messages push dans les applications mobiles</a></li>
<li><a href="../fr472200/index.html">Modernisation du cours d'informatique dans une √©cole russe sur une framboise: pas cher et gai</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>