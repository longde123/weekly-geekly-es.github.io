<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕣 🔺 🔯 Principe ouvert-fermé 👩‍🎨 🛒 👴🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Voici une traduction d'un article de Robert Martin du principe Open-Closed qu'il a publié en janvier 1996. L'article, pour le moins, n'...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Principe ouvert-fermé</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/472186/"><p>  Bonjour, Habr!  Voici une traduction d'un article de Robert Martin du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://web.archive.org/web/20060822033314/">principe Open-Closed</a> qu'il a publié en janvier 1996.  L'article, pour le moins, n'est pas le dernier.  Mais dans RuNet, les articles d'oncle Bob sur SOLID ne sont racontés que sous une forme tronquée, j'ai donc pensé qu'une traduction complète ne serait pas superflue. </p><br><p><img src="https://habrastorage.org/webt/yt/xn/-q/ytxn-qjuk7_t4wyyna-6nr4xvsc.png"></p><br><p>  J'ai décidé de commencer par la lettre O, car le principe d'ouverture-fermeture, en fait, est central.  Entre autres choses, il existe de nombreuses subtilités importantes qui méritent une attention particulière: </p><br><ul><li>  Aucun programme ne peut être "fermé" à 100%. </li><li>  La programmation orientée objet (POO) ne fonctionne pas avec des objets physiques du monde réel, mais avec des concepts - par exemple, le concept de "commande". <a name="habracut"></a></li></ul><br><p>  Ceci est le premier article de ma colonne <em>Notes d'ingénieur</em> pour <em>le rapport C ++</em> .  Les articles publiés dans cette colonne se concentreront sur l'utilisation de C ++ et OOP et aborderont les difficultés du développement logiciel.  Je vais essayer de rendre les matériaux pragmatiques et utiles pour les ingénieurs en exercice.  Pour la documentation de la conception orientée objet dans ces articles, j'utiliserai la notation de Buch. </p><br><p>  Il existe de nombreuses heuristiques associées à la programmation orientée objet.  Par exemple, «toutes les variables membres doivent être privées», ou «les variables globales doivent être évitées» ou «la détermination du type lors de l'exécution est dangereuse».  Quelle est la raison de ces heuristiques?  Pourquoi sont-ils vrais?  Sont-ils <em>toujours</em> vrais?  Cette colonne explore le principe de conception qui sous-tend ces heuristiques - le principe d'ouverture-fermeture. <br>  Ivar Jacobson a déclaré: «Tous les systèmes changent au cours du cycle de vie.  Cela doit être pris en compte lors de la conception d'un système pour lequel plusieurs versions sont attendues. »  Comment concevoir un système pour qu'il soit stable face au changement et que plus d'une version soit attendue?  Bertrand Meyer nous en a parlé en 1988, lorsque le désormais célèbre principe d'ouverture-proximité a été formulé: </p><br><p>  <strong>Les entités de programme (classes, modules, fonctions, etc.) doivent être ouvertes pour l'expansion et fermées pour les modifications.</strong> </p><br><p>  Si un changement dans le programme entraîne une cascade de changements dans les modules dépendants, alors le programme affiche des signes indésirables d'une «mauvaise» conception. </p><br><p>  Le programme devient fragile, inflexible, imprévisible et inutilisé.  Le principe d'ouverture-ouverture résout ces problèmes de manière très simple.  Il dit qu'il faut concevoir des modules qui ne <em>changent</em> jamais.  Lorsque les exigences changent, vous devez étendre le comportement de ces modules en ajoutant du nouveau code, plutôt qu'en changeant l'ancien code déjà fonctionnel. </p><br><h1>  La description </h1><br><p>  Les modules qui répondent au principe d'ouverture-proximité ont deux caractéristiques principales: </p><br><ol><li>  <strong>Ouvert pour expansion.</strong>  Cela signifie que le comportement du module peut être étendu.  Autrement dit, nous pouvons ajouter un nouveau comportement au module en fonction des exigences changeantes de l'application ou pour répondre aux besoins de nouvelles applications. </li><li> <strong>Fermé pour changement.</strong>  Le code source d'un tel module est intouchable.  Personne n'a le droit d'y apporter des modifications. </li></ol><br><p>  Il semble que ces deux signes ne s'emboîtent pas.  La manière standard d'étendre le comportement d'un module consiste à y apporter des modifications.  Un module qui ne peut pas être modifié est généralement considéré comme un module à comportement fixe.  Comment ces deux conditions opposées peuvent-elles être remplies? </p><br><h1>  La clé de la solution est l'abstraction. </h1><br><p>  En C ++, en utilisant les principes de la conception orientée objet, il est possible de créer des abstractions fixes qui peuvent représenter un ensemble illimité de comportements possibles. </p><br><p>  Les abstractions sont des classes de base abstraites et un ensemble illimité de comportements possibles est représenté par toutes les classes successives possibles.  Un module peut manipuler l'abstraction.  Un tel module est fermé pour modifications, car il dépend d'une abstraction fixe.  De plus, le comportement du module peut être étendu en créant de nouveaux descendants d'abstraction. </p><br><p> Le diagramme ci-dessous montre une option de conception simple qui ne répond pas au principe d'ouverture-proximité.  Les deux classes, <code>Client</code> et <code>Server</code> , ne sont pas abstraites.  Il n'y a aucune garantie que les fonctions qui sont membres de la classe <code>Server</code> sont virtuelles.  La classe <code>Client</code> utilise la classe <code>Server</code> .  Si nous voulons que l'objet de classe <code>Client</code> utilise un autre objet serveur, nous devons changer la classe <code>Client</code> pour faire référence à la nouvelle classe de serveur. </p><br><p><img src="https://habrastorage.org/webt/ee/0b/3d/ee0b3dy_mdhs48fzsk2cz9qm6tu.png" alt="image"><br>  <em>Client fermé</em> </p><br><p>  Et le diagramme suivant montre l'option de conception correspondante, qui répond au principe d'ouverture-proximité.  Dans ce cas, la classe <code>AbstractServer</code> est une classe abstraite, dont toutes les fonctions membres sont virtuelles.  La classe <code>Client</code> utilise l'abstraction.  Cependant, les objets de la classe <code>Client</code> utiliseront des objets de la classe successeur <code>Server</code> .  Si nous voulons que les objets de la classe <code>Client</code> utilisent une classe de serveur différente, nous introduirons un nouveau descendant de la classe <code>AbstractServer</code> .  La classe <code>Client</code> restera inchangée. </p><br><p><img src="https://habrastorage.org/webt/k6/ea/y_/k6eay_lv4u4q7rsu7z37pimqtme.png" alt="image"><br>  <em>Client ouvert</em> </p><br><h1>  <code>Shape</code> abstraite </h1><br><p>  Prenons une application qui devrait dessiner des cercles et des carrés dans une interface graphique standard.  Les cercles et les carrés doivent être dessinés dans un ordre spécifique.  Dans l'ordre correspondant, une liste de cercles et de carrés sera compilée, le programme devrait parcourir cette liste dans l'ordre et dessiner chaque cercle ou carré. </p><br><p>  En C, en utilisant des techniques de programmation procédurale qui ne respectent pas le principe d'ouverture-fermeture, nous pourrions résoudre ce problème comme le montre le listing 1. Ici, nous voyons de nombreuses structures de données avec le même premier élément.  Cet élément est un code de type qui identifie la structure de données comme un cercle ou un carré.  La fonction <code>DrawAllShapes</code> passe par un tableau de pointeurs vers ces structures de données, reconnaissant le code de type et appelant ensuite la fonction correspondante ( <code>DrawCircle</code> ou <code>DrawSquare</code> ). </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 //  /    enum ShapeType {circle, square} struct Shape { ShapeType itsType; }; struct Circle { ShapeType itsType; double itsRadius; Point itsCenter; }; struct Square { ShapeType itsType; double itsSide; Point itsTopLeft; }; // //     // void DrawSquare(struct Square*) void DrawCircle(struct Circle*); typedef struct Shape *ShapePointer; void DrawAllShapes(ShapePointer list[], int n) { int i; for (i=0; i&lt;n; i++) { struct Shape* s = list[i]; switch (s-&gt;itsType) { case square: DrawSquare((struct Square*)s); break; case circle: DrawCircle((struct Circle*)s); break; } } }</span></span></code> </pre> <br><p>  La fonction <code>DrawAllShapes</code> répond pas au principe d'ouverture-fermeture, car elle ne peut pas être «fermée» à partir de nouveaux types de formes.  Si je voulais étendre cette fonction avec la possibilité de dessiner des formes à partir d'une liste qui comprend des triangles, alors je devrais changer la fonction.  En fait, je dois changer la fonction pour chaque nouveau type de forme que je dois dessiner. </p><br><p>  Bien sûr, ce programme n'est qu'un exemple.  Dans la vie réelle, l'opérateur de <code>switch</code> de la fonction <code>DrawAllShapes</code> serait répété maintes et maintes fois dans diverses fonctions de l'application, et chacun ferait quelque chose de différent.  Ajouter de nouvelles formes à une telle application signifie trouver tous les endroits où de telles <code>switch</code> (ou chaînes <code>if/else</code> ) sont utilisées, et ajouter une nouvelle forme à chacune d'elles.  De plus, il est très peu probable que toutes les <code>switch</code> et les chaînes <code>if/else</code> soient aussi bien structurées que dans <code>DrawAllShapes</code> .  Il est beaucoup plus probable que les prédicats dans le <code>if</code> soient combinées avec des opérateurs logiques, ou que les blocs de <code>switch</code> soient combinés de manière à «simplifier» une place particulière dans le code.  Par conséquent, le problème de trouver et de comprendre tous les endroits où vous devez ajouter une nouvelle figure peut être non trivial. </p><br><p>  Dans le Listing 2, je montrerai du code qui illustre une solution carrée / circulaire qui répond au principe d'ouverture-fermeture.  Une classe <code>Shape</code> abstraite est introduite.  Cette classe abstraite contient une fonction de <code>Draw</code> virtuel pur.  Les classes <code>Circle</code> et <code>Square</code> sont des descendants de la classe <code>Shape</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 2 //  /  - class Shape { public: virtual void Draw() const = 0; }; class Square : public Shape { public: virtual void Draw() const; }; class Circle : public Shape { public: virtual void Draw() const; }; void DrawAllShapes(Set&lt;Shape*&gt;&amp; list) { for (Iterator&lt;Shape*&gt;i(list); i; i++) (*i)-&gt;Draw(); }</span></span></code> </pre> <br><p>  Notez que si nous voulons étendre le comportement de la fonction <code>DrawAllShapes</code> du Listing 2 pour dessiner un nouveau type de forme, tout ce que nous devons faire est d'ajouter un nouveau descendant de la classe <code>Shape</code> .  Pas besoin de changer la fonction <code>DrawAllShapes</code> .  Par conséquent, <code>DrawAllShapes</code> répond au principe d'ouverture-proximité.  Son comportement peut être étendu sans changer la fonction elle-même. </p><br><p>  Dans le monde réel, la classe <code>Shape</code> contiendrait de nombreuses autres méthodes.  Et pourtant, ajouter une nouvelle forme à l'application est toujours très simple, car il vous suffit de saisir un nouvel héritier et de mettre en œuvre ces fonctions.  Pas besoin de parcourir toute l'application à la recherche de lieux à changer. </p><br><p>  Par conséquent, les programmes qui respectent le principe d'ouverture-proximité sont modifiés en ajoutant un nouveau code, et non en changeant le code existant; ils ne répercutent pas en cascade les changements caractéristiques des programmes qui ne correspondent pas à ce principe. </p><br><h1>  Stratégie d'entrée fermée </h1><br><p>  De toute évidence, aucun programme ne peut être fermé à 100%.  Par exemple, <code>DrawAllShapes</code> il de la fonction <code>DrawAllShapes</code> dans le listing 2 si nous décidons que les cercles puis les carrés doivent être dessinés en premier?  La fonction <code>DrawAllShapes</code> pas fermée de ce type de modification.  En général, peu importe à quel point le module est «fermé», il y a toujours un certain type de changement dont il n'est pas fermé. </p><br><p>  La fermeture ne pouvant être complète, elle doit être introduite de manière stratégique.  Autrement dit, le concepteur doit choisir les types de modifications à partir desquelles le programme sera fermé.  Cela nécessite une certaine expérience.  Un développeur expérimenté connaît suffisamment les utilisateurs et l'industrie pour calculer la probabilité de divers changements.  Il s'assure ensuite que le principe d'ouverture-proximité est respecté pour les changements les plus probables. </p><br><h2>  Utilisation de l'abstraction pour obtenir une proximité supplémentaire </h2><br><p>  Comment fermer la fonction <code>DrawAllShapes</code> des modifications de l'ordre de dessin?  N'oubliez pas que la fermeture est basée sur l'abstraction.  Par conséquent, pour fermer <code>DrawAllShapes</code> de la commande, nous avons besoin d'une sorte d'abstraction de commande.  Un cas particulier de commande, présenté ci-dessus, est le dessin de figures d'un type devant des figures d'un autre type. </p><br><p>  La politique de commande implique qu'avec deux objets, vous pouvez déterminer lequel doit être dessiné en premier.  Par conséquent, nous pouvons définir une méthode pour la classe <code>Shape</code> appelée <code>Precedes</code> , qui prend un autre objet <code>Shape</code> comme argument et renvoie une valeur booléenne <code>true</code> si l'objet <code>Shape</code> qui a reçu ce message doit être trié avant l'objet <code>Shape</code> qui était passé en argument. </p><br><p>  En C ++, cette fonction peut être représentée comme une surcharge de l'opérateur "&lt;".  Le listing 3 montre la classe <code>Shape</code> avec des méthodes de tri. </p><br><p>  Maintenant que nous avons un moyen de déterminer l'ordre des objets de la classe <code>Shape</code> , nous pouvons les trier puis les dessiner.  Le listing 4 montre le code C ++ correspondant.  Il utilise les classes <code>Set</code> , <code>OrderedSet</code> et <code>Iterator</code> de la catégorie <code>Components</code> développée dans mon livre (Designing Object Oriented C ++ Applications using the Booch Method, Robert C. Martin, Prentice Hall, 1995). </p><br><p>  Nous avons donc implémenté l'ordre des objets de la classe <code>Shape</code> et les dessiner dans l'ordre approprié.  Mais nous n'avons toujours pas de mise en œuvre de l'abstraction de la commande.  De toute évidence, chaque objet <code>Shape</code> doit remplacer la méthode <code>Precedes</code> pour déterminer l'ordre.  Comment cela peut-il fonctionner?  Quel code doit être écrit dans <code>Circle::Precedes</code> pour que les cercles soient dessinés en carrés?  Faites attention à la liste 5. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 3 //  Shape    . class Shape { public: virtual void Draw() const = 0; virtual bool Precedes(const Shape&amp;) const = 0; bool operator&lt;(const Shape&amp; s) {return Precedes(s);} };</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 4 // DrawAllShapes   void DrawAllShapes(Set&lt;Shape*&gt;&amp; list) { //    OrderedSet  . OrderedSet&lt;Shape*&gt; orderedList = list; orderedList.Sort(); for (Iterator&lt;Shape*&gt; i(orderedList); i; i++) (*i)-&gt;Draw(); }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 5 //    bool Circle::Precedes(const Shape&amp; s) const { if (dynamic_cast&lt;Square*&gt;(s)) return true; else return false; }</span></span></code> </pre> <br><p>  Il est clair que cette fonction ne répond pas au principe d'ouverture-proximité.  Il n'y a aucun moyen de le fermer aux nouveaux descendants de la classe <code>Shape</code> .  Chaque fois qu'un nouveau descendant de la classe <code>Shape</code> apparaît, cette fonction doit être modifiée. </p><br><h2>  Utilisation d'une approche basée sur les données pour réaliser la fermeture </h2><br><p>  La proximité des héritiers de la classe <code>Shape</code> peut être obtenue en utilisant une approche tabulaire qui ne provoque pas de changements dans chaque classe héritée.  Un exemple de cette approche est illustré dans le Listing 6. </p><br><p>  En utilisant cette approche, nous avons réussi à fermer la fonction <code>DrawAllShapes</code> des changements liés à l'ordre et à chaque descendant de la classe <code>Shape</code> - de l'introduction d'un nouveau descendant ou d'un changement dans la politique de classement des objets de la classe <code>Shape</code> fonction de leur type (par exemple, de sorte que les objets de la classe <code>Squares</code> doivent être tiré en premier). </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 6 //     #include &lt;typeinfo.h&gt; #include &lt;string.h&gt; enum {false, true}; typedef int bool; class Shape { public: virtual void Draw() const = 0; virtual bool Precedes(const Shape&amp;) const; bool operator&lt;(const Shape&amp; s) const {return Precedes(s);} private: static char* typeOrderTable[]; }; char* Shape::typeOrderTable[] = { "Circle", "Square", 0 }; //      . //   ,    //  . ,    , //      bool Shape::Precedes(const Shape&amp; s) const { const char* thisType = typeid(*this).name(); const char* argType = typeid(s).name(); bool done = false; int thisOrd = -1; int argOrd = -1; for (int i=0; !done; i++) { const char* tableEntry = typeOrderTable[i]; if (tableEntry != 0) { if (strcmp(tableEntry, thisType) == 0) thisOrd = i; if (strcmp(tableEntry, argType) == 0) argOrd = i; if ((argOrd &gt; 0) &amp;&amp; (thisOrd &gt; 0)) done = true; } else // table entry == 0 done = true; } return thisOrd &lt; argOrd; }</span></span></code> </pre> <br><p>  Le seul élément qui n'est pas empêché de changer l'ordre des formes de dessin est un tableau.  La table peut être placée dans un module séparé, séparé de tous les autres modules, et donc ses modifications n'affecteront pas les autres modules. </p><br><h2>  Fermeture supplémentaire </h2><br><p>  Ce n'est pas la fin de l'histoire.  Nous avons fermé la hiérarchie de la classe <code>Shape</code> et de la fonction <code>DrawAllShapes</code> de la modification de la stratégie de <code>DrawAllShapes</code> fonction du type de formes.  Cependant, les descendants de la classe <code>Shape</code> ne sont pas fermés aux règles de classement qui ne sont pas associées aux types de <code>Shape</code> .  Il semble que nous devons organiser le dessin des formes selon une structure de niveau supérieur.  Une étude complète de ces problèmes dépasse le cadre de cet article;  cependant, un lecteur intéressé pourrait penser comment résoudre ce problème en utilisant la classe abstraite <code>OrderedObject</code> contenue dans la classe <code>OrderedShape</code> , qui hérite des <code>OrderedObject</code> <code>Shape</code> et <code>OrderedObject</code> . </p><br><h1>  Heuristique et conventions </h1><br><p>  Comme mentionné au début de l'article, le principe d'ouverture-proximité est la motivation clé derrière de nombreuses heuristiques et conventions qui ont émergé au cours des années de développement du paradigme OOP.  Voici les plus importants. </p><br><h2>  Rendre toutes les variables membres privées </h2><br><p>  Il s'agit de l'une des conventions les plus durables de l'OLP.  Les variables membres ne doivent être connues que des méthodes de la classe dans laquelle elles sont définies.  Les membres variables ne doivent être connus d'aucune autre classe, y compris les classes dérivées.  Par conséquent, ils doivent être déclarés avec un modificateur d'accès <code>private</code> , non <code>public</code> ou <code>protected</code> . <br>  À la lumière du principe d'ouverture-proximité, la raison d'une telle convention est compréhensible.  Lorsque des variables de membre de classe changent, chaque fonction qui en dépend doit changer.  Autrement dit, la fonction n'est pas fermée aux modifications de ces variables. </p><br><p>  En POO, nous nous attendons à ce que les méthodes d'une classe ne soient pas fermées aux modifications des variables qui sont membres de cette classe.  Cependant, nous nous attendons à ce que toute autre classe, y compris les sous-classes, soit fermée aux modifications de ces variables.  C'est ce qu'on appelle l'encapsulation. </p><br><p>  Mais que faire si vous avez une variable dont vous êtes sûr qu'elle ne changera jamais?  Est-il judicieux de le rendre <code>private</code> ?  Par exemple, le Listing 7 montre la classe <code>Device</code> qui contient le <code>bool status</code> membre variable.  Il stocke l'état de la dernière opération.  Si l'opération a réussi, la valeur de la variable d' <code>status</code> sera <code>true</code> , sinon <code>false</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 7 //   class Device { public: bool status; };</span></span></code> </pre> <br><p>  Nous savons que le type ou la signification de cette variable ne changera jamais.  Alors pourquoi ne pas le rendre <code>public</code> et lui donner un accès direct?  Si la variable ne change jamais vraiment, si tous les clients suivent les règles et ne lisent qu'à partir de cette variable, alors il n'y a rien de mal à ce que la variable soit publique.  Cependant, réfléchissez à ce qui se passera si l'un des clients saisit l'occasion d'écrire dans cette variable et de modifier sa valeur. </p><br><p>  Du coup, ce client peut affecter le fonctionnement de tout autre client de la classe <code>Device</code> .  Cela signifie qu'il est impossible de fermer les clients de la classe <code>Device</code> des modifications apportées à ce module incorrect.  C'est trop de risque. </p><br><p>  Par contre, supposons que nous ayons la classe <code>Time</code> , montrée dans l'extrait 8. Quel est le danger de la publicité des variables qui sont membres de cette classe?  Il est très peu probable qu'ils changent.  De plus, peu importe que les modules clients modifient ou non les valeurs de ces variables, car un changement dans ces variables est supposé.  Il est également très peu probable que les classes héritées puissent dépendre de la valeur d'une variable membre particulière.  Y a-t-il donc un problème? </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 8 class Time { public: int hours, minutes, seconds; Time&amp; operator-=(int seconds); Time&amp; operator+=(int seconds); bool operator&lt; (const Time&amp;); bool operator&gt; (const Time&amp;); bool operator==(const Time&amp;); bool operator!=(const Time&amp;); };</span></span></code> </pre> <br><p>  La seule plainte que je pourrais faire au code du Listing 8 est que le changement d'heure n'est pas atomique.  Autrement dit, le client peut modifier la valeur de la variable <code>minutes</code> sans modifier la valeur de la variable <code>hours</code> .  Cela peut entraîner un objet de la classe <code>Time</code> à contenir des données incohérentes.  Je préférerais introduire une seule fonction pour régler l'heure, ce qui prendrait trois arguments, ce qui ferait de régler l'heure une opération atomique.  Mais c'est un argument faible. </p><br><p>  Il est facile de trouver d'autres conditions dans lesquelles la publicité de ces variables peut entraîner des problèmes.  En fin de compte, cependant, il n'y a aucune raison convaincante de les rendre <code>private</code> .  Je pense toujours que rendre ces variables publiques est un mauvais style, mais ce n'est peut-être pas une mauvaise conception.  Je pense que c'est un mauvais style, car il ne coûte presque rien pour entrer dans les fonctions appropriées pour accéder à ces membres, et cela vaut vraiment la peine de vous protéger du petit risque associé à la survenue éventuelle de problèmes de fermeture. </p><br><p>  Par conséquent, dans de tels cas rares, lorsque le principe d'ouverture-fermeture n'est pas violé, l'interdiction des variables <code>public</code> - et <code>protected</code> dépend davantage du style et non du contenu. </p><br><h2>  Pas de variables globales ... du tout! </h2><br><p>  L'argument contre les variables globales est le même que l'argument contre les variables de membre public.  Aucun module qui dépend d'une variable globale ne peut être fermé à partir d'un module qui peut y écrire.  Tout module qui utilise cette variable d'une manière non prévue par d'autres modules cassera ces modules.  Il est trop risqué d'avoir plusieurs modules, selon les caprices d'un seul module malveillant. <br>  D'un autre côté, dans les cas où les variables globales ont un petit nombre de modules qui en dépendent ou ne peuvent pas être utilisées de manière incorrecte, elles ne nuisent pas.  Le concepteur doit évaluer combien d'intimité est sacrifiée et déterminer si la commodité fournie par la variable globale en vaut la peine. </p><br><p>  Là encore, des problèmes de style entrent en jeu.  Les alternatives à l'utilisation de variables globales sont généralement peu coûteuses.  Dans de tels cas, l'utilisation d'une technique qui introduit, bien que faible, mais un risque de fermeture au lieu d'une technique qui élimine complètement un tel risque, est un signe de mauvais style.  Cependant, l'utilisation de variables globales est parfois très pratique.  Un exemple typique est les variables globales cout et cin.  Dans de tels cas, si le principe d'ouverture-proximité n'est pas violé, vous pouvez sacrifier le style pour des raisons de commodité. </p><br><h2>  RTTI est dangereux </h2><br><p>  Une autre interdiction courante est l'utilisation de <code>dynamic_cast</code> .  Très souvent, <code>dynamic_cast</code> ou toute autre forme de détermination du type d'exécution (RTTI) est accusé d'être une technique extrêmement dangereuse et doit donc être évitée.  Dans le même temps, ils donnent souvent un exemple de l'extrait 9, qui viole manifestement le principe d'ouverture et de proximité.  Cependant, le Listing 10 montre un exemple d'un programme similaire qui utilise <code>dynamic_cast</code> sans violer le principe d'ouverture-fermeture. </p><br><p>  La différence entre eux est que dans le premier cas, illustré dans l'extrait 9, le code doit être changé à chaque fois qu'un nouveau descendant de la classe <code>Shape</code> apparaît (sans mentionner que c'est une solution absolument ridicule).  Cependant, dans le listing 10, aucune modification n'est requise dans ce cas.  Par conséquent, le code du Listing 10 ne viole pas le principe d'ouverture-fermeture. <br>  Dans ce cas, la règle de base est que RTTI peut être utilisé si le principe d'ouverture-fermeture n'est pas violé. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 9 //RTTI,   -. class Shape {}; class Square : public Shape { private: Point itsTopLeft; double itsSide; friend DrawSquare(Square*); }; class Circle : public Shape { private: Point itsCenter; double itsRadius; friend DrawCircle(Circle*); }; void DrawAllShapes(Set&lt;Shape*&gt;&amp; ss) { for (Iterator&lt;Shape*&gt;i(ss); i; i++) { Circle* c = dynamic_cast&lt;Circle*&gt;(*i); Square* s = dynamic_cast&lt;Square*&gt;(*i); if (c) DrawCircle(c); else if (s) DrawSquare(s); } }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 10 //RTTI,    -. class Shape { public: virtual void Draw() cont = 0; }; class Square : public Shape { // . }; void DrawSquaresOnly(Set&lt;Shape*&gt;&amp; ss) { for (Iterator&lt;Shape*&gt;i(ss); i; i++) { Square* s = dynamic_cast&lt;Square*&gt;(*i); if (s) s-&gt;Draw(); } }</span></span></code> </pre> <br><h1>  Conclusion </h1><br><p>  Je pourrais parler longtemps du principe d'ouverture-proximité.  À bien des égards, ce principe est le plus important pour la programmation orientée objet.  Le respect de ce principe particulier offre les principaux avantages de la technologie orientée objet, à savoir la réutilisation et le support. </p><br><p>    ,   -        -.      ,   ,   ,  ,    ,      . <br></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr472186/">https://habr.com/ru/post/fr472186/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr472174/index.html">Personnalité et son: Paul Voight - «Sennheiser 30s», le père du haut débit, d'un crossover mécanique et des lignes de transmission</a></li>
<li><a href="../fr472176/index.html">Musée virtuel Pouchkine</a></li>
<li><a href="../fr472178/index.html">Holivar. Histoire de Runet. Partie 7. YouTube: comédiens, couinements et Silicon Valley</a></li>
<li><a href="../fr472182/index.html">Annonce de l'aperçu 1 de .NET Core 3.1</a></li>
<li><a href="../fr472184/index.html">SSH à distance: trucs et astuces</a></li>
<li><a href="../fr472188/index.html">Ce que vous devez savoir sur la vérification des chèques sur l'App Store (reçu de l'App Store)</a></li>
<li><a href="../fr472190/index.html">Exécutez des scripts PHP via php-fpm sans serveur Web. Ou votre client FastCGI (sous le capot)</a></li>
<li><a href="../fr472196/index.html">Du «sucre» fait maison pour un projet Android ou «Comment ne pas le faire»</a></li>
<li><a href="../fr472198/index.html">Localisation des messages push dans les applications mobiles</a></li>
<li><a href="../fr472200/index.html">Modernisation du cours d'informatique dans une école russe sur une framboise: pas cher et gai</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>