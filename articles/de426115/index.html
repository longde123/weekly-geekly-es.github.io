<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👄 💐 🐜 Die Praxis der Verwendung des Schauspielermodells in der Backend-Plattform von Quake Champions 🚣🏼 🐴 🖕🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich lade weiterhin Berichte mit Pixonic DevGAMM Talks hoch, unserem September-Treffen für Entwickler hoch geladener Systeme. Sie haben viele Erfahrung...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die Praxis der Verwendung des Schauspielermodells in der Backend-Plattform von Quake Champions</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/426115/">  Ich lade weiterhin Berichte mit Pixonic DevGAMM Talks hoch, unserem September-Treffen für Entwickler hoch geladener Systeme.  Sie haben viele Erfahrungen und Fälle geteilt, und heute veröffentliche ich eine Abschrift der Rede des Backend-Entwicklers von Sabre Interactive Roman Rogozin.  Er sprach über die Praxis der Anwendung des Akteurmodells am Beispiel der Verwaltung von Spielern und deren Status (andere Berichte finden Sie am Ende des Artikels, die Liste wird ergänzt). <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/dDYQpvtEEfo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br>  Unser Team arbeitet an einem Backend für das Spiel Quake Champions, und ich werde darüber sprechen, was das Schauspielermodell ist und wie es im Projekt verwendet wird. <br><br>  Ein bisschen über Technologie-Stack.  Wir schreiben Code in C #, alle Technologien sind daran gebunden.  Ich möchte darauf hinweisen, dass es einige spezifische Dinge geben wird, die ich am Beispiel dieser Sprache zeigen werde, aber die allgemeinen Prinzipien bleiben unverändert. <br><br><img src="https://habrastorage.org/webt/h-/st/yl/h-styljhwr1ci0hqzjnibcbgx2q.png"><br><br>  Derzeit hosten wir unsere Dienste in Azure.  Es gibt einige sehr interessante Grundelemente, die wir nicht aufgeben möchten, wie z. B. Table Storage und Cosmos DB (aber wir versuchen, sie für das plattformübergreifende Projekt nicht zu eng zu machen). <br><br>  Jetzt möchte ich ein wenig darüber erzählen, was ein Schauspielermodell ist.  Und zunächst erschien es grundsätzlich vor mehr als 40 Jahren. <br><br><img src="https://habrastorage.org/webt/ps/wh/o5/pswho5g6goopdvjqgdzbbrudros.png"><br><br>  Ein Akteur ist ein Modell für paralleles Rechnen, das angibt, dass es ein bestimmtes isoliertes Objekt gibt, das über einen eigenen internen Status und exklusiven Zugriff zum Ändern dieses Status verfügt.  Ein Akteur kann Nachrichten lesen und darüber hinaus nacheinander eine Art Geschäftslogik ausführen, wenn er seinen internen Status ändern und Nachrichten an externe Dienste, einschließlich anderer Akteure, senden möchte.  Und er weiß, wie man andere Schauspieler erschafft. <br><br>  Akteure kommunizieren asynchron miteinander, sodass Sie hoch ausgelastete verteilte Cloud-Systeme erstellen können.  In dieser Hinsicht ist das Akteurmodell in letzter Zeit weit verbreitet. <br><br>  Zusammenfassend stellen wir uns vor, wir haben eine Cloud, in der es eine Art Servercluster gibt, und unsere Akteure drehen sich um diesen Cluster. <br><br><img src="https://habrastorage.org/webt/k7/le/o8/k7leo8f4_bksrkrxepnw7vlp_xk.png"><br><br>  Akteure sind voneinander isoliert, kommunizieren über asynchrone Aufrufe und in sich selbst sind die Akteure threadsicher. <br><br>  Wie es aussehen könnte.  Angenommen, wir haben mehrere Benutzer (keine sehr große Last), und irgendwann verstehen wir, dass es einen Zustrom von Spielern gibt, und wir müssen dringend eine Hochskalierung durchführen. <br><br><img src="https://habrastorage.org/webt/m5/v7/8k/m5v78k2trbiawxv2obnxtcpbhd0.png"><br><br>  Wir können unserer Cloud Server hinzufügen und mithilfe des Akteurmodells einzelne Benutzer pushen - weisen Sie jedem einzelnen Akteur zu und weisen Sie diesem Akteur in der Cloud Speicherplatz für Speicher und Prozessorzeit zu. <br><br>  Somit spielt der Akteur zum einen die Rolle eines Caches, und zum anderen handelt es sich um einen „intelligenten Cache“, der einige Nachrichten verarbeiten und Geschäftslogik ausführen kann.  Auch hier gilt: Wenn Sie eine Verkleinerung vornehmen müssen (z. B. die Spieler sind gegangen), ist es auch kein Problem, diese Akteure aus dem System zu entfernen. <br><br>  Wir im Backend verwenden nicht das klassische Schauspielermodell, sondern basieren auf dem Orleans-Framework.  Was ist der Unterschied? Ich werde versuchen, es Ihnen jetzt zu sagen. <br><br><img src="https://habrastorage.org/webt/bg/bi/iu/bgbiiudonlat560_soge7gyv0-a.png"><br><br>  Zunächst führt Orleans das Konzept des virtuellen Schauspielers oder, wie es auch genannt wird, des Getreides ein.  Im Gegensatz zum klassischen Darstellermodell, bei dem ein Dienst dafür verantwortlich ist, diesen Darsteller zu erstellen und auf einigen Servern zu platzieren, übernimmt Orleans die Arbeit.  Das heißt,  Wenn ein bestimmter Benutzerdienst eine bestimmte Note anfordert, versteht Orleans, welcher der Server jetzt weniger ausgelastet ist, platziert den Akteur dort und gibt das Ergebnis an den Benutzerdienst zurück. <br><br>  Ein Beispiel.  Für Körner ist es wichtig, nur den Typ des Akteurs zu kennen, z. B. Benutzerstatus und ID.  Angenommen, Benutzer-ID 777, wir erhalten die Körnung dieses Benutzers und denken nicht darüber nach, wie diese Körnung gespeichert werden soll. Wir steuern nicht den Lebenszyklus der Körnung.  Orleans jedoch speichert die Wege aller Schauspieler auf sehr listige Weise in sich.  Wenn es keinen Schauspieler gibt, erstellt er sie, wenn der Schauspieler lebt, gibt er sie zurück, und für Benutzerdienste sieht alles so aus, dass alle Schauspieler immer am Leben sind. <br><br><img src="https://habrastorage.org/webt/ud/5s/id/ud5sidxydmqbafgbhfjzcowwjgs.png"><br><br>  Welche Vorteile bringt uns das?  Erstens transparenter Lastausgleich aufgrund der Tatsache, dass der Programmierer den Standort des Akteurs nicht selbst verwalten muss.  Er sagt einfach Orleans, das auf mehreren Servern bereitgestellt wird: Geben Sie mir einen solchen Schauspieler von Ihren Servern. <br><br><img src="https://habrastorage.org/webt/r8/wn/dp/r8wndpcexsiwuw9qn_x5znxwkhc.png"><br><br>  Falls gewünscht, können Sie eine Verkleinerung vornehmen, wenn die Belastung des Prozessors und des Speichers gering ist.  Auch hier können Sie die Hochskalierung in die entgegengesetzte Richtung durchführen.  Aber der Dienst weiß nichts darüber, er bittet um die Körnung, und Orleans gibt ihm diese Körnung.  So übernimmt Orleans die infrastrukturelle Versorgung für den Lebenszyklus der Körner. <br><br>  Zweitens behandelt Orleans Serverabstürze. <br><br><img src="https://habrastorage.org/webt/u8/cl/2c/u8cl2cjbxptjng5vy6sqg0f3pkw.png"><br><br>  Dies bedeutet, dass im klassischen Modell der Programmierer für die eigenständige Behandlung eines solchen Falls verantwortlich ist (er hat den Akteur auf einem Server platziert und dieser Server ist abgestürzt, und wir müssen diesen Akteur selbst auf einem der Live-Server erhöhen), was mehr Mechanik hinzufügt oder komplexe Netzwerkarbeit für einen Programmierer, dann sieht es in Orleans transparent aus.  Wir fordern eine Körnung an, Orleans sieht, dass sie nicht verfügbar ist, holt sie ab (platziert sie auf einigen Live-Servern) und gibt sie an den Dienst zurück. <br><br>  Schauen wir uns zur Verdeutlichung ein kleines Beispiel an, wie ein Benutzer einen Teil seines Status liest. <br><br><img src="https://habrastorage.org/webt/je/_4/iw/je_4iwdh8tk1q5wtveptzzhf33e.png"><br><br>  Ein Staat kann sein wirtschaftlicher Zustand sein, in dem die Rüstung, Waffen, Währung oder Champions dieses Benutzers aufbewahrt werden.  Um diese Zustände zu erhalten, ruft er den PublicUserService auf, der sich für den Zustand an Orleans wendet.  Was passiert: Orleans sieht, dass es noch keinen solchen Akteur (d. H. Getreide) gibt, er erstellt es auf einem freien Server und das Getreide liest seinen Zustand aus einem Persistenzspeicher. <br><br>  Wenn Sie also das nächste Mal Ressourcen aus der Cloud lesen, wie auf der Folie gezeigt, werden alle Lesevorgänge aus dem Cache-Cache stammen.  Für den Fall, dass der Benutzer das Spiel verlässt, werden keine Ressourcen gelesen, sodass Orleans versteht, dass das Getreide von niemandem mehr verwendet wird und deaktiviert werden kann. <br><br>  Wenn wir mehrere Clients haben (Spielclient, Spielserver), können sie Benutzerstatus anfordern, und einer von ihnen erhöht diese Körnung.  Genauer gesagt, Orleans wird es abholen, und dann werden alle Anrufe, wie wir bereits wissen, nacheinander threadsicher ausgeführt.  Zuerst erhält der Client den Status und dann den Spieleserver. <br><br><img src="https://habrastorage.org/webt/ih/og/2i/ihog2i9tqxlitxio9djssspgavy.png"><br><br>  Der gleiche Ablauf beim Update.  Wenn ein Client einen Status aktualisieren möchte, überträgt er diese Verantwortung auf das Korn, d. H.  wird ihm sagen: "Gib diesem Benutzer 10 Gold", und das Korn steigt, es verarbeitet diesen Zustand mit einer Art Geschäftslogik innerhalb des Korns.  Und dann kommt die Aktualisierung des Cache-Cache und, falls gewünscht, die Persistenz in der Persistenz. <br><br><img src="https://habrastorage.org/webt/ym/2i/3v/ym2i3viyvuzcowtmkdqwat8mb2s.png"><br><br>  Warum ist hier Ausdauer erforderlich?  Dies ist ein separates Thema und es liegt in der Tatsache, dass es für uns manchmal nicht besonders wichtig ist, dass das Getreide seine Zustände ständig in der Persistenz beibehält.  Wenn dies der Zustand des Online-Spielers ist, sind wir bereit, ihn aus Gründen der Produktivität zu verlieren. Wenn es um die Wirtschaft geht, müssen wir sicher sein, dass seine Zustände erhalten bleiben. <br><br>  Der einfachste Fall: Schreiben Sie dieses Update für jeden Aufruf des Sicherungsstatus in Persistence.  Wenn der Grayn plötzlich unerwartet abfällt, führt das nächste Anheben des Grayn auf einigen anderen Servern zu einer Cache-Aktualisierung mit den aktuellen Daten. <br><br>  Ein kleines Beispiel, wie es aussieht. <br><br><img src="https://habrastorage.org/webt/gi/vp/bj/givpbj4gdy2lyshx4hblowzqncw.png"><br><br>  Wie ich bereits sagte, besteht ein Korn aus einem Typ und einem Schlüssel (in diesem Fall ist der Typ IPlayerState, der Schlüssel ist IGrainWithGuidKey, was bedeutet, dass es Guid ist).  Und wir haben eine Schnittstelle, die wir implementieren, d. H.  GetStates gibt eine Liste von Status und ApplyState zurück, für die ein Status gilt.  Orleans-Methoden geben Task zurück.  Was dies bedeutet: Aufgabe ist ein Versprechen, das uns sagt, dass sich das Versprechen in einem aufgelösten Zustand befindet, wenn der Staat zurückkehrt.  Wir haben auch einige PlayerState, die wir mit GrainFactory bekommen.  Das heißt,  Hier erhalten wir einen Link und wissen nichts über den physischen Standort dieses Getreides.  Wenn Sie GetStates aufrufen, erhöht Orleans unser Korn, liest den Status aus dem Persistenzspeicher in seinen Speicher und wenn ApplyState einen neuen Status anwendet, aktualisiert es diesen Status sowohl im Speicher als auch in der Persistenz. <br><br>  Ich möchte ein etwas komplexeres Beispiel für die High-Level-Architektur unseres UserStates-Dienstes ausarbeiten. <br><br><img src="https://habrastorage.org/webt/4d/1s/r5/4d1sr5q9chg2qkm1-nj-qeldqtw.png"><br><br>  Wir haben eine Art Spieleclient, der seine Zustände über OfferSevice erhält.  Wir haben einen GameConfigurationService, der für das Wirtschaftsmodell einer Benutzergruppe verantwortlich ist, in diesem Fall unseres Benutzers.  Und wir haben einen Betreiber, der dieses Wirtschaftsmodell ändert.  Dementsprechend fordert der Benutzer ein OfferSevice an, seinen Status zu erhalten.  Und OfferSevice greift bereits auf den UserOrleans-Dienst zu, der aus diesen Körnern besteht. Es erhöht diesen Status des Benutzers in seinem Speicher, führt möglicherweise eine Art Geschäftslogik aus und gibt die Daten über OfferService an den Benutzer zurück. <br><br>  Im Allgemeinen möchte ich darauf hinweisen, dass Orleans aufgrund der Tatsache, dass Körner unabhängig voneinander sind, für seine hohe Parallelitätsfähigkeit gut ist.  Andererseits müssen wir innerhalb der Körnung keine Synchronisationsprimitive verwenden, da wir wissen, dass jeder Aufruf dieser Körnung irgendwie konsistent ist. <br><br>  Hier möchte ich einige der Fallstricke dieses Modells erkennen. <br><br><img src="https://habrastorage.org/webt/bi/nr/vt/binrvttwhrlmxqonc74qchyjzdc.png"><br><br>  Das erste ist zu viel Körnung.  Da alle Aufrufe in der Greine nacheinander threadsicher sind und wir eine fettige Logik auf der Greine haben, müssen wir zu lange warten.  Wiederum wird zu viel Speicher für ein solches Korn zugewiesen.  Es gibt keinen genauen Algorithmus für die Größe des Korns, da ein zu kleines Korn auch schlecht ist.  Hier ist es eher notwendig, vom optimalen Wert auszugehen.  Ich werde nicht genau sagen, welches, es liegt am Programmierer zu entscheiden. <br><br>  Das zweite Problem ist nicht so offensichtlich - dies ist die sogenannte Kettenreaktion.  Wenn ein Benutzer einige Körner erhöht, kann er implizit andere Körner im System erhöhen.  So geschieht dies: Der Benutzer erhält seinen Status, der Benutzer hat Freunde und er erhält den Status seiner Freunde.  Somit behält das gesamte System alle seine Körner im Speicher, und wenn wir 1000 Benutzer haben und jeder 100 Freunde hat, können 100.000 Körner einfach so aktiv sein.  Dieser Fall muss auch vermieden werden - irgendwie speichern Sie die Zustände von Freunden in einer Art gemeinsamem Speicher. <br><br><img src="https://habrastorage.org/webt/iu/ep/0z/iuep0z7a5vgw_qak3i-j8hx6hkc.png"><br><br>  Nun, welche Technologien gibt es, um das Akteurmodell zu implementieren?  Das vielleicht berühmteste ist Akka, das mit Java zu uns kam.  Es gibt eine Abzweigung namens Akka.NET für .NET.  Es gibt Orleans, das Open Source ist und in anderen Sprachen als Implementierung verfügbar ist.  Es gibt Azure-Grundelemente wie Service Fabric Actor - es gibt viele Technologien. <br><br><h2>  Fragen aus dem Publikum </h2><br>  <b>- Wie lösen Sie klassische Probleme wie CICD, aktualisieren diese Akteure, verwenden Sie Docker und wird es überhaupt benötigt?</b> <br><br>  - Wir verwenden Docker noch nicht.  Im Allgemeinen ist DevOps an der Bereitstellung beteiligt und stellt unsere Dienste im Azure-Clouddienst bereit. <br><br>  <b>- Kontinuierliche Aktualisierung ohne Ausfallzeiten, wie geschieht dies?</b>  <b>Orleans selbst entscheidet, auf welchen Server der Server geht, auf welchen Server die Anfrage geht und wie dieser Dienst aktualisiert wird.</b>  <b>Das heißt,</b>  <b>Eine neue Geschäftslogik ist erschienen, ein Update desselben Akteurs ist erschienen - wie werden diese Updates gerollt?</b> <br><br>  - Wenn wir über die Aktualisierung des gesamten Dienstes sprechen und wenn wir eine Geschäftslogik des Schauspielers aktualisiert haben, können wir einen neuen Orleans-Dienst dafür einführen.  Normalerweise wird dies mit unseren Grundelementen gelöst, die als Topologie bezeichnet werden.  Wir haben einen Dienst in New Orleans eingeführt, der vorerst leer und ohne Schauspieler ist. Zeigen Sie den alten Dienst an und ersetzen Sie ihn durch einen neuen.  Es werden überhaupt keine Akteure im System vorhanden sein, aber bei der nächsten Benutzeranforderung werden diese Akteure bereits erstellt.  Am Anfang wird es wahrscheinlich eine Art Spitze geben.  In solchen Fällen findet das Update normalerweise am Morgen statt, da wir am Morgen die geringste Anzahl von Spielern haben. <br><br>  <b>"Wie versteht Orleans, dass der Server abgestürzt ist?"</b>  <b>Sie sagten, dass er die Schauspieler schnell auf einen anderen Server wirft ...</b> <br><br>  - Er hat einen Pingator, der regelmäßig versteht, welche der Server am Leben sind. <br><br>  <b>- Pingt er einen Schauspieler oder Server speziell an?</b> <br><br>  - Insbesondere der Server. <br><br>  <b>- Eine solche Frage: Ein Fehler ist innerhalb des Schauspielers aufgetreten, Sie sagen, er geht Schritt für Schritt, jede Anweisung.</b>  <b>Aber ein Fehler ist aufgetreten und was passiert mit dem Schauspieler?</b>  <b>Angenommen, ein Fehler wird nicht verarbeitet.</b>  <b>Stirbt der Schauspieler gerade?</b> <br><br>  - Nein, Orleans löst eine Ausnahme im Standard-.NET-Schema aus. <br><br>  <b>- Schauen Sie, wir haben keine Ausnahme behandelt, der Schauspieler ist anscheinend gestorben.</b>  <b>Dem Spieler weiß ich nicht, wie es aussehen wird, aber was passiert dann?</b>  <b>Versuchen Sie, diesen Schauspieler irgendwie neu zu starten oder etwas anderes zu tun?</b> <br><br>  - Es kommt darauf an, in welchem ​​Fall es auf welchen Fall ankommt.  Zum Beispiel retriable oder nicht retriable. <br><br>  <b>- Das heißt.</b>  <b>Ist das alles konfigurierbar?</b> <br><br>  - Eher programmiert.  Wir behandeln einige Ausnahmen.  Das heißt,  Wir sehen deutlich, dass ein solcher Fehlercode und einige, wie nicht behandelte Ausnahmen, bereits weiter vorangetrieben werden. <br><br>  <b>- Haben Sie mehrere Persistenzen - ist es wie eine Datenbank?</b> <br><br>  - Persistenz, ja, eine Datenbank mit persistentem Speicher. <br><br>  <b>- Nehmen wir an, eine Datenbank hat festgelegt, in welcher (bedingten) Spielgeld.</b>  <b>Was passiert, wenn ein Schauspieler sie nicht erreichen kann?</b>  <b>Wie gehst du damit um?</b> <br><br>  - Zuallererst ist es Speicher.  Im Moment verwenden wir Azure Table Storage, und solche Probleme treten tatsächlich auf - Speicher stürzt ab.  Normalerweise müssen Sie es in diesem Fall neu konfigurieren. <br><br>  <b>- Wenn der Schauspieler etwas nicht im Speicher haben konnte, wie sieht der Spieler aus?</b>  <b>Er hat dieses Geld einfach nicht oder schließt er das Spiel sofort?</b> <br><br>  - Dies sind wichtige Änderungen für den Benutzer.  Da jeder Dienst seinen eigenen Schweregrad hat, ist der Benutzerdienst in diesem Fall ein Terminalstatus und der Client stürzt einfach ab. <br><br>  <b>- Es schien mir, dass die Nachrichten der Schauspieler durch asynchrone Warteschlangen auftreten.</b>  <b>Wie ist diese optimierte Lösung?</b>  <b>Schwillt es nicht an, lässt es den Spieler nicht auflegen?</b>  <b>Ist es nicht besser, einen reaktiven Ansatz zu verwenden?</b> <br><br>  - Das Problem der Warteschlangen bei Schauspielern ist ziemlich bekannt, da wir die Größe der Warteschlange so eindeutig nicht kontrollieren können, dass Sie Recht haben.  Aber Orleans übernimmt erstens eine Art Managementarbeit und zweitens denke ich, dass der Zugang zum Schauspieler einfach durch Timeout sinken wird, d. H.  Wir können zum Beispiel den Schauspieler nicht erreichen. <br><br>  <b>- Und wie wirkt sich das auf den Spieler aus?</b> <br><br>  - Da der Benutzerdienst den Akteur kontaktiert, wird eine Ausnahme-Timeout-Ausnahme ausgelöst. Wenn es sich um einen „kritischen“ Dienst handelt, gibt der Client einen Fehler aus und schließt.  Und wenn es weniger kritisch ist, wird es warten. <br><br>  <b>- Das heißt.</b>  <b>Haben Sie eine DDoS-Bedrohung?</b>  <b>Eine große Anzahl kleiner Aktionen kann einen Spieler setzen?</b>  <b>Nehmen wir an, jemand lädt schnell Freunde usw. ein.</b> <br><br>  - Nein, es gibt einen Anforderungsbegrenzer, mit dem Sie nicht zu oft auf Dienste zugreifen können. <br><br>  <b>- Wie gehen Sie mit Datenkonsistenz um?</b>  <b>Angenommen, wir haben zwei Benutzer, wir müssen etwas von einem nehmen und dem anderen etwas in Rechnung stellen, damit es transaktional ist.</b> <br><br>  - Gute Frage.  Erstens unterstützt Orleans 2.0 die Distributed Actor Transaction - dies ist die erste Version.  Genauer gesagt muss bereits über die Wirtschaft gesprochen werden.  Und als einfachster Weg - im letzten Orleans werden Transaktionen zwischen Akteuren problemlos durchgeführt. <br><br>  <b>- Das heißt.</b>  <b>Weiß es bereits, wie sichergestellt werden kann, dass die Daten integer bleiben?</b> <br><br>  - Ja. <br><br><h3>  Weitere Gespräche mit Pixonic DevGAMM Talks </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwendung des Konsuls zur Skalierung staatlicher Dienste</a> (Ivan Bubnov, DevOps bei BIT.GAMES); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CICD: nahtlose Bereitstellung auf verteilten Clustersystemen ohne Ausfallzeiten</a> (Egor Panov, Pixonic-Systemadministrator); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Meta-Server-Architektur für mobile Online-Shooter von</a> Tacticool (Pavel Platto, Lead Software Engineer bei PanzerDog); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie ECS, C # Job System und SRP den Architekturansatz ändern</a> (Valentin Simonov, Field Engineer bei Unity); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">KISS-Prinzip in der Entwicklung</a> (Konstantin Gladyshev, Lead Game Programmer bei 1C Game Studios); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Allgemeine Spielelogik auf Client und Server</a> (Anton Grigoriev, stellvertretender technischer Mitarbeiter bei Pixonic). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gurke in der Cloud: Verwenden von BDD-Skripten für Produktstresstests</a> (Anton Kosyakin, Technischer Produktmanager auf der ALICE-Plattform). </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de426115/">https://habr.com/ru/post/de426115/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426101/index.html">Datenintegrität in der Microservice-Architektur - wie Sie dies ohne verteilte Transaktionen und enge Konnektivität sicherstellen können</a></li>
<li><a href="../de426103/index.html">Webinar „Brauchen Sie Kubernetes?“ 15. Oktober um 19:00 Uhr</a></li>
<li><a href="../de426105/index.html">Mein Fang in einer Woche</a></li>
<li><a href="../de426111/index.html">Google wird weiterhin einen zensierten Suchdienst in China starten</a></li>
<li><a href="../de426113/index.html">Google News und Leo Tolstoy: Visualisierung von Vektordarstellungen von Wörtern mit t-SNE</a></li>
<li><a href="../de426117/index.html">Der Bürgerbeauftragte schlägt vor, Anzeigen mit potenziell gefährlichen Babyprodukten zu blockieren</a></li>
<li><a href="../de426119/index.html">Altertümer: Cryptonomicon Iron</a></li>
<li><a href="../de426121/index.html">MC.exe (Nachrichten-Compiler), rc.exe, link.exe zum Generieren einer DLL für EventMessageFile</a></li>
<li><a href="../de426123/index.html">Lerne OpenGL. Lektion 6.1. PBR oder physikalisch korrektes Rendern. Theorie</a></li>
<li><a href="../de426125/index.html">Karriere Steroide. Aufzüge</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>