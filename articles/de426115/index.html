<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÑ üíê üêú Die Praxis der Verwendung des Schauspielermodells in der Backend-Plattform von Quake Champions üö£üèº üê¥ üñïüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich lade weiterhin Berichte mit Pixonic DevGAMM Talks hoch, unserem September-Treffen f√ºr Entwickler hoch geladener Systeme. Sie haben viele Erfahrung...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die Praxis der Verwendung des Schauspielermodells in der Backend-Plattform von Quake Champions</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/426115/">  Ich lade weiterhin Berichte mit Pixonic DevGAMM Talks hoch, unserem September-Treffen f√ºr Entwickler hoch geladener Systeme.  Sie haben viele Erfahrungen und F√§lle geteilt, und heute ver√∂ffentliche ich eine Abschrift der Rede des Backend-Entwicklers von Sabre Interactive Roman Rogozin.  Er sprach √ºber die Praxis der Anwendung des Akteurmodells am Beispiel der Verwaltung von Spielern und deren Status (andere Berichte finden Sie am Ende des Artikels, die Liste wird erg√§nzt). <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/dDYQpvtEEfo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br>  Unser Team arbeitet an einem Backend f√ºr das Spiel Quake Champions, und ich werde dar√ºber sprechen, was das Schauspielermodell ist und wie es im Projekt verwendet wird. <br><br>  Ein bisschen √ºber Technologie-Stack.  Wir schreiben Code in C #, alle Technologien sind daran gebunden.  Ich m√∂chte darauf hinweisen, dass es einige spezifische Dinge geben wird, die ich am Beispiel dieser Sprache zeigen werde, aber die allgemeinen Prinzipien bleiben unver√§ndert. <br><br><img src="https://habrastorage.org/webt/h-/st/yl/h-styljhwr1ci0hqzjnibcbgx2q.png"><br><br>  Derzeit hosten wir unsere Dienste in Azure.  Es gibt einige sehr interessante Grundelemente, die wir nicht aufgeben m√∂chten, wie z. B. Table Storage und Cosmos DB (aber wir versuchen, sie f√ºr das plattform√ºbergreifende Projekt nicht zu eng zu machen). <br><br>  Jetzt m√∂chte ich ein wenig dar√ºber erz√§hlen, was ein Schauspielermodell ist.  Und zun√§chst erschien es grunds√§tzlich vor mehr als 40 Jahren. <br><br><img src="https://habrastorage.org/webt/ps/wh/o5/pswho5g6goopdvjqgdzbbrudros.png"><br><br>  Ein Akteur ist ein Modell f√ºr paralleles Rechnen, das angibt, dass es ein bestimmtes isoliertes Objekt gibt, das √ºber einen eigenen internen Status und exklusiven Zugriff zum √Ñndern dieses Status verf√ºgt.  Ein Akteur kann Nachrichten lesen und dar√ºber hinaus nacheinander eine Art Gesch√§ftslogik ausf√ºhren, wenn er seinen internen Status √§ndern und Nachrichten an externe Dienste, einschlie√ülich anderer Akteure, senden m√∂chte.  Und er wei√ü, wie man andere Schauspieler erschafft. <br><br>  Akteure kommunizieren asynchron miteinander, sodass Sie hoch ausgelastete verteilte Cloud-Systeme erstellen k√∂nnen.  In dieser Hinsicht ist das Akteurmodell in letzter Zeit weit verbreitet. <br><br>  Zusammenfassend stellen wir uns vor, wir haben eine Cloud, in der es eine Art Servercluster gibt, und unsere Akteure drehen sich um diesen Cluster. <br><br><img src="https://habrastorage.org/webt/k7/le/o8/k7leo8f4_bksrkrxepnw7vlp_xk.png"><br><br>  Akteure sind voneinander isoliert, kommunizieren √ºber asynchrone Aufrufe und in sich selbst sind die Akteure threadsicher. <br><br>  Wie es aussehen k√∂nnte.  Angenommen, wir haben mehrere Benutzer (keine sehr gro√üe Last), und irgendwann verstehen wir, dass es einen Zustrom von Spielern gibt, und wir m√ºssen dringend eine Hochskalierung durchf√ºhren. <br><br><img src="https://habrastorage.org/webt/m5/v7/8k/m5v78k2trbiawxv2obnxtcpbhd0.png"><br><br>  Wir k√∂nnen unserer Cloud Server hinzuf√ºgen und mithilfe des Akteurmodells einzelne Benutzer pushen - weisen Sie jedem einzelnen Akteur zu und weisen Sie diesem Akteur in der Cloud Speicherplatz f√ºr Speicher und Prozessorzeit zu. <br><br>  Somit spielt der Akteur zum einen die Rolle eines Caches, und zum anderen handelt es sich um einen ‚Äûintelligenten Cache‚Äú, der einige Nachrichten verarbeiten und Gesch√§ftslogik ausf√ºhren kann.  Auch hier gilt: Wenn Sie eine Verkleinerung vornehmen m√ºssen (z. B. die Spieler sind gegangen), ist es auch kein Problem, diese Akteure aus dem System zu entfernen. <br><br>  Wir im Backend verwenden nicht das klassische Schauspielermodell, sondern basieren auf dem Orleans-Framework.  Was ist der Unterschied? Ich werde versuchen, es Ihnen jetzt zu sagen. <br><br><img src="https://habrastorage.org/webt/bg/bi/iu/bgbiiudonlat560_soge7gyv0-a.png"><br><br>  Zun√§chst f√ºhrt Orleans das Konzept des virtuellen Schauspielers oder, wie es auch genannt wird, des Getreides ein.  Im Gegensatz zum klassischen Darstellermodell, bei dem ein Dienst daf√ºr verantwortlich ist, diesen Darsteller zu erstellen und auf einigen Servern zu platzieren, √ºbernimmt Orleans die Arbeit.  Das hei√üt,  Wenn ein bestimmter Benutzerdienst eine bestimmte Note anfordert, versteht Orleans, welcher der Server jetzt weniger ausgelastet ist, platziert den Akteur dort und gibt das Ergebnis an den Benutzerdienst zur√ºck. <br><br>  Ein Beispiel.  F√ºr K√∂rner ist es wichtig, nur den Typ des Akteurs zu kennen, z. B. Benutzerstatus und ID.  Angenommen, Benutzer-ID 777, wir erhalten die K√∂rnung dieses Benutzers und denken nicht dar√ºber nach, wie diese K√∂rnung gespeichert werden soll. Wir steuern nicht den Lebenszyklus der K√∂rnung.  Orleans jedoch speichert die Wege aller Schauspieler auf sehr listige Weise in sich.  Wenn es keinen Schauspieler gibt, erstellt er sie, wenn der Schauspieler lebt, gibt er sie zur√ºck, und f√ºr Benutzerdienste sieht alles so aus, dass alle Schauspieler immer am Leben sind. <br><br><img src="https://habrastorage.org/webt/ud/5s/id/ud5sidxydmqbafgbhfjzcowwjgs.png"><br><br>  Welche Vorteile bringt uns das?  Erstens transparenter Lastausgleich aufgrund der Tatsache, dass der Programmierer den Standort des Akteurs nicht selbst verwalten muss.  Er sagt einfach Orleans, das auf mehreren Servern bereitgestellt wird: Geben Sie mir einen solchen Schauspieler von Ihren Servern. <br><br><img src="https://habrastorage.org/webt/r8/wn/dp/r8wndpcexsiwuw9qn_x5znxwkhc.png"><br><br>  Falls gew√ºnscht, k√∂nnen Sie eine Verkleinerung vornehmen, wenn die Belastung des Prozessors und des Speichers gering ist.  Auch hier k√∂nnen Sie die Hochskalierung in die entgegengesetzte Richtung durchf√ºhren.  Aber der Dienst wei√ü nichts dar√ºber, er bittet um die K√∂rnung, und Orleans gibt ihm diese K√∂rnung.  So √ºbernimmt Orleans die infrastrukturelle Versorgung f√ºr den Lebenszyklus der K√∂rner. <br><br>  Zweitens behandelt Orleans Serverabst√ºrze. <br><br><img src="https://habrastorage.org/webt/u8/cl/2c/u8cl2cjbxptjng5vy6sqg0f3pkw.png"><br><br>  Dies bedeutet, dass im klassischen Modell der Programmierer f√ºr die eigenst√§ndige Behandlung eines solchen Falls verantwortlich ist (er hat den Akteur auf einem Server platziert und dieser Server ist abgest√ºrzt, und wir m√ºssen diesen Akteur selbst auf einem der Live-Server erh√∂hen), was mehr Mechanik hinzuf√ºgt oder komplexe Netzwerkarbeit f√ºr einen Programmierer, dann sieht es in Orleans transparent aus.  Wir fordern eine K√∂rnung an, Orleans sieht, dass sie nicht verf√ºgbar ist, holt sie ab (platziert sie auf einigen Live-Servern) und gibt sie an den Dienst zur√ºck. <br><br>  Schauen wir uns zur Verdeutlichung ein kleines Beispiel an, wie ein Benutzer einen Teil seines Status liest. <br><br><img src="https://habrastorage.org/webt/je/_4/iw/je_4iwdh8tk1q5wtveptzzhf33e.png"><br><br>  Ein Staat kann sein wirtschaftlicher Zustand sein, in dem die R√ºstung, Waffen, W√§hrung oder Champions dieses Benutzers aufbewahrt werden.  Um diese Zust√§nde zu erhalten, ruft er den PublicUserService auf, der sich f√ºr den Zustand an Orleans wendet.  Was passiert: Orleans sieht, dass es noch keinen solchen Akteur (d. H. Getreide) gibt, er erstellt es auf einem freien Server und das Getreide liest seinen Zustand aus einem Persistenzspeicher. <br><br>  Wenn Sie also das n√§chste Mal Ressourcen aus der Cloud lesen, wie auf der Folie gezeigt, werden alle Lesevorg√§nge aus dem Cache-Cache stammen.  F√ºr den Fall, dass der Benutzer das Spiel verl√§sst, werden keine Ressourcen gelesen, sodass Orleans versteht, dass das Getreide von niemandem mehr verwendet wird und deaktiviert werden kann. <br><br>  Wenn wir mehrere Clients haben (Spielclient, Spielserver), k√∂nnen sie Benutzerstatus anfordern, und einer von ihnen erh√∂ht diese K√∂rnung.  Genauer gesagt, Orleans wird es abholen, und dann werden alle Anrufe, wie wir bereits wissen, nacheinander threadsicher ausgef√ºhrt.  Zuerst erh√§lt der Client den Status und dann den Spieleserver. <br><br><img src="https://habrastorage.org/webt/ih/og/2i/ihog2i9tqxlitxio9djssspgavy.png"><br><br>  Der gleiche Ablauf beim Update.  Wenn ein Client einen Status aktualisieren m√∂chte, √ºbertr√§gt er diese Verantwortung auf das Korn, d. H.  wird ihm sagen: "Gib diesem Benutzer 10 Gold", und das Korn steigt, es verarbeitet diesen Zustand mit einer Art Gesch√§ftslogik innerhalb des Korns.  Und dann kommt die Aktualisierung des Cache-Cache und, falls gew√ºnscht, die Persistenz in der Persistenz. <br><br><img src="https://habrastorage.org/webt/ym/2i/3v/ym2i3viyvuzcowtmkdqwat8mb2s.png"><br><br>  Warum ist hier Ausdauer erforderlich?  Dies ist ein separates Thema und es liegt in der Tatsache, dass es f√ºr uns manchmal nicht besonders wichtig ist, dass das Getreide seine Zust√§nde st√§ndig in der Persistenz beibeh√§lt.  Wenn dies der Zustand des Online-Spielers ist, sind wir bereit, ihn aus Gr√ºnden der Produktivit√§t zu verlieren. Wenn es um die Wirtschaft geht, m√ºssen wir sicher sein, dass seine Zust√§nde erhalten bleiben. <br><br>  Der einfachste Fall: Schreiben Sie dieses Update f√ºr jeden Aufruf des Sicherungsstatus in Persistence.  Wenn der Grayn pl√∂tzlich unerwartet abf√§llt, f√ºhrt das n√§chste Anheben des Grayn auf einigen anderen Servern zu einer Cache-Aktualisierung mit den aktuellen Daten. <br><br>  Ein kleines Beispiel, wie es aussieht. <br><br><img src="https://habrastorage.org/webt/gi/vp/bj/givpbj4gdy2lyshx4hblowzqncw.png"><br><br>  Wie ich bereits sagte, besteht ein Korn aus einem Typ und einem Schl√ºssel (in diesem Fall ist der Typ IPlayerState, der Schl√ºssel ist IGrainWithGuidKey, was bedeutet, dass es Guid ist).  Und wir haben eine Schnittstelle, die wir implementieren, d. H.  GetStates gibt eine Liste von Status und ApplyState zur√ºck, f√ºr die ein Status gilt.  Orleans-Methoden geben Task zur√ºck.  Was dies bedeutet: Aufgabe ist ein Versprechen, das uns sagt, dass sich das Versprechen in einem aufgel√∂sten Zustand befindet, wenn der Staat zur√ºckkehrt.  Wir haben auch einige PlayerState, die wir mit GrainFactory bekommen.  Das hei√üt,  Hier erhalten wir einen Link und wissen nichts √ºber den physischen Standort dieses Getreides.  Wenn Sie GetStates aufrufen, erh√∂ht Orleans unser Korn, liest den Status aus dem Persistenzspeicher in seinen Speicher und wenn ApplyState einen neuen Status anwendet, aktualisiert es diesen Status sowohl im Speicher als auch in der Persistenz. <br><br>  Ich m√∂chte ein etwas komplexeres Beispiel f√ºr die High-Level-Architektur unseres UserStates-Dienstes ausarbeiten. <br><br><img src="https://habrastorage.org/webt/4d/1s/r5/4d1sr5q9chg2qkm1-nj-qeldqtw.png"><br><br>  Wir haben eine Art Spieleclient, der seine Zust√§nde √ºber OfferSevice erh√§lt.  Wir haben einen GameConfigurationService, der f√ºr das Wirtschaftsmodell einer Benutzergruppe verantwortlich ist, in diesem Fall unseres Benutzers.  Und wir haben einen Betreiber, der dieses Wirtschaftsmodell √§ndert.  Dementsprechend fordert der Benutzer ein OfferSevice an, seinen Status zu erhalten.  Und OfferSevice greift bereits auf den UserOrleans-Dienst zu, der aus diesen K√∂rnern besteht. Es erh√∂ht diesen Status des Benutzers in seinem Speicher, f√ºhrt m√∂glicherweise eine Art Gesch√§ftslogik aus und gibt die Daten √ºber OfferService an den Benutzer zur√ºck. <br><br>  Im Allgemeinen m√∂chte ich darauf hinweisen, dass Orleans aufgrund der Tatsache, dass K√∂rner unabh√§ngig voneinander sind, f√ºr seine hohe Parallelit√§tsf√§higkeit gut ist.  Andererseits m√ºssen wir innerhalb der K√∂rnung keine Synchronisationsprimitive verwenden, da wir wissen, dass jeder Aufruf dieser K√∂rnung irgendwie konsistent ist. <br><br>  Hier m√∂chte ich einige der Fallstricke dieses Modells erkennen. <br><br><img src="https://habrastorage.org/webt/bi/nr/vt/binrvttwhrlmxqonc74qchyjzdc.png"><br><br>  Das erste ist zu viel K√∂rnung.  Da alle Aufrufe in der Greine nacheinander threadsicher sind und wir eine fettige Logik auf der Greine haben, m√ºssen wir zu lange warten.  Wiederum wird zu viel Speicher f√ºr ein solches Korn zugewiesen.  Es gibt keinen genauen Algorithmus f√ºr die Gr√∂√üe des Korns, da ein zu kleines Korn auch schlecht ist.  Hier ist es eher notwendig, vom optimalen Wert auszugehen.  Ich werde nicht genau sagen, welches, es liegt am Programmierer zu entscheiden. <br><br>  Das zweite Problem ist nicht so offensichtlich - dies ist die sogenannte Kettenreaktion.  Wenn ein Benutzer einige K√∂rner erh√∂ht, kann er implizit andere K√∂rner im System erh√∂hen.  So geschieht dies: Der Benutzer erh√§lt seinen Status, der Benutzer hat Freunde und er erh√§lt den Status seiner Freunde.  Somit beh√§lt das gesamte System alle seine K√∂rner im Speicher, und wenn wir 1000 Benutzer haben und jeder 100 Freunde hat, k√∂nnen 100.000 K√∂rner einfach so aktiv sein.  Dieser Fall muss auch vermieden werden - irgendwie speichern Sie die Zust√§nde von Freunden in einer Art gemeinsamem Speicher. <br><br><img src="https://habrastorage.org/webt/iu/ep/0z/iuep0z7a5vgw_qak3i-j8hx6hkc.png"><br><br>  Nun, welche Technologien gibt es, um das Akteurmodell zu implementieren?  Das vielleicht ber√ºhmteste ist Akka, das mit Java zu uns kam.  Es gibt eine Abzweigung namens Akka.NET f√ºr .NET.  Es gibt Orleans, das Open Source ist und in anderen Sprachen als Implementierung verf√ºgbar ist.  Es gibt Azure-Grundelemente wie Service Fabric Actor - es gibt viele Technologien. <br><br><h2>  Fragen aus dem Publikum </h2><br>  <b>- Wie l√∂sen Sie klassische Probleme wie CICD, aktualisieren diese Akteure, verwenden Sie Docker und wird es √ºberhaupt ben√∂tigt?</b> <br><br>  - Wir verwenden Docker noch nicht.  Im Allgemeinen ist DevOps an der Bereitstellung beteiligt und stellt unsere Dienste im Azure-Clouddienst bereit. <br><br>  <b>- Kontinuierliche Aktualisierung ohne Ausfallzeiten, wie geschieht dies?</b>  <b>Orleans selbst entscheidet, auf welchen Server der Server geht, auf welchen Server die Anfrage geht und wie dieser Dienst aktualisiert wird.</b>  <b>Das hei√üt,</b>  <b>Eine neue Gesch√§ftslogik ist erschienen, ein Update desselben Akteurs ist erschienen - wie werden diese Updates gerollt?</b> <br><br>  - Wenn wir √ºber die Aktualisierung des gesamten Dienstes sprechen und wenn wir eine Gesch√§ftslogik des Schauspielers aktualisiert haben, k√∂nnen wir einen neuen Orleans-Dienst daf√ºr einf√ºhren.  Normalerweise wird dies mit unseren Grundelementen gel√∂st, die als Topologie bezeichnet werden.  Wir haben einen Dienst in New Orleans eingef√ºhrt, der vorerst leer und ohne Schauspieler ist. Zeigen Sie den alten Dienst an und ersetzen Sie ihn durch einen neuen.  Es werden √ºberhaupt keine Akteure im System vorhanden sein, aber bei der n√§chsten Benutzeranforderung werden diese Akteure bereits erstellt.  Am Anfang wird es wahrscheinlich eine Art Spitze geben.  In solchen F√§llen findet das Update normalerweise am Morgen statt, da wir am Morgen die geringste Anzahl von Spielern haben. <br><br>  <b>"Wie versteht Orleans, dass der Server abgest√ºrzt ist?"</b>  <b>Sie sagten, dass er die Schauspieler schnell auf einen anderen Server wirft ...</b> <br><br>  - Er hat einen Pingator, der regelm√§√üig versteht, welche der Server am Leben sind. <br><br>  <b>- Pingt er einen Schauspieler oder Server speziell an?</b> <br><br>  - Insbesondere der Server. <br><br>  <b>- Eine solche Frage: Ein Fehler ist innerhalb des Schauspielers aufgetreten, Sie sagen, er geht Schritt f√ºr Schritt, jede Anweisung.</b>  <b>Aber ein Fehler ist aufgetreten und was passiert mit dem Schauspieler?</b>  <b>Angenommen, ein Fehler wird nicht verarbeitet.</b>  <b>Stirbt der Schauspieler gerade?</b> <br><br>  - Nein, Orleans l√∂st eine Ausnahme im Standard-.NET-Schema aus. <br><br>  <b>- Schauen Sie, wir haben keine Ausnahme behandelt, der Schauspieler ist anscheinend gestorben.</b>  <b>Dem Spieler wei√ü ich nicht, wie es aussehen wird, aber was passiert dann?</b>  <b>Versuchen Sie, diesen Schauspieler irgendwie neu zu starten oder etwas anderes zu tun?</b> <br><br>  - Es kommt darauf an, in welchem ‚Äã‚ÄãFall es auf welchen Fall ankommt.  Zum Beispiel retriable oder nicht retriable. <br><br>  <b>- Das hei√üt.</b>  <b>Ist das alles konfigurierbar?</b> <br><br>  - Eher programmiert.  Wir behandeln einige Ausnahmen.  Das hei√üt,  Wir sehen deutlich, dass ein solcher Fehlercode und einige, wie nicht behandelte Ausnahmen, bereits weiter vorangetrieben werden. <br><br>  <b>- Haben Sie mehrere Persistenzen - ist es wie eine Datenbank?</b> <br><br>  - Persistenz, ja, eine Datenbank mit persistentem Speicher. <br><br>  <b>- Nehmen wir an, eine Datenbank hat festgelegt, in welcher (bedingten) Spielgeld.</b>  <b>Was passiert, wenn ein Schauspieler sie nicht erreichen kann?</b>  <b>Wie gehst du damit um?</b> <br><br>  - Zuallererst ist es Speicher.  Im Moment verwenden wir Azure Table Storage, und solche Probleme treten tats√§chlich auf - Speicher st√ºrzt ab.  Normalerweise m√ºssen Sie es in diesem Fall neu konfigurieren. <br><br>  <b>- Wenn der Schauspieler etwas nicht im Speicher haben konnte, wie sieht der Spieler aus?</b>  <b>Er hat dieses Geld einfach nicht oder schlie√üt er das Spiel sofort?</b> <br><br>  - Dies sind wichtige √Ñnderungen f√ºr den Benutzer.  Da jeder Dienst seinen eigenen Schweregrad hat, ist der Benutzerdienst in diesem Fall ein Terminalstatus und der Client st√ºrzt einfach ab. <br><br>  <b>- Es schien mir, dass die Nachrichten der Schauspieler durch asynchrone Warteschlangen auftreten.</b>  <b>Wie ist diese optimierte L√∂sung?</b>  <b>Schwillt es nicht an, l√§sst es den Spieler nicht auflegen?</b>  <b>Ist es nicht besser, einen reaktiven Ansatz zu verwenden?</b> <br><br>  - Das Problem der Warteschlangen bei Schauspielern ist ziemlich bekannt, da wir die Gr√∂√üe der Warteschlange so eindeutig nicht kontrollieren k√∂nnen, dass Sie Recht haben.  Aber Orleans √ºbernimmt erstens eine Art Managementarbeit und zweitens denke ich, dass der Zugang zum Schauspieler einfach durch Timeout sinken wird, d. H.  Wir k√∂nnen zum Beispiel den Schauspieler nicht erreichen. <br><br>  <b>- Und wie wirkt sich das auf den Spieler aus?</b> <br><br>  - Da der Benutzerdienst den Akteur kontaktiert, wird eine Ausnahme-Timeout-Ausnahme ausgel√∂st. Wenn es sich um einen ‚Äûkritischen‚Äú Dienst handelt, gibt der Client einen Fehler aus und schlie√üt.  Und wenn es weniger kritisch ist, wird es warten. <br><br>  <b>- Das hei√üt.</b>  <b>Haben Sie eine DDoS-Bedrohung?</b>  <b>Eine gro√üe Anzahl kleiner Aktionen kann einen Spieler setzen?</b>  <b>Nehmen wir an, jemand l√§dt schnell Freunde usw. ein.</b> <br><br>  - Nein, es gibt einen Anforderungsbegrenzer, mit dem Sie nicht zu oft auf Dienste zugreifen k√∂nnen. <br><br>  <b>- Wie gehen Sie mit Datenkonsistenz um?</b>  <b>Angenommen, wir haben zwei Benutzer, wir m√ºssen etwas von einem nehmen und dem anderen etwas in Rechnung stellen, damit es transaktional ist.</b> <br><br>  - Gute Frage.  Erstens unterst√ºtzt Orleans 2.0 die Distributed Actor Transaction - dies ist die erste Version.  Genauer gesagt muss bereits √ºber die Wirtschaft gesprochen werden.  Und als einfachster Weg - im letzten Orleans werden Transaktionen zwischen Akteuren problemlos durchgef√ºhrt. <br><br>  <b>- Das hei√üt.</b>  <b>Wei√ü es bereits, wie sichergestellt werden kann, dass die Daten integer bleiben?</b> <br><br>  - Ja. <br><br><h3>  Weitere Gespr√§che mit Pixonic DevGAMM Talks </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwendung des Konsuls zur Skalierung staatlicher Dienste</a> (Ivan Bubnov, DevOps bei BIT.GAMES); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CICD: nahtlose Bereitstellung auf verteilten Clustersystemen ohne Ausfallzeiten</a> (Egor Panov, Pixonic-Systemadministrator); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Meta-Server-Architektur f√ºr mobile Online-Shooter von</a> Tacticool (Pavel Platto, Lead Software Engineer bei PanzerDog); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie ECS, C # Job System und SRP den Architekturansatz √§ndern</a> (Valentin Simonov, Field Engineer bei Unity); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">KISS-Prinzip in der Entwicklung</a> (Konstantin Gladyshev, Lead Game Programmer bei 1C Game Studios); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Allgemeine Spielelogik auf Client und Server</a> (Anton Grigoriev, stellvertretender technischer Mitarbeiter bei Pixonic). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gurke in der Cloud: Verwenden von BDD-Skripten f√ºr Produktstresstests</a> (Anton Kosyakin, Technischer Produktmanager auf der ALICE-Plattform). </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de426115/">https://habr.com/ru/post/de426115/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426101/index.html">Datenintegrit√§t in der Microservice-Architektur - wie Sie dies ohne verteilte Transaktionen und enge Konnektivit√§t sicherstellen k√∂nnen</a></li>
<li><a href="../de426103/index.html">Webinar ‚ÄûBrauchen Sie Kubernetes?‚Äú 15. Oktober um 19:00 Uhr</a></li>
<li><a href="../de426105/index.html">Mein Fang in einer Woche</a></li>
<li><a href="../de426111/index.html">Google wird weiterhin einen zensierten Suchdienst in China starten</a></li>
<li><a href="../de426113/index.html">Google News und Leo Tolstoy: Visualisierung von Vektordarstellungen von W√∂rtern mit t-SNE</a></li>
<li><a href="../de426117/index.html">Der B√ºrgerbeauftragte schl√§gt vor, Anzeigen mit potenziell gef√§hrlichen Babyprodukten zu blockieren</a></li>
<li><a href="../de426119/index.html">Altert√ºmer: Cryptonomicon Iron</a></li>
<li><a href="../de426121/index.html">MC.exe (Nachrichten-Compiler), rc.exe, link.exe zum Generieren einer DLL f√ºr EventMessageFile</a></li>
<li><a href="../de426123/index.html">Lerne OpenGL. Lektion 6.1. PBR oder physikalisch korrektes Rendern. Theorie</a></li>
<li><a href="../de426125/index.html">Karriere Steroide. Aufz√ºge</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>