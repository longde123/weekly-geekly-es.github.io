<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦍 🍥 ⛰️ Trabajar con objeciones: el análisis estático tomará parte del tiempo de trabajo 🔗 🤞🏽 🐇</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Al comunicarnos con personas en conferencias y en comentarios a artículos, nos encontramos con la siguiente objeción: el análisis estático reduce el t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Trabajar con objeciones: el análisis estático tomará parte del tiempo de trabajo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/467153/"><img src="https://habrastorage.org/getpro/habr/post_images/44e/3f2/c43/44e3f2c43b9bf3f6a6bcde04008188d1.png" alt="Sostener el error" align="left">  Al comunicarnos con personas en conferencias y en comentarios a artículos, nos encontramos con la siguiente objeción: el análisis estático reduce el tiempo dedicado a la búsqueda de errores, pero toma tiempo de los programadores, lo que elimina el beneficio de su uso e incluso ralentiza el proceso de desarrollo.  Analicemos esta objeción y demostremos que no tiene fundamento. <br><a name="habracut"></a><br>  La afirmación "el análisis estático ocupará parte del tiempo de trabajo" aislada del contexto es cierta.  La revisión periódica de las advertencias del analizador estático emitidas para el código nuevo o modificado realmente lleva tiempo.  Sin embargo, el pensamiento debe continuar: pero el tiempo dedicado a esto es mucho menor que el dedicado a identificar errores por otros métodos.  Aún peor es aprender sobre los errores de los clientes. <br><br>  Aquí, las pruebas unitarias pueden ser una muy buena analogía.  Las pruebas unitarias también toman tiempo para los desarrolladores, pero esta no es una razón para no usarlas.  El beneficio de escribir un código mejor y más confiable cuando se usan pruebas unitarias excede el costo de escribirlos. <br><br>  Otra analogía: advertencias del compilador.  Este es generalmente un tema muy cercano, ya que las advertencias de las herramientas de análisis estático pueden verse como una primera aproximación como una extensión de las advertencias del compilador.  Naturalmente, cuando un programador ve una advertencia del compilador, pasa tiempo en ella.  Debería cambiar el código o pasar tiempo explícitamente suprimiendo la advertencia, por ejemplo, usando #pragma.  Sin embargo, esta vez no es una razón para deshabilitar las advertencias del compilador.  Y si alguien hace esto, otros lo interpretarán inequívocamente como inadecuación profesional. <br><br>  Sin embargo, ¿de dónde viene el temor a la necesidad de pasar tiempo advirtiendo a los analizadores de código estático? <br><br>  Todo es muy sencillo.  Los programadores que todavía son nuevos en esta metodología confunden las ejecuciones de prueba y el uso regular.  En los primeros inicios, cualquier analizador ofrece una gran lista de advertencias, lo que es incluso aterrador de ver.  La razón es que el analizador aún no está configurado.  Un analizador sintonizado genera una pequeña cantidad de falsos positivos durante los lanzamientos regulares.  En otras palabras, la mayoría de las advertencias revelan defectos reales o un código de olor.  Solo es importante hacer esta configuración.  Este es todo el truco que convierte un analizador estático del mal, que lleva tiempo, en un amigo y un ayudante. <br><br>  Cualquier analizador estático producirá primero muchos falsos positivos.  Hay muchas razones para esto, y este tema merece un artículo separado.  Naturalmente, tanto nosotros como los desarrolladores de otros analizadores <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">luchamos</a> con falsos positivos.  Pero aún habrá muchos aspectos positivos si, sin preparación, de repente toma y ejecuta el analizador en algún proyecto.  La misma imagen, por cierto, con advertencias del compilador.  Supongamos que tiene un proyecto grande que siempre ha creado, por ejemplo, utilizando el compilador de Visual C ++.  Supongamos que el proyecto fue milagrosamente portátil y compilado usando GCC.  Aun así, recibirá una montaña de advertencias del CCG.  Cualquiera que haya experimentado un cambio de compiladores en un proyecto grande comprende de qué se trata. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8b2/25b/769/8b225b7693ce622964fbe9f49092c2a5.png" alt="Advertencias"></div><br><br>  Sin embargo, nadie obliga a cavar constantemente en las montañas de basura de las advertencias después de cambiar el compilador o después de iniciar el analizador.  El siguiente paso natural es configurar el compilador o el analizador.  Quienes dicen que "el análisis de advertencias lleva mucho tiempo" evalúa la complejidad de implementar la herramienta, pensando solo en todas estas advertencias que deben superarse al principio, pero no piensan en un uso regular y tranquilo. <br><br>  Configurar analizadores, así como compiladores, no es tan complicado y laborioso como a los programadores les gusta asustar.  Si es gerente, no los escuche.  Son simplemente vagos.  El programador puede decir con orgullo cómo pasó 3 días buscando el error encontrado por el probador / cliente.  Y esto es normal para él.  Sin embargo, desde su punto de vista, es inaceptable pasar un día ajustando la herramienta, después de lo cual se detectará un error similar antes de que entre al sistema de control de versiones. <br><br>  Sí, habrá falsas alarmas después de la sintonización.  Pero su número es exagerado.  Es muy posible configurar el analizador de modo que el porcentaje de falsos positivos sea del 10% al 15%.  Es decir  para 9 defectos encontrados, solo 1 advertencia requerirá supresión como falsa.  Entonces, ¿dónde está la "pérdida de tiempo" aquí?  Al mismo tiempo, el 15% es un valor muy real, que se puede encontrar con más detalle en este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">artículo</a> . <br><br>  Queda una cosa más.  El programador puede objetar: <br><br>  <i>Bueno, supongamos que las ejecuciones regulares de análisis estático son realmente efectivas.</i>  <i>¿Pero qué hacer con el ruido inicial?</i>  <i>En nuestro gran proyecto, no podremos configurar la herramienta para 1 día prometido.</i>  <i>Solo una recompilación para verificar el próximo lote de configuraciones lleva varias horas.</i>  <i>No estamos listos para pasar un par de semanas en todo esto.</i> <br><br>  Y esto no es un problema, sino un intento de encontrar una razón para no introducir algo nuevo.  Por supuesto, no todo es fácil en un proyecto grande.  Pero, en primer lugar, brindamos soporte y ayudamos a integrar PVS-Studio en el proceso de desarrollo.  Y en segundo lugar, no es necesario comenzar a resolver todas las advertencias. <br><br>  Dado que su aplicación funciona, significa que los errores allí no son tan críticos y probablemente se encuentren en un código poco utilizado.  Ya se han encontrado y corregido errores evidentes con métodos más lentos y costosos.  Pero al respecto a continuación en una <b>nota</b> .  Ahora algo más es importante para nosotros.  No tiene sentido realizar ediciones masivas en el código, corrigiendo muchos errores menores.  Con tanta refactorización, algo es fácil de romper y habrá más daño que bien. <br><br>  Es mejor considerar las advertencias existentes como una deuda técnica.  Será posible volver a endeudarse más tarde y trabajar con viejas advertencias gradualmente.  Usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el mecanismo de supresión de alertas masivas</a> , puede comenzar a usar rápidamente PVS-Studio en un proyecto grande.  Muy brevemente, sucede así: <br><br><ol><li>  Excluye directorios explícitamente redundantes (bibliotecas de terceros) del análisis.  En cualquier caso, esta configuración se realiza mejor desde el principio para reducir el tiempo de análisis. </li><li>  Intenta PVS-Studio y estudia las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">advertencias más interesantes</a> .  Le gustan los resultados y muestra la herramienta a colegas y superiores.  El equipo decide comenzar su uso regular. </li><li>  El proyecto está siendo verificado.  Todas las advertencias encontradas se desactivan utilizando el mecanismo de supresión masiva.  En otras palabras, todas las advertencias disponibles actualmente se consideran una deuda técnica, que se puede devolver más tarde. </li><li>  El archivo resultante con advertencias suprimidas se establece en el sistema de control de versiones.  Este archivo es grande, pero no da miedo.  Realiza esta operación una vez (o, al menos, lo hará extremadamente raramente).  Y ahora este archivo aparecerá en todos los desarrolladores. </li><li>  Ahora todos los desarrolladores ven advertencias que se aplican solo a código nuevo o modificado.  A partir de este momento, el equipo comienza a beneficiarse del análisis estático.  Configure gradualmente el analizador y haga deuda técnica. </li></ol><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e8b/6a4/b4b/e8b6a4b4bf8404d32c8ba4e4f4dd7557.png" alt="Genial"></div><br>  Por cierto, el sistema para almacenar advertencias poco interesantes es lo suficientemente inteligente.  Los hashes se almacenan para una cadena con un posible error, así como para el anterior y el siguiente.  Debido a esto, si se agrega una línea al comienzo de uno de los archivos, entonces nada se "corroerá" y el analizador seguirá en silencio sobre el código considerado un deber técnico. <br><br>  Espero que hayamos podido disipar uno de los prejuicios con respecto al análisis estático.  Ven, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">descarga</a> y prueba nuestro analizador de código estático PVS-Studio.  Detectará muchos errores en las primeras etapas y hará que su código en general sea más confiable y de alta calidad. <br><br>  <b>Nota</b> <br><br>  Al desarrollar cualquier proyecto, constantemente aparecen nuevos errores y se corrigen.  Los errores no detectados "se asientan" en el código durante mucho tiempo, y luego se pueden detectar muchos de ellos al ejecutar el análisis de código estático.  Debido a esto, a veces existe la falsa sensación de que los analizadores estáticos encuentran solo algunos errores poco interesantes en secciones de código poco utilizadas.  Por supuesto, este es el caso si usa el analizador incorrectamente y lo ejecuta solo de vez en cuando, por ejemplo, poco antes del lanzamiento de la versión.  Más sobre este tema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> .  Sí, al escribir artículos, nosotros mismos realizamos verificaciones únicas de proyectos abiertos.  Pero tenemos un objetivo diferente.  Queremos demostrar las capacidades de un analizador de código para detectar defectos.  Esta tarea tiene poco que ver con mejorar la calidad del código del proyecto en su conjunto y reducir los costos asociados con la corrección de errores. <br><br>  <b>Enlaces adicionales:</b> <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PVS-Studio ROI</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El análisis estático mejorará la base de código de proyectos complejos de C ++</a> . </li><li>  Heisenbug 2019. Informe de Ivan Ponomarev " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Análisis continuo de código estático</a> ". </li><li>  Ivan Ponomarev.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Incruste el análisis estático en el proceso, no busque errores con él</a> . </li></ol><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br>  Si desea compartir este artículo con una audiencia de habla inglesa, utilice el enlace a la traducción: Andrey Karpov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Manejo de objeciones: el análisis estático ocupará parte del tiempo de trabajo</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/467153/">https://habr.com/ru/post/467153/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../467143/index.html">Uso de impurezas en aplicaciones Flutter</a></li>
<li><a href="../467145/index.html">No solo comercio: cómo usar el intercambio como una alternativa a los depósitos bancarios y obtener ingresos</a></li>
<li><a href="../467147/index.html">Ataques masivos: características de contraataque a la experiencia de los últimos años.</a></li>
<li><a href="../467149/index.html">Antigüedades: 1992 en la prensa informática</a></li>
<li><a href="../467151/index.html">Manejo de objeciones: el análisis estático ocupará parte del tiempo de trabajo</a></li>
<li><a href="../467155/index.html">Mejores prácticas para contenedores de Kubernetes: controles de salud</a></li>
<li><a href="../467161/index.html">Aplicación web en Kotlin + Spring Boot + Vue.js</a></li>
<li><a href="../467163/index.html">Cómo migrar a la nube en dos horas gracias a Kubernetes y la automatización</a></li>
<li><a href="../467165/index.html">Siguiendo los pasos del movimiento ruso Scala. Parte 2</a></li>
<li><a href="../467169/index.html">Lecciones aprendidas de las pruebas Más de 200,000 líneas de Código de Infraestructura</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>