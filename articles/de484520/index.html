<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíï „ÄΩÔ∏è üì´ Wie das Zip-Archiv aussieht und was wir damit machen k√∂nnen. Teil 3 - Praktische Anwendung ü§±üèº üë≥ üßòüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Fortsetzung des Artikels Wie das Zip-Archiv aussieht und was wir damit machen k√∂nnen. Teil 2 - Datenbeschreibung und -komprimierung . 

 Sehr geehrte ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie das Zip-Archiv aussieht und was wir damit machen k√∂nnen. Teil 3 - Praktische Anwendung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484520/">  <i>Fortsetzung des Artikels <a href="https://habr.com/ru/post/472966/">Wie das Zip-Archiv aussieht und was wir damit machen k√∂nnen.</a></i>  <i><a href="https://habr.com/ru/post/472966/">Teil 2 - Datenbeschreibung und -komprimierung</a> .</i> <br><br>  Sehr geehrte Leserinnen und Leser, ich begr√º√üe Sie erneut zum Transfer von Unconventional Programming in PHP.  Um zu verstehen, was passiert, empfehle ich Ihnen, die beiden vorherigen Artikel √ºber Zip-Archive zu lesen: <a href="https://habr.com/ru/post/471066/">Wie sieht ein Zip-Archiv aus und was k√∂nnen wir damit machen</a> ? <a href="https://habr.com/ru/post/471066/">Wie sieht ein Zip-Archiv</a> <a href="https://habr.com/ru/post/472966/">aus und was k√∂nnen wir damit machen</a> ?  <a href="https://habr.com/ru/post/472966/">Teil 2 - Datenbeschreibung und -komprimierung</a> <br><br>  Zuvor habe ich dar√ºber gesprochen, wie Archive nur mit PHP-Code und ohne Bibliotheken und Erweiterungen (einschlie√ülich der Standard- <a href="https://www.php.net/manual/ru/book.zip.php">Zip-Datei</a> ) erstellt werden, und auch einige Verwendungsszenarien erw√§hnt.  Heute werde ich versuchen, ein Beispiel f√ºr eines dieser Szenarien zu geben. <br><br>  Wir speichern die Bilder im Archiv auf einem Remote-Server und zeigen dem Benutzer bei Bedarf ein bestimmtes Bild an, ohne das Archiv herunterzuladen oder zu entpacken, aber nur Daten vom Server selbst zu empfangen, speziell aufgenommenes Bild und nichts weiter (nun ja, niemand hat den Overhead f√ºr Header abgebrochen aber immer noch). <br><a name="habracut"></a><br><h3>  Kochen </h3><br>  Eines meiner Lieblingsprojekte verf√ºgt √ºber ein einfaches Skript, mit dem ich eine Reihe von Bildern herunterlade und im Archiv speichere.  Das Skript akzeptiert eine Liste von Links in json, um STDIN einzugeben, gibt das Archiv selbst an STDOUT und json mit einer Array-Struktur in STDERR (dies ist nat√ºrlich ein bisschen √ºbertrieben, und es ist nicht erforderlich, ein Archiv mit nativem PHP zu erstellen, Sie k√∂nnen daf√ºr geeignetere Tools verwenden und dann einfach Lesen Sie die Struktur - Ich werde versuchen, diesen Punkt in der Zukunft hervorzuheben, aber zu diesem Zeitpunkt scheint es mir, dass es offensichtlicher sein wird). <br><br>  Dieses Skript, mit einigen √Ñnderungen, zitiere ich unten: <br><br><div class="spoiler">  <b class="spoiler_title">zip.php</b> <div class="spoiler_text"><pre><code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $buffer = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!feof(STDIN)) { $buffer .= fread(STDIN, <span class="hljs-number"><span class="hljs-number">4096</span></span>); } $photos = json_decode($buffer, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, <span class="hljs-number"><span class="hljs-number">512</span></span>, JSON_THROW_ON_ERROR); $skeleton = [<span class="hljs-string"><span class="hljs-string">'files'</span></span> =&gt; []]; $written = <span class="hljs-number"><span class="hljs-number">0</span></span>; [$written, $skeleton] = writeZip($written, $skeleton, $photos); $CDFH_Offset = $written; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($skeleton[<span class="hljs-string"><span class="hljs-string">'files'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $index =&gt; $info) { $written += fwrite(STDOUT, $info[<span class="hljs-string"><span class="hljs-string">'CDFH'</span></span>]); $skeleton[<span class="hljs-string"><span class="hljs-string">'files'</span></span>][$index][<span class="hljs-string"><span class="hljs-string">'CDFH'</span></span>] = base64_encode($info[<span class="hljs-string"><span class="hljs-string">'CDFH'</span></span>]); } $skeleton[<span class="hljs-string"><span class="hljs-string">'EOCD'</span></span>] = pack(<span class="hljs-string"><span class="hljs-string">'LSSSSLLS'</span></span>, <span class="hljs-number"><span class="hljs-number">0x06054b50</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, $records = count($skeleton[<span class="hljs-string"><span class="hljs-string">'files'</span></span>]), $records, $written - $CDFH_Offset, $CDFH_Offset, <span class="hljs-number"><span class="hljs-number">0</span></span>); $written += fwrite(STDOUT, $skeleton[<span class="hljs-string"><span class="hljs-string">'EOCD'</span></span>]); $skeleton[<span class="hljs-string"><span class="hljs-string">'EOCD'</span></span>] = base64_encode($skeleton[<span class="hljs-string"><span class="hljs-string">'EOCD'</span></span>]); fwrite(STDERR, json_encode($skeleton)); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeZip</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($written, $skeleton, $files)</span></span></span><span class="hljs-function"> </span></span>{ $c = curl_init(); curl_setopt_array($c, [ CURLOPT_RETURNTRANSFER =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>, CURLOPT_TIMEOUT =&gt; <span class="hljs-number"><span class="hljs-number">50</span></span>, CURLOPT_FOLLOWLOCATION =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, ]); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($files <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $index =&gt; $url) { $fileName = $index . <span class="hljs-string"><span class="hljs-string">'.jpg'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i = <span class="hljs-number"><span class="hljs-number">0</span></span>; $i &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>; $i++ ) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { curl_setopt($c, CURLOPT_URL, $url); [$content, $code, $contentLength] = [ curl_exec($c), (int) curl_getinfo($c, CURLINFO_HTTP_CODE), (int) curl_getinfo($c, CURLINFO_CONTENT_LENGTH_DOWNLOAD) ]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($code !== <span class="hljs-number"><span class="hljs-number">200</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \<span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span>(<span class="hljs-string"><span class="hljs-string">"[{$index}] "</span></span> . <span class="hljs-string"><span class="hljs-string">'Photo download error ('</span></span> . $code . <span class="hljs-string"><span class="hljs-string">'): '</span></span> . curl_error($c)); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (strlen($content) !== $contentLength) { var_dump(strlen($content), $contentLength); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \<span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span>(<span class="hljs-string"><span class="hljs-string">"[{$index}] "</span></span> . <span class="hljs-string"><span class="hljs-string">'Different content-length'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">false</span></span> === $imageSize = @getimagesizefromstring($content)) || $imageSize[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt; <span class="hljs-number"><span class="hljs-number">1</span></span> || $imageSize[<span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \<span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span>(<span class="hljs-string"><span class="hljs-string">"[{$index}] "</span></span> . <span class="hljs-string"><span class="hljs-string">'Broken image'</span></span>); } [$width, $height] = $imageSize; $t = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (\Throwable $t) {} } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($t !== <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \<span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span>(<span class="hljs-string"><span class="hljs-string">'Error: '</span></span> . $index . <span class="hljs-string"><span class="hljs-string">' &gt; '</span></span> . $url, <span class="hljs-number"><span class="hljs-number">0</span></span>, $t); } $fileInfo = [ <span class="hljs-string"><span class="hljs-string">'versionToExtract'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-string"><span class="hljs-string">'generalPurposeBitFlag'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'compressionMethod'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'modificationTime'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">28021</span></span>, <span class="hljs-string"><span class="hljs-string">'modificationDate'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">20072</span></span>, <span class="hljs-string"><span class="hljs-string">'crc32'</span></span> =&gt; hexdec(hash(<span class="hljs-string"><span class="hljs-string">'crc32b'</span></span>, $content)), <span class="hljs-string"><span class="hljs-string">'compressedSize'</span></span> =&gt; $size = strlen($content), <span class="hljs-string"><span class="hljs-string">'uncompressedSize'</span></span> =&gt; $size, <span class="hljs-string"><span class="hljs-string">'filenameLength'</span></span> =&gt; strlen($fileName), <span class="hljs-string"><span class="hljs-string">'extraFieldLength'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, ]; $LFH_Offset = $written; $skeleton[<span class="hljs-string"><span class="hljs-string">'files'</span></span>][$index] = [ <span class="hljs-string"><span class="hljs-string">'LFH'</span></span> =&gt; pack(<span class="hljs-string"><span class="hljs-string">'LSSSSSLLLSSa*'</span></span>, <span class="hljs-number"><span class="hljs-number">0x04034b50</span></span>, ...array_values($fileInfo + [<span class="hljs-string"><span class="hljs-string">'filename'</span></span> =&gt; $fileName])), <span class="hljs-string"><span class="hljs-string">'CDFH'</span></span> =&gt; pack(<span class="hljs-string"><span class="hljs-string">'LSSSSSSLLLSSSSSLLa*'</span></span>, <span class="hljs-number"><span class="hljs-number">0x02014b50</span></span>, <span class="hljs-number"><span class="hljs-number">798</span></span>, ...array_values($fileInfo + [ <span class="hljs-string"><span class="hljs-string">'fileCommentLength'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'diskNumber'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'internalFileAttributes'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'externalFileAttributes'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">2176057344</span></span>, <span class="hljs-string"><span class="hljs-string">'localFileHeaderOffset'</span></span> =&gt; $LFH_Offset, <span class="hljs-string"><span class="hljs-string">'filename'</span></span> =&gt; $fileName, ])), <span class="hljs-string"><span class="hljs-string">'width'</span></span> =&gt; $width, <span class="hljs-string"><span class="hljs-string">'height'</span></span> =&gt; $height, ]; $written += fwrite(STDOUT, $skeleton[<span class="hljs-string"><span class="hljs-string">'files'</span></span>][$index][<span class="hljs-string"><span class="hljs-string">'LFH'</span></span>]); $written += fwrite(STDOUT, $content); $skeleton[<span class="hljs-string"><span class="hljs-string">'files'</span></span>][$index][<span class="hljs-string"><span class="hljs-string">'LFH'</span></span>] = base64_encode($skeleton[<span class="hljs-string"><span class="hljs-string">'files'</span></span>][$index][<span class="hljs-string"><span class="hljs-string">'LFH'</span></span>]); } curl_close($c); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [$written, $skeleton]; }</code> </pre> </div></div><br>  Speichern wir es irgendwo, rufen zip.php auf und versuchen es auszuf√ºhren. <br><br>  Ich habe bereits eine fertige Liste mit Links, ich empfehle sie zu verwenden, da es Bilder √ºber ~ 18 MB gibt und die Gesamtgr√∂√üe des Archivs 20 MB nicht √ºberschreiten darf (etwas sp√§ter werde ich erkl√§ren, warum) - <a href="">https://gist.githubusercontent.com /userqq/d0ca3aba6b6762c9ce5bc3ace92a9f9e/raw/70f446eb98f1ba6838ad3c19c3346cba371fd263/photos.json</a> <br><br>  Wir werden so laufen: <br><br><pre> <code class="bash hljs">$ curl -s \ https://gist.githubusercontent.com/userqq/d0ca3aba6b6762c9ce5bc3ace92a9f9e/raw/70f446eb98f1ba6838ad3c19c3346cba371fd263/photos.json \ | php zip.php \ 2&gt; structure.json \ 1&gt; photos.zip</code> </pre> <br>  Wenn das Skript seine Arbeit beendet hat, sollten wir am Ausgang zwei Dateien erhalten - <i>photos.zip</i> . Ich empfehle, dies mit dem Befehl zu √ºberpr√ºfen: <br><br><pre> <code class="bash hljs">$ unzip -tq photos.zip</code> </pre> <br>  und <i>structure.json</i> , in dem wir json mit base64 von allem speichern, was sich in unserem Archiv befindet, mit Ausnahme der Daten selbst - alle LFH- und CDFH-Strukturen sowie EOCD.  Ich sehe noch keine praktische Anwendung von EOCD getrennt vom Archiv, aber die Position des LFH-Offsets relativ zum Dateianfang und die Datenl√§nge sind in CDFH angegeben.  Wenn wir also die L√§nge des LFH kennen, k√∂nnen wir sicher wissen, von welcher Position aus die Daten beginnen und wo sie enden werden. <br><br>  Jetzt m√ºssen wir unsere Datei auf einen Remote-Server hochladen. <br><br>  Zum Beispiel verwende ich den Telegramm-Bot - dies ist der einfachste, weshalb es so wichtig war, in das 20-MB-Limit zu passen. <br><br>  Registrieren Sie den Bot bei @BotFather, wenn Sie noch keinen haben, schreiben Sie etwas Willkommenes in Ihren Bot, suchen Sie Ihre Nachricht unter <a href="https://api.telegram.org/bot%257B%257BTOKEN%257D%257D/getUpdates">https://api.telegram.org/bot{{TOKEN‚ñ∫‚ñ∫/getUpdates</a> , von dem wir die Eigenschaft message.from isolieren .id = Dies ist die ID Ihres Chat-Bot. <br><br>  F√ºllen Sie unser Archiv mit Ihnen, das Sie im vorherigen Schritt erhalten haben: <br><br><pre> <code class="bash hljs">$ curl -F document=@<span class="hljs-string"><span class="hljs-string">"photos.zip"</span></span> <span class="hljs-string"><span class="hljs-string">"https://api.telegram.org/bot{{TOKEN}}/sendDocument?chat_id={{CHAT ID}}"</span></span> &gt; stored.json</code> </pre> <br>  Jetzt haben wir bereits zwei json-Dateien - <i>structure.json</i> und <i>saved.json</i> . <br><br>  Und wenn alles gut gegangen ist, enth√§lt die Datei saved.json json mit ok-Feldern gleich true und result.document.file_id, die wir ben√∂tigen. <br><br><h3>  Prototyp </h3><br>  Nun, da alles fertig ist, lasst uns zur Sache kommen: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> define(<span class="hljs-string"><span class="hljs-string">'TOKEN'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    $structure = json_decode(file_get_contents('structure.json'), true, 512, JSON_THROW_ON_ERROR); $stored = json_decode(file_get_contents('stored.json'), true, 512, JSON_THROW_ON_ERROR); $selectedFile = $structure['files'][array_rand($structure['files'])]; $LFH = base64_decode($selectedFile['LFH']); $CDFH = base64_decode($selectedFile['CDFH']); $fileLength = unpack('Llen', substr($CDFH, 24, 4))['len']; $fileStart = unpack('Lpos', substr($CDFH, 42, 4))['pos'] + strlen($LFH); $fileEnd = $fileStart + $fileLength; $response = json_decode(file_get_contents('https://api.telegram.org/bot' . TOKEN . '/getFile?' . http_build_query([ 'file_id' =&gt; $stored['result']['document']['file_id'] ])), true, 512, JSON_THROW_ON_ERROR); header('Content-Type: image/jpeg'); readfile('https://api.telegram.org/file/bot' . TOKEN . '/' . $response['result']['file_path'], false, stream_context_create([ 'http' =&gt; ['header' =&gt; "Range: bytes={$fileStart}-{$fileEnd}"] ]));</span></span></code> </pre><br>  In diesem Skript w√§hlen wir eine zuf√§llige Datei aus der Liste aus, die wir im Archiv haben, suchen die LFH-Startposition, addieren die LFH-L√§nge dazu und erhalten so die Startposition der Daten f√ºr eine bestimmte Datei im Archiv. <br><br>  Addiert man die Dateil√§nge dazu, so erh√§lt man die Position des Datenendes. <br><br>  Es bleibt, die Adresse der Datei selbst zu erhalten (dies ist in einem bestimmten Fall bei einem Telegramm der Fall) und dann einfach eine Anfrage mit der √úberschrift <code>Range: bytes=&lt;-&gt;-&lt;-&gt;</code> <br><br>  (vorausgesetzt der Server unterst√ºtzt Range Requests) <br><br>  Wenn Sie auf das angegebene Skript zugreifen, sehen Sie den Inhalt eines zuf√§lligen Bildes aus unserem Archiv. <br><br><h3>  Nein, es ist nicht ernst ... </h3><br>  Es versteht sich von selbst, dass die Anforderung von <i>getFile</i> zwischengespeichert werden sollte, da Telegramme garantieren, dass die Verbindung mindestens eine Stunde lang besteht.  Im Allgemeinen ist dieses Beispiel nichts weiter als zu zeigen, dass es funktioniert. <br><br>  Lass es uns etwas h√§rter versuchen - starte alles mit Amphp.  Immerhin verteilen die Leute statische Daten in der Produktion auf node.js, aber was hindert uns daran (naja, abgesehen vom gesunden Menschenverstand nat√ºrlich)?  Wir haben auch hier Asynchronit√§t, wissen Sie. <br><br>  Wir brauchen 3 Pakete: <br><br><ul><li>  <b>amphp / http-server</b> - offensichtlich der Server, an den wir Dateien verteilen werden </li><li>  <b>amphp / artax</b> - http-client, mit dem wir die Daten <b>abrufen und</b> einen direkten Link zur Datei im Cache aktualisieren. </li><li>  <b>amphp / parallel</b> ist eine Bibliothek f√ºr Multithreading und so weiter.  Aber keine Angst, wir brauchen nur SharedMemoryParcel, das uns als Im-Memory-Cache dient. </li></ul><br>  Wir setzen die notwendigen Abh√§ngigkeiten: <br><br><pre> <code class="bash hljs">$ composer require amphp/http-server amphp/artax amphp/parallel</code> </pre> <br>  Und schreibe das <br><br><div class="spoiler">  <b class="spoiler_title">Skript</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> define(<span class="hljs-string"><span class="hljs-string">'TOKEN'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    use Amp\Artax\DefaultClient; use Amp\Artax\Request as ArtaxRequest; use Amp\Http\Server\RequestHandler\CallableRequestHandler; use Amp\Http\Server\Server as HttpServer; use Amp\Http\Server\Request; use Amp\Http\Server\Response; use Amp\Http\Status; use Amp\Parallel\Sync\SharedMemoryParcel; use Amp\Socket; use Psr\Log\NullLogger; require 'vendor/autoload.php'; Amp\Loop::run(function () { $structure = json_decode(file_get_contents('structure.json'), true, 512, JSON_THROW_ON_ERROR); $stored = json_decode(file_get_contents('stored.json'), true, 512, JSON_THROW_ON_ERROR); $parcel = SharedMemoryParcel::create($id = bin2hex(random_bytes(10)), []); $client = new DefaultClient(); $handler = function (Request $request) use ($parcel, $client, $structure, $stored) { $cached = yield $parcel-&gt;synchronized(function (array $value) use ($client, $stored) { if (!isset($value['file_path']) || $value['expires'] &lt;= time()) { $response = yield $client-&gt;request('https://api.telegram.org/bot' . TOKEN . '/getFile?' . http_build_query([ 'file_id' =&gt; $stored['result']['document']['file_id'] ])); $json = json_decode(yield $response-&gt;getBody(), true, 512, JSON_THROW_ON_ERROR); $value = ['file_path' =&gt; $json['result']['file_path'], 'expires' =&gt; time() + 55 * 60]; } return $value; }); $selectedFile = $structure['files'][array_rand($structure['files'])]; $LFH = base64_decode($selectedFile['LFH']); $CDFH = base64_decode($selectedFile['CDFH']); $fileLength = unpack('Llen', substr($CDFH, 24, 4))['len']; $fileStart = unpack('Lpos', substr($CDFH, 42, 4))['pos'] + strlen($LFH); $fileEnd = $fileStart + $fileLength; $request = (new ArtaxRequest('https://api.telegram.org/file/bot' . TOKEN . '/' . $cached['file_path'])) -&gt;withHeader('Range', "bytes={$fileStart}-{$fileEnd}"); $response = yield $client-&gt;request($request); if (!in_array($response-&gt;getStatus(), [200, 206])) { return new Response(Status::SERVICE_UNAVAILABLE, ['content-type' =&gt; 'text/plain'], "Service Unavailable."); } return new Response(Status::OK, ['content-type' =&gt; 'image/jpeg'], $response-&gt;getBody()); }; $server = new HttpServer([Socket\listen("0.0.0.0:10051")], new CallableRequestHandler($handler), new NullLogger); yield $server-&gt;start(); Amp\Loop::onSignal(SIGINT, function (string $watcherId) use ($server) { Amp\Loop::cancel($watcherId); yield $server-&gt;stop(); }); });</span></span></code> </pre></div></div><br>  Was wir als Ergebnis erhalten: Wir haben jetzt einen Cache, in dem wir einen Link zu einem Dokument f√ºr 55 Minuten speichern. Dies stellt auch sicher, dass wir einen Link nicht mehrmals hintereinander anfordern, wenn wir zum Zeitpunkt des Cache-Ablaufs viele Anfragen erhalten.  Nun, all dies ist mit PHP-FPM (oder, Gott bewahre, PHP-CGI) eindeutig einfacher als readfile. <br><br>  Au√üerdem k√∂nnen Sie den Amphp-Instanz-Pool erh√∂hen - SharedMemoryParcel weist nach seinem Namen darauf hin, dass unser Cache zwischen Prozessen / Threads hin und her wechselt.  Nun, oder, wenn Sie immer noch Bedenken hinsichtlich der Zuverl√§ssigkeit dieses Entwurfs haben, dann sollten Sie <a href="https://habr.com/ru/post/460685/">proxy_pass und nginx verwenden</a> . <br><br>  Im Allgemeinen ist die Idee alles andere als neu und sogar in den b√§rtigen Jahren konnten Sie mit DownloadMaster eine bestimmte Datei aus dem Zip-Archiv herunterladen, ohne das gesamte Archiv herunterzuladen. Daher ist es nicht erforderlich, die Struktur separat zu speichern, sondern es werden einige Anforderungen gespeichert.  Was ist, wenn wir beispielsweise die Datei dem Benutzer im laufenden Betrieb als Proxy zur Verf√ºgung stellen m√∂chten, wirkt sich dies ziemlich stark auf die Geschwindigkeit der Anforderung aus. <br><br>  Warum k√∂nnte dies n√ºtzlich sein?  Um beispielsweise Inode zu speichern, wenn Sie zig Millionen kleiner Dateien haben und diese nicht direkt in der Datenbank speichern m√∂chten, k√∂nnen Sie sie in Archiven speichern, wobei Sie den Versatz kennen, um eine einzelne Datei zu empfangen. <br><br>  Oder wenn Sie Dateien aus der Ferne speichern.  In einem 20-MB-Telegramm k√∂nnen Sie sich nat√ºrlich nicht fortbewegen, aber wer wei√ü, es gibt noch andere M√∂glichkeiten. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de484520/">https://habr.com/ru/post/de484520/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de484504/index.html">Herstellung eines Luftionisators f√ºr weniger als 10 US-Dollar</a></li>
<li><a href="../de484506/index.html">Ich bin Fotograf und werde mich selbst zum Arbeitsger√§t machen</a></li>
<li><a href="../de484512/index.html">TOP 25 der gr√∂√üten ICOs: Was ist jetzt mit ihnen los?</a></li>
<li><a href="../de484514/index.html">Universelles Routing f√ºr reaktive Anwendungen</a></li>
<li><a href="../de484518/index.html">Wir bekommen das Video von der Kamera via DVRIP mit PHP</a></li>
<li><a href="../de484522/index.html">DEFCON-Konferenz 27. Hacken Sie die Polizei. Teil 2</a></li>
<li><a href="../de484526/index.html">Vorbereiten eines SDL2-Projekts f√ºr die Ausf√ºhrung unter Android</a></li>
<li><a href="../de484528/index.html">Wie ich mein Hobbyprojekt auf k8s √ºbertragen habe</a></li>
<li><a href="../de484530/index.html">CNC-Maschine zur Plasmabearbeitung / Modifikation von Polymerwerkstoffen</a></li>
<li><a href="../de484532/index.html">√úber die geometrische Bedeutung von Gray-Codes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>