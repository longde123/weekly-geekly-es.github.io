<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï∞Ô∏è üë©üèø‚Äçüé§ ‚§µÔ∏è Dasar-dasar Futex üíê üë¢ üë©üèº‚Äçüç≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Futex (futex - kependekan dari "Fast userspace mutex") adalah mekanisme yang diusulkan oleh pengembang Linux dari IBM pada tahun 2002 dan memasuki ker...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dasar-dasar Futex</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/infopulse/blog/418705/">  <b>Futex</b> (futex - kependekan dari "Fast userspace mutex") adalah mekanisme yang diusulkan oleh pengembang Linux dari IBM pada tahun 2002 dan memasuki kernel pada akhir tahun 2003.  Gagasan utamanya adalah menyediakan cara yang lebih efisien untuk menyinkronkan utas pengguna dengan jumlah panggilan minimum ke kernel OS. <br><br>  Pada artikel ini, kami akan meninjau futex, mencoba memahami prinsip-prinsip pekerjaan mereka, dan juga menggunakannya sebagai batu bata untuk membangun objek sinkronisasi level tinggi (dan akrab bagi kami). <br><br>  Poin penting: futex adalah alat tingkat rendah, layak digunakan secara langsung hanya ketika mengembangkan pustaka dasar, seperti pustaka C / C ++ standar.  Sangat tidak mungkin bahwa Anda akan perlu menggunakan futex dalam aplikasi reguler. <br><a name="habracut"></a><br><h3>  Motivasi </h3><br>  Sebelum munculnya futex, perlu untuk melakukan panggilan sistem (menggunakan, misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">semop</a> ) setiap kali untuk mengontrol akses ke sumber daya bersama dari beberapa utas, yang, seperti yang Anda tahu, padat sumber daya, karena setiap panggilan memerlukan pengalihan konteks dari mode pengguna ke mode kernel.  Dengan peningkatan jumlah core pada prosesor modern dan peningkatan jumlah utas dalam perangkat lunak aplikasi, ini telah menjadi masalah yang signifikan.  Itu bahkan lebih "ofensif", mengingat bahwa semua panggilan ini tidak membawa fungsi yang diterapkan, tidak menerapkan logika bisnis, tetapi hanya menjamin operasi yang benar dari sisa kode. <br><br>  Proposal untuk menambahkan konsep baru "futex" ke OS didasarkan pada pengamatan sederhana: dalam banyak kasus, upaya untuk menangkap objek sinkronisasi berhasil pertama kali.  Pemrogram menulis perangkat lunak sedemikian rupa sehingga sesedikit mungkin waktu beralih dari mengunci kunci untuk membukanya, yang berarti ada peluang yang sangat tinggi bahwa upaya untuk menangkap utas lainnya tidak akan menemui hambatan.  Saat aliran mencapai objek sinkronisasi "bebas", kami dapat menangkapnya tanpa membuat panggilan sistem menggunakan operasi atom yang relatif murah.  Dan ada peluang yang sangat besar bahwa operasi atom akan berhasil dengan sukses. <br><br>  Dalam kasus yang jarang terjadi, ketika kami masih mencoba mengakses sumber daya yang diblokir oleh utas lainnya, operasi atom akan mengembalikan kesalahan.  Dalam hal ini, kami memiliki dua opsi.  Kita dapat memutar di beberapa kunci-spin dari mode pengguna, menunggu rilis sumber daya (yang akan memakan sumber daya CPU), atau meminta kernel untuk menempatkan kita ke mode tidur, menunggu rilis sumber daya.  Di sinilah futex datang ke tempat kejadian. <br><br><h3>  Penggunaan sederhana dari futex - harapan dan kebangkitan </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panggilan sistem futex</a> menggabungkan cukup beragam fungsi.  Kami tidak akan mempertimbangkan opsi rumit di sini (beberapa di antaranya sangat rumit sehingga bahkan tidak dijelaskan dalam dokumentasi resmi), tetapi fokus pada operasi FUTEX_WAIT dan FUTEX_WAKE.  Deskripsi dalam dokumentasi resmi akan menjadi dasar yang baik: <br><blockquote>  Panggilan sistem futex () menyediakan program dengan metode untuk menunggu kondisi tertentu menjadi kenyataan.  Biasanya, panggilan sistem ini menggunakan konstruksi pemblokiran dalam konteks sinkronisasi memori bersama.  Saat menggunakan futex, operasi sinkronisasi utama dilakukan di ruang pengguna.  Program ruang pengguna hanya menjalankan panggilan sistem futex () bila program perlu memasuki mode siaga untuk waktu yang lama hingga kondisinya menjadi benar.  Juga, futex () dapat digunakan untuk membangunkan proses atau utas yang mengharapkan kondisi tertentu. </blockquote>  Sederhananya, futex adalah konstruksi kernel yang membantu kode pengguna menyinkronkan utas ketika sesuatu terjadi.  Beberapa proses (atau utas) dapat menunggu acara dalam panggilan FUTEX_WAIT, sementara yang lain dapat memanggil acara ini dengan FUTEX_WAKE.  Menunggu berfungsi dengan efisien - utas menunggu ditangguhkan oleh kernel dan tidak menggunakan sumber daya prosesor sampai terbangun ketika peristiwa yang diharapkan terjadi. <br><br>  Luangkan waktu untuk membaca dokumentasi secara keseluruhan.  Ya, atau setidaknya baca bagian tentang FUTEX_WAIT dan FUTEX_WAKE. <br><br>  Mari kita lihat <a href="">contoh sederhana</a> yang menunjukkan penggunaan dasar futex untuk mengoordinasikan pekerjaan dua proses. <br><br>  Proses anak: <br><br><ol><li>  Menunggu 0xA di slot memori umum </li><li>  Menulis nilai 0xB ke slot ini </li></ol><br>  Proses induk saat ini: <br><br><ol><li>  Menulis nilai 0xA ke slot memori bersama </li><li>  Menunggu 0xB muncul di dalamnya </li></ol><br>  Seperti "jabat tangan" antara dua proses.  Ini kodenya: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">** argv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> shm_id = shmget(IPC_PRIVATE, <span class="hljs-number"><span class="hljs-number">4096</span></span>, IPC_CREAT | <span class="hljs-number"><span class="hljs-number">0666</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (shm_id &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { perror(<span class="hljs-string"><span class="hljs-string">"shmget"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* shared_data = shmat(shm_id, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); *shared_data = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> forkstatus = fork(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (forkstatus &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { perror(<span class="hljs-string"><span class="hljs-string">"fork"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (forkstatus == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//   printf("child waiting for A\n"); wait_on_futex_value(shared_data, 0xA); printf("child writing B\n"); //  0xB         *shared_data = 0xB; wake_futex_blocking(shared_data); } else { //   printf("parent writing A\n"); //  0xA         *shared_data = 0xA; wake_futex_blocking(shared_data); printf("parent waiting for B\n"); wait_on_futex_value(shared_data, 0xB); // Wait for the child to terminate. wait(NULL); shmdt(shared_data); } return 0; }</span></span></code> </pre> <br>  Perhatikan panggilan POSIX untuk mengalokasikan memori bersama antar proses.  Kami tidak dapat menggunakan alokasi memori yang biasa di sini, karena bahkan alamat pointer yang sama dalam proses yang berbeda sebenarnya akan menunjuk ke blok memori yang berbeda (unik untuk setiap proses). <br><br>  Perlu dicatat bahwa contoh ini agak menyimpang dari kanon, karena futex pada awalnya dibuat untuk menunggu perubahan dalam arti tertentu "dari sesuatu yang spesifik untuk apa pun", dan bukan "dari sesuatu ke sesuatu yang spesifik".  Saya memberikan contoh ini untuk menunjukkan kemungkinan seperti itu, dan di bawah ini kami akan mempertimbangkan versi dasar (di atasnya kami menerapkan mutex). <br><br>  Dan inilah kode fungsi wait_on_futex_value: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait_on_futex_value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* futex_addr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> futex_rc = futex(futex_addr, FUTEX_WAIT, val, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (futex_rc == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (errno != EAGAIN) { perror(<span class="hljs-string"><span class="hljs-string">"futex"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (futex_rc == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*futex_addr == val) { <span class="hljs-comment"><span class="hljs-comment">//    return; } } else { abort(); } } }</span></span></code> </pre> <br>  Tugas utama dari fungsi ini (selain itu, sebenarnya, panggilan sistem futex) adalah siklus di mana kita menjalankan ketika kita bangun palsu (tidak tertarik pada kita).  Ini bisa terjadi ketika nilai baru, tetapi tidak kami harapkan, dipasang di slot memori bersama.  Baik, atau dalam kasus ketika proses lain dibangunkan lebih awal dari kita (ini tidak bisa terjadi dalam kasus khusus kita, tetapi dengan cara yang lebih umum itu mungkin). <br><br>  Semantik Futex adalah hal yang cukup rumit!  Panggilan FUTEX_WAIT akan segera kembali jika nilai pada alamat futex tidak sama dengan val argumen yang diteruskan.  Dalam kasus kami, ini bisa terjadi jika proses anak pergi menunggu sebelum orang tua menulis nilai 0xA di slot.  Futex dalam hal ini mengembalikan nilai EAGAIN. <br><br>  Dan di sini adalah kode fungsi wake_futex_blocking: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wake_futex_blocking</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* futex_addr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> futex_rc = futex(futex_addr, FUTEX_WAKE, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (futex_rc == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { perror(<span class="hljs-string"><span class="hljs-string">"futex wake"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (futex_rc &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } }</code> </pre> <br>  Ini adalah pembungkus pemblokiran di atas FUTEX_WAKE yang akan dengan cepat bekerja dan mengembalikan nilai, tidak peduli berapa banyak pendengar yang mengharapkannya.  Dalam contoh kami, ini digunakan sebagai bagian dari "jabat tangan," tetapi penggunaan lain mungkin dilakukan. <br><br><h3>  Futex adalah antrian kernel untuk kode khusus. </h3><br>  Sederhananya, sebuah futex adalah antrian yang digerakkan oleh kernel untuk menyelesaikan tugas kode kustom.  Ini memungkinkan kode pengguna untuk meminta kernel untuk menunda eksekusi utasnya sampai suatu peristiwa terjadi, dan ke utas lainnya pada saat yang sama untuk memberi sinyal pada acara ini dan membangunkan semua utas yang menunggunya.  Sebelumnya kami menyebutkan kemampuan untuk mengatur spin-lock dalam mode pengguna, menunggu beberapa kondisi terpenuhi.  Namun, antrian di kernel adalah alternatif yang jauh lebih baik, karena ini menyelamatkan kita dari miliaran instruksi prosesor yang terbuang yang dijalankan dalam satu lingkaran tunggu. <br><br>  Berikut adalah diagram dari artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Tinjauan umum dan pembaruan"</a> di LWN: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/476/433/d4e/476433d4e5a9ba7dcd840a7fe5eb3d87.png" alt="gambar"><br><br>  Dalam kode kernel Linux, futex diimplementasikan dalam file kernel / futex.c.  Kernel menyimpan tabel hash di mana kunci adalah alamat - untuk dengan cepat menemukan antrian yang diinginkan dan menambahkan proses panggilan ke dalamnya.  Semuanya, tentu saja, tidak begitu sederhana - lagipula, kernel itu sendiri perlu menyinkronkan akses ke data di dalamnya, plus mendukung segala macam opsi tambahan untuk futeksov. <br><br><h3>  Waktu tunggu terbatas dengan FUTEX_WAIT </h3><br>  Panggilan sistem futex memiliki parameter batas waktu yang memungkinkan pengguna menentukan berapa lama mereka siap untuk menunggu.  Berikut ini adalah <a href="">contoh</a> lengkap di mana ini diterapkan, tetapi di sini adalah bagian kunci: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"child waiting for A\n"</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timespec</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timeout</span></span></span><span class="hljs-class"> = {</span></span>.tv_sec = <span class="hljs-number"><span class="hljs-number">0</span></span>, .tv_nsec = <span class="hljs-number"><span class="hljs-number">500000000</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> t1 = time_ns(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> futex_rc = futex(shared_data, FUTEX_WAIT, <span class="hljs-number"><span class="hljs-number">0xA</span></span>, &amp;timeout, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"child woken up rc=%d errno=%s, elapsed=%llu\n"</span></span>, futex_rc, futex_rc ? strerror(errno) : <span class="hljs-string"><span class="hljs-string">""</span></span>, time_ns() - t1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (futex_rc == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; *shared_data == <span class="hljs-number"><span class="hljs-number">0xA</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br>  Jika menunggu ditunda selama 500 ms, maka fungsi futex akan berakhir, dan pada iterasi berikutnya dari loop kita entah bagaimana dapat bereaksi terhadap ini (menampilkan sesuatu di layar, menulis ke log, melanjutkan menunggu atau berhenti). <br><br><h3>  Menggunakan futex untuk mengimplementasikan mutex </h3><br>  Kami memulai artikel ini dengan fakta bahwa futex memiliki kegunaan praktis dalam implementasi objek sinkronisasi tingkat tinggi.  Mari kita coba menggunakannya (juga atomik) untuk mengimplementasikan mutex klasik.  Implementasi di bawah ini didasarkan pada kode dari artikel "Futexes Tricky" yang ditulis oleh Ulrich Drepper. <br><br>  Untuk contoh ini, saya menggunakan C ++, terutama untuk kemampuan menggunakan atom dari standar C ++ 11.  Anda dapat menemukan kode lengkap di <a href="">sini</a> , tetapi bagian terpenting adalah: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mutex</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Mutex() : atom_(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c = cmpxchg(&amp;atom_, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// If the lock was previously unlocked, there's nothing else for us to do. // Otherwise, we'll probably have to wait. if (c != 0) { do { // If the mutex is locked, we signal that we're waiting by setting the // atom to 2. A shortcut checks is it's 2 already and avoids the atomic // operation in this case. if (c == 2 || cmpxchg(&amp;atom_, 1, 2) != 0) { // Here we have to actually sleep, because the mutex is actually // locked. Note that it's not necessary to loop around this syscall; // a spurious wakeup will do no harm since we only exit the do...while // loop when atom_ is indeed 0. syscall(SYS_futex, (int*)&amp;atom_, FUTEX_WAIT, 2, 0, 0, 0); } // We're here when either: // (a) the mutex was in fact unlocked (by an intervening thread). // (b) we slept waiting for the atom and were awoken. // // So we try to lock the atom again. We set teh state to 2 because we // can't be certain there's no other thread at this exact point. So we // prefer to err on the safe side. } while ((c = cmpxchg(&amp;atom_, 0, 2)) != 0); } } void unlock() { if (atom_.fetch_sub(1) != 1) { atom_.store(0); syscall(SYS_futex, (int*)&amp;atom_, FUTEX_WAKE, 1, 0, 0, 0); } } private: // 0 means unlocked // 1 means locked, no waiters // 2 means locked, there are waiters in lock() std::atomic&lt;int&gt; atom_; };</span></span></code> </pre><br>  Dalam kode ini, fungsi cmpxhg adalah pembungkus sederhana untuk penggunaan atom yang lebih mudah: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// An atomic_compare_exchange wrapper with semantics expected by the paper's // mutex - return the old value stored in the atom. int cmpxchg(std::atomic&lt;int&gt;* atom, int expected, int desired) { int* ep = &amp;expected; std::atomic_compare_exchange_strong(atom, ep, desired); return *ep; }</span></span></code> </pre> <br>  Contoh kode ini berisi banyak komentar yang menjelaskan logika operasinya.  Ini tidak akan sakit, karena ada risiko yang signifikan bahwa Anda ingin menulis versi yang sedikit lebih sederhana, tetapi sepenuhnya salah.  Adapun kode ini - juga tidak sempurna dalam segala hal.  Sebagai contoh, ia mencoba membuat asumsi tentang perangkat internal dari tipe std :: atomic, melemparkan isinya ke int * untuk meneruskan panggilan futex.  Ini biasanya tidak demikian.  Kode mengkompilasi dan berjalan di Linux x64, tetapi kami tidak memiliki jaminan kompatibilitas dengan platform lain.  Untuk mendapatkannya, kita perlu menambahkan lapisan ketergantungan platform untuk atom.  Karena ini bukan topik artikel ini (dan juga karena sangat tidak mungkin bahwa Anda akan mencampur futex dalam modul C ++ yang sama) kami akan mengabaikan implementasi ini.  Ini hanya demonstrasi! <br><br><h3>  Mutib glibc dan kunci tingkat rendah </h3><br>  Jadi kita sampai pada titik di mana glibc mengimplementasikan thread POSIX, yang sebagian adalah tipe pthread_mutex_t.  Seperti yang saya katakan di awal artikel ini, futex bukanlah hal yang dibutuhkan oleh pengembang biasa.  Mereka digunakan oleh pustaka runtime atau sesuatu yang sangat khusus untuk mengimplementasikan primitif sinkronisasi tingkat tinggi.  Dalam konteks ini, menarik untuk melihat implementasi dari mutex untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NPTL</a> .  Dalam kode glibc, ini adalah file nptl / pthread_mutex_lock.c. <br><br>  Kode ini cukup rumit karena kebutuhan untuk mendukung berbagai jenis mutex, tetapi kita dapat menemukan blok yang cukup akrab jika diinginkan.  Anda juga dapat melihat file sysdeps / unix / sysv / linux / x86_64 / lowlevellock.h dan nptl / lowlevellock.c.  Kode ini agak membingungkan, tetapi kombinasi panggilan to-and-exchange dan futex masih mudah. <br><br>  Komentar awal dari file systeds / nptl / lowlevellock.h harus sudah dipahami dengan baik oleh Anda: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Low-level locks use a combination of atomic operations (to acquire and release lock ownership) and futex operations (to block until the state of a lock changes). A lock can be in one of three states: 0: not acquired, 1: acquired with no waiters; no other threads are blocked or about to block for changes to the lock state, &gt;1: acquired, possibly with waiters; there may be other threads blocked or about to block for changes to the lock state. We expect that the common case is an uncontended lock, so we just need to transition the lock between states 0 and 1; releasing the lock does not need to wake any other blocked threads. If the lock is contended and a thread decides to block using a futex operation, then this thread needs to first change the state to &gt;1; if this state is observed during lock release, the releasing thread will wake one of the potentially blocked threads. .. */</span></span></code> </pre> <br><h3>  Pergi runtime futex </h3><br>  Rantime Go tidak menggunakan libc (dalam banyak kasus).  Dengan demikian, tidak dapat mengandalkan implementasi utas POSIX.  Sebagai gantinya, ia langsung memanggil panggilan sistem tingkat bawah.  Ini membuatnya menjadi contoh yang baik menggunakan futex.  Karena tidak ada cara untuk memanggil pthread_mutex_t, Anda harus menulis penggantinya sendiri.  Mari kita lihat bagaimana ini dilakukan, mari kita mulai dengan tipe sync.Mutex yang terlihat oleh pengguna (di src / sync / mutex.go). <br><br>  Metode Kunci jenis ini mencoba menggunakan operasi pertukaran atom untuk menangkap kunci dengan cepat.  Jika ternyata Anda perlu menunggu, ia memanggil runtime_SemacquireMutex, yang memanggil runtime.lock.  Fungsi ini didefinisikan dalam src / runtime / lock_futex.go dan mendeklarasikan beberapa konstanta yang mungkin Anda kenal: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( mutex_unlocked = <span class="hljs-number"><span class="hljs-number">0</span></span> mutex_locked = <span class="hljs-number"><span class="hljs-number">1</span></span> mutex_sleeping = <span class="hljs-number"><span class="hljs-number">2</span></span> ... ) <span class="hljs-comment"><span class="hljs-comment">// Possible lock states are mutex_unlocked, mutex_locked and mutex_sleeping. // mutex_sleeping means that there is presumably at least one sleeping thread.</span></span></code> </pre><br>  runtime.lock juga mencoba menangkap kunci menggunakan fungsi atom.  Ini masuk akal, karena runtime.lock dipanggil di banyak tempat Go runtime, tetapi bagi saya tampaknya mungkin untuk mengoptimalkan kode dengan menghapus dua panggilan berurutan dari fungsi atom saat memanggil runtime.lock dari Mutex.lock. <br><br>  Jika ternyata Anda harus menunggu, fungsi platform-dependent futexsleep disebut, yang didefinisikan untuk Linux dalam file src / runtime / os_linux.go.  Fungsi ini membuat panggilan sistem futex dengan kode FUTEX_WAIT_PRIVATE (dalam hal ini, ini cocok, karena runtime Go hidup dalam satu proses). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id418705/">https://habr.com/ru/post/id418705/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id418691/index.html">Peternak: Kubernet dalam 5 menit dengan logam kosong</a></li>
<li><a href="../id418693/index.html">Mengapa kebahagiaan begitu sulit dideteksi di otak</a></li>
<li><a href="../id418695/index.html">Perang Anti-Pembajakan - The Empire Strikes Back</a></li>
<li><a href="../id418699/index.html">Membuat mesin arcade emulator. Bagian 3</a></li>
<li><a href="../id418701/index.html">Kami mempelajari parser sintaksis untuk bahasa Rusia</a></li>
<li><a href="../id418707/index.html">KDispatcher - eventbus yang ringan dan nyaman untuk penggunaan sehari-hari</a></li>
<li><a href="../id418709/index.html">Perlu memaksa diri Anda: driver dan hambatan antarmuka</a></li>
<li><a href="../id418711/index.html">Register Terkelola Token 1.0</a></li>
<li><a href="../id418713/index.html">Game untuk meningkatkan kualitas Wikipedia</a></li>
<li><a href="../id418715/index.html">Seberapa efisien sistem file virtual procfs dan mungkinkah mengoptimalkannya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>