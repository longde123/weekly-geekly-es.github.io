<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚ÄçüöÄ üòπ üéì Verschwindende Rahmenbedingungen üç± ü§öüèª ü§£</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Warum verwenden wir Frameworks? Angular, React und Vue helfen uns beim Erstellen komplexer Webanwendungen: Strukturieren von Code, Verwalten des Statu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verschwindende Rahmenbedingungen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/450822/">  Warum verwenden wir Frameworks?  Angular, React und Vue helfen uns beim Erstellen komplexer Webanwendungen: Strukturieren von Code, Verwalten des Status und Entwickeln komplexer Schnittstellen.  In den letzten zehn Jahren sind Frameworks zum Standard geworden.  Ein teurer Standard.  Seit der Verwendung von Frameworks ist JS sehr aufgebl√§ht.  Es gibt mehr Seiten mit einem Gewicht von mehreren Megabyte, und ein wesentlicher Teil dieses Volumens ist das Framework selbst.  Es scheint ein wenig zu sein, aber f√ºr den Benutzer ist es kritisch - auf dem Telefon oder im schwachen Internet wird die Seite m√∂glicherweise nicht einmal geladen.  Das ist ein Problem. <br><br><img src="https://habrastorage.org/webt/l4/wd/k7/l4wdk7s_mctdg-p6ctwusbwiq7m.png"><br><br>  Klassische Frameworks sind nicht nur √ºbergewichtig, sondern haben auch viele andere Nachteile und sind nicht f√ºr alle Projekte geeignet.  Diese Probleme werden in "gef√§hrdeten Frameworks" gel√∂st.  Was ist dieser neue Trend, warum ist es nicht ‚Äûein weiteres JS-Framework‚Äú, sondern eine gute Idee und wie mysteri√∂se Frameworks unsere Anwendungen verbessern k√∂nnen, wird Pavel Malyshev erz√§hlen. <br><a name="habracut"></a><br>  <b>√úber den Sprecher: Pavel Malyshev</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">PaulMaly</a> ) - Fullstack mit mehr als 10 Jahren Erfahrung.  Er arbeitet bei Mustlab, das das Internet, Smart TV und mobile Ger√§te sowie das Internet der Dinge auslagert.  Ein Evangelist des Svelte JS-Rahmens in Russland leitet eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Telegrammgruppe</a> zu diesem Thema. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/NvNe4nKmZT0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  Was sollte nicht im Bericht sein </h2><br>  Als ich diese Geschichte betrachtete, entschied ich, dass sie nicht dem Standard entsprechen sollte.  Deshalb habe ich geschrieben, was hier nicht sein soll.  Es wird keine Betonung auf ein bestimmtes Framework geben, Vergleiche mit anderen Frameworks - sie sind m√ºde von allen, und nat√ºrlich m√∂chte ich nicht Captain Obvious sein.  All dies h√§tte nicht in meiner Geschichte sein sollen, aber leider wird es ... <br><br>  Als Sie den Namen gelesen haben, haben Sie wahrscheinlich gedacht, dass es einen anderen Rahmen gibt und es bereits einen ganzen Zoo gibt. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b9e/324/d9c/b9e324d9cd7205923e0805c009b820e5.png"><br><br>  Es scheint mir, dass wenn ein neuer Rahmen erscheint, die alten einige unserer Bed√ºrfnisse nicht befriedigen.  Vielleicht √§ndern sich die Bed√ºrfnisse selbst im Laufe der Zeit, und deshalb brauchen wir neue L√∂sungen - effektiver und interessanter.  Daher bitte ich Sie, das Vorstehende unter diesem Gesichtspunkt offen anzugehen und die verschwundenen Frameworks als neues Werkzeug zu betrachten, das Ihnen bei Ihrer Arbeit helfen kann. <br><br>  Lassen Sie uns zun√§chst herausfinden, wer wer ist. <br><br><h2>  Wer ist wer </h2><br>  Ich nahm die gro√üen Drei und Svelte.  Es ist interessant, dass sich jedes Werkzeug anders charakterisiert.  <b>Angular</b> positioniert sich als Rahmen f√ºr alle Gelegenheiten, "alles in einer Box".  <b>React</b> ahmt eine Bibliothek nach: ‚ÄûIch bin so klein wie eine Bibliothek‚Äú, aber zusammen mit der gesamten Infrastruktur ist es auch ein vollwertiges Framework.  <b>Vue</b> ist angeblich ein progressiver Rahmen.  Sie k√∂nnen mit jQuery nacheinander wechseln, indem Sie den Code sequentiell √ºbertragen, beginnend fast mit dem √ºblichen <code>script</code> Tag ohne Kollektoren.  <b>Svelte</b> ist ein magisch verschwindender Rahmen.  Wat? <br><br>  Lassen Sie uns herausfinden, wovon ich spreche. <br><br><h2>  Warum verschwanden die Frameworks? </h2><br><blockquote>  Wir senden zu viel Code an unsere Benutzer. </blockquote><br>  Unsere Kunden werden immer mobiler, aber die Internet-Technologie ist nicht √ºberall gut - selbst 3G ist nicht √ºberall, ganz zu schweigen von LTE.  Wir m√ºssen die Gr√∂√üe des Codes reduzieren. <br><br>  Zu diesem Thema gibt es eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">interessante Studie</a> aus dem Jahr 2017, die zeigt, dass Sie, wenn Ihre Anwendung viel JS enth√§lt, nur <b>130 KB verwenden k√∂nnen, um den Benutzer gl√ºcklich zu machen</b> .  Wenn JS klein ist, dann bis zu 170 KB.  Dieser Unterschied ist auf die Tatsache zur√ºckzuf√ºhren, dass in der Studie ber√ºcksichtigt wurde, dass sich JS von anderen Arten von Ressourcen unterscheidet. Es muss analysiert, interpretiert usw. werden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8b5/032/ec3/8b5032ec37fd48a2f95998759f41c5f9.png"><br><br>  In der Studie sind 130 KB nicht nur JS, sondern im Allgemeinen alles, einschlie√ülich CSS, HTML, nat√ºrlich ohne Bilder.  Gleichzeitig wiegt ein Winkel 143 Kb, und wir haben noch nicht einmal eine einzige Codezeile geschrieben.  Mal sehen, was uns aktuelle L√∂sungen bieten. <br><br><h3>  Leistung </h3><br>  Im Prinzip ist jedes klassische Framework eine Abstraktion √ºber eine Plattform, die es uns erm√∂glicht, auf bequemeren Ebenen zu schreiben.  Dies ist schlecht, da jede Abstraktion einige Kosten verursacht, einschlie√ülich der Leistung. <br><br><blockquote>  Durch unn√∂tige Abstraktionen zwischen unserem Code und dem Browser entstehen uns zus√§tzliche Kosten. </blockquote><br>  Verschwindende Frameworks haben das Merkmal, dass sie <b>unn√∂tige Abstraktionen und Berechnungen aus der Browser-Laufzeit entfernen</b> und zum Zeitpunkt der Kompilierung Analysen und Berechnungen durchf√ºhren.  Deshalb verschwinden sie.  Wir werden weiter unten ausf√ºhrlicher darauf eingehen. <br><br><h3>  Kompatibilit√§t </h3><br><blockquote>  F√ºr das klassische Framework geschriebene L√∂sungen k√∂nnen nirgendwo angewendet werden. </blockquote><br>  Sie arbeiten nur im Rahmen dieses Rahmens.  Zum Beispiel machen Sie 2-3 Projekte mit Ihrem Lieblingsreact, schreiben eine Reihe cooler L√∂sungen daf√ºr und entscheiden sich dann f√ºr Angular.  Sie brauchen diese L√∂sungen nicht mehr, Sie k√∂nnen sie wegwerfen.  Obwohl die Kernidee der Komponentenabgleich ist, machen es klassische Frameworks uns unm√∂glich, Code wiederzuverwenden. <br><br>  Das Verschwinden von Frameworks <b>hat keine Abstraktionen</b> , und in diesem Fall gibt es zur Laufzeit kein Framework.  Ihr Code ist absolut Vanilla JS, der √ºberall hin mitgenommen werden kann - zu jedem Projekt, auch in einem anderen Framework.  Beispielsweise k√∂nnen Sie den Code in ein verschwindendes Framework √ºbernehmen und an React √ºbertragen. <br><br><h3>  Code-Aufteilung und Baumsch√ºtteln </h3><br><blockquote>  Alte Technologien erschweren die Anwendung neuer Technologien. </blockquote><br>  Die meisten Frameworks wurden erstellt, als diese Technologien nicht so entwickelt wurden.  Wir haben einen ziemlich monolithischen Kernel, und jede Komponente, selbst der kleinste Teil Ihres Codes, ist an das gesamte Framework gebunden.  Dementsprechend ist es nicht m√∂glich, Code effektiv aufzuteilen und sogar B√§ume zu sch√ºtteln. <br><br>  Jetzt entwickeln sich alle Frameworks zu einer gr√∂√üeren Modularit√§t, um besser zu ‚Äûwackeln‚Äú.  In verschwindenden Frameworks wird dies sofort gel√∂st, da sie so erstellt werden, dass <b>nur der Code, den Sie anfangs ben√∂tigen, zum Bundle hinzugef√ºgt</b> wird und Ihre Aufgabe ausschlie√ülich gel√∂st wird.  Dies ist ein sehr spezifischer Fall - als ob Sie den Code mit Ihren H√§nden genau f√ºr Ihre Aufgabe geschrieben und in das Bundle eingef√ºgt h√§tten, tut dies nur das Framework f√ºr Sie. <br><br><h3>  Funktionskosten </h3><br><blockquote>  Jedes Framework hat einen Preis f√ºr eine neue Funktion. </blockquote><br>  Die Community ben√∂tigt verschiedene neue Funktionen und jedes Mitglied ben√∂tigt etwas Eigenes, und jede Funktion hat einen Preis.  In verschwindenden Frameworks wird dieses Problem auf Konzeptebene gel√∂st, da alle Funktionen, die Sie nicht verwenden, niemals in Ihr Bundle aufgenommen werden. <br>  Die Hauptfrage lautet also: K√∂nnen verschwindende Frameworks und insbesondere Svelte all diese Probleme l√∂sen?  Lass es uns richtig machen. <br><br><h2>  Bez mit Laufzeit </h2><br>  Rantime ist ein eher kurzlebiges Thema.  Es ist nicht klar, was es ist, und verschiedene Leute verstehen es unterschiedlich.  In diesem Zusammenhang werde ich die Laufzeit unter zwei Gesichtspunkten betrachten: der <b>Umgebung, in der der Code ausgef√ºhrt wird,</b> und <b>dem Code selbst</b> . <br><br><h3>  Laufzeit als Umgebung </h3><br>  Schauen wir uns ein Beispiel an.  Wenn der Code in Vanilla geschrieben ist, wird nur das DOM zur Laufzeit ben√∂tigt.  Wenn der Code in React geschrieben ist, ben√∂tigen Sie eine andere Laufzeit: DOM, React und React DOM. <br><br><blockquote>  Die kleinste Komponente Ihres Codes in React h√§ngt davon ab, in welcher Umgebung Ihr Framework arbeitet, dh von der Laufzeit. </blockquote><br><br><h3>  Laufzeit als Codeausf√ºhrung </h3><br>  Der zweite Punkt ist die Laufzeit in Bezug auf die Codeausf√ºhrung zur Laufzeit.  Schauen wir uns den heutigen grundlegenden Laufzeitfall f√ºr das Frontend an - das virtuelle DOM - einen gro√üen Teil der Laufzeit, beispielsweise in React-Anwendungen - anhand eines einfachen Beispiels: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span>Hello {world}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  In diesem HTML-Teil gibt es eine dynamische Variable.  Aus Sicht des virtuellen DOM funktioniert der Code folgenderma√üen. <br><br><ul><li>  Diese Variable wird ge√§ndert. <br></li><li>  Der virtuelle DOM-Baum im Speicher wird erstellt. <br></li><li>  Im Vergleich zur Vorg√§ngerversion. <br></li><li>  DOM-Manipulationen werden direkt durchgef√ºhrt, was letztendlich sehr effektiv ist, da wir eine Art Diff haben und genau wissen, was wir im realen DOM √§ndern m√ºssen. <br></li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/12e/082/a7e/12e082a7e3f5e596d6251c22b4016046.png"><br><br><blockquote>  Ein virtuelles DOM ist ein absoluter Overhead, da es immer so schneller ist: Sobald √Ñnderungen vorgenommen wurden, haben sie sofort √Ñnderungen am DOM vorgenommen. </blockquote><br><img src="https://habrastorage.org/getpro/habr/post_images/5f8/18a/d83/5f818ad83b71a697f3af30a4b747bdaf.png"><br><br>  Frage: Wie kann man verstehen, was sich ge√§ndert hat und was ge√§ndert werden muss?  Das virtuelle DOM l√∂st das Problem der √Ñnderungen und nicht die Geschwindigkeit dieser √Ñnderungen.  Die Geschwindigkeit wird dadurch erreicht, dass wir so viel wie m√∂glich wissen, was sich ge√§ndert hat, und das DOM effektiv manipulieren k√∂nnen. <br><br><h2>  Kompiliere es </h2><br>  Um dieses Problem zu l√∂sen, bestimmen verschwindende Frameworks einfach die √Ñnderungen in der Kompilierungsphase: Sie haben den Code geschrieben. W√§hrend der Kompilierung erstellt das verschwindende Framework alle Abh√§ngigkeiten und berechnet, welche Manipulationen im DOM erforderlich sind.  Tats√§chlich erledigt alles, was ein virtuelles DOM zur Laufzeit tut, ein verschwindendes Framework in der Erstellungszeit: Es generiert direkte Manipulationen mit dem DOM, die einfach zur Laufzeit aufgerufen werden.  Das Ergebnis ist ein Diagramm: Wenn wir √Ñnderungen vornehmen, erfolgt die Manipulation im DOM sofort. <br><br><blockquote>  Sie k√∂nnen keine ernsthaften Anwendungen in Vanille-JavaScript schreiben, ohne auf eine Komplexit√§tswand zu sto√üen.  Aber ein Compiler kann das f√ºr Sie tun. <br>  <b>Rich Harris, Sch√∂pfer von Svelte</b> </blockquote><br>  Ich erz√§hle dir, wie ich Svelte kennengelernt habe.  Wir hatten ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">interessantes Projekt</a> - ein Widget, das auf einer unbegrenzten Anzahl von Websites eingef√ºgt werden kann, obwohl wir nicht wissen, um welche Websites es sich handelt und auf welchen Ger√§ten der Benutzer sie √∂ffnen wird.  Das Widget sollte sehr klein und sehr schnell sein.  Als wir diese Aufgabe aufnahmen, haben wir nat√ºrlich sofort verstanden, was bei React oder sogar bei Vue zu tun ist, da dies eine Menge zus√§tzlichen Aufwand bedeutet. <br><br>  Wir waren fast geneigt, in Vanille zu schreiben, aber es ist schwierig und nicht immer bequem zu pflegen.  Aber wir hatten Gl√ºck - wir sind auf Svelte gesto√üen.  Die Hauptidee dieses Frameworks wird in einem Zitat angegeben: Sie k√∂nnen keine seri√∂se Anwendung auf Vanilla schreiben, da Sie schnell auf eine komplexe Wand sto√üen - es wird f√ºr das Team schwierig zu arbeiten sein, es gibt keine gemeinsamen Ans√§tze und der Compiler kann dies f√ºr Sie tun. <br><br><h3>  Wie funktioniert es? </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/822/0c9/463/8220c9463072b5a7aedd40185dfa8a70.png"><br><br>  <b>Quellcode ist ein Framework-basierter Code</b> - ein Code, der vom Framework abh√§ngt.  Alles ist wie gewohnt: Es gibt eine Dokumentation, Sie schreiben den Code so, als ob Sie ein anderes Framework verwenden, das eine Art API, Prinzipien und Ans√§tze hat.  Alles wie gew√∂hnlich. <br><br>  Zur Erstellungszeit wird dieser Code kompiliert.  Infolgedessen liegt Vanilla JS im Bundle, und wie gesagt, genau der Code, der zum Ausf√ºhren Ihrer Anwendung ben√∂tigt wird, kommt genau dort an.  Wenn Sie in zwei Minuten dort eine weitere neue Funktion hinzuf√ºgen oder eine neue Funktion aus dem Framework verwenden, f√ºgt Svelte sie dort hinzu und sie wird auch in das Bundle aufgenommen.  Andernfalls wird dies nicht passieren. <br><br>  Lassen Sie uns die Schritte genauer betrachten.  Der erste Schritt ist die <b>Komponente</b> .  Betrachten Sie die gleiche Komponente. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span>Hello {world}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Im zweiten Schritt - <b>AST</b> - wird der Code in einem abstrakten Syntaxbaum erzeugt. <br><br><pre> <code class="xml hljs">{"type": "Element", "name": "h1", "children": [{ "type": "Text", "data": "Hello",....}]}</code> </pre><br>  Der dritte Schritt ist die <b>DOM-API</b> .  Auf Basis des Baums wird der Code direkt generiert, der f√ºr den Betrieb dieser Komponente erforderlich ist.  Der Code ist sehr einfach, hier gibt es im Prinzip keine komplizierten Laufzeiten und Abstraktionen. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">changed, ctx</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (changed.name) { text_1.data = ctx.name; } }</code> </pre><br>  Geben Sie am Ende des Artikels in der Umfrage an, ob Ihnen die Idee der AOT-Kompilierung des Svelte-Frameworks gef√§llt.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beim letzten Mal</a> sprach <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die</a> Mehrheit positiv. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5aa/be9/d8e/5aabe9d8e0bd77fef1a1ed0e1844ac91.png"><br><br>  Nun wollen wir sehen, was Svelte ist. <br><br><h2>  Svelte </h2><br>  Das englische Wort svelte oder svelt bedeutet "schlank, flexibel".  Svelte JS ist! <br><br>  Ich behaupte, dass dies kein ‚Äûweiteres JS-Framework‚Äú ist, da es sich um ein <b>UI-Framework zur Build-Zeit handelt</b> .  Regelm√§√üige Frameworks funktionieren zur Laufzeit, und Svelte existiert nur, bevor wir es kompiliert haben. <br><br>  Dies ist ein <b>statischer Analysator zur Kompilierungszeit</b> oder ein statischer Code-Analysator, der den Code w√§hrend der Kompilierung durchl√§uft, ihn statisch analysiert und auf dieser Grundlage das entsprechende endg√ºltige B√ºndel generiert. <br><br>  Dies ist ein <b>vorzeitiger Compiler</b> - ein AOT-Compiler, der alles kann. <br><br>  Der Sch√∂pfer des Rich Harris-Frameworks, das Sie aus Tools wie Rollup, Ractive, Buble - einem Analogon von Babel - kennen, ist ein cooler Typ.  Meiner Meinung nach ist das gleiche Rollup immer noch die beste Implementierung zum Sch√ºtteln von B√§umen.  Es erschien viel fr√ºher als in Webpack und funktioniert immer noch besser.  Harris baute das Svelte-Framework urspr√ºnglich mit Tree-Shaking, Code-Splitting und anderen modernen Ans√§tzen. <br><br><blockquote>  Svelte ist ein Tool zum Schreiben von Vanilla JS, ohne Vanilla JS schreiben zu m√ºssen. </blockquote><br>  Schauen wir uns diesen Rahmen von innen an. <br><br><h3>  Einzelne Dateikomponente </h3><br>  <b>Svelte ist eine Einzeldateikomponente</b> .  Wenn Sie mit Vue gearbeitet haben, wird es Sie sehr an dieses Framework erinnern, aber es ist kein Zufall.  Die Syntax, die Vue haupts√§chlich verwendet, leitet sich aus dem Ractive-Framework ab, das Harris bereits 2012 erstellt hat.  Dieses Framework wurde leider nicht popul√§r, wie es mir scheint, weil es in 1.0 zu sp√§t ver√∂ffentlicht wurde.  Sie waren so durcheinander mit den Versionen, dass Ractive 6 Jahre lang in Nebenversionen war. <br><br>  Vue hat von dort viele Schnittstellen ausgeliehen, und Svelte ist der Nachfolger von Ractive.  Daher scheint es Ihnen, dass alles √§hnlich ist, aber 2013 wurden in Ractive Einzeldateikomponenten ver√∂ffentlicht.  Sie sehen ein bisschen anders aus, aber insgesamt - es sieht aus.  Jede Komponente, die Sie in Svelte schreiben, sieht ungef√§hr so ‚Äã‚Äãaus. <br><br><pre> <code class="plaintext hljs">&lt;h1 &gt;Hello {world}!&lt;/h1 &gt; &lt;script&gt; export default { /* component behaviour */ }; &lt;/script&gt; &lt;style&gt;    /* scoped styles */ &lt;/style&gt;</code> </pre> <br>  Oben ist eine bestimmte HTML-Vorlage - einfaches HTML ohne Ausnahmen.  Das einzige, was noch dazu kommt, ist eine bestimmte Vorlagensprache namens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HTMLx</a> .  Ich werde dir sp√§ter mehr √ºber ihn erz√§hlen. <br><br>  Als n√§chstes kommt das Skript, in das wir das Verhalten unserer Komponente schreiben.  Wie man es schreibt, ist in der Anleitung beschrieben.  Dort k√∂nnen Sie verschiedene Funktionen und Methoden importieren, erstellen - alles wie in Vue. <br><br>  Sie k√∂nnen den G√ºltigkeitsbereich verwenden, um isolierte Komponentenstile aus der Box abzurufen.  Das funktioniert so: In der Hauptkompilierung wird ein Hash generiert, wodurch ein Shadow-DOM emuliert wird. <br><br>  Keiner der Abschnitte ist erforderlich, daher kann eine Komponente nur aus einem HTML-Code bestehen. <br><br><h3>  HTMLx-Syntax </h3><br>  Wie bei jedem HTML-Code werden Daten in Klammern geschrieben. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span>Say hello {name}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  So werden bedingte Anweisungen geschrieben. <br><br><pre> <code class="xml hljs">{#if name} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span>Say hello {name}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> {/if}</code> </pre> <br>  Aufz√§hlungen und Schleifen: <br><pre> <code class="xml hljs">{#each users as { name, email}} {#if name} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span>Say hello {name}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> {/if} {/each}</code> </pre> <br>  Sie k√∂nnen Anweisungen verwenden, um Ereignisse abzufangen und die Daten doppelt zu binden. <br><br><pre> <code class="xml hljs">{#each users as { name, email}} {#if name} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">on:click</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"say(name)"</span></span></span><span class="hljs-tag">&gt;</span></span>Say hello {name}<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> {/if} {/each}</code> </pre> <br>  In HTMLx gibt es nur sehr wenige Anweisungen - nur 4-5 Arten, und es gibt keine benutzerdefinierten Anweisungen wie in Angular. <br><br>  Sie k√∂nnen beliebige dynamische Daten in beliebige Attribute verschieben, dies ist kein Problem. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">= </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{dynamic}"</span></span></span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"used"</span></span></span><span class="hljs-tag">&gt;</span></span> {#each users as { name, email}} {#if name} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">on:click</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"say(name) "</span></span></span><span class="hljs-tag"> &gt;</span></span>Say hello {name}<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> {/if} {/each} <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h3>  Isolierte Stile und Entfernen von nicht verwendeten </h3><br>  Wenn Sie isolierte Stile verwenden, werden nicht verwendete Stile nicht nur isoliert, sondern auch automatisch geschnitten. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">= </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{dynamic}"</span></span></span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"used"</span></span></span><span class="hljs-tag">&gt;</span></span> {#each users as { name, email}} {#if name} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">on:click</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"say(name) "</span></span></span><span class="hljs-tag"> &gt;</span></span>Say hello {name}<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> {/if} {/each} <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span> .used {...} .unused {...} <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Wenn der Stil <code>used</code> , wird er verwendet, und wenn der Stil <code>unused</code> , befindet er sich nicht im Bundle.  Der Rahmen wird alles schneiden, aber ordentlich.  Daher kann diese Funktion leicht unterbrochen werden, wenn Sie viel Dynamik verwenden.  Svelte wird denken: "Ich ber√ºhre besser nicht" - und gehen.  Man muss vorsichtig sein, aber es ist sehr praktisch.  Da Svelte √ºber einen statischen Analysator verf√ºgt, wird beim Start in der Konsole angezeigt, welche Stile nicht verwendet werden.  Wenn Sie sie wirklich nicht ben√∂tigen, k√∂nnen Sie sie sofort entfernen. <br><br><h3>  Zusammensetzung der Komponenten </h3><br>  Hier ist alles wie gewohnt: Wir importieren die Datei, registrieren sie in den Komponenten und verwenden sie als Tag. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Nested</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">foo</span></span></span><span class="hljs-tag">= </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"static"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">bar</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{dynamic}</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">bind:baz</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">baz</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="javascript"><span class="javascript"> </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">import</span></span></span><span class="javascript"> Nested </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">from</span></span></span><span class="javascript"> </span><span class="hljs-string"><span class="javascript"><span class="hljs-string">'Nested.html'</span></span></span><span class="javascript">;</span><span class="hljs-string"><span class="javascript"><span class="hljs-string">' export default {   components: {Nested} }; </span></span></span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Sie k√∂nnen alle Daten √ºber die Attribute √ºbertragen, doppelte Bindung verwenden.  Oder nicht zu verwenden - Doppelbindung ist optional, kann sogar auf Compilerebene deaktiviert werden und wird nirgendwo anders sein.  Dies ist f√ºr diejenigen, die keine Bindungen m√∂gen.  Bindungen werden mit der Direktive <code>bind:</code> . <br><br><h3>  Zus√§tzliche Funktionen von Svelte </h3><br>  Die ersten beiden M√∂glichkeiten sind: <b>SSR &amp;</b> Hydration - Server-Rendering und -Hydratation sowie <b>integriertes Statusmanagement</b> - integriertes globales Statusmanagement basierend auf unserer eigenen L√∂sung, dem sogenannten Store. <br><br>  Im Prinzip k√∂nnen Sie Redux verwenden, was viele tun: diejenigen, die an Redux gew√∂hnt sind, verwenden es mit Svelte.  Es gibt jedoch eine einfachere interne L√∂sung, die tief integriert ist. Wenn Sie sie im Gesch√§ft registrieren, ist sie sofort in allen Komponentenhierarchien verf√ºgbar - √ºberhaupt keine Manipulationen.  Die einzige Verwendung ist die Verwendung des Pr√§fixes <code>$</code> dh alle Methoden oder Speicherdaten werden mit diesem Pr√§fix geschrieben.  <code>$</code> kann in beliebigen Vorlagen verwendet werden. <br><br>  Der Store hat eine interessante Funktion, die ich sonst nirgends gesehen habe - er erstreckt sich global auf eine Hierarchie von Komponenten.  Wenn Sie beispielsweise eine Root-Komponente haben, wird diese in dieser Hierarchie verwendet.  Wenn Sie irgendwo in dieser Hierarchie ein anderes Gesch√§ft haben, erstreckt sich dieses Gesch√§ft auf die gesamte untere Hierarchie. <br><br>  Dies ist praktisch, wenn Sie eine gro√üe komplexe Komponente mit vielen Unterkomponenten erstellen und diese dann in verschiedenen Projekten verwenden m√∂chten, von denen einige Redux enthalten und andere nicht.  Wenn Sie regul√§re Stores mit Redux verwenden, m√ºssen Sie sicherstellen, dass das Projekt, in dem Sie es hinzuf√ºgen, Redux enth√§lt.  Dies muss hier nicht erfolgen - Svelte implementiert einen eigenen Speicher f√ºr diese Hierarchie.  Es kann problemlos auch auf Projekte √ºbertragen werden, in denen es √ºberhaupt keinen globalen Speicher gibt.  Du hast es mitgebracht und Svelte macht schon alles drinnen. <br><br>  <b>Benutzerdefinierte Elemente werden sofort unterst√ºtzt</b> .  Es gibt eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">spezielle Site,</a> auf der die Unterst√ºtzung durch Frameworks des Web Components-Standards getestet wird.  Laut Tests unterst√ºtzt Svelte benutzerdefinierte Elemente zu 100%.  Dies funktioniert folgenderma√üen: Der Tag-Name wird angegeben, das Flag "customElement: true" wird im Compiler gesetzt und ein benutzerdefiniertes Element wird generiert, das alle vorhandenen Svelte-Funktionen unterst√ºtzt. <br><br>  <b>Sapper - Svelte App Maker</b> .  Dies ist ein Analogon von Next.js und Nuxt.js f√ºr Vue.  Im Prinzip ist alles gleich: Isomorphismus, Unterst√ºtzung f√ºr Code-Splitting, Prefetching und Offline-Out-of-the-Box und andere Funktionen.  Meiner Meinung nach kamen k√ºrzlich sogar einige der Routing-Ideen von Sapper zu Next.js. <br><br>  Aber nicht ein einziger Svelte tut dies.  Wir sind f√ºr fairen Wettbewerb! <br><br><h2>  Wer sonst? </h2><br>  <b>Stencil</b> ist ein Framework von Ionic-Entwicklern.  Sie arbeiten auch an einem kompilierten Framework, wobei der Schwerpunkt jedoch auf Webkomponenten und benutzerdefinierten Elementen liegt.  Svelte unterscheidet sich davon darin, dass seine Komponenten normalerweise in regul√§re JS-Klassen kompiliert werden und dass Webkomponenten keine Verzerrung aufweisen. <br><br>  <b>Glimmer</b> - Ich denke, jeder kennt dieses Projekt.  Es wird hier nur vorgestellt, weil es auch kompiliert: Es hat einen eigenen Bytecode, eine eigene virtuelle Maschine, die offensichtlich zus√§tzliche Optimierungen f√ºr den endg√ºltigen Code bietet. <br><br>  <b>Marko von eBay</b> .  Ich habe es nicht im Detail studiert, aber sie kompilieren auch, nicht sicher, was so tief ist wie Svelte.  Es stimmt, ich habe es nicht im Detail verstanden und k√∂nnte mich irren. <br><br>  <b>Winkelig</b>  Es gibt hier einen AOT-Compiler, der gut beworben wird, aber es ist nur eine Neukompilierung von Zeichenfolgenvorlagen in einer vorgefertigten sortierten Form im Voraus.  Soweit ich wei√ü, gibt es dort noch keine vollst√§ndige AoT-Zusammenstellung. <br><br><h2>  Hallo Filme </h2><br>  Ich habe eine kleine Anwendung geschrieben - eine Liste von Filmen mit Filtern, die auf der TMDb-API basieren.  Es hat Kategorien: beliebt, am besten bewertet, bevorstehend.  Sie k√∂nnen durch die Seiten gehen, ein Land ausw√§hlen, Filter daf√ºr anwenden und die Sprache √§ndern.  Diese primitive Anwendung ben√∂tigt nur 6,4 Kb. <br><br>  Insgesamt besteht HELLO MOVIES nur aus 172 Codezeilen zusammen mit HTML, davon 36 Zeilen JS-Code, zusammen mit allen Arten von Anf√ºhrungszeichen.  Dies ist der gesamte Code, den ich pers√∂nlich geschrieben habe.  Nat√ºrlich wird all dies auf ein viel gr√∂√üeres Volumen kompiliert, aber f√ºr mich als Entwickler spielt es keine Rolle. <br><br>  Noch ein paar Indikatoren.  "TodoList MVC" auf Svelte ben√∂tigt 3,6 Kb - es h√§ngt davon ab, wer es sagt, aber selbst auf Vanilla dauert es 11 Kb und auf Vue und React noch mehr - 80 bzw. 300 Kb.  Das Projekt "RealWorld", ein Klon von Medium, mit Registrierung, Konten, Likes, Shares, Freunden - 40 Kb, auf React and Angular - 211 und 575 Kb.  Der Klon von "HackerNews" auf Svelte ist 30 KB gro√ü, auf React and Vue - mehrmals mehr. <br><br><h2>  Benchmarks </h2><br>  Wir alle lieben Hollichivat zum Thema Benchmarks.  Ich habe den ber√ºhmten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Krausest-</a> Benchmark verwendet.  Sie denken wahrscheinlich, dass ich jetzt die Ergebnisse zeigen werde, bei denen Svelte alle in St√ºcke rei√üt und Inferno nur beiseite weint.  Das wird aber nicht passieren. <br><br><img src="https://habrastorage.org/webt/3r/xz/4_/3rxz4_c2qbhoczgeo8yzr_kbg8s.jpeg"><br><br>  Ich habe Svelte in den letzten Versionen mit den Big Three - Angular, React und Vue verglichen.  Infolgedessen identifizierte er die ersten beiden Positionen in Bezug auf Vanille.  Und hier sind die Zahlen nicht so wichtig wie die Hauptidee, n√§mlich dass <b>Svelte sehr ausgeglichen ist</b> . <br><br>  Svelte strebt nach Ausgewogenheit - <b>es ist in jeder Hinsicht in jeder Hinsicht gut</b> .  In gewisser Weise √ºberholt Svelte sogar Vanilla, in einigen F√§llen dauert es die erste, aber irgendwo √ºberholt es Vue und Angular.  In allen Tests verbrauchen Angular und Vue jedoch viel Speicher, Svelte jedoch nicht.        ,    ,       .   ‚Äî . <br><br>  Svelte     ‚Äî    .  ,    . <br><br><h2> - ‚Äî   ! </h2><br>  Svelte   New York Times.    . ,      Svelte, ,   legacy-  CMS,       .     ,     ,    . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/080/9a3/6c8/0809a36c8b7f7d9d4eb9e18fe3d3bfa2.png"><br><br> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> -</a>   ¬´ ¬ª ‚Äî  ,  Drag&amp;Drop.       Svelte,    . <br><br>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Soft-Gear</a>    ,     ,  Svelte.   ,         -     . <br><br>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">airca.st</a>    Svelte.    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dabble</a>   Svelte.    -  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">i-want-to-ride-an-electric-citi</a>        Svelte. <br><br>      . ,   RuTube.       Smart TV   Tizen,    Samsung.     Tizen  Smart TV     Svelte.      ,    . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/46c/154/f5d/46c154f5d392f46698fb5a03e4234adc.png"><br><br><h2>   </h2><br><br> <b>  standalone vanilla JavaScript  </b> .     ,      ,  overhead . <br><br> <b>    </b> .  Svelte       DOM.    . <br><br> <b>  </b> .  ,     Vue,   Svelte  .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">REPL</a> ,         ,     . <br><br> <b>      </b> .   ,      ‚Äî    ,         .       ,   . <br><br> <b>Code-splitting &amp; tree-shaking</b> .         code-splitting  tree-shaking.         .     ,          . <br><br> <b>Micro-frontends ready</b> .     -.      ,    ,        PHP,    Svelte-. ,      .      ,          .        code-splitting  tree-shaking. <br><br><h2>   </h2><br><br> <b>Svelte  ,   </b> .      2016 .          . <br><br> <b> </b> .  ,              .         . ,  ,   ,    ,     ,     Vue. <br><br> <b>  </b> .  React  Facebook, Angular ‚Äî Google, Vue    ,      Rich Harris   ,            . <br><br><blockquote>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Frontend Conf</a>   ++      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> ,  ,    .   33       .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>              ++ 27  28 . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de450822/">https://habr.com/ru/post/de450822/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de450812/index.html">PSR-14 - das Hauptereignis in PHP</a></li>
<li><a href="../de450814/index.html">Wie BGP funktioniert</a></li>
<li><a href="../de450816/index.html">HTTP-Header f√ºr den verantwortlichen Entwickler</a></li>
<li><a href="../de450818/index.html">Von der hohen Ceph-Latenz zum Kernel-Patch mit eBPF / BCC</a></li>
<li><a href="../de450820/index.html">FrontendConf-Programmkomitee: Rahmenbedingungen, Horizonte, Welterfahrung und Mission der Konferenz</a></li>
<li><a href="../de450824/index.html">Der Zustand von CSS</a></li>
<li><a href="../de450826/index.html">Wie man mit dem Mikrocontroller von JS spricht</a></li>
<li><a href="../de450828/index.html">Wenn die Stadt einschl√§ft ...</a></li>
<li><a href="../de450830/index.html">Nikita Dubko √ºber Konferenzen, Betrugssyndrom und Berichterstattung</a></li>
<li><a href="../de450832/index.html">Die Geschichte einer Animation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>