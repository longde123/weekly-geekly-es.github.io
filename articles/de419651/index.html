<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍳 👁‍🗨 🕓 Weder GA noch YM. Wie wir unseren eigenen Clickstream gemacht haben 😂 💥 👩🏽‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir sammeln täglich mehr als zwei Milliarden analytische Ereignisse. Dank dessen können wir eine Reihe notwendiger Dinge herausfinden: ob sie mehr auf...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Weder GA noch YM. Wie wir unseren eigenen Clickstream gemacht haben</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/avito/blog/419651/"><p>  Wir sammeln täglich mehr als zwei Milliarden analytische Ereignisse.  Dank dessen können wir eine Reihe notwendiger Dinge herausfinden: ob sie mehr auf die Herzen als auf die Sterne klicken, zu welchen Stunden sie detailliertere Beschreibungen schreiben, in welchen Regionen sie häufig die grünen Knöpfe übersehen. </p><br><p>  Das Ereigniserfassungs- und -analysesystem kann allgemein als Clickstream bezeichnet werden.  Ich erzähle Ihnen etwas über die technische Seite des Clickstreams in Avito: die Anordnung von Ereignissen, deren Versand und Zustellung, Analysen und Berichte.  Warum wollen Sie Ihre eigenen, wenn es Google Analytics und Yandex.Metrica gibt, die Clickstream-Entwickler das Leben verderben und warum Go-Codierer PHP nicht vergessen können? </p><br><p><img src="https://habrastorage.org/webt/b_/yj/uz/b_yjuzzjoz1p2bhzpwnnubrhrt0.png"></p><a name="habracut"></a><br><h1 id="obo-mne">  Über mich </h1><br><p>  Dmitry Khasanov, zehn Jahre in der Webentwicklung, drei Jahre in Avito.  Ich arbeite in einem Plattformteam und entwickle gemeinsame Infrastruktur-Tools.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ich liebe Hackathons</a> . </p><br><h1 id="zadacha">  Herausforderung </h1><br><p>  Das Geschäft erfordert ein tiefes Verständnis der Prozesse auf der Website.  Wenn ich beispielsweise einen Benutzer registriere, möchte ich wissen, aus welcher Region, von welchem ​​Gerät und über welchen Browser sich der Benutzer angemeldet hat.  Wie die Formularfelder ausgefüllt werden, ob sie gesendet wurden oder der Benutzer aufgegeben hat.  Und wenn Sie aufgegeben haben, bei welchem ​​Schritt.  Und wie lange es gedauert hat. </p><br><p> Ich würde gerne wissen, ob sie öfter auf die Schaltfläche klicken, wenn sie grün gestrichen ist.  Wird der grüne Knopf in Murmansk oder in Wladiwostok Tag und Nacht von Benutzern mobiler Anwendungen oder der Website häufiger gedrückt?  Benutzer, die von der Haupt- oder von der Suche kamen;  wer hat vorher bei Avito gekauft oder wer ist zum ersten Mal gekommen. </p><br><p>  Alle diese Zeichen: Betriebssystem, Benutzer-ID, Anforderungszeit, Gerät, Browser, Werte in den Feldern - müssen für die Analyse zur Verfügung gestellt werden.  Sammeln, strukturieren, schnellen Zugriff auf Daten gewähren. </p><br><p>  Darüber hinaus ist es häufig erforderlich, den Ereignisfluss aufzuteilen.  Projekte müssen Maßnahmen ergreifen, wenn bestimmte Ereignisse eintreten.  Auf diese Weise wird beispielsweise eine Rückmeldung erhalten, um das Modell für die Mustererkennung und automatische Moderation neu zu trainieren, und es werden Echtzeitstatistiken erstellt. </p><br><p>  Mit Clickstream als Produkt sollte es Programmierern leicht fallen, Ereignisse aus einem Projekt zu senden, und Analysten sollten es ermöglichen, gesammelte Ereignisse zu verwalten und eine Vielzahl von Berichten zu erstellen, die Trends und unterstützende Hypothesen zeigen. </p><br><p>  <strong>Berichte basierend auf dem Ereignisfluss.</strong> <br>  <strong>Beispiel 1</strong> <br><img src="https://habrastorage.org/webt/lt/vt/e3/ltvte3vhpz37df89hbwurg1gjno.png"></p><br><p>  <strong>Beispiel 2</strong> <br><img src="https://habrastorage.org/webt/bl/he/wc/blhewctbesnuyilsxv4zozn7tlu.png"></p><br><h1 id="gotovye-instrumenty">  Fertige Werkzeuge </h1><br><p>  Wir kennen Yandex Metric und Google Analytics und verwenden es für einige Aufgaben.  Mit ihrer Hilfe ist es gut und schnell, analytische Daten von den Frontends zu sammeln.  Um Daten aus Backends in externe Analysesysteme zu exportieren, müssen Sie jedoch schwierige Integrationen durchführen. </p><br><p>  Mit externen Tools müssen Sie das Problem der Aufteilung des Ereignisflusses unabhängig lösen. </p><br><p>  Analytische Informationen sind sehr wertvoll.  Wir sammeln es seit Jahren und können so detailliert wissen, wie sich unsere Benutzer verhalten.  Ich möchte dieses Wissen nicht mit der Außenwelt teilen. </p><br><p>  Die Gesetzgebung verpflichtet, Daten auf dem Territorium Russlands zu speichern. </p><br><p>  Diese Gründe reichten völlig aus, um unsere eigene Lösung als Hauptwerkzeug für die Erfassung und Verarbeitung von Analysedaten zu entwickeln. </p><br><h1 id="reshenie">  Lösung </h1><br><p>  Ereignisse werden über einen Hochleistungstransport (Event Streaming Processing, ESP) im Speicher (Data Warehouse, DWH) ausgelöst.  Basierend auf den Daten im Repository werden Analyseberichte erstellt. </p><br><h3 id="sobytie">  Ereignis </h3><br><p>  Zentrale Einheit.  An sich bedeutet es Tatsache.  In der angegebenen Zeiteinheit ist etwas Konkretes passiert. </p><br><p>  Es ist notwendig, ein Ereignis von einem anderen zu unterscheiden.  Dies ist die eindeutige Kennung des Ereignisses. </p><br><p>  Interessiert sich auch für den Zeitpunkt des Auftretens von Ereignissen.  Wir senden es in jedem Fall mit einer Genauigkeit von Mikrosekunden.  Bei Ereignissen, die von den Frontends eingehen, legen wir zusätzlich die Zeit auf dem Clientgerät fest, um die Abfolge der Aktionen genauer wiederherzustellen. </p><br><h3 id="pole">  Das Feld </h3><br><p>  Ein Ereignis besteht aus Feldern.  Feld ist die kleinste semantische Einheit des analytischen Systems.  Im vorherigen Absatz gibt es Beispiele für Felder: Ereigniskennung, Sendezeit. </p><br><p>  Feldattribute: Typ (Zeichenfolge, Nummer, Array), obligatorisch. </p><br><h3 id="okruzhenie">  Die Umwelt </h3><br><p>  Das gleiche Ereignis kann in verschiedenen Teilen des Systems auftreten: Beispielsweise ist eine Autorisierung auf der Site oder in einer mobilen Anwendung möglich.  In diesem Fall senden wir dasselbe Ereignis, fügen jedoch immer die eindeutige Kennung der Ereignisquelle hinzu. </p><br><p>  Quellen unterscheiden sich merklich voneinander.  Dies können interne Dämonen und Kronen, ein Frontend- oder Backend-Service oder eine mobile Anwendung sein.  Ein Teil der Felder muss mit jedem Ereignis einer bestimmten Quelle gesendet werden. </p><br><p>  Es gibt das Konzept der "Umwelt".  Dies ist eine logische Gruppierung von Ereignissen nach Quelle mit der Möglichkeit, gemeinsame Felder für alle Quellenereignisse festzulegen. </p><br><p>  Beispiele für Umgebungen: "Backend von Service A", "Frontend von Service A", "ios-Anwendung von Service A". </p><br><h3 id="spravochnik-sobytiy">  Ereignisverzeichnis </h3><br><p>  Alle vorhandenen Ereignisse werden in einem Verzeichnis beschrieben, das Entwickler und Analysten bearbeiten können.  Ereignisse werden logisch nach Umgebung gruppiert, jedes Ereignis hat einen Eigentümer, ein Protokoll der Änderungen im Verzeichnis wird geführt. </p><br><p>  Derzeit beschreibt das Verzeichnis mehrere hundert Felder, mehrere zehn Umgebungen und mehr als tausend Ereignisse. </p><br><h3 id="langpak">  Langpack </h3><br><p>  Wir haben Folter abgelehnt und Entwickler nicht länger gezwungen, den Code für den Ereignisversand manuell zu schreiben.  Stattdessen generieren wir basierend auf dem Verzeichnis eine Reihe von Dateien für jede der von der Firma unterstützten Serversprachen: PHP, Go oder Python.  Ein solcher generierter Code wird als "Langpack" bezeichnet. </p><br><p>  Die Dateien im Langpack sind so einfach wie möglich, sie kennen die Geschäftslogik der Projekte nicht.  Dies ist eine Reihe von Gettern und Feldsetzern für jedes der Ereignisse und ein Code zum Senden des Ereignisses. </p><br><p>  Für jede Umgebung wird ein Langpack erstellt.  Es zerfällt in ein Paket-Repository (satis für PHP, Pypi für Python).  Es wird automatisch aktualisiert, wenn Änderungen am Verzeichnis vorgenommen werden. </p><br><p>  Sie können nicht aufhören, in PHP zu schreiben.  Der Code für den Dienst, der die Langpacks generiert, ist in Go geschrieben.  Das Unternehmen hat genug PHP-Projekte, daher musste ich mich an meine Lieblings-Programmiersprache mit drei Buchstaben erinnern und PHP-Code auf Go generieren.  Wenn Sie ein wenig mitgerissen werden, können Sie auch Tests generieren, um den generierten Code mit diesen Tests zu testen. </p><br><h3 id="versionirovanie">  Versionierung </h3><br><p>  Referenz kann bearbeitet werden.  Der Code im Kampf kann nicht gebrochen werden.  Wir generieren den Kampfcode basierend auf dem Verzeichnis.  Gefährlich. </p><br><p>  Nach jeder Änderung des Ereignisses wird eine neue Version im Verzeichnis erstellt.  Alle jemals erstellten Versionen von Ereignissen leben für immer im Verzeichnis.  Wir lösen also das Problem der Unveränderlichkeit bestimmter Ereignisse.  Projekte geben immer an, mit welcher Version des Ereignisses wir arbeiten. </p><br><p>  Wenn sich der Langpack-Code ändert (zum Beispiel gab es nur Setter, aber jetzt haben wir auch beschlossen, Getter hinzuzufügen), erstellen Sie eine neue Version des Langpacks.  Sie wird auch für immer leben.  Projekte fragen immer nach einer bestimmten Version des Langpacks für ihre Umgebung.  Wir lösen also das Problem der Invarianz der Langpack-Schnittstelle. </p><br><p>  Wir benutzen Semver.  Die Version jedes Langpacks besteht aus drei Zahlen.  Der erste ist immer Null, der zweite ist die Version des Langpack-Codes, der dritte ist das Inkrement.  Die dritte Ziffer ändert sich am häufigsten nach jeder Änderung von Ereignissen. </p><br><p>  Mit der zweistufigen Versionierung können Sie das Verzeichnis bearbeiten, ohne den Code im Kampf zu beschädigen.  Es basiert auf zwei Prinzipien: Sie können nichts löschen;  Sie können erstellte Entitäten nicht bearbeiten, sondern nur geänderte Kopien nebeneinander erstellen. </p><br><h3 id="transport">  Transport </h3><br><p>  Im Gegensatz zu den Jungs von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Badoo auf LSD</a> haben wir nie gelernt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, Dateien schön zu schreiben</a> .  Und wir glauben, dass NSQ nicht nur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Warteschlangenserver ist</a> , sondern auch ein Transport für Ereignisse. </p><br><p>  Sie versteckten NSQ hinter einer kleinen Schicht Go-Code, legten mithilfe von Daemon-Sets Kollektoren für jeden Knoten im Kubernetes-Cluster an und schrieben Konsumenten, die Ereignisse zu verschiedenen Quellen hinzufügen können. </p><br><p>  Derzeit liefert der Transport täglich rund zwei Milliarden Veranstaltungen.  Unter einer solchen Last arbeiten dreißig Sammler mit einem gewissen Spielraum.  Jeder verbraucht etwas mehr Prozessorkern und etwas mehr als ein Gigabyte Speicher. </p><br><h3 id="routing-sobytiy">  Ereignisrouting </h3><br><p>  Event-Absender können Projekte sein, die innerhalb oder außerhalb unseres Clusters leben.  Innerhalb von Clustern sind dies Service-Backends, Crowns, Daemons, Infrastrukturprojekte und ein Intranet.  Draußen kommen Veranstaltungen von den Frontends öffentlicher Projekte, von mobilen Anwendungen und Partnerprojekten. </p><br><p>  Um Ereignisse außerhalb des Clusters zu empfangen, verwenden wir einen Proxy.  Ein gemeinsamer Einstiegspunkt mit einer kleinen Filterung des Ereignisflusses mit der Möglichkeit ihrer Anreicherung.  Weiteres Versenden an den Transport gemäß dem allgemeinen Schema. </p><br><p>  Allgemeines Routing-Schema: Jedes Ereignis kann eine Reihe von Empfängern haben.  Mögliche Empfänger sind ein Shared Analytic Repository (DWH), Rebbits oder Monga-Projekte, die an bestimmten Ereignissen interessiert sind.  Der letztere Fall wird beispielsweise verwendet, um die automatischen Moderationsmodelle von Anzeigen neu zu trainieren.  Models hören sich bestimmte Ereignisse an und erhalten das notwendige Feedback. </p><br><p>  Von Seiten der Projekte gibt es keine Kenntnisse über das Routing.  Sie senden Ereignisse mit Langpacks, in die Adressen gängiger Sammler eingenäht sind. </p><br><h3 id="hranilische">  Lagerung </h3><br><p>  Das Hauptereignis-Repository ist HP Vertica, einige Dutzend Terabyte.  Eine Spaltenbasis mit Funktionen, die für unsere Analysten geeignet sind.  Schnittstelle - Tableau für die Berichterstellung. </p><br><p>  Es ist effizienter, Ereignisse in unserem Speicher in großen Mengen aufzuzeichnen.  Vor dem Speicher befindet sich ein Puffer in Form von Mongo.  Automatisch erstellte automatische Löschsammlungen für jede Stunde.  Sammlungen werden mehrere Tage gespeichert, um das Korrekturlesen in Vertica neu starten zu können, wenn etwas schief geht. </p><br><p>  Auslesen aus Puffer Mongo auf Haustier-Skripten.  Skripte werden von einer Referenz geleitet. Wir versuchen, die Geschäftslogik hier nicht beizubehalten.  In dieser Phase ist eine Ereignisanreicherung möglich. </p><br><h1 id="evolyuciya">  Evolution </h1><br><h3 id="ruchnye-tancy-v-temnote">  Hand tanzt im Dunkeln </h3><br><p>  Die Notwendigkeit, Ereignisse zu protokollieren, trat viel früher auf als das Bewusstsein, dass ein Verzeichnis gepflegt werden muss.  Die Entwickler in jedem der Projekte haben eine Möglichkeit gefunden, Ereignisse zu senden und nach Transportmitteln zu suchen.  Dies erzeugte viel Code in verschiedenen Sprachen, der in verschiedenen Projekten lag, aber ein Problem löste. </p><br><p>  Oft lebten im Ereignisversandcode Teile der Geschäftslogik weiter.  Code mit diesem Wissen kann nicht auf andere Projekte portiert werden.  Beim Refactoring muss die Geschäftslogik an das Projekt zurückgegeben werden, sodass im Ereigniscode nur das angegebene Datenformat eingehalten wird. </p><br><p>  Zu diesem Zeitpunkt gab es kein Verzeichnis der Ereignisse.  Um zu verstehen, welche Ereignisse bereits protokolliert werden, welche Felder die Ereignisse hatten, war es nur möglich, in den Code zu schauen.  Um zu erfahren, dass der Entwickler versehentlich aufgehört hat, Daten in das erforderliche Feld zu schreiben, war es beim Erstellen des Berichts möglich, wenn Sie dies besonders beachten. </p><br><p>  Es gab nicht viele Ereignisse.  Puffersammlungen in Mongos wurden nach Bedarf hinzugefügt.  Mit zunehmender Anzahl von Ereignissen war es erforderlich, Ereignisse manuell in andere Sammlungen umzuleiten, um die erforderlichen Sammlungen zu erstellen.  Die Entscheidung, das Ereignis in einer bestimmten Puffersammlung zu platzieren, wurde zum Zeitpunkt des Sendens auf der Projektseite getroffen.  Der Transport war fließend, der Kunde dafür war td-agent. </p><br><h3 id="osvedomlyonnyy-rassinhron">  Bewusst asynchron </h3><br><p>  Es wurde beschlossen, ein Verzeichnis aller vorhandenen Ereignisse zu erstellen.  Wir haben den Code der Backends analysiert und einige Informationen von dort abgerufen.  Wir haben die Entwickler verpflichtet, dies bei jeder Änderung des Ereigniscodes im Verzeichnis zu vermerken. </p><br><p>  Ereignisse, die von den Frontends und von mobilen Anwendungen ankommen, wurden manuell beschrieben, wobei manchmal die erforderlichen Informationen aus dem Ereignisstrom auf Transportebene abgerufen wurden. </p><br><p>  Entwickler wissen zu vergessen.  Dies führte zu einer Desynchronisation des Verzeichnisses und des Codes, aber das Verzeichnis zeigte das allgemeine Bild. </p><br><p>  Die Anzahl der Puffersammlungen ist erheblich gestiegen, die manuelle Arbeit zu deren Wartung hat erheblich zugenommen.  Eine unersetzliche Person erschien mit einer Menge geheimer Kenntnisse über den Pufferspeicher. </p><br><h3 id="novyy-transport">  Neuer Transport </h3><br><p>  Sie erstellten einen gemeinsamen Transport, ESP, der alle Ereignisübermittlungspunkte kennt.  Sie machten es zu einem einzigen Empfangspunkt.  Dies ermöglichte die Steuerung aller Ereignisflüsse.  Projekte haben direkt auf den Pufferspeicher zugegriffen. </p><br><h3 id="prosveschyonnyy-klikstrimizm">  Erleuchteter Clickstreamismus </h3><br><p>  Basierend auf dem Verzeichnis wurden Langpacks generiert.  Sie erlauben nicht die Erstellung ungültiger Ereignisse. </p><br><p>  Einführung automatischer Überprüfungen der Richtigkeit von Ereignissen, die von Frontends und mobilen Anwendungen eingehen.  In diesem Fall hören wir nicht auf, Ereignisse zu schreiben, um keine Daten zu verlieren, sondern protokollieren Fehler und signalisieren den Entwicklern. </p><br><p>  Seltene Ereignisse in Backends, die schwer umzugestalten sind und die noch nicht über Langpacks gesendet werden, werden von einer separaten Bibliothek gemäß den Regeln aus dem Verzeichnis überprüft.  Lösen Sie bei Fehlern eine Ausnahme aus, die den Rollout blockiert. </p><br><p>  Ich habe ein System, das dazu neigt, mit dem Verzeichnis übereinzustimmen.  Boni: Transparenz, Verwaltbarkeit, Geschwindigkeit der Erstellung und Änderung von Ereignissen. </p><br><h1 id="posleslovie">  Nachwort </h1><br><p>  Die Hauptschwierigkeiten und Lektionen waren organisatorisch.  Es ist schwierig, Initiativen mit mehreren Teams zu verknüpfen.  Es ist nicht einfach, den Code eines großen alten Projekts zu ändern.  Die Fähigkeit, mit anderen Teams zu kommunizieren, Aufgaben in relativ unabhängige und durchdachte Integration mit der Möglichkeit der unabhängigen Einführung von Hilfe aufzuteilen.  Clickstream-Entwickler lieben Produktteams nicht mehr, wenn die Integrationsphase einer neuen Lösung beginnt.  Wenn sich die Schnittstellen ändern, wird allen Arbeit hinzugefügt. </p><br><p>  Das Erstellen eines Verzeichnisses war eine sehr gute Idee.  Er wurde zur einzigen Quelle der Wahrheit, bei Unstimmigkeiten im Code kann man sich immer an ihn wenden.  Ein Großteil der Automatisierung ist an das Verzeichnis gebunden: Überprüfungen, Ereignisrouting, Codegenerierung. </p><br><p>  Die Infrastruktur muss nichts über Geschäftslogik wissen.  Anzeichen für die Entstehung der Geschäftslogik: Ereignisse ändern sich auf dem Weg vom Projekt zum Repository.  Transportwechsel ohne Projektwechsel werden unmöglich.  Auf der Infrastrukturseite sollte Wissen über die Zusammensetzung von Ereignissen, Feldtypen und deren Verbindlichkeit vorhanden sein.  Auf der Produktseite die logische Bedeutung dieser Felder. </p><br><p>  Es gibt immer Raum zum Wachsen.  Technisch gesehen bedeutet dies eine Zunahme der Anzahl von Ereignissen, eine Verkürzung der Zeit von der Erstellung des Ereignisses bis zum Beginn der Datenaufzeichnung und den Wegfall manueller Arbeit in allen Phasen. </p><br><p>  Es gibt ein paar mutige Ideen.  Abrufen eines detaillierten Diagramms der Benutzerübergänge, Konfigurieren von Ereignissen im laufenden Betrieb, ohne den Dienst einzuführen.  Aber mehr dazu in den folgenden Artikeln. </p><br><p>  PS Ich habe auf dem Backend United # 1-Meeting zu diesem Thema gesprochen.  Vinaigrette.  Kann sehen <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Präsentation</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Video</a> von der Besprechung. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de419651/">https://habr.com/ru/post/de419651/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de419637/index.html">[Übersetzung] Funktionsweise von Graal - Java JVM JVM Compiler</a></li>
<li><a href="../de419641/index.html">Erstellen einer einfachen C # AI in Unity</a></li>
<li><a href="../de419643/index.html">Minsk EPAM Software Engineering Konferenz: Machen Sie es real</a></li>
<li><a href="../de419647/index.html">Seminar „Schwarzer Freitag im E-Commerce. Geheimnisse des Überlebens, 16. August, Moskau</a></li>
<li><a href="../de419649/index.html">Ein bisschen über Katzen oder welchen CAT wir für die Synchronisierung von Podcasts ausgewählt haben</a></li>
<li><a href="../de419653/index.html">So führen Sie Benutzersuchen auf GitHub ohne React + RxJS 6 + Recompose durch</a></li>
<li><a href="../de419655/index.html">Musik in der Wohnung. Einbetten</a></li>
<li><a href="../de419657/index.html">Wie kollektive Intelligenz für eine Herde Drohnen entwickelt wurde</a></li>
<li><a href="../de419659/index.html">Wo Hollywood Hacker richtig darstellt und wo - fälschlicherweise</a></li>
<li><a href="../de419661/index.html">Einen Radiosender aus GTA machen: San Andreas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>