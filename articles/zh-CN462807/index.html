<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👆🏾 👩🏿‍🔧 🗡️ WinForms：错误，福尔摩斯 🔀 🤽🏾 🧝🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我们喜欢在Microsoft项目中寻找错误。 怎么了 很简单：他们的项目通常很容易检查（可以在Visual Studio环境中立即完成工作，为此PVS-Studio拥有便捷的插件），并且几乎没有错误。 因此，通常的工作算法如下：从MS查找并下载一个打开的项目； 检查一下； 选择有趣的错误； 确保数量...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WinForms：错误，福尔摩斯</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/462807/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/71b/aeb/a84/71baeba847a8865aef0cc8148effbb8c.png" alt="图片5"></div><br> 我们喜欢在Microsoft项目中寻找错误。 怎么了 很简单：他们的项目通常很容易检查（可以在Visual Studio环境中立即完成工作，为此PVS-Studio拥有便捷的插件），并且几乎没有错误。 因此，通常的工作算法如下：从MS查找并下载一个打开的项目； 检查一下； 选择有趣的错误； 确保数量很少； 写一篇文章，不要忘记赞扬开发人员。 太好了！ 双赢：花了一些时间，手册很高兴在博客上看到新材料，业力井然有序。 但是这一次出了点问题。 让我们看看在Windows Forms的源代码中发现了什么有趣的东西，以及这次是否应该赞扬Microsoft。 <br><a name="habracut"></a><br>  <b>引言</b> <br><br> 在2018年12月上旬，微软<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">宣布</a>发布.NET Core 3 Preview 1。 您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>查看提交统计信息。 现在，任何人都可以下载WinForms源代码以进行审查。 <br><br> 我还下载了源代码，以使用PVS-Studio查找错误。 检查没有造成困难。 必需：Visual Studio 2019，.NET Core 3.0 SDK预览，PVS-Studio。 现在接收到分析仪警告日志。 <br><br> 收到PVS-Studio日志后，我通常以诊断编号的升序对其进行排序（Visual Studio中带有PVS-Studio消息日志的窗口具有用于排序和过滤列表的各种选项）。 这允许处理相同类型的错误组，从而大大简化了源代码的分析。 我在星号上标记了有趣的错误，然后，在分析了整个日志之后，我写出了代码片段并进行了描述。 而且由于通常很少有错误，因此我将它们混合在一起，试图将最有趣的错误放在文章的开头和结尾。 但这一次错误的确多了一些（嗯，很长一段时间都无法保存这种阴谋），我将按照诊断编号的顺序进行处理。 <br><br> 发现了什么？ 在1670 cs文件中，对540,000行代码（不包括空代码）发出了833个高和中置信度警告（分别为249和584）。 是的，根据传统，我没有检查测试，也没有考虑低置信度（发出215）的警告。 根据我以前的观察，MS对该项目提出了太多警告。 但并非所有警告都是错误。 <br><br> 对于该项目，误报的数量约为30％。 在大约20％的情况下，由于我不熟悉该代码，所以我无法就这是否是一个错误做出准确的结论。 好吧，我错过的错误中至少有20％可以归因于人为因素：匆忙，疲劳等。 顺便说一句，相反的效果也是可能的：我查看了一些相同类型的触发，其触发次数可能达到70-80，通过偶尔会增加我认为是真正的错误的触发次数。 <br><br> 在任何情况下，如果尚未预先配置分析仪，则30％的警告表示实际错误，这是一个很大的百分比。 <br><br> 因此，我能够检测到的错误数量约为240，这在统计数据的范围内。 我认为，对于MS的项目，我再说一遍，这并不是最出色的结果（尽管每1000行代码只有0.44错误），并且WinForms代码中可能存在更多实际错误。 我建议在文章结尾讨论原因，但现在让我们看看最有趣的错误。 <br><br>  <b>失误</b> <br><br>  PVS-Studio： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3003</a>已检测到'if（A）{...} else if（A）{...}'模式的使用。 存在逻辑错误的可能性。 检查行：213、224。ButtonStandardAdapter.cs 213 <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PaintWorker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PaintEventArgs e, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> up, CheckState state)</span></span></span><span class="hljs-function"> </span></span>{ up = up &amp;&amp; state == CheckState.Unchecked; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (up &amp; IsHighContrastHighlighted()) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (up &amp; IsHighContrastHighlighted()) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } .... }</code> </pre> <br> 在<i>if</i>和<i>else if</i>块中，检查相同条件。 看起来像是复制粘贴。 这是一个错误吗？ 如果您查看<i>IsHighContrastHighlighted</i>方法的声明，则会有疑问： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsHighContrastHighlighted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SystemInformation.HighContrast &amp;&amp; Application.RenderWithVisualStyles &amp;&amp; (Control.Focused || Control.MouseIsOver || (Control.IsDefault &amp;&amp; Control.Enabled)); }</code> </pre> <br> 该方法可能在连续调用中返回不同的值。 当然，在调用方法中执行的操作看起来很奇怪，但是它具有生命权。 但是，我建议作者看一下这段代码。 以防万一。 但是，这是一个很好的例子，说明了在分析不熟悉的代码时很难得出结论。 <br><br>  PVS-Studio： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3004'then</a> '语句等效于'else'语句。  RichTextBox.cs 1018 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SelectionCharOffset { get { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> selCharOffset = <span class="hljs-number"><span class="hljs-number">0</span></span>; .... NativeMethods.CHARFORMATA cf = GetCharFormat(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-comment"><span class="hljs-comment">// if the effects member contains valid info if ((cf.dwMask &amp; RichTextBoxConstants.CFM_OFFSET) != 0) { selCharOffset = cf.yOffset; // &lt;= } else { // The selection contains characters of different offsets, // so we just return the offset of the first character. selCharOffset = cf.yOffset; // &lt;= } .... } .... }</span></span></code> </pre> <br> 在这里肯定会出现复制粘贴错误。 无论条件如何， <i>selCharOffset</i>变量<i>将</i>始终获得相同的值。 <br><br>  WinForms代码中还有两个类似的错误： <ul><li>  V3004'then'语句等效于'else'语句。  SplitContainer.cs 1700 </li><li>  V3004'then'语句等效于'else'语句。 工具tripProfessionalRenderer.cs 371 </li></ul><br>  PVS-Studio： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3008</a>连续两次为变量分配值。 也许这是一个错误。 检查行：681、680。ProfessionalColorTable.cs 681 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitSystemColors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ref Dictionary&lt;KnownColors, Color&gt; rgbTable)</span></span></span><span class="hljs-function"> </span></span>{ .... rgbTable[ProfessionalColorTable.KnownColors.msocbvcrCBBdrOuterDocked] = buttonFace; rgbTable[ProfessionalColorTable.KnownColors.msocbvcrCBBdrOuterDocked] = buttonShadow; .... }</code> </pre> <br> 该方法填充<i>rgbTable</i>字典。 分析器指向一段代码，其中两个不同的值依次写入同一键。 一切都会好起来的，但是这种方法还有16个这样的位置，这不再像一个错误。 但是为什么要这样做，对我来说仍然是个谜。 我没有发现自动生成代码的迹象。 在编辑器中，它看起来像这样： <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/006/f68/827/006f688275da3701f28abe7918835ce9.png" alt="图片3"></div><br> 我将列出前十个操作： <br><br><ol><li>  V3008为变量连续分配两次值。 也许这是一个错误。 检查行：785，784。ProfessionalColorTable.cs 785 </li><li>  V3008为变量连续分配两次值。 也许这是一个错误。 检查行：787、786。ProfessionalColorTable.cs 787 </li><li>  V3008为变量连续分配两次值。 也许这是一个错误。 检查行：789、788。ProfessionalColorTable.cs 789 </li><li>  V3008为变量连续分配两次值。 也许这是一个错误。 检查行：791、790。ProfessionalColorTable.cs 791 </li><li>  V3008为变量连续分配两次值。 也许这是一个错误。 检查行：797、796。ProfessionalColorTable.cs 797 </li><li>  V3008为变量连续分配两次值。 也许这是一个错误。 检查行：799、798。ProfessionalColorTable.cs 799 </li><li>  V3008为变量连续分配两次值。 也许这是一个错误。 检查行：807、806。ProfessionalColorTable.cs 807 </li><li>  V3008为变量连续分配两次值。 也许这是一个错误。 检查行：815、814。ProfessionalColorTable.cs 815 </li><li>  V3008为变量连续分配两次值。 也许这是一个错误。 检查行：817，816。ProfessionalColorTable.cs 817 </li><li>  V3008为变量连续分配两次值。 也许这是一个错误。 检查行：823，822。ProfessionalColorTable.cs 823 </li></ol><br>  PVS-Studio： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3011</a>遇到两个相反的条件。 第二个条件始终为假。 检查行：5242、5240。DataGrid.cs 5242 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckHierarchyState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (checkHierarchy &amp;&amp; listManager != null &amp;&amp; myGridTable != null) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (myGridTable == null) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { // there was nothing to check return; } for (int j = 0; j &lt; myGridTable.GridColumnStyles.Count; j++) { DataGridColumnStyle gridColumn = myGridTable.GridColumnStyles[j]; } checkHierarchy = false; } }</span></span></code> </pre> <br>  <i>return语句</i>将永远不会执行。 最有可能的是，条件<i>myGridTable！=</i>外部<i>if</i>块中的<i>Null</i>在重构期间稍后添加。 现在检查<i>myGridTable == null是</i>没有意义的。 为了提高代码的质量，请删除此检查。 <br><br>  PVS-Studio： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3019</a>可能在使用'as'关键字进行类型转换后将不正确的变量与null进行比较。 检查变量“ left”，“ cscLeft”。  TypeCodeDomSerializer.cs 611 <br><br>  PVS-Studio： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3019</a>可能在使用'as'关键字进行类型转换后将不正确的变量与null进行比较。 检查变量“ right”，“ cscRight”。  TypeCodeDomSerializer.cs 615 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Compare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object left, object right)</span></span></span><span class="hljs-function"> </span></span>{ OrderedCodeStatementCollection cscLeft = left as OrderedCodeStatementCollection; OrderedCodeStatementCollection cscRight = right as OrderedCodeStatementCollection; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (left == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (right == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (right == left) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cscLeft.Order - cscRight.Order; <span class="hljs-comment"><span class="hljs-comment">// &lt;= }</span></span></code> </pre> <br> 分析仪立即对<i>Compare</i>方法发出两个警告。 怎么了 只是不检查<i>cscLeft</i>和<i>cscRight</i>的值是否等于<i>null</i> 。 在不成功地转换为<i>OrderedCodeStatementCollection</i>类型之后，他们可以获得此值。 然后，将在最后一个<i>return语句中</i>引发异常。 当所有检查都通过<i>左</i>和<i>右</i>并且没有导致该方法的初步退出时，这种情况是可能的。 <br><br> 要修复代码，应在<i>各处</i>使用<i>cscLeft</i> / <i>cscRight</i>而不是<i>left</i> / <i>right</i> 。 <br><br>  PVS-Studio： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3020</a>循环内无条件的“中断”。  SelectionService.cs 421 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ISelectionService.SetSelectedComponents( ICollection components, SelectionTypes selectionType) { .... <span class="hljs-comment"><span class="hljs-comment">// Handle the click case object requestedPrimary = null; int primaryIndex; if (fPrimary &amp;&amp; 1 == components.Count) { foreach (object o in components) { requestedPrimary = o; if (o == null) { throw new ArgumentNullException(nameof(components)); } break; } } .... }</span></span></code> </pre> <br> 该片段是指“带有气味”的代码。 这里没有错误。 但是，对<i>每个</i>循环的组织方式提出了疑问。 为什么在这里需要它-很明显：由于需要提取作为<i>ICollection</i>传递的集合的元素。 但是，为什么在最初为单次迭代而设计的循环中（前提是<i>组件</i>集合中存在单个元素），则需要一个额外的安全网（以<i>中断</i>的形式）？ 答案可能是：“它是历史发展的”。 该代码看起来很难看。 <br><br>  PVS-Studio： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3022</a>表达式'ocxState！= Null'始终为true。  AxHost.cs 2186 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> State OcxState { .... <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } .... ocxState = value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ocxState != null) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { axState[manualUpdate] = ocxState._GetManualUpdate(); licenseKey = ocxState._GetLicenseKey(); } else { axState[manualUpdate] = false; licenseKey = null; } .... } }</span></span></code> </pre> <br> 由于逻辑错误，在此片段中形成了“死代码”。  <i>else</i>块中的表达式将永远不会执行。 <br><br>  PVS-Studio： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3027</a>在针对同一逻辑表达式中的null进行验证之前，在逻辑表达式中使用了变量'e'。 图像编辑器.cs 99 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... ImageEditor e = ....; Type myClass = GetType(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!myClass.Equals(e.GetType()) &amp;&amp; e != null &amp;&amp; myClass.IsInstanceOfType(e)) { .... } .... }</code> </pre> <br> 首先使用条件中的变量<i>e</i> ，然后检查<i>空</i>不等式。 嗨， <i>NullReferenceException</i> 。 <br><br> 另一个类似的错误： <br><br>  PVS-Studio： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3027</a>在对同一逻辑表达式中的null进行验证之前，在逻辑表达式中使用了变量'dropDownItem'。  ToolStripMenuItemDesigner.cs 1351 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnterInSituEdit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ToolStripItem toolItem)</span></span></span><span class="hljs-function"> </span></span>{ .... ToolStripDropDownItem dropDownItem = toolItem as ToolStripDropDownItem; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(dropDownItem.Owner is ToolStripDropDownMenu) &amp;&amp; dropDownItem != null &amp;&amp; dropDownItem.Bounds.Width &lt; commitedEditorNode.Bounds.Width) { .... } .... }</code> </pre> <br> 这种情况与上一个类似，只不过具有变量<i>dropDownItem</i> 。 我认为这些错误是由于重构期间的疏忽而出现的。 稍后，部分条件<i>！（DropDownItem.Owner是ToolStripDropDownMenu）可能</i>已添加到代码中。 <br><br>  PVS-Studio： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3030</a>定期检查。  'columnCount&gt; 0'条件已经在行3900中得到验证。ListView.cs 3903 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal ColumnHeader </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InsertColumn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, ColumnHeader ch, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> refreshSubItems)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">// Add the column to our internal array int columnCount = (columnHeaders == null ? 0 : columnHeaders.Length); if (columnCount &gt; 0) { ColumnHeader[] newHeaders = new ColumnHeader[columnCount + 1]; if (columnCount &gt; 0) { System.Array.Copy(columnHeaders, 0, newHeaders, 0, columnCount); } .... } .... }</span></span></code> </pre> <br> 一个看似无害的错误。 确实，可以执行额外的检查，但这不会影响工作的逻辑。 有时，当您需要重新检查视觉组件的状态时，他们甚至会这样做，例如，通过获取列表中的条目数。 仅在这种情况下，他们才仔细检查<i>局部</i>变量<i>columnCount</i> 。 这是非常可疑的。 他们要么想要检查另一个变量，要么在其中一项检查中使用了错误的条件。 <br><br>  PVS-Studio： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3061</a>参数“ lprcClipRect”始终在使用前在方法主体中重写。  WebBrowserSiteBase.cs 281 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> UnsafeNativeMethods.IOleInPlaceSite.GetWindowContext( out UnsafeNativeMethods.IOleInPlaceFrame ppFrame, out UnsafeNativeMethods.IOleInPlaceUIWindow ppDoc, NativeMethods.COMRECT lprcPosRect, NativeMethods.COMRECT lprcClipRect, NativeMethods.tagOIFI lpFrameInfo) { ppDoc = null; ppFrame = Host.GetParentContainer(); lprcPosRect.left = Host.Bounds.X; lprcPosRect.top = Host.Bounds.Y; .... lprcClipRect = WebBrowserHelper.GetClipRect(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= if (lpFrameInfo != null) { lpFrameInfo.cb = Marshal.SizeOf&lt;NativeMethods.tagOIFI&gt;(); lpFrameInfo.fMDIApp = false; .... } return NativeMethods.S_OK; }</span></span></code> </pre> <br> 显而易见的错误。 是的， <i>lprcClipRect</i>参数实际上<i>是</i>用新值初始化的，没有以任何方式使用它。 但是，这会导致什么呢？ 我认为在调用代码的某个地方，通过此参数传递的链接将保持不变，尽管其意图有所不同。 确实，请看看在此方法中使用其他变量。 甚至它的名称（“ Get”前缀）也暗示将通过传递的参数在方法内部进行一些初始化。 就是这样。 前两个参数（ <i>ppFrame</i>和<i>ppDoc</i> ）与<i>out</i>修饰符一起传递并获取新值。 链接<i>lprcPosRect</i>和<i>lpFrameInfo</i>用于访问类的字段并对其进行初始化。 并且只有<i>lprcClipRect</i>不在常规列表中。 最有可能的是，此参数需要<i>out</i>或<i>ref</i>修饰符。 <br><br>  PVS-Studio： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3066</a>传递给“ AdjustCellBorderStyle”方法的参数的可能错误顺序：“ isFirstDisplayedRow”和“ isFirstDisplayedColumn”。  DataGridViewComboBoxCell.cs 1934 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnMouseMove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DataGridViewCellMouseEventArgs e)</span></span></span><span class="hljs-function"> </span></span>{ .... dgvabsEffective = AdjustCellBorderStyle( DataGridView.AdvancedCellBorderStyle, dgvabsPlaceholder, singleVerticalBorderAdded, singleHorizontalBorderAdded, isFirstDisplayedRow, <span class="hljs-comment"><span class="hljs-comment">// &lt;= isFirstDisplayedColumn); // &lt;= .... }</span></span></code> </pre> <br> 分析器怀疑最后两个参数混淆了。 让我们看一下<i>AdjustCellBorderStyle</i>方法的声明： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> DataGridViewAdvancedBorderStyle </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustCellBorderStyle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( DataGridViewAdvancedBorderStyledataGridViewAdvancedBorderStyleInput, DataGridViewAdvancedBorderStyle dataGridViewAdvancedBorderStylePlaceholder, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> singleVerticalBorderAdded, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> singleHorizontalBorderAdded, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isFirstDisplayedColumn, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isFirstDisplayedRow)</span></span></span><span class="hljs-function"> </span></span>{ .... }</code> </pre> <br> 看起来像是一个错误。 是的，经常有意地以相反的顺序传递一些参数，例如，以便交换某些变量。 但我认为情况并非如此。 调用或被调用方法中没有任何内容说明这种使用模式。 首先， <i>布尔</i>类型变量令人困惑。 其次，方法的名称也很常见：没有“交换”或“反向”。 而且，犯这样的错误并不难。 人们通常对行/列对的顺序有不同的认识。 例如，对我而言，仅熟悉“行/列”。 但是对于名为<i>AdjustCellBorderStyle</i>方法的作者<i>来说</i> ，显然，更熟悉的顺序是“列/行”。 <br><br>  PVS-Studio： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3070</a>初始化“ LOCALE_USER_DEFAULT”变量时使用未初始化的变量“ LANG_USER_DEFAULT”。  NativeMethods.cs 890 <br><br><pre> <code class="cpp hljs">internal <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NativeMethods</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LOCALE_USER_DEFAULT = MAKELCID(LANG_USER_DEFAULT); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LANG_USER_DEFAULT = MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT); .... }</code> </pre> <br> 一个罕见的错误。 类字段的初始化顺序混合在一起。 要计算<i>LOCALE_USER_DEFAULT</i>字段的值，请使用<i>LANG_USER_DEFAULT</i>字段，该字段尚未初始化且值为0。顺便说一句， <i>LANG_USER_DEFAULT</i>变量未在代码中的其他任何地方使用。 我不太懒惰，并编写了一个模拟这种情况的小型控制台程序。 我代替了WinForms代码中使用的某些常量的值，而是替换了它们的实际值： <br><br><pre> <code class="cpp hljs">internal <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NativeMethods</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LOCALE_USER_DEFAULT = MAKELCID(LANG_USER_DEFAULT); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LANG_USER_DEFAULT = MAKELANGID(<span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0x01</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MAKELANGID</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> primary, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sub)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((((ushort)(sub)) &lt;&lt; <span class="hljs-number"><span class="hljs-number">10</span></span>) | (ushort)(primary)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MAKELCID</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lgid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MAKELCID(lgid, <span class="hljs-number"><span class="hljs-number">0x0</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MAKELCID</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lgid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sort)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((<span class="hljs-number"><span class="hljs-number">0xFFFF</span></span> &amp; lgid) | (((<span class="hljs-number"><span class="hljs-number">0x000f</span></span>) &amp; sort) &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>)); } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Program</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.Console.WriteLine(NativeMethods.LOCALE_USER_DEFAULT); } }</code> </pre> <br> 启动后，控制台上将显示以下内容：0。现在，我们交换<i>LOCALE_USER_DEFAULT</i>和<i>LANG_USER_DEFAULT字段</i>的声明。 程序的结果格式为：1024。我认为这里无可奉告了。 <br><br>  PVS-Studio： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3080</a>可能取消空引用。 考虑检查“ ces”。 第562章 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DeserializeStatement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( IDesignerSerializationManager manager, CodeStatement statement)</span></span></span><span class="hljs-function"> </span></span>{ .... CodeExpressionStatement ces = statement as CodeExpressionStatement; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ces != null) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... DeserializeExpression(manager, null, ces.Expression); <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... } .... }</span></span></code> </pre> <br> 应该“下降”的代码足够稳定，因为仅当<i>ces</i>引用为<i>null</i>时，您才能进入<i>else</i>分支。 <br><br> 另一个类似的例子： <br><br>  PVS-Studio： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3080</a>可能取消空引用。 考虑检查“ comboBox”。  ComboBox.cs 6610 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidateOwnerDrawRegions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ComboBox comboBox, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (comboBox != null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Rectangle topOwnerDrawArea = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rectangle(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, comboBox.Width, innerBorder.Top); .... }</code> </pre> <br> 矛盾的代码。 显然，他们通过编写<i>if（comboBox！= Null）</i>而不是<i>if（comboBox == null）</i>来混合测试。 这样-我们将收到下一个<i>NullReferenceException</i> 。 <br><br> 我们检查了两个非常明显的错误<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3080</a> ，您可以在其中直观地跟踪方法中可能使用空引用的情况。 但是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3080</a>诊断更加智能，可以在方法调用链中查找类似的错误。 不久前，我们显着增强了数据流和过程间分析的机制。 您可以在文章“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">C＃8.0和静态分析中的可空引用类型</a> ”中阅读有关此内容的信息。 这是在WinForms中发现的类似错误： <br><br>  PVS-Studio： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3080'reader.NameTable</a> '中的方法内部可能存在空取消引用。 考虑检查第一个参数：contentReader。  ResXResourceReader.cs 267 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnsureResData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... XmlTextReader contentReader = null; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fileContents != null) { contentReader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XmlTextReader(....); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reader != null) { contentReader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XmlTextReader(....); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fileName != null || stream != null) { .... contentReader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XmlTextReader(....); } SetupNameTable(contentReader); <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... } finally { .... } .... }</span></span></code> </pre> <br> 查看方法主体中的变量<i>contentReader</i>会发生什么。 在使用空引用进行初始化之后，由于检查之一，该链接将被初始化。 但是，一系列检查并不以<i>else</i>块结尾。 这意味着在极少数情况下（或由于将来的重构），链接仍然可以保持零。 接下来，它将被传递到<i>SetupNameTable</i>方法，在此方法中无需任何验证即可使用它： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetupNameTable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(XmlReader reader)</span></span></span><span class="hljs-function"> </span></span>{ reader.NameTable.Add(ResXResourceWriter.TypeStr); reader.NameTable.Add(ResXResourceWriter.NameStr); .... }</code> </pre> <br> 这可能是不安全的代码。 <br><br> 还有一个错误，分析仪必须经过一系列调用才能确定问题： <br><br>  PVS-Studio： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3080</a>可能取消空引用。 考虑检查“布局”。  156，第156章 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Rectangle </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAnchorDestination</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( IArrangedElement element, Rectangle displayRect, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> measureOnly)</span></span></span><span class="hljs-function"> </span></span>{ .... AnchorInfo layout = GetAnchorInfo(element); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> left = layout.Left + displayRect.X; .... }</code> </pre> <br> 分析器声称可以从<i>GetAnchorInfo</i>方法获取空引用，该方法将在计算<i>左</i>值时引发异常。 让我们遍历整个呼叫链，并检查是否是这样： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> AnchorInfo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAnchorInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IArrangedElement element)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (AnchorInfo)element.Properties.GetObject(s_layoutInfoProperty); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key)</span></span></span><span class="hljs-function"> </span></span>=&gt; GetObject(key, out _); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key, out </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> found)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> keyIndex = SplitKey(key, out <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> element); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!LocateObjectEntry(keyIndex, out <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index)) { found = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } <span class="hljs-comment"><span class="hljs-comment">// We have found the relevant entry. See if // the bitmask indicates the value is used. if (((1 &lt;&lt; element) &amp; s_objEntries[index].Mask) == 0) { found = false; return null; } found = true; switch (element) { case 0: return s_objEntries[index].Value1; .... default: Debug.Fail("Invalid element obtained from LocateObjectEntry"); return null; } }</span></span></code> </pre> <br> 实际上，在某些情况下，关闭调用链的<i>GetObject</i>方法将返回<i>null</i> ，而无需任何其他检查，该方法将传递给调用方法。 可能， <i>GetAnchorDestination</i>方法应提供这种情况。 <br><br> 在WinForms代码中，有很多这样的错误， <b>超过70个</b> 。 它们都是相似的，因此在本文中不再赘述。 <br><br>  PVS-Studio： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3091</a>实证分析。 字符串文字中可能存在错字：“ ShowCheckMargin”。  “ ShowCheckMargin”一词可疑。  PropertyNames.cs 136 <br><br><pre> <code class="cpp hljs">internal <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PropertyNames</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> ShowImageMargin = <span class="hljs-string"><span class="hljs-string">"ShowCheckMargin"</span></span>; ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> ShowCheckMargin = <span class="hljs-string"><span class="hljs-string">"ShowCheckMargin"</span></span>; .... }</code> </pre> <br> 一个不太容易发现的错误的好例子。 初始化类字段时，它们使用相同的值，尽管代码的作者显然并不这么认为（应归咎于复制粘贴）。 分析器通过比较变量名称和分配的字符串的值来得出此结论。 我只给出了错误行，但在代码编辑器中查看了它的外观： <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/313/196/4de/3131964de8f3f5161678c44086ed2e40.png" alt="图片2"></div><br> 正是对此类错误的检测证明了静态分析工具的强大功能和无限关注。 <br><br>  PVS-Studio： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3095</a>在对null进行验证之前，已使用'currentForm'对象。 检查行：3386、3404。Application.cs 3386 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RunMessageLoopInner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reason, ApplicationContext context)</span></span></span><span class="hljs-function"> </span></span>{ .... hwndOwner = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HandleRef( null, UnsafeNativeMethods.GetWindowLong( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HandleRef(currentForm, currentForm.Handle), <span class="hljs-comment"><span class="hljs-comment">// &lt;= NativeMethods.GWL_HWNDPARENT)); .... if (currentForm != null &amp;&amp; ....) .... }</span></span></code> </pre> <br> 经典版 使用<i>currentForm</i>变量无需任何检查。 但是在代码的更深处，它检查<i>空</i>相等性。 在这种情况下，我建议您在使用引用类型以及使用静态分析器时要格外小心：)。 <br><br> 另一个类似的错误： <br><br>  PVS-Studio： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3095</a>在对null进行验证之前，已使用“ backgroundBrush”对象。 检查行：2331，2334。DataGrid.cs 2331 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color BackgroundColor { .... <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!value.Equals(backgroundBrush.Color)) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { if (backgroundBrush != null &amp;&amp; BackgroundBrush != DefaultBackgroundBrush) .... } } }</span></span></code> </pre> <br> 在WinForms代码中，我遇到了<b>60</b>多个此类错误。 我认为，所有这些都非常关键，需要开发人员的注意。 但是在本文中，谈论它们并不是那么有趣，因此，我将只限于上面讨论的两个。 <br><br>  PVS-Studio： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3125</a>已使用'_propInfo'对象，并在不同的执行分支中针对null对其进行了验证。 检查行：996、982。Binding.cs 996 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetPropValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object value)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_propInfo != null) .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { _propInfo.SetValue(_control, value); } .... }</code> </pre> <br> 要完成图片，这也是一种经典的bug <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3125</a> 。 相反的情况。 首先，安全地使用可能为null的引用，检查是否为<i>null</i> ，但随后他们不再在代码中这样做。 <br><br> 还有另一个类似的错误： <br><br>  PVS-Studio： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3125</a>在针对null进行验证之后，使用了“所有者”对象。 检查行：64，60。FlatButtonAppearance.cs 64 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> BorderSize { .... <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (owner != null &amp;&amp; owner.ParentInternal != null) { LayoutTransaction.DoLayoutIf(....); } owner.Invalidate(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... } }</span></span></code> </pre> <br> 美人 但这是从外部研究人员的角度来看的。 实际上，除了这两个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3125之外</a> ，分析器还在WinForms代码中发现了<b>50多个</b>类似的模式。 开发人员有工作要做。 <br><br> 最后，我认为这是一个非常有趣的错误。 <br><br>  PVS-Studio： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3137</a>分配了“ hCurrentFont”变量，但该变量未在功能结束时使用。  DeviceContext2.cs 241 <br><br><pre> <code class="cpp hljs">sealed partial <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeviceContext</span></span></span><span class="hljs-class"> :</span></span> .... { WindowsFont selectedFont; .... <span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DisposeFont</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> disposing)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (disposing) { DeviceContexts.RemoveDeviceContext(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (selectedFont != null &amp;&amp; selectedFont.Hfont != IntPtr.Zero) { IntPtr hCurrentFont = IntUnsafeNativeMethods.GetCurrentObject( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HandleRef(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, hDC), IntNativeMethods.OBJ_FONT); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hCurrentFont == selectedFont.Hfont) { <span class="hljs-comment"><span class="hljs-comment">// select initial font back in IntUnsafeNativeMethods.SelectObject(new HandleRef(this, Hdc), new HandleRef(null, hInitialFont)); hCurrentFont = hInitialFont; // &lt;= } selectedFont.Dispose(disposing); selectedFont = null; } } .... }</span></span></code> </pre> <br> 让我们看看分析器警告了什么，以及为什么为变量分配了一个值，但以后在该方法中不使用它的事实可能表明存在问题。 <br><br> 在文件<i>DeviceContext2.cs中</i>声明了部分类。  <i>DisposeFont</i>方法用于处理图形后释放资源：设备上下文和字体。 为了更好地理解，我提供了整个<i>DisposeFont</i>方法。 注意局部变量<i>hCurrentFont</i> 。 问题在于，在方法中声明此变量将隐藏相同名称的类字段。 我发现<i>DeviceContext</i>类的两个方法<i>都使用</i>了一个名为<i>hCurrentFont</i>的<b>字段</b> ： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IntPtr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SelectFont</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(WindowsFont font)</span></span></span><span class="hljs-function"> </span></span>{ .... hCurrentFont = font.Hfont; .... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResetFont</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... hCurrentFont = hInitialFont; }</code> </pre> <br> 看一下<i>ResetFont</i>方法。 最后一行正是<i>DisposeFont</i>方法在嵌套<i>if</i>块中<i>所做</i>的操作（分析器指向此位置）。 在同一个名称的<i>hCurrentFont</i>字段是在<i>DeviceContext.cs</i>文件的部分类的另一部分中<i>声明的</i> ： <br><br><pre> <code class="cpp hljs">sealed partial <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeviceContext</span></span></span><span class="hljs-class"> :</span></span> .... { .... IntPtr hInitialFont; .... IntPtr hCurrentFont; <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... }</span></span></code> </pre> <br> 因此，犯了一个明显的错误。 另一个问题是它的重要性。 现在，由于<i>DisposeFont</i>方法在标有“选择返回初始字体”注释的部分中<i>起作用</i> ，因此<i>hCurrentFont</i>字段将不会被分配一些初始值。 我认为只有代码作者才能给出确切的结论。 <br><br>  <b>结论</b> <br><br> 因此，这一次我不得不“责骂” MS。 在WinForms中，存在许多错误，需要开发人员密切注意。 也许这是由于MS在.NET Core 3和包括WinForms在内的组件上匆忙工作所致。 我认为WinForms代码仍然“潮湿”，但我希望情况会很快好转。 <br><br> 出现大量错误的第二个原因可能是我们的分析仪更好地寻找了它们：)。 <br><br> 顺便说一下，我的同事Sergey Vasiliev的一篇文章很快就会发表，他在其中搜索并发现了.NET Core库代码中的许多问题。 我希望他的工作也将有助于改善.NET平台的性能，因为我们始终尝试将开发人员的项目分析结果传达给开发人员。 <br><br> 好吧，对于那些想要自己改进产品或进行研究以发现他人项目中的错误的人，我建议<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">下载并尝试使用</a> PVS-Studio。 <br><br> 所有干净的代码！ <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br> 如果您想与讲英语的读者分享这篇文章，请使用以下链接：Sergey Khrenov。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WinForms：错误，福尔摩斯</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN462807/">https://habr.com/ru/post/zh-CN462807/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN462797/index.html">关于云，不仅是专业人士</a></li>
<li><a href="../zh-CN462799/index.html">RAVIS和DAB的起步较低。 DRM冒犯了。 俄罗斯联邦数字广播的奇异未来</a></li>
<li><a href="../zh-CN462801/index.html">2019年15种产品经理必备工具</a></li>
<li><a href="../zh-CN462803/index.html">从一个ERP系统迁移到另一个</a></li>
<li><a href="../zh-CN462805/index.html">分析：在交易所交易时如何实际保护货币</a></li>
<li><a href="../zh-CN462809/index.html">WinForms：错误，福尔摩斯</a></li>
<li><a href="../zh-CN462811/index.html">为什么在Go中需要泛型？</a></li>
<li><a href="../zh-CN462813/index.html">叶卡捷琳堡，8月14日-Atlassian User Group mitap</a></li>
<li><a href="../zh-CN462817/index.html">Kotlin / Everywhere报告-展示实践：7月31日</a></li>
<li><a href="../zh-CN462819/index.html">独联体语言教育的不足：多角度的看法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>