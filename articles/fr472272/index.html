<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåö üîÖ üêô Un nouveau jeu avec une vieille ambiance sur Three.js. 2e partie üí£ üìÖ üé®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans la premi√®re partie, j'ai parl√© des probl√®mes que j'ai rencontr√©s lors de la cr√©ation d'un jeu 3D pour le navigateur utilisant Three.js. Maintenan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Un nouveau jeu avec une vieille ambiance sur Three.js. 2e partie</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472272/"> Dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">premi√®re</a> partie, j'ai parl√© des probl√®mes que j'ai rencontr√©s lors de la cr√©ation d'un jeu 3D pour le navigateur utilisant Three.js.  Maintenant, je voudrais m'attarder en d√©tail sur la r√©solution de certains probl√®mes importants lors de l'√©criture d'un jeu, tels que la construction de niveaux, la d√©tection de collisions et l'adaptation de l'image √† n'importe quel rapport d'aspect de la fen√™tre du navigateur. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ds/jr/45/dsjr45-khpwum64yaoqvndmfynw.jpeg"></div><br><h3>  Diagrammes de niveau </h3><br>  En fait, les niveaux eux-m√™mes sont cr√©√©s dans l'√©diteur 3D, √† savoir leur g√©om√©trie, la cartographie des textures, la cuisson des ombres, etc.  J'ai d√©crit tout cela dans la premi√®re partie.  Pourquoi existe-t-il d'autres r√©gimes?  Le fait est que Three.js n'offre aucun type de moteur physique, et j'utilise des sch√©mas de niveaux pour identifier les obstacles. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pk/7u/j6/pk7uj6hvp3cyrkehdo_ohagtfnc.jpeg"></div><br>  Three.js pour r√©soudre le probl√®me de collision n'offre que le lancer de rayons - le moyen le plus simple de d√©terminer l'intersection de la g√©om√©trie des objets.  En principe, il peut √™tre utilis√©, et je l'ai m√™me fait dans l'un de mes autres projets.  C'√©tait une ville virtuelle directement sur le site, dans le navigateur.  Vous pouvez vous d√©placer dans la ville et ne pas passer √† travers les murs. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ud/8y/4s/ud8y4smxvagibioopva3vc1ajoc.jpeg"></div><br>  Dans le cas o√π l'intersection de la g√©om√©trie du joueur et du b√¢timent se produit pendant le mouvement, j'ai mis en ≈ìuvre la r√©pulsion du joueur d'une certaine distance dans la direction oppos√©e au mur.  Mais pour cela, les objets doivent √™tre parall√©l√©pip√®des.  Autour de quelques objets complexes, j'ai cr√©√© des collisionneurs (nous appellerons les objets invisibles qui jouent le r√¥le d'obstacles et emp√™chent le joueur de se traverser), le long desquels des intersections ont √©t√© am√©nag√©es.  Et les parties inf√©rieures de certains b√¢timents, qui sont simplement des ¬´bo√Ætes¬ª, √©taient parfois utilis√©es comme collisionneurs elles-m√™mes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fz/on/3e/fzon3eg8bjup0zvzs_cgg81lrmo.jpeg"></div><br>  Sur les objets g√©om√©triquement complexes, le lancer de rayons peut ne pas fonctionner ou se comporter de mani√®re inappropri√©e.  Et, juste comme solution, vous pouvez int√©grer dans l'objet non pas un, mais plusieurs petits collisionneurs invisibles sous forme de parall√©l√©pip√®des avec une transparence √† 100%, dessin√©s les uns √† c√¥t√© des autres et les uns sur les autres, r√©p√©tant grossi√®rement la forme de l'objet. <br><br>  Dans le jeu sur les donjons, le niveau est un seul objet long avec des mouvements coup√©s pour d√©placer le joueur.  En fait, pour r√©soudre le probl√®me de collision, on pourrait coller des collisionneurs invisibles si n√©cessaire et utiliser le raytracing.  Cependant, j'ai d√©cid√© d'aller dans l'autre sens. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rz/ul/ln/rzullnsn4a_befsw71uctfqjyzg.jpeg"></div><br><ul><li>  Tout d'abord, je voulais automatiser le processus de cr√©ation d'un tableau de collisionneurs. </li><li>  Deuxi√®mement, vous ne pouvez utiliser que des informations sur les collisionneurs, c'est-√†-dire leurs coordonn√©es dans l'espace, et ne pas charger la sc√®ne 3D elle-m√™me avec des objets vides suppl√©mentaires. </li><li>  Troisi√®mement, puisque le jeu n'utilise qu'une vue lat√©rale et que l'une des coordonn√©es ne change jamais lors du d√©placement, vous pouvez utiliser le calcul des intersections en seulement deux coordonn√©es. </li><li>  Et quatri√®mement, apr√®s tout, en fait, il y aura un sch√©ma de niveaux.  De plus, trouver de nouveaux niveaux est tout simplement pratique √† partir d'un tel sch√©ma.  Vous pouvez simplement faire glisser des blocs autour de l'√©cran dans n'importe quel √©diteur graphique, construire de nouveaux couloirs et obstacles, puis ex√©cuter le script et obtenir des informations sur les collisionneurs.  Autrement dit, le probl√®me de l'√©diteur de niveau est partiellement r√©solu. </li></ul><br>  J'ai √©crit un script qui prend des param√®tres d'entr√©e tels que le nom du fichier de sch√©ma de niveaux (png) et la couleur, dont le remplissage est interpr√©t√© comme un obstacle.  La couleur d'espace libre par d√©faut est le noir.  Pour le traitement par le script, le sch√©ma de chaque niveau doit √™tre enregistr√© dans un fichier png s√©par√©.  Par exemple, pour le niveau le plus bas, cela ressemble √† ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ba/rg/kw/bargkw-qc8xqbvpszjia3zvnllq.jpeg"></div><br>  J'ai convenu qu'un bloc devrait avoir une largeur de 80 pixels et une hauteur de 48 pixels.  Cela correspond √† 4 x 2,4 m√®tres dans le monde 3D.  Il serait possible de faire 40 x 24 pixels, c'est-√†-dire dix fois, mais dans l'image, cela semble petit. <br><br>  Le r√©sultat du script au premier niveau (l'image est rogn√©e √† droite): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xx/zu/9f/xxzu9fsntacg-giuqubbj75iq5k.jpeg"></div><br>  Le script est ex√©cut√© dans le navigateur.  Je pense que le balisage html ne sert √† rien, c'est √©l√©mentaire: des champs de saisie de donn√©es et un bouton de d√©marrage.  Ensuite, l'image lue est affich√©e sur la toile.  Et √† la suite du script, un tableau est affich√© sous l'image √† l'√©chelle mondiale 3D, qui contient les coordonn√©es inf√©rieure gauche et sup√©rieure droite de chaque bloc, et avec le d√©calage sp√©cifi√© dans le script pour chaque niveau.  Ce tableau peut √™tre copi√© et coll√© dans la liste des collisionneurs √† utiliser dans le jeu (plus d'informations ci-dessous), il sera stock√© dans une sorte de constante.  Les coordonn√©es apparaissent √©galement sur l'image elle-m√™me, mais dans le cadre de r√©f√©rence de l'image 2D.  Ces nombres sont affich√©s au centre de chaque bloc et vous permettent de v√©rifier si tous les blocs sont inclus dans le calcul.  √Ä eux seuls, ces num√©ros ne sont n√©cessaires que pour une inspection visuelle.  Certains blocs, comme les colonnes entre lesquelles passe le joueur, ne doivent pas √™tre compt√©s.  A propos des objets exclus du calcul - ci-dessous. <br><br>  De plus, par exemple, au deuxi√®me niveau, il y a de fines plaques horizontales sur lesquelles le joueur marche.  Ils doivent √™tre pris en consid√©ration.  Par cons√©quent, vous devez vous assurer que les num√©ros y figurent √©galement.  Dans le diagramme, faites-les 2 pixels de haut. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pq/vm/w1/pqvmw1tghz4brz--t0qh6y-bzek.jpeg"></div><br><br>  Maintenant, sur la fa√ßon dont le script prend en compte les blocs: <br><br><ul><li>  Le sch√©ma est trait√© par blocs de 80x48, dans chacun desquels une zone est prise du 2e au 79e pixels horizontalement et du 2e au 47e pixels verticalement.  Le premier et le dernier pixel ne sont pas utilis√©s afin que autour des blocs vous puissiez cr√©er un cadre noir d'une largeur de 1 pixel, cela am√©liore la perception visuelle du circuit et facilite sa cr√©ation. </li><li>  Tous les pixels de la ligne sup√©rieure du bloc sont affich√©s.  S'il y en a des color√©s, les coordonn√©es du bloc vont du premier au dernier pixel color√© horizontalement et √† la pleine hauteur du bloc verticalement dans le tableau final.  Ce sera un bloc vierge √† pleine ou partielle largeur. </li><li>  Tous les pixels de la derni√®re ligne du bloc sont affich√©s.  S'il y a des couleurs parmi eux, mais qu'il n'y en a pas de couleur dans la rang√©e sup√©rieure, les coordonn√©es du bloc vont du premier au dernier pixel color√© horizontalement et 3 pixels verticalement du bas au tableau final.  Ce sera une plateforme sur laquelle marcher.  √Ä l'int√©rieur d'un bloc, il peut y avoir plusieurs plates-formes horizontales.  Les plateformes ne sont reconnues qu'en bas du bloc.  Les coordonn√©es de la plate-forme sont ¬´enfonc√©es¬ª dans un bloc, qui est situ√© en dessous, de sorte que la surface de la plate-forme soit au m√™me niveau que les blocs voisins - pas les plates-formes. </li><li>  Les colonnes et autres d√©corations √† l'int√©rieur d'un bloc vide ne sont pas trait√©es, car seules les lignes sup√©rieure et inf√©rieure de pixels sont prises en compte.  Par cons√©quent, √† l'int√©rieur du bloc, vous pouvez placer un d√©cor, des explications pour le diagramme, des pointeurs, des colonnes, etc., sans craindre que cela n'affecte en quelque sorte le r√©sultat du script. </li></ul><br>  Ensuite, toutes les coordonn√©es re√ßues du r√©seau sont traduites √† l'√©chelle du monde 3D, multipli√©e par le coefficient de son √©chelle (qui a √©t√© s√©lectionn√© dans l'√©diteur 3D lors de sa cr√©ation).  La matrice est pr√™te √† √™tre utilis√©e dans le jeu.  Le code du script a √©t√© √©crit √† la h√¢te, il ne pr√©tend donc pas √™tre √©l√©gant, mais il remplit sa t√¢che. <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre><code class="javascript hljs">ap = { <span class="hljs-comment"><span class="hljs-comment">//      (  ),   3D   lvd: { 'lv01.png': { invw: false, invh: true, level_dw: -8.5, level_dh: -1.5 }, 'lv02.png': { invw: true, invh: true, level_dw: -19.5, level_dh: -5.5 } }, blockw: 80, //   2D blockh: 48, //   2D sc3d: 0.05, //,   3D  ex: 100, //  3D (-   ) v: { data: [] }, i: 0, par: {}, datai: [], resi: [], ars: [], fStopEncode: false, blockColor: function(cl) { document.getElementById('input_cl').value = cl; }, startEncode: function() { //      for (var key in ap.lvd) { ap.lvd[key].dw = ap.lvd[key].level_dw * ap.blockw; ap.lvd[key].dh = ap.lvd[key].level_dh * ap.blockh; }; document.getElementById('startbtn').style.display = 'none'; document.getElementById('startmsg').style.display = 'block'; var cl = document.getElementById('input_cl').value; var fld = document.getElementById('input_fld').value; var nm = document.getElementById('input_nm').value; ap.nm = nm; ap.par = { path: [fld + '/', nm], key: [nm], cl: aplib.hexToRgb(cl.substring(1, 7)) }; setTimeout(function() { ap.datai[ap.par.key] = new Image(); ap.datai[ap.par.key].onload = function() { ap.parseData(); }; ap.datai[ap.par.key].src = ap.par.path[0] + ap.par.path[1]; }, 500); }, stopEnode: function(e) { if (typeof ap !== "undefined") { if (e.keyCode == 27) { console.log('stop'); ap.fStopEncode = true; }; }; }, parseData: function() { ap.w = ap.datai[ap.par.key[0]].width, ap.h = ap.datai[ap.par.key[0]].height; aplib.initCanv(ap.w, ap.h); ctx.drawImage(ap.datai[ap.par.key[0]], 0, 0, ap.w, ap.h, 0, 0, ap.w, ap.h); ap.ars = []; ap.i = 0; setTimeout(function() { ap.parseData1(); }, 1000); }, parseData1: function() { if (ap.i &lt; ap.par.key.length) { document.getElementById('info').innerHTML = '' + ap.nm; ap.blocksw = Math.floor(ap.w / ap.blockw); ap.blocksh = Math.floor(ap.h / ap.blockh); ap.ar = []; ap.arv = {}; ap.hi = 0; ctx.fillStyle = '#CCCCCC'; ap.parseData2(); } else { document.getElementById('startbtn').style.display = 'block'; document.getElementById('startmsg').style.display = 'none'; }; }, parseData2: function() { if (ap.hi &lt; ap.blocksh) { ap.ar.push([]); ap.wi = 0; ap.parseData3(); } else { ap.parseData4(); }; }, parseData3: function() { var k = ''; if (ap.wi &lt; ap.blocksw) { var fground = true, fvari = false, fempty = true; var upx1 = 0, upx2 = 0, dnx1 = 0, dnx2 = 0; var upxf = false, dnxf = false; for (var wii = 1; wii &lt; ap.blockw - 2 + 2; wii++) { pixelDatai = ctx.getImageData(ap.wi * ap.blockw + wii, ap.hi * ap.blockh + 1, 1, 1).data; //  pixelDatai2 = ctx.getImageData(ap.wi * ap.blockw + wii, (ap.hi + 1) * ap.blockh - 3, 1, 1).data; //  if ((pixelDatai[0] == ap.par.cl.r) &amp; (pixelDatai[1] == ap.par.cl.g) &amp; (pixelDatai[2] == ap.par.cl.b)) { //   ground    if (upxf == false) { upxf = true; upx1 = wii; }; } else { //    if (upxf == true) { upx2 = wii + 1; upx1--; //   dy = -1; // 3D       1 ap.v.data.push([ap.wi * ap.blockw + upx1, ap.hi * ap.blockh + dy, ap.wi * ap.blockw + upx2, ap.hi * (ap.blockh) + ap.blockh - 1]); upxf = false; upx1 = 0; upx2 = 0; }; }; if ((pixelDatai2[0] == ap.par.cl.r) &amp; (pixelDatai2[1] == ap.par.cl.g) &amp; (pixelDatai2[2] == ap.par.cl.b)) { //   ground     if (upxf == false) { if (dnxf == false) { dnxf = true dnx1 = wii; }; }; } else { if (upxf == false) { if (dnxf == true) { dnx2 = wii + 1; dnx1--; //   dy = 2; // 3D    2 ap.v.data.push([ap.wi * ap.blockw + dnx1, (ap.hi + 1) * ap.blockh - 3 + dy, ap.wi * ap.blockw + dnx2, (ap.hi + 1) * ap.blockh - 3 + 2 + dy]); dnxf = false; dnx1 = 0; dnx2 = 0; }; }; }; }; if (ap.fStopEncode == true) { ap.hi = ap.h, ap.wi = ap.w, i = ap.par.key.length; }; setTimeout(function() { ap.wi++; ap.parseData3(); }, 10); } else { ap.hi++; ap.parseData2(); }; }, parseData4: function() { setTimeout(function() { var t, tw, tx, ty, ar = []; //  for (var i = 0; i &lt; ap.v.data.length; i++) { ar = ap.v.data[i]; t = ar[0] + ';' + (ar[1]+1) + '&lt;br/&gt;' + ar[2] + ';' + (ar[3]+1); tw = ar[2] - ar[0]; tx = ar[0]; ty = ar[1] + Math.floor((ar[3] - ar[1]) / 2) - 0; aplib.Tex2Canvas(ctx, t, 'normal 10px Arial', 10, '#CCCCCC', tx, ty, tw, 0, 'center', 'top'); }; ap.parseData5(); }, 10); }, parseData5: function() { var t, tw, tx, ty, ar = [], n; //   3D var lv = ap.lvd[ap.nm]; for (var i = 0; i &lt; ap.v.data.length; i++) { ar = ap.v.data[i]; ar[0] += lv.dw; ar[1] += lv.dh; ar[2] += lv.dw; ar[3] += lv.dh; if (lv.invh == true) { n = -ar[1]; ar[1] = -ar[3]; ar[3] = n; }; if (lv.invw == true) { n = -ar[0] ar[0] = -ar[2]; ar[2] = n; }; ar[0] = Math.round(ap.sc3d * ar[0] * ap.ex) / ap.ex; ar[1] = Math.round(ap.sc3d * ar[1] * ap.ex) / ap.ex; ar[2] = Math.round(ap.sc3d * ar[2] * ap.ex) / ap.ex; ar[3] = Math.round(ap.sc3d * ar[3] * ap.ex) / ap.ex; }; //    ap.v.data.sort(aplib.sortBy0); console.log(ap.v.data); document.getElementById('divresult').innerHTML = JSON.stringify(ap.v.data); } }; aplib = { hexToRgb: function(hex) { var arrBuff = new ArrayBuffer(4); var vw = new DataView(arrBuff); vw.setUint32(0, parseInt(hex, 16), false); var arrByte = new Uint8Array(arrBuff); return { r: arrByte[1], g: arrByte[2], b: arrByte[3], s: arrByte[1] + "," + arrByte[2] + "," + arrByte[3] }; }, //   canvas Tex2Canvas: function(ctx, t, font, lin, fcolor, x, y, w, h, haln, valn) { //left, right, center, center-lim- ctx.font = font; ctx.fillStyle = fcolor; var l = 0; var tx = x; var ftw = false; var tw = 1; var arr = t.split('&lt;br/&gt;'); for (var i = 0; i &lt; arr.length; i++) { arr[i] = arr[i].split(' '); }; for (var i = 0; i &lt; arr.length; i++) { var s = '', slen = 0, s1 = '', j = 0; while (j &lt; arr[i].length) { var wordcount = 0; while ((slen &lt; w) &amp; (j &lt; arr[i].length)) { s = s1; s1 = s + arr[i][j] + ' '; slen = ctx.measureText(s1).width; if (slen &lt; w) { j++; wordcount++; } else { if (wordcount &gt; 0) { s1 = s; } else { j++; }; }; }; ftw = false; tw = ctx.measureText(s1).width; if (haln == 'center') { tx = x + Math.round((w - tw) / 2); }; if (haln == 'right') { tx = x + Math.round((w - tw)); }; if (haln == 'center-lim') { if (tw &gt; w) { tw = w; }; if (tw &lt; 1) { tw = 1; }; tx = x + Math.round((w - tw) / 2); ftw = true; }; if (ftw == false) { ctx.fillText(s1, tx, l * lin + y); } else { ctx.fillText(s1, tx, l * lin + y, tw); }; if (s1 == '') { j = arr[i].length + 1; }; l++; s1 = ''; slen = 0; }; }; return Math.round(tw); }, // canvas initCanv: function(w, h) { function canvErr() { document.getElementById('divcanv').innerHTML = '&lt;div style="height:130px"&gt;&lt;/div&gt;&lt;div style="width:440px; border:#FFFFFF 1px solid; margin:10px; padding:4px; background-color:#000000"&gt;&lt;p class="txterr"&gt;---&gt; Error&lt;br/&gt;HTML5 Canvas is not supported!&lt;br/&gt;Please, update your browser!&lt;/p&gt;&lt;/div&gt;'; }; if (w == 0) { w = 740; h = 680; }; elcanv = document.getElementById('divcanv'); elcanv.innerHTML = '&lt;canvas id="canv" style="width:' + w + 'px; height:' + h + 'px; display:block;" width="' + w + '" height="' + h + '"&gt;&lt;/canvas&gt;'; canvas1 = document.getElementById('canv'); if (!canvas1) { canvErr(); return 0; } else { if (canvas1.getContext) { ctx = canvas1.getContext('2d'); ctx.clearRect(0, 0, w, h); return 1; } else { canvErr(); }; }; }, sortBy0: function(i, ii) { if (i[0] &gt; ii[0]) return 1; else if (i[0] &lt; ii[0]) return -1; else return 0; } };</span></span></code> </pre> <br></div></div><br>  Maintenant - sur la fa√ßon dont le jeu fonctionne avec un tableau de blocs.  Le jeu utilise des couloirs (niveaux) qui se croisent.  Lorsqu'un joueur se transforme en couloir, un nouveau tableau de blocs est connect√©: et pour chaque couloir, en cons√©quence, son propre tableau est obtenu, obtenu √† partir de son sch√©ma de niveaux.  Pendant le mouvement du joueur, ses coordonn√©es sont v√©rifi√©es pour √™tre √† l'int√©rieur de chaque bloc.  Et s'il est √† l'int√©rieur d'un bloc, nous obtenons une collision.  Mais √† chaque mouvement du joueur, nous n'avons pas besoin de chercher des intersections avec tous les blocs du niveau, car il peut y en avoir beaucoup.  Cr√©ez un tableau compos√© uniquement des blocs les plus proches du joueur. <br><br><pre> <code class="javascript hljs">collisionsUpdate: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y, dw, dh</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> coll = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ap.v.lv.d.length; i++) { o = ap.v.lv.d[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((o[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;= x - ap.v.dw) &amp; (o[<span class="hljs-number"><span class="hljs-number">2</span></span>] &lt;= x + ap.v.dw)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((o[<span class="hljs-number"><span class="hljs-number">1</span></span>] &gt;= y - ap.v.dh) &amp; (o[<span class="hljs-number"><span class="hljs-number">3</span></span>] &lt;= y + ap.v.dh)) { coll.push(o); }; }; }; ap.v.coll = coll; },</code> </pre> <br>  Ici, √† l'entr√©e x, y sont les coordonn√©es actuelles du joueur, dw, dh est la distance √† laquelle vous souhaitez rechercher des blocs horizontalement et verticalement, par exemple 12 et 8 m√®tres.  En d'autres termes, prenez tous les blocs autour du joueur dans un carr√© de 24x16 m√®tres.  Ils participeront √† la recherche d'affrontements.  ap.v.lv.d [i] est un √©l√©ment d'un tableau de blocs du niveau actuel, en fait, il est lui-m√™me aussi un tableau de 4 nombres d√©finissant les limites d'un bloc - [x1, y1, x2, y2], donc, pour v√©rifier le carr√© horizontalement, nous prenons des √©l√©ments d'indices 0 et 2, et verticalement - 1 et 3. S'il y a une correspondance, ajoutez ce bloc √† la liste des collisions ap.v.coll. <br><br>  Lorsque le joueur bouge, nous mettrons √† jour cette liste de collisions, mais, pour √©conomiser les performances, nous ne le ferons pas √† chaque √©tape (ou plut√¥t, en rendant le cadre), mais lorsque le joueur quitte un certain carr√©, l√©g√®rement plus petit, sp√©cifi√© dans ap.v.collwStep et ap.v.collhStep, par exemple 8 et 4 m√®tres.  Autrement dit, nous allons r√©assembler le tableau de collision lorsque le joueur passe un certain chemin horizontalement ou verticalement √† partir de sa position d'origine.  En m√™me temps, rappelons-nous sa position √† laquelle nous avons remont√© le tableau afin de l'utiliser pour la prochaine it√©ration.  pers [ax] - ici, par hache, nous entendons l'axe des coordonn√©es (ax), il peut √™tre x ou z, selon la direction du couloir le long duquel le joueur marche. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   if ((Math.abs(pers[ax] - ap.v.collw) &gt; ap.v.collwStep) || (Math.abs(pers.y - ap.v.collh) &gt; ap.v.collhStep)) { ap.v.collw = pers[ax]; ap.v.collh = pers.y; ap.collisionsUpdate(pers[ax], pers.y, 12, 8); };</span></span></code> </pre> <br>  Pourquoi de telles difficult√©s?  Pourquoi ne pas utiliser toute la gamme de collisions au niveau et ne pas prendre de bain de vapeur.  Le fait est que la d√©tection de collision est effectu√©e selon un algorithme beaucoup plus complexe, et il n'est pas rentable de v√©rifier la collision avec absolument tous les blocs de niveau, et non les plus proches, √† chaque rendu de la trame.  (Bien que ce ne soit pas exact.) <br><br>  La d√©finition des collisions √† chaque rendu d'une trame √† l'aide du tableau de collisions pr√©par√© ci-dessus: <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="javascript hljs">collisionsDetect: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y, xOld, yOld, up</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//up=-1 -  var res = false, o; var collw = false, collh = false, collwi = false, collhi = false, collhsup = false, support = [], supportf = false, fw = false, upb = -1; var bub = -1, bubw = 0; var pw2 = ap.v.player.pw2, ph2 = ap.v.player.ph2, supportd = ap.v.supportd; for (var i = 0; i &lt; ap.v.coll.length; i++) { o = ap.v.coll[i]; collwi = false; collhi = false; collhsup = false; fw = false; if ((x + pw2 &gt;= o[0]) &amp; (x - pw2 &lt;= o[2])) { if ((y + ph2 &gt; o[1]) &amp; (y - ph2 &lt; o[3])) { collwi = true; }; }; //     if ((xOld + pw2 &gt;= o[0]) &amp; (xOld - pw2 &lt;= o[2])) { if ((yOld + ph2 &gt; o[1]) &amp; (yOld - ph2 &lt; o[3])) { bub = i; if (Math.abs(xOld - o[0]) &lt; Math.abs(xOld - o[2])) { bubw = -1; } else { bubw = 1; }; }; }; if ((x &gt;= o[0]) &amp; (x &lt;= o[2])) { fw = true; //  i   }; if ((y + ph2 &gt;= o[1]) &amp; (y - ph2 &lt;= o[3])) { if ((x &gt; o[0]) &amp; (x &lt; o[2])) { collhi = true; //  if (y + ph2 &gt; o[3]) { collhsup = true; supportf = true; support = o; upb = 1; }; //  if (y - ph2 &lt; o[1]) { upb = -1; }; }; }; if ((y - ph2 &gt;= o[3] + supportd - 0.11) &amp; (y - ph2 &lt;= o[3] + supportd + 0.001)) { if (fw == true) { collhi = true; collh = true; res = true; collhsup = true; supportf = true; support = o; }; }; if (collwi &amp; collhi) { res = true; }; if (collwi) { collw = true; }; if (collhi) { collh = true; }; }; return { f: res, w: collw, h: collh, support: support, supportf: supportf, upb: upb, bub: bub, bubw: bubw }; },</span></span></code> </pre> <br></div></div><br>  Ici x, y, xOld, yOld sont les coordonn√©es nouvelles et actuelles du joueur.  Les nouveaux sont calcul√©s sur simple pression d'un bouton, en fonction d'une vitesse de d√©placement donn√©e, c'est-√†-dire qu'il s'agit de coordonn√©es possibles.  Ils sont v√©rifi√©s pour voir s'ils entrent dans un bloc de la liste des collisions.  S'ils tombent, ils retournent aux anciens et le joueur ne passe pas √† travers l'obstacle.  Et s'ils ne tombent pas, ils deviennent courants.  pw2 et ph2 sont la moiti√© de la largeur et de la hauteur du collisionneur imaginaire du joueur (largeur du joueur / 2, hauteur du joueur / 2).  La sortie est √©mise s'il y a une collision horizontale et verticale (collw, collh), s'il y a un bloc de support sous le lecteur (supportf) - cela indique clairement s'il faut continuer l'animation de chute ou si le joueur est simplement pass√© √† un bloc voisin, et ainsi de suite.  Ne me demandez simplement pas pourquoi j'y ai ajout√© 0,001 et soustrait 0,11.  C'est une terrible b√©quille qui emp√™che de tomber √† travers les blocs et l'effet de gigue lors d'une collision avec un obstacle horizontal ... Cette fonction fonctionne, mais elle doit √™tre r√©√©crite de mani√®re normale.  L'optimisation de cette fonction fait √©galement d√©faut. <br><br>  Je pense qu'avec les collisions, √ßa vaut la peine de s'arr√™ter l√†. <br><br>  Il est difficile de dire √† quel point ma m√©thode est plus rapide ou peut-√™tre plus lente que le lancer de rayons, mais dans ce dernier cas, Three.js stocke √©galement un tableau d'objets qui participent au syst√®me de collision.  C'est juste que les collisions l√†-bas sont d√©termin√©es par la m√©thode d'√©mission du faisceau et son intersection avec les plans des c√¥t√©s des objets, et avec moi, en d√©terminant si les coordonn√©es d'un objet sont √† l'int√©rieur de l'autre le long de chacun des deux axes. <br><br>  Le jeu a √©galement des objets en mouvement (requin) et des objets marqueurs qui d√©clenchent une sorte d'animation (par exemple, le contact avec l'eau d√©clenche le mouvement d'un requin).  Tous ces objets participent √©galement aux collisions, et certains avec des coordonn√©es variant dans le temps.  L√†, curieusement, tout est plus simple: lors du d√©placement de l'objet ses coordonn√©es sont compar√©es aux coordonn√©es du joueur. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mj/cx/rz/mjcxrz4m_3fwkm7kep-yrtbp-qa.jpeg"></div><br><h3>  Gamepad </h3><br>  En g√©n√©ral, la maintenance d'une manette de jeu javascript dans un navigateur n'est pas une t√¢che triviale.  Il n'y a aucun √©v√©nement de pression et de rel√¢chement de bouton.  Il n'y a que des √©v√©nements qui connectent et d√©connectent le p√©riph√©rique et l'√©tat qui peut √™tre obtenu par interrogation p√©riodique, puis comparez-le avec le pr√©c√©dent. <br><br>  Une vid√©o montrant le fonctionnement de la manette de jeu dans un navigateur sur une tablette sous Windows 8.1 et un PC sous Windows 10. Cependant, la tablette est une ancienne, sortie en 2014, donc l'√©clairage dynamique est d√©sactiv√© dans le jeu. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/knkMKB5uizk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Pour interroger la manette de jeu, une fonction appel√©e une fois toutes les 100 millisecondes est utilis√©e.  Il est d√©fini √† l'aide de la fonction de ma biblioth√®que m3d.lib.globalTimer.addEvent. <br><br><pre> <code class="javascript hljs">m3d.lib.globalTimer.addEvent({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'gamepad'</span></span>, <span class="hljs-attr"><span class="hljs-attr">ti</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-attr"><span class="hljs-attr">f</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> st = m3d.gamepad.state(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (st == <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (contr.gpDownFlag == <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { m3d.gamepad.resetH(); }; }; } });</code> </pre> <br>  GlobalTimer est ici le syst√®me de gestion d'√©v√©nements javascript setInterval timer que j'ai √©crit.  L√†, simplement une s√©rie d'√©v√©nements sont ajout√©s √† un certain tableau qui doivent √™tre appel√©s √† diff√©rents intervalles.  Ensuite, un temporisateur setInterval est d√©fini avec la fr√©quence correspondant √† l'√©v√©nement avec la fr√©quence la plus √©lev√©e de toutes.  Le temporisateur interroge la fonction m3d.lib.globalTimer.update (), qui parcourt la liste de tous les √©v√©nements et ex√©cute les fonctions de ceux qui sont venus pour s'ex√©cuter.  Lors de l'ajout ou de la suppression d'√©v√©nements, la fr√©quence d'intervalle peut √©galement changer (par exemple, si vous supprimez l'√©v√©nement le plus rapide). <br><br>  Le jeu d√©finit √©galement des gestionnaires pour chaque touche de la manette de jeu: 'a' est pour l'axe (hache), 'b' pour le bouton (bouton), et 11 est l'√©cart gauche le long de l'axe horizontal de la croix (comme si son bouton 1), 12 - la d√©viation droite le long de l'axe horizontal de la croix (comme si son bouton 2), 21 et 22 - pour l'axe vertical.  Par exemple: <br><br>  [¬´a¬ª, 11], <br>  ['b', 3] <br><br>  signifie que la fonction suivante sera r√©gl√©e en m√™me temps pour la d√©viation le long de l'axe horizontal vers la gauche et pour le bouton 3 (gauche).  Eh bien, une fonction est d√©finie qui sera ex√©cut√©e lorsque le bouton sera enfonc√©, puis rel√¢ch√©. <br><br><pre> <code class="javascript hljs"> m3d.gamepad.setHandler( [ [<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>], [<span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] ], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (contr.btState.lt == <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { contr.keyDownFlag = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; contr.btState.lt = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; contr.gpDownFlag = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; apcontrolsRenderStart(); }; }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function">) </span></span>{ contr.btState.lt = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; m3d.contr.controlsCheckBt(); apcontrolsRenderStart(); } );</code> </pre> <br>  Ici, apcontrolsRenderStart () est une fonction qui lance un rendu s'il n'est pas d√©j√† en cours d'ex√©cution.  En g√©n√©ral, le support de la manette de jeu est √©troitement li√© √† ma biblioth√®que m3d, donc si je continue √† d√©crire toutes ses fonctionnalit√©s, il s'√©tirera tr√®s longtemps ... <br><br>  Je ne vous en donnerai qu'une partie: la manette de jeu, dans laquelle j'ai impl√©ment√© l'initialisation de la manette de jeu, l'installation de gestionnaires et l'interrogation d'√©tat de la mani√®re la plus simple. <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="javascript hljs">gamepad: { <span class="hljs-attr"><span class="hljs-attr">connected</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">gamepad</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">gamepadKey</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-attr"><span class="hljs-attr">axesCount</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">buttonsCount</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">f</span></span>: [], <span class="hljs-comment"><span class="hljs-comment">//  fup: [], //  fval: [], //      fupCall: [], //   buttons: [], //link to f [0.. ] axes: [], //link to f [0.. ] initCb: function() {}, resetH: function() {}, init: function(gp) { var f = false; for (var key in gp) { if (f == false) { if (gp[key] != null) { if (typeof gp[key].id !== "undefined") { f = true; this.connected = true; this.gamepad = gp[key]; this.gamepadKey = key; }; }; }; }; if (typeof this.gamepad.axes !== "undefined") { this.axesCount = this.gamepad.axes.length; }; if (typeof this.gamepad.buttons !== "undefined") { this.buttonsCount = this.gamepad.buttons.length; }; this.f = []; this.fup = []; this.fval = []; this.fupCall = []; this.axes = []; for (var i = 0; i &lt; this.axesCount * 2; i++) { this.axes.push(-1); }; this.buttons = []; for (var i = 0; i &lt; this.buttonsCount; i++) { this.buttons.push(-1); }; this.initCb(); }, setHandlerReset: function(f) { this.resetH = f; }, setHandler: function(ar, f, fup) { //ar['b',3] ['a',11] var fi, bt, ax, finext, finexta; finexta = false; for (var i = 0; i &lt; ar.length; i++) { if (ar[i][0] == 'a') { ax = Math.floor(ar[i][1] / 10); bt = ar[i][1] - (ax * 10); bt = ax * 2 + bt - 3; fi = this.axes[bt]; if (fi == -1) { //   fi = this.f.length; if (finexta == false) { finexta = true; this.f.push(f); this.fup.push(fup); this.fval.push(0); this.fupCall.push(true); this.axes[bt] = fi; } else { fi--; this.f[fi] = f; this.fup[fi] = fup; this.axes[bt] = fi; }; } else { this.f[fi] = f; this.fup[fi] = fup; }; } else if (ar[i][0] == 'b') { bt = ar[i][1] - 1; fi = this.buttons[bt]; if (fi == -1) { //   fi = this.f.length; if (finexta == false) { finexta = true; this.f.push(f); this.fup.push(fup); this.fval.push(0); this.fupCall.push(true); this.buttons[bt] = fi; } else { fi--; this.f[fi] = f; this.fup[fi] = fup; this.buttons[bt] = fi; }; } else { this.f[fi] = f; this.fup[fi] = fup; }; }; }; }, state: function() { var pressed = false; var fi, fval, axesval; for (var i = 0; i &lt; this.fval.length; i++) { this.fval[i] = 0; }; //   var gp = navigator.getGamepads()[this.gamepadKey]; for (var i = 0; i &lt; this.axesCount; i++) { axesval = Math.round(gp.axes[i]); if (axesval &lt; 0) { pressed = true; fi = this.axes[i * 2]; if (fi != -1) { this.fval[fi] = gp.axes[i]; this.fupCall[fi] = true; }; } else if (axesval &gt; 0) { pressed = true; fi = this.axes[i * 2 + 1]; if (fi != -1) { this.fval[fi] = gp.axes[i]; this.fupCall[fi] = true; }; }; }; for (var i = 0; i &lt; this.buttonsCount; i++) { if (gp.buttons[i].pressed == true) { pressed = true; fi = this.buttons[i]; if (fi != -1) { this.fval[fi] = 1; this.fupCall[fi] = true; }; }; }; for (var i = 0; i &lt; this.fval.length; i++) { fval = this.fval[i]; if (fval != 0) { this.f[i](this.fval[i]); } else { if (this.fupCall[i] == true) { this.fupCall[i] = false; this.fup[i](this.fval[i]); }; }; }; return pressed; } }, //gamepad</span></span></code> </pre> <br></div></div><br>  En g√©n√©ral, le support du gamepad dans le jeu est encore incomplet: seul le support du gamepad le plus simple est impl√©ment√©, mais pas celui qui, par exemple, est utilis√© dans la XBox, car je ne l'ai pas.  Si je le re√ßois, je le programme et je travaille avec.  L√†, il sera possible d'ajuster la vitesse du personnage, c'est-√†-dire qu'il sera possible de se d√©placer √† n'importe quelle vitesse dans la plage de l'√©tape √† la course.  Ceci est r√©alis√© en prenant des param√®tres fractionnaires des axes.  Ma manette de jeu ne renvoie que les nombres entiers -1 et 1. De plus, ma manette de jeu a une croix d√©go√ªtante, et lorsqu'elle est enfonc√©e √† gauche ou √† droite, elle appuie simultan√©ment vers le bas ou vers le haut.  Par cons√©quent, je n'ai pas utilis√© le haut et le bas sur la croix et je l'ai dupliqu√© avec les boutons √† droite de la manette de jeu ... √Ä la sortie du jeu, je pr√©vois de cr√©er plusieurs profils de manettes de jeu.  De plus, dans le cas de la connexion de plusieurs manettes de jeu, seule cette derni√®re sera utilis√©e jusqu'√† pr√©sent. <br><br><h3>  √âcran r√©actif </h3><br>  Le jeu est con√ßu pour un rapport d'aspect de 16: 9.  Mais j'ai ajout√© un ajustement horizontal automatique de ¬± 10% de sorte que dans la fen√™tre du navigateur √©largie, il n'y avait pas de telles barres noires sur les c√¥t√©s: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ey/bn/a5/eybna55ofeptyziaakgix67heea.jpeg"></div><br>  Et ce serait comme √ßa: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vm/0n/aa/vm0naaertcqacqufxjadz-sdfyu.jpeg"></div><br>  En mode plein √©cran, il y aura un vrai 16: 9.  Il serait possible d'adapter l'image en g√©n√©ral √† n'importe quel rapport d'aspect de la fen√™tre du navigateur, mais je ne l'ai pas fait, car une fen√™tre large et basse conduirait √† un angle de vision trop grand, ce qui n'est pas bon du point de vue du gameplay: des impasses lointaines, des objets, des ennemis seront imm√©diatement visibles et tout ce que le joueur n'a pas encore besoin de voir.  Par cons√©quent, je me suis limit√© √† un ajustement √† ¬± 10% de 16: 9.  Cependant, pour les moniteurs √©troits (4: 3), j'ai n√©anmoins r√©alis√© la possibilit√© de passer de 16: 9 au mode d'adaptation de 4: 3 √† 16: 9 en appuyant sur la touche Y.  Mais pas plus large - donc, encore une fois, pour ne pas briser le gameplay.  Autrement dit, vous pouvez jouer dans le rapport 16: 9 classique, ou vous pouvez agrandir l'image √† la hauteur de la fen√™tre en la recadrant horizontalement.  Bien que cela ne soit pas tr√®s bon, par exemple, dans les situations d'arcade, lorsque quelque chose vole vers le joueur depuis le c√¥t√©.  Il reste peu de temps pour la r√©action.  Mais vous pouvez toujours revenir rapidement au mode classique. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/re/bp/ci/rebpciy7i7vmap1bwt_ijmub2fk.jpeg"></div><br>  L'adaptation de l'√©cran, ainsi que toutes les touches de raccourci utilis√©es dans le jeu sont pr√©sent√©es dans la vid√©o suivante: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/FamXdunFFHY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  En fait, le rapport hauteur / largeur est d√©fini dans les param√®tres du jeu. <br><br><pre> <code class="javascript hljs">aspect1:{<span class="hljs-attr"><span class="hljs-attr">w</span></span>:<span class="hljs-number"><span class="hljs-number">1280</span></span>, <span class="hljs-attr"><span class="hljs-attr">h</span></span>:<span class="hljs-number"><span class="hljs-number">720</span></span>, <span class="hljs-attr"><span class="hljs-attr">p</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>}, <span class="hljs-comment"><span class="hljs-comment">//16x9 +- 10% aspect2:{w:960, h:720, p:34}, //4x3 +- 34%</span></span></code> </pre> <br>  Et dans le jeu, lorsque vous appuyez sur Y, cela change: <br><br><pre> <code class="javascript hljs">contr.btCodesDn[<span class="hljs-number"><span class="hljs-number">89</span></span>] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//'y' if (m3dcache.setup.aspect.swch == 1) { m3dcache.setup.aspect = m3dcache.setup.aspect2; m3dcache.setup.aspect.swch = 2; } else { m3dcache.setup.aspect = m3dcache.setup.aspect1; m3dcache.setup.aspect.swch = 1; }; m3d.core.onWindowResize(0); m3d.contr.renderAll(); };</span></span></code> </pre> <br>  Ma biblioth√®que a un √©v√©nement qui se bloque sur la fen√™tre de redimensionnement.  En voici un fragment: <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="javascript hljs">m3dcache.v.vw = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerWidth; m3dcache.v.vh = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.innerHeight; m3dcache.v.vclipw = <span class="hljs-number"><span class="hljs-number">0</span></span>; m3dcache.v.vcliph = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> m3dcache.setup.aspect !== <span class="hljs-string"><span class="hljs-string">"undefined"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((m3dcache.setup.aspect.w == <span class="hljs-number"><span class="hljs-number">0</span></span>) || (m3dcache.setup.aspect.h == <span class="hljs-number"><span class="hljs-number">0</span></span>)) {} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o = m3d.lib.inBlock(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, m3dcache.setup.aspect.w, m3dcache.setup.aspect.h, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, m3dcache.v.vw, m3dcache.v.vh, <span class="hljs-string"><span class="hljs-string">'center'</span></span>, <span class="hljs-string"><span class="hljs-string">'center'</span></span>, <span class="hljs-string"><span class="hljs-string">'resize'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> m3dcache.setup.aspect.p !== <span class="hljs-string"><span class="hljs-string">"undefined"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o.clipx &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { ow = ow * (m3dcache.setup.aspect.p / <span class="hljs-number"><span class="hljs-number">100</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ow &gt; m3dcache.v.vw) { ow = m3dcache.v.vw; }; o = m3d.lib.inBlock(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, ow, oh, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, m3dcache.v.vw, m3dcache.v.vh, <span class="hljs-string"><span class="hljs-string">'center'</span></span>, <span class="hljs-string"><span class="hljs-string">'center'</span></span>, <span class="hljs-string"><span class="hljs-string">'resize'</span></span>); }; }; m3dcache.v.vclipw = o.clipx; m3dcache.v.vcliph = o.clipy; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> margx = o.clipx + <span class="hljs-string"><span class="hljs-string">'px'</span></span>, margy = o.clipy + <span class="hljs-string"><span class="hljs-string">'px'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'m3dcontainer'</span></span>).style.marginLeft = margx; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'m3dcontainer'</span></span>).style.marginTop = margy; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'renderer'</span></span>) !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'renderer'</span></span>).style.marginLeft = margx; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'renderer'</span></span>).style.marginTop = margy; }; m3dcache.v.vw = ow; m3dcache.v.vh = oh; }; };</code> </pre> <br></div></div><br>  m3d.lib.inBlock est √©galement une fonction de ma biblioth√®que, qui inscrit un rectangle dans un autre rectangle avec des param√®tres tels que le centrage, la mise √† l'√©chelle ou le recadrage, et affiche les nouvelles dimensions du rectangle inscrit, ainsi que les tailles des champs qui sont form√©s dans ce processus.  Sur la base de ces informations, le conteneur div de la fen√™tre est positionn√©.  'renderer' est un √©l√©ment de contexte de bloc d'une sc√®ne 3D.  Ensuite, la toile y est mise √† l'√©chelle en fonction des param√®tres obtenus. <br><br>  L'interface utilisateur est affich√©e dans le conteneur sur un √©l√©ment de canevas distinct.  En g√©n√©ral, l'arborescence de documents se compose de trois blocs DIV transparents avec positionnement absolu (plus ou moins possible, selon les besoins du jeu): en bas se trouve le canevas de la sc√®ne 3D, au-dessus se trouve le canevas pour IU et le haut est utilis√© pour animer des √©l√©ments d'interface et d'autres effets visuels .  Autrement dit, l'interface utilisateur n'est pas rendue en 3D, mais sur son knavass, ou calque.  La t√¢che de combiner les calques en une seule image est laiss√©e au navigateur.  Pour travailler avec l'interface utilisateur, j'ai un objet sp√©cial dans la biblioth√®que.  En bref - l'essentiel est le suivant.  Les listes de sprites avec des √©l√©ments d'interface utilisateur au format png avec transparence sont charg√©es.  De l√†, les √©l√©ments n√©cessaires sont pris - arri√®re-plans, boutons.  Et ils sont dessin√©s sur le canevas du milieu √† l'aide de la fonction js drawImage (img, ix, iy, iw, ih, x, y, w, h).  C'est-√†-dire que les fragments n√©cessaires de l'image sont affich√©s dans les positions n√©cessaires sur l'√©cran.  Les boutons sont affich√©s au-dessus des arri√®re-plans qui leur sont attach√©s - toutes leurs positions et tailles sont d√©finies dans la configuration de l'interface utilisateur.  Lors du redimensionnement d'une fen√™tre, les positions des √©l√©ments sur le canevas cible (sur lesquelles ils sont affich√©s) sont recalcul√©es, selon que tel ou tel √©l√©ment est centr√© horizontalement et verticalement ou accroch√© √† un coin ou une face de l'√©cran.  Cela cr√©e une interface utilisateur adaptative qui ne d√©pend pas du rapport d'aspect de l'√©cran.  Seulement, il est n√©cessaire de d√©finir la r√©solution minimale possible horizontalement et verticalement et de ne pas tomber en dessous afin que les √©l√©ments ne se chevauchent pas.  Je parlerai de l'interface utilisateur une autre fois, car l'article s'est av√©r√© volumineux, et je travaille toujours sur l'interface utilisateur, car il me manque encore beaucoup de fonctions.  Par exemple, sur les moniteurs haute r√©solution, l'interface para√Ætra petite.  Vous pouvez multiplier la taille des √©l√©ments par un certain coefficient, selon la r√©solution de l'√©cran.  D'un autre c√¥t√©, peut-√™tre que les √©normes boutons sur l'√©cran ne sont pas n√©cessaires?  Si la r√©solution d'√©cran est √©norme, alors l'√©cran lui-m√™me est assez grand. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kg/id/am/kgidamgcsszbyxejvyyar7bgave.jpeg"></div><br>  Et vous pouvez donner au programmeur un choix - que ce soit pour redimensionner dynamiquement l'IU avec la taille de la fen√™tre ou pour r√©partir les √©l√©ments dans les coins.  Dans le cas de la taille dynamique, il y a aussi des questions qui leur sont propres - par exemple, le ¬´savon¬ª d'une interface lorsqu'elle est affich√©e √† trop grande √©chelle.  Si vous cr√©ez des sprites d'√©l√©ments d'interface dans une r√©solution d√©lib√©r√©ment √©norme, ils prendront alors beaucoup de place et, probablement, cela ne sera pas utile pour les petits appareils - ils n'ont toujours pas besoin de grands sprites, mais consommeront de la m√©moire. <br><br>  Je pense que cela suffit pour aujourd'hui.  Il y a encore quelque chose √† penser, comment mettre en ≈ìuvre ceci ou cela.  En attendant, je m'√©loigne un peu de la programmation et fais de la promotion.  Je pr√©vois de participer √† une paire de vitrines ind√©pendantes et je suis activement engag√© dans la promotion du jeu sur les r√©seaux sociaux, car en novembre je pr√©vois d'entrer sur la plateforme de financement participatif: j'aurai besoin de sp√©cialistes dans le domaine du graphisme 3D et de l'animation squelettique pour terminer le jeu. <br><br>  Dans les articles suivants, je parlerai des commandes tactiles dans les navigateurs pour appareils mobiles - tout le monde ne connecte pas une manette de jeu ou un clavier √† la tablette, sur l'optimisation des graphiques 3D pour les appareils √† faible consommation d'√©nergie, et bien plus encore. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr472272/">https://habr.com/ru/post/fr472272/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr472258/index.html">Comment "apprendre √† apprendre" - am√©liorer la pleine conscience</a></li>
<li><a href="../fr472262/index.html">Le condens√© de mat√©riaux int√©ressants pour le d√©veloppeur mobile # 318 (du 14 au 20 octobre)</a></li>
<li><a href="../fr472264/index.html">Arch√©ologie num√©rique et r√©alit√© virtuelle ou comment j'ai essay√© de me faire des amis avec le BIM et la VR</a></li>
<li><a href="../fr472268/index.html">Am√©lioration des contr√¥les Microsoft Edge sur Chromium</a></li>
<li><a href="../fr472270/index.html">¬´Vous n'avez pas acc√®s √† la pri√®re actuelle¬ª: des perles hi-tech du Vatican ont √©t√© pirat√©es en 15 minutes</a></li>
<li><a href="../fr472274/index.html">SSH √† distance: conseils et astuces</a></li>
<li><a href="../fr472278/index.html">Mon git commit pr√©f√©r√©</a></li>
<li><a href="../fr472280/index.html">La t√¢che de d√©terminer la pr√©sence d'une paume sur un scanner veineux</a></li>
<li><a href="../fr472288/index.html">9 extensions de navigateur utiles pour les d√©veloppeurs (liste pour 2020)</a></li>
<li><a href="../fr472290/index.html">Structures vs classes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>