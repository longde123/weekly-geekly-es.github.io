<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔋 🤛🏿 👩🏾‍🤝‍👨🏿 Seluruh kebenaran tentang RTOS. Artikel # 10. Penjadwal: fitur canggih dan pelestarian konteks 🤙🏻 🏤 🌈</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam artikel sebelumnya, kami melihat berbagai jenis perencanaan yang didukung oleh RTOS dan kemampuan terkait di Nucleus SE. Dalam artikel ini, kita...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Seluruh kebenaran tentang RTOS. Artikel # 10. Penjadwal: fitur canggih dan pelestarian konteks</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423967/"><img src="https://habrastorage.org/webt/m-/ag/9y/m-ag9yjhbtfwdjmljyermwi6duu.jpeg"><br><br>  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel sebelumnya,</a> kami melihat berbagai jenis perencanaan yang didukung oleh RTOS dan kemampuan terkait di Nucleus SE.  Dalam artikel ini, kita akan melihat opsi perencanaan tambahan di Nucleus SE dan proses menyimpan dan memulihkan konteks. <br><a name="habracut"></a><br>  Artikel sebelumnya dalam seri: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penjadwal: implementasi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nucleus SE: Desain dan Penyebaran Internal</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nucleus SE: Pendahuluan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Layanan RTOS lainnya</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Interaksi tugas dan sinkronisasi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tugas, pengalihan konteks, dan interupsi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tugas dan Perencanaan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RTOS: Struktur dan mode waktu-nyata</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RTOS: pengantar.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><br></a> <br><h2>  Fitur opsional </h2><br>  Selama pengembangan Nucleus SE, saya membuat jumlah maksimum fungsi opsional, yang menghemat memori dan / atau waktu. <br><br><h3>  Tangguhkan Tugas </h3><br>  Seperti yang disebutkan sebelumnya dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penjadwal: Artikel implementasi</a> , Nucleus SE mendukung berbagai opsi untuk menjeda tugas, tetapi fitur ini opsional dan disertakan oleh simbol <b>NUSE_SUSPEND_ENABLE</b> di <b>nuse_config.h</b> .  Jika diatur ke <b>TRUE</b> , maka struktur data didefinisikan sebagai <b>NUSE_Task_Status []</b> .  Jenis suspensi ini berlaku untuk semua tugas.  Array adalah tipe <b>U8</b> , di mana 2 camilan digunakan secara terpisah.  4 bit yang lebih rendah berisi status tugas: <br>  <b>NUSE_READY, NUSE_PURE_SUSPEND</b> , <b>NUSE_SLEEP_SUSPEND</b> , <b>NUSE_MAILBOX_SUSPEND</b> , dll.  Jika tugas ditangguhkan oleh panggilan API (misalnya, <b>NUSE_MAILBOX_SUSPEND</b> ), 4 bit tinggi berisi indeks objek di mana tugas ditangguhkan.  Informasi ini digunakan ketika sumber daya tersedia dan untuk memanggil API Anda perlu mencari tahu dari tugas yang ditangguhkan yang harus dilanjutkan. <br><br>  Untuk melakukan penangguhan tugas, sepasang fungsi penjadwal digunakan: <b>NUSE_Suspend_Task ()</b> dan <b>NUSE_Wake_Task ()</b> . <br><br>  Kode <b>NUSE_Suspend_Task ()</b> adalah sebagai berikut: <br><br><img src="https://habrastorage.org/webt/ep/1j/gi/ep1jgiocsfdclopsjghruszeggq.png"><br><br>  Fungsi menyimpan status tugas yang baru (semua 8 bit), yang diperoleh sebagai parameter suspend_code.  Saat Anda mengaktifkan penguncian (lihat "Kunci Panggilan API" di bawah), kode pengembalian <b>NUSE_SUCCESS disimpan</b> .  Selanjutnya, <b>NUSE_Reschedule ()</b> dipanggil untuk mentransfer kontrol ke tugas berikutnya. <br><br>  Kode <b>NUSE_Wake_Task ()</b> cukup sederhana: <br><br><img src="https://habrastorage.org/webt/br/of/0p/brof0ptcaza3ovc4ykffacmkphy.png"><br><br>  Status tugas diatur ke <b>NUSE_READY</b> .  Jika penjadwal Prioritas tidak digunakan, tugas saat ini terus menempati prosesor hingga saatnya tiba untuk membebaskan sumber daya.  Jika penjadwal Prioritas digunakan, <b>NUSE_Reschedule ()</b> dipanggil dengan indeks tugas sebagai indikasi penyelesaian, karena tugas mungkin memiliki prioritas lebih tinggi dan harus segera dieksekusi. <br><br><h3>  Kunci panggilan API </h3><br>  Nucleus RTOS mendukung sejumlah panggilan API yang dengannya pengembang dapat menjeda (memblokir) tugas jika sumber daya tidak tersedia.  Tugas akan dilanjutkan ketika sumber daya tersedia lagi.  Mekanisme ini juga diimplementasikan dalam Nucleus SE dan berlaku untuk sejumlah objek kernel: tugas dapat diblokir di bagian memori, dalam grup acara, kotak surat, antrian, saluran, atau semafor.  Tapi, seperti kebanyakan alat di Nucleus SE, itu opsional dan ditentukan oleh simbol <b>NUSE_BLOCKING_ENABLE</b> di <b>nuse_config.h</b> .  Jika diatur ke <b>TRUE</b> , maka array <b>NUSE_Task_Blocking_Return []</b> didefinisikan, yang berisi kode balik untuk setiap tugas;  itu bisa berupa <b>NUSE_SUCCESS</b> atau kode <b>NUSE_MAILBOX_WAS_RESET</b> , yang menunjukkan bahwa objek diatur ulang saat tugas dikunci.  Ketika penguncian diaktifkan, kode yang sesuai dimasukkan dalam fungsi API menggunakan kompilasi bersyarat. <br><br><h3>  Penghitung penjadwal </h3><br>  Nucleus RTOS menghitung berapa kali tugas telah dijadwalkan sejak tugas itu dibuat dan reset terakhir.  Fitur ini juga diimplementasikan dalam Nucleus SE, tetapi bersifat opsional dan ditentukan oleh simbol <b>NUSE_SCHEDULE_COUNT_SUPPORT</b> di <b>nuse_config.h</b> .  Jika diatur ke <b>TRUE</b> , array <b>NUSE_Task_Schedule_Count [] dari</b> tipe <b>U16 dibuat</b> , yang menyimpan konter setiap tugas dalam aplikasi. <br><br><h3>  Keadaan awal tugas </h3><br>  Ketika tugas dibuat di Nucleus RTOS, Anda dapat memilih statusnya: siap atau dijeda.  Di Nucleus SE, secara default, semua tugas siap saat startup.  Opsi yang dipilih dengan simbol <b>NUSE_INITIAL_TASK_STATE_SUPPORT</b> di <b>nuse_config.h</b> memungkinkan Anda untuk memilih kondisi awal.  <b>Array NUSE_Task_Initial_State []</b> didefinisikan dalam <b>nuse_config.c</b> dan membutuhkan inisialisasi <b>NUSE_READY</b> atau <b>NUSE_PURE_SUSPEND</b> untuk setiap tugas dalam aplikasi. <br><br><h2>  Menyimpan Konteks </h2><br>  Gagasan mempertahankan konteks tugas dengan semua jenis penjadwal, kecuali untuk RTC (Run to Completion), disajikan dalam artikel # 3 "Tugas dan penjadwalan".  Seperti yang telah disebutkan, ada beberapa cara untuk mempertahankan konteks.  Mengingat bahwa Nucleus SE tidak dirancang untuk prosesor 32-bit, saya memilih untuk menggunakan tabel, bukan tumpukan, untuk mempertahankan konteks. <br><br>  Array dua dimensi dari tipe <b>ADDR NUSE_Task_Context [] []</b> digunakan untuk menyimpan konteks untuk semua tugas dalam aplikasi.  <b>Barisnya</b> adalah <b>NUSE_TASK_NUMBER</b> (jumlah tugas dalam aplikasi), kolomnya adalah <b>NUSE_REGISTERS</b> (jumlah register yang perlu disimpan; tergantung pada prosesor dan diatur ke <b>nuse_types.h)</b> . <br><br>  Tentu saja, mempertahankan konteks dan mengembalikan kode tergantung pada prosesor.  Dan ini adalah satu-satunya kode Nucleus SE yang diikat ke perangkat tertentu (dan lingkungan pengembangan).  Saya akan memberikan contoh kode save / restore untuk prosesor ColdFire.  Walaupun pilihan ini mungkin tampak aneh karena prosesor yang sudah ketinggalan zaman, assemblernya lebih mudah dibaca daripada assembler dari kebanyakan prosesor modern.  Kode ini cukup sederhana untuk digunakan sebagai dasar untuk membuat saklar konteks untuk prosesor lain: <br><br><img src="https://habrastorage.org/webt/kw/gw/ct/kwgwctpm3q_igjvz2qfhmbi0awm.png"><br><br>  Ketika pengalihan konteks diperlukan, kode ini disebut dalam NUSE_Context_Swap.  Dua variabel digunakan: <b>NUSE_Task_Active</b> , indeks tugas saat ini, konteks yang harus dilestarikan;  <b>NUSE_Task_Next</b> , indeks tugas yang konteksnya ingin Anda muat (lihat bagian Data Global). <br><br>  Proses pelestarian konteks berfungsi sebagai berikut: <br><br><ul><li>  Register <b>A0</b> dan <b>D0</b> disimpan sementara di stack; </li><li>  <b>A0</b> dikonfigurasikan untuk menunjuk ke array blok konteks <b>NUSE_Task_Context [] []</b> ; </li><li>  <b>D0</b> dimuat menggunakan <b>NUSE_Task_Active</b> dan dikalikan dengan 72 (ColdFire memiliki 18 register, membutuhkan 72 byte untuk penyimpanan); </li><li>  kemudian <b>D0</b> ditambahkan ke <b>A0</b> , yang sekarang menunjuk ke blok konteks untuk tugas saat ini; </li><li>  kemudian register disimpan di blok konteks;  pertama <b>A0</b> dan <b>D0</b> (dari stack), kemudian <b>D1-D7</b> dan <b>A1-A6</b> , kemudian <b>SR</b> dan <b>PC</b> (dari stack, kita akan melihat konteks switching yang dimulai dengan cepat), dan pada akhirnya penunjuk stack disimpan. </li></ul><br>  Proses pemuatan konteks adalah urutan tindakan yang sama dalam urutan terbalik: <br><br><ul><li>  <b>A0</b> dikonfigurasikan untuk menunjuk ke array blok konteks <b>NUSE_Task_Context [] []</b> ; </li><li>  <b>D0</b> dimuat menggunakan <b>NUSE_Task_Active</b> , bertambah dan dikalikan dengan 72; </li><li>  kemudian <b>D0</b> ditambahkan ke <b>A0</b> , yang sekarang menunjuk ke blok konteks untuk tugas baru (karena pemuatan konteks harus dilakukan dalam proses kebalikan dari menyimpan urutan, penumpukan tumpukan diperlukan pertama kali); </li><li>  kemudian register dipulihkan dari blok konteks;  pertama, penunjuk tumpukan, kemudian <b>PC</b> dan <b>SR didorong</b> ke tumpukan, kemudian <b>D1-D7</b> dan <b>A1-A6</b> dimuat, dan pada akhir <b>D0</b> dan <b>A0</b> . </li></ul><br>  Kesulitan dalam menerapkan pengalihan konteks adalah bahwa akses ke register negara sulit bagi banyak prosesor (untuk ColdFire, ini <b>SR</b> ).  Solusi umum adalah gangguan, yaitu gangguan program atau gangguan cabang bersyarat, yang menyebabkan <b>SR</b> memuat ke tumpukan bersama dengan <b>PC</b> .  Beginilah cara Nucleus SE bekerja di ColdFire.  Makro <b>NUSE_CONTEXT_SWAP ()</b> diatur dalam <b>nuse_types.h</b> , yang meluas ke: <br>  <b>asm ("trap # 0");</b> <br><br>  Berikut ini adalah kode inisialisasi ( <b>NUSE_Init_Task ()</b> di <b>nuse_init.c</b> ) untuk blok konteks: <br><br><img src="https://habrastorage.org/webt/h7/8n/td/h78ntdz05whdi70d0pkfx-ffnok.png"><br><br>  Ini adalah bagaimana inisialisasi stack pointer, <b>PC,</b> dan <b>SR</b> terjadi.  Dua yang pertama memiliki nilai yang ditetapkan oleh pengguna di <b>nuse_config.c</b> .  Nilai <b>SR</b> didefinisikan sebagai karakter <b>NUSE_STATUS_REGISTER</b> di <b>nuse_types.h</b> .  Untuk ColdFire, nilai ini adalah <b>0x40002000</b> . <br><br><h2>  Data global </h2><br>  Penjadwal Nucleus SE hanya membutuhkan sedikit memori untuk menyimpan data, tetapi, tentu saja, menggunakan struktur data yang terkait dengan tugas, yang akan dibahas secara rinci dalam artikel berikut. <br><br><h3>  Data RAM </h3><br>  Penjadwal tidak menggunakan data yang terletak di ROM, dan 2 hingga 5 variabel global ditempatkan di RAM (semua diatur dalam <b>nuse_globals.c</b> ), tergantung pada penjadwal mana yang digunakan: <br><br><ul><li>  <b>NUSE_Task_Active</b> - variabel tipe <b>U8 yang</b> berisi indeks tugas saat ini; </li><li>  <b>NUSE_Task_State</b> - variabel tipe <b>U8 yang</b> mengandung nilai yang menunjukkan status kode yang saat ini dieksekusi, yang dapat berupa tugas, interrupt handler, atau kode startup;  nilai yang mungkin adalah: <b>NUSE_TASK_CONTEXT</b> , <b>NUSE_STARTUP_CONTEXT</b> , <b>NUSE_NISR_CONTEXT</b> dan <b>NUSE_MISR_CONTEXT</b> ; </li><li>  <b>NUSE_Task_Saved_State</b> - variabel tipe <b>U8 yang</b> digunakan untuk melindungi nilai <b>NUSE_Task_State</b> dalam interupsi terkelola; </li><li>  <b>NUSE_Task_Next</b> - variabel tipe <b>U8 yang</b> berisi indeks tugas berikutnya, yang harus dijadwalkan untuk semua penjadwal kecuali RTC; </li><li>  <b>NUSE_Time_Slice_Ticks</b> - variabel tipe <b>U16 yang</b> mengandung penghitung <b>irisan</b> waktu;  hanya digunakan dengan penjadwal TS. </li></ul><br><h3>  Footprint Data Penjadwal </h3><br>  Penjadwal Nucleus SE tidak menggunakan data ROM.  Jumlah pasti data RAM bervariasi tergantung pada penjadwal yang digunakan: <br><br><ul><li>  untuk RTC - 2 byte ( <b>NUSE_Task_Active</b> dan <b>NUSE_Task_State</b> ); </li><li>  untuk RR dan Prioritas - 4 byte ( <b>NUSE_Task_Active</b> , <b>NUSE_Task_State</b> , <b>NUSE_Task_Saved_State</b> dan <b>NUSE_Task_Next</b> ); </li><li>  untuk TS - 6 byte ( <b>NUSE_Task_Active</b> , <b>NUSE_Task_State</b> , <b>NUSE_Task_Saved_State</b> , <b>NUSE_Task_Next</b> dan <b>NUSE_Time_Slice_Ticks</b> ). </li></ul><br><h2>  Implementasi mekanisme perencanaan lainnya </h2><br>  Terlepas dari kenyataan bahwa Nucleus SE menawarkan pilihan 4 penjadwal, yang mencakup sebagian besar kasus, arsitektur terbuka memungkinkan Anda untuk menerapkan peluang untuk kasus-kasus lain. <br><br><h3>  Mengiris waktu dengan tugas latar belakang </h3><br>  Seperti yang sudah dijelaskan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel # 3, "Tugas dan Penjadwalan," Penjadwal</a> Waktu Iris yang sederhana memiliki keterbatasan karena membatasi waktu maksimum yang dapat diambil oleh prosesor.  Opsi yang lebih canggih adalah menambahkan dukungan untuk tugas latar belakang.  Tugas semacam itu dapat dijadwalkan pada setiap slot yang dialokasikan untuk tugas yang dijeda, dan dijalankan ketika slot tersebut sebagian dibebaskan.  Pendekatan ini memungkinkan Anda untuk menjadwalkan tugas secara berkala dan dengan perkiraan persentase waktu inti prosesor untuk diselesaikan. <br><br><h3>  Priority and Round Robin (RR) </h3><br>  Di sebagian besar inti waktu nyata, penjadwal prioritas mendukung beberapa tugas di setiap tingkat prioritas, tidak seperti Nucleus SE, di mana setiap tugas memiliki tingkat yang unik.  Saya memberi preferensi pada opsi yang terakhir, karena sangat menyederhanakan struktur data dan, oleh karena itu, kode penjadwal.  Untuk mendukung arsitektur yang lebih kompleks, diperlukan banyak tabel ROM dan RAM. <br><br>  <b>Tentang Pengarang:</b> Colin Walls telah bekerja di industri elektronik selama lebih dari tiga puluh tahun, mencurahkan sebagian besar waktunya untuk firmware.  Dia sekarang adalah seorang insinyur firmware di Mentor Embedded (sebuah divisi dari Mentor Graphics).  Colin Walls sering berbicara di konferensi dan seminar, penulis berbagai artikel teknis dan dua buku tentang firmware.  Tinggal di Inggris.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Blog</a> profesional <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Colin</a> , email: colin_walls@mentor.com. <br><br>  <b>Tentang penerjemahan:</b> seri artikel ini tampak menarik karena, meskipun ada pendekatan yang sudah ketinggalan zaman di beberapa tempat, penulis dalam bahasa yang sangat dimengerti memperkenalkan pembaca yang kurang terlatih ke fitur-fitur dari OS real-time.  Saya sendiri termasuk dalam tim pembuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RTOS Rusia</a> , yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ingin</a> kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bebaskan</a> , dan saya harap siklus ini akan bermanfaat bagi pengembang pemula. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id423967/">https://habr.com/ru/post/id423967/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id423957/index.html">Generasi lalu lintas ruang pengguna</a></li>
<li><a href="../id423959/index.html">Kasus Bawah Air - Untuk Robot</a></li>
<li><a href="../id423961/index.html">Jangan kehilangan diri Anda: metode baru untuk mendiagnosis demensia</a></li>
<li><a href="../id423963/index.html">Kelvin Point Prolog</a></li>
<li><a href="../id423965/index.html">Anda membeli SIEM dan yakin bahwa SOC ada di saku Anda, bukan?</a></li>
<li><a href="../id423971/index.html">Webmaster Skillbox Friday: Untuk Pengembang Dari Pengembang</a></li>
<li><a href="../id423973/index.html">Pembuat botai Mirai sekarang memerangi kejahatan di pihak FBI</a></li>
<li><a href="../id423977/index.html">Bertemu dengan DevOps Deflope di DevOpsConf 2018</a></li>
<li><a href="../id423979/index.html">Panel Biomarker Penuaan Sehat Inggris</a></li>
<li><a href="../id423981/index.html">Buku DDIA (buku dengan babi) - lakukan peningkatan level dalam memahami basis data</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>