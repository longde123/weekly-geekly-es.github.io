<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõå ‚úãüèΩ üíΩ Die Untersuchung der Dateisystem-Festplatte des DVR-Modells QCM-08DL üòá ‚è±Ô∏è üë®üèº‚Äçüé§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel befasst sich mit der Untersuchung der Dateistruktur der Festplatte eines Achtkanal-Videorecorders zum Zweck der Massenextraktion von Vi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die Untersuchung der Dateisystem-Festplatte des DVR-Modells QCM-08DL</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421933/"><img src="https://habrastorage.org/webt/jl/fy/ud/jlfyudollyahkfmnnmsy0fa-8xu.jpeg"><br><br>  Dieser Artikel befasst sich mit der Untersuchung der Dateistruktur der Festplatte eines Achtkanal-Videorecorders zum Zweck der Massenextraktion von Videodateien.  Am Ende des Artikels steht die Implementierung des entsprechenden Programms in C. <br><a name="habracut"></a><br>  Videorecorder (abgek√ºrzt DVR) QCM-08DL wird in Video√ºberwachungssystemen verwendet und erm√∂glicht Video- und Audioaufnahmen mit acht Kan√§len.  Dieses Modell ist meiner Meinung nach eines der billigsten und gleichzeitig zuverl√§ssigsten im Betrieb.  Das Videokomprimierungsformat ist das beliebte H264-Format.  F√ºr Audio ist das Komprimierungsformat ADPCM.  Video und Audio werden auf einer im DVR installierten SATA-Festplatte (HDD) eines Standardcomputers aufgezeichnet.  Mit dem DVR selbst k√∂nnen Sie Aufnahmen anzeigen, indem Sie sie nach Datum und Uhrzeit durchsuchen.  Es ist auch m√∂glich, Daten in eine Datei auf einem externen Medium zu extrahieren.  Erstens an ein USB-Laufwerk, das an die USB-Schnittstelle des DVR angeschlossen wird.  Zweitens - √ºber die WEB-Schnittstelle des DVR zum Computer.  Der Name der resultierenden Datei ist lang und enth√§lt das Aufnahmedatum, die Start- und Endzeit, den Aufnahmekanal und andere zus√§tzliche Informationen.  Die Dateierweiterung lautet ".264".  Eine Pr√ºfung des Inhalts einer solchen Datei hat mir klar gemacht, dass der Mediencontainer, in den Audio- und Videostreams gepackt sind, weit vom Standard entfernt ist.  Eine solche Datei kann mit dem mit dem DVR gelieferten Player ge√∂ffnet werden.  Der Spieler f√ºhlt sich sehr unwohl.  Sie k√∂nnen aber auch das Repacker-Programm f√ºr den AVI-Container verwenden, der ebenfalls enthalten ist.  Dieses Programm packt den Videostream neu und bel√§sst ihn im H264-Format.  Der Soundstrom wird von ADMCM in PCM konvertiert und um das Vierfache vergr√∂√üert.  Das Ergebnis ist eine .avi-Datei, die von jedem Standard-Player abgespielt werden kann.  Ich stelle sofort fest, dass dieses Umpackprogramm sehr unpraktisch ist.  Sie k√∂nnen damit nur Operationen f√ºr eine Datei ausf√ºhren.  Um eine Reihe von Dateien neu zu packen, m√ºssen Sie sie nacheinander √∂ffnen. <br><br>  Die folgenden Aufgaben wurden festgelegt. <br><br><ol><li>  Erhalten Sie Zugriff auf alle .264-Dateien von der Festplatte des DVR, indem Sie die Festplatte an den Computer anschlie√üen. </li><li>  Um den Algorithmus zu untersuchen, mit dem das Standardprogramm 264-avi repacker funktioniert, und dasselbe Programm zu erstellen, das dieselben Operationen ausf√ºhrt, jedoch nicht mit einem, sondern mit einer ganzen Gruppe von Dateien mit einem Klick. </li></ol><br>  Die erste Aufgabe mag auf den ersten Blick sehr einfach erscheinen: Sie m√ºssen nur die Festplatte an den Computer anschlie√üen und die Partitionen im Explorer √∂ffnen.  Es gibt jedoch Fallstricke.  Dieser Artikel ist der ersten Aufgabe gewidmet. <br><br>  Ich wusste bereits im Voraus, dass die Software-Shell des DVR-Mikrocontrollers auf einem Linux-√§hnlichen Betriebssystem basiert.  Daher wird die Partitionierung der Festplatte h√∂chstwahrscheinlich auch Linux-√§hnlich sein.  Daher ben√∂tigen Sie einen Linux-Computer.  In meinem Fall betr√§gt die Kapazit√§t der Festplatte 1 TB, ein Computer mit OS Xubuntu.  Nachdem ich die Festplatte an den Computer angeschlossen hatte, konnte ich nur eine Partition pro mehrere Gigabyte sehen.  Dies ist eindeutig nicht das, was Sie brauchen.  Innerhalb des Abschnitts befinden sich viele Ordner im Namensformat ‚ÄûJJJJ-MM-TT‚Äú, die den Daten der Datens√§tze entsprechen.  In jedem Ordner befinden sich viele Dateien, die den Eintr√§gen entsprechen.  Dateien mit demselben Namen wie beim Extrahieren aus dem DVR.  Ihre Gr√∂√üe ist jedoch um ein Vielfaches kleiner und die Erweiterung ist nicht .264, sondern .nvr.  Es sollte angenommen werden, dass dieselben NVR-Dateien Schl√ºssel f√ºr die entsprechenden 264 Dateien (oder deren Medienstr√∂me) sind, deren Inhalt sich auf dem Hauptfestplattenspeicher befindet.  Ich habe die Daten aus dem Dateiordner zur weiteren Recherche auf ein separates Medium kopiert. <br><br>  Ich habe viele Software-Tools f√ºr die Recherche verwendet: einen Disk-Editor (es ist auch ein Bin√§rdatei-Editor) DiskExplorer (ich habe sp√§ter WinHex verwendet), MS Excel f√ºr Hilfsberechnungen und Korrekturergebnisse, Dev-C ++ - Programmierumgebung zum Schreiben von Hilfs- und Endkonsolenprogrammen usw.  In diesem Artikel werde ich versuchen, √ºber dieses Verfahren zu sprechen. <br><br>  Schauen Sie sich zun√§chst den ersten Sektor der Festplatte an (ein Sektor (1 LBA) ben√∂tigt 512 Byte).  Dieser Sektor enth√§lt in der Regel eine MBR-Struktur.  Es enth√§lt einen Bootloader und ein grundlegendes Inhaltsverzeichnis.  Die Struktur dieses Sektors sowie die Struktur der Abschnittsbeschreibung sind unten angegeben (entnommen aus Wikipedia). <br><br><img src="https://habrastorage.org/webt/yb/x9/iq/ybx9iqnwe7dx7ghojh7xnyfghbm.jpeg"><br><br><img src="https://habrastorage.org/webt/mz/w4/v1/mzw4v1rt6vrfmmrmbbrn2m-ggu0.jpeg"><br><br>  Im Fall der untersuchten Festplatte haben wir Folgendes.  Wenn wir uns die Abbildung unten ansehen und den obigen Tabellen folgen, sehen wir, dass der Bootloader fehlt.  Wir interessieren uns aber mehr f√ºr die Partitionstabelle.  Es wird in einem roten Rahmen hervorgehoben.  Die letzten zwei Bytes (blaue F√ºllung) - MBR-Signatur.  Sie k√∂nnen der Partitionstabelle entnehmen, dass die Festplatte in zwei Abschnitte unterteilt ist.  Der Code f√ºr den Typ des ersten Abschnitts (gelbe F√ºllung) lautet 0x0B.  Dies ist eine FAT32-Partition.  Der Code f√ºr den Typ der Sekunde (orange F√ºllung) ist 0x83.  Dies ist eine der Linux-Partitionen (im Sinne von EXT).  Partitionstyp-Codebytes sind blau eingekreist. <br><br><img src="https://habrastorage.org/webt/ua/2h/l6/ua2hl6viqijfm3qwziadcpf3myi.jpeg"><br><br>  Eine vollst√§ndige Entschl√ºsselung des MBR-Sektors mit einer Tabelle von Abschnitten und ihren Parametern ist unten angegeben. <br><br><img src="https://habrastorage.org/webt/h2/mc/8j/h2mc8jovgedyxw1lcswaodx-xoa.jpeg"><br><br>  Unter Ber√ºcksichtigung der Gr√∂√üe der Partitionen (einschlie√ülich der Anzahl der Sektoren in Gigabyte) ist es leicht zu erraten, dass es sich bei dem Computer mit dem Betriebssystem Xubuntu um die erste Partition handelte, die einen kleinen Teil des Speicherplatzes einnahm.  √úbrigens wurde in Windows XP nur die erste Partition angezeigt, die jedoch nicht √ºber den Explorer ge√∂ffnet wurde.  Und warum erschien dann die zweite Linux-Partition nicht auf dem Xubuntu-Betriebssystem? <br><br>  Nachdem ich zuvor die Struktur und Organisation des Linux-Dateisystems am Beispiel von EXT2 untersucht hatte, begann ich, den zweiten Abschnitt zu studieren. <br><br>  Wie Sie der Abschnittstabelle entnehmen k√∂nnen, beginnt der zweite Abschnitt mit dem Sektor 16016805. Das Handbuch zum EXT2-Dateisystem zeigt das Vorhandensein des sogenannten Superblocks an, der sich 1024 Byte vom Anfang des Abschnitts entfernt befindet (dh zwei Sektoren vom Anfang).  Der Sektor 16016805 + 2 = 16016807 war jedoch leer.  Der erste Sektor 16016805 in seiner Struktur √§hnelte jedoch einem Superblock.  Der Inhalt entsprach jedoch nicht vollst√§ndig der Beschreibung des Inhalts des Superblocks aus dem Handbuch.  Der Superblock ist der Hauptblock, der eine Art Tabelle mit verschiedenen Konstanten und Parametern f√ºr die Funktionsweise des Dateisystems enth√§lt: Adressen von Positionen und Gr√∂√üen anderer erforderlicher Bl√∂cke, insbesondere Header von Dateidatens√§tzen und Verzeichnissen.  Weitere Untersuchungen in diesem Abschnitt f√ºhrten mich nur zu einer Schlussfolgerung: Der DVR verwendet ein eigenes einzigartiges Dateisystem. <br><br>  In Zukunft habe ich beschlossen, den ersten Sektor des ersten Abschnitts (Sektor 63) zu betrachten und nach unten zu scrollen.  Es wurde auf dem Inhalt von Sektor 65 (zwei Sektoren unten) gefunden, der dem Inhalt des FS EXT2-Superblocks, der im Handbuch beschrieben wird, v√∂llig √§hnlich ist.  Weitere Untersuchungen f√ºhrten zu dem Schluss, dass die erste Partition des HDD-DVR die EXT2-Partition ist, die auf dem Xubuntu-Betriebssystem angezeigt wurde, unabh√§ngig von der Markierung 0x08 (nicht EXT) im Inhaltsverzeichnis!  Daher ist die erste Partition der Festplatte des DVR die EXT2-Partition, auf der NVR-Dateien aufgezeichnet werden. Dies sind die Schl√ºssel f√ºr die erforderlichen Videoaufnahmen. <br><br>  Ich werde kurz √ºber die Struktur von .264-Dateien schreiben, die ich zuvor ebenfalls untersucht habe.  Diese Informationen werden in Zukunft ben√∂tigt, um den zweiten Abschnitt der Festplatte zu untersuchen.  Wie in jedem Mediencontainer gibt es in ‚Äû264‚Äú einen Header mit Serviceinformationen und Medien-Tags sowie Audio- und Videostreams, die in kleinen Bl√∂cken nacheinander folgen.  Bei einem Versatz von 0 x 84 Byte vom Dateianfang wird das Schl√ºsselwort "MDVR96NT_2_R" registriert.  Vor diesem Wort stehen Bytes, die sich auf Datum und Uhrzeit der Aufzeichnung beziehen.  Diese Informationen sind jedoch im Dateinamen enthalten und verdienen daher hier keine besondere Aufmerksamkeit.  Danach kommen viele Bytes von Nullen.  Die Hauptinformationen mit Audio- und Videostreams stammen aus einem Offset von 65.536 Bytes.  Videostream-Bl√∂cke beginnen mit einem 8-Byte-Header ‚Äû01dcH264‚Äú (auch ‚Äû00dcH264‚Äú).  Die folgenden 4 Bytes beschreiben die Gr√∂√üe des aktuellen Blocks des Videostreams in Bytes.  Nach 4 Bytes von Nullen (00 00 00 00) beginnt der Videostreamblock selbst.  Die Audio-Stream-Bl√∂cke haben den Titel "03wb" (obwohl nach meinen Beobachtungen das erste Zeichen des Headers in einigen F√§llen nicht unbedingt "0" war).  Nach - 12 Bytes an Informationen, die ich noch nicht herausgefunden habe.  Und beginnend mit dem 17. Byte - einem Audiostream mit einer festen L√§nge von 160 Bytes.  Am Ende der Datei befinden sich keine Tags. <br><br>  Wir untersuchen die Struktur von Dateien und Verzeichnissen auf der ersten Partition der Festplatte.  Wie oben erw√§hnt, wurde der Inhalt des Abschnitts √ºber einen regul√§ren Explorer im Xununtu-Betriebssystem auf ein separates Medium kopiert.  In jedem Verzeichnis (Verzeichnis) gibt es zus√§tzlich zu den NVR-Dateien eine Bin√§rdatei mit dem Namen "file_list".  Nach dem Namen zu urteilen, enth√§lt es Informationen √ºber die Liste der Dateien im aktuellen Verzeichnis.  √ñffnen Sie diese Datei im Bin√§reditor (siehe Abbildung unten).  Ich habe die Struktur dieser Datei untersucht, und hier gibt es im Grunde nichts Interessantes.  Die Datei enth√§lt keine Informationen zum Speicherort der gew√ºnschten Medienstr√∂me.  Trotzdem werde ich kurz √ºber diese Struktur schreiben.  Die ersten 32 Bytes sind ein Header mit einigen Konstanten.  Die n√§chsten 16 Bytes beziehen sich auf Datum und Uhrzeit sowie die Anzahl der Dateien im aktuellen Verzeichnis.  Darauf folgen 48 Byte Konstanten.  Weiter - 8 Byte Konstanten, die den Beginn des Dateidatensatzes angeben.  Als n√§chstes 96 Bytes, die den vollst√§ndigen Pfad zur NVR-Datei einschlie√ülich ihres Namens angeben.  Weiter - 24 Bytes in Bezug auf die Zeit (die Anzahl der Sekunden, die seit Beginn des Tages, dem Beginn und dem Ende des Videos vergangen sind) und andere Attribute des Videos.  Und so weiter analog f√ºr alle NVR-Dateien im aktuellen Verzeichnis.  Ihre Anzahl entspricht der Anzahl der Videos f√ºr den aktuellen Tag, angegeben durch den Namen des aktuellen Verzeichnisses.  Wof√ºr ist diese Datei?  Anscheinend, um die Suche nach Videos innerhalb der DVR-Schnittstelle zu beschleunigen. <br><br><img src="https://habrastorage.org/webt/ey/tq/dh/eytqdh-oadafzwauaoh2fbogo9o.jpeg"><br><br>  Lassen Sie uns nun die Struktur der NVR-Dateien selbst untersuchen.  Das Erscheinungsbild einer solchen Datei in einem Bin√§reditor (genauer gesagt in einem Hexadezimaleditor) ist in der folgenden Abbildung dargestellt.  Ohne auf die Beschreibung der Inhaltsstruktur einzugehen (von der mir ein Teil ein R√§tsel blieb), habe ich die grundlegendsten Parameter hervorgehoben, die der Schl√ºssel sind, der gefunden werden kann.  Dies sind 32-Bit-Werte (4 Byte), die sich alle 32 Byte ab Byte bei Offset 40 befinden. In der Abbildung sind sie rot hervorgehoben.  In Zukunft war ich √ºberzeugt, dass dies f√ºr den Schl√ºssel zu den Videos v√∂llig ausreicht.  Ich erinnere Sie daran, dass sich 4 Bytes des Werts dieses Schl√ºsselparameters vom niedrigsten zum h√∂chsten befinden, aber nicht umgekehrt!  Diese Notation ist auf die Architektur des PC-Prozessors zur√ºckzuf√ºhren.  Das Beispiel in der Abbildung zeigt die erste NVR-Datei des ersten Verzeichnisses.  Dies entspricht der ersten Videoaufnahme des DVR.  Offensichtlich bilden die Werte der Parameter, die ich im obigen Beispiel als Schl√ºssel bezeichnet habe, eine Folge von ganzen Zahlen, beginnend bei Null und in aufsteigender Reihenfolge.  Bei der Untersuchung anderer NVR-Dateien und der genauen Betrachtung dieser angegebenen Bytes wurden auch Ganzzahlen in aufsteigender Reihenfolge angezeigt.  Aber diese Sequenz begann nat√ºrlich nicht mehr von vorne, und in einigen F√§llen wurden stellenweise L√ºcken in einer oder zwei Zahlen beobachtet.  Zum Beispiel (Nummern vom Bulldozer): 435, 436, 438, 439, 442, ... (oder hexadezimal: B3010000, B4010000, B6010000, B7010000, BA010000, ...). <br><br><img src="https://habrastorage.org/webt/nl/50/eo/nl50eo8cjnx0mnexkbcf-sqld20.jpeg"><br><br>  Eine solche Sequenz mit Auslassungen trat bei NVR-Dateien auf, die den Videos entsprachen, die der DVR gleichzeitig von zwei oder mehr Kan√§len aufzeichnete.  Das hei√üt, wenn sich beispielsweise die Sequenz "435, 436, 438, 439, 442, ..." auf Video von einem Kanal bezieht, beziehen sich die fehlenden Werte (437, 440, 441) auf Video von einem anderen Kanal, das im selben Kanal ausgef√ºhrt wurde Zeitpunkt.  Ich selbst war davon √ºberzeugt, indem ich die entsprechenden NVR-Dateien anhand ihres Namens angesehen und verglichen habe.  Es besteht kein Zweifel, dass die obigen Zahlen die Nummern einiger Teile bilden, die sich auf die Videos beziehen.  Es bleibt nur die Beziehung zwischen diesen Zahlen und den Koordinaten des Speicherplatzes zu entschl√ºsseln, auf dem sich die Daten befinden. <br><br>  Au√üerdem sollte genau herausgefunden werden, welche Daten in die oben nummerierten Segmente unterteilt sind.  Die erste Annahme - die Daten sind Audio- und Videostr√∂me, die in dem Beh√§lter 264 durch kurze Bl√∂cke dargestellt werden, und wie gesagt wurde, haben die Bl√∂cke des Videostreams unterschiedliche Gr√∂√üen.  Gleichzeitig sammelt der DVR diese Str√∂me und packt sie in einen Container 264 beim Extrahieren von Videoaufzeichnungen auf externe Medien. Die zweite Annahme ist, dass der DVR zu Beginn und w√§hrend der Videoaufnahme Streams von Audio und Video in einen Container 264 packt.  Gleichzeitig werden bereits generierte .264-Dateidaten auf die Festplatte geschrieben, was sich aufgrund der Extraktion auf ein externes Medium herausgestellt h√§tte.  Beim Durchsuchen des Festplattenspeichers in der Mitte des zweiten Abschnitts sowie der Bytes von Audio- und Videostreams und ihrer Header des gleichen Typs wie in Container 264 stie√ü ich auch auf die Header des Containers selbst: MDVR96NT_2_R.  Nach diesem Header gab es auch viele Bytes von Nullen.  Im Allgemeinen hat die Studie gezeigt, dass es eine zweite Option der beiden oben genannten gibt.  Um die gew√ºnschte .264-Datei zu erhalten, m√ºssen Sie h√∂chstwahrscheinlich nur alle Segmente miteinander verbinden, deren Nummern in der entsprechenden nvr-Datei enthalten sind. <br><br>  Beginnen wir mit der Suche nach der Beziehung zwischen der Segmentnummer und den Koordinaten auf der Festplatte. <br><br>  Der Anfang der Daten des Containers 264 entspricht der allerersten Videoaufzeichnung (wobei die Nummerierung der Segmente bei Null beginnt) mit Suchwerkzeugen, die ich im Sektor 16046629 gefunden habe (29824 Sektoren vom Anfang des Abschnitts).  Wir k√∂nnen eine Annahme √ºber den sogenannten Parameter machen  anf√§ngliche Verzerrung, die an der Formel teilnimmt, die die gew√ºnschte Abh√§ngigkeit beschreibt. <br><br>  Nehmen wir zwei NVR-Dateien, die Videos von verschiedenen Kan√§len entsprechen, die der DVR gleichzeitig aufgenommen hat.  Schauen Sie sich dazu die Dateinamen an.  Beispielsweise wurden die Videos, auf die in den Dateien "ch00000000000001-150330-160937-161035-02p101000000.nvr" und "ch00000000000004-150330-160000-163000-00p004000000.nvr" verwiesen wird, gleichzeitig aufgezeichnet.  Die erste Aufnahme ist die Aufnahme vom 1. Kanal von 16:09:37 bis 16:10:35 Uhr.  Die zweite Aufzeichnung ist eine Aufzeichnung vom 4. Kanal von 16:00:00 bis 16:30:00 Uhr.  Beide Eintr√§ge wurden am 30. M√§rz 2015 vorgenommen. Auf der Zeitachse ist das Zeitintervall des ersten Datensatzes offensichtlich eine Teilmenge des Zeitintervalls des zweiten Datensatzes.  Ich ber√ºcksichtige auch die Tatsache, dass der DVR in einem k√ºrzeren Zeitintervall (im Schnittpunkt zweier Intervalle) keine Videoaufnahme von einem der anderen 6 Kan√§le durchgef√ºhrt hat.  Durchsuchen Sie den Inhalt dieser NVR-Dateien.  Wir werden sicherstellen, dass die fehlenden Zahlen (Segmentnummern) in der zweiten langen Datei notwendigerweise vollst√§ndig und vollst√§ndig in der ersten kurzen Datei vorhanden sind.  Wenn Sie den DVR wie gewohnt verwenden, m√ºssen Sie im Voraus mindestens eine der .264-Dateien extrahieren, auf die in den untersuchten nvr-Dateien verwiesen wird.  Angenommen, "ch00000000000001-150330-160937-161035-02p101000000.264" wurde extrahiert.  √ñffnen Sie es im Bin√§reditor.  Wie bereits erw√§hnt, befinden sich am Anfang dieser Datei vor dem Schl√ºsselwort "MDVR96NT_2_R" eindeutige Bytes, die dem Datum und der Uhrzeit der in dieser Datei enthaltenen Videoaufzeichnung entsprechen.  Wir schreiben alle diese Bytes ab, beginnend mit ungleich Null und endend mit dem Header (je k√ºrzer die f√ºr diese Videoaufnahme eindeutige Bytekette ist, desto besser).  Schreiben Sie auch den Offset dieser Bytefolge vom Anfang der Datei.  Es ist zu beachten, dass am Anfang der extrahierten .264-Datei zus√§tzliche 4 Byte Nullen stehen.  Dies wurde durch den Vergleich der ersten 512 Bytes der .264-Datei und des Speicherplatzsektors, von dem aus der Inhalt einer der .264-Dateien beginnt, deutlich (eine Datei fast jedes Dateisystems beginnt immer am Anfang des Sektors, au√üerdem ein Cluster).  Das hei√üt, die Informationen in der .264-Datei werden im Voraus um 4 Byte nach rechts verschoben.  Die Gr√∂√üe (in Bytes) einer .264-Datei ist erst dann ein Vielfaches von 512, wenn zuerst die Zahl 4 von der Gr√∂√üe abgezogen wurde.  Beginnen wir mit der Suche nach dem Sektor, von dem aus die untersuchte .264-Datei beginnt.  Starten Sie im Festplatteneditor die Suchfunktion.  Geben Sie im Feld des gew√ºnschten Werts eine eindeutige Zeichenfolge von Bytes ein, die im Voraus abgeschrieben wurden.  Um die Suche zu beschleunigen, geben Sie den Versatzwert in das Feld "Suche nach Versatz" ein und subtrahieren Sie zuvor 4. Starten Sie die Suche.  Einige Stunden sp√§ter war die Suche erfolgreich.  Wir notieren die Nummer des Sektors, in dem sich der eindeutige Titel befindet.  Sei dies der Wert von s.  Wir schauen uns den Inhalt der NVR-Datei f√ºr dieses Video an.  Wir schreiben die Nummer des ersten Segments ab (4 Bytes bei Offset 40).  Sei dies der Wert von b.  Insgesamt kennen wir zwar die Plattensektornummer (16046629) f√ºr die Nullsegmentnummer (in der allerersten Videoaufzeichnung) und die Nummer des gefundenen Sektors der Platte s f√ºr die gerade abgeschriebene Segmentnummer b.  Sie k√∂nnen die gesch√§tzte Segmentgr√∂√üe berechnen: (s-16046629) / (b-0).  Nach der Berechnung habe ich den Wert 128 erhalten. Somit entspricht die Segmentgr√∂√üe 128 Plattensektoren (LBA) oder 128 * 512 = 65536 Bytes! <br><br>  Ich f√ºhrte ein weiteres interessantes Experiment durch, um endlich alle Zweifel auszur√§umen.  Es wird unten beschrieben. <br><br>  Ab dem Beginn der Sektoren w√§hlen wir einen Bereich auf der Festplatte mit einer Gr√∂√üe aus, die mit der Gr√∂√üe einer .264-Datei vergleichbar ist, die mit diesem Sektor beginnt.  Wenn meine Vermutungen richtig sind, fallen Segmente einer anderen .264-Datei, die gleichzeitig mit der ersten auf der Festplatte aufgenommen wurde, in den ausgew√§hlten Bereich.  Speichern Sie diesen Bereich in einer Datei (erstellen Sie ein Bild).  Schneiden Sie das resultierende Bild in Dateien mit 65.536 Byte (Segmentgr√∂√üe).  Dies kann mit der Funktion ‚ÄûDatei teilen‚Äú in Total Commander erfolgen.  Lassen Sie es St√ºcke M1, M2, M3, .... sein.  In √§hnlicher Weise schneiden wir die untersuchte .264-Datei (die auf benutzerfreundliche Weise aus dem DVR extrahiert wurde), entfernen jedoch zuerst 4 Byte Nullen.  Lassen Sie es St√ºcke K1, K2, K3, .... sein.  Mit der Funktion "Nach Inhalt vergleichen" in Total Commander vergleichen wir nacheinander die Teile des Bildes und die Teile aus der .264-Datei.  (M1 mit K1, M2 mit K2 usw.), geleitet von den Segmentnummern aus der entsprechenden NVR-Datei.  Das Ergebnis ist das Folgende.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angenommen (Zahlen vom Bulldozer), die Zahlenkette in nvr ist wie folgt: 435, 436, 438, 439, 442, ... In dieser Situation ist M1 = K1, M2 = K2, M4 = K3, M5 = K4, M8 = K5, .... Das hei√üt, die Teile, in die die Bilddatei und die .264-Datei unterteilt wurden, sind gleich, wobei der entsprechende Fortschritt in der Anzahl der Teile der Bilddatei entsprechend den Auslassungen in der Sequenz ber√ºcksichtigt wird. So ist das! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Insgesamt haben wir die gesch√§tzte Abh√§ngigkeit erhalten: S = 16046629 + 128 * d, wobei d die Segmentnummer in der nvr-Datei und S die Sektornummer auf der Festplatte ist, beginnend am Anfang der Platte, von der aus der Inhalt des Segments beginnt. Segmentgr√∂√üe - 128 Sektoren. Die obige Formel ber√ºcksichtigt nicht die Existenz des zweiten Abschnitts. Die Abh√§ngigkeit wird nur f√ºr ein bestimmtes Beispiel von HDD bis 1 TB gefunden. Wenn Sie der DVR-Festplatte eine andere Kapazit√§t hinzuf√ºgen, sehen die Konstanten m√∂glicherweise anders aus.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die G√ºltigkeit der Formel zu √ºberpr√ºfen, berechnen wir die Position des ersten Segments einer anderen beliebigen .264-Datei, die von der entsprechenden nvr-Datei geleitet wird. Vergleichen Sie das Datum und die Uhrzeit im Dateinamen und vergleichen Sie sie mit den ersten Bytes im .264-Header des berechneten Sektors. Bytes, die die Anzahl, den Monat, das Jahr, die Stunden, die Minuten und die Sekunden einzeln codieren, entsprechen tempor√§ren Daten im Dateinamen. Deshalb "den Nagel treffen"! Wir berechnen in der nvr-Datei, die der im Voraus extrahierten .264-Datei entspricht, die Anzahl der cs-Segmente. Im Allgemeinen ist ihre Anzahl cs = sf / 32-1, wobei sf die Gr√∂√üe der nvr-Datei ist. Wenn die .264-Datei aus cs-Segmenten besteht, sollte ihre Gr√∂√üe gleich cs * 65536 + 4 sein (die Anzahl der Segmente multipliziert mit der Segmentgr√∂√üe in Bytes plus 4 derselben Bytes von Nullen). Und das ist es wirklich!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versuchen Sie dennoch, den zweiten Abschnitt zu erkunden. Wie bereits erw√§hnt, befindet sich etwas √Ñhnliches wie ein Superblock direkt im ersten Sektor des Abschnitts (16016805). Und seine genaue Kopie wurde von sieben Sektoren unten entdeckt (16016812). Offensichtlich befinden sich grundlegende Informationen ungleich Null im ersten Sektor des Superblocks. Das Erscheinungsbild im Festplatteneditor ist in der folgenden Abbildung dargestellt.</font></font><br><br><img src="https://habrastorage.org/webt/rg/gz/wc/rggzwchl6xsvzhuvbfzslhrhyho.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe es geschafft, einen Teil der 4-Byte-Parameter zu entschl√ºsseln. Datum und Uhrzeit der Montage der Partition sind blau hervorgehoben. Datum und Uhrzeit werden in einer speziellen Notation ‚ÄûUnix-Zeit‚Äú dargestellt (die Anzahl der Sekunden, die seit Mitternacht am 1. Januar 1970 vergangen sind). Im obigen Beispiel entspricht ‚Äû03 7E 74 54‚Äú (Dezimalwert 1416920579) ‚ÄûDi, 25. November 2014, 13:02:59 GMT‚Äú. Um die Werte zu √ºbersetzen, habe ich einen speziellen Online-Rechner verwendet. Der Wert 65536 ist im violetten Rahmen eingekreist. Es ist m√∂glich, dass der Dateisysteminterpreter im DVR-Programm beim Lesen der Blockgr√∂√üe auf diese Position des Superblocks verweist (im vorherigen Kontext habe ich Blocksegmente genannt). Die Werte 1 werden im gr√ºnen Rahmen hervorgehoben. Einer von ihnen gibt wahrscheinlich die Position des sogenannten Anfangs an Bitmap (in der Anzahl der Bl√∂cke vom Anfang des Abschnitts). In der TatIm Voraus wurde der Anfang der Informationen gefunden, √§hnlich einer Bitmap f√ºr den Sektor 16016933 (16016805 + 128 * 1). Der Wert 233 wird im roten Rahmen hervorgehoben. Dies ist genau die Position des Beginns dieser .264-Videoaufnahmen vom Anfang des Abschnitts: 16016805 + 128 * 233 = 16046629.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das hei√üt, der zweite Abschnitt kann als abgeschnittener und leicht modifizierter Abschnitt von EXT2 bezeichnet werden. Es hat einen Superblock, eine Kopie davon, eine Bitmap. Es gibt aber keine sogenannten. Informationsknoten, die Dateidatens√§tzen entsprechen. Der Abschnitt enth√§lt Daten von .264-Dateien (Audio- und Videostreams), aber die Informationsknoten (sagen wir mal) f√ºr diese Daten befinden sich in NVR-Dateien im ersten Abschnitt. Vielleicht gibt es eine kompetentere Formulierung? Das ist mir aber nicht so wichtig.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schreiben wir ein einfaches Programm zur Massenextraktion von .264-Dateien. Ich muss sofort sagen, dass ich nicht viel Erfahrung in der Programmierung unter Windows habe. Das Programm scannt alle NVR-Dateien, die vorab in den 1-TB-Bereich der neuen Festplatte kopiert wurden. Durch die Analyse erstellt das Programm eine .264-Datei mit demselben Namen im selben Verzeichnis und verwendet dabei den Zugriff auf die Sektoren der urspr√ºnglichen Festplatte. Zuvor wurde in einem leeren Bereich der neuen Festplatte ein Ordner mit dem Namen ‚ÄûDVR‚Äú erstellt, in dem Ordner nach Datum abgelegt werden, die unter Linux auf die ‚Äû√ºbliche Weise‚Äú kopiert werden. Es war m√∂glich, einen Algorithmus f√ºr die Arbeit mit der ersten Linux-Partition in dieses Programm aufzunehmen, um auf NVR-Dateien zuzugreifen, damit diese nicht vorab kopiert werden m√ºssen. Und Sie k√∂nnten andere praktische Funktionen hinzuf√ºgen. Ja, das war m√∂glich, aber in diesem Moment wollte ich alles so schnell wie m√∂glich erledigen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe keine Rekursion zum Scannen von Verzeichnissen verwendet, da das Format der Verzeichnisse festgelegt ist und zwei Anhangsebenen aufweist. </font><font style="vertical-align: inherit;">Dementsprechend habe ich zwei Zyklen angewendet: Durchlaufen der Ordner bis zum Ende und Durchlaufen der Dateien in jedem Ordner mit derselben Bedingung. </font><font style="vertical-align: inherit;">Zum Lesen von Dateien habe ich die Funktion fopen verwendet. </font><font style="vertical-align: inherit;">F√ºr die Arbeit mit Festplattensektoren habe ich die WinAPI-Funktionalit√§t verwendet, die der Arbeit mit Dateien √§hnelt. </font><font style="vertical-align: inherit;">Fahren wir mit dem Programmcode fort. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bibliotheken brauchen solche.</font></font><br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;windows.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt;</span></span></span></span></code> </pre> <br>  Und ich habe diese Funktionen komplett aus einem Forum kopiert. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">HANDLE </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">openDevice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> device)</span></span></span><span class="hljs-function"> </span></span>{ HANDLE handle = INVALID_HANDLE_VALUE; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (device &lt;<span class="hljs-number"><span class="hljs-number">0</span></span> || device &gt;<span class="hljs-number"><span class="hljs-number">99</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> INVALID_HANDLE_VALUE; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> _devicename[<span class="hljs-number"><span class="hljs-number">20</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(_devicename, <span class="hljs-string"><span class="hljs-string">"\\\\.\\PhysicalDrive%d"</span></span>, device); <span class="hljs-comment"><span class="hljs-comment">// Creating a handle to disk drive using CreateFile () function .. handle = CreateFile(_devicename, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL); return handle; } HANDLE openOutputFile(const char * filename) { return CreateFile ( filename, // Open Two.txt. GENERIC_WRITE, // Open for writing 0, // Do not share NULL, // No security OPEN_ALWAYS, // Open or create FILE_ATTRIBUTE_NORMAL, // Normal file NULL); // No template file }</span></span></code> </pre><br>  Die Kopierfunktion enth√§lt eine lineare Abh√§ngigkeitsformel, die in der obigen Theorie enthalten ist. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HANDLE device, HANDLE file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> s)</span></span></span></span>{ LONG HPos; LONG LPos; __int64 sector; sector = <span class="hljs-number"><span class="hljs-number">16046629</span></span>+<span class="hljs-number"><span class="hljs-number">128</span></span>*s; HPos = (sector*<span class="hljs-number"><span class="hljs-number">512</span></span>)&gt;&gt;<span class="hljs-number"><span class="hljs-number">32</span></span>; LPos = (sector*<span class="hljs-number"><span class="hljs-number">512</span></span>); SetFilePointer (device, LPos, &amp;HPos, FILE_BEGIN); DWORD dwBytesRead; DWORD dwBytesWritten; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">65536</span></span>]; ReadFile(device, buf, <span class="hljs-number"><span class="hljs-number">65536</span></span>, &amp;dwBytesRead, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); WriteFile(file, buf, dwBytesRead, &amp;dwBytesWritten, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); }</code> </pre><br>  Die Hauptfunktion ist auch recht einfach. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ HANDLE hdd = openDevice(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    HDD  DVR,    ; SetFilePointer (hdd, 0, NULL, FILE_BEGIN); DWORD dwBytesRead; char name[100]; unsigned int bl; //  ; unsigned int N; // ; unsigned long int pt; //  ; WIN32_FIND_DATA fld,fld1; //   nvr   ; HANDLE hf,hf1; hf=FindFirstFile("E:\\DVR\\*",&amp;fld); FindNextFile(hf,&amp;fld);// "."; FindNextFile(hf,&amp;fld);// ".."; do{ char *str = new char; sprintf(str,"%s%s%s","E:\\DVR\\",fld.cFileName,"\\*.nvr"); printf("\n\nFOLDER: %s\n\n",str); hf1=FindFirstFile(str,&amp;fld1); do{ FILE *nvr; sprintf(name,"%s%s%s%s","E:\\DVR\\",fld.cFileName,"\\",fld1.cFileName); nvr=fopen(name,"rb"); name[strlen(name)-3]='2'; //   ,  name[strlen(name)-2]='6'; // ; name[strlen(name)-1]='4'; HANDLE out = openOutputFile(name); SetFilePointer(out, 4, NULL, FILE_BEGIN); //  "",  4      (  ); bl=0; N=fld1.nFileSizeLow/32-1; //   (); printf("\t%s\n\t%i Blocks\n\n",fld1.cFileName,N); for(bl=0;bl&lt;N;bl++){ //  ; fseek(nvr,40+32*bl,SEEK_SET); //; fread(&amp;pt,1,4,nvr); // ; copy(hdd,out,pt); //  ; } CloseHandle(out); fclose(nvr); }while(FindNextFile(hf1,&amp;fld1)); FindClose(hf1); delete str; }while(FindNextFile(hf,&amp;fld)); FindClose(hf); CloseHandle(hdd); system("PAUSE"); return 0; }</span></span></code> </pre><br>  Auf einem alten Computer mit einem Pentium 4-Prozessor und einem PCI-SATA-Controller √ºbertrug das Programm erfolgreich eine Vollfestplatte mit mehreren tausend .264-Dateien in durchschnittlich 7 Stunden.  Auf einem neuen Computer - dreimal schneller.  Wie bereits erw√§hnt, ist das Programm nicht universell, alle Konstanten und Variablen werden von HDD bis 1 TB an meinen speziellen Fall angepasst.  Sie k√∂nnen jedoch etwas mehr arbeiten und es universell machen, indem Sie eine grafische Oberfl√§che dazu zeichnen. <br><br>  Im zweiten Teil des Artikels werde ich schreiben, wie man es selbst macht, um vom Container "264" in den Standardcontainer "avi" umzupacken. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de421933/">https://habr.com/ru/post/de421933/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de421923/index.html">Wir verstehen Designberufe</a></li>
<li><a href="../de421925/index.html">√úbersicht √ºber den 3D-Drucker Raise 3D Pro 2 Plus</a></li>
<li><a href="../de421927/index.html">√úberblick √ºber das Smartphone General Mobile GM8 Go: Ein t√ºrkischer Budget-Mitarbeiter mit Android 8.1 Oreo Go Edition</a></li>
<li><a href="../de421929/index.html">Ein Jahr vor dem Brexit: Gro√übritannien l√∂st das Problem des Arbeitskr√§ftemangels durch Robotik</a></li>
<li><a href="../de421931/index.html">Auswirkungen des Spectre-, Meltdown- und Foreshadow-Schutzes auf die Leistung von Linux 4.19</a></li>
<li><a href="../de421935/index.html">Erste Eindr√ºcke vom √úbergang von Ubuntu 16.04 LTS zu Ubuntu 18.04 LTS</a></li>
<li><a href="../de421937/index.html">Smart City im Inneren - ein Blick auf Huawei</a></li>
<li><a href="../de421939/index.html">Verwenden von SQL in Rails</a></li>
<li><a href="../de421945/index.html">Google und Mastercard schlie√üen ein geheimes Gesch√§ft ab, um Eink√§ufe in Gesch√§ften zu verfolgen</a></li>
<li><a href="../de421947/index.html">Willkommen zum Android Devs Meetup am 8. September</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>