<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍💻 👩‍❤️‍💋‍👩 🧙🏻 Optimisation des requêtes de base de données sur l'exemple de service B2B pour les constructeurs 👦🏽 👐 👊</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Comment faire croître 10 fois le nombre de requêtes de base de données sans passer à un serveur plus efficace et maintenir le système en marche? Je va...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimisation des requêtes de base de données sur l'exemple de service B2B pour les constructeurs</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461071/"> Comment faire croître 10 fois le nombre de requêtes de base de données sans passer à un serveur plus efficace et maintenir le système en marche?  Je vais vous dire comment nous avons lutté avec la dégradation des performances de notre base de données, comment nous avons optimisé les requêtes SQL pour servir le plus d'utilisateurs possible et ne pas augmenter le coût des ressources informatiques. <br><a name="habracut"></a><br>  Je fais un service de gestion des processus d'affaires dans les entreprises de construction.  Environ 3 000 entreprises travaillent avec nous.  Plus de 10 000 personnes travaillent quotidiennement avec notre système pendant 4 à 10 heures.  Il résout diverses tâches de planification, alertes, avertissements, validations ... Nous utilisons PostgreSQL 9.6.  Nous avons environ 300 tables dans la base de données et chaque jour, jusqu'à 200 millions de demandes (10 000 différentes) lui sont envoyées.  En moyenne, nous avons 3 à 4 000 demandes par seconde, dans les moments les plus actifs, plus de 10 000 demandes par seconde.  La plupart des demandes sont OLAP.  Il y a beaucoup moins d'ajouts, de modifications et de suppressions, c'est-à-dire que la charge OLTP est relativement faible.  J'ai donné tous ces chiffres afin que vous puissiez évaluer la portée de notre projet et comprendre comment notre expérience peut vous être utile. <br><br><h3>  La première photo.  Lyrique </h3><br>  Lorsque nous avons commencé le développement, nous ne pensions pas vraiment au type de charge qui tomberait sur la base de données et à ce que nous ferions si le serveur arrêtait de tirer.  Lors de la conception de la base de données, nous avons suivi les recommandations générales et essayé de ne pas nous tirer dans le pied, mais au-delà des conseils généraux tels que «n'utilisez pas le modèle de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">valeurs d'attribut d'entité</a> , nous n'y sommes pas allés.  Conçu sur la base des principes de normalisation évitant la redondance des données et ne se souciant pas d'accélérer certaines requêtes.  Dès l'arrivée des premiers utilisateurs, nous avons rencontré un problème de performances.  Comme d'habitude, nous n'étions absolument pas préparés à cela.  Les premiers problèmes étaient simples.  En règle générale, tout a été décidé en ajoutant un nouvel index.  Mais il est arrivé un moment où de simples correctifs ne fonctionnaient plus.  Ayant réalisé qu'il n'y a pas assez d'expérience et qu'il devient de plus en plus difficile de comprendre quelle est la cause des problèmes, nous avons embauché des spécialistes qui nous ont aidés à configurer correctement le serveur, à connecter la surveillance, à montrer où chercher pour obtenir des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">statistiques</a> . <br><br><h3>  La deuxième photo.  Statistiques </h3><br>  Nous avons donc environ 10 000 requêtes différentes qui sont exécutées par jour dans notre base de données.  Sur ces 10 000, il y a des monstres qui s'exécutent 2 à 3 millions de fois avec un temps d'exécution moyen de 0,1 à 0,3 ms et il y a des requêtes avec un temps d'exécution moyen de 30 secondes qui sont appelées 100 fois par jour. <br><br>  Il n'a pas été possible d'optimiser les 10 000 requêtes, nous avons donc décidé de déterminer où diriger les efforts afin d'améliorer correctement les performances de la base de données.  Après plusieurs itérations, nous avons commencé à diviser les demandes en types. <br><br><h4>  TOP requêtes </h4><br>  Ce sont les requêtes les plus difficiles qui prennent le plus de temps (temps total).  Ce sont des requêtes qui sont soit appelées très souvent, soit des requêtes qui prennent très longtemps (les requêtes longues et fréquentes ont été optimisées dès les premières itérations de la lutte pour la vitesse).  En conséquence, le serveur passe le plus de temps à leur exécution au total.  De plus, il est important de séparer les requêtes principales par le temps d'exécution total et séparément par le temps d'E / S.  Les moyens d'optimiser ces requêtes sont légèrement différents. <br><br>  La pratique habituelle de toutes les entreprises est de traiter les demandes TOP.  Il y en a peu, l'optimisation d'une seule demande peut libérer jusqu'à 5 à 10% des ressources.  Cependant, à mesure que le projet vieillit, l'optimisation des requêtes TOP devient une tâche de plus en plus simple.  Toutes les méthodes simples ont déjà été élaborées, et même la demande la plus «difficile» ne prend «que» 3 à 5% des ressources.  Si les requêtes TOP prennent au total moins de 30 à 40% du temps, alors vous avez probablement déjà fait des efforts pour qu'elles fonctionnent rapidement et il est temps de passer à l'optimisation des requêtes du groupe suivant. <br>  Il reste à répondre à la question du nombre de requêtes principales à inclure dans ce groupe.  Je prends habituellement pas moins de 10, mais pas plus de 20. J'essaie de faire en sorte que l'heure du premier et du dernier dans le groupe TOP ne diffère pas plus de 10 fois.  Autrement dit, si le temps d'exécution de la requête chute fortement de 1 à 10, alors je prends TOP-10, si la chute est plus fluide, alors j'augmente la taille du groupe à 15 ou 20. <br><img src="https://habrastorage.org/webt/y5/j5/yx/y5j5yxa6u4kxlpahplsaprh07ro.png" alt="image"><br><br><h4>  Paysans moyens (moyen) </h4><br>  Ce sont toutes des demandes qui vont immédiatement après TOP, à l'exception des 5-10% derniers.  Habituellement, dans l'optimisation de ces demandes particulières réside la possibilité d'augmenter considérablement les performances du serveur.  Ces requêtes peuvent «peser» jusqu'à 80%.  Mais même si leur part a dépassé 50%, il est temps de les regarder de plus près. <br><br><h4>  Queue </h4><br>  Comme cela a été dit, ces demandes vont à la fin et prennent 5 à 10% du temps.  Vous ne pouvez les oublier que si vous n'utilisez pas d'outils d'analyse automatique des requêtes, leur optimisation peut également être bon marché. <br><br>  Comment évaluer chaque groupe? <br><br>  J'utilise une requête SQL qui aide à faire une telle évaluation pour PostgreSQL (je suis sûr que pour de nombreux autres SGBD, vous pouvez écrire une requête similaire) <br><br><div class="spoiler">  <b class="spoiler_title">Requête SQL pour estimer la taille des groupes TOP-MEDIUM-TAIL</b> <div class="spoiler_text"><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(time_top) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> sum_top, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(time_medium) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> sum_medium, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(time_tail) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> sum_tail <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> rn &lt;= <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> tt_percent <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> time_top, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> rn &gt; <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> rn &lt;= <span class="hljs-number"><span class="hljs-number">800</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> tt_percent <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> time_medium, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> rn &gt; <span class="hljs-number"><span class="hljs-number">800</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> tt_percent <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> time_tail <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> total_time / (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(total_time) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_statements) * <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> tt_percent, <span class="hljs-keyword"><span class="hljs-keyword">query</span></span>, ROW_NUMBER () <span class="hljs-keyword"><span class="hljs-keyword">OVER</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> total_time <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> rn <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_statements <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> total_time <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> t ) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ts</code> </pre> <br></div></div><br>  Le résultat de la requête est composé de trois colonnes, chacune contenant un pourcentage du temps consacré au traitement des demandes de ce groupe.  Dans la requête, il y a deux nombres (dans mon cas, 20 et 800) qui séparent les demandes d'un groupe d'un autre. <br><br>  C'est ainsi que les proportions de demandes au moment du démarrage des travaux d'optimisation sont à peu près en corrélation. <br><br><img src="https://habrastorage.org/webt/db/at/i_/dbati_rdn49yulwdicigqdvrgew.png"><br><br>  Le diagramme montre que la part des demandes TOP a fortement diminué, mais les «paysans moyens» ont augmenté. <br>  Initialement, les erreurs TOP ont touché les requêtes TOP.  Au fil du temps, les maladies infantiles ont disparu, la part des demandes TOP a été réduite et davantage d'efforts ont dû être faits pour accélérer les demandes difficiles. <br><br><div class="spoiler">  <b class="spoiler_title">Pour obtenir le texte des demandes, nous utilisons une telle demande</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> ROW_NUMBER () <span class="hljs-keyword"><span class="hljs-keyword">OVER</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> total_time <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> rn, total_time / (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(total_time) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_statements) * <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> tt_percent, <span class="hljs-keyword"><span class="hljs-keyword">query</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_statements <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> total_time <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> T <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> rn &lt;= <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-comment"><span class="hljs-comment">-- TOP -- rn &gt; 20 AND rn &lt;= 800 -- MEDIUM -- rn &gt; 800 -- TAIL</span></span></code> </pre><br></div></div><br>  Voici une liste des astuces les plus couramment utilisées qui nous ont aidés à accélérer les requêtes TOP: <br><br><ul><li>  Refonte des systèmes, par exemple, traitement de la logique de notification sur le courtier de messages au lieu des requêtes de base de données périodiques </li><li>  Ajout ou modification d'index </li><li>  Réécrire les requêtes ORM en SQL pur </li><li>  Réécrire la logique de chargement des données paresseuses </li><li>  Mise en cache via la dénormalisation des données.  Par exemple, nous avons un lien entre les tables Livraison -&gt; Facture -&gt; Demande -&gt; Demande.  En d'autres termes, chaque livraison est associée à l'application via d'autres tables.  Afin de ne pas lier toutes les tables dans chaque demande, nous avons dupliqué le lien vers l'application dans la table de livraison. </li><li>  Mise en cache des tables statiques avec des répertoires et rarement des tables changeantes dans la mémoire du programme. </li></ul><br>  Parfois, les changements entraînaient une refonte impressionnante, mais ils donnaient 5 à 10% du déchargement du système et étaient justifiés.  Au fil du temps, l'échappement est devenu de moins en moins, et la refonte devait être de plus en plus sérieuse. <br><br>  Nous avons ensuite attiré l'attention sur le deuxième groupe de demandes - le groupe des paysans moyens.  Il a beaucoup plus de demandes et il semblait que cela prendrait beaucoup de temps pour analyser l'ensemble du groupe.  Cependant, la plupart des requêtes se sont avérées très simples pour l'optimisation, et de nombreux problèmes ont été répétés des dizaines de fois dans différentes variantes.  Voici des exemples d'optimisations typiques que nous avons appliquées à des dizaines de requêtes similaires et chaque groupe de requêtes optimisées a déchargé la base de données de 3 à 5%. <br><br><ul><li>  Au lieu de vérifier la présence d'enregistrements avec COUNT et une analyse complète de la table, EXISTS <br></li><li>  Nous nous sommes débarrassés de DISTINCT (il n'y a pas de recette générale, mais parfois vous pouvez facilement vous en débarrasser en accélérant la requête 10 à 100 fois). <br><br>  Par exemple, au lieu d'interroger pour sélectionner tous les pilotes sur une grande table de livraison (LIVRAISON) <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DISTINCT</span></span> P.ID, P.FIRST_NAME, P.LAST_NAME <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> DELIVERY D <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> PERSON P <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> D.DRIVER_ID = P.ID</code> </pre><br>  a fait une demande pour une table PERSON relativement petite <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> P.ID, P.FIRST_NAME, P.LAST_NAME <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> PERSON <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> D.ID <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> DELIVERY <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> D.DRIVER_ID = P.ID)</code> </pre><br>  Il semblerait que nous ayons utilisé une sous-requête corrélative, mais cela donne une accélération de plus de 10 fois. <br></li><li>  Dans de nombreux cas, COUNT et <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">remplacé par le calcul de la valeur approximative</a> <br></li><li>  au lieu de <br><br><pre> <code class="sql hljs">UPPER(s) LIKE JOHN%'</code> </pre><br>  utiliser <br><br><pre> <code class="sql hljs">s ILIKE “John%”</code> </pre><br></li></ul><br>  Chaque demande spécifique a parfois été accélérée de 3 à 1 000 fois.  Malgré les performances impressionnantes, au début, il nous semblait inutile d'optimiser la requête, qui était exécutée pendant 10 ms, incluse dans la 3e centaine des requêtes les plus lourdes et dans le temps total de chargement de la base de données, elle prenait des centièmes de pour cent.  Mais en appliquant la même recette à un groupe de demandes similaires, nous avons regagné plusieurs pour cent.  Afin de ne pas perdre de temps à visualiser manuellement les centaines de requêtes, nous avons écrit plusieurs scripts simples qui, à l'aide d'expressions régulières, ont trouvé des requêtes similaires.  Par conséquent, la recherche automatique de groupes de requêtes nous a permis d'améliorer encore nos performances en déployant des efforts modestes. <br><br>  En conséquence, nous travaillons sur le même matériel depuis trois ans maintenant.  La charge journalière moyenne est d'environ 30%, aux pointes elle atteint 70%.  Le nombre de demandes ainsi que le nombre d'utilisateurs a augmenté d'environ 10 fois.  Et tout cela grâce au suivi constant de ces mêmes groupes de requêtes TOP-MEDIUM.  Dès qu'une nouvelle demande apparaît dans le groupe TOP, nous l'analysons immédiatement et essayons de l'accélérer.  Nous passons en revue le groupe MEDIUM une fois par semaine à l'aide de scripts d'analyse de requête.  Si vous rencontrez de nouvelles demandes que nous savons déjà optimiser, nous les modifions rapidement.  Parfois, nous trouvons de nouvelles méthodes d'optimisation qui peuvent être appliquées à plusieurs requêtes à la fois. <br><br>  Selon nos prévisions, le serveur actuel supportera une augmentation du nombre d'utilisateurs de 3 à 5 fois.  Certes, nous avons un atout de plus dans la pochette; nous n'avons toujours pas traduit les requêtes SELECT dans le miroir, comme recommandé.  Mais nous ne le faisons pas consciemment, car nous voulons d'abord épuiser pleinement les possibilités d'optimisation «intelligente» avant d'activer «l'artillerie lourde». <br>  Un examen critique du travail effectué peut suggérer l'utilisation d'une mise à l'échelle verticale.  Achetez un serveur plus puissant, au lieu de perdre le temps des spécialistes.  Le serveur peut ne pas coûter si cher, d'autant plus que les limites de la mise à l'échelle verticale n'ont pas encore été épuisées.  Cependant, seul le nombre de demandes a augmenté 10 fois.  Depuis plusieurs années, la fonctionnalité du système a augmenté et il existe désormais plus de variétés de demandes.  La fonctionnalité qui était due à la mise en cache est réalisée par moins de demandes, de plus, des demandes plus efficaces.  Vous pouvez donc multiplier en toute sécurité par 5 autres pour obtenir le coefficient d'accélération réel.  Ainsi, selon les estimations les plus prudentes, nous pouvons dire que l'accélération a été de 50 fois ou plus.  Secouer verticalement le serveur 50 fois coûterait plus cher.  Surtout si l'on considère qu'une fois l'optimisation est effectuée tout le temps, et une facture pour un serveur loué vient chaque mois. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr461071/">https://habr.com/ru/post/fr461071/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr461059/index.html">Écrire une application Android pour les fans de films - Partie 1 (Prototypage)</a></li>
<li><a href="../fr461061/index.html">Alliages de magnésium, frontières jumelles et ségrégation</a></li>
<li><a href="../fr461063/index.html">Interaction de R avec des bases de données sur l'exemple de Microsoft SQL Server et d'autres SGBD</a></li>
<li><a href="../fr461067/index.html">Les 65 principales questions SQL des entretiens d'embauche auxquelles vous devriez vous préparer en 2019. Partie I</a></li>
<li><a href="../fr461069/index.html">Caméras IP extérieures Nobelic: tests, technologies et capacités des systèmes de vidéosurveillance Ivideon</a></li>
<li><a href="../fr461073/index.html">Nous connectons des cartes en ligne au navigateur sur le smartphone. Partie 3 - OverpassTurbo</a></li>
<li><a href="../fr461075/index.html">Intelligence d'affaires. Objets informatiques, composants, outils</a></li>
<li><a href="../fr461077/index.html">Comment les pentesters sont-ils cuits? Test d'entrée pour les stagiaires en sécurité numérique</a></li>
<li><a href="../fr461079/index.html">Ville sans embouteillage</a></li>
<li><a href="../fr461081/index.html">Le jour où Dodo IS s'est arrêté. Script asynchrone</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>