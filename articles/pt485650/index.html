<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë© üë¶üèΩ üåà T√©cnicas de redu√ß√£o de imagem do Docker ‚úåüèª ü§æ üëàüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Voc√™ j√° se perguntou por que o tamanho de um cont√™iner do Docker contendo apenas um aplicativo pode ter cerca de 400 MB? Ou talvez voc√™ estivesse preo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>T√©cnicas de redu√ß√£o de imagem do Docker</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/485650/">  Voc√™ j√° se perguntou por que o tamanho de um cont√™iner do Docker contendo apenas um aplicativo pode ter cerca de 400 MB?  Ou talvez voc√™ estivesse preocupado com o tamanho bastante grande da imagem do Docker contendo um √∫nico bin√°rio de v√°rias dezenas de MB de tamanho? <br><br> <a href="https://habr.com/ru/company/ruvds/blog/485650/"><img src="https://habrastorage.org/webt/ny/az/k8/nyazk8uqdkaog5lwtukn8qz1zpu.jpeg"></a> <br><br>  O autor do artigo, cuja tradu√ß√£o estamos publicando hoje, deseja analisar os principais fatores que afetam o tamanho dos cont√™ineres do Docker.  Al√©m disso, ele compartilhar√° recomenda√ß√µes sobre a redu√ß√£o do tamanho dos cont√™ineres. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Camadas de imagem do Docker</font> </h2><br>  Uma imagem de um cont√™iner do Docker √© essencialmente uma cole√ß√£o de arquivos empilhados uns sobre os outros em v√°rias camadas.  Um cont√™iner de trabalho √© montado a partir desses arquivos.  O Docker usa o sistema de arquivos <a href="https://en.wikipedia.org/wiki/UnionFS">UnionFS</a> , no qual os arquivos s√£o agrupados em camadas.  Uma camada pode conter um arquivo ou v√°rios arquivos, camadas que se sobrep√µem.  Durante a execu√ß√£o do cont√™iner, o conte√∫do das camadas √© combinado, como resultado, o usu√°rio final do cont√™iner percebe os materiais "dispostos" em camadas como um √∫nico sistema de arquivos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a2/3ba/eea/0a23baeea85753e1a66d8399ff188b4c.png"></div><br>  <i><font color="#999999">Visualiza√ß√£o simplificada do UnionFS</font></i> <br><br>  O sistema de arquivos resultante √© apresentado ao usu√°rio final usando algumas implementa√ß√µes do UnionFS (o Docker <a href="https://docs.docker.com/storage/storagedriver/select-storage-driver/">suporta</a> muitas implementa√ß√µes semelhantes por meio de drivers de armazenamento de plug-in).  O tamanho total dos arquivos recebidos pelo usu√°rio final √© igual √† soma dos tamanhos dos arquivos nas camadas.  Quando o Docker cria um cont√™iner com base na imagem, ele usa todas as camadas somente leitura da imagem, adicionando uma camada fina sobre essas camadas que suporta leitura e grava√ß√£o.  √â essa camada que permite modificar arquivos em um cont√™iner em execu√ß√£o. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aaf/895/c00/aaf895c00a3353efa96934aeabd85f6f.png"></div><br>  <i><font color="#999999">O cont√™iner em execu√ß√£o cont√©m uma camada de leitura e grava√ß√£o localizada na parte superior das camadas de somente leitura</font></i> <br><br>  O que acontece se um arquivo for exclu√≠do na <code>Layer 4</code> cont√™iner apresentado esquematicamente acima?  Embora esse arquivo n√£o esteja dispon√≠vel no sistema de arquivos que o usu√°rio v√™, o tamanho desse arquivo ainda ser√° um dos componentes do tamanho do cont√™iner, pois esse arquivo permanecer√° em uma das camadas somente leitura. <br><br>  √â muito simples come√ßar a criar a imagem com um pequeno arquivo execut√°vel de aplicativo e obter uma imagem muito grande.  Abaixo, veremos v√°rios m√©todos para tornar os cont√™ineres o menor poss√≠vel. <br><br><h2>  <font color="#3AC1EF">Preste aten√ß√£o ao caminho para a pasta, com base nos materiais em que as imagens s√£o coletadas</font> </h2><br>  Qual √© a maneira mais comum de montar imagens do Docker?  Aparentemente - assim: <br><br><pre> <code class="plaintext hljs">docker build .</code> </pre> <br>  O ponto neste comando diz ao Docker que consideramos o diret√≥rio de trabalho atual como a raiz do sistema de arquivos usado no processo de montagem da imagem. <br><br>  Para entender melhor o que acontece depois que o comando acima √© executado, vale lembrar que a cria√ß√£o de uma imagem do Docker √© um processo cliente-servidor.  A interface da linha de comandos do Docker (cliente), √† ‚Äã‚Äãqual fornecemos o <code>docker build</code> , usa o mecanismo do Docker (servidor) para criar a imagem do cont√™iner.  Para limitar o acesso ao sistema de arquivos base do cliente, o sistema de montagem de imagens precisa saber onde est√° localizada a raiz do sistema de arquivos virtual.  √â a√≠ que as instru√ß√µes do arquivo <code>Dockerfile</code> pesquisam recursos de arquivo que eventualmente podem acabar na imagem que est√° sendo montada. <br><br>  Imagine um lugar onde um <code>Dockerfile</code> geralmente <code>Dockerfile</code> colocado.  Este √© provavelmente o diret√≥rio raiz do projeto?  Se houver um <code>Dockerfile</code> na raiz do projeto, usado pelo <code>docker build</code> para criar a imagem, acontece que todos os arquivos do projeto podem entrar na imagem.  Isso pode levar ao fato de que milhares de arquivos indesejados, com muitos megabytes de tamanho, podem entrar no contexto do conjunto de imagens.  Se voc√™ usar levemente os comandos <code>ADD</code> e <code>COPY</code> no <code>Dockerfile</code> , todos os arquivos do projeto poder√£o se tornar parte da imagem final.  Na maioria das vezes, aqueles que coletam imagens n√£o precisam disso, pois a imagem final geralmente deve incluir apenas alguns arquivos selecionados. <br><br>  Sempre verifique se o comando <code>docker build</code> caminho correto e se n√£o h√° comandos no <code>Dockerfile</code> que adicionem arquivos desnecess√°rios √† imagem.  Se, por algum motivo, voc√™ precisar tornar o projeto raiz no contexto de constru√ß√£o, poder√° incluir seletivamente arquivos nele e exclu√≠-los usando <code>.dockerignore</code> . <br><br><h2>  <font color="#3AC1EF">Otimizar camadas de imagem</font> </h2><br>  O n√∫mero m√°ximo de camadas que uma imagem pode ter √© 127 (dado o suporte para esse n√∫mero de camadas usado pelo driver do armaz√©m de dados).  Essa limita√ß√£o, se absolutamente necess√°ria, pode ser relaxada, mas com essa abordagem, a gama de sistemas nos quais essas imagens podem ser coletadas √© reduzida.  O ponto √© que o mecanismo do Docker deve ser executado em um sistema cujo kernel √© modificado de acordo. <br><br>  Como mencionado na se√ß√£o anterior, devido ao fato de o UnionFS ser usado na montagem de imagens, os arquivos que caem em uma determinada camada permanecem l√°, mesmo que tenham sido exclu√≠dos das camadas subjacentes.  Vamos descobrir isso usando o Dockerfile experimental: <br><br><pre> <code class="plaintext hljs">FROM alpine RUN wget http://xcal1.vodafone.co.uk/10MB.zip -P /tmp RUN rm /tmp/10MB.zip</code> </pre> <br>  Vamos montar a imagem: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44b/d7c/e6d/44bd7ce6d60c71fd0856e96bd48ec5b7.png"></div><br>  <i><font color="#999999">Montagem de uma imagem experimental na qual existe espa√ßo irracionalmente usado</font></i> <br><br>  Explore a imagem usando o <a href="https://github.com/wagoodman/dive">mergulho</a> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2da/e7f/1a5/2dae7f1a5875ece43a52042632a21401.png"></div><br>  <i><font color="#999999">O indicador de desempenho da imagem √© de 34%</font></i> <br><br>  O indicador de efici√™ncia de imagem de 34% indica que uma quantidade consider√°vel de espa√ßo na imagem √© usada irracionalmente.  Isso leva a um aumento no tempo de inicializa√ß√£o da imagem, ao desperd√≠cio desnecess√°rio de recursos de rede e a um tempo de in√≠cio mais lento do cont√™iner. <br><br>  Como se livrar desse problema?  Vamos considerar v√°rias op√ß√µes. <br><br><h3>  <font color="#3AC1EF">‚ñç Mesclando resultados do trabalho em equipe</font> </h3><br>  Voc√™ j√° viu <code>Dockerfile</code> contendo diretivas <code>RUN</code> muito longas, nas quais muitos comandos do shell s√£o combinados usando <code>&amp;&amp;</code> ?  Esta √© a fus√£o dos resultados das equipes. <br><br>  Usando esse m√©todo, criamos, com base nos resultados de uma √∫nica equipe longa, apenas uma camada.  Como n√£o haver√° camadas na imagem que contenham arquivos exclu√≠dos nas camadas a seguir, a imagem final n√£o incluir√° esses ‚Äúarquivos fantasmas‚Äù.  Considere isso como um exemplo, trazendo o <code>Dockerfile</code> acima para este estado: <br><br><pre> <code class="plaintext hljs">FROM alpine RUN wget http://xcal1.vodafone.co.uk/10MB.zip -P /tmp &amp;&amp; rm /tmp/10MB.zip</code> </pre> <br>  Depois disso, analisamos a imagem: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fbe/87f/a16/fbe87fa1633aec55d8fdcbe4d8d1014e.png"></div><br>  <i><font color="#999999">Mesclar equipes permitiu criar uma imagem 100% otimizada</font></i> <br><br>  A aplica√ß√£o desta t√©cnica para otimizar o tamanho das imagens na pr√°tica √© que, depois que voc√™ terminar de trabalhar no arquivo <code>Dockerfile</code> , precisar√° analis√°-la e descobrir se a mesclagem de comandos pode ser usada para reduzir a quantidade de espa√ßo desperdi√ßado. <br><br><h3>  <font color="#3AC1EF">‚ñçAplicando a op√ß√£o --squash</font> </h3><br>  Nos casos em que voc√™ usa <code>Dockerfile</code> outras pessoas que voc√™ n√£o deseja ou n√£o pode alterar, uma alternativa aos comandos de mesclagem pode ser a montagem de uma imagem usando a op√ß√£o <code>--squash</code> . <br><br>  As vers√µes modernas do Docker (come√ßando com 1.13) permitem reunir todas as camadas em uma camada, eliminando, assim, os "recursos fantasmas".  Nesse caso, voc√™ pode usar o <code>Dockerfile</code> original n√£o modificado, contendo muitos comandos separados.  Mas voc√™ precisa criar a imagem usando a op√ß√£o <code>--squash</code> : <br><br><pre> <code class="plaintext hljs">docker build --squash .</code> </pre> <br>  A imagem resultante tamb√©m √© 100% otimizada: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/923/10f/5fc/92310f5fc60ee677d39db75f3d0bac93.png"></div><br>  <i><font color="#999999">O uso da op√ß√£o --squash durante a montagem permitiu criar uma imagem 100% otimizada</font></i> <br><br>  Aqui voc√™ pode prestar aten√ß√£o a um detalhe interessante.  Ou seja, no <code>Dockerfile</code> uma camada foi criada para adicionar um arquivo e outra para excluir esse arquivo.  A op√ß√£o <code>--squash</code> √© inteligente o suficiente para entender que, nesse cen√°rio, voc√™ n√£o precisa criar camadas adicionais (na imagem final, h√° apenas <code>9ccd9‚Ä¶</code> camada <code>9ccd9‚Ä¶</code> partir da imagem base que usamos).  Em geral, para isso, podemos colocar <code>--squash</code> uma vantagem adicional.  √â verdade que, usando <code>--squash</code> , √© necess√°rio considerar que isso pode interferir no uso de camadas em cache. <br><br>  Como resultado, √© recomend√°vel levar em considera√ß√£o o fato de que, ao trabalhar com o <code>Dockerfile</code> outra pessoa que voc√™ n√£o gostaria de alterar, voc√™ pode minimizar a quantidade de espa√ßo de imagem usado irracionalmente coletando imagens usando a op√ß√£o <code>--squash</code> .  Para analisar a imagem final, voc√™ pode usar a ferramenta de <a href="https://github.com/wagoodman/dive">mergulho</a> . <br><br><h2>  <font color="#3AC1EF">Excluir caches e arquivos tempor√°rios</font> </h2><br>  Ao cont√™iner de aplicativos, muitas vezes surge uma situa√ß√£o em que voc√™ precisa colocar ferramentas, bibliotecas e utilit√°rios adicionais na imagem com eles.  Isso √© feito usando gerenciadores de pacotes como <code>apk</code> , <code>yum</code> , <code>apt</code> . <br><br>  Os gerentes de pacotes se esfor√ßam para economizar tempo do usu√°rio e n√£o carregar sua conex√£o de rede mais uma vez ao instalar pacotes.  Portanto, eles armazenam em cache os dados baixados.  Para que o tamanho da imagem final do Docker seja o menor poss√≠vel, n√£o precisamos armazenar caches do gerenciador de pacotes nessa imagem.  Afinal, se precisarmos de outra imagem, sempre podemos reconstru√≠-la usando o <code>Dockerfile</code> atualizado. <br><br>  Para remover os caches criados pelos tr√™s gerenciadores de pacotes populares mencionados acima, no final de um comando agregado (ou seja, aquele executado para criar uma camada), voc√™ pode adicionar o seguinte: <br><br><pre> <code class="plaintext hljs">APK: ... &amp;&amp; rm -rf /etc/apk/cache YUM: ... &amp;&amp; rm -rf /var/cache/yum APT: ... &amp;&amp; rm -rf /var/cache/apt</code> </pre> <br>  Como resultado, √© recomend√°vel que, antes de concluir o trabalho no <code>Dockerfile</code> adicione <code>Dockerfile</code> a ele que removem os caches dos gerenciadores de pacotes usados ‚Äã‚Äãpara construir a imagem.  O mesmo se aplica a arquivos tempor√°rios que n√£o afetam a opera√ß√£o correta do cont√™iner. <br><br><h2>  <font color="#3AC1EF">Escolha sua imagem de base com cuidado</font> </h2><br>  Cada <code>Dockerfile</code> come√ßa com uma diretiva <code>FROM</code> .  √â aqui que definimos a imagem b√°sica com base na qual nossa imagem ser√° criada. <br><br>  Aqui est√° o que a <a href="https://docs.docker.com/engine/reference/builder/">documenta√ß√£o</a> do Docker diz sobre o assunto: ‚ÄúA instru√ß√£o <code>FROM</code> inicializa uma nova fase de constru√ß√£o e configura a imagem base para as instru√ß√µes a seguir.  Como resultado, um <code>Dockerfile</code> adequadamente composto deve come√ßar com uma instru√ß√£o <code>FROM</code> .  Uma imagem pode ser qualquer imagem vi√°vel.  √â mais f√°cil come√ßar a montar sua pr√≥pria imagem, tendo como base uma imagem de um reposit√≥rio p√∫blico ". <br><br>  Obviamente, existem muitas imagens b√°sicas, cada uma com suas pr√≥prias caracter√≠sticas.  A sele√ß√£o correta de uma imagem b√°sica que cont√©m exatamente o que o aplicativo precisa, nem mais nem menos, tem um enorme impacto no tamanho da imagem final. <br><br>  Como voc√™ pode esperar, os tamanhos das imagens base populares variam tremendamente: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/847/e59/97c/847e5997cf00104e3b212874ee830243.png"></div><br>  <i><font color="#999999">Tamanhos de imagens populares b√°sicas do Docker</font></i> <br><br>  Portanto, a conteineriza√ß√£o do aplicativo usando a imagem base do <a href="https://hub.docker.com/layers/ubuntu/library/ubuntu/19.10/images/sha256-bceb2fb47400491f75a9056a3d4e219cbe5f9512d4220ca43f3f5cb3d08e9d04">Ubuntu 19.10</a> levar√° ao fato de que o tamanho da imagem, al√©m do tamanho do aplicativo, ser√£o adicionados outros 73 MB.  Se coletarmos a mesma imagem com base na imagem do <a href="https://hub.docker.com/layers/alpine/library/alpine/3.10.3/images/sha256-77cbe97593c890eb1c4cadcbca37809ebff2b5f46a036666866c99f08a708967">Alpine 3.10.3</a> , obteremos um "aditivo" apenas na quantidade de 6 MB.  Como o Docker armazena em cache as camadas da imagem, os recursos de rede s√£o gastos no carregamento de uma imagem somente quando o cont√™iner √© iniciado pela primeira vez da maneira apropriada (em outras palavras, quando a imagem √© carregada pela primeira vez).  Mas o tamanho da imagem em si n√£o fica menor com isso. <br><br>  Aqui voc√™ pode chegar √† seguinte conclus√£o (completamente l√≥gica): "Ent√£o - eu sempre usarei o Alpine!".  Mas, infelizmente, no mundo do desenvolvimento de software, nem tudo √© t√£o simples. <br><br>  Talvez os <a href="https://gitlab.alpinelinux.org/groups/alpine/-/activity">desenvolvedores do Alpine Linux</a> tenham descoberto algum ingrediente secreto que o Ubuntu ou o Debian ainda n√£o conseguem encontrar?  N√£o.  O fato √© que, para criar uma imagem do Docker, cujo tamanho √© uma ordem de magnitude menor que o tamanho da imagem do mesmo Debian, os desenvolvedores da Alpine tiveram que tomar algumas decis√µes sobre o que precisa ser inclu√≠do na imagem e o que n√£o √© necess√°rio.  Antes de chamar Alpine a imagem base que voc√™ sempre usar√°, pergunte se ela tem tudo o que voc√™ precisa.  Al√©m disso, mesmo que a Alpine tenha um gerenciador de pacotes, pode ser que o pacote espec√≠fico usado em seu ambiente de trabalho com base, por exemplo, no Ubuntu, n√£o esteja dispon√≠vel no Alpine.  Ou - n√£o um pacote, mas a vers√£o desejada do pacote.  Essas s√£o as compensa√ß√µes que voc√™ deve conhecer antes de escolher e testar a imagem b√°sica mais adequada ao seu projeto. <br><br>  E, finalmente, se voc√™ realmente precisa de uma das maiores imagens b√°sicas, pode usar a ferramenta para minimizar o tamanho da imagem.  Por exemplo - uma ferramenta gratuita de c√≥digo aberto <a href="https://dockersl.im/">DockerSlim</a> .  Isso reduzir√° o tamanho da imagem final. <br><br>  No final, podemos dizer que o uso de uma imagem b√°sica cuidadosamente selecionada √© extremamente importante na cria√ß√£o de suas pr√≥prias imagens compactas.  Avalie as necessidades do seu projeto e selecione uma imagem que contenha o que voc√™ precisa e, ao mesmo tempo, dimens√µes que s√£o aceit√°veis ‚Äã‚Äãpara voc√™. <br><br><h2>  <font color="#3AC1EF">Considere criar uma imagem que n√£o tenha uma imagem b√°sica.</font> </h2><br>  Se seu aplicativo puder ser executado sem um ambiente adicional fornecido de uma maneira b√°sica, voc√™ pode optar por n√£o usar uma imagem b√°sica.  Obviamente, como a instru√ß√£o <code>FROM</code> deve estar presente no <code>Dockerfile</code> , voc√™ n√£o pode prescindir dela.  Al√©m disso, ela deve apontar para algum tipo de imagem.  Que imagem usar em tal situa√ß√£o? <br><br>  Uma apar√™ncia do <a href="https://hub.docker.com/_/scratch">zero</a> pode ser √∫til aqui.  A partir da descri√ß√£o dele, voc√™ pode descobrir que ele foi especialmente vazio e projetado para criar imagens, se voc√™ falar o idioma do <code>Dockerfile</code> , do <code>FROM scratch</code> , ou seja, do zero.  Essa imagem √© especialmente √∫til ao criar imagens b√°sicas (como imagens debian e busybox) ou imagens extremamente m√≠nimas (aquelas que cont√™m um √∫nico arquivo bin√°rio e o que √© necess√°rio para sua opera√ß√£o, digamos ol√° mundo).  O uso desta imagem como base da imagem descrita pelo <code>Dockerfile</code> √© semelhante ao uso de uma "opera√ß√£o vazia" em algum programa.  A aplica√ß√£o de uma imagem de <code>scratch</code> n√£o criar√° uma camada adicional na imagem final. <br><br>  Como resultado, se o seu aplicativo for um execut√°vel independente que possa funcionar por si s√≥, a escolha da imagem inicial de base permitir√° minimizar o tamanho do cont√™iner. <br><br><h2>  <font color="#3AC1EF">Use compila√ß√µes de v√°rios est√°gios</font> </h2><br>  Constru√ß√µes em v√°rios est√°gios t√™m sido o foco de aten√ß√£o desde o Docker 05/17.  Era uma oportunidade aguardada h√° muito tempo.  Ele permite que os construtores de imagens abandonem seus pr√≥prios scripts para criar imagens e implementar tudo o que precisam usando o conhecido formato <code>Dockerfile</code> . <br><br>  Em termos gerais, um assembly de v√°rios est√°gios pode ser considerado como combina√ß√£o de v√°rios <code>Dockerfile</code> ou como um <code>Dockerfile</code> , que possui v√°rias instru√ß√µes <code>FROM</code> . <br><br>  Antes do surgimento de montagens de v√°rios est√°gios, se voc√™ precisasse criar uma montagem do seu projeto e distribu√≠-la em um cont√™iner usando o <code>Dockerfile</code> , provavelmente seria necess√°rio executar o processo de montagem, o que levaria √† apar√™ncia de um cont√™iner, como o mostrado abaixo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/060/270/1b9/0602701b97e37b957b0e77663b79faec.png"></div><br>  <i><font color="#999999">Construa e distribua um aplicativo sem usar a tecnologia de constru√ß√£o de v√°rios est√°gios</font></i> <br><br>  Embora, do ponto de vista t√©cnico, tudo tenha sido feito corretamente, a imagem final e o cont√™iner resultante s√£o preenchidos com camadas criadas no processo de prepara√ß√£o dos materiais do projeto.  E essas camadas n√£o s√£o necess√°rias para formar o ambiente de tempo de execu√ß√£o do projeto. <br><br>  As montagens de v√°rios est√°gios permitem separar as fases de cria√ß√£o e prepara√ß√£o dos materiais do projeto do ambiente em que o c√≥digo do projeto √© executado. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b30/938/c61/b30938c61707b5fb08866fac84df1c85.png"></div><br>  <i><font color="#999999">Montagem em v√°rias etapas, separa√ß√£o do processo de cria√ß√£o e prepara√ß√£o dos materiais do projeto do ambiente de execu√ß√£o</font></i> <br><br>  Ao mesmo tempo, um √∫nico <code>Dockerfile</code> suficiente para descrever o processo completo de cria√ß√£o do projeto.  Mas agora voc√™ pode copiar material de um est√°gio para outro e se livrar de dados desnecess√°rios. <br><br>  Assemblies de v√°rios est√°gios permitem criar assemblies de plataforma cruzada que podem ser usados ‚Äã‚Äãrepetidamente sem usar seus pr√≥prios scripts de assembly escritos para um sistema operacional espec√≠fico.  O tamanho final da imagem pode ser minimizado devido √† possibilidade de inclus√£o seletiva de materiais gerados nas etapas anteriores do processo de montagem da imagem. <br><br><h2>  <font color="#3AC1EF">Sum√°rio</font> </h2><br>  Criar imagens de cont√™iner do Docker √© um processo com o qual os programadores modernos geralmente precisam lidar.  Existem muitos recursos para criar <code>Dockerfile</code> e voc√™ pode encontrar muitos exemplos desses arquivos na Internet.  Mas n√£o importa o que voc√™ use, ao criar seu pr√≥prio <code>Dockerfile</code> sempre vale a pena considerar o tamanho das imagens resultantes. <br><br>  Aqui, vimos v√°rias t√©cnicas para minimizar o tamanho das imagens do Docker.  Aten√ß√£o ao conte√∫do do <code>Dockerfile</code> , incluindo apenas o que √© realmente necess√°rio, escolhendo a imagem base apropriada, usando a tecnologia de constru√ß√£o em v√°rios est√°gios - tudo isso pode ajudar a reduzir seriamente o tamanho das imagens do Docker que voc√™ cria. <br><br>  <b>PS</b> Lan√ßamos o <a href="https://ruvds.com/ru-rub/marketplace">mercado</a> no site da RUVDS.  No mercado, a imagem do <a href="https://ruvds.com/ru-rub/marketplace/docker">Docker</a> √© instalada em um clique. Voc√™ pode verificar como os cont√™ineres funcionam no <a href="https://ruvds.com/">VPS</a> . <a href="https://ruvds.com/">Tr√™s</a> dias para testes s√£o fornecidos gratuitamente a todos os novos clientes. <br><br>  <b>Caros leitores!</b>  Como voc√™ otimiza o tamanho das imagens do Docker? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt485650/">https://habr.com/ru/post/pt485650/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt485634/index.html">O painel Dungeons and Dragons me ajudou a aprender ingl√™s</a></li>
<li><a href="../pt485636/index.html">Os v√≠rus resistentes ao CRISPR constroem abrigos para proteger os genomas das enzimas que penetram no DNA</a></li>
<li><a href="../pt485640/index.html">M√©todos de oculta√ß√£o de p√°ginas da Web</a></li>
<li><a href="../pt485646/index.html">Dicas √∫teis sobre Python que voc√™ nunca conheceu antes. Parte 2</a></li>
<li><a href="../pt485648/index.html">A abordagem pit√¥nica para loops range () e enumerate ()</a></li>
<li><a href="../pt485652/index.html">Estat√≠sticas de coment√°rios em linha do Confluence</a></li>
<li><a href="../pt485654/index.html">Uma ideia tirada da f√≠sica ajuda a IA a trabalhar em dimens√µes mais altas.</a></li>
<li><a href="../pt485660/index.html">A pr√≥pria empresa de prote√ß√£o contra DDoS lan√ßou ataques DDoS, admitiu seu fundador</a></li>
<li><a href="../pt485664/index.html">Criando par√¢metros din√¢micos em um trabalho Jenkins ou como tornar sua tarefa f√°cil de usar</a></li>
<li><a href="../pt485672/index.html">Melhores pr√°ticas do Redis, parte 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>