<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍❤️‍💋‍👩 👦🏽 🌈 Técnicas de redução de imagem do Docker ✌🏻 🤾 👈🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Você já se perguntou por que o tamanho de um contêiner do Docker contendo apenas um aplicativo pode ter cerca de 400 MB? Ou talvez você estivesse preo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Técnicas de redução de imagem do Docker</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/485650/">  Você já se perguntou por que o tamanho de um contêiner do Docker contendo apenas um aplicativo pode ter cerca de 400 MB?  Ou talvez você estivesse preocupado com o tamanho bastante grande da imagem do Docker contendo um único binário de várias dezenas de MB de tamanho? <br><br> <a href="https://habr.com/ru/company/ruvds/blog/485650/"><img src="https://habrastorage.org/webt/ny/az/k8/nyazk8uqdkaog5lwtukn8qz1zpu.jpeg"></a> <br><br>  O autor do artigo, cuja tradução estamos publicando hoje, deseja analisar os principais fatores que afetam o tamanho dos contêineres do Docker.  Além disso, ele compartilhará recomendações sobre a redução do tamanho dos contêineres. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Camadas de imagem do Docker</font> </h2><br>  Uma imagem de um contêiner do Docker é essencialmente uma coleção de arquivos empilhados uns sobre os outros em várias camadas.  Um contêiner de trabalho é montado a partir desses arquivos.  O Docker usa o sistema de arquivos <a href="https://en.wikipedia.org/wiki/UnionFS">UnionFS</a> , no qual os arquivos são agrupados em camadas.  Uma camada pode conter um arquivo ou vários arquivos, camadas que se sobrepõem.  Durante a execução do contêiner, o conteúdo das camadas é combinado, como resultado, o usuário final do contêiner percebe os materiais "dispostos" em camadas como um único sistema de arquivos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a2/3ba/eea/0a23baeea85753e1a66d8399ff188b4c.png"></div><br>  <i><font color="#999999">Visualização simplificada do UnionFS</font></i> <br><br>  O sistema de arquivos resultante é apresentado ao usuário final usando algumas implementações do UnionFS (o Docker <a href="https://docs.docker.com/storage/storagedriver/select-storage-driver/">suporta</a> muitas implementações semelhantes por meio de drivers de armazenamento de plug-in).  O tamanho total dos arquivos recebidos pelo usuário final é igual à soma dos tamanhos dos arquivos nas camadas.  Quando o Docker cria um contêiner com base na imagem, ele usa todas as camadas somente leitura da imagem, adicionando uma camada fina sobre essas camadas que suporta leitura e gravação.  É essa camada que permite modificar arquivos em um contêiner em execução. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aaf/895/c00/aaf895c00a3353efa96934aeabd85f6f.png"></div><br>  <i><font color="#999999">O contêiner em execução contém uma camada de leitura e gravação localizada na parte superior das camadas de somente leitura</font></i> <br><br>  O que acontece se um arquivo for excluído na <code>Layer 4</code> contêiner apresentado esquematicamente acima?  Embora esse arquivo não esteja disponível no sistema de arquivos que o usuário vê, o tamanho desse arquivo ainda será um dos componentes do tamanho do contêiner, pois esse arquivo permanecerá em uma das camadas somente leitura. <br><br>  É muito simples começar a criar a imagem com um pequeno arquivo executável de aplicativo e obter uma imagem muito grande.  Abaixo, veremos vários métodos para tornar os contêineres o menor possível. <br><br><h2>  <font color="#3AC1EF">Preste atenção ao caminho para a pasta, com base nos materiais em que as imagens são coletadas</font> </h2><br>  Qual é a maneira mais comum de montar imagens do Docker?  Aparentemente - assim: <br><br><pre> <code class="plaintext hljs">docker build .</code> </pre> <br>  O ponto neste comando diz ao Docker que consideramos o diretório de trabalho atual como a raiz do sistema de arquivos usado no processo de montagem da imagem. <br><br>  Para entender melhor o que acontece depois que o comando acima é executado, vale lembrar que a criação de uma imagem do Docker é um processo cliente-servidor.  A interface da linha de comandos do Docker (cliente), à ​​qual fornecemos o <code>docker build</code> , usa o mecanismo do Docker (servidor) para criar a imagem do contêiner.  Para limitar o acesso ao sistema de arquivos base do cliente, o sistema de montagem de imagens precisa saber onde está localizada a raiz do sistema de arquivos virtual.  É aí que as instruções do arquivo <code>Dockerfile</code> pesquisam recursos de arquivo que eventualmente podem acabar na imagem que está sendo montada. <br><br>  Imagine um lugar onde um <code>Dockerfile</code> geralmente <code>Dockerfile</code> colocado.  Este é provavelmente o diretório raiz do projeto?  Se houver um <code>Dockerfile</code> na raiz do projeto, usado pelo <code>docker build</code> para criar a imagem, acontece que todos os arquivos do projeto podem entrar na imagem.  Isso pode levar ao fato de que milhares de arquivos indesejados, com muitos megabytes de tamanho, podem entrar no contexto do conjunto de imagens.  Se você usar levemente os comandos <code>ADD</code> e <code>COPY</code> no <code>Dockerfile</code> , todos os arquivos do projeto poderão se tornar parte da imagem final.  Na maioria das vezes, aqueles que coletam imagens não precisam disso, pois a imagem final geralmente deve incluir apenas alguns arquivos selecionados. <br><br>  Sempre verifique se o comando <code>docker build</code> caminho correto e se não há comandos no <code>Dockerfile</code> que adicionem arquivos desnecessários à imagem.  Se, por algum motivo, você precisar tornar o projeto raiz no contexto de construção, poderá incluir seletivamente arquivos nele e excluí-los usando <code>.dockerignore</code> . <br><br><h2>  <font color="#3AC1EF">Otimizar camadas de imagem</font> </h2><br>  O número máximo de camadas que uma imagem pode ter é 127 (dado o suporte para esse número de camadas usado pelo driver do armazém de dados).  Essa limitação, se absolutamente necessária, pode ser relaxada, mas com essa abordagem, a gama de sistemas nos quais essas imagens podem ser coletadas é reduzida.  O ponto é que o mecanismo do Docker deve ser executado em um sistema cujo kernel é modificado de acordo. <br><br>  Como mencionado na seção anterior, devido ao fato de o UnionFS ser usado na montagem de imagens, os arquivos que caem em uma determinada camada permanecem lá, mesmo que tenham sido excluídos das camadas subjacentes.  Vamos descobrir isso usando o Dockerfile experimental: <br><br><pre> <code class="plaintext hljs">FROM alpine RUN wget http://xcal1.vodafone.co.uk/10MB.zip -P /tmp RUN rm /tmp/10MB.zip</code> </pre> <br>  Vamos montar a imagem: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44b/d7c/e6d/44bd7ce6d60c71fd0856e96bd48ec5b7.png"></div><br>  <i><font color="#999999">Montagem de uma imagem experimental na qual existe espaço irracionalmente usado</font></i> <br><br>  Explore a imagem usando o <a href="https://github.com/wagoodman/dive">mergulho</a> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2da/e7f/1a5/2dae7f1a5875ece43a52042632a21401.png"></div><br>  <i><font color="#999999">O indicador de desempenho da imagem é de 34%</font></i> <br><br>  O indicador de eficiência de imagem de 34% indica que uma quantidade considerável de espaço na imagem é usada irracionalmente.  Isso leva a um aumento no tempo de inicialização da imagem, ao desperdício desnecessário de recursos de rede e a um tempo de início mais lento do contêiner. <br><br>  Como se livrar desse problema?  Vamos considerar várias opções. <br><br><h3>  <font color="#3AC1EF">▍ Mesclando resultados do trabalho em equipe</font> </h3><br>  Você já viu <code>Dockerfile</code> contendo diretivas <code>RUN</code> muito longas, nas quais muitos comandos do shell são combinados usando <code>&amp;&amp;</code> ?  Esta é a fusão dos resultados das equipes. <br><br>  Usando esse método, criamos, com base nos resultados de uma única equipe longa, apenas uma camada.  Como não haverá camadas na imagem que contenham arquivos excluídos nas camadas a seguir, a imagem final não incluirá esses “arquivos fantasmas”.  Considere isso como um exemplo, trazendo o <code>Dockerfile</code> acima para este estado: <br><br><pre> <code class="plaintext hljs">FROM alpine RUN wget http://xcal1.vodafone.co.uk/10MB.zip -P /tmp &amp;&amp; rm /tmp/10MB.zip</code> </pre> <br>  Depois disso, analisamos a imagem: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fbe/87f/a16/fbe87fa1633aec55d8fdcbe4d8d1014e.png"></div><br>  <i><font color="#999999">Mesclar equipes permitiu criar uma imagem 100% otimizada</font></i> <br><br>  A aplicação desta técnica para otimizar o tamanho das imagens na prática é que, depois que você terminar de trabalhar no arquivo <code>Dockerfile</code> , precisará analisá-la e descobrir se a mesclagem de comandos pode ser usada para reduzir a quantidade de espaço desperdiçado. <br><br><h3>  <font color="#3AC1EF">▍Aplicando a opção --squash</font> </h3><br>  Nos casos em que você usa <code>Dockerfile</code> outras pessoas que você não deseja ou não pode alterar, uma alternativa aos comandos de mesclagem pode ser a montagem de uma imagem usando a opção <code>--squash</code> . <br><br>  As versões modernas do Docker (começando com 1.13) permitem reunir todas as camadas em uma camada, eliminando, assim, os "recursos fantasmas".  Nesse caso, você pode usar o <code>Dockerfile</code> original não modificado, contendo muitos comandos separados.  Mas você precisa criar a imagem usando a opção <code>--squash</code> : <br><br><pre> <code class="plaintext hljs">docker build --squash .</code> </pre> <br>  A imagem resultante também é 100% otimizada: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/923/10f/5fc/92310f5fc60ee677d39db75f3d0bac93.png"></div><br>  <i><font color="#999999">O uso da opção --squash durante a montagem permitiu criar uma imagem 100% otimizada</font></i> <br><br>  Aqui você pode prestar atenção a um detalhe interessante.  Ou seja, no <code>Dockerfile</code> uma camada foi criada para adicionar um arquivo e outra para excluir esse arquivo.  A opção <code>--squash</code> é inteligente o suficiente para entender que, nesse cenário, você não precisa criar camadas adicionais (na imagem final, há apenas <code>9ccd9…</code> camada <code>9ccd9…</code> partir da imagem base que usamos).  Em geral, para isso, podemos colocar <code>--squash</code> uma vantagem adicional.  É verdade que, usando <code>--squash</code> , é necessário considerar que isso pode interferir no uso de camadas em cache. <br><br>  Como resultado, é recomendável levar em consideração o fato de que, ao trabalhar com o <code>Dockerfile</code> outra pessoa que você não gostaria de alterar, você pode minimizar a quantidade de espaço de imagem usado irracionalmente coletando imagens usando a opção <code>--squash</code> .  Para analisar a imagem final, você pode usar a ferramenta de <a href="https://github.com/wagoodman/dive">mergulho</a> . <br><br><h2>  <font color="#3AC1EF">Excluir caches e arquivos temporários</font> </h2><br>  Ao contêiner de aplicativos, muitas vezes surge uma situação em que você precisa colocar ferramentas, bibliotecas e utilitários adicionais na imagem com eles.  Isso é feito usando gerenciadores de pacotes como <code>apk</code> , <code>yum</code> , <code>apt</code> . <br><br>  Os gerentes de pacotes se esforçam para economizar tempo do usuário e não carregar sua conexão de rede mais uma vez ao instalar pacotes.  Portanto, eles armazenam em cache os dados baixados.  Para que o tamanho da imagem final do Docker seja o menor possível, não precisamos armazenar caches do gerenciador de pacotes nessa imagem.  Afinal, se precisarmos de outra imagem, sempre podemos reconstruí-la usando o <code>Dockerfile</code> atualizado. <br><br>  Para remover os caches criados pelos três gerenciadores de pacotes populares mencionados acima, no final de um comando agregado (ou seja, aquele executado para criar uma camada), você pode adicionar o seguinte: <br><br><pre> <code class="plaintext hljs">APK: ... &amp;&amp; rm -rf /etc/apk/cache YUM: ... &amp;&amp; rm -rf /var/cache/yum APT: ... &amp;&amp; rm -rf /var/cache/apt</code> </pre> <br>  Como resultado, é recomendável que, antes de concluir o trabalho no <code>Dockerfile</code> adicione <code>Dockerfile</code> a ele que removem os caches dos gerenciadores de pacotes usados ​​para construir a imagem.  O mesmo se aplica a arquivos temporários que não afetam a operação correta do contêiner. <br><br><h2>  <font color="#3AC1EF">Escolha sua imagem de base com cuidado</font> </h2><br>  Cada <code>Dockerfile</code> começa com uma diretiva <code>FROM</code> .  É aqui que definimos a imagem básica com base na qual nossa imagem será criada. <br><br>  Aqui está o que a <a href="https://docs.docker.com/engine/reference/builder/">documentação</a> do Docker diz sobre o assunto: “A instrução <code>FROM</code> inicializa uma nova fase de construção e configura a imagem base para as instruções a seguir.  Como resultado, um <code>Dockerfile</code> adequadamente composto deve começar com uma instrução <code>FROM</code> .  Uma imagem pode ser qualquer imagem viável.  É mais fácil começar a montar sua própria imagem, tendo como base uma imagem de um repositório público ". <br><br>  Obviamente, existem muitas imagens básicas, cada uma com suas próprias características.  A seleção correta de uma imagem básica que contém exatamente o que o aplicativo precisa, nem mais nem menos, tem um enorme impacto no tamanho da imagem final. <br><br>  Como você pode esperar, os tamanhos das imagens base populares variam tremendamente: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/847/e59/97c/847e5997cf00104e3b212874ee830243.png"></div><br>  <i><font color="#999999">Tamanhos de imagens populares básicas do Docker</font></i> <br><br>  Portanto, a conteinerização do aplicativo usando a imagem base do <a href="https://hub.docker.com/layers/ubuntu/library/ubuntu/19.10/images/sha256-bceb2fb47400491f75a9056a3d4e219cbe5f9512d4220ca43f3f5cb3d08e9d04">Ubuntu 19.10</a> levará ao fato de que o tamanho da imagem, além do tamanho do aplicativo, serão adicionados outros 73 MB.  Se coletarmos a mesma imagem com base na imagem do <a href="https://hub.docker.com/layers/alpine/library/alpine/3.10.3/images/sha256-77cbe97593c890eb1c4cadcbca37809ebff2b5f46a036666866c99f08a708967">Alpine 3.10.3</a> , obteremos um "aditivo" apenas na quantidade de 6 MB.  Como o Docker armazena em cache as camadas da imagem, os recursos de rede são gastos no carregamento de uma imagem somente quando o contêiner é iniciado pela primeira vez da maneira apropriada (em outras palavras, quando a imagem é carregada pela primeira vez).  Mas o tamanho da imagem em si não fica menor com isso. <br><br>  Aqui você pode chegar à seguinte conclusão (completamente lógica): "Então - eu sempre usarei o Alpine!".  Mas, infelizmente, no mundo do desenvolvimento de software, nem tudo é tão simples. <br><br>  Talvez os <a href="https://gitlab.alpinelinux.org/groups/alpine/-/activity">desenvolvedores do Alpine Linux</a> tenham descoberto algum ingrediente secreto que o Ubuntu ou o Debian ainda não conseguem encontrar?  Não.  O fato é que, para criar uma imagem do Docker, cujo tamanho é uma ordem de magnitude menor que o tamanho da imagem do mesmo Debian, os desenvolvedores da Alpine tiveram que tomar algumas decisões sobre o que precisa ser incluído na imagem e o que não é necessário.  Antes de chamar Alpine a imagem base que você sempre usará, pergunte se ela tem tudo o que você precisa.  Além disso, mesmo que a Alpine tenha um gerenciador de pacotes, pode ser que o pacote específico usado em seu ambiente de trabalho com base, por exemplo, no Ubuntu, não esteja disponível no Alpine.  Ou - não um pacote, mas a versão desejada do pacote.  Essas são as compensações que você deve conhecer antes de escolher e testar a imagem básica mais adequada ao seu projeto. <br><br>  E, finalmente, se você realmente precisa de uma das maiores imagens básicas, pode usar a ferramenta para minimizar o tamanho da imagem.  Por exemplo - uma ferramenta gratuita de código aberto <a href="https://dockersl.im/">DockerSlim</a> .  Isso reduzirá o tamanho da imagem final. <br><br>  No final, podemos dizer que o uso de uma imagem básica cuidadosamente selecionada é extremamente importante na criação de suas próprias imagens compactas.  Avalie as necessidades do seu projeto e selecione uma imagem que contenha o que você precisa e, ao mesmo tempo, dimensões que são aceitáveis ​​para você. <br><br><h2>  <font color="#3AC1EF">Considere criar uma imagem que não tenha uma imagem básica.</font> </h2><br>  Se seu aplicativo puder ser executado sem um ambiente adicional fornecido de uma maneira básica, você pode optar por não usar uma imagem básica.  Obviamente, como a instrução <code>FROM</code> deve estar presente no <code>Dockerfile</code> , você não pode prescindir dela.  Além disso, ela deve apontar para algum tipo de imagem.  Que imagem usar em tal situação? <br><br>  Uma aparência do <a href="https://hub.docker.com/_/scratch">zero</a> pode ser útil aqui.  A partir da descrição dele, você pode descobrir que ele foi especialmente vazio e projetado para criar imagens, se você falar o idioma do <code>Dockerfile</code> , do <code>FROM scratch</code> , ou seja, do zero.  Essa imagem é especialmente útil ao criar imagens básicas (como imagens debian e busybox) ou imagens extremamente mínimas (aquelas que contêm um único arquivo binário e o que é necessário para sua operação, digamos olá mundo).  O uso desta imagem como base da imagem descrita pelo <code>Dockerfile</code> é semelhante ao uso de uma "operação vazia" em algum programa.  A aplicação de uma imagem de <code>scratch</code> não criará uma camada adicional na imagem final. <br><br>  Como resultado, se o seu aplicativo for um executável independente que possa funcionar por si só, a escolha da imagem inicial de base permitirá minimizar o tamanho do contêiner. <br><br><h2>  <font color="#3AC1EF">Use compilações de vários estágios</font> </h2><br>  Construções em vários estágios têm sido o foco de atenção desde o Docker 05/17.  Era uma oportunidade aguardada há muito tempo.  Ele permite que os construtores de imagens abandonem seus próprios scripts para criar imagens e implementar tudo o que precisam usando o conhecido formato <code>Dockerfile</code> . <br><br>  Em termos gerais, um assembly de vários estágios pode ser considerado como combinação de vários <code>Dockerfile</code> ou como um <code>Dockerfile</code> , que possui várias instruções <code>FROM</code> . <br><br>  Antes do surgimento de montagens de vários estágios, se você precisasse criar uma montagem do seu projeto e distribuí-la em um contêiner usando o <code>Dockerfile</code> , provavelmente seria necessário executar o processo de montagem, o que levaria à aparência de um contêiner, como o mostrado abaixo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/060/270/1b9/0602701b97e37b957b0e77663b79faec.png"></div><br>  <i><font color="#999999">Construa e distribua um aplicativo sem usar a tecnologia de construção de vários estágios</font></i> <br><br>  Embora, do ponto de vista técnico, tudo tenha sido feito corretamente, a imagem final e o contêiner resultante são preenchidos com camadas criadas no processo de preparação dos materiais do projeto.  E essas camadas não são necessárias para formar o ambiente de tempo de execução do projeto. <br><br>  As montagens de vários estágios permitem separar as fases de criação e preparação dos materiais do projeto do ambiente em que o código do projeto é executado. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b30/938/c61/b30938c61707b5fb08866fac84df1c85.png"></div><br>  <i><font color="#999999">Montagem em várias etapas, separação do processo de criação e preparação dos materiais do projeto do ambiente de execução</font></i> <br><br>  Ao mesmo tempo, um único <code>Dockerfile</code> suficiente para descrever o processo completo de criação do projeto.  Mas agora você pode copiar material de um estágio para outro e se livrar de dados desnecessários. <br><br>  Assemblies de vários estágios permitem criar assemblies de plataforma cruzada que podem ser usados ​​repetidamente sem usar seus próprios scripts de assembly escritos para um sistema operacional específico.  O tamanho final da imagem pode ser minimizado devido à possibilidade de inclusão seletiva de materiais gerados nas etapas anteriores do processo de montagem da imagem. <br><br><h2>  <font color="#3AC1EF">Sumário</font> </h2><br>  Criar imagens de contêiner do Docker é um processo com o qual os programadores modernos geralmente precisam lidar.  Existem muitos recursos para criar <code>Dockerfile</code> e você pode encontrar muitos exemplos desses arquivos na Internet.  Mas não importa o que você use, ao criar seu próprio <code>Dockerfile</code> sempre vale a pena considerar o tamanho das imagens resultantes. <br><br>  Aqui, vimos várias técnicas para minimizar o tamanho das imagens do Docker.  Atenção ao conteúdo do <code>Dockerfile</code> , incluindo apenas o que é realmente necessário, escolhendo a imagem base apropriada, usando a tecnologia de construção em vários estágios - tudo isso pode ajudar a reduzir seriamente o tamanho das imagens do Docker que você cria. <br><br>  <b>PS</b> Lançamos o <a href="https://ruvds.com/ru-rub/marketplace">mercado</a> no site da RUVDS.  No mercado, a imagem do <a href="https://ruvds.com/ru-rub/marketplace/docker">Docker</a> é instalada em um clique. Você pode verificar como os contêineres funcionam no <a href="https://ruvds.com/">VPS</a> . <a href="https://ruvds.com/">Três</a> dias para testes são fornecidos gratuitamente a todos os novos clientes. <br><br>  <b>Caros leitores!</b>  Como você otimiza o tamanho das imagens do Docker? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt485650/">https://habr.com/ru/post/pt485650/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt485634/index.html">O painel Dungeons and Dragons me ajudou a aprender inglês</a></li>
<li><a href="../pt485636/index.html">Os vírus resistentes ao CRISPR constroem abrigos para proteger os genomas das enzimas que penetram no DNA</a></li>
<li><a href="../pt485640/index.html">Métodos de ocultação de páginas da Web</a></li>
<li><a href="../pt485646/index.html">Dicas úteis sobre Python que você nunca conheceu antes. Parte 2</a></li>
<li><a href="../pt485648/index.html">A abordagem pitônica para loops range () e enumerate ()</a></li>
<li><a href="../pt485652/index.html">Estatísticas de comentários em linha do Confluence</a></li>
<li><a href="../pt485654/index.html">Uma ideia tirada da física ajuda a IA a trabalhar em dimensões mais altas.</a></li>
<li><a href="../pt485660/index.html">A própria empresa de proteção contra DDoS lançou ataques DDoS, admitiu seu fundador</a></li>
<li><a href="../pt485664/index.html">Criando parâmetros dinâmicos em um trabalho Jenkins ou como tornar sua tarefa fácil de usar</a></li>
<li><a href="../pt485672/index.html">Melhores práticas do Redis, parte 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>