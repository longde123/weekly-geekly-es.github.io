<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤬 👨🏾‍🤝‍👨🏻 🕳️ Shaders de jeu 3D pour débutants: Effets 👩‍❤️‍👩 🐴 👨🏽‍🔧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[ La première partie ] 

 Après avoir traité des bases, dans cette partie de l'article, nous mettons en œuvre des effets tels que les contours des obj...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Shaders de jeu 3D pour débutants: Effets</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453692/">  [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La première partie</a> ] <br><br>  Après avoir traité des bases, dans cette partie de l'article, nous mettons en œuvre des effets tels que les contours des objets, la floraison, le SSAO, le flou, la profondeur de champ, la pixellisation, etc. <br><br><h2>  Contours </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b8/96f/9b2/3b896f9b246e1695fa908b4bdc145480.gif"></div><br>  La création de contours autour de la géométrie de la scène donne au jeu un aspect unique qui ressemble à des bandes dessinées ou des dessins animés. <br><br><h3>  Matériau diffus </h3><br>  Le shader de contour a besoin d'une texture d'entrée pour reconnaître et colorer les bords.  Les candidats à une telle texture entrante peuvent être une couleur diffuse à partir de matériaux, des couleurs à partir de textures diffuses, des normales de vertex ou même des couleurs à partir de cartes normales. <br><br><pre><code class="cpp hljs">uniform <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> vec4 diffuse ; } p3d_Material; out vec4 fragColor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ vec3 diffuseColor = p3d_Material.diffuse.rgb; fragColor = vec4(diffuseColor, <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br>  Il s'agit d'un petit ombrage de fragment qui rend la couleur diffuse d'un matériau géométrique en une texture de tampon de trame.  Cette texture de couleur diffuse provenant du tampon de trame sera la texture d'entrée du shader de chemin. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f0b/abd/05c/f0babd05caf7104156c15929995c9279.gif"></div><br>  Il s'agit de la texture de la couleur diffuse du matériau provenant du tampon d'image, qui affiche les couleurs que nous avons définies dans Blender.  Le shader contour reconnaîtra les bords de la scène et les coloriera. <br><br>  Il convient de noter que la couleur diffuse des matériaux ne fonctionnera pas si certaines parties de la scène n'ont pas leur propre couleur diffuse du matériau. <br><br><h3>  Création d'arêtes </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33a/a0d/57a/33aa0d57aeba90366ddd95865ea0d6c6.gif"></div><br>  La création d'arêtes est similaire à l'utilisation de filtres de reconnaissance d'arêtes dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GIMP</a> . <br><br>  Tous les calculs pour cette technique d'ombrage sont effectués dans un fragment shader.  Pour créer des contours pour le vertex shader, il suffit de passer quatre sommets du maillage rectangulaire à la sortie pour s'adapter à l'écran. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform sampler2D materialDiffuseTexture; // ... vec2 texSize = textureSize(materialDiffuseTexture, 0).xy; vec2 texCoord = gl_FragCoord.xy; // ...</span></span></code> </pre> <br>  Avant de commencer à reconnaître les bords, vous devez préparer la texture entrante, avec laquelle nous travaillerons.  Puisque la texture a une taille d'écran, nous pouvons calculer les coordonnées UV, connaissant les coordonnées du fragment et la taille de la texture entrante. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... int separation = 1; // ...</span></span></code> </pre> <br>  <code>separation</code> peut être personnalisée selon vos goûts.  Plus la séparation est grande, plus les bords ou les lignes sont épais. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float threshold = 0; // ... vec4 mx = vec4(0); vec4 mn = vec4(1); int x = -1; int y = -1; for (int i = 0; i &lt; 9; ++i) { vec4 color = texture ( materialDiffuseTexture , (texCoord + (vec2(x, y) * separation)) / texSize ); mx = max(color, mx); mn = min(color, mn); x += 1; if (x &gt;= 2) { x = -1; y += 1; } } float alpha = ((mx.r + mx.g + mx.b) / 3) - ((mn.r + mn.g + mn.b) / 3); if (alpha &gt; threshold) { alpha = 1; } // ...</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/42f/d24/e56/42fd24e5682700e1e7cd5186bebc33af.gif"></div><br>  La technique de reconnaissance des bords trouve des changements dans les couleurs de la texture entrante.  En se concentrant sur le fragment actuel, il utilise la fenêtre de fragments 3x3 pour trouver les couleurs les plus claires et les plus sombres des neuf échantillons.  Ensuite, elle soustrait de la luminosité d'une couleur la luminosité d'une autre, obtenant leur différence. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 lineRgb = vec3(0.012, 0.014, 0.022); // ... vec4 lineColor = vec4(lineRgb, alpha); // ... fragColor = lineColor; // ...</span></span></code> </pre> <br>  Cette différence est utilisée dans le canal alpha de la couleur de sortie.  S'il n'y a pas de différence, le bord ou la ligne n'est pas tracé.  S'il y a une différence, le bord est tracé. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float threshold = 0; // ... if (alpha &gt; threshold) { alpha = 1; } // ...</span></span></code> </pre> <br>  Essayez de tester la valeur seuil.  Maintenant, c'est zéro.  Toute valeur différente de zéro devient un bord; ce seuil peut être modifié.  Ceci est particulièrement utile pour les textures entrantes plus bruyantes avec de petites différences.  Dans le cas d'une texture entrante bruyante, vous devez généralement créer des contours uniquement pour les grandes différences. <br><br><h3>  Code source </h3><br><ul><li>  <a href="">main.cxx</a> </li><li>  <a href="">base.vert</a> </li><li>  <a href="">basic.vert</a> </li><li>  <a href="">material-diffuse.frag</a> </li><li>  <a href="">contour.frag</a> </li></ul><br><h2>  Brouillard </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5af/02c/e52/5af02ce52f813b27461f79e5dca5fe20.gif"></div><br>  Le brouillard (ou brume, comme on l'appelle dans Blender) ajoute une brume atmosphérique à la scène, créant de mystérieuses parties saillantes ramollies.  Les parties saillantes apparaissent lorsqu'une géométrie tombe soudainement dans la pyramide de visibilité de la caméra. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform struct p3d_FogParameters { vec4 color ; float start ; float end ; } p3d_Fog; // ...</span></span></code> </pre> <br>  Panda3D a une structure de données pratique qui contient tous les paramètres de brouillard, mais vous pouvez les transférer manuellement vers votre shader. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float fogIntensity = clamp ( ( p3d_Fog.end - vertexPosition.y) / ( p3d_Fog.end - p3d_Fog.start) , 0 , 1 ); fogIntensity = 1 - fogIntensity; // ...</span></span></code> </pre> <br>  Dans l'exemple de code, un modèle linéaire est utilisé pour calculer la luminosité du brouillard lorsque vous vous éloignez de la caméra.  Au lieu de cela, vous pouvez utiliser le modèle exponentiel.  La luminosité du brouillard est nulle avant ou au début du brouillard.  Lorsque la position du sommet approche de la fin du brouillard, <code>fogIntensity</code> rapproche de l'unité.  Pour tous les sommets après la fin du brouillard, <code>fogIntensity</code> limité à 1 à partir du dessus. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... fragColor = mix ( outputColor , p3d_Fog.color , fogIntensity ); // ...</span></span></code> </pre> <br>  En fonction de la luminosité du brouillard, nous mélangeons la couleur du brouillard avec la couleur de sortie.  À <code>fogIntensity</code> que <code>fogIntensity</code> approche l'unité, il y aura de moins en moins <code>outputColor</code> et de plus en plus de couleur de brouillard.  Lorsque <code>fogIntensity</code> atteint l'unité, seule la couleur du brouillard restera. <br><br><h3>  Brouillard sur les contours </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1f/ee8/d49/e1fee8d490abe10ecb798df618f183f7.gif"></div><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform sampler2D positionTexture; // ... vec4 position = texture(positionTexture, texCoord / texSize); float fogIntensity = clamp ( ( p3d_Fog.end - position.y) / ( p3d_Fog.end - p3d_Fog.start) , 0 , 1 ); fogIntensity = 1 - fogIntensity; vec4 lineWithFogColor = mix ( lineColor , p3d_Fog.color , fogIntensity ); fragColor = vec4(lineWithFogColor.rgb, alpha); // ...</span></span></code> </pre> <br>  Le Path Shader applique du brouillard aux couleurs des bords pour une image plus holistique.  S'il ne le faisait pas, la géométrie des contours serait obscurcie par le brouillard, ce qui serait étrange.  Cependant, il crée toujours des contours sur les bords les plus externes de la géométrie de la scène avec le fraisage, car les bords dépassent la géométrie - là où il n'y a pas de positions de sommet. <br><br>  <code>positionTexture</code> est une texture de tampon d'image qui contient les positions des sommets de l'espace de vue.  Vous en saurez plus lorsque nous implémenterons le shader SSAO. <br><br><h3>  Code source </h3><br><ul><li>  <a href="">main.cxx</a> </li><li>  <a href="">base.vert</a> </li><li>  <a href="">basic.vert</a> </li><li>  <a href="">base.frag</a> </li><li>  <a href="">contour.frag</a> </li></ul><br><h2>  Bloom </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31d/744/f35/31d744f35168ac87f609474998802b12.gif"></div><br>  Ajouter de la floraison à la scène peut créer une illusion convaincante du modèle d'éclairage.  Les objets émetteurs de lumière deviennent plus convaincants et les reflets lumineux reçoivent une quantité supplémentaire de rayonnement. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//... float separation = 3; int samples = 15; float threshold = 0.5; float amount = 1; // ...</span></span></code> </pre> <br>  Vous pouvez personnaliser ces paramètres à votre guise.  La séparation augmente la taille du flou.  Les échantillons déterminent la force du flou.  Le seuil détermine ce qui sera et ne sera pas affecté par cet effet.  La quantité contrôle la quantité de floraison produite. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... int size = samples; int size2 = size * size; int x = 0; int y = 0; // ... float value = 0; vec4 result = vec4(0); vec4 color = vec4(0); // ... for (int i = 0; i &lt; size2; ++i) { // ... } // ...</span></span></code> </pre> <br>  Cette technique commence par passer des <code>samples</code> taille d'une fenêtre sur des <code>samples</code> centrés par rapport au fragment actuel.  Il ressemble à une fenêtre utilisée pour créer des chemins. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... color = texture ( bloomTexture , ( gl_FragCoord.xy + vec2(x * separation, y * separation) ) / texSize ); value = ((0.3 * color.r) + (0.59 * color.g) + (0.11 * color.b)); if (value &lt; threshold) { color = vec4(0); } result += color; // ...</span></span></code> </pre> <br>  Ce code obtient la couleur de la texture entrante et transforme les valeurs du rouge, du vert et du bleu en une valeur en niveaux de gris.  Si la valeur en niveaux de gris est inférieure au seuil, elle rejette cette couleur, la rendant noire. <br><br>  En passant par tous les échantillons dans la fenêtre, il accumule toutes leurs valeurs en <code>result</code> . <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... result = result / size2; // ...</span></span></code> </pre> <br>  Ayant terminé la collecte des échantillons, il divise la somme des échantillons de couleur par le nombre d'échantillons prélevés.  Le résultat est la couleur médiane du fragment lui-même et de ses voisins.  Ce faisant, pour chaque fragment, nous obtenons une image floue.  Ce type de flou est appelé flou de boîte. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f90/16f/ea4/f9016fea492bc7b136ef6437a683c937.gif"></div><br>  Vous voyez ici le processus d'exécution de l'algorithme de floraison. <br><br><h3>  Code source </h3><br><ul><li>  <a href="">main.cxx</a> </li><li>  <a href="">basic.vert</a> </li><li>  <a href="">bloom.frag</a> </li></ul><br><h2>  Screen Space Ambient Occlusion (SSAO) </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f93/5ab/5bf/f935ab5bf4794caae3be90b611ad771c.gif"></div><br>  SSAO est l'un de ces effets que vous ne connaissez pas, mais dès que vous savez que vous ne pouvez plus vivre sans eux.  Il peut transformer une scène médiocre en une scène incroyable!  Dans les scènes statiques, l'occlusion ambiante peut être intégrée dans la texture, mais pour les scènes plus dynamiques, nous avons besoin d'un shader.  SSAO est l'une des techniques d'ombrage les plus sophistiquées, mais une fois que vous l'aurez compris, vous deviendrez un maître shader. <br><br>  Notez que le terme «espace d'écran» dans le titre n'est pas entièrement correct, car tous les calculs ne sont pas effectués dans l'espace d'écran. <br><br><h3>  Données entrantes </h3><br>  Le shader SSAO aura besoin de l'entrée suivante. <br><br><ul><li>  Vecteurs de positions des sommets dans l'espace d'observation. </li><li>  Vecteurs normaux aux sommets de l'espace de visualisation. </li><li>  Exemples de vecteurs dans l'espace tangent. </li><li>  Vecteurs de bruit dans l'espace tangent. </li><li>  La matrice de projection sur l'objectif de la caméra. </li></ul><br><h3>  Poste </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d2/f36/d42/2d2f36d425c2596288d8982158687354.png"></div><br>  Il n'est pas nécessaire de stocker les positions des sommets dans la texture du tampon de trame.  Nous pouvons les recréer à partir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">du tampon de profondeur</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">la caméra</a> .  J'écris un guide pour les débutants, nous n'utiliserons donc pas cette optimisation et nous nous mettrons immédiatement au travail.  Dans votre implémentation, vous pouvez facilement utiliser le tampon de profondeur. <br><br><pre> <code class="cpp hljs">PT(Texture) depthTexture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture(<span class="hljs-string"><span class="hljs-string">"depthTexture"</span></span>); depthTexture-&gt;set_format(Texture::Format::F_depth_component32); PT(GraphicsOutput) depthBuffer = graphicsOutput-&gt;make_texture_buffer(<span class="hljs-string"><span class="hljs-string">"depthBuffer"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, depthTexture); depthBuffer-&gt;set_clear_color(LVecBase4f(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); NodePath depthCameraNP = window-&gt;make_camera(); DCAST(Camera, depthCameraNP.node())-&gt;set_lens(window-&gt;get_camera(<span class="hljs-number"><span class="hljs-number">0</span></span>)-&gt;get_lens()); PT(DisplayRegion) depthBufferRegion = depthBuffer-&gt;make_display_region(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); depthBufferRegion-&gt;set_camera(depthCameraNP);</code> </pre> <br>  Si vous décidez d'utiliser le tampon de profondeur, voici comment vous pouvez le configurer dans Panda3D. <br><br><pre> <code class="cpp hljs">in vec4 vertexPosition; out vec4 fragColor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ fragColor = vertexPosition; }</code> </pre> <br>  Voici un shader simple pour rendre les positions des sommets dans l'espace de visualisation dans une texture de tampon de trame.  Une tâche plus difficile consiste à ajuster la texture du tampon de trame de sorte que les composants du vecteur fragment obtenu par celui-ci ne soient pas limités à l'intervalle <code>[0, 1]</code> , et que chacun ait une précision suffisamment élevée (un nombre suffisamment important de bits).  Par exemple, si une sorte de position de sommet interpolée est <code>&lt;-139.444444566, 0.00000034343, 2.5&gt;</code> , vous ne pouvez pas l'enregistrer dans la texture en tant que <code>&lt;0.0, 0.0, 1.0&gt;</code> . <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... FrameBufferProperties fbp = FrameBufferProperties::get_default(); // ... fbp.set_rgba_bits(32, 32, 32, 32); fbp.set_rgb_color(true); fbp.set_float_color(true); // ...</span></span></code> </pre> <br>  Voici un exemple de code qui prépare une texture de tampon de trame pour stocker les positions des sommets.  Il a besoin de 32 bits pour le rouge, le vert, le bleu et l'alpha, il désactive donc la restriction des valeurs par l'intervalle <code>[0, 1]</code> .  L'appel à <code>set_rgba_bits(32, 32, 32, 32)</code> définit le volume binaire et désactive la restriction. <br><br><pre> <code class="cpp hljs"> glTexImage2D ( GL_TEXTURE_2D , <span class="hljs-number"><span class="hljs-number">0</span></span> , GL_RGB32F , <span class="hljs-number"><span class="hljs-number">1200</span></span> , <span class="hljs-number"><span class="hljs-number">900</span></span> , <span class="hljs-number"><span class="hljs-number">0</span></span> , GL_RGB , GL_FLOAT , <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> );</code> </pre> <br>  Voici un appel similaire sur OpenGL.  <code>GL_RGB32F</code> définit les bits et désactive la restriction. <br><br><blockquote>  Si le tampon de couleur a une virgule fixe, les composants des valeurs initiale et finale, ainsi que les indices de mélange, avant de calculer l'équation de mélange sont limités à [0, 1] ou [-1, 1], respectivement, pour les tampons de couleur normalisés non signés normalisés et signés.  Si le tampon de couleur a une virgule flottante, la restriction n'est pas respectée. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Source</a> </blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/17b/2d0/2ad/17b2d02ad53c411dc251d90fdc16fdf3.png"></div><br>  Ici vous voyez les positions des sommets;  l'axe y est vers le haut. <br><br>  N'oubliez pas que Panda3D définit l'axe z comme un vecteur pointant vers le haut, tandis que dans OpenGL, l'axe y recherche.  Le shader de position affiche les positions des sommets avec un z vers le haut, car dans Panda3D <br>  le paramètre <code>gl-coordinate-system default</code> est configuré. <br><br><h3>  Normal </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c4/064/9c5/0c40649c525edd7bcf3c829d6e948789.gif"></div><br>  Pour l'orientation correcte des échantillons obtenus dans le shader SSAO, nous avons besoin des normales aux sommets.  L'exemple de code génère plusieurs vecteurs d'échantillonnage répartis sur l'hémisphère, mais vous pouvez utiliser la sphère et résoudre complètement le problème du besoin de normales. <br><br><pre> <code class="cpp hljs">in vec3 vertexNormal; out vec4 fragColor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ vec3 normal = normalize(vertexNormal); fragColor = vec4(normal, <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br>  Comme le shader de position, le shader normal est très simple.  N'oubliez pas de normaliser les normales aux sommets et n'oubliez pas qu'elles sont dans l'espace de visualisation. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/57b/a82/f00/57ba82f003b0ab9c2aafa7c9affa28bb.gif"></div><br>  Les normales aux sommets sont montrées ici;  l'axe y est vers le haut. <br><br>  Rappelons que Panda3D considère l'axe z comme le vecteur ascendant et OpenGL vers l'axe y.  Le shader normal affiche les positions des sommets avec l'axe z pointant vers le haut, car le <code>gl-coordinate-system default</code> configuré dans Panda3D. <br><br><h3>  Échantillons </h3><br>  Pour déterminer la valeur d'occlusion ambiante pour tout fragment unique, nous devons échantillonner la zone environnante. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... for (int i = 0; i &lt; numberOfSamples; ++i) { LVecBase3f sample = LVecBase3f ( randomFloats(generator) * 2.0 - 1.0 , randomFloats(generator) * 2.0 - 1.0 , randomFloats(generator) ).normalized(); float rand = randomFloats(generator); sample[0] *= rand; sample[1] *= rand; sample[2] *= rand; float scale = (float) i / (float) numberOfSamples; scale = lerp(0.1, 1.0, scale * scale); sample[0] *= scale; sample[1] *= scale; sample[2] *= scale; ssaoSamples.push_back(sample); } // ...</span></span></code> </pre> <br>  L'exemple de code génère 64 échantillons aléatoires répartis dans un hémisphère.  Ces <code>ssaoSamples</code> seront passés au shader SSAO. <br><br><pre> <code class="cpp hljs"> LVecBase3f sample = LVecBase3f ( randomFloats(generator) * <span class="hljs-number"><span class="hljs-number">2.0</span></span> - <span class="hljs-number"><span class="hljs-number">1.0</span></span> , randomFloats(generator) * <span class="hljs-number"><span class="hljs-number">2.0</span></span> - <span class="hljs-number"><span class="hljs-number">1.0</span></span> , randomFloats(generator) * <span class="hljs-number"><span class="hljs-number">2.0</span></span> - <span class="hljs-number"><span class="hljs-number">1.0</span></span> ).normalized();</code> </pre> <br>  Si vous souhaitez répartir vos échantillons sur une sphère, modifiez alors l'intervalle de la composante aléatoire z pour qu'il passe de moins un à un. <br><br><h3>  Le bruit </h3><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... for (int i = 0; i &lt; 16; ++i) { LVecBase3f noise = LVecBase3f ( randomFloats(generator) * 2.0 - 1.0 , randomFloats(generator) * 2.0 - 1.0 , 0.0 ); ssaoNoise.push_back(noise); } // ...</span></span></code> </pre> <br>  Afin de bien couvrir la zone échantillonnée, nous devons générer des vecteurs de bruit.  Ces vecteurs de bruit peuvent faire tourner des échantillons autour du haut de la surface. <br><br><h3>  Occlusion ambiante </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d35/c1d/bb4/d35c1dbb4e0e9dfeedc3bd4285f26004.gif"></div><br>  SSAO accomplit sa tâche en échantillonnant l'espace d'observation autour du fragment.  Plus il y a d'échantillons sous la surface, plus la couleur du fragment est foncée.  Ces échantillons sont situés dans le fragment et indiquent dans la direction générale de la normale au sommet.  Chaque échantillon est utilisé pour rechercher une position dans la texture de la position du tampon de trame.  La position retournée est comparée à l'échantillon.  Si l'échantillon est plus éloigné de la caméra que la position, alors l'échantillon vers le fragment est occlus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb7/b9a/f1d/cb7b9af1d4dc613f337da5a253ef5a8c.gif"></div><br>  Ici, vous voyez un espace au-dessus de la surface échantillonnée pour l'occlusion. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float radius = 1.1; float bias = 0.026; float lowerRange = -2; float upperRange = 2; // ...</span></span></code> </pre> <br>  Comme certaines autres techniques, le shader SSAO a plusieurs paramètres de contrôle qui peuvent être modifiés pour obtenir l'apparence souhaitée.  un biais est ajouté à la distance entre l'échantillon et la caméra.  Ce paramètre peut être utilisé pour lutter contre les taches.  Le rayon augmente ou diminue la zone de couverture de l'espace échantillon.  lowerRange et upperRange modifient la plage standard de la métrique de facteur de <code>[0, 1]</code> à n'importe quelle valeur que vous sélectionnez.  En augmentant la plage, vous pouvez augmenter le contraste. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 position = texture(positionTexture, texCoord); vec3 normal = texture(normalTexture, texCoord).xyz; int noiseX = int(gl_FragCoord.x - 0.5) % 4; int noiseY = int(gl_FragCoord.y - 0.5) % 4; vec3 random = noise[noiseX + (noiseY * 4)]; // ...</span></span></code> </pre> <br>  Nous obtenons la position, le vecteur normal et aléatoire pour une utilisation ultérieure.  Rappelons que dans l'exemple de code, 16 vecteurs aléatoires ont été créés.  Un vecteur aléatoire est sélectionné en fonction de la position à l'écran des fragments actuels. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 tangent = normalize(random - normal * dot(random, normal)); vec3 binormal = cross(normal, tangent); mat3 tbn = mat3(tangent, binormal, normal); // ...</span></span></code> </pre> <br>  En utilisant un vecteur aléatoire et un vecteur normal, nous collectons la matrice de la tangente, binormale et normale.  Nous avons besoin de cette matrice pour transformer les vecteurs échantillons de l'espace tangent à l'espace d'enquête. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float occlusion = NUM_SAMPLES; for (int i = 0; i &lt; NUM_SAMPLES; ++i) { // ... } // ...</span></span></code> </pre> <br>  Ayant une matrice, le shader peut parcourir tous les échantillons de la boucle, en soustrayant le nombre de non ouverts. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 sample = tbn * samples[i]; sample = position.xyz + sample * radius; // ...</span></span></code> </pre> <br>  À l'aide de la matrice, placez l'échantillon à côté de la position du sommet / fragment et mettez-le à l'échelle par le rayon. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 offset = vec4(sample, 1.0); offset = lensProjection * offset; offset.xyz /= offset.w; offset.xyz = offset.xyz * 0.5 + 0.5; // ...</span></span></code> </pre> <br>  En utilisant la position de l'échantillon dans l'espace d'observation, nous le transformons de l'espace d'observation à l'espace d'écrêtage, puis à l'espace UV. <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">-1</span></span> * <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> * <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  N'oubliez pas que les composants de l'espace d'écrêtage sont compris entre moins un et un, et que les coordonnées UV sont comprises entre zéro et un.  Pour convertir les coordonnées de l'espace d'écrêtage en coordonnées UV, multipliez-les par une seconde et ajoutez une seconde. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 offsetPosition = texture(positionTexture, offset.xy); float occluded = 0; if (sample.y + bias &lt;= offsetPosition.y) { occluded = 0; } else { occluded = 1; } // ...</span></span></code> </pre> <br>  En utilisant les coordonnées de décalage UV obtenues en projetant l'échantillon 3D sur la texture de position 2D, nous trouvons le vecteur de position correspondant.  Cela nous amène de l'espace de visualisation à l'espace de détourage à l'espace UV, puis de retour à l'espace de visualisation.  Le shader exécute cette boucle pour déterminer s'il existe une géométrie derrière l'échantillon, à l'emplacement de l'échantillon ou devant l'échantillon.  Si l'échantillon est situé devant ou dans une certaine géométrie, cet échantillon n'est tout simplement pas pris en compte par rapport au fragment chevauché.  Si l'échantillon est derrière une géométrie, cet échantillon est pris en compte par rapport au fragment chevauché. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float intensity = smoothstep ( 0.0 , 1.0 , radius / abs(position.y - offsetPosition.y) ); occluded *= intensity; occlusion -= occluded; // ...</span></span></code> </pre> <br>  Ajoutez maintenant du poids à cette position échantillonnée en fonction de sa distance à l'intérieur ou à l'extérieur du rayon.  Ensuite, soustrayez cet échantillon de la métrique d'occlusion car cela suppose que tous les échantillons se sont chevauchés avant la boucle. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... occlusion /= NUM_SAMPLES; // ... fragColor = vec4(vec3(occlusion), position.a); // ...</span></span></code> </pre> <br>  Divisez le nombre de chevauchements par le nombre d'échantillons pour convertir l'indicateur d'occlusion de l'intervalle <code>[0, NUM_SAMPLES]</code> à l'intervalle <code>[0, 1]</code> .  Zéro signifie une occlusion complète, les unités signifient aucune occlusion.  Maintenant, affectez la métrique d'occlusion à la couleur du fragment, et c'est tout. <br><br>  Veuillez noter que dans l'exemple de code, le canal alpha se voit attribuer la valeur alpha de la texture de position du tampon de trame pour éviter le chevauchement de l'arrière-plan. <br><br><h3>  Flou </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b1/566/2a7/5b15662a7c46db6b8102fe9eabae17c9.gif"></div><br>  La texture du tampon de trame SSAO est un peu bruyante, vous devez donc la rendre floue pour le lissage. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... for (int i = 0; i &lt; size2; ++i) { x = size - xCount; y = yCount - size; result += texture ( ssaoTexture , texCoord + vec2(x * parameters.x, y * parameters.x) ).rgb; xCount -= 1; if (xCount &lt; countMin) { xCount = countMax; yCount -= 1; } } result = result / size2; // ...</span></span></code> </pre> <br>  Le shader de flou SSAO est un flou de boîte régulier.  Comme le shader de floraison, il dessine une fenêtre sur la texture entrante et fait la moyenne de chaque fragment avec les valeurs de ses voisins. <br><br>  Notez que <code>parameters.x</code> est un paramètre de séparation. <br><br><h3>  Couleur ambiante </h3><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec2 ssaoBlurTexSize = textureSize(ssaoBlurTexture, 0).xy; vec2 ssaoBlurTexCoord = gl_FragCoord.xy / ssaoBlurTexSize; float ssao = texture(ssaoBlurTexture, ssaoBlurTexCoord).r; vec4 ambient = p3d_Material.ambient * p3d_LightModel.ambient * diffuseTex * ssao; // ...</span></span></code> </pre> <br>  Le dernier défi pour SSAO réside à nouveau dans les calculs d'éclairage.  Nous voyons ici comment l'occlusion se trouve dans le tampon de texture SSAO de texture et est incluse dans le calcul de la lumière ambiante. <br><br><h3>  Code source </h3><br><ul><li>  <a href="">main.cxx</a> </li><li>  <a href="">base.vert</a> </li><li>  <a href="">basic.vert</a> </li><li>  <a href="">position.frag</a> </li><li>  <a href="">normal.frag</a> </li><li>  <a href="">ssao.frag</a> </li><li>  <a href="">blur.frag</a> </li></ul><br><h2>  Profondeur de champ </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ef/eb0/10f/6efeb010f4623ff49b928d72550f7985.gif"></div><br>  La profondeur de champ est également un tel effet, après avoir appris lequel, vous ne pouvez pas vous en passer.  D'un point de vue artistique, vous pouvez l'utiliser pour attirer l'attention du spectateur sur un objet spécifique.  Mais dans le cas général, la profondeur de champ au prix d'un petit effort ajoute une grande part de réalisme. <br><br><h3>  En bref </h3><br>  La première étape consiste à rendre la scène complètement nette.  Rendez-le à la texture du tampon d'image.  Ce sera l'une des valeurs d'entrée pour la profondeur du tampon de champ. <br><br><h3>  Flou </h3><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 result = vec4(0); for (int i = 0; i &lt; size2; ++i) { x = size - xCount; y = yCount - size; result += texture ( blurTexture , texCoord + vec2(x * parameters.x, y * parameters.x) ); xCount -= 1; if (xCount &lt; countMin) { xCount = countMax; yCount -= 1; } } result = result / size2; // ...</span></span></code> </pre> <br>  La deuxième étape consiste à rendre la scène floue comme si elle était complètement floue.  Comme avec Bloom et SSAO, vous pouvez utiliser le flou de boîte.  Rendez cette scène défocalisée à la texture du tampon d'image.  Ce sera une autre valeur d'entrée pour le shader de profondeur de champ. <br><br>  Notez que <code>parameters.x</code> est un paramètre de séparation. <br><br><h3>  Confusion </h3><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d68/067/83a/d6806783a567c4708d8f13dcb0763f7c.gif"></div><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float focalLengthSharpness = 100; float blurRate = 6; // ...</span></span></code> </pre> <br>  Vous pouvez personnaliser ces options à votre goût.  <code>focalLengthSharpness</code> affecte la défocalisation de la scène à la distance focale.  Plus la <code>focalLengthSharpness</code> , plus la scène sera défocalisée à la distance focale.  <code>blurRate</code> affecte la vitesse de flou de la scène lorsque vous vous éloignez de la distance focale.  Plus le <code>blurRate</code> flou est petit, moins la scène sera floue <code>blurRate</code> s'éloignant du point AF. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 focusColor = texture(focusTexture, texCoord); vec4 outOfFocusColor = texture(outOfFocusTexture, texCoord); // ...</span></span></code> </pre> <br>  Nous aurons besoin de couleurs au point et dans une image défocalisée. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 position = texture(positionTexture, texCoord); // ...</span></span></code> </pre> <br>  Nous pouvons également avoir besoin de la position du sommet dans l'espace de visualisation.  Vous pouvez réappliquer la texture des positions à partir du tampon de trame utilisé pour SSAO. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float blur = clamp ( pow ( blurRate , abs(position.y - focalLength.x) ) / focalLengthSharpness , 0 , 1 ); // ... fragColor = mix(focusColor, outOfFocusColor, blur); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et ici, la confusion a lieu. </font><font style="vertical-align: inherit;">Le plus proche </font></font><code>blur</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d'un, plus il utilisera </font></font><code>outOfFocusColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Une valeur de zéro </font></font><code>blur</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">signifie que ce fragment est entièrement au point. </font><font style="vertical-align: inherit;">Avec </font></font><code>blur &gt;= 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ce fragment est complètement défocalisé.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Code source </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blur.frag</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">depth-of-field.frag</font></font></a> </li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Postérisation </font></font></h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f18/078/84d/f1807884d79c5c73915ce9adf6ead5cb.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La postérisation, ou échantillonnage des couleurs, est le processus de réduction du nombre de couleurs uniques dans une image. </font><font style="vertical-align: inherit;">Vous pouvez utiliser ce shader pour donner au jeu un look comique ou rétro. </font><font style="vertical-align: inherit;">Si vous le combinez avec un contour, vous obtenez un vrai style caricatural.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float levels = 8; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez expérimenter avec ce paramètre. </font><font style="vertical-align: inherit;">Plus il est grand, plus il restera de fleurs.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 texColor = texture(posterizeTexture, texCoord); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous aurons besoin de la couleur entrante. </font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 grey = vec3((texColor.r + texColor.g + texColor.b) / 3.0); vec3 grey1 = grey; grey = floor(grey * levels) / levels; texColor.rgb += (grey - grey1); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je n'ai pas vu une telle méthode de postérisation. </font><font style="vertical-align: inherit;">Après l'avoir vérifié, j'ai vu qu'il crée de plus beaux résultats par rapport aux méthodes conventionnelles. </font><font style="vertical-align: inherit;">Pour réduire la palette de couleurs, convertissez d'abord la couleur en une valeur en niveaux de gris. </font><font style="vertical-align: inherit;">Nous discrétisons la couleur en la liant à l'un des niveaux. </font><font style="vertical-align: inherit;">Nous calculons la différence entre la valeur discrétisée en niveaux de gris et la valeur non discrétisée en niveaux de gris. </font><font style="vertical-align: inherit;">Ajoutez cette différence à la couleur d'entrée. </font><font style="vertical-align: inherit;">Cette différence est la quantité par laquelle la couleur doit augmenter / diminuer pour obtenir une valeur discrétisée en niveaux de gris.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... fragColor = texColor; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N'oubliez pas d'attribuer la valeur de la couleur d'entrée à la couleur du fragment. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ombrage cel </font></font></h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d1/f9c/133/2d1f9c1333960c0299388fc51323a8b3.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La postérisation peut donner à une image l'apparence de l'ombrage cel, car l'ombrage cel est le processus de discrétisation des couleurs diffuses et diffuses en nuances discrètes. </font><font style="vertical-align: inherit;">Nous voulons utiliser uniquement des couleurs diffuses solides sans détails fins de la carte normale et une petite valeur </font></font><code>levels</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Code source </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">posterize.frag</font></font></a> </li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pixélisation </font></font></h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/396/0b9/9bc/3960b99bc2f1fa900c40a1c9f32169bc.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La pixellisation d'un jeu 3D peut lui donner une apparence intéressante, ou vous faire gagner du temps qui aurait été nécessaire pour créer manuellement tout le pixel art. </font><font style="vertical-align: inherit;">Combinez-le avec la postérisation pour créer un véritable look rétro.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... int pixelSize = 5; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez ajuster vous-même la taille des pixels. </font><font style="vertical-align: inherit;">Plus elle est grande, plus l'image sera rugueuse.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/413/818/aee/413818aee5509763cc383f800b837cfb.gif"></div><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float x = int(gl_FragCoord.x) % pixelSize; float y = int(gl_FragCoord.y) % pixelSize; x = floor(pixelSize / 2.0) - x; y = floor(pixelSize / 2.0) - y; x = gl_FragCoord.x + x; y = gl_FragCoord.y + y; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette technique attache chaque fragment au centre de sa fenêtre de taille de pixel non superposée la plus proche. </font><font style="vertical-align: inherit;">Ces fenêtres s'alignent au-dessus de la texture entrante. </font><font style="vertical-align: inherit;">Les fragments au centre de la fenêtre déterminent la couleur des autres fragments de leur fenêtre.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... fragColor = texture(pixelizeTexture, vec2(x, y) / texSize); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Après avoir déterminé les coordonnées du fragment souhaité à utiliser, prenez sa couleur dans la texture entrante et affectez-la à la couleur du fragment. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Code source </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pixelize.frag</font></font></a> </li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aiguiser </font></font></h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b52/674/617/b52674617a0733ee1fe0d525b0053750.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'effet de netteté (netteté) augmente le contraste sur les bords de l'image. </font><font style="vertical-align: inherit;">Il est utile lorsque les graphismes s'avèrent trop mous.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float amount = 0.8; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En modifiant la valeur, nous pouvons contrôler l'amplitude de la netteté du résultat. </font><font style="vertical-align: inherit;">Si la valeur est zéro, l'image ne changera pas. </font><font style="vertical-align: inherit;">Avec des valeurs négatives, l'image commence à paraître étrange.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float neighbor = amount * -1; float center = amount * 4 + 1; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les fragments adjacents sont multipliés par </font></font><code>amount * -1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Le fragment actuel est multiplié par </font></font><code>amount * 4 + 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 color = texture(sharpenTexture, vec2(gl_FragCoord.x + 0, gl_FragCoord.y + 1) / texSize).rgb * neighbor + texture(sharpenTexture, vec2(gl_FragCoord.x - 1, gl_FragCoord.y + 0) / texSize).rgb * neighbor + texture(sharpenTexture, vec2(gl_FragCoord.x + 0, gl_FragCoord.y + 0) / texSize).rgb * center + texture(sharpenTexture, vec2(gl_FragCoord.x + 1, gl_FragCoord.y + 0) / texSize).rgb * neighbor + texture(sharpenTexture, vec2(gl_FragCoord.x + 0, gl_FragCoord.y - 1) / texSize).rgb * neighbor ; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les fragments voisins sont en haut, en bas, à gauche et à droite. </font><font style="vertical-align: inherit;">Après avoir multiplié les voisins et le fragment actuel par leurs valeurs, le résultat est additionné.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... fragColor = vec4(color, texture(sharpenTexture, texCoord).a); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cette quantité est la couleur finale du fragment. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Code source </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sharpen.frag</font></font></a> </li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Grain de film </font></font></h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f3/16e/232/2f316e232598d07fa8114f8db32c12a7.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le grain du film (à petites doses, et pas comme dans l'exemple) peut ajouter du réalisme, qui est invisible jusqu'à ce que cet effet soit supprimé. </font><font style="vertical-align: inherit;">Ce sont généralement les imperfections qui rendent l'image générée numériquement plus convaincante. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notez que le grain du film est généralement le dernier effet appliqué au cadre avant d'être affiché.</font></font><br><br><h3>  Valeur </h3><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float amount = 0.1; // ...</span></span></code> </pre> <br> <code>amount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contrôle la visibilité du grain du film. </font><font style="vertical-align: inherit;">Plus la valeur est élevée, plus il y a de «neige» sur l'image.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Luminosité aléatoire </font></font></h3><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform float osg_FrameTime; //... float toRadians = 3.14 / 180; //... float randomIntensity = fract ( 10000 * sin ( ( gl_FragCoord.x + gl_FragCoord.y * osg_FrameTime ) * toRadians ) ); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ce morceau de code calcule la luminosité aléatoire nécessaire pour ajuster la valeur. </font></font><br><br><pre> <code class="cpp hljs">Time Since F1 = <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">01</span></span> <span class="hljs-number"><span class="hljs-number">02</span></span> <span class="hljs-number"><span class="hljs-number">03</span></span> <span class="hljs-number"><span class="hljs-number">04</span></span> <span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">06</span></span> <span class="hljs-number"><span class="hljs-number">07</span></span> <span class="hljs-number"><span class="hljs-number">08</span></span> <span class="hljs-number"><span class="hljs-number">09</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> Frame Number = F1 F3 F4 F5 F6 osg_FrameTime = <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">02</span></span> <span class="hljs-number"><span class="hljs-number">04</span></span> <span class="hljs-number"><span class="hljs-number">07</span></span> <span class="hljs-number"><span class="hljs-number">08</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Valeur </font></font><code>osg_FrameTime</code> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fournie par</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Panda3D. </font><font style="vertical-align: inherit;">Un temps d'image est un horodatage contenant des informations sur le nombre de secondes écoulées depuis la première image. </font><font style="vertical-align: inherit;">L'exemple de code l'utilise pour animer le grain du film, qui </font></font><code>osg_FrameTime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sera différent dans chaque image.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... ( gl_FragCoord.x + gl_FragCoord.y * 8009 // Large number here. // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour les grains statiques, les films doivent être remplacés par un </font></font><code>osg_FrameTime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">grand nombre. </font><font style="vertical-align: inherit;">Pour éviter de voir des modèles, vous pouvez essayer différents nombres.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/358/2bd/6d2/3582bd6d2d67eb5ac1fdcdf8d52800e6.gif"></div><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... * sin ( ( gl_FragCoord.x + gl_FragCoord.y * someNumber // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour créer des points ou des taches de grain de film, les coordonnées, x et y sont utilisées. </font><font style="vertical-align: inherit;">Si vous utilisez x, seules les lignes verticales seront affichées, si vous utilisez y, seules les lignes horizontales seront affichées. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans le code, une coordonnée est multipliée par une autre pour détruire la symétrie diagonale.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c0/ad6/d5a/4c0ad6d5ada5d533b6dc31bbfa7aa0fc.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien sûr, vous pouvez vous débarrasser du multiplicateur de coordonnées et obtenir un effet de pluie tout à fait acceptable. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notez que pour animer l'effet pluie, multipliez la sortie </font></font><code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par </font></font><code>osg_FrameTime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Expérimentez avec les coordonnées x et y pour changer la direction de la pluie. </font><font style="vertical-align: inherit;">Pour une douche descendante, ne laissez que la coordonnée x.</font></font><br><br><pre> <code class="cpp hljs">input = (gl_FragCoord.x + gl_FragCoord.y * osg_FrameTime) * toRadians frame(<span class="hljs-number"><span class="hljs-number">10000</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(input)) = fract(<span class="hljs-number"><span class="hljs-number">10000</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(<span class="hljs-number"><span class="hljs-number">6.977777777777778</span></span>)) = fract(<span class="hljs-number"><span class="hljs-number">10000</span></span> * <span class="hljs-number"><span class="hljs-number">0.6400723818964882</span></span>) =</code> </pre> <br> <code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilisé comme fonction de hachage. </font><font style="vertical-align: inherit;">Les coordonnées des fragments sont hachées avec les valeurs de sortie </font></font><code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Grâce à cela, une propriété pratique apparaît - quelles que soient les données d'entrée (grandes ou petites), l'intervalle de sortie sera compris entre moins un et un.</font></font><br><br><pre> <code class="cpp hljs">fract(<span class="hljs-number"><span class="hljs-number">10000</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(<span class="hljs-number"><span class="hljs-number">6.977777777777778</span></span>)) = fract(<span class="hljs-number"><span class="hljs-number">10000</span></span> * <span class="hljs-number"><span class="hljs-number">0.6400723818964882</span></span>) = fract(<span class="hljs-number"><span class="hljs-number">6400.723818964882</span></span>) = <span class="hljs-number"><span class="hljs-number">0.723818964882</span></span></code> </pre> <br> <code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en combinaison avec </font></font><code>fract</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">également utilisé comme générateur de nombres pseudo aléatoires.</font></font><br><br><pre> <code class="cpp hljs">&gt;&gt;&gt; [<span class="hljs-built_in"><span class="hljs-built_in">floor</span></span>(fract(<span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(x * toRadians)) * <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">for</span></span></span><span class="hljs-function"> x in </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">range</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">] [0, 0, 1, 2, 2, 3, 4, 4, 5, 6] &gt;&gt;&gt; [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">floor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fract(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10000</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">sin</span></span></span></span><span class="hljs-function"><span class="hljs-params">(x * toRadians)) * </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">for</span></span></span><span class="hljs-function"> x in </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">range</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">] [0, 4, 8, 0, 2, 1, 7, 0, 0, 5]</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regardez d'abord la première rangée de chiffres, puis la seconde. </font><font style="vertical-align: inherit;">Chaque ligne est déterministe, mais le motif est moins visible dans la seconde que dans la seconde. </font><font style="vertical-align: inherit;">Par conséquent, malgré le fait que la sortie est </font></font><code>fract(10000 * sin(...))</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">déterministe, le modèle est reconnu beaucoup plus faible.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b88/6e7/f0f/b886e7f0feda6760c5fc87df6680680f.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ici, nous voyons comment le facteur </font></font><code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est d'abord 1, puis 10, puis 100, puis 1000. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque le multiplicateur des valeurs de sortie augmente, le </font></font><code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">modèle devient moins perceptible. </font><font style="vertical-align: inherit;">Pour cette raison, le code </font></font><code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est multiplié par 10 000.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Couleur du fragment </font></font></h3><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec2 texSize = textureSize(filmGrainTexture, 0).xy; vec2 texCoord = gl_FragCoord.xy / texSize; vec4 color = texture(filmGrainTexture, texCoord); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Convertissez les coordonnées du fragment en coordonnées UV. </font><font style="vertical-align: inherit;">En utilisant ces coordonnées UV, nous recherchons la couleur de texture pour le fragment actuel.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... amount *= randomIntensity; color.rgb += amount; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modifiez la valeur en une luminosité aléatoire et ajoutez-la à la couleur. </font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... fragColor = color; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Définissez la couleur du fragment, et c'est tout. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Code source </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">film-grain.frag</font></font></a> </li></ul><br><h2>  Remerciements </h2><br><ul><li>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Kiwi Soda Font</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr453692/">https://habr.com/ru/post/fr453692/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr453676/index.html">Connexion à Windows via SSH comme sous Linux</a></li>
<li><a href="../fr453678/index.html">Comment voir la réverbération ou la transmission vidéo par le son dans l'eau - 2</a></li>
<li><a href="../fr453682/index.html">Développement du «firmware» le plus simple pour les FPGA installés dans Redd. Partie 2. Code de programme</a></li>
<li><a href="../fr453686/index.html">Semaine de la sécurité 22: statistiques sur les menaces, chevaux de Troie bancaires et exploits populaires</a></li>
<li><a href="../fr453688/index.html">Java n'est pas seulement une entreprise sanglante, mais aussi des applications sensibles à la latence rapide</a></li>
<li><a href="../fr453694/index.html">Connectez-vous à Windows via SSH comme sous Linux</a></li>
<li><a href="../fr453696/index.html">Reliure angulaire bidirectionnelle, un peu plus de compréhension</a></li>
<li><a href="../fr453698/index.html">L'information quantique dans la conscience quantique</a></li>
<li><a href="../fr453700/index.html">Leçons sur SDL 2: Leçon 1 - Bonjour, SDL 2</a></li>
<li><a href="../fr453706/index.html">Comment j'ai réussi l'examen de certification Google Cloud Professional Data Engineer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>