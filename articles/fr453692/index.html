<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§¨ üë®üèæ‚Äçü§ù‚Äçüë®üèª üï≥Ô∏è Shaders de jeu 3D pour d√©butants: Effets üë©‚Äç‚ù§Ô∏è‚Äçüë© üê¥ üë®üèΩ‚Äçüîß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[ La premi√®re partie ] 

 Apr√®s avoir trait√© des bases, dans cette partie de l'article, nous mettons en ≈ìuvre des effets tels que les contours des obj...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Shaders de jeu 3D pour d√©butants: Effets</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453692/">  [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La premi√®re partie</a> ] <br><br>  Apr√®s avoir trait√© des bases, dans cette partie de l'article, nous mettons en ≈ìuvre des effets tels que les contours des objets, la floraison, le SSAO, le flou, la profondeur de champ, la pixellisation, etc. <br><br><h2>  Contours </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b8/96f/9b2/3b896f9b246e1695fa908b4bdc145480.gif"></div><br>  La cr√©ation de contours autour de la g√©om√©trie de la sc√®ne donne au jeu un aspect unique qui ressemble √† des bandes dessin√©es ou des dessins anim√©s. <br><br><h3>  Mat√©riau diffus </h3><br>  Le shader de contour a besoin d'une texture d'entr√©e pour reconna√Ætre et colorer les bords.  Les candidats √† une telle texture entrante peuvent √™tre une couleur diffuse √† partir de mat√©riaux, des couleurs √† partir de textures diffuses, des normales de vertex ou m√™me des couleurs √† partir de cartes normales. <br><br><pre><code class="cpp hljs">uniform <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> vec4 diffuse ; } p3d_Material; out vec4 fragColor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ vec3 diffuseColor = p3d_Material.diffuse.rgb; fragColor = vec4(diffuseColor, <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br>  Il s'agit d'un petit ombrage de fragment qui rend la couleur diffuse d'un mat√©riau g√©om√©trique en une texture de tampon de trame.  Cette texture de couleur diffuse provenant du tampon de trame sera la texture d'entr√©e du shader de chemin. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f0b/abd/05c/f0babd05caf7104156c15929995c9279.gif"></div><br>  Il s'agit de la texture de la couleur diffuse du mat√©riau provenant du tampon d'image, qui affiche les couleurs que nous avons d√©finies dans Blender.  Le shader contour reconna√Ætra les bords de la sc√®ne et les coloriera. <br><br>  Il convient de noter que la couleur diffuse des mat√©riaux ne fonctionnera pas si certaines parties de la sc√®ne n'ont pas leur propre couleur diffuse du mat√©riau. <br><br><h3>  Cr√©ation d'ar√™tes </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33a/a0d/57a/33aa0d57aeba90366ddd95865ea0d6c6.gif"></div><br>  La cr√©ation d'ar√™tes est similaire √† l'utilisation de filtres de reconnaissance d'ar√™tes dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GIMP</a> . <br><br>  Tous les calculs pour cette technique d'ombrage sont effectu√©s dans un fragment shader.  Pour cr√©er des contours pour le vertex shader, il suffit de passer quatre sommets du maillage rectangulaire √† la sortie pour s'adapter √† l'√©cran. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform sampler2D materialDiffuseTexture; // ... vec2 texSize = textureSize(materialDiffuseTexture, 0).xy; vec2 texCoord = gl_FragCoord.xy; // ...</span></span></code> </pre> <br>  Avant de commencer √† reconna√Ætre les bords, vous devez pr√©parer la texture entrante, avec laquelle nous travaillerons.  Puisque la texture a une taille d'√©cran, nous pouvons calculer les coordonn√©es UV, connaissant les coordonn√©es du fragment et la taille de la texture entrante. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... int separation = 1; // ...</span></span></code> </pre> <br>  <code>separation</code> peut √™tre personnalis√©e selon vos go√ªts.  Plus la s√©paration est grande, plus les bords ou les lignes sont √©pais. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float threshold = 0; // ... vec4 mx = vec4(0); vec4 mn = vec4(1); int x = -1; int y = -1; for (int i = 0; i &lt; 9; ++i) { vec4 color = texture ( materialDiffuseTexture , (texCoord + (vec2(x, y) * separation)) / texSize ); mx = max(color, mx); mn = min(color, mn); x += 1; if (x &gt;= 2) { x = -1; y += 1; } } float alpha = ((mx.r + mx.g + mx.b) / 3) - ((mn.r + mn.g + mn.b) / 3); if (alpha &gt; threshold) { alpha = 1; } // ...</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/42f/d24/e56/42fd24e5682700e1e7cd5186bebc33af.gif"></div><br>  La technique de reconnaissance des bords trouve des changements dans les couleurs de la texture entrante.  En se concentrant sur le fragment actuel, il utilise la fen√™tre de fragments 3x3 pour trouver les couleurs les plus claires et les plus sombres des neuf √©chantillons.  Ensuite, elle soustrait de la luminosit√© d'une couleur la luminosit√© d'une autre, obtenant leur diff√©rence. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 lineRgb = vec3(0.012, 0.014, 0.022); // ... vec4 lineColor = vec4(lineRgb, alpha); // ... fragColor = lineColor; // ...</span></span></code> </pre> <br>  Cette diff√©rence est utilis√©e dans le canal alpha de la couleur de sortie.  S'il n'y a pas de diff√©rence, le bord ou la ligne n'est pas trac√©.  S'il y a une diff√©rence, le bord est trac√©. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float threshold = 0; // ... if (alpha &gt; threshold) { alpha = 1; } // ...</span></span></code> </pre> <br>  Essayez de tester la valeur seuil.  Maintenant, c'est z√©ro.  Toute valeur diff√©rente de z√©ro devient un bord; ce seuil peut √™tre modifi√©.  Ceci est particuli√®rement utile pour les textures entrantes plus bruyantes avec de petites diff√©rences.  Dans le cas d'une texture entrante bruyante, vous devez g√©n√©ralement cr√©er des contours uniquement pour les grandes diff√©rences. <br><br><h3>  Code source </h3><br><ul><li>  <a href="">main.cxx</a> </li><li>  <a href="">base.vert</a> </li><li>  <a href="">basic.vert</a> </li><li>  <a href="">material-diffuse.frag</a> </li><li>  <a href="">contour.frag</a> </li></ul><br><h2>  Brouillard </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5af/02c/e52/5af02ce52f813b27461f79e5dca5fe20.gif"></div><br>  Le brouillard (ou brume, comme on l'appelle dans Blender) ajoute une brume atmosph√©rique √† la sc√®ne, cr√©ant de myst√©rieuses parties saillantes ramollies.  Les parties saillantes apparaissent lorsqu'une g√©om√©trie tombe soudainement dans la pyramide de visibilit√© de la cam√©ra. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform struct p3d_FogParameters { vec4 color ; float start ; float end ; } p3d_Fog; // ...</span></span></code> </pre> <br>  Panda3D a une structure de donn√©es pratique qui contient tous les param√®tres de brouillard, mais vous pouvez les transf√©rer manuellement vers votre shader. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float fogIntensity = clamp ( ( p3d_Fog.end - vertexPosition.y) / ( p3d_Fog.end - p3d_Fog.start) , 0 , 1 ); fogIntensity = 1 - fogIntensity; // ...</span></span></code> </pre> <br>  Dans l'exemple de code, un mod√®le lin√©aire est utilis√© pour calculer la luminosit√© du brouillard lorsque vous vous √©loignez de la cam√©ra.  Au lieu de cela, vous pouvez utiliser le mod√®le exponentiel.  La luminosit√© du brouillard est nulle avant ou au d√©but du brouillard.  Lorsque la position du sommet approche de la fin du brouillard, <code>fogIntensity</code> rapproche de l'unit√©.  Pour tous les sommets apr√®s la fin du brouillard, <code>fogIntensity</code> limit√© √† 1 √† partir du dessus. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... fragColor = mix ( outputColor , p3d_Fog.color , fogIntensity ); // ...</span></span></code> </pre> <br>  En fonction de la luminosit√© du brouillard, nous m√©langeons la couleur du brouillard avec la couleur de sortie.  √Ä <code>fogIntensity</code> que <code>fogIntensity</code> approche l'unit√©, il y aura de moins en moins <code>outputColor</code> et de plus en plus de couleur de brouillard.  Lorsque <code>fogIntensity</code> atteint l'unit√©, seule la couleur du brouillard restera. <br><br><h3>  Brouillard sur les contours </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1f/ee8/d49/e1fee8d490abe10ecb798df618f183f7.gif"></div><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform sampler2D positionTexture; // ... vec4 position = texture(positionTexture, texCoord / texSize); float fogIntensity = clamp ( ( p3d_Fog.end - position.y) / ( p3d_Fog.end - p3d_Fog.start) , 0 , 1 ); fogIntensity = 1 - fogIntensity; vec4 lineWithFogColor = mix ( lineColor , p3d_Fog.color , fogIntensity ); fragColor = vec4(lineWithFogColor.rgb, alpha); // ...</span></span></code> </pre> <br>  Le Path Shader applique du brouillard aux couleurs des bords pour une image plus holistique.  S'il ne le faisait pas, la g√©om√©trie des contours serait obscurcie par le brouillard, ce qui serait √©trange.  Cependant, il cr√©e toujours des contours sur les bords les plus externes de la g√©om√©trie de la sc√®ne avec le fraisage, car les bords d√©passent la g√©om√©trie - l√† o√π il n'y a pas de positions de sommet. <br><br>  <code>positionTexture</code> est une texture de tampon d'image qui contient les positions des sommets de l'espace de vue.  Vous en saurez plus lorsque nous impl√©menterons le shader SSAO. <br><br><h3>  Code source </h3><br><ul><li>  <a href="">main.cxx</a> </li><li>  <a href="">base.vert</a> </li><li>  <a href="">basic.vert</a> </li><li>  <a href="">base.frag</a> </li><li>  <a href="">contour.frag</a> </li></ul><br><h2>  Bloom </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31d/744/f35/31d744f35168ac87f609474998802b12.gif"></div><br>  Ajouter de la floraison √† la sc√®ne peut cr√©er une illusion convaincante du mod√®le d'√©clairage.  Les objets √©metteurs de lumi√®re deviennent plus convaincants et les reflets lumineux re√ßoivent une quantit√© suppl√©mentaire de rayonnement. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//... float separation = 3; int samples = 15; float threshold = 0.5; float amount = 1; // ...</span></span></code> </pre> <br>  Vous pouvez personnaliser ces param√®tres √† votre guise.  La s√©paration augmente la taille du flou.  Les √©chantillons d√©terminent la force du flou.  Le seuil d√©termine ce qui sera et ne sera pas affect√© par cet effet.  La quantit√© contr√¥le la quantit√© de floraison produite. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... int size = samples; int size2 = size * size; int x = 0; int y = 0; // ... float value = 0; vec4 result = vec4(0); vec4 color = vec4(0); // ... for (int i = 0; i &lt; size2; ++i) { // ... } // ...</span></span></code> </pre> <br>  Cette technique commence par passer des <code>samples</code> taille d'une fen√™tre sur des <code>samples</code> centr√©s par rapport au fragment actuel.  Il ressemble √† une fen√™tre utilis√©e pour cr√©er des chemins. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... color = texture ( bloomTexture , ( gl_FragCoord.xy + vec2(x * separation, y * separation) ) / texSize ); value = ((0.3 * color.r) + (0.59 * color.g) + (0.11 * color.b)); if (value &lt; threshold) { color = vec4(0); } result += color; // ...</span></span></code> </pre> <br>  Ce code obtient la couleur de la texture entrante et transforme les valeurs du rouge, du vert et du bleu en une valeur en niveaux de gris.  Si la valeur en niveaux de gris est inf√©rieure au seuil, elle rejette cette couleur, la rendant noire. <br><br>  En passant par tous les √©chantillons dans la fen√™tre, il accumule toutes leurs valeurs en <code>result</code> . <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... result = result / size2; // ...</span></span></code> </pre> <br>  Ayant termin√© la collecte des √©chantillons, il divise la somme des √©chantillons de couleur par le nombre d'√©chantillons pr√©lev√©s.  Le r√©sultat est la couleur m√©diane du fragment lui-m√™me et de ses voisins.  Ce faisant, pour chaque fragment, nous obtenons une image floue.  Ce type de flou est appel√© flou de bo√Æte. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f90/16f/ea4/f9016fea492bc7b136ef6437a683c937.gif"></div><br>  Vous voyez ici le processus d'ex√©cution de l'algorithme de floraison. <br><br><h3>  Code source </h3><br><ul><li>  <a href="">main.cxx</a> </li><li>  <a href="">basic.vert</a> </li><li>  <a href="">bloom.frag</a> </li></ul><br><h2>  Screen Space Ambient Occlusion (SSAO) </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f93/5ab/5bf/f935ab5bf4794caae3be90b611ad771c.gif"></div><br>  SSAO est l'un de ces effets que vous ne connaissez pas, mais d√®s que vous savez que vous ne pouvez plus vivre sans eux.  Il peut transformer une sc√®ne m√©diocre en une sc√®ne incroyable!  Dans les sc√®nes statiques, l'occlusion ambiante peut √™tre int√©gr√©e dans la texture, mais pour les sc√®nes plus dynamiques, nous avons besoin d'un shader.  SSAO est l'une des techniques d'ombrage les plus sophistiqu√©es, mais une fois que vous l'aurez compris, vous deviendrez un ma√Ætre shader. <br><br>  Notez que le terme ¬´espace d'√©cran¬ª dans le titre n'est pas enti√®rement correct, car tous les calculs ne sont pas effectu√©s dans l'espace d'√©cran. <br><br><h3>  Donn√©es entrantes </h3><br>  Le shader SSAO aura besoin de l'entr√©e suivante. <br><br><ul><li>  Vecteurs de positions des sommets dans l'espace d'observation. </li><li>  Vecteurs normaux aux sommets de l'espace de visualisation. </li><li>  Exemples de vecteurs dans l'espace tangent. </li><li>  Vecteurs de bruit dans l'espace tangent. </li><li>  La matrice de projection sur l'objectif de la cam√©ra. </li></ul><br><h3>  Poste </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d2/f36/d42/2d2f36d425c2596288d8982158687354.png"></div><br>  Il n'est pas n√©cessaire de stocker les positions des sommets dans la texture du tampon de trame.  Nous pouvons les recr√©er √† partir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">du tampon de profondeur</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">la cam√©ra</a> .  J'√©cris un guide pour les d√©butants, nous n'utiliserons donc pas cette optimisation et nous nous mettrons imm√©diatement au travail.  Dans votre impl√©mentation, vous pouvez facilement utiliser le tampon de profondeur. <br><br><pre> <code class="cpp hljs">PT(Texture) depthTexture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture(<span class="hljs-string"><span class="hljs-string">"depthTexture"</span></span>); depthTexture-&gt;set_format(Texture::Format::F_depth_component32); PT(GraphicsOutput) depthBuffer = graphicsOutput-&gt;make_texture_buffer(<span class="hljs-string"><span class="hljs-string">"depthBuffer"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, depthTexture); depthBuffer-&gt;set_clear_color(LVecBase4f(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); NodePath depthCameraNP = window-&gt;make_camera(); DCAST(Camera, depthCameraNP.node())-&gt;set_lens(window-&gt;get_camera(<span class="hljs-number"><span class="hljs-number">0</span></span>)-&gt;get_lens()); PT(DisplayRegion) depthBufferRegion = depthBuffer-&gt;make_display_region(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); depthBufferRegion-&gt;set_camera(depthCameraNP);</code> </pre> <br>  Si vous d√©cidez d'utiliser le tampon de profondeur, voici comment vous pouvez le configurer dans Panda3D. <br><br><pre> <code class="cpp hljs">in vec4 vertexPosition; out vec4 fragColor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ fragColor = vertexPosition; }</code> </pre> <br>  Voici un shader simple pour rendre les positions des sommets dans l'espace de visualisation dans une texture de tampon de trame.  Une t√¢che plus difficile consiste √† ajuster la texture du tampon de trame de sorte que les composants du vecteur fragment obtenu par celui-ci ne soient pas limit√©s √† l'intervalle <code>[0, 1]</code> , et que chacun ait une pr√©cision suffisamment √©lev√©e (un nombre suffisamment important de bits).  Par exemple, si une sorte de position de sommet interpol√©e est <code>&lt;-139.444444566, 0.00000034343, 2.5&gt;</code> , vous ne pouvez pas l'enregistrer dans la texture en tant que <code>&lt;0.0, 0.0, 1.0&gt;</code> . <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... FrameBufferProperties fbp = FrameBufferProperties::get_default(); // ... fbp.set_rgba_bits(32, 32, 32, 32); fbp.set_rgb_color(true); fbp.set_float_color(true); // ...</span></span></code> </pre> <br>  Voici un exemple de code qui pr√©pare une texture de tampon de trame pour stocker les positions des sommets.  Il a besoin de 32 bits pour le rouge, le vert, le bleu et l'alpha, il d√©sactive donc la restriction des valeurs par l'intervalle <code>[0, 1]</code> .  L'appel √† <code>set_rgba_bits(32, 32, 32, 32)</code> d√©finit le volume binaire et d√©sactive la restriction. <br><br><pre> <code class="cpp hljs"> glTexImage2D ( GL_TEXTURE_2D , <span class="hljs-number"><span class="hljs-number">0</span></span> , GL_RGB32F , <span class="hljs-number"><span class="hljs-number">1200</span></span> , <span class="hljs-number"><span class="hljs-number">900</span></span> , <span class="hljs-number"><span class="hljs-number">0</span></span> , GL_RGB , GL_FLOAT , <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> );</code> </pre> <br>  Voici un appel similaire sur OpenGL.  <code>GL_RGB32F</code> d√©finit les bits et d√©sactive la restriction. <br><br><blockquote>  Si le tampon de couleur a une virgule fixe, les composants des valeurs initiale et finale, ainsi que les indices de m√©lange, avant de calculer l'√©quation de m√©lange sont limit√©s √† [0, 1] ou [-1, 1], respectivement, pour les tampons de couleur normalis√©s non sign√©s normalis√©s et sign√©s.  Si le tampon de couleur a une virgule flottante, la restriction n'est pas respect√©e. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Source</a> </blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/17b/2d0/2ad/17b2d02ad53c411dc251d90fdc16fdf3.png"></div><br>  Ici vous voyez les positions des sommets;  l'axe y est vers le haut. <br><br>  N'oubliez pas que Panda3D d√©finit l'axe z comme un vecteur pointant vers le haut, tandis que dans OpenGL, l'axe y recherche.  Le shader de position affiche les positions des sommets avec un z vers le haut, car dans Panda3D <br>  le param√®tre <code>gl-coordinate-system default</code> est configur√©. <br><br><h3>  Normal </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c4/064/9c5/0c40649c525edd7bcf3c829d6e948789.gif"></div><br>  Pour l'orientation correcte des √©chantillons obtenus dans le shader SSAO, nous avons besoin des normales aux sommets.  L'exemple de code g√©n√®re plusieurs vecteurs d'√©chantillonnage r√©partis sur l'h√©misph√®re, mais vous pouvez utiliser la sph√®re et r√©soudre compl√®tement le probl√®me du besoin de normales. <br><br><pre> <code class="cpp hljs">in vec3 vertexNormal; out vec4 fragColor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ vec3 normal = normalize(vertexNormal); fragColor = vec4(normal, <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br>  Comme le shader de position, le shader normal est tr√®s simple.  N'oubliez pas de normaliser les normales aux sommets et n'oubliez pas qu'elles sont dans l'espace de visualisation. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/57b/a82/f00/57ba82f003b0ab9c2aafa7c9affa28bb.gif"></div><br>  Les normales aux sommets sont montr√©es ici;  l'axe y est vers le haut. <br><br>  Rappelons que Panda3D consid√®re l'axe z comme le vecteur ascendant et OpenGL vers l'axe y.  Le shader normal affiche les positions des sommets avec l'axe z pointant vers le haut, car le <code>gl-coordinate-system default</code> configur√© dans Panda3D. <br><br><h3>  √âchantillons </h3><br>  Pour d√©terminer la valeur d'occlusion ambiante pour tout fragment unique, nous devons √©chantillonner la zone environnante. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... for (int i = 0; i &lt; numberOfSamples; ++i) { LVecBase3f sample = LVecBase3f ( randomFloats(generator) * 2.0 - 1.0 , randomFloats(generator) * 2.0 - 1.0 , randomFloats(generator) ).normalized(); float rand = randomFloats(generator); sample[0] *= rand; sample[1] *= rand; sample[2] *= rand; float scale = (float) i / (float) numberOfSamples; scale = lerp(0.1, 1.0, scale * scale); sample[0] *= scale; sample[1] *= scale; sample[2] *= scale; ssaoSamples.push_back(sample); } // ...</span></span></code> </pre> <br>  L'exemple de code g√©n√®re 64 √©chantillons al√©atoires r√©partis dans un h√©misph√®re.  Ces <code>ssaoSamples</code> seront pass√©s au shader SSAO. <br><br><pre> <code class="cpp hljs"> LVecBase3f sample = LVecBase3f ( randomFloats(generator) * <span class="hljs-number"><span class="hljs-number">2.0</span></span> - <span class="hljs-number"><span class="hljs-number">1.0</span></span> , randomFloats(generator) * <span class="hljs-number"><span class="hljs-number">2.0</span></span> - <span class="hljs-number"><span class="hljs-number">1.0</span></span> , randomFloats(generator) * <span class="hljs-number"><span class="hljs-number">2.0</span></span> - <span class="hljs-number"><span class="hljs-number">1.0</span></span> ).normalized();</code> </pre> <br>  Si vous souhaitez r√©partir vos √©chantillons sur une sph√®re, modifiez alors l'intervalle de la composante al√©atoire z pour qu'il passe de moins un √† un. <br><br><h3>  Le bruit </h3><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... for (int i = 0; i &lt; 16; ++i) { LVecBase3f noise = LVecBase3f ( randomFloats(generator) * 2.0 - 1.0 , randomFloats(generator) * 2.0 - 1.0 , 0.0 ); ssaoNoise.push_back(noise); } // ...</span></span></code> </pre> <br>  Afin de bien couvrir la zone √©chantillonn√©e, nous devons g√©n√©rer des vecteurs de bruit.  Ces vecteurs de bruit peuvent faire tourner des √©chantillons autour du haut de la surface. <br><br><h3>  Occlusion ambiante </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d35/c1d/bb4/d35c1dbb4e0e9dfeedc3bd4285f26004.gif"></div><br>  SSAO accomplit sa t√¢che en √©chantillonnant l'espace d'observation autour du fragment.  Plus il y a d'√©chantillons sous la surface, plus la couleur du fragment est fonc√©e.  Ces √©chantillons sont situ√©s dans le fragment et indiquent dans la direction g√©n√©rale de la normale au sommet.  Chaque √©chantillon est utilis√© pour rechercher une position dans la texture de la position du tampon de trame.  La position retourn√©e est compar√©e √† l'√©chantillon.  Si l'√©chantillon est plus √©loign√© de la cam√©ra que la position, alors l'√©chantillon vers le fragment est occlus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb7/b9a/f1d/cb7b9af1d4dc613f337da5a253ef5a8c.gif"></div><br>  Ici, vous voyez un espace au-dessus de la surface √©chantillonn√©e pour l'occlusion. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float radius = 1.1; float bias = 0.026; float lowerRange = -2; float upperRange = 2; // ...</span></span></code> </pre> <br>  Comme certaines autres techniques, le shader SSAO a plusieurs param√®tres de contr√¥le qui peuvent √™tre modifi√©s pour obtenir l'apparence souhait√©e.  un biais est ajout√© √† la distance entre l'√©chantillon et la cam√©ra.  Ce param√®tre peut √™tre utilis√© pour lutter contre les taches.  Le rayon augmente ou diminue la zone de couverture de l'espace √©chantillon.  lowerRange et upperRange modifient la plage standard de la m√©trique de facteur de <code>[0, 1]</code> √† n'importe quelle valeur que vous s√©lectionnez.  En augmentant la plage, vous pouvez augmenter le contraste. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 position = texture(positionTexture, texCoord); vec3 normal = texture(normalTexture, texCoord).xyz; int noiseX = int(gl_FragCoord.x - 0.5) % 4; int noiseY = int(gl_FragCoord.y - 0.5) % 4; vec3 random = noise[noiseX + (noiseY * 4)]; // ...</span></span></code> </pre> <br>  Nous obtenons la position, le vecteur normal et al√©atoire pour une utilisation ult√©rieure.  Rappelons que dans l'exemple de code, 16 vecteurs al√©atoires ont √©t√© cr√©√©s.  Un vecteur al√©atoire est s√©lectionn√© en fonction de la position √† l'√©cran des fragments actuels. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 tangent = normalize(random - normal * dot(random, normal)); vec3 binormal = cross(normal, tangent); mat3 tbn = mat3(tangent, binormal, normal); // ...</span></span></code> </pre> <br>  En utilisant un vecteur al√©atoire et un vecteur normal, nous collectons la matrice de la tangente, binormale et normale.  Nous avons besoin de cette matrice pour transformer les vecteurs √©chantillons de l'espace tangent √† l'espace d'enqu√™te. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float occlusion = NUM_SAMPLES; for (int i = 0; i &lt; NUM_SAMPLES; ++i) { // ... } // ...</span></span></code> </pre> <br>  Ayant une matrice, le shader peut parcourir tous les √©chantillons de la boucle, en soustrayant le nombre de non ouverts. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 sample = tbn * samples[i]; sample = position.xyz + sample * radius; // ...</span></span></code> </pre> <br>  √Ä l'aide de la matrice, placez l'√©chantillon √† c√¥t√© de la position du sommet / fragment et mettez-le √† l'√©chelle par le rayon. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 offset = vec4(sample, 1.0); offset = lensProjection * offset; offset.xyz /= offset.w; offset.xyz = offset.xyz * 0.5 + 0.5; // ...</span></span></code> </pre> <br>  En utilisant la position de l'√©chantillon dans l'espace d'observation, nous le transformons de l'espace d'observation √† l'espace d'√©cr√™tage, puis √† l'espace UV. <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">-1</span></span> * <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> * <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  N'oubliez pas que les composants de l'espace d'√©cr√™tage sont compris entre moins un et un, et que les coordonn√©es UV sont comprises entre z√©ro et un.  Pour convertir les coordonn√©es de l'espace d'√©cr√™tage en coordonn√©es UV, multipliez-les par une seconde et ajoutez une seconde. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 offsetPosition = texture(positionTexture, offset.xy); float occluded = 0; if (sample.y + bias &lt;= offsetPosition.y) { occluded = 0; } else { occluded = 1; } // ...</span></span></code> </pre> <br>  En utilisant les coordonn√©es de d√©calage UV obtenues en projetant l'√©chantillon 3D sur la texture de position 2D, nous trouvons le vecteur de position correspondant.  Cela nous am√®ne de l'espace de visualisation √† l'espace de d√©tourage √† l'espace UV, puis de retour √† l'espace de visualisation.  Le shader ex√©cute cette boucle pour d√©terminer s'il existe une g√©om√©trie derri√®re l'√©chantillon, √† l'emplacement de l'√©chantillon ou devant l'√©chantillon.  Si l'√©chantillon est situ√© devant ou dans une certaine g√©om√©trie, cet √©chantillon n'est tout simplement pas pris en compte par rapport au fragment chevauch√©.  Si l'√©chantillon est derri√®re une g√©om√©trie, cet √©chantillon est pris en compte par rapport au fragment chevauch√©. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float intensity = smoothstep ( 0.0 , 1.0 , radius / abs(position.y - offsetPosition.y) ); occluded *= intensity; occlusion -= occluded; // ...</span></span></code> </pre> <br>  Ajoutez maintenant du poids √† cette position √©chantillonn√©e en fonction de sa distance √† l'int√©rieur ou √† l'ext√©rieur du rayon.  Ensuite, soustrayez cet √©chantillon de la m√©trique d'occlusion car cela suppose que tous les √©chantillons se sont chevauch√©s avant la boucle. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... occlusion /= NUM_SAMPLES; // ... fragColor = vec4(vec3(occlusion), position.a); // ...</span></span></code> </pre> <br>  Divisez le nombre de chevauchements par le nombre d'√©chantillons pour convertir l'indicateur d'occlusion de l'intervalle <code>[0, NUM_SAMPLES]</code> √† l'intervalle <code>[0, 1]</code> .  Z√©ro signifie une occlusion compl√®te, les unit√©s signifient aucune occlusion.  Maintenant, affectez la m√©trique d'occlusion √† la couleur du fragment, et c'est tout. <br><br>  Veuillez noter que dans l'exemple de code, le canal alpha se voit attribuer la valeur alpha de la texture de position du tampon de trame pour √©viter le chevauchement de l'arri√®re-plan. <br><br><h3>  Flou </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b1/566/2a7/5b15662a7c46db6b8102fe9eabae17c9.gif"></div><br>  La texture du tampon de trame SSAO est un peu bruyante, vous devez donc la rendre floue pour le lissage. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... for (int i = 0; i &lt; size2; ++i) { x = size - xCount; y = yCount - size; result += texture ( ssaoTexture , texCoord + vec2(x * parameters.x, y * parameters.x) ).rgb; xCount -= 1; if (xCount &lt; countMin) { xCount = countMax; yCount -= 1; } } result = result / size2; // ...</span></span></code> </pre> <br>  Le shader de flou SSAO est un flou de bo√Æte r√©gulier.  Comme le shader de floraison, il dessine une fen√™tre sur la texture entrante et fait la moyenne de chaque fragment avec les valeurs de ses voisins. <br><br>  Notez que <code>parameters.x</code> est un param√®tre de s√©paration. <br><br><h3>  Couleur ambiante </h3><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec2 ssaoBlurTexSize = textureSize(ssaoBlurTexture, 0).xy; vec2 ssaoBlurTexCoord = gl_FragCoord.xy / ssaoBlurTexSize; float ssao = texture(ssaoBlurTexture, ssaoBlurTexCoord).r; vec4 ambient = p3d_Material.ambient * p3d_LightModel.ambient * diffuseTex * ssao; // ...</span></span></code> </pre> <br>  Le dernier d√©fi pour SSAO r√©side √† nouveau dans les calculs d'√©clairage.  Nous voyons ici comment l'occlusion se trouve dans le tampon de texture SSAO de texture et est incluse dans le calcul de la lumi√®re ambiante. <br><br><h3>  Code source </h3><br><ul><li>  <a href="">main.cxx</a> </li><li>  <a href="">base.vert</a> </li><li>  <a href="">basic.vert</a> </li><li>  <a href="">position.frag</a> </li><li>  <a href="">normal.frag</a> </li><li>  <a href="">ssao.frag</a> </li><li>  <a href="">blur.frag</a> </li></ul><br><h2>  Profondeur de champ </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ef/eb0/10f/6efeb010f4623ff49b928d72550f7985.gif"></div><br>  La profondeur de champ est √©galement un tel effet, apr√®s avoir appris lequel, vous ne pouvez pas vous en passer.  D'un point de vue artistique, vous pouvez l'utiliser pour attirer l'attention du spectateur sur un objet sp√©cifique.  Mais dans le cas g√©n√©ral, la profondeur de champ au prix d'un petit effort ajoute une grande part de r√©alisme. <br><br><h3>  En bref </h3><br>  La premi√®re √©tape consiste √† rendre la sc√®ne compl√®tement nette.  Rendez-le √† la texture du tampon d'image.  Ce sera l'une des valeurs d'entr√©e pour la profondeur du tampon de champ. <br><br><h3>  Flou </h3><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 result = vec4(0); for (int i = 0; i &lt; size2; ++i) { x = size - xCount; y = yCount - size; result += texture ( blurTexture , texCoord + vec2(x * parameters.x, y * parameters.x) ); xCount -= 1; if (xCount &lt; countMin) { xCount = countMax; yCount -= 1; } } result = result / size2; // ...</span></span></code> </pre> <br>  La deuxi√®me √©tape consiste √† rendre la sc√®ne floue comme si elle √©tait compl√®tement floue.  Comme avec Bloom et SSAO, vous pouvez utiliser le flou de bo√Æte.  Rendez cette sc√®ne d√©focalis√©e √† la texture du tampon d'image.  Ce sera une autre valeur d'entr√©e pour le shader de profondeur de champ. <br><br>  Notez que <code>parameters.x</code> est un param√®tre de s√©paration. <br><br><h3>  Confusion </h3><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d68/067/83a/d6806783a567c4708d8f13dcb0763f7c.gif"></div><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float focalLengthSharpness = 100; float blurRate = 6; // ...</span></span></code> </pre> <br>  Vous pouvez personnaliser ces options √† votre go√ªt.  <code>focalLengthSharpness</code> affecte la d√©focalisation de la sc√®ne √† la distance focale.  Plus la <code>focalLengthSharpness</code> , plus la sc√®ne sera d√©focalis√©e √† la distance focale.  <code>blurRate</code> affecte la vitesse de flou de la sc√®ne lorsque vous vous √©loignez de la distance focale.  Plus le <code>blurRate</code> flou est petit, moins la sc√®ne sera floue <code>blurRate</code> s'√©loignant du point AF. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 focusColor = texture(focusTexture, texCoord); vec4 outOfFocusColor = texture(outOfFocusTexture, texCoord); // ...</span></span></code> </pre> <br>  Nous aurons besoin de couleurs au point et dans une image d√©focalis√©e. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 position = texture(positionTexture, texCoord); // ...</span></span></code> </pre> <br>  Nous pouvons √©galement avoir besoin de la position du sommet dans l'espace de visualisation.  Vous pouvez r√©appliquer la texture des positions √† partir du tampon de trame utilis√© pour SSAO. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float blur = clamp ( pow ( blurRate , abs(position.y - focalLength.x) ) / focalLengthSharpness , 0 , 1 ); // ... fragColor = mix(focusColor, outOfFocusColor, blur); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et ici, la confusion a lieu. </font><font style="vertical-align: inherit;">Le plus proche </font></font><code>blur</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d'un, plus il utilisera </font></font><code>outOfFocusColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Une valeur de z√©ro </font></font><code>blur</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">signifie que ce fragment est enti√®rement au point. </font><font style="vertical-align: inherit;">Avec </font></font><code>blur &gt;= 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ce fragment est compl√®tement d√©focalis√©.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Code source </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blur.frag</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">depth-of-field.frag</font></font></a> </li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Post√©risation </font></font></h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f18/078/84d/f1807884d79c5c73915ce9adf6ead5cb.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La post√©risation, ou √©chantillonnage des couleurs, est le processus de r√©duction du nombre de couleurs uniques dans une image. </font><font style="vertical-align: inherit;">Vous pouvez utiliser ce shader pour donner au jeu un look comique ou r√©tro. </font><font style="vertical-align: inherit;">Si vous le combinez avec un contour, vous obtenez un vrai style caricatural.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float levels = 8; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez exp√©rimenter avec ce param√®tre. </font><font style="vertical-align: inherit;">Plus il est grand, plus il restera de fleurs.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 texColor = texture(posterizeTexture, texCoord); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous aurons besoin de la couleur entrante. </font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 grey = vec3((texColor.r + texColor.g + texColor.b) / 3.0); vec3 grey1 = grey; grey = floor(grey * levels) / levels; texColor.rgb += (grey - grey1); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je n'ai pas vu une telle m√©thode de post√©risation. </font><font style="vertical-align: inherit;">Apr√®s l'avoir v√©rifi√©, j'ai vu qu'il cr√©e de plus beaux r√©sultats par rapport aux m√©thodes conventionnelles. </font><font style="vertical-align: inherit;">Pour r√©duire la palette de couleurs, convertissez d'abord la couleur en une valeur en niveaux de gris. </font><font style="vertical-align: inherit;">Nous discr√©tisons la couleur en la liant √† l'un des niveaux. </font><font style="vertical-align: inherit;">Nous calculons la diff√©rence entre la valeur discr√©tis√©e en niveaux de gris et la valeur non discr√©tis√©e en niveaux de gris. </font><font style="vertical-align: inherit;">Ajoutez cette diff√©rence √† la couleur d'entr√©e. </font><font style="vertical-align: inherit;">Cette diff√©rence est la quantit√© par laquelle la couleur doit augmenter / diminuer pour obtenir une valeur discr√©tis√©e en niveaux de gris.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... fragColor = texColor; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N'oubliez pas d'attribuer la valeur de la couleur d'entr√©e √† la couleur du fragment. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ombrage cel </font></font></h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d1/f9c/133/2d1f9c1333960c0299388fc51323a8b3.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La post√©risation peut donner √† une image l'apparence de l'ombrage cel, car l'ombrage cel est le processus de discr√©tisation des couleurs diffuses et diffuses en nuances discr√®tes. </font><font style="vertical-align: inherit;">Nous voulons utiliser uniquement des couleurs diffuses solides sans d√©tails fins de la carte normale et une petite valeur </font></font><code>levels</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Code source </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">posterize.frag</font></font></a> </li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pix√©lisation </font></font></h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/396/0b9/9bc/3960b99bc2f1fa900c40a1c9f32169bc.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La pixellisation d'un jeu 3D peut lui donner une apparence int√©ressante, ou vous faire gagner du temps qui aurait √©t√© n√©cessaire pour cr√©er manuellement tout le pixel art. </font><font style="vertical-align: inherit;">Combinez-le avec la post√©risation pour cr√©er un v√©ritable look r√©tro.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... int pixelSize = 5; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez ajuster vous-m√™me la taille des pixels. </font><font style="vertical-align: inherit;">Plus elle est grande, plus l'image sera rugueuse.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/413/818/aee/413818aee5509763cc383f800b837cfb.gif"></div><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float x = int(gl_FragCoord.x) % pixelSize; float y = int(gl_FragCoord.y) % pixelSize; x = floor(pixelSize / 2.0) - x; y = floor(pixelSize / 2.0) - y; x = gl_FragCoord.x + x; y = gl_FragCoord.y + y; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette technique attache chaque fragment au centre de sa fen√™tre de taille de pixel non superpos√©e la plus proche. </font><font style="vertical-align: inherit;">Ces fen√™tres s'alignent au-dessus de la texture entrante. </font><font style="vertical-align: inherit;">Les fragments au centre de la fen√™tre d√©terminent la couleur des autres fragments de leur fen√™tre.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... fragColor = texture(pixelizeTexture, vec2(x, y) / texSize); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apr√®s avoir d√©termin√© les coordonn√©es du fragment souhait√© √† utiliser, prenez sa couleur dans la texture entrante et affectez-la √† la couleur du fragment. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Code source </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pixelize.frag</font></font></a> </li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aiguiser </font></font></h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b52/674/617/b52674617a0733ee1fe0d525b0053750.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'effet de nettet√© (nettet√©) augmente le contraste sur les bords de l'image. </font><font style="vertical-align: inherit;">Il est utile lorsque les graphismes s'av√®rent trop mous.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float amount = 0.8; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En modifiant la valeur, nous pouvons contr√¥ler l'amplitude de la nettet√© du r√©sultat. </font><font style="vertical-align: inherit;">Si la valeur est z√©ro, l'image ne changera pas. </font><font style="vertical-align: inherit;">Avec des valeurs n√©gatives, l'image commence √† para√Ætre √©trange.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float neighbor = amount * -1; float center = amount * 4 + 1; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les fragments adjacents sont multipli√©s par </font></font><code>amount * -1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Le fragment actuel est multipli√© par </font></font><code>amount * 4 + 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 color = texture(sharpenTexture, vec2(gl_FragCoord.x + 0, gl_FragCoord.y + 1) / texSize).rgb * neighbor + texture(sharpenTexture, vec2(gl_FragCoord.x - 1, gl_FragCoord.y + 0) / texSize).rgb * neighbor + texture(sharpenTexture, vec2(gl_FragCoord.x + 0, gl_FragCoord.y + 0) / texSize).rgb * center + texture(sharpenTexture, vec2(gl_FragCoord.x + 1, gl_FragCoord.y + 0) / texSize).rgb * neighbor + texture(sharpenTexture, vec2(gl_FragCoord.x + 0, gl_FragCoord.y - 1) / texSize).rgb * neighbor ; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les fragments voisins sont en haut, en bas, √† gauche et √† droite. </font><font style="vertical-align: inherit;">Apr√®s avoir multipli√© les voisins et le fragment actuel par leurs valeurs, le r√©sultat est additionn√©.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... fragColor = vec4(color, texture(sharpenTexture, texCoord).a); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cette quantit√© est la couleur finale du fragment. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Code source </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sharpen.frag</font></font></a> </li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Grain de film </font></font></h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f3/16e/232/2f316e232598d07fa8114f8db32c12a7.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le grain du film (√† petites doses, et pas comme dans l'exemple) peut ajouter du r√©alisme, qui est invisible jusqu'√† ce que cet effet soit supprim√©. </font><font style="vertical-align: inherit;">Ce sont g√©n√©ralement les imperfections qui rendent l'image g√©n√©r√©e num√©riquement plus convaincante. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notez que le grain du film est g√©n√©ralement le dernier effet appliqu√© au cadre avant d'√™tre affich√©.</font></font><br><br><h3>  Valeur </h3><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float amount = 0.1; // ...</span></span></code> </pre> <br> <code>amount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contr√¥le la visibilit√© du grain du film. </font><font style="vertical-align: inherit;">Plus la valeur est √©lev√©e, plus il y a de ¬´neige¬ª sur l'image.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Luminosit√© al√©atoire </font></font></h3><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform float osg_FrameTime; //... float toRadians = 3.14 / 180; //... float randomIntensity = fract ( 10000 * sin ( ( gl_FragCoord.x + gl_FragCoord.y * osg_FrameTime ) * toRadians ) ); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ce morceau de code calcule la luminosit√© al√©atoire n√©cessaire pour ajuster la valeur. </font></font><br><br><pre> <code class="cpp hljs">Time Since F1 = <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">01</span></span> <span class="hljs-number"><span class="hljs-number">02</span></span> <span class="hljs-number"><span class="hljs-number">03</span></span> <span class="hljs-number"><span class="hljs-number">04</span></span> <span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">06</span></span> <span class="hljs-number"><span class="hljs-number">07</span></span> <span class="hljs-number"><span class="hljs-number">08</span></span> <span class="hljs-number"><span class="hljs-number">09</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> Frame Number = F1 F3 F4 F5 F6 osg_FrameTime = <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">02</span></span> <span class="hljs-number"><span class="hljs-number">04</span></span> <span class="hljs-number"><span class="hljs-number">07</span></span> <span class="hljs-number"><span class="hljs-number">08</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Valeur </font></font><code>osg_FrameTime</code> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fournie par</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Panda3D. </font><font style="vertical-align: inherit;">Un temps d'image est un horodatage contenant des informations sur le nombre de secondes √©coul√©es depuis la premi√®re image. </font><font style="vertical-align: inherit;">L'exemple de code l'utilise pour animer le grain du film, qui </font></font><code>osg_FrameTime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sera diff√©rent dans chaque image.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... ( gl_FragCoord.x + gl_FragCoord.y * 8009 // Large number here. // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour les grains statiques, les films doivent √™tre remplac√©s par un </font></font><code>osg_FrameTime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">grand nombre. </font><font style="vertical-align: inherit;">Pour √©viter de voir des mod√®les, vous pouvez essayer diff√©rents nombres.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/358/2bd/6d2/3582bd6d2d67eb5ac1fdcdf8d52800e6.gif"></div><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... * sin ( ( gl_FragCoord.x + gl_FragCoord.y * someNumber // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour cr√©er des points ou des taches de grain de film, les coordonn√©es, x et y sont utilis√©es. </font><font style="vertical-align: inherit;">Si vous utilisez x, seules les lignes verticales seront affich√©es, si vous utilisez y, seules les lignes horizontales seront affich√©es. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans le code, une coordonn√©e est multipli√©e par une autre pour d√©truire la sym√©trie diagonale.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c0/ad6/d5a/4c0ad6d5ada5d533b6dc31bbfa7aa0fc.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien s√ªr, vous pouvez vous d√©barrasser du multiplicateur de coordonn√©es et obtenir un effet de pluie tout √† fait acceptable. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notez que pour animer l'effet pluie, multipliez la sortie </font></font><code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par </font></font><code>osg_FrameTime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exp√©rimentez avec les coordonn√©es x et y pour changer la direction de la pluie. </font><font style="vertical-align: inherit;">Pour une douche descendante, ne laissez que la coordonn√©e x.</font></font><br><br><pre> <code class="cpp hljs">input = (gl_FragCoord.x + gl_FragCoord.y * osg_FrameTime) * toRadians frame(<span class="hljs-number"><span class="hljs-number">10000</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(input)) = fract(<span class="hljs-number"><span class="hljs-number">10000</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(<span class="hljs-number"><span class="hljs-number">6.977777777777778</span></span>)) = fract(<span class="hljs-number"><span class="hljs-number">10000</span></span> * <span class="hljs-number"><span class="hljs-number">0.6400723818964882</span></span>) =</code> </pre> <br> <code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilis√© comme fonction de hachage. </font><font style="vertical-align: inherit;">Les coordonn√©es des fragments sont hach√©es avec les valeurs de sortie </font></font><code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Gr√¢ce √† cela, une propri√©t√© pratique appara√Æt - quelles que soient les donn√©es d'entr√©e (grandes ou petites), l'intervalle de sortie sera compris entre moins un et un.</font></font><br><br><pre> <code class="cpp hljs">fract(<span class="hljs-number"><span class="hljs-number">10000</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(<span class="hljs-number"><span class="hljs-number">6.977777777777778</span></span>)) = fract(<span class="hljs-number"><span class="hljs-number">10000</span></span> * <span class="hljs-number"><span class="hljs-number">0.6400723818964882</span></span>) = fract(<span class="hljs-number"><span class="hljs-number">6400.723818964882</span></span>) = <span class="hljs-number"><span class="hljs-number">0.723818964882</span></span></code> </pre> <br> <code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en combinaison avec </font></font><code>fract</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√©galement utilis√© comme g√©n√©rateur de nombres pseudo al√©atoires.</font></font><br><br><pre> <code class="cpp hljs">&gt;&gt;&gt; [<span class="hljs-built_in"><span class="hljs-built_in">floor</span></span>(fract(<span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(x * toRadians)) * <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">for</span></span></span><span class="hljs-function"> x in </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">range</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">] [0, 0, 1, 2, 2, 3, 4, 4, 5, 6] &gt;&gt;&gt; [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">floor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fract(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10000</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">sin</span></span></span></span><span class="hljs-function"><span class="hljs-params">(x * toRadians)) * </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">for</span></span></span><span class="hljs-function"> x in </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">range</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">] [0, 4, 8, 0, 2, 1, 7, 0, 0, 5]</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regardez d'abord la premi√®re rang√©e de chiffres, puis la seconde. </font><font style="vertical-align: inherit;">Chaque ligne est d√©terministe, mais le motif est moins visible dans la seconde que dans la seconde. </font><font style="vertical-align: inherit;">Par cons√©quent, malgr√© le fait que la sortie est </font></font><code>fract(10000 * sin(...))</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©terministe, le mod√®le est reconnu beaucoup plus faible.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b88/6e7/f0f/b886e7f0feda6760c5fc87df6680680f.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ici, nous voyons comment le facteur </font></font><code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est d'abord 1, puis 10, puis 100, puis 1000. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque le multiplicateur des valeurs de sortie augmente, le </font></font><code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mod√®le devient moins perceptible. </font><font style="vertical-align: inherit;">Pour cette raison, le code </font></font><code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est multipli√© par 10 000.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Couleur du fragment </font></font></h3><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec2 texSize = textureSize(filmGrainTexture, 0).xy; vec2 texCoord = gl_FragCoord.xy / texSize; vec4 color = texture(filmGrainTexture, texCoord); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Convertissez les coordonn√©es du fragment en coordonn√©es UV. </font><font style="vertical-align: inherit;">En utilisant ces coordonn√©es UV, nous recherchons la couleur de texture pour le fragment actuel.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... amount *= randomIntensity; color.rgb += amount; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modifiez la valeur en une luminosit√© al√©atoire et ajoutez-la √† la couleur. </font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... fragColor = color; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> D√©finissez la couleur du fragment, et c'est tout. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Code source </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">film-grain.frag</font></font></a> </li></ul><br><h2>  Remerciements </h2><br><ul><li>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Kiwi Soda Font</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr453692/">https://habr.com/ru/post/fr453692/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr453676/index.html">Connexion √† Windows via SSH comme sous Linux</a></li>
<li><a href="../fr453678/index.html">Comment voir la r√©verb√©ration ou la transmission vid√©o par le son dans l'eau - 2</a></li>
<li><a href="../fr453682/index.html">D√©veloppement du ¬´firmware¬ª le plus simple pour les FPGA install√©s dans Redd. Partie 2. Code de programme</a></li>
<li><a href="../fr453686/index.html">Semaine de la s√©curit√© 22: statistiques sur les menaces, chevaux de Troie bancaires et exploits populaires</a></li>
<li><a href="../fr453688/index.html">Java n'est pas seulement une entreprise sanglante, mais aussi des applications sensibles √† la latence rapide</a></li>
<li><a href="../fr453694/index.html">Connectez-vous √† Windows via SSH comme sous Linux</a></li>
<li><a href="../fr453696/index.html">Reliure angulaire bidirectionnelle, un peu plus de compr√©hension</a></li>
<li><a href="../fr453698/index.html">L'information quantique dans la conscience quantique</a></li>
<li><a href="../fr453700/index.html">Le√ßons sur SDL 2: Le√ßon 1 - Bonjour, SDL 2</a></li>
<li><a href="../fr453706/index.html">Comment j'ai r√©ussi l'examen de certification Google Cloud Professional Data Engineer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>