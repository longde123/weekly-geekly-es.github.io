<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚝 🥠 🧚🏼 具有高级身份验证和授权的OpenVPN 👨‍🎨 👩 🤙🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="本文讨论了具有其他功能的OpenVPN的配置： 



- 用于主要身份验证的令牌证书（以Rutoken为例） 
- 用于辅助身份验证的LDAP后端（以ActiveDirectory为例） 
- 过滤用户可用的内部资源（通过iptables） 
 它还描述了如何为Linux，Windows和MacO...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>具有高级身份验证和授权的OpenVPN</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433250/"> 本文讨论了具有其他功能的OpenVPN的配置： <br><br><ul><li> 用于主要身份验证的令牌证书（以Rutoken为例） </li><li> 用于辅助身份验证的LDAP后端（以ActiveDirectory为例） </li><li> 过滤用户可用的内部资源（通过iptables） </li></ul><br> 它还描述了如何为Linux，Windows和MacOS配置客户端。 <br><a name="habracut"></a><br><h3> 服务器设置 </h3><br><h4> 安装OpenVPN </h4><br> 以脚本<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Nyr / openvpn-install</a> ，从根目录运行。 <br><br><pre><code class="plaintext hljs">git clone https://github.com/Nyr/openvpn-install.git cd openvpn-install</code> </pre> <br> 启动过程将询问一些问题。 <br><br><ul><li>  udp协议 </li><li>  1194端口 </li><li>  DNS服务器-本地 </li><li> 外部ip-Internet上的网关地址，通过该网关可以使用vpn服务器 </li></ul><br> 原始脚本还有一个增强安全性的版本<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-github.com/Angristan/OpenVPN-install</a> 。 它具有更多的加密设置以及原因说明。 <br><br><h4> 用户管理 </h4><br>  <b>新增中</b> <br> 如果不使用令牌，则通过相同的脚本添加用户。 该脚本实质上会生成一个自定义的ovpn配置，并在其中插入由根证书签名的证书。 <br><br> 如果使用了令牌（请参阅下面的令牌部分），那么将根据对令牌生成的证书请求，手动将证书写出。 用户配置必须从现有模板（从生成配置脚本的模板）中手动完成。 模板在这里<code>/etc/openvpn/client-common.txt</code> 。 它不包含在openvpn软件包中，而是由脚本在配置过程中生成的。 <br><br>  <b>删掉</b> <br> 删除用户是通过相同的安装脚本完成的。 证书被添加到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CRL</a> ，新的CRL被推送到vpn服务器。 服务器认为CRL中的所有证书均无效，并拒绝接受。 <br><br> 如何手动吊销证书： <br><br><pre> <code class="plaintext hljs">cd /etc/openvpn/easyrsa #   ./easyrsa revoke $CLIENT #   crl ./easyrsa gen-crl #   crl rm -rf /etc/openvpn/crl.pem #    cp /etc/openvpn/easy-rsa/pki/crl.pem /etc/openvpn/crl.pem # openvpn    crl,       nobody chown nobody:nobody /etc/openvpn/crl.pem</code> </pre><br><h4> 筛选客户端可用的主机 </h4><br> 客户端需要受它们连接到openvpn时可以在网络上访问的主机的限制。 <br><br>  <b>手动地</b> <br><br> 这个想法是即使在<code>tun0</code>接口上也要捕获数据包，这些数据包来自客户端，并在进入NAT之前对其进行过滤。 进行NAT之后，将没有理由对其进行过滤-它们在内部网络上都将具有openvpn服务器ip地址。 在进入NAT之前，每个用户的数据包都有自己唯一的ip地址（有关ip地址和用户的对应关系，请参见文件<code>/etc/openvpn/ipp.txt</code> ）。 <br><br> 穿过系统的数据包（不是直接来自系统，也不是传入的，也就是说，实际上是由系统路由）由FORWARD表处理。  iptables中的表是从上到下处理的，如果表中的任何规则都没有导致有关数据包命运的决定，那么将触发默认规则。 <br><br> 准备FORWARD表： <br><br><pre> <code class="plaintext hljs">#   iptables -F FORWARD #     FORWARD -    iptables -P FORWARD DROP #     iptables -I FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPT</code> </pre><br> 特定客户的示例规则。 由于该表的默认规则是DRO​​P，因此仅保留它允许的主机+端口对。 允许访问主机上的端口+ ping主机本身： <br><br><pre> <code class="plaintext hljs">iptables -I FORWARD -s 10.8.0.3 -i tun0 -d 10.0.2.3 -p tcp --dport 443 -j ACCEPT iptables -I FORWARD -s 10.8.0.3 -i tun0 -d 10.0.2.3 -p icmp --icmp-type echo-request -j ACCEPT</code> </pre><br> 在上面的示例中，主机10.8.0.3被允许访问主机10.0.2.3的端口443。 <br><br> 如何关闭访问权限： <br><br><pre> <code class="plaintext hljs">#         iptables -L FORWARD --line-numbers #     iptables -D FORWARD { }</code> </pre><br> 然后，您需要找到特定客户端的所有规则并将其删除。 <br><br> 在调试过程中，可以方便地查看哪些规则有效。 每个规则都有一个已处理数据包的计数器。 <br><br><pre> <code class="plaintext hljs">#  ,      watch iptables -nvL FORWARD #     iptables -Z FORWARD</code> </pre><br>  <b>自动地</b> <br><br>  OpenVPN服务器可以执行某些动作的脚本。 特别是在连接和断开客户端时。 只要脚本是可执行的，脚本就可以写在任何东西上。 在脚本内部，环境变量将各种参数传递给当前连接。 我们对变量感兴趣： <br><br><ul><li>  <code>common_name</code> （证书所有者的名称；创建证书时驱动到“通用名称”字段的内容） </li><li>  <code>ifconfig_pool_remote_ip</code> （tun0上的客户端IP地址） </li><li>  <code>script_type</code> （发生了哪个事件-连接或断开连接）。 </li></ul><br> 您需要root特权才能管理iptables。 连接后的Openvpn会将权限重置为无人，并从中运行脚本。 不允许任何人从sudo下做某事是很不好的，最好不要在规则中使用星号，但是您需要以某种方式允许用户控制iptables。 <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># /etc/sudoers.d/50_openvpn # #    nobody ALL = NOPASSWD: /sbin/iptables -A FORWARD* #     nobody ALL = NOPASSWD: /sbin/iptables -L FORWARD* #    nobody ALL = NOPASSWD: /sbin/iptables -D FORWARD*</span></span></code> </pre><br> 在服务器配置中，您需要添加权限以执行第三方文件，并启用两个负责连接和断开用户连接的钩子。 <br><br><pre> <code class="bash hljs">script-security 2 client-connect /etc/openvpn/bin/hosts.rb client-disconnect /etc/openvpn/bin/hosts.rb</code> </pre><br> 该脚本本身读取配置并为iptables应用规则。 该脚本的工作原理与上一节中所述的相同。 <br><br><div class="spoiler">  <b class="spoiler_title">/openvpn/bin/hosts.rb</b> <div class="spoiler_text"><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/ruby # -*- coding: utf-8 -*- require 'pp' def log(string) puts 'hosts.rb: ' + string end def parse_config_file(name) config_path = "hosts/#{name}" unless File.exist?(config_path) puts "There is no specific configuration for #{name}." p name exit 0 end config_source = IO.read(config_path).split("\n") config = config_source.inject([]) do |result,line| ip, port, protocol = line.split(/\s+/) result &lt;&lt; { ip: ip, port: port, protocol: protocol || 'tcp' } end end def get_config(name) user_config = parse_config_file(name) if user_config everybody_config = parse_config_file('everybody') end everybody_config + user_config end def apply_rule(rule) command = "sudo iptables #{rule}" log(command) system(command) end def remove_rule(number) command = "sudo iptables -D FORWARD #{number}" log(command) system(command) end def allow_target(source_ip, options) #         . apply_rule("-A FORWARD -s #{source_ip} -i tun0 -d #{options[:ip]} -p #{options[:protocol]} --dport #{options[:port]} -j ACCEPT") #       apply_rule("-A FORWARD -s #{source_ip} -i tun0 -d #{options[:ip]} -p icmp --icmp-type echo-request -j ACCEPT") end def clear_targets(source_ip) #      FORWARD,  source_ip. rules_exist = true while rules_exist table = `sudo iptables -L FORWARD --line-number`.split("\n") the_line = table.find do |line| fields = line.split(/\s+/) ip = fields[4] ip == source_ip end if the_line number = the_line.split(/\s+/)[0] remove_rule(number) else rules_exist = false end end end ################################################################################ script_type = ENV['script_type'] log(script_type) name = ENV['common_name'] source_ip = ENV['ifconfig_pool_remote_ip'] case script_type when 'client-connect' config = get_config(name) config.each{|target| allow_target(source_ip, target)} when 'client-disconnect' clear_targets(source_ip) else puts "Unknown script type #{script_type}." end</span></span></code> </pre></div></div><br> 规则存储在与<code>/etc/openvpn/hosts</code>文件夹中的证书的通用名称相对应的文件中。 它们准确地指定了特定客户端可以使用的IP地址。 分隔符-任意数量的空格。  IP地址，端口和协议（tcp或udp）通过分隔符写入。 <br><br><pre> <code class="bash hljs">10.0.0.24 53 udp 10.0.0.25 53 udp 10.0.2.3 443 tcp</code> </pre><br> 结果，以下结构应<code>/etc/openvpn</code>在<code>/etc/openvpn</code>文件夹中 <br><br>  ├──箱 <br>  │└──hosts.rb <br>  ├──房东 <br>  │├──用户1 <br>  │├──user2 <br>  │└──大家 <br>  ├──server.conf <br>  └──... <br><br>  <code>User1</code>和<code>user2</code>是上述格式的文件。 它们描述了具有相应公共名称的用户可以访问的主机。 <br><br> 还有另一个附加的<code>everybody</code>文件，它包含适用于所有客户端的规则，前提是这些客户端有单独的配置文件。 也就是说，如果用户有一个可以访问的主机列表，则将应用此列表以及<code>everybody</code>人中列出的那些主机。 如果没有，那么<code>everybody</code>都不适用。 例如，将DNS服务器放置在此文件中非常方便。 <br><br>  <b>记录中</b> <br><br> 安装脚本仅包括当前连接的日志记录（ <code>status)</code>参数<code>status)</code> 。 为了显示常规日志，您需要在服务器配置（ <code>/etc/openvpn/server.conf</code> ）中添加<code>/etc/openvpn/server.conf</code> ： <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">log</span></span>-append /var/<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>/openvpn.log</code> </pre> <br><br>  <b>LDAP</b> <br><br> 有一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">openvpn-auth-ldap</a>插件，可让您通过LDAP再次验证用户身份。 <br><br> 交付包裹： <br><br><pre> <code class="plaintext hljs">sudo yum install openvpn-auth-ldap</code> </pre> <br> 添加到server.conf： <br><br><pre> <code class="plaintext hljs">plugin /usr/lib64/openvpn/plugin/lib/openvpn-auth-ldap.so "/etc/openvpn/ldap.conf"</code> </pre> <br> 在<code>/etc/openvpn/ldap.conf</code>为ldap创建一个配置： <br><pre> <code class="plaintext hljs">&lt;LDAP&gt; URL ldaps://{LDAP_DOMAIN_HERE} Timeout 15 TLSEnable no FollowReferrals yes BindDN "BIND_DN_HERE" Password "BIND_PASSWORD_HERE" &lt;/LDAP&gt; &lt;Authorization&gt; BaseDN "{BASE_DN_HERE}" SearchFilter "(&amp;(sAMAccountName=%u)(objectClass=organizationalPerson)(objectCategory=person)(!(userAccountControl:1.2.840.113556.1.4.803:=2)))" RequireGroup false &lt;/Authorization&gt;</code> </pre><br> 将行添加到自定义ovpn配置中： <br><br><pre> <code class="plaintext hljs">auth-user-pass</code> </pre> <br> 因此，首先将要求用户从域中输入用户名和密码，然后是来自令牌的PIN。 如果这些步骤之一失败，将不会建立连接。 <br><br>  ldap.conf的选项描述<a href="">在插件存储库中</a> 。 它支持通过组成员身份进行身份验证，但我尚未对其进行测试。 <br><br><h4> 速度 </h4><br> 速度的最大提高使udp模式成为可能。 在所有手册中都建议这样做。 关键是，在TCP通道中启动TCP客户端连接没有任何意义。 客户端一个TCP就足以正确发送数据包。 如果数据包在udp通道中丢失，则客户端tcp连接将控制传递调整。 <br><br> 速度至少会提高，因为不需要等待确认通道中每个数据包的传递。  TCP存在第二个问题-一个客户端tcp数据包很可能不适合vpn通道的一个数据包。  MTU相同，但是需要将标头添加到客户端程序包。 结果，您必须在每个用户数据包的vpn通道内发送两个数据包。 <br><br> 如果无法通过其他方式使用TCP，则可以使用。 例如，当vpn通过ssh通道工作时。 <br><br><h4> 完整服务器配置的示例 </h4><br><div class="spoiler">  <b class="spoiler_title">example-server.conf</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">port 1194 proto tcp dev tun sndbuf 0 rcvbuf 0 ca ca.crt cert server.crt key server.key dh dh.pem tls-auth ta.key 0 topology subnet server 10.8.0.0 255.255.255.0 ifconfig-pool-persist ipp.txt push "redirect-gateway def1 bypass-dhcp" push "dhcp-option DNS 10.0.0.25" push "dhcp-option DNS 10.0.0.24" keepalive 10 120 cipher AES-256-CBC comp-lzo user nobody group nobody persist-key persist-tun status openvpn-status.log verb 3 crl-verify crl.pem log-append /var/log/openvpn.log script-security 2 client-connect /etc/openvpn/bin/hosts.rb client-disconnect /etc/openvpn/bin/hosts.rb</code> </pre><br></div></div><br><h3> 代币设置 </h3><br><h4>  PKCS＃11库 </h4><br> 要使用令牌，您需要一个特殊的库。 创建密钥对和实际连接都需要该库。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">通过链接下载所有平台</a> 。 <br><br> 以后无论在哪里找到librtpkcs11ecp.so，这都是一个需要下载的库，并将其放在方便的地方。 <br><br><h4> 在令牌上创建证书 </h4><br> 在令牌上生成密钥对。 这里的id参数是密钥对适合的令牌上插槽的序列号。 <br><br><pre> <code class="plaintext hljs">pkcs11-tool --module /usr/lib64/librtpkcs11ecp.so --keypairgen --key-type rsa:2048 -l --id 01</code> </pre><br> 提出公共密钥证书请求。 在创建证书请求的过程中，将设置证书的生存期和通用名称，该名称和名称用于过滤网络中的可用ip地址。 公用名必须与ActiveDirectory中的登录名匹配，以免造成混淆。 <br><br><pre> <code class="plaintext hljs">openssl openssl&gt; engine -t dynamic -pre SO_PATH:/usr/lib64/openssl/engines/pkcs11.so -pre ID:pkcs11 -pre LIST_ADD:1 -pre LOAD -pre MODULE_PATH:/usr/lib64/librtpkcs11ecp.so openssl&gt; req -engine pkcs11 -new -key slot_0-id_01 -keyform engine -out /home/john/good.req</code> </pre><br> 收到的请求必须移至<code>/etc/openvpn/easy-rsa/pki/reqs/</code> 。 文件扩展名必须为<code>req</code> 。 <br> 将请求转换为证书： <br><br><pre> <code class="plaintext hljs">cd /etc/openvpn/easy-rsa/ ./easyrsa sign-req client good</code> </pre><br> 之后，具有相同名称但扩展名为<code>crt</code>的证书将出现在<code>/etc/openvpn/easy-rsa/pki/issued/</code>文件夹中。 <br><br> 在记录之前，必须将证书转换为DER： <br><br><pre> <code class="plaintext hljs">openssl x509 -in /home/user/user-cert.pem -out /home/user/user-cert.crt -outform DER</code> </pre><br> 为令牌编写证书： <br><br><pre> <code class="plaintext hljs">pkcs11-tool --module /usr/lib/librtpkcs11ecp.so -l -y cert -w /home/user/user-cert.crt --id 45 --label TEST</code> </pre> <br> 它是根据<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“将Rutoken EDS与OpenSSL（RSA）结合使用”</a>一文编写的。 <br><br><h4> 使用令牌进行身份验证 </h4><br> 找到要提供给服务器的证书的ID： <br><br><pre> <code class="plaintext hljs">$ openvpn --show-pkcs11-ids /usr/lib64/librtpkcs11ecp.so The following objects are available for use. Each object shown below may be used as parameter to --pkcs11-id option please remember to use single quote mark. Certificate DN: /CN=User1 Serial: 490B82C4000000000075 Serialized id: aaaa/bbb/41545F5349474E415455524581D2A1A1B23C4AA4CB17FAF7A4600</code> </pre><br> 我们对这里的序列化ID感兴趣。 <br><br> 必须在ovpn配置中输入的选项，以便令牌可以使用： <br><br><pre> <code class="plaintext hljs">pkcs11-providers /usr/lib64/librtpkcs11ecp.so pkcs11-id 'aaaa/bbb/41545F5349474E415455524581D2A1A1B23C4AA4CB17FAF7A4600'</code> </pre> <br>  <code>pkcs11-id</code>选项<b>必须用单引号引起来。</b> <br><br> 本手册适用于所有平台。 您需要在标记上指定库的路径和证书ID。 该库的名称可能有所不同，即<code>.dll</code>而不是<code>.so</code> ，但含义相同。 <br><br> 在这种情况下，您需要从ovpn文件中删除<code>cert</code>和<code>key</code>部分，因为证书和私钥将从令牌中获取。 <br><br> 完整的客户端配置（对于Windows）如下所示： <br><br><div class="spoiler">  <b class="spoiler_title">客户程序</b> <div class="spoiler_text"> <code>client <br> dev tun <br> proto tcp <br> sndbuf 0 <br> rcvbuf 0 <br> remote 78.47.37.247 22222 <br> resolv-retry infinite <br> nobind <br> persist-key <br> persist-tun <br> remote-cert-tls server <br> cipher AES-256-CBC <br> comp-lzo <br> setenv opt block-outside-dns <br> key-direction 1 <br> verb 3 <br> <br> pkcs11-providers "c://Windows//System32//rtPKCS11ECP.dll" <br> pkcs11-id 'Aktiv\x20Co\x2E/Rutoken\x20ECP/342b871d/Rutoken/01' <br> <br> -----BEGIN CERTIFICATE----- <br> {CERT_HERE} <br> -----END CERTIFICATE----- <br> <br> <br> &lt;tls-auth&gt; <br> # <br> # 2048 bit OpenVPN static key <br> # <br> -----BEGIN OpenVPN Static key V1----- <br> {KEY_HERE} <br> -----END OpenVPN Static key V1----- <br> &lt;/tls-auth&gt;</code> <br> </div></div><br> 基于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“如何使用客户端智能卡向OpenVPN配置添加双因素身份验证”</a>撰写。 <br><br><h3> 客户设置 </h3><br><h4> 的Linux </h4><br>  Openvpn有一个错误，如果该程序包是在systemd支持下构建的，则阻止用户从令牌中输入PIN码。 由于systemd最近无处不在，因此存储库中所有可用的软件包都将在其支持下进行编译。  Linux上的客户端需要自行收集软件包。 这是在Arch Linux上为我工作的示例配置： <br><br><pre> <code class="plaintext hljs">./configure \ --prefix=/usr \ --sbindir=/usr/bin \ --enable-iproute2 \ --enable-pkcs11 \ --enable-plugins \ --enable-x509-alt-username</code> </pre><br> 您可以使用以下命令验证openvpn是使用systemd或不使用systemd构建的： <br><br><pre> <code class="plaintext hljs">openvpn --version | grep --color enable_systemd</code> </pre><br><h4> 马索斯 </h4><br> 在Mac OS下，只有一个免费客户端<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-Tunnelblink</a> 。 <br><br> 他不知道如何从gui令牌输入密码。 该错误的描述示例如下： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https:</a> //groups.google.com/forum/#! <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">topic/</a> tunnelblick-discuss/f_Rp_2nV-x8从控制台启动openvpn可以绕过此错误。 鉴于Windows的官方客户端也不知道这一点，因此这并不奇怪。 <br><br> 同样在Mac OS（不同于Windows）下，还需要其他脚本来配置网络。 如果仅从控制台运行openvpn，则DNS将不起作用（也许其他原因，仅DNS将出现）。 <br><br>  TunnelBlick具有这些网络配置脚本，仅在建立和断开连接时才需要调用它们。 您需要添加到ovpn配置的内容： <br><br><pre> <code class="bash hljs">script-security 2 up <span class="hljs-string"><span class="hljs-string">"/Applications/Tunnelblick.app/Contents/Resources/client.up.tunnelblick.sh -9 -d -f -m -w -ptADGNWradsgnw"</span></span> down <span class="hljs-string"><span class="hljs-string">"/Applications/Tunnelblick.app/Contents/Resources/client.down.tunnelblick.sh -9 -d -f -m -w -ptADGNWradsgnw"</span></span></code> </pre> <br> 用于启动openvpn连接的示例脚本，可以将其放在桌面上并用鼠标戳一下： <br><br><pre> <code class="plaintext hljs">#!/bin/bash tunnelblick=/Applications/Tunnelblick.app/Contents/Resources/openvpn/openvpn-2.4.2-openssl-1.0.2k sudo $tunnelblick/openvpn --config $tunnelblick/user.ovpn</code> </pre><br><h4> 窗户 </h4><br> 在Windows下，一切似乎正常。 官方客户端不知道如何从令牌输入PIN码，而是设法从控制台手动打开vpn。 <br><br> 最重要的事情是从管理员那里做所有事情。 以管理员身份运行客户端安装程序。 启动同时具有管理员权限的openvpn启动终端，否则它将无法控制网络接口。 <br><br> 在Windows下，用于处理令牌的库的路径应通过双斜杠记录。 这适用于命令行上的ovpn配置和<code>--show-pkcs11-ids</code>选项。 <br><br><pre> <code class="bash hljs">pkcs11-providers <span class="hljs-string"><span class="hljs-string">"c://Windows//System32//rtPKCS11ECP.dll"</span></span> pkcs11-id <span class="hljs-string"><span class="hljs-string">'Aktiv\x20Co\x2E/Rutoken\x20ECP/342b871d/Rutoken/01'</span></span></code> </pre></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN433250/">https://habr.com/ru/post/zh-CN433250/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN433234/index.html">需要一个完美的保姆； 确保进行AI扫描以评估尊重和良好的举止</a></li>
<li><a href="../zh-CN433236/index.html">Google负责人认为，对AI的恐惧“完全有道理”</a></li>
<li><a href="../zh-CN433242/index.html">毒面具</a></li>
<li><a href="../zh-CN433246/index.html">框架：DLT系统分析</a></li>
<li><a href="../zh-CN433248/index.html">使用OtterCTF解析内存取证并引入波动性框架</a></li>
<li><a href="../zh-CN433252/index.html">涡轮喷气混合动力直升机上的人体模特</a></li>
<li><a href="../zh-CN433254/index.html">我们只是在与死亡作斗争，你呢？ 或开发神奇药物的公司</a></li>
<li><a href="../zh-CN433256/index.html">用Flutter进行UI开发</a></li>
<li><a href="../zh-CN433258/index.html">您甚至可以在欧洲购买电子元器件。 在保加利亚的Mouser购物体验</a></li>
<li><a href="../zh-CN433260/index.html">周末阅读：有关使用PD的材料，数据中心中铁的评论以及IaaS提供商的“厨房”</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>