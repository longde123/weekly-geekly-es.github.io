<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📹 🛑 🥖 JavaScript: Objekte erkunden 🤚🏻 👨🏼‍🍳 🐣</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Material, dessen Übersetzung wir heute veröffentlichen, ist dem Studium von Objekten gewidmet - einer der Schlüsselessenzen von JavaScript. Es ric...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript: Objekte erkunden</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/420615/">  Das Material, dessen Übersetzung wir heute veröffentlichen, ist dem Studium von Objekten gewidmet - einer der Schlüsselessenzen von JavaScript.  Es richtet sich in erster Linie an Anfänger, die ihr Wissen über Objekte optimieren möchten. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/vo/lg/xb/volgxbgclrhdnqvvi_qdqfc1yna.jpeg"></a> <br><br>  Objekte in JavaScript sind dynamische Sammlungen von Eigenschaften, die zusätzlich eine „versteckte“ Eigenschaft enthalten, die ein Prototyp des Objekts ist.  Eigenschaften von Objekten sind durch Schlüssel und Werte gekennzeichnet.  Beginnen wir die Konversation über JS-Objekte mit Schlüsseln. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Objekteigenschaftsschlüssel</font> </h2><br>  Der Objekteigenschaftsschlüssel ist eine eindeutige Zeichenfolge.  Sie können zwei Methoden verwenden, um auf Eigenschaften zuzugreifen: Zugriff über einen Punkt und Angabe des Objektschlüssels in eckigen Klammern.  Beim Zugriff auf Eigenschaften über einen Punkt muss der Schlüssel eine gültige JavaScript-Kennung sein.  Betrachten Sie ein Beispiel: <br><br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">let</span></span> obj = {  <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> : <span class="hljs-string"><span class="hljs-string">"A message"</span></span> } obj.message //<span class="hljs-string"><span class="hljs-string">"A message"</span></span> obj[<span class="hljs-string"><span class="hljs-string">"message"</span></span>] //<span class="hljs-string"><span class="hljs-string">"A message"</span></span></code> </pre> <br>  Beim Versuch, auf eine nicht vorhandene Eigenschaft eines Objekts zuzugreifen, wird keine Fehlermeldung angezeigt, aber der <code>undefined</code> Wert wird zurückgegeben: <br><br><pre> <code class="hljs objectivec">obj.otherProperty <span class="hljs-comment"><span class="hljs-comment">//undefined</span></span></code> </pre> <br>  Wenn Sie in eckigen Klammern auf Eigenschaften zugreifen, können Sie Schlüssel verwenden, die keine gültigen JavaScript-Bezeichner sind (der Schlüssel kann beispielsweise eine Zeichenfolge sein, die Leerzeichen enthält).  Sie können einen beliebigen Wert haben, der in eine Zeichenfolge umgewandelt werden kann: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> french = {}; french[<span class="hljs-string"><span class="hljs-string">"merci beaucoup"</span></span>] = <span class="hljs-string"><span class="hljs-string">"thank you very much"</span></span>; french[<span class="hljs-string"><span class="hljs-string">"merci beaucoup"</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//"thank you very much"</span></span></code> </pre> <br>  Wenn Nicht-String-Werte als Schlüssel verwendet werden, werden sie automatisch in Strings konvertiert (wenn möglich mit der <code>toString()</code> -Methode): <br><br><pre> <code class="hljs powershell">et obj = {}; //Number obj[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-string"><span class="hljs-string">"Number 1"</span></span>; obj[<span class="hljs-number"><span class="hljs-number">1</span></span>] === obj[<span class="hljs-string"><span class="hljs-string">"1"</span></span>]; //true //Object let number1 = { toString : function() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"1"</span></span>; } } obj[<span class="hljs-type"><span class="hljs-type">number1</span></span>] === obj[<span class="hljs-string"><span class="hljs-string">"1"</span></span>]; //true</code> </pre> <br>  In diesem Beispiel wird das Objekt <code>number1</code> als Schlüssel verwendet.  Beim Versuch, auf eine Eigenschaft zuzugreifen, wird diese in Zeile <code>1</code> konvertiert, und das Ergebnis dieser Konvertierung wird als Schlüssel verwendet. <br><br><h2>  <font color="#3AC1EF">Objekteigenschaftswerte</font> </h2><br>  Objekteigenschaften können primitive Werte, Objekte oder Funktionen sein. <br><br><h3>  <font color="#3AC1EF">▍Objekt als Objekteigenschaftswert</font> </h3><br>  Objekte können in anderen Objekten platziert werden.  Betrachten Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Beispiel</a> : <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> book = { title : <span class="hljs-string"><span class="hljs-string">"The Good Parts"</span></span>, author : {   firstName : <span class="hljs-string"><span class="hljs-string">"Douglas"</span></span>,   lastName : <span class="hljs-string"><span class="hljs-string">"Crockford"</span></span> } } book.author.firstName; <span class="hljs-comment"><span class="hljs-comment">//"Douglas"</span></span></code> </pre> <br>  Ein ähnlicher Ansatz kann zum Erstellen von Namespaces verwendet werden: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> app = {}; app.authorService = { <span class="hljs-attr"><span class="hljs-attr">getAuthors</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} }; app.bookService = { <span class="hljs-attr"><span class="hljs-attr">getBooks</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} };</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Funktion als Objekteigenschaftswert</font> </h3><br>  Wenn eine Funktion als Objekteigenschaftswert verwendet wird, wird sie normalerweise zu einer Objektmethode.  Verwenden Sie in der Methode das <code>this</code> , um auf das aktuelle Objekt zuzugreifen. <br><br>  Dieses Schlüsselwort kann jedoch je nach Aufruf der Funktion unterschiedliche Bedeutungen haben.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier</a> können Sie über Situationen lesen, in denen <code>this</code> den Kontext verliert. <br><br><h2>  <font color="#3AC1EF">Die Dynamik von Objekten</font> </h2><br>  Objekte in JavaScript sind von Natur aus dynamische Entitäten.  Sie können ihnen jederzeit Eigenschaften hinzufügen. Gleiches gilt für das Löschen von Eigenschaften: <br><br><pre> <code class="hljs ruby">let obj = {}; obj.message = <span class="hljs-string"><span class="hljs-string">"This is a message"</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   obj.otherMessage = <span class="hljs-string"><span class="hljs-string">"A new message"</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    delete obj.otherMessage; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> </code> </pre> <br><h2>  <font color="#3AC1EF">Objekte als assoziative Arrays</font> </h2><br>  Objekte können als assoziative Arrays betrachtet werden.  Assoziative Array-Schlüssel sind die Eigenschaftsnamen des Objekts.  Um auf den Schlüssel zuzugreifen, müssen Sie nicht alle Eigenschaften betrachten, dh der Vorgang des Zugriffs auf den Schlüssel eines assoziativen Arrays basierend auf einem Objekt wird in O (1) -Zeit ausgeführt. <br><br><h2>  <font color="#3AC1EF">Objektprototypen</font> </h2><br>  Objekte haben einen "versteckten" Link, <code>__proto__</code> , der auf ein Prototypobjekt verweist, von dem das Objekt Eigenschaften erbt. <br><br>  Ein mit einem Objektliteral erstelltes Objekt verfügt beispielsweise über einen Link zu <code>Object.prototype</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = {}; obj.__proto__ === <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype; <span class="hljs-comment"><span class="hljs-comment">//true</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍ Leere Objekte</font> </h3><br>  Wie wir gerade gesehen haben, ist das "leere" Objekt <code>{}</code> tatsächlich nicht so leer, da es einen Verweis auf <code>Object.prototype</code> .  Um ein wirklich leeres Objekt zu erstellen, müssen Sie die folgende Konstruktion verwenden: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>)</code> </pre> <br>  Dadurch wird ein Objekt ohne Prototyp erstellt.  Solche Objekte werden normalerweise verwendet, um assoziative Arrays zu erstellen. <br><br><h3>  <font color="#3AC1EF">▍ Prototypkette</font> </h3><br>  Prototypobjekte können eigene Prototypen haben.  Wenn Sie versuchen, auf eine Eigenschaft eines Objekts zuzugreifen, das sich nicht darin befindet, versucht JavaScript, diese Eigenschaft im Prototyp dieses Objekts zu finden. Wenn die gewünschte Eigenschaft nicht vorhanden ist, wird versucht, sie im Prototyp des Prototyps zu finden.  Dies wird fortgesetzt, bis die gewünschte Eigenschaft gefunden wurde oder bis das Ende der Prototypkette erreicht ist. <br><br><h2>  <font color="#3AC1EF">Primitive Typwerte und Objektverpackungen</font> </h2><br>  Mit JavaScript können Sie mit den Werten primitiver Typen als Objekte arbeiten, in dem Sinne, dass Sie mit der Sprache auf deren Eigenschaften und Methoden zugreifen können. <br><br><pre> <code class="hljs ruby">(<span class="hljs-number"><span class="hljs-number">1.23</span></span>).toFixed(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-string"><span class="hljs-string">"1.2"</span></span> <span class="hljs-string"><span class="hljs-string">"text"</span></span>.toUpperCase(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-string"><span class="hljs-string">"TEXT"</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>.toString(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-string"><span class="hljs-string">"true"</span></span></code> </pre> <br>  Darüber hinaus sind die Werte primitiver Typen natürlich keine Objekte. <br><br>  Um den Zugriff auf die „Eigenschaften“ von Werten primitiver Typen zu organisieren, erstellt JavaScript bei Bedarf Wrapper-Objekte, die, nachdem sie nicht mehr benötigt werden, zerstört werden.  Der Prozess zum Erstellen und Zerstören von Wrapper-Objekten wird von der JS-Engine optimiert. <br><br>  Objekt-Wrapper haben Werte vom numerischen, Zeichenfolgen- und logischen Typ.  Objekte der entsprechenden Typen werden durch die Konstruktorfunktionen <code>Number</code> , <code>String</code> und <code>Boolean</code> . <br><br><h2>  <font color="#3AC1EF">Eingebettete Prototypen</font> </h2><br>  Number-Objekte erben Eigenschaften und Methoden vom Prototyp <code>Number.prototype</code> , dem Nachkommen von <code>Object.prototype</code> : <br><br><pre> <code class="hljs pgsql">var <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">no</span></span>.__proto__ === Number.prototype; //<span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">no</span></span>.__proto__.__proto__ === <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.prototype; //<span class="hljs-keyword"><span class="hljs-keyword">true</span></span></code> </pre> <br>  Der Prototyp von String-Objekten ist <code>String.prototype</code> .  Der Prototyp von booleschen Objekten ist <code>Boolean.prototype</code> .  Der Prototyp von Arrays (die auch Objekte sind) ist <code>Array.prototype</code> . <br><br>  Funktionen in JavaScript sind auch Objekte mit einem Prototyp <code>Function.prototype</code> .  Funktionen haben Methoden wie <code>bind()</code> , <code>apply()</code> und <code>call()</code> . <br><br>  Alle Objekte, Funktionen und Objekte, die primitive <code>Object.prototype</code> (mit Ausnahme von <code>null</code> und <code>undefined</code> Werten), erben Eigenschaften und Methoden von <code>Object.prototype</code> .  Dies führt dazu, dass beispielsweise alle eine <code>toString()</code> -Methode haben. <br><br><h2>  <font color="#3AC1EF">Erweitern eingebetteter Objekte mit Polyfills</font> </h2><br>  Mit JavaScript können eingebettete Objekte mithilfe sogenannter Polyfills problemlos um neue Funktionen erweitert werden.  Eine Polyfüllung ist ein Code, der Funktionen implementiert, die von keinem Browser unterstützt werden. <br><br><h3>  <font color="#3AC1EF">▍Verwendung von Polyfills</font> </h3><br>  Beispielsweise gibt es eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Polyfüllung</a> für die <code>Object.assign()</code> -Methode.  Sie können dem <code>Object</code> eine neue Funktion hinzufügen, wenn diese nicht verfügbar ist. <br><br>  Gleiches gilt für das <code>Array.from()</code> , das, wenn sich die <code>from()</code> -Methode nicht im <code>Array</code> Objekt befindet, mit dieser Methode ausgestattet wird. <br><br><h3>  <font color="#3AC1EF">▍ Polyfill und Prototypen</font> </h3><br>  Mit Hilfe von Polyfills können Prototypen von Objekten um neue Methoden erweitert werden.  Mit der <code>String.prototype.trim()</code> für <code>String.prototype.trim()</code> können Sie beispielsweise alle String-Objekte mit der Methode <code>trim()</code> ausstatten: <br><br><pre> <code class="hljs pgsql">let <span class="hljs-type"><span class="hljs-type">text</span></span> = "   A text "; <span class="hljs-type"><span class="hljs-type">text</span></span>.trim(); //"A text"</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mit der</a> <code>Array.prototype.find()</code> für <code>Array.prototype.find()</code> können Sie alle Arrays mit der <code>find()</code> -Methode ausstatten.  Die <code>Array.prototype.findIndex()</code> für <code>Array.prototype.findIndex()</code> funktioniert auf ähnliche Weise: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = [<span class="hljs-string"><span class="hljs-string">"A"</span></span>, <span class="hljs-string"><span class="hljs-string">"B"</span></span>, <span class="hljs-string"><span class="hljs-string">"C"</span></span>, <span class="hljs-string"><span class="hljs-string">"D"</span></span>, <span class="hljs-string"><span class="hljs-string">"E"</span></span>]; arr.indexOf(<span class="hljs-string"><span class="hljs-string">"C"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//2</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Einzelvererbung</font> </h2><br>  Mit dem Befehl <code>Object.create()</code> können Sie neue Objekte mit einem bestimmten Prototypobjekt erstellen.  Dieser Befehl wird in JavaScript verwendet, um einen einzelnen Vererbungsmechanismus zu implementieren.  Betrachten Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Beispiel</a> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bookPrototype = { <span class="hljs-attr"><span class="hljs-attr">getFullTitle</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.title + <span class="hljs-string"><span class="hljs-string">" by "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.author; } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> book = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(bookPrototype); book.title = <span class="hljs-string"><span class="hljs-string">"JavaScript: The Good Parts"</span></span>; book.author = <span class="hljs-string"><span class="hljs-string">"Douglas Crockford"</span></span>; book.getFullTitle();<span class="hljs-comment"><span class="hljs-comment">//JavaScript: The Good Parts by Douglas Crockford</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Mehrfachvererbung</font> </h2><br>  Der Befehl <code>Object.assign()</code> kopiert Eigenschaften von einem oder mehreren Objekten in das Zielobjekt.  Es kann verwendet werden, um mehrere Vererbungsschemata zu implementieren.  Hier ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Beispiel</a> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> authorDataService = { <span class="hljs-attr"><span class="hljs-attr">getAuthors</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bookDataService = { <span class="hljs-attr"><span class="hljs-attr">getBooks</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> userDataService = { <span class="hljs-attr"><span class="hljs-attr">getUsers</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dataService = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign({}, authorDataService, bookDataService, userDataService ); dataService.getAuthors(); dataService.getBooks(); dataService.getUsers();</code> </pre> <br><h2>  <font color="#3AC1EF">Unveränderliche Objekte</font> </h2><br>  Mit dem Befehl <code>Object.freeze()</code> können Sie ein Objekt „einfrieren“.  Sie können einem solchen Objekt keine neuen Eigenschaften hinzufügen.  Eigenschaften können weder gelöscht noch ihre Werte geändert werden.  Mit diesem Befehl wird ein Objekt unveränderlich oder unveränderlich: <br><br><pre> <code class="hljs pgsql">"use strict"; let book = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({ title : "Functional-Light JavaScript", author : "Kyle Simpson" }); book.title = "Other title";//: Cannot assign <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> property <span class="hljs-string"><span class="hljs-string">'title'</span></span></code> </pre> <br>  Der Befehl <code>Object.freeze()</code> führt das sogenannte "flache Einfrieren" von Objekten durch.  Dies bedeutet, dass in einem "eingefrorenen" Objekt verschachtelte Objekte geändert werden können.  Um ein Objekt tief einzufrieren, müssen Sie alle seine Eigenschaften rekursiv einfrieren. <br><br><h2>  <font color="#3AC1EF">Objekte klonen</font> </h2><br>  Um Klone (Kopien) von Objekten zu erstellen, können Sie den Befehl <code>Object.assign()</code> : <br><br><pre> <code class="hljs pgsql">let book = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({ title : "JavaScript Allongé", author : "Reginald Braithwaite" }); let clone = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.assign({}, book);</code> </pre> <br>  Dieser Befehl führt ein flaches Kopieren von Objekten durch, dh er kopiert nur Eigenschaften der obersten Ebene.  Verschachtelte Objekte sind für Originalobjekte und ihre Kopien üblich. <br><br><h2>  <font color="#3AC1EF">Objektliteral</font> </h2><br>  Objektliterale bieten Entwicklern eine einfache und unkomplizierte Möglichkeit, Objekte zu erstellen: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timer = { <span class="hljs-attr"><span class="hljs-attr">fn</span></span> : <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-attr"><span class="hljs-attr">start</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">callback</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fn = callback; }, <span class="hljs-attr"><span class="hljs-attr">stop</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}, }</code> </pre> <br>  Diese Methode zum Erstellen von Objekten hat jedoch Nachteile.  Insbesondere sind bei diesem Ansatz alle Eigenschaften des Objekts öffentlich verfügbar, die Methoden des Objekts können neu definiert werden und sie können nicht zum Erstellen neuer Instanzen derselben Objekte verwendet werden: <br><br><pre> <code class="hljs pgsql">timer.fn;//<span class="hljs-keyword"><span class="hljs-keyword">null</span></span> timer.start = <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() { console.log("New implementation"); }</code> </pre> <br><h2>  <font color="#3AC1EF">Object.create () -Methode</font> </h2><br>  Die beiden oben genannten Probleme können durch die gemeinsame Verwendung der Methoden <code>Object.create()</code> und <code>Object.freeze()</code> . <br><br>  Wir wenden diese Technik auf unser vorheriges Beispiel an.  Erstellen Sie zunächst einen eingefrorenen Prototyp <code>timerPrototype</code> , der alle Methoden enthält, die von verschiedenen Instanzen des Objekts benötigt werden.  Erstellen Sie anschließend ein Objekt, das ein Nachfolger von <code>timerPrototype</code> : <br><br><pre> <code class="hljs pgsql">let timerPrototype = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({ <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() {}, stop : <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() {} }); let timer = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(timerPrototype); timer.__proto__ === timerPrototype; //<span class="hljs-keyword"><span class="hljs-keyword">true</span></span></code> </pre> <br>  Wenn der Prototyp vor Änderungen geschützt ist, kann das Objekt, das sein Erbe ist, die im Prototyp definierten Eigenschaften nicht ändern.  Jetzt können die Methoden <code>start()</code> und <code>stop()</code> nicht überschrieben werden: <br><br><pre> <code class="hljs javascript"><span class="hljs-meta"><span class="hljs-meta">"use strict"</span></span>; timer.start = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"New implementation"</span></span>); } <span class="hljs-comment"><span class="hljs-comment">//: Cannot assign to read only property 'start' of object</span></span></code> </pre> <br>  Mit dem <code>Object.create(timerPrototype)</code> können mehrere Objekte mit demselben Prototyp erstellt werden. <br><br><h2>  <font color="#3AC1EF">Konstruktorfunktion</font> </h2><br>  JavaScript verfügt über sogenannte Konstruktorfunktionen, die "syntaktischer Zucker" sind, um die oben genannten Schritte zum Erstellen neuer Objekte auszuführen.  Betrachten Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Beispiel</a> : <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Timer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">callback</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fn = callback; } Timer.prototype = { <span class="hljs-attr"><span class="hljs-attr">start</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}, <span class="hljs-attr"><span class="hljs-attr">stop</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTodos</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Timer(getTodos);</code> </pre> <br>  Sie können jede Funktion als Konstruktor verwenden.  Der Konstruktor wird mit dem <code>new</code> Schlüsselwort aufgerufen.  Ein Objekt, das mit einer Konstruktorfunktion namens <code>FunctionConstructor</code> , erhält einen Prototyp <code>FunctionConstructor.prototype</code> : <br><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">timer</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Timer</span></span>(); <span class="hljs-built_in"><span class="hljs-built_in">timer</span></span>.__proto__ === <span class="hljs-built_in"><span class="hljs-built_in">Timer</span></span>.prototype;</code> </pre> <br>  Um eine Änderung des Prototyps zu verhindern, können Sie den Prototyp erneut einfrieren: <br><br><pre> <code class="hljs pgsql">Timer.prototype = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({ <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() {}, stop : <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() {} });</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Stichwort neu</font> </h3><br>  Wenn ein Befehl des Formulars <code>new Timer()</code> ausgeführt wird, werden dieselben Aktionen ausgeführt wie die Funktion <code>newTimer()</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newTimer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> newObj = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(Timer.prototype); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> returnObj = Timer.call(newObj, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(returnObj) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> returnObj;   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> newObj; }</code> </pre> <br>  Hier wird ein neues Objekt erstellt, dessen Prototyp <code>Timer.prototype</code> .  Anschließend wird die <code>Timer</code> Funktion aufgerufen, mit der die Felder für das neue Objekt festgelegt werden. <br><br><h2>  <font color="#3AC1EF">Klassenschlüsselwort</font> </h2><br>  Mit ECMAScript 2015 wurde eine neue Methode zur Durchführung der oben genannten Aktionen eingeführt, bei der es sich um eine weitere Charge „syntaktischen Zuckers“ handelt.  Wir sprechen über das <code>class</code> und die damit verbundenen zugehörigen Konstrukte.  Betrachten Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Beispiel</a> : <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Timer{ constructor(callback){   this.fn = callback; } <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>() {} stop() {} } <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>(Timer.prototype);</code> </pre> <br>  Ein Objekt, das mit dem Schlüsselwort <code>class</code> basierend auf einer Klasse namens <code>ClassName</code> , hat den Prototyp <code>ClassName.prototype</code> .  Verwenden Sie beim Erstellen eines Objekts basierend auf einer Klasse das <code>new</code> Schlüsselwort: <br><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">timer</span></span>= <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Timer</span></span>(); <span class="hljs-built_in"><span class="hljs-built_in">timer</span></span>.__proto__ === <span class="hljs-built_in"><span class="hljs-built_in">Timer</span></span>.prototype;</code> </pre> <br>  Die Verwendung von Klassen macht Prototypen nicht unveränderlich.  Falls erforderlich, müssen sie auf die gleiche Weise „eingefroren“ werden, wie wir es bereits getan haben: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>(Timer.prototype);</code> </pre> <br><h2>  <font color="#3AC1EF">Prototypbasierte Vererbung</font> </h2><br>  In JavaScript erben Objekte Eigenschaften und Methoden von anderen Objekten.  Konstruktorfunktionen und -klassen sind „syntaktischer Zucker“ zum Erstellen von Prototypobjekten, die alle erforderlichen Methoden enthalten.  Mit ihnen werden neue Objekte erstellt, die die Erben des Prototyps sind, deren Eigenschaften für eine bestimmte Instanz mithilfe der Konstruktorfunktion oder mithilfe der Klassenmechanismen festgelegt werden. <br><br>  Es wäre schön, wenn Konstruktorfunktionen und -klassen Prototypen automatisch unveränderlich machen könnten. <br><br>  Die Stärken der Prototypvererbung sind Speichereinsparungen.  Tatsache ist, dass ein Prototyp nur einmal erstellt wird, wonach alle auf seiner Basis erstellten Objekte ihn verwenden. <br><br><h3>  <font color="#3AC1EF">▍ Das Problem des Fehlens integrierter Verkapselungsmechanismen</font> </h3><br>  Die Prototyp-Vererbungsvorlage verwendet nicht die Trennung der Eigenschaften von Objekten in private und öffentliche.  Alle Eigenschaften von Objekten sind öffentlich verfügbar. <br><br>  Beispielsweise gibt der Befehl <code>Object.keys()</code> ein Array zurück, das alle Eigenschaftsschlüssel des Objekts enthält.  Es kann verwendet werden, um alle Eigenschaften eines Objekts zu durchlaufen: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> logProperty(<span class="hljs-type"><span class="hljs-type">name</span></span>){ console.log(<span class="hljs-type"><span class="hljs-type">name</span></span>); //  console.log(obj[<span class="hljs-type"><span class="hljs-type">name</span></span>]); //  } <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.keys(obj).<span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span>(logProperty);</code> </pre> <br>  Es gibt ein Muster, das private Eigenschaften nachahmt und sich auf die Tatsache stützt, dass Entwickler nicht auf Eigenschaften zugreifen, deren Namen mit einem Unterstrich ( <code>_</code> ) beginnen: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Timer</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(callback){   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._fn = callback;   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._timerId = <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br><h2>  <font color="#3AC1EF">Werksfunktionen</font> </h2><br>  Eingekapselte Objekte in JavaScript können mithilfe von Factory-Funktionen erstellt werden.  Es sieht so aus: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> TodoStore(callback){   let fn = callback;     <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>() {},   <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> stop() {}     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({      <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>,      stop   }); }</code> </pre> <br>  Hier ist die Variable <code>fn</code> privat.  Nur die Methoden <code>start()</code> und <code>stop()</code> sind öffentlich verfügbar.  Diese Methoden können nicht extern geändert werden.  Das Schlüsselwort this wird hier nicht verwendet. Wenn Sie diese Methode zum Erstellen von Objekten verwenden, ist das Problem des Verlusts <code>this</code> Kontexts irrelevant. <br><br>  Der Befehl <code>return</code> verwendet ein Objektliteral, das nur Funktionen enthält.  Darüber hinaus werden diese Funktionen zum Abschluss erklärt, sie haben einen gemeinsamen Zustand.  Um eine öffentliche API eines Objekts einzufrieren, wird der bereits bekannte Befehl <code>Object.freeze()</code> . <br><br>  Hier haben wir in den Beispielen das <code>Timer</code> Objekt verwendet.  In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem</a> Material finden Sie die vollständige Implementierung. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  In JavaScript werden die Werte primitiver Typen, gewöhnlicher Objekte und Funktionen als Objekte behandelt.  Objekte sind dynamischer Natur und können als assoziative Arrays verwendet werden.  Objekte sind Erben anderer Objekte.  Konstruktorfunktionen und -klassen sind „syntaktischer Zucker“, mit dem Sie Objekte basierend auf Prototypen erstellen können.  Sie können die <code>Object.create()</code> -Methode verwenden, um die Einzelvererbung zu organisieren, und <code>Object.create()</code> um die Mehrfachvererbung zu organisieren.  Sie können Factory-Funktionen verwenden, um gekapselte Objekte zu erstellen. <br><br>  <b>Liebe Leser!</b>  Wenn Sie aus anderen Sprachen zu JavaScript gekommen sind, teilen Sie uns bitte mit, was Sie an JS-Objekten mögen oder nicht mögen, im Vergleich zur Implementierung von Objekten in Sprachen, die Sie bereits kennen. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de420615/">https://habr.com/ru/post/de420615/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de420605/index.html">Überblick über den Algorithmus für Vorstellungsgespräche - Set-Generierung</a></li>
<li><a href="../de420607/index.html">Digitale Veranstaltungen in Moskau vom 20. bis 26. August</a></li>
<li><a href="../de420609/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends für die letzte Woche Nr. 327 (13. - 19. August 2018)</a></li>
<li><a href="../de420611/index.html">Modellierung der Quantenverschränkung in C #</a></li>
<li><a href="../de420613/index.html">11 Bibliotheken (Komponentensätze) für React Native, über die Sie 2018 Bescheid wissen sollten</a></li>
<li><a href="../de420617/index.html">Webdesign-Handbuch für Entwickler</a></li>
<li><a href="../de420619/index.html">Responsive Images: CSS-Tricks, die Zeit sparen</a></li>
<li><a href="../de420623/index.html">Verteilte C ++ - Anwendungen mit minimalem Aufwand</a></li>
<li><a href="../de420625/index.html">KDD 2018, Erster Tag, Tutorials</a></li>
<li><a href="../de420627/index.html">C # Asynchrone Programmierung: Wie geht es Ihnen mit der Leistung?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>