<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìπ üõë ü•ñ JavaScript: Objekte erkunden ü§öüèª üë®üèº‚Äçüç≥ üê£</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Material, dessen √úbersetzung wir heute ver√∂ffentlichen, ist dem Studium von Objekten gewidmet - einer der Schl√ºsselessenzen von JavaScript. Es ric...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript: Objekte erkunden</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/420615/">  Das Material, dessen √úbersetzung wir heute ver√∂ffentlichen, ist dem Studium von Objekten gewidmet - einer der Schl√ºsselessenzen von JavaScript.  Es richtet sich in erster Linie an Anf√§nger, die ihr Wissen √ºber Objekte optimieren m√∂chten. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/vo/lg/xb/volgxbgclrhdnqvvi_qdqfc1yna.jpeg"></a> <br><br>  Objekte in JavaScript sind dynamische Sammlungen von Eigenschaften, die zus√§tzlich eine ‚Äûversteckte‚Äú Eigenschaft enthalten, die ein Prototyp des Objekts ist.  Eigenschaften von Objekten sind durch Schl√ºssel und Werte gekennzeichnet.  Beginnen wir die Konversation √ºber JS-Objekte mit Schl√ºsseln. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Objekteigenschaftsschl√ºssel</font> </h2><br>  Der Objekteigenschaftsschl√ºssel ist eine eindeutige Zeichenfolge.  Sie k√∂nnen zwei Methoden verwenden, um auf Eigenschaften zuzugreifen: Zugriff √ºber einen Punkt und Angabe des Objektschl√ºssels in eckigen Klammern.  Beim Zugriff auf Eigenschaften √ºber einen Punkt muss der Schl√ºssel eine g√ºltige JavaScript-Kennung sein.  Betrachten Sie ein Beispiel: <br><br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">let</span></span> obj = {  <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> : <span class="hljs-string"><span class="hljs-string">"A message"</span></span> } obj.message //<span class="hljs-string"><span class="hljs-string">"A message"</span></span> obj[<span class="hljs-string"><span class="hljs-string">"message"</span></span>] //<span class="hljs-string"><span class="hljs-string">"A message"</span></span></code> </pre> <br>  Beim Versuch, auf eine nicht vorhandene Eigenschaft eines Objekts zuzugreifen, wird keine Fehlermeldung angezeigt, aber der <code>undefined</code> Wert wird zur√ºckgegeben: <br><br><pre> <code class="hljs objectivec">obj.otherProperty <span class="hljs-comment"><span class="hljs-comment">//undefined</span></span></code> </pre> <br>  Wenn Sie in eckigen Klammern auf Eigenschaften zugreifen, k√∂nnen Sie Schl√ºssel verwenden, die keine g√ºltigen JavaScript-Bezeichner sind (der Schl√ºssel kann beispielsweise eine Zeichenfolge sein, die Leerzeichen enth√§lt).  Sie k√∂nnen einen beliebigen Wert haben, der in eine Zeichenfolge umgewandelt werden kann: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> french = {}; french[<span class="hljs-string"><span class="hljs-string">"merci beaucoup"</span></span>] = <span class="hljs-string"><span class="hljs-string">"thank you very much"</span></span>; french[<span class="hljs-string"><span class="hljs-string">"merci beaucoup"</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//"thank you very much"</span></span></code> </pre> <br>  Wenn Nicht-String-Werte als Schl√ºssel verwendet werden, werden sie automatisch in Strings konvertiert (wenn m√∂glich mit der <code>toString()</code> -Methode): <br><br><pre> <code class="hljs powershell">et obj = {}; //Number obj[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-string"><span class="hljs-string">"Number 1"</span></span>; obj[<span class="hljs-number"><span class="hljs-number">1</span></span>] === obj[<span class="hljs-string"><span class="hljs-string">"1"</span></span>]; //true //Object let number1 = { toString : function() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"1"</span></span>; } } obj[<span class="hljs-type"><span class="hljs-type">number1</span></span>] === obj[<span class="hljs-string"><span class="hljs-string">"1"</span></span>]; //true</code> </pre> <br>  In diesem Beispiel wird das Objekt <code>number1</code> als Schl√ºssel verwendet.  Beim Versuch, auf eine Eigenschaft zuzugreifen, wird diese in Zeile <code>1</code> konvertiert, und das Ergebnis dieser Konvertierung wird als Schl√ºssel verwendet. <br><br><h2>  <font color="#3AC1EF">Objekteigenschaftswerte</font> </h2><br>  Objekteigenschaften k√∂nnen primitive Werte, Objekte oder Funktionen sein. <br><br><h3>  <font color="#3AC1EF">‚ñçObjekt als Objekteigenschaftswert</font> </h3><br>  Objekte k√∂nnen in anderen Objekten platziert werden.  Betrachten Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Beispiel</a> : <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> book = { title : <span class="hljs-string"><span class="hljs-string">"The Good Parts"</span></span>, author : {   firstName : <span class="hljs-string"><span class="hljs-string">"Douglas"</span></span>,   lastName : <span class="hljs-string"><span class="hljs-string">"Crockford"</span></span> } } book.author.firstName; <span class="hljs-comment"><span class="hljs-comment">//"Douglas"</span></span></code> </pre> <br>  Ein √§hnlicher Ansatz kann zum Erstellen von Namespaces verwendet werden: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> app = {}; app.authorService = { <span class="hljs-attr"><span class="hljs-attr">getAuthors</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} }; app.bookService = { <span class="hljs-attr"><span class="hljs-attr">getBooks</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} };</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Funktion als Objekteigenschaftswert</font> </h3><br>  Wenn eine Funktion als Objekteigenschaftswert verwendet wird, wird sie normalerweise zu einer Objektmethode.  Verwenden Sie in der Methode das <code>this</code> , um auf das aktuelle Objekt zuzugreifen. <br><br>  Dieses Schl√ºsselwort kann jedoch je nach Aufruf der Funktion unterschiedliche Bedeutungen haben.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier</a> k√∂nnen Sie √ºber Situationen lesen, in denen <code>this</code> den Kontext verliert. <br><br><h2>  <font color="#3AC1EF">Die Dynamik von Objekten</font> </h2><br>  Objekte in JavaScript sind von Natur aus dynamische Entit√§ten.  Sie k√∂nnen ihnen jederzeit Eigenschaften hinzuf√ºgen. Gleiches gilt f√ºr das L√∂schen von Eigenschaften: <br><br><pre> <code class="hljs ruby">let obj = {}; obj.message = <span class="hljs-string"><span class="hljs-string">"This is a message"</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   obj.otherMessage = <span class="hljs-string"><span class="hljs-string">"A new message"</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    delete obj.otherMessage; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> </code> </pre> <br><h2>  <font color="#3AC1EF">Objekte als assoziative Arrays</font> </h2><br>  Objekte k√∂nnen als assoziative Arrays betrachtet werden.  Assoziative Array-Schl√ºssel sind die Eigenschaftsnamen des Objekts.  Um auf den Schl√ºssel zuzugreifen, m√ºssen Sie nicht alle Eigenschaften betrachten, dh der Vorgang des Zugriffs auf den Schl√ºssel eines assoziativen Arrays basierend auf einem Objekt wird in O (1) -Zeit ausgef√ºhrt. <br><br><h2>  <font color="#3AC1EF">Objektprototypen</font> </h2><br>  Objekte haben einen "versteckten" Link, <code>__proto__</code> , der auf ein Prototypobjekt verweist, von dem das Objekt Eigenschaften erbt. <br><br>  Ein mit einem Objektliteral erstelltes Objekt verf√ºgt beispielsweise √ºber einen Link zu <code>Object.prototype</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = {}; obj.__proto__ === <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype; <span class="hljs-comment"><span class="hljs-comment">//true</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Leere Objekte</font> </h3><br>  Wie wir gerade gesehen haben, ist das "leere" Objekt <code>{}</code> tats√§chlich nicht so leer, da es einen Verweis auf <code>Object.prototype</code> .  Um ein wirklich leeres Objekt zu erstellen, m√ºssen Sie die folgende Konstruktion verwenden: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>)</code> </pre> <br>  Dadurch wird ein Objekt ohne Prototyp erstellt.  Solche Objekte werden normalerweise verwendet, um assoziative Arrays zu erstellen. <br><br><h3>  <font color="#3AC1EF">‚ñç Prototypkette</font> </h3><br>  Prototypobjekte k√∂nnen eigene Prototypen haben.  Wenn Sie versuchen, auf eine Eigenschaft eines Objekts zuzugreifen, das sich nicht darin befindet, versucht JavaScript, diese Eigenschaft im Prototyp dieses Objekts zu finden. Wenn die gew√ºnschte Eigenschaft nicht vorhanden ist, wird versucht, sie im Prototyp des Prototyps zu finden.  Dies wird fortgesetzt, bis die gew√ºnschte Eigenschaft gefunden wurde oder bis das Ende der Prototypkette erreicht ist. <br><br><h2>  <font color="#3AC1EF">Primitive Typwerte und Objektverpackungen</font> </h2><br>  Mit JavaScript k√∂nnen Sie mit den Werten primitiver Typen als Objekte arbeiten, in dem Sinne, dass Sie mit der Sprache auf deren Eigenschaften und Methoden zugreifen k√∂nnen. <br><br><pre> <code class="hljs ruby">(<span class="hljs-number"><span class="hljs-number">1.23</span></span>).toFixed(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-string"><span class="hljs-string">"1.2"</span></span> <span class="hljs-string"><span class="hljs-string">"text"</span></span>.toUpperCase(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-string"><span class="hljs-string">"TEXT"</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>.toString(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-string"><span class="hljs-string">"true"</span></span></code> </pre> <br>  Dar√ºber hinaus sind die Werte primitiver Typen nat√ºrlich keine Objekte. <br><br>  Um den Zugriff auf die ‚ÄûEigenschaften‚Äú von Werten primitiver Typen zu organisieren, erstellt JavaScript bei Bedarf Wrapper-Objekte, die, nachdem sie nicht mehr ben√∂tigt werden, zerst√∂rt werden.  Der Prozess zum Erstellen und Zerst√∂ren von Wrapper-Objekten wird von der JS-Engine optimiert. <br><br>  Objekt-Wrapper haben Werte vom numerischen, Zeichenfolgen- und logischen Typ.  Objekte der entsprechenden Typen werden durch die Konstruktorfunktionen <code>Number</code> , <code>String</code> und <code>Boolean</code> . <br><br><h2>  <font color="#3AC1EF">Eingebettete Prototypen</font> </h2><br>  Number-Objekte erben Eigenschaften und Methoden vom Prototyp <code>Number.prototype</code> , dem Nachkommen von <code>Object.prototype</code> : <br><br><pre> <code class="hljs pgsql">var <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">no</span></span>.__proto__ === Number.prototype; //<span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">no</span></span>.__proto__.__proto__ === <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.prototype; //<span class="hljs-keyword"><span class="hljs-keyword">true</span></span></code> </pre> <br>  Der Prototyp von String-Objekten ist <code>String.prototype</code> .  Der Prototyp von booleschen Objekten ist <code>Boolean.prototype</code> .  Der Prototyp von Arrays (die auch Objekte sind) ist <code>Array.prototype</code> . <br><br>  Funktionen in JavaScript sind auch Objekte mit einem Prototyp <code>Function.prototype</code> .  Funktionen haben Methoden wie <code>bind()</code> , <code>apply()</code> und <code>call()</code> . <br><br>  Alle Objekte, Funktionen und Objekte, die primitive <code>Object.prototype</code> (mit Ausnahme von <code>null</code> und <code>undefined</code> Werten), erben Eigenschaften und Methoden von <code>Object.prototype</code> .  Dies f√ºhrt dazu, dass beispielsweise alle eine <code>toString()</code> -Methode haben. <br><br><h2>  <font color="#3AC1EF">Erweitern eingebetteter Objekte mit Polyfills</font> </h2><br>  Mit JavaScript k√∂nnen eingebettete Objekte mithilfe sogenannter Polyfills problemlos um neue Funktionen erweitert werden.  Eine Polyf√ºllung ist ein Code, der Funktionen implementiert, die von keinem Browser unterst√ºtzt werden. <br><br><h3>  <font color="#3AC1EF">‚ñçVerwendung von Polyfills</font> </h3><br>  Beispielsweise gibt es eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Polyf√ºllung</a> f√ºr die <code>Object.assign()</code> -Methode.  Sie k√∂nnen dem <code>Object</code> eine neue Funktion hinzuf√ºgen, wenn diese nicht verf√ºgbar ist. <br><br>  Gleiches gilt f√ºr das <code>Array.from()</code> , das, wenn sich die <code>from()</code> -Methode nicht im <code>Array</code> Objekt befindet, mit dieser Methode ausgestattet wird. <br><br><h3>  <font color="#3AC1EF">‚ñç Polyfill und Prototypen</font> </h3><br>  Mit Hilfe von Polyfills k√∂nnen Prototypen von Objekten um neue Methoden erweitert werden.  Mit der <code>String.prototype.trim()</code> f√ºr <code>String.prototype.trim()</code> k√∂nnen Sie beispielsweise alle String-Objekte mit der Methode <code>trim()</code> ausstatten: <br><br><pre> <code class="hljs pgsql">let <span class="hljs-type"><span class="hljs-type">text</span></span> = "   A text "; <span class="hljs-type"><span class="hljs-type">text</span></span>.trim(); //"A text"</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mit der</a> <code>Array.prototype.find()</code> f√ºr <code>Array.prototype.find()</code> k√∂nnen Sie alle Arrays mit der <code>find()</code> -Methode ausstatten.  Die <code>Array.prototype.findIndex()</code> f√ºr <code>Array.prototype.findIndex()</code> funktioniert auf √§hnliche Weise: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = [<span class="hljs-string"><span class="hljs-string">"A"</span></span>, <span class="hljs-string"><span class="hljs-string">"B"</span></span>, <span class="hljs-string"><span class="hljs-string">"C"</span></span>, <span class="hljs-string"><span class="hljs-string">"D"</span></span>, <span class="hljs-string"><span class="hljs-string">"E"</span></span>]; arr.indexOf(<span class="hljs-string"><span class="hljs-string">"C"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//2</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Einzelvererbung</font> </h2><br>  Mit dem Befehl <code>Object.create()</code> k√∂nnen Sie neue Objekte mit einem bestimmten Prototypobjekt erstellen.  Dieser Befehl wird in JavaScript verwendet, um einen einzelnen Vererbungsmechanismus zu implementieren.  Betrachten Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Beispiel</a> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bookPrototype = { <span class="hljs-attr"><span class="hljs-attr">getFullTitle</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.title + <span class="hljs-string"><span class="hljs-string">" by "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.author; } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> book = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(bookPrototype); book.title = <span class="hljs-string"><span class="hljs-string">"JavaScript: The Good Parts"</span></span>; book.author = <span class="hljs-string"><span class="hljs-string">"Douglas Crockford"</span></span>; book.getFullTitle();<span class="hljs-comment"><span class="hljs-comment">//JavaScript: The Good Parts by Douglas Crockford</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Mehrfachvererbung</font> </h2><br>  Der Befehl <code>Object.assign()</code> kopiert Eigenschaften von einem oder mehreren Objekten in das Zielobjekt.  Es kann verwendet werden, um mehrere Vererbungsschemata zu implementieren.  Hier ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Beispiel</a> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> authorDataService = { <span class="hljs-attr"><span class="hljs-attr">getAuthors</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bookDataService = { <span class="hljs-attr"><span class="hljs-attr">getBooks</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> userDataService = { <span class="hljs-attr"><span class="hljs-attr">getUsers</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dataService = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign({}, authorDataService, bookDataService, userDataService ); dataService.getAuthors(); dataService.getBooks(); dataService.getUsers();</code> </pre> <br><h2>  <font color="#3AC1EF">Unver√§nderliche Objekte</font> </h2><br>  Mit dem Befehl <code>Object.freeze()</code> k√∂nnen Sie ein Objekt ‚Äûeinfrieren‚Äú.  Sie k√∂nnen einem solchen Objekt keine neuen Eigenschaften hinzuf√ºgen.  Eigenschaften k√∂nnen weder gel√∂scht noch ihre Werte ge√§ndert werden.  Mit diesem Befehl wird ein Objekt unver√§nderlich oder unver√§nderlich: <br><br><pre> <code class="hljs pgsql">"use strict"; let book = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({ title : "Functional-Light JavaScript", author : "Kyle Simpson" }); book.title = "Other title";//: Cannot assign <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> property <span class="hljs-string"><span class="hljs-string">'title'</span></span></code> </pre> <br>  Der Befehl <code>Object.freeze()</code> f√ºhrt das sogenannte "flache Einfrieren" von Objekten durch.  Dies bedeutet, dass in einem "eingefrorenen" Objekt verschachtelte Objekte ge√§ndert werden k√∂nnen.  Um ein Objekt tief einzufrieren, m√ºssen Sie alle seine Eigenschaften rekursiv einfrieren. <br><br><h2>  <font color="#3AC1EF">Objekte klonen</font> </h2><br>  Um Klone (Kopien) von Objekten zu erstellen, k√∂nnen Sie den Befehl <code>Object.assign()</code> : <br><br><pre> <code class="hljs pgsql">let book = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({ title : "JavaScript Allong√©", author : "Reginald Braithwaite" }); let clone = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.assign({}, book);</code> </pre> <br>  Dieser Befehl f√ºhrt ein flaches Kopieren von Objekten durch, dh er kopiert nur Eigenschaften der obersten Ebene.  Verschachtelte Objekte sind f√ºr Originalobjekte und ihre Kopien √ºblich. <br><br><h2>  <font color="#3AC1EF">Objektliteral</font> </h2><br>  Objektliterale bieten Entwicklern eine einfache und unkomplizierte M√∂glichkeit, Objekte zu erstellen: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timer = { <span class="hljs-attr"><span class="hljs-attr">fn</span></span> : <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-attr"><span class="hljs-attr">start</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">callback</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fn = callback; }, <span class="hljs-attr"><span class="hljs-attr">stop</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}, }</code> </pre> <br>  Diese Methode zum Erstellen von Objekten hat jedoch Nachteile.  Insbesondere sind bei diesem Ansatz alle Eigenschaften des Objekts √∂ffentlich verf√ºgbar, die Methoden des Objekts k√∂nnen neu definiert werden und sie k√∂nnen nicht zum Erstellen neuer Instanzen derselben Objekte verwendet werden: <br><br><pre> <code class="hljs pgsql">timer.fn;//<span class="hljs-keyword"><span class="hljs-keyword">null</span></span> timer.start = <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() { console.log("New implementation"); }</code> </pre> <br><h2>  <font color="#3AC1EF">Object.create () -Methode</font> </h2><br>  Die beiden oben genannten Probleme k√∂nnen durch die gemeinsame Verwendung der Methoden <code>Object.create()</code> und <code>Object.freeze()</code> . <br><br>  Wir wenden diese Technik auf unser vorheriges Beispiel an.  Erstellen Sie zun√§chst einen eingefrorenen Prototyp <code>timerPrototype</code> , der alle Methoden enth√§lt, die von verschiedenen Instanzen des Objekts ben√∂tigt werden.  Erstellen Sie anschlie√üend ein Objekt, das ein Nachfolger von <code>timerPrototype</code> : <br><br><pre> <code class="hljs pgsql">let timerPrototype = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({ <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() {}, stop : <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() {} }); let timer = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(timerPrototype); timer.__proto__ === timerPrototype; //<span class="hljs-keyword"><span class="hljs-keyword">true</span></span></code> </pre> <br>  Wenn der Prototyp vor √Ñnderungen gesch√ºtzt ist, kann das Objekt, das sein Erbe ist, die im Prototyp definierten Eigenschaften nicht √§ndern.  Jetzt k√∂nnen die Methoden <code>start()</code> und <code>stop()</code> nicht √ºberschrieben werden: <br><br><pre> <code class="hljs javascript"><span class="hljs-meta"><span class="hljs-meta">"use strict"</span></span>; timer.start = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"New implementation"</span></span>); } <span class="hljs-comment"><span class="hljs-comment">//: Cannot assign to read only property 'start' of object</span></span></code> </pre> <br>  Mit dem <code>Object.create(timerPrototype)</code> k√∂nnen mehrere Objekte mit demselben Prototyp erstellt werden. <br><br><h2>  <font color="#3AC1EF">Konstruktorfunktion</font> </h2><br>  JavaScript verf√ºgt √ºber sogenannte Konstruktorfunktionen, die "syntaktischer Zucker" sind, um die oben genannten Schritte zum Erstellen neuer Objekte auszuf√ºhren.  Betrachten Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Beispiel</a> : <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Timer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">callback</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fn = callback; } Timer.prototype = { <span class="hljs-attr"><span class="hljs-attr">start</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}, <span class="hljs-attr"><span class="hljs-attr">stop</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTodos</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Timer(getTodos);</code> </pre> <br>  Sie k√∂nnen jede Funktion als Konstruktor verwenden.  Der Konstruktor wird mit dem <code>new</code> Schl√ºsselwort aufgerufen.  Ein Objekt, das mit einer Konstruktorfunktion namens <code>FunctionConstructor</code> , erh√§lt einen Prototyp <code>FunctionConstructor.prototype</code> : <br><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">timer</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Timer</span></span>(); <span class="hljs-built_in"><span class="hljs-built_in">timer</span></span>.__proto__ === <span class="hljs-built_in"><span class="hljs-built_in">Timer</span></span>.prototype;</code> </pre> <br>  Um eine √Ñnderung des Prototyps zu verhindern, k√∂nnen Sie den Prototyp erneut einfrieren: <br><br><pre> <code class="hljs pgsql">Timer.prototype = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({ <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() {}, stop : <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() {} });</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Stichwort neu</font> </h3><br>  Wenn ein Befehl des Formulars <code>new Timer()</code> ausgef√ºhrt wird, werden dieselben Aktionen ausgef√ºhrt wie die Funktion <code>newTimer()</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newTimer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> newObj = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(Timer.prototype); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> returnObj = Timer.call(newObj, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(returnObj) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> returnObj;   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> newObj; }</code> </pre> <br>  Hier wird ein neues Objekt erstellt, dessen Prototyp <code>Timer.prototype</code> .  Anschlie√üend wird die <code>Timer</code> Funktion aufgerufen, mit der die Felder f√ºr das neue Objekt festgelegt werden. <br><br><h2>  <font color="#3AC1EF">Klassenschl√ºsselwort</font> </h2><br>  Mit ECMAScript 2015 wurde eine neue Methode zur Durchf√ºhrung der oben genannten Aktionen eingef√ºhrt, bei der es sich um eine weitere Charge ‚Äûsyntaktischen Zuckers‚Äú handelt.  Wir sprechen √ºber das <code>class</code> und die damit verbundenen zugeh√∂rigen Konstrukte.  Betrachten Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Beispiel</a> : <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Timer{ constructor(callback){   this.fn = callback; } <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>() {} stop() {} } <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>(Timer.prototype);</code> </pre> <br>  Ein Objekt, das mit dem Schl√ºsselwort <code>class</code> basierend auf einer Klasse namens <code>ClassName</code> , hat den Prototyp <code>ClassName.prototype</code> .  Verwenden Sie beim Erstellen eines Objekts basierend auf einer Klasse das <code>new</code> Schl√ºsselwort: <br><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">timer</span></span>= <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Timer</span></span>(); <span class="hljs-built_in"><span class="hljs-built_in">timer</span></span>.__proto__ === <span class="hljs-built_in"><span class="hljs-built_in">Timer</span></span>.prototype;</code> </pre> <br>  Die Verwendung von Klassen macht Prototypen nicht unver√§nderlich.  Falls erforderlich, m√ºssen sie auf die gleiche Weise ‚Äûeingefroren‚Äú werden, wie wir es bereits getan haben: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>(Timer.prototype);</code> </pre> <br><h2>  <font color="#3AC1EF">Prototypbasierte Vererbung</font> </h2><br>  In JavaScript erben Objekte Eigenschaften und Methoden von anderen Objekten.  Konstruktorfunktionen und -klassen sind ‚Äûsyntaktischer Zucker‚Äú zum Erstellen von Prototypobjekten, die alle erforderlichen Methoden enthalten.  Mit ihnen werden neue Objekte erstellt, die die Erben des Prototyps sind, deren Eigenschaften f√ºr eine bestimmte Instanz mithilfe der Konstruktorfunktion oder mithilfe der Klassenmechanismen festgelegt werden. <br><br>  Es w√§re sch√∂n, wenn Konstruktorfunktionen und -klassen Prototypen automatisch unver√§nderlich machen k√∂nnten. <br><br>  Die St√§rken der Prototypvererbung sind Speichereinsparungen.  Tatsache ist, dass ein Prototyp nur einmal erstellt wird, wonach alle auf seiner Basis erstellten Objekte ihn verwenden. <br><br><h3>  <font color="#3AC1EF">‚ñç Das Problem des Fehlens integrierter Verkapselungsmechanismen</font> </h3><br>  Die Prototyp-Vererbungsvorlage verwendet nicht die Trennung der Eigenschaften von Objekten in private und √∂ffentliche.  Alle Eigenschaften von Objekten sind √∂ffentlich verf√ºgbar. <br><br>  Beispielsweise gibt der Befehl <code>Object.keys()</code> ein Array zur√ºck, das alle Eigenschaftsschl√ºssel des Objekts enth√§lt.  Es kann verwendet werden, um alle Eigenschaften eines Objekts zu durchlaufen: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> logProperty(<span class="hljs-type"><span class="hljs-type">name</span></span>){ console.log(<span class="hljs-type"><span class="hljs-type">name</span></span>); //  console.log(obj[<span class="hljs-type"><span class="hljs-type">name</span></span>]); //  } <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.keys(obj).<span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span>(logProperty);</code> </pre> <br>  Es gibt ein Muster, das private Eigenschaften nachahmt und sich auf die Tatsache st√ºtzt, dass Entwickler nicht auf Eigenschaften zugreifen, deren Namen mit einem Unterstrich ( <code>_</code> ) beginnen: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Timer</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(callback){   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._fn = callback;   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._timerId = <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br><h2>  <font color="#3AC1EF">Werksfunktionen</font> </h2><br>  Eingekapselte Objekte in JavaScript k√∂nnen mithilfe von Factory-Funktionen erstellt werden.  Es sieht so aus: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> TodoStore(callback){   let fn = callback;     <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>() {},   <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> stop() {}     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({      <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>,      stop   }); }</code> </pre> <br>  Hier ist die Variable <code>fn</code> privat.  Nur die Methoden <code>start()</code> und <code>stop()</code> sind √∂ffentlich verf√ºgbar.  Diese Methoden k√∂nnen nicht extern ge√§ndert werden.  Das Schl√ºsselwort this wird hier nicht verwendet. Wenn Sie diese Methode zum Erstellen von Objekten verwenden, ist das Problem des Verlusts <code>this</code> Kontexts irrelevant. <br><br>  Der Befehl <code>return</code> verwendet ein Objektliteral, das nur Funktionen enth√§lt.  Dar√ºber hinaus werden diese Funktionen zum Abschluss erkl√§rt, sie haben einen gemeinsamen Zustand.  Um eine √∂ffentliche API eines Objekts einzufrieren, wird der bereits bekannte Befehl <code>Object.freeze()</code> . <br><br>  Hier haben wir in den Beispielen das <code>Timer</code> Objekt verwendet.  In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem</a> Material finden Sie die vollst√§ndige Implementierung. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  In JavaScript werden die Werte primitiver Typen, gew√∂hnlicher Objekte und Funktionen als Objekte behandelt.  Objekte sind dynamischer Natur und k√∂nnen als assoziative Arrays verwendet werden.  Objekte sind Erben anderer Objekte.  Konstruktorfunktionen und -klassen sind ‚Äûsyntaktischer Zucker‚Äú, mit dem Sie Objekte basierend auf Prototypen erstellen k√∂nnen.  Sie k√∂nnen die <code>Object.create()</code> -Methode verwenden, um die Einzelvererbung zu organisieren, und <code>Object.create()</code> um die Mehrfachvererbung zu organisieren.  Sie k√∂nnen Factory-Funktionen verwenden, um gekapselte Objekte zu erstellen. <br><br>  <b>Liebe Leser!</b>  Wenn Sie aus anderen Sprachen zu JavaScript gekommen sind, teilen Sie uns bitte mit, was Sie an JS-Objekten m√∂gen oder nicht m√∂gen, im Vergleich zur Implementierung von Objekten in Sprachen, die Sie bereits kennen. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de420615/">https://habr.com/ru/post/de420615/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de420605/index.html">√úberblick √ºber den Algorithmus f√ºr Vorstellungsgespr√§che - Set-Generierung</a></li>
<li><a href="../de420607/index.html">Digitale Veranstaltungen in Moskau vom 20. bis 26. August</a></li>
<li><a href="../de420609/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends f√ºr die letzte Woche Nr. 327 (13. - 19. August 2018)</a></li>
<li><a href="../de420611/index.html">Modellierung der Quantenverschr√§nkung in C #</a></li>
<li><a href="../de420613/index.html">11 Bibliotheken (Komponentens√§tze) f√ºr React Native, √ºber die Sie 2018 Bescheid wissen sollten</a></li>
<li><a href="../de420617/index.html">Webdesign-Handbuch f√ºr Entwickler</a></li>
<li><a href="../de420619/index.html">Responsive Images: CSS-Tricks, die Zeit sparen</a></li>
<li><a href="../de420623/index.html">Verteilte C ++ - Anwendungen mit minimalem Aufwand</a></li>
<li><a href="../de420625/index.html">KDD 2018, Erster Tag, Tutorials</a></li>
<li><a href="../de420627/index.html">C # Asynchrone Programmierung: Wie geht es Ihnen mit der Leistung?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>