<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧢 😅 👩🏿‍🤝‍👩🏽 Community-Zählung "Was?" Wo? Wann? “(ChGK) oder wie viele Handshakes vor einem Freund? 🏤 👩🏾‍✈️ 🍏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo habr 


 Neujahrsferien sind eine gute Zeit, um  Machen Sie eine Pause von der IT  Verwenden Sie professionelle Fähigkeiten in Ihrem Lieblingsho...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Community-Zählung "Was?" Wo? Wann? “(ChGK) oder wie viele Handshakes vor einem Freund?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483356/"><img src="https://habrastorage.org/webt/sx/cv/ze/sxcvzemh1zfstlb99nne9_2hoxm.png"><br><p>  Hallo habr </p><br><p>  Neujahrsferien sind eine gute Zeit, um <del>  Machen Sie eine Pause von der IT </del>  Verwenden Sie professionelle Fähigkeiten in Ihrem Lieblingshobby.  Beim Stöbern auf der <a href="https://rating.chgk.info/" rel="nofollow">Seite mit dem Sport-ChGK-Rating habe</a> ich eine hervorragende API gefunden, mit der Sie Daten zu allen Spielen aller Turniere <a href="https://rating.chgk.info/" rel="nofollow">abrufen</a> können.  So kam mir die Idee, ein Diagramm der Expertengemeinschaft zu erstellen und die Theorie von sechs Handshakes in einer geografisch verteilten und streng offline arbeitenden Community zu testen.  Unter katom Bilder von Graphen und unbrauchbaren Statistiken. </p><a name="habracut"></a><br><p>  Zunächst ein kurzes Bildungsprogramm, was Sport ChGK ist. </p><br><div class="spoiler">  <b class="spoiler_title">Was ist Sport ChGK</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/w8/fb/yk/w8fbykni1pnbv0jgab0-9sbo4j4.jpeg" alt="ChGK Sportturnier"></p><br><p>  Ich bin mir sicher, dass mit der Fernsehversion von "What?  Wo?  Wann? “Der Leser kennt den Kopf und die Buchstaben der Zuschauer.  Sport ChGK ist eine Erweiterung des Fernsehformats, mit der mehrere Mannschaften gleichzeitig spielen können. </p><br><p>  Im Café, im Jugendhaus, in der Aula der Universität versammeln sich mehrere Teams von bis zu sechs Personen.  Der Gastgeber liest die Fragen vor, eine Minute wird zum Nachdenken gegeben.  Am Ende der Minute zeichnet das Team die Reaktion auf die Spielform auf und erhöht sie.  Speziell ausgebildete Schwalben sammeln Papier.  Normalerweise werden pro Spiel 36 Fragen gelesen, die in drei Runden unterteilt sind.  Wer am allermeisten geantwortet hat, der hat das gut gemacht. </p><br><p>  Es gibt viele Turniere in ChGK, es gibt sogar eine Europameisterschaft und eine Weltmeisterschaft, die ich den Neugierigen an eine <a href="http://lurkmore.to/%25D0%25A1%25D0%25BF%25D0%25BE%25D1%2580%25D1%2582%25D0%25B8%25D0%25B2%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25A7%25D0%2593%25D0%259A" rel="nofollow">seriöse Informationsquelle</a> sende.  Und Beispiele für Fragen finden Sie <a href="https://db.chgk.info/" rel="nofollow">hier</a> . </p></div></div><br><h2 id="poluchenie-dannyh">  Datenabruf </h2><br><p>  Wir gehen davon aus, dass die Spieler miteinander vertraut sind, wenn sie mindestens einmal an einem Spieltisch gespielt haben.  Dank der <a href="https://rating.chgk.info/api-doc" rel="nofollow">guten API ist das</a> Herunterladen von Daten zu allen Turnieren und Teams kein Problem. </p><br><p>  Unter den Spoilern wird nicht einmal Beautiful Soup verwendet, nur Nachfragen.  Ein Jupyter-Notizbuch mit dem gesamten Quellcode wird am Ende des Artikels erscheinen. </p><br><div class="spoiler">  <b class="spoiler_title">Daten für alle Turniere herunterladen</b> <div class="spoiler_text"><pre><code class="python hljs">url = <span class="hljs-string"><span class="hljs-string">'https://rating.chgk.info/api/tournaments.json/?page={}'</span></span> df = pd.DataFrame(columns=[<span class="hljs-string"><span class="hljs-string">'name'</span></span>, <span class="hljs-string"><span class="hljs-string">'start'</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>): data = requests.get(url.format(i)).json() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> data[<span class="hljs-string"><span class="hljs-string">"items"</span></span>]: df.loc[item[<span class="hljs-string"><span class="hljs-string">"idtournament"</span></span>]] = (item[<span class="hljs-string"><span class="hljs-string">"name"</span></span>], item[<span class="hljs-string"><span class="hljs-string">"date_start"</span></span>]) df.to_csv(<span class="hljs-string"><span class="hljs-string">'tournaments.csv'</span></span>)</code> </pre> </div></div><br><p>  Es bleibt noch Zeit, die Spielpläne aller Turniere herunterzuladen und sich an alle Bekannten zu erinnern.  Ursprünglich wollte ich die Fakten eines gemeinsamen Spiels in einem DataFrame speichern, aber die Geschwindigkeit, mit der neue Datensätze hinzugefügt wurden, war bedrückend.  Aus diesem Grund setzen wir Tupel (id1, id2), wobei id1, id2 die Bezeichner von Spielern sind, die mit einander vertraut sind.  Gleichzeitig werden Sie Duplikate los. </p><br><div class="spoiler">  <b class="spoiler_title">Kompositionen herunterladen und Bekanntschaften schließen</b> <div class="spoiler_text"><pre> <code class="python hljs">df = pd.read_csv(<span class="hljs-string"><span class="hljs-string">'tournaments.csv'</span></span>).set_index(<span class="hljs-string"><span class="hljs-string">'Unnamed: 0'</span></span>) url = <span class="hljs-string"><span class="hljs-string">'https://rating.chgk.info/api/tournaments/{}/recaps.json'</span></span> links = set() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> df.index: teams = requests.get(url.format(id)).json() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> team <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> teams: t = team[<span class="hljs-string"><span class="hljs-string">"recaps"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(t)): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(i + <span class="hljs-number"><span class="hljs-number">1</span></span>, len(t)): first = int(t[i][<span class="hljs-string"><span class="hljs-string">"idplayer"</span></span>]) second = int(t[j][<span class="hljs-string"><span class="hljs-string">"idplayer"</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> first &lt; second: links.add((first, second)) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: links.add((second, first)) <span class="hljs-comment"><span class="hljs-comment">#    sleep(1) clear_output(wait=True) display('Current tournament: ' + str(df.index.get_loc(id) + 1) + '/' + str(len(df))) display('Links total: ' + str(len(links)))</span></span></code> </pre> </div></div><br><h2 id="poluchenie-grafa-i-issledovanie-komponent-svyaznosti">  Ein Diagramm erstellen und verbundene Komponenten untersuchen </h2><br><p>  Nach Abschluss der Datenvorbereitung ist es Zeit, ein Diagramm zu erstellen!  Dazu verwenden wir die <a href="https://networkx.github.io/" rel="nofollow">networkx-</a> Bibliothek, deren Funktionen für unseren Cluster völlig ausreichen. </p><br><pre> <code class="python hljs">players = itertools.chain(*links) G = nx.Graph() G.add_nodes_from(players) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> links: G.add_edge(*t) print(nx.info(G))</code> </pre> <br><p>  Mittlerweile gibt es in der ChGK-Community ungefähr zweihunderttausend Menschen, und im Durchschnitt hat ein Experte für eine Karriere mit 12 Menschen gespielt: </p><br><pre> <code class="plaintext hljs">Number of nodes: 198145 Number of edges: 1206076 Average degree: 12.1737</code> </pre> <br><p>  Es ist Zeit herauszufinden, wie viele verbundene Komponenten in der Datierungsgrafik enthalten sind.  Networkx hat eine großartige Funktion namens connected_components, die genau das tut, was Sie brauchen: </p><br><pre> <code class="python hljs">clusters_l = [len(c) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sorted(nx.connected_components(G), key=len, reverse=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)] print(clusters_l[:<span class="hljs-number"><span class="hljs-number">20</span></span>])</code> </pre> <br><p>  Fast drei Viertel der Spieler befinden sich in einer zusammenhängenden Komponente, der Rest ist in sehr kleine Untergraphen unterteilt.  Es gibt mehr als achttausend von ihnen. </p><br><pre> <code class="plaintext hljs">[145922, 153, 124, 74, 72, 56, 50, 47, 42, 40, 39, 39, 38, 38, 37, 36, 36, 36, 36, 35]</code> </pre> <br><p>  Selbst im logarithmischen Maßstab sieht die Dominanz der Hauptkomponente beeindruckend aus.  Auf der X-Achse - die Nummer der Komponente vom größten bis zum kleinsten, auf der Y-Achse - ihre Größe (die Achse ist logarithmisch). </p><br><img src="https://habrastorage.org/webt/c9/pa/ol/c9paolwikv7_cjugzxctqtpffwy.png"><br><p>  Was hat eine so ungleichmäßige Verteilung der Personen in verbundenen Komponenten verursacht?  Meiner Meinung nach geht es um Folgendes: </p><br><ul><li>  Eine kleine Gruppe von Menschen kommt zum ersten Mal zum Spiel und bildet so einen kleinen Cluster für 4-6 Personen. </li><li>  Wenn die Stadt bereits eine große Gemeinde hat, verschmilzt ein solcher Cluster sehr schnell mit dem Hauptcluster. Nur eine Person muss für ein Team aus dem Hauptcluster spielen. </li><li>  Wenn in der Stadt ChGK gerade erschienen ist, wird der Cluster länger leben, weil  Schwieriger ist es, für eine Mannschaft aus dem Hauptcluster zu spielen. </li></ul><br><p>  Der Prozess ähnelt der Bildung von Regentropfen in den Wolken: Ein großer Tropfen zieht kleine Tropfen an und wächst schnell. </p><br><p>  Bevor wir uns mit der Hauptkomponente befassen, schauen wir uns die Komponenten an erster oder neunter Stelle an (ich betrachte die Hauptkomponente als Null).  Wir testen die Hypothese, dass die Menschen in diesen Komponenten aus derselben Stadt stammen.  Der Kenner hat keine Bindung an die Stadt (was in unserer modernen Welt logisch ist).  Sie können sich jedoch den Heimathafen der Mannschaft ansehen, für die er das letzte Mal gespielt hat </p><br><div class="spoiler">  <b class="spoiler_title">Code der Stadtstatistik</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>): _g = list(sorted(nx.connected_components(G), key=len, reverse=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)[i]) s = pd.Series() p_url = <span class="hljs-string"><span class="hljs-string">'https://rating.chgk.info/api/players/{}/tournaments.json'</span></span> t_url = <span class="hljs-string"><span class="hljs-string">'https://rating.chgk.info/api/teams/{}.json'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> player <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _g: data = requests.get(p_url.format(player)).json() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> data: team_id = data[item][<span class="hljs-string"><span class="hljs-string">"tournaments"</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-string"><span class="hljs-string">"idteam"</span></span>] data = requests.get(t_url.format(team_id)).json() town = data[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-string"><span class="hljs-string">"town"</span></span>] s.at[len(s)] = town print(<span class="hljs-string"><span class="hljs-string">' #{}'</span></span>.format(i)) print(s.value_counts())</code> </pre> </div></div><br><p>  Zusammenfassung Platte: </p><br><div class="scrollable-table"><table><thead><tr><th>  Konnektivitätskomponente Nr. </th><th>  Größe </th><th>  Städte </th></tr></thead><tbody><tr><td>  1 </td><td>  153 </td><td>  Kertsch </td></tr><tr><td>  2 </td><td>  124 </td><td>  110 - Ust-Ilimsk, 12 - Wladiwostok, 2 - Irkutsk </td></tr><tr><td>  3 </td><td>  74 </td><td>  Tambow - 72, <strong>Luxemburg - 2</strong> </td></tr><tr><td>  4 </td><td>  72 </td><td>  Wald </td></tr><tr><td>  5 </td><td>  56 </td><td>  Yeisk </td></tr><tr><td>  6 </td><td>  50 </td><td>  Bischkek </td></tr><tr><td>  7 </td><td>  47 </td><td>  <strong>Gorno-Altaisk</strong> </td></tr><tr><td>  8 </td><td>  42 </td><td>  Schytomyr - 37, Glasow - 5 </td></tr><tr><td>  9 </td><td>  40 </td><td>  <strong>Gorno-Altaisk - 31, Moskau - 9</strong> </td></tr></tbody></table></div><br><p>  Ja, kleine Gruppen stammen fast ausschließlich aus einer Stadt.  Bitte beachten Sie die Komponente von zweiundsiebzig Tambow-Bewohnern, die mit Luxemburg verbunden ist.  Auf den Plätzen sieben und neun befinden sich Komponenten von Gorno-Altaisk, die aus irgendeinem Grund nicht miteinander verbunden sind.  Ich stelle mir den Kampf zweier ChGK-Ash-Clans wie Montecca und Capulet vor, die um die Kontrolle über die Stadt kämpfen. <br>  Ich nehme an, dass diese Komponenten in naher Zukunft in die Hauptkomponente übergehen werden <del>  werde aber weiter kämpfen </del>  . </p><br><h2 id="osnovnaya-komponenta-svyaznosti">  Die Hauptkomponente der Konnektivität </h2><br><p>  Also kamen wir zur Hauptkomponente.  Wir erhalten den gewünschten Subgraphen und sehen uns dessen Statistiken an: </p><br><pre> <code class="python hljs">subgraph_v = list(sorted(nx.connected_components(G), key=len, reverse=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>]) subgraph = G.subgraph(subgraph_v) print(nx.info(subgraph))</code> </pre> <br><p>  Es stellte sich heraus, dass die durchschnittliche Anzahl der Verbindungen höher war. </p><br><pre> <code class="plaintext hljs">Number of nodes: 145922 Number of edges: 1070504 Average degree: 14.6723</code> </pre> <br><p>  Und was ist die maximale Anzahl von Verbindungen pro Spieler? </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sorted(G.degree, key=<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x[<span class="hljs-number"><span class="hljs-number">1</span></span>], reverse=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)[:<span class="hljs-number"><span class="hljs-number">10</span></span>]: print(<span class="hljs-string"><span class="hljs-string">' {}   {} '</span></span>.format(t[<span class="hljs-number"><span class="hljs-number">0</span></span>], t[<span class="hljs-number"><span class="hljs-number">1</span></span>]))</code> </pre> <br><pre> <code class="plaintext hljs"> 42511   818   15051   798   29800   678   23020   666   16581   662   5328   657   29887   651   15811   645   30352   605   1055   602 </code> </pre> <br><p>  Ehrlich gesagt bin ich ein bisschen schockiert von den Zahlen.  Wenn Sie jedes Mal mit einer neuen Mannschaft spielen, benötigen Sie 818/5 ≈ 164 Spiele, um den ersten Platz zu erreichen.  Unglaublich. <br>  Wir werden uns an die ersten beiden Experten in diesem Rating erinnern und ihre Kommunikationsfähigkeiten weiter einsetzen. <br>  Lassen Sie uns schätzen, wie viele engste Bekannte ein Durchschnittsfachmann hat: </p><br><div class="spoiler">  <b class="spoiler_title">Daten abrufen und Plotten</b> <div class="spoiler_text"><pre> <code class="python hljs">_count = <span class="hljs-number"><span class="hljs-number">50</span></span> values = nx.degree_histogram(subgraph) plt.figure(figsize=(<span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>), dpi=<span class="hljs-number"><span class="hljs-number">80</span></span>) plt.plot(range(_count),values[:_count],<span class="hljs-string"><span class="hljs-string">'ro-'</span></span>) <span class="hljs-comment"><span class="hljs-comment"># in-degree plt.xlabel(' ', fontsize=18) plt.xticks(range(0,_count, 5)) plt.ylabel(' ', fontsize=18) plt.title(' ', fontsize=22) plt.show()</span></span></code> </pre> </div></div><br><img src="https://habrastorage.org/webt/rt/cl/eh/rtclehktplh8tx_5mms3ny6gcom.png"><br><p>  Auf der X-Achse - die Anzahl der nächsten Bekannten, auf der Y-Achse - die Anzahl der Experten, die über die entsprechende Anzahl von Bekannten verfügen.  Zum Beispiel haben ungefähr 40.000 Experten jeweils fünf Bekannte. <br>  Beachten Sie, dass die Mode 5 Bekannte hat (es ist lustig, dass bis zu sechs Personen am Tisch sitzen können).  Gleichzeitig beträgt der arithmetische Durchschnitt der Anzahl der Bekannten 14,67 und der Median 7. Fakt ist, dass die Herren aus der obigen Bewertung den Durchschnitt stark überschätzen.  Wenn hundert Leute nicht in ChGK spielen und man 800 Bekannte hat, dann spielen sie im Durchschnitt in ChGK. </p><br><h2 id="rasstoyaniya-do-igrokov">  Entfernungen zu den Spielern </h2><br><p>  Weil  Den Durchmesser eines solchen Graphen zu bestimmen, ist <a href="https://neerc.ifmo.ru/wiki/index.php%3Ftitle%3D%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC%25D1%258B_%25D0%25BD%25D0%25B0_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D1%258C%25D1%258F%25D1%2585" rel="nofollow">etwas schwierig</a> . Machen wir es uns leichter: Nehmen Sie eine Liste mit mehreren Spielern und finden Sie das Maximum der kürzesten Entfernungen von ihnen zu anderen Experten.  Als diese Spieler habe ich einige bekannte Experten genommen, mich selbst, einen zufälligen Spieler und zwei Experten mit der größten Anzahl an Bekannten (siehe Bewertung oben).  Folgendes ist passiert: </p><br><pre> <code class="python hljs">famous_players = {<span class="hljs-number"><span class="hljs-number">9808</span></span>: <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-number"><span class="hljs-number">5195</span></span>: <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-number"><span class="hljs-number">25882</span></span>: <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-number"><span class="hljs-number">29333</span></span>: <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-number"><span class="hljs-number">118622</span></span>: <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-number"><span class="hljs-number">42511</span></span>: <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-number"><span class="hljs-number">15051</span></span>: <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-number"><span class="hljs-number">118621</span></span>: <span class="hljs-string"><span class="hljs-string">' '</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> famous_players: print(<span class="hljs-string"><span class="hljs-string">'{}: {} -      '</span></span> .format(famous_players[key], nx.eccentricity(subgraph, v=key)))</code> </pre><br><pre> <code class="plaintext hljs"> : 12 -        : 12 -        : 12 -        : 12 -        : 13 -        : 12 -        : 13 -        : 13 -      </code> </pre><br><p>  Es stellt sich heraus, dass eine starke Formulierung der Theorie von sechs Handshakes (zwei Personen sind durch nicht mehr als fünf Ebenen gemeinsamer Freunde getrennt) falsch ist.  Der Durchmesser des Diagramms beträgt höchstwahrscheinlich 13-14. <br>  Was ist mit einer schwächeren Formulierung (zwei Personen sind <strong>durchschnittlich</strong> durch nicht mehr als fünf Ebenen gemeinsamer Freunde getrennt)? </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> famous_players: paths = nx.shortest_path_length(subgraph, source=key).values() print(<span class="hljs-string"><span class="hljs-string">'{}: {} -      '</span></span> .format(famous_players[key], sum(paths) / len(paths)))</code> </pre><br><pre> <code class="plaintext hljs"> : 3.941461876893135 -        : 3.7971107852140182 -        : 3.89353216101753 -        : 3.8634887131481204 -        : 4.1443373857266215 -        : 3.575478680390894 -        : 3.608674497334192 -        : 4.564102739819904 -      </code> </pre><br><p>  Wenn wir den Wortlaut lockern, ist die Theorie erfüllt - im Durchschnitt zwischen Experten auf 4-5 Ebenen von Bekannten.  Wir zeichnen auf, wie viele Leute den zufälligen Kenner A. Druzem direkt kennen, durch einen, zwei usw.  Kenner. </p><br><div class="spoiler">  <b class="spoiler_title">Daten abrufen und Plotten</b> <div class="spoiler_text"><pre> <code class="python hljs">paths = nx.shortest_path_length(subgraph, source=<span class="hljs-number"><span class="hljs-number">9808</span></span>) neighbours = [<span class="hljs-number"><span class="hljs-number">0</span></span>] * <span class="hljs-number"><span class="hljs-number">15</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> paths: neighbours[paths[k]] += <span class="hljs-number"><span class="hljs-number">1</span></span> _count = <span class="hljs-number"><span class="hljs-number">15</span></span> plt.figure(figsize=(<span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>), dpi=<span class="hljs-number"><span class="hljs-number">80</span></span>) plt.plot(range(_count),neighbours[:_count],<span class="hljs-string"><span class="hljs-string">'ro-'</span></span>) <span class="hljs-comment"><span class="hljs-comment"># in-degree plt.xlabel(' ', fontsize=18) plt.xticks(range(_count)) plt.ylabel(' ', fontsize=18) plt.title('  .', fontsize=22) plt.show()</span></span></code> </pre> </div></div><br><p>  Auf der X-Achse der Bekanntheitsgrad von A. Druzem (direkt, durch eine, zwei usw.), auf der Y-Achse die Anzahl der Experten, die mit A. Druzem auf diese Weise vertraut sind. </p><br><img src="https://habrastorage.org/webt/fj/tt/sk/fjttskyhdbiw2qrmdux5ug1mnn8.png"><br><h2 id="socialnye-grafy">  Soziale Graphen </h2><br><p>  Weil  Es ist keine gute Idee, ein Diagramm für fast 200.000 Personen zu erstellen. Wir machen es einfacher: Wir werden die Kerch-Konnektivitätskomponente und ein Diagramm der Personen erstellen, die dem Autor zugeordnet sind. </p><br><h3 id="kerchenskaya-komponenta">  Kertsch-Komponente </h3><br><pre> <code class="python hljs">little_v = list(sorted(nx.connected_components(G), key=len, reverse=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)[<span class="hljs-number"><span class="hljs-number">1</span></span>]) little = G.subgraph(little_v) plt.figure(figsize=(<span class="hljs-number"><span class="hljs-number">24</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>), dpi=<span class="hljs-number"><span class="hljs-number">200</span></span>) pos = nx.kamada_kawai_layout(little) nx.draw(little, pos=pos, node_size=<span class="hljs-number"><span class="hljs-number">100</span></span>, edge_color=<span class="hljs-string"><span class="hljs-string">'gray'</span></span>, node_color=[val <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (node, val) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> little.degree()], cmap=plt.cm.jet) plt.show()</code> </pre> <br><img src="https://habrastorage.org/webt/_p/tu/k6/_ptuk61dseuqzz0mviea_1jw4iy.png"><br><p>  Sie können die Aufteilung der Komponenten in Teams sehen.  Darüber hinaus sind die Teams in der Regel durch ein oder zwei gesellige Kenner miteinander verbunden.  In der Mitte befindet sich ein eher kleiner Kern von Experten, die mit einer großen Anzahl anderer Spieler spielten. </p><br><h3 id="graf-odnogo-cheloveka">  Zählung von einer Person </h3><br><p>  Wir werden die engsten Bekannten einer Person finden und sehen, wie sie miteinander verwandt sind.  Um das Diagramm zu vereinfachen, werden wir die Person nicht selbst hinzufügen (sie ist bereits mit allen verbunden). </p><br><pre> <code class="python hljs">id = <span class="hljs-number"><span class="hljs-number">118622</span></span> ego_graph = [n <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> G.neighbors(id)] <span class="hljs-comment"><span class="hljs-comment">#ego_graph.append(id) ego_graph = G.subgraph(ego_graph) plt.figure(figsize=(24, 16), dpi=200) pos = nx.kamada_kawai_layout(ego_graph) nx.draw(ego_graph, pos=pos, node_size=100, edge_color='gray', node_color=[val for (node, val) in ego_graph.degree()], cmap=plt.cm.jet) plt.show()</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/ag/pq/xx/agpqxx0wdbosfslvdrrl0hu_x8u.png"><br><p>  Die Grafik ist viel dichter, ein Kern von 10-15 Personen, die sich auskennen, ist erkennbar.  Die maximale Klickgröße beträgt 13. </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><ul><li>  Es ist viel schwieriger, eine Person in der Sport-ChGK kennenzulernen als in einem sozialen Netzwerk. Sie müssen offline gehen und mindestens ein Turnier spielen.  Gleichzeitig sind Experten auf der ganzen Welt verteilt.  Die <strong>durchschnittliche</strong> Entfernung zwischen Experten beträgt jedoch weniger als fünf. </li><li>  Die Bewertungsseite verwendet <a href="https://rating.chgk.info/players.php%3Fshow_bacon_stats" rel="nofollow">die Snyatkovsky-Nummer</a> , die <a href="https://ru.wikipedia.org/wiki/%25D0%25A7%25D0%25B8%25D1%2581%25D0%25BB%25D0%25BE_%25D0%25AD%25D1%2580%25D0%25B4%25D1%2591%25D1%2588%25D0%25B0" rel="nofollow">der Erdös-Nummer</a> in der Welt von ChGK entspricht.  Herr Snyatkovsky selbst belegt in unserer Rangliste der geselligsten Kenner den dritten Platz. </li><li>  Code aus einem Artikel in meinem <a href="https://github.com/atepaevm/ChGK" rel="nofollow">Github</a> . </li><li>  Für wertvolle Kommentare <a href="https://habr.com/ru/users/firemoon/" class="user_link">dankt</a> der Autor Roger Federer, Mikhail Akulov, Vera <a href="https://habr.com/ru/users/firemoon/" class="user_link">Terentyeva</a> und <a href="https://habr.com/ru/users/firemoon/" class="user_link">Firemoon</a> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de483356/">https://habr.com/ru/post/de483356/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de483346/index.html">Wie wird die Blockchain die Buchhaltung ändern?</a></li>
<li><a href="../de483348/index.html">Wie berechnet man die "Ähnlichkeit" von Zahlen in Pässen? Und das Gleiche auch mit Tippfehlern</a></li>
<li><a href="../de483350/index.html">Neuigkeiten in unserer .NET-Dokumentation (Dezember 2019)</a></li>
<li><a href="../de483352/index.html">Python in Visual Studio Code - Veröffentlichung im Januar 2020</a></li>
<li><a href="../de483354/index.html">Fluch des zweiten Monats</a></li>
<li><a href="../de483360/index.html">Elektrische Antriebssteuerung. Amateur Erfahrung</a></li>
<li><a href="../de483364/index.html">Sie können Code bei der Arbeit schreiben, um Ihre Freizeit zu sparen.</a></li>
<li><a href="../de483366/index.html">Internet History: Vernetzung</a></li>
<li><a href="../de483368/index.html">Erstellen des ELF-Dateipackers x86_64 für Linux</a></li>
<li><a href="../de483372/index.html">So trainieren Sie ein DeepPavlov-neuronales Netzwerk auf einem Laptop mit einer GPU</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>