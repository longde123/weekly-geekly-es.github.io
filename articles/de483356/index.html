<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üß¢ üòÖ üë©üèø‚Äçü§ù‚Äçüë©üèΩ Community-Z√§hlung "Was?" Wo? Wann? ‚Äú(ChGK) oder wie viele Handshakes vor einem Freund? üè§ üë©üèæ‚Äç‚úàÔ∏è üçè</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo habr 


 Neujahrsferien sind eine gute Zeit, um  Machen Sie eine Pause von der IT  Verwenden Sie professionelle F√§higkeiten in Ihrem Lieblingsho...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Community-Z√§hlung "Was?" Wo? Wann? ‚Äú(ChGK) oder wie viele Handshakes vor einem Freund?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483356/"><img src="https://habrastorage.org/webt/sx/cv/ze/sxcvzemh1zfstlb99nne9_2hoxm.png"><br><p>  Hallo habr </p><br><p>  Neujahrsferien sind eine gute Zeit, um <del>  Machen Sie eine Pause von der IT </del>  Verwenden Sie professionelle F√§higkeiten in Ihrem Lieblingshobby.  Beim St√∂bern auf der <a href="https://rating.chgk.info/" rel="nofollow">Seite mit dem Sport-ChGK-Rating habe</a> ich eine hervorragende API gefunden, mit der Sie Daten zu allen Spielen aller Turniere <a href="https://rating.chgk.info/" rel="nofollow">abrufen</a> k√∂nnen.  So kam mir die Idee, ein Diagramm der Expertengemeinschaft zu erstellen und die Theorie von sechs Handshakes in einer geografisch verteilten und streng offline arbeitenden Community zu testen.  Unter katom Bilder von Graphen und unbrauchbaren Statistiken. </p><a name="habracut"></a><br><p>  Zun√§chst ein kurzes Bildungsprogramm, was Sport ChGK ist. </p><br><div class="spoiler">  <b class="spoiler_title">Was ist Sport ChGK</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/w8/fb/yk/w8fbykni1pnbv0jgab0-9sbo4j4.jpeg" alt="ChGK Sportturnier"></p><br><p>  Ich bin mir sicher, dass mit der Fernsehversion von "What?  Wo?  Wann? ‚ÄúDer Leser kennt den Kopf und die Buchstaben der Zuschauer.  Sport ChGK ist eine Erweiterung des Fernsehformats, mit der mehrere Mannschaften gleichzeitig spielen k√∂nnen. </p><br><p>  Im Caf√©, im Jugendhaus, in der Aula der Universit√§t versammeln sich mehrere Teams von bis zu sechs Personen.  Der Gastgeber liest die Fragen vor, eine Minute wird zum Nachdenken gegeben.  Am Ende der Minute zeichnet das Team die Reaktion auf die Spielform auf und erh√∂ht sie.  Speziell ausgebildete Schwalben sammeln Papier.  Normalerweise werden pro Spiel 36 Fragen gelesen, die in drei Runden unterteilt sind.  Wer am allermeisten geantwortet hat, der hat das gut gemacht. </p><br><p>  Es gibt viele Turniere in ChGK, es gibt sogar eine Europameisterschaft und eine Weltmeisterschaft, die ich den Neugierigen an eine <a href="http://lurkmore.to/%25D0%25A1%25D0%25BF%25D0%25BE%25D1%2580%25D1%2582%25D0%25B8%25D0%25B2%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25A7%25D0%2593%25D0%259A" rel="nofollow">seri√∂se Informationsquelle</a> sende.  Und Beispiele f√ºr Fragen finden Sie <a href="https://db.chgk.info/" rel="nofollow">hier</a> . </p></div></div><br><h2 id="poluchenie-dannyh">  Datenabruf </h2><br><p>  Wir gehen davon aus, dass die Spieler miteinander vertraut sind, wenn sie mindestens einmal an einem Spieltisch gespielt haben.  Dank der <a href="https://rating.chgk.info/api-doc" rel="nofollow">guten API ist das</a> Herunterladen von Daten zu allen Turnieren und Teams kein Problem. </p><br><p>  Unter den Spoilern wird nicht einmal Beautiful Soup verwendet, nur Nachfragen.  Ein Jupyter-Notizbuch mit dem gesamten Quellcode wird am Ende des Artikels erscheinen. </p><br><div class="spoiler">  <b class="spoiler_title">Daten f√ºr alle Turniere herunterladen</b> <div class="spoiler_text"><pre><code class="python hljs">url = <span class="hljs-string"><span class="hljs-string">'https://rating.chgk.info/api/tournaments.json/?page={}'</span></span> df = pd.DataFrame(columns=[<span class="hljs-string"><span class="hljs-string">'name'</span></span>, <span class="hljs-string"><span class="hljs-string">'start'</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>): data = requests.get(url.format(i)).json() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> data[<span class="hljs-string"><span class="hljs-string">"items"</span></span>]: df.loc[item[<span class="hljs-string"><span class="hljs-string">"idtournament"</span></span>]] = (item[<span class="hljs-string"><span class="hljs-string">"name"</span></span>], item[<span class="hljs-string"><span class="hljs-string">"date_start"</span></span>]) df.to_csv(<span class="hljs-string"><span class="hljs-string">'tournaments.csv'</span></span>)</code> </pre> </div></div><br><p>  Es bleibt noch Zeit, die Spielpl√§ne aller Turniere herunterzuladen und sich an alle Bekannten zu erinnern.  Urspr√ºnglich wollte ich die Fakten eines gemeinsamen Spiels in einem DataFrame speichern, aber die Geschwindigkeit, mit der neue Datens√§tze hinzugef√ºgt wurden, war bedr√ºckend.  Aus diesem Grund setzen wir Tupel (id1, id2), wobei id1, id2 die Bezeichner von Spielern sind, die mit einander vertraut sind.  Gleichzeitig werden Sie Duplikate los. </p><br><div class="spoiler">  <b class="spoiler_title">Kompositionen herunterladen und Bekanntschaften schlie√üen</b> <div class="spoiler_text"><pre> <code class="python hljs">df = pd.read_csv(<span class="hljs-string"><span class="hljs-string">'tournaments.csv'</span></span>).set_index(<span class="hljs-string"><span class="hljs-string">'Unnamed: 0'</span></span>) url = <span class="hljs-string"><span class="hljs-string">'https://rating.chgk.info/api/tournaments/{}/recaps.json'</span></span> links = set() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> df.index: teams = requests.get(url.format(id)).json() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> team <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> teams: t = team[<span class="hljs-string"><span class="hljs-string">"recaps"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(t)): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(i + <span class="hljs-number"><span class="hljs-number">1</span></span>, len(t)): first = int(t[i][<span class="hljs-string"><span class="hljs-string">"idplayer"</span></span>]) second = int(t[j][<span class="hljs-string"><span class="hljs-string">"idplayer"</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> first &lt; second: links.add((first, second)) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: links.add((second, first)) <span class="hljs-comment"><span class="hljs-comment">#    sleep(1) clear_output(wait=True) display('Current tournament: ' + str(df.index.get_loc(id) + 1) + '/' + str(len(df))) display('Links total: ' + str(len(links)))</span></span></code> </pre> </div></div><br><h2 id="poluchenie-grafa-i-issledovanie-komponent-svyaznosti">  Ein Diagramm erstellen und verbundene Komponenten untersuchen </h2><br><p>  Nach Abschluss der Datenvorbereitung ist es Zeit, ein Diagramm zu erstellen!  Dazu verwenden wir die <a href="https://networkx.github.io/" rel="nofollow">networkx-</a> Bibliothek, deren Funktionen f√ºr unseren Cluster v√∂llig ausreichen. </p><br><pre> <code class="python hljs">players = itertools.chain(*links) G = nx.Graph() G.add_nodes_from(players) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> links: G.add_edge(*t) print(nx.info(G))</code> </pre> <br><p>  Mittlerweile gibt es in der ChGK-Community ungef√§hr zweihunderttausend Menschen, und im Durchschnitt hat ein Experte f√ºr eine Karriere mit 12 Menschen gespielt: </p><br><pre> <code class="plaintext hljs">Number of nodes: 198145 Number of edges: 1206076 Average degree: 12.1737</code> </pre> <br><p>  Es ist Zeit herauszufinden, wie viele verbundene Komponenten in der Datierungsgrafik enthalten sind.  Networkx hat eine gro√üartige Funktion namens connected_components, die genau das tut, was Sie brauchen: </p><br><pre> <code class="python hljs">clusters_l = [len(c) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sorted(nx.connected_components(G), key=len, reverse=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)] print(clusters_l[:<span class="hljs-number"><span class="hljs-number">20</span></span>])</code> </pre> <br><p>  Fast drei Viertel der Spieler befinden sich in einer zusammenh√§ngenden Komponente, der Rest ist in sehr kleine Untergraphen unterteilt.  Es gibt mehr als achttausend von ihnen. </p><br><pre> <code class="plaintext hljs">[145922, 153, 124, 74, 72, 56, 50, 47, 42, 40, 39, 39, 38, 38, 37, 36, 36, 36, 36, 35]</code> </pre> <br><p>  Selbst im logarithmischen Ma√üstab sieht die Dominanz der Hauptkomponente beeindruckend aus.  Auf der X-Achse - die Nummer der Komponente vom gr√∂√üten bis zum kleinsten, auf der Y-Achse - ihre Gr√∂√üe (die Achse ist logarithmisch). </p><br><img src="https://habrastorage.org/webt/c9/pa/ol/c9paolwikv7_cjugzxctqtpffwy.png"><br><p>  Was hat eine so ungleichm√§√üige Verteilung der Personen in verbundenen Komponenten verursacht?  Meiner Meinung nach geht es um Folgendes: </p><br><ul><li>  Eine kleine Gruppe von Menschen kommt zum ersten Mal zum Spiel und bildet so einen kleinen Cluster f√ºr 4-6 Personen. </li><li>  Wenn die Stadt bereits eine gro√üe Gemeinde hat, verschmilzt ein solcher Cluster sehr schnell mit dem Hauptcluster. Nur eine Person muss f√ºr ein Team aus dem Hauptcluster spielen. </li><li>  Wenn in der Stadt ChGK gerade erschienen ist, wird der Cluster l√§nger leben, weil  Schwieriger ist es, f√ºr eine Mannschaft aus dem Hauptcluster zu spielen. </li></ul><br><p>  Der Prozess √§hnelt der Bildung von Regentropfen in den Wolken: Ein gro√üer Tropfen zieht kleine Tropfen an und w√§chst schnell. </p><br><p>  Bevor wir uns mit der Hauptkomponente befassen, schauen wir uns die Komponenten an erster oder neunter Stelle an (ich betrachte die Hauptkomponente als Null).  Wir testen die Hypothese, dass die Menschen in diesen Komponenten aus derselben Stadt stammen.  Der Kenner hat keine Bindung an die Stadt (was in unserer modernen Welt logisch ist).  Sie k√∂nnen sich jedoch den Heimathafen der Mannschaft ansehen, f√ºr die er das letzte Mal gespielt hat </p><br><div class="spoiler">  <b class="spoiler_title">Code der Stadtstatistik</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>): _g = list(sorted(nx.connected_components(G), key=len, reverse=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)[i]) s = pd.Series() p_url = <span class="hljs-string"><span class="hljs-string">'https://rating.chgk.info/api/players/{}/tournaments.json'</span></span> t_url = <span class="hljs-string"><span class="hljs-string">'https://rating.chgk.info/api/teams/{}.json'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> player <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _g: data = requests.get(p_url.format(player)).json() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> data: team_id = data[item][<span class="hljs-string"><span class="hljs-string">"tournaments"</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-string"><span class="hljs-string">"idteam"</span></span>] data = requests.get(t_url.format(team_id)).json() town = data[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-string"><span class="hljs-string">"town"</span></span>] s.at[len(s)] = town print(<span class="hljs-string"><span class="hljs-string">' #{}'</span></span>.format(i)) print(s.value_counts())</code> </pre> </div></div><br><p>  Zusammenfassung Platte: </p><br><div class="scrollable-table"><table><thead><tr><th>  Konnektivit√§tskomponente Nr. </th><th>  Gr√∂√üe </th><th>  St√§dte </th></tr></thead><tbody><tr><td>  1 </td><td>  153 </td><td>  Kertsch </td></tr><tr><td>  2 </td><td>  124 </td><td>  110 - Ust-Ilimsk, 12 - Wladiwostok, 2 - Irkutsk </td></tr><tr><td>  3 </td><td>  74 </td><td>  Tambow - 72, <strong>Luxemburg - 2</strong> </td></tr><tr><td>  4 </td><td>  72 </td><td>  Wald </td></tr><tr><td>  5 </td><td>  56 </td><td>  Yeisk </td></tr><tr><td>  6 </td><td>  50 </td><td>  Bischkek </td></tr><tr><td>  7 </td><td>  47 </td><td>  <strong>Gorno-Altaisk</strong> </td></tr><tr><td>  8 </td><td>  42 </td><td>  Schytomyr - 37, Glasow - 5 </td></tr><tr><td>  9 </td><td>  40 </td><td>  <strong>Gorno-Altaisk - 31, Moskau - 9</strong> </td></tr></tbody></table></div><br><p>  Ja, kleine Gruppen stammen fast ausschlie√ülich aus einer Stadt.  Bitte beachten Sie die Komponente von zweiundsiebzig Tambow-Bewohnern, die mit Luxemburg verbunden ist.  Auf den Pl√§tzen sieben und neun befinden sich Komponenten von Gorno-Altaisk, die aus irgendeinem Grund nicht miteinander verbunden sind.  Ich stelle mir den Kampf zweier ChGK-Ash-Clans wie Montecca und Capulet vor, die um die Kontrolle √ºber die Stadt k√§mpfen. <br>  Ich nehme an, dass diese Komponenten in naher Zukunft in die Hauptkomponente √ºbergehen werden <del>  werde aber weiter k√§mpfen </del>  . </p><br><h2 id="osnovnaya-komponenta-svyaznosti">  Die Hauptkomponente der Konnektivit√§t </h2><br><p>  Also kamen wir zur Hauptkomponente.  Wir erhalten den gew√ºnschten Subgraphen und sehen uns dessen Statistiken an: </p><br><pre> <code class="python hljs">subgraph_v = list(sorted(nx.connected_components(G), key=len, reverse=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>]) subgraph = G.subgraph(subgraph_v) print(nx.info(subgraph))</code> </pre> <br><p>  Es stellte sich heraus, dass die durchschnittliche Anzahl der Verbindungen h√∂her war. </p><br><pre> <code class="plaintext hljs">Number of nodes: 145922 Number of edges: 1070504 Average degree: 14.6723</code> </pre> <br><p>  Und was ist die maximale Anzahl von Verbindungen pro Spieler? </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sorted(G.degree, key=<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x[<span class="hljs-number"><span class="hljs-number">1</span></span>], reverse=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)[:<span class="hljs-number"><span class="hljs-number">10</span></span>]: print(<span class="hljs-string"><span class="hljs-string">' {}   {} '</span></span>.format(t[<span class="hljs-number"><span class="hljs-number">0</span></span>], t[<span class="hljs-number"><span class="hljs-number">1</span></span>]))</code> </pre> <br><pre> <code class="plaintext hljs"> 42511   818   15051   798   29800   678   23020   666   16581   662   5328   657   29887   651   15811   645   30352   605   1055   602 </code> </pre> <br><p>  Ehrlich gesagt bin ich ein bisschen schockiert von den Zahlen.  Wenn Sie jedes Mal mit einer neuen Mannschaft spielen, ben√∂tigen Sie 818/5 ‚âà 164 Spiele, um den ersten Platz zu erreichen.  Unglaublich. <br>  Wir werden uns an die ersten beiden Experten in diesem Rating erinnern und ihre Kommunikationsf√§higkeiten weiter einsetzen. <br>  Lassen Sie uns sch√§tzen, wie viele engste Bekannte ein Durchschnittsfachmann hat: </p><br><div class="spoiler">  <b class="spoiler_title">Daten abrufen und Plotten</b> <div class="spoiler_text"><pre> <code class="python hljs">_count = <span class="hljs-number"><span class="hljs-number">50</span></span> values = nx.degree_histogram(subgraph) plt.figure(figsize=(<span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>), dpi=<span class="hljs-number"><span class="hljs-number">80</span></span>) plt.plot(range(_count),values[:_count],<span class="hljs-string"><span class="hljs-string">'ro-'</span></span>) <span class="hljs-comment"><span class="hljs-comment"># in-degree plt.xlabel(' ', fontsize=18) plt.xticks(range(0,_count, 5)) plt.ylabel(' ', fontsize=18) plt.title(' ', fontsize=22) plt.show()</span></span></code> </pre> </div></div><br><img src="https://habrastorage.org/webt/rt/cl/eh/rtclehktplh8tx_5mms3ny6gcom.png"><br><p>  Auf der X-Achse - die Anzahl der n√§chsten Bekannten, auf der Y-Achse - die Anzahl der Experten, die √ºber die entsprechende Anzahl von Bekannten verf√ºgen.  Zum Beispiel haben ungef√§hr 40.000 Experten jeweils f√ºnf Bekannte. <br>  Beachten Sie, dass die Mode 5 Bekannte hat (es ist lustig, dass bis zu sechs Personen am Tisch sitzen k√∂nnen).  Gleichzeitig betr√§gt der arithmetische Durchschnitt der Anzahl der Bekannten 14,67 und der Median 7. Fakt ist, dass die Herren aus der obigen Bewertung den Durchschnitt stark √ºbersch√§tzen.  Wenn hundert Leute nicht in ChGK spielen und man 800 Bekannte hat, dann spielen sie im Durchschnitt in ChGK. </p><br><h2 id="rasstoyaniya-do-igrokov">  Entfernungen zu den Spielern </h2><br><p>  Weil  Den Durchmesser eines solchen Graphen zu bestimmen, ist <a href="https://neerc.ifmo.ru/wiki/index.php%3Ftitle%3D%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC%25D1%258B_%25D0%25BD%25D0%25B0_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D1%258C%25D1%258F%25D1%2585" rel="nofollow">etwas schwierig</a> . Machen wir es uns leichter: Nehmen Sie eine Liste mit mehreren Spielern und finden Sie das Maximum der k√ºrzesten Entfernungen von ihnen zu anderen Experten.  Als diese Spieler habe ich einige bekannte Experten genommen, mich selbst, einen zuf√§lligen Spieler und zwei Experten mit der gr√∂√üten Anzahl an Bekannten (siehe Bewertung oben).  Folgendes ist passiert: </p><br><pre> <code class="python hljs">famous_players = {<span class="hljs-number"><span class="hljs-number">9808</span></span>: <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-number"><span class="hljs-number">5195</span></span>: <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-number"><span class="hljs-number">25882</span></span>: <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-number"><span class="hljs-number">29333</span></span>: <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-number"><span class="hljs-number">118622</span></span>: <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-number"><span class="hljs-number">42511</span></span>: <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-number"><span class="hljs-number">15051</span></span>: <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-number"><span class="hljs-number">118621</span></span>: <span class="hljs-string"><span class="hljs-string">' '</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> famous_players: print(<span class="hljs-string"><span class="hljs-string">'{}: {} -      '</span></span> .format(famous_players[key], nx.eccentricity(subgraph, v=key)))</code> </pre><br><pre> <code class="plaintext hljs"> : 12 -        : 12 -        : 12 -        : 12 -        : 13 -        : 12 -        : 13 -        : 13 -      </code> </pre><br><p>  Es stellt sich heraus, dass eine starke Formulierung der Theorie von sechs Handshakes (zwei Personen sind durch nicht mehr als f√ºnf Ebenen gemeinsamer Freunde getrennt) falsch ist.  Der Durchmesser des Diagramms betr√§gt h√∂chstwahrscheinlich 13-14. <br>  Was ist mit einer schw√§cheren Formulierung (zwei Personen sind <strong>durchschnittlich</strong> durch nicht mehr als f√ºnf Ebenen gemeinsamer Freunde getrennt)? </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> famous_players: paths = nx.shortest_path_length(subgraph, source=key).values() print(<span class="hljs-string"><span class="hljs-string">'{}: {} -      '</span></span> .format(famous_players[key], sum(paths) / len(paths)))</code> </pre><br><pre> <code class="plaintext hljs"> : 3.941461876893135 -        : 3.7971107852140182 -        : 3.89353216101753 -        : 3.8634887131481204 -        : 4.1443373857266215 -        : 3.575478680390894 -        : 3.608674497334192 -        : 4.564102739819904 -      </code> </pre><br><p>  Wenn wir den Wortlaut lockern, ist die Theorie erf√ºllt - im Durchschnitt zwischen Experten auf 4-5 Ebenen von Bekannten.  Wir zeichnen auf, wie viele Leute den zuf√§lligen Kenner A. Druzem direkt kennen, durch einen, zwei usw.  Kenner. </p><br><div class="spoiler">  <b class="spoiler_title">Daten abrufen und Plotten</b> <div class="spoiler_text"><pre> <code class="python hljs">paths = nx.shortest_path_length(subgraph, source=<span class="hljs-number"><span class="hljs-number">9808</span></span>) neighbours = [<span class="hljs-number"><span class="hljs-number">0</span></span>] * <span class="hljs-number"><span class="hljs-number">15</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> paths: neighbours[paths[k]] += <span class="hljs-number"><span class="hljs-number">1</span></span> _count = <span class="hljs-number"><span class="hljs-number">15</span></span> plt.figure(figsize=(<span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>), dpi=<span class="hljs-number"><span class="hljs-number">80</span></span>) plt.plot(range(_count),neighbours[:_count],<span class="hljs-string"><span class="hljs-string">'ro-'</span></span>) <span class="hljs-comment"><span class="hljs-comment"># in-degree plt.xlabel(' ', fontsize=18) plt.xticks(range(_count)) plt.ylabel(' ', fontsize=18) plt.title('  .', fontsize=22) plt.show()</span></span></code> </pre> </div></div><br><p>  Auf der X-Achse der Bekanntheitsgrad von A. Druzem (direkt, durch eine, zwei usw.), auf der Y-Achse die Anzahl der Experten, die mit A. Druzem auf diese Weise vertraut sind. </p><br><img src="https://habrastorage.org/webt/fj/tt/sk/fjttskyhdbiw2qrmdux5ug1mnn8.png"><br><h2 id="socialnye-grafy">  Soziale Graphen </h2><br><p>  Weil  Es ist keine gute Idee, ein Diagramm f√ºr fast 200.000 Personen zu erstellen. Wir machen es einfacher: Wir werden die Kerch-Konnektivit√§tskomponente und ein Diagramm der Personen erstellen, die dem Autor zugeordnet sind. </p><br><h3 id="kerchenskaya-komponenta">  Kertsch-Komponente </h3><br><pre> <code class="python hljs">little_v = list(sorted(nx.connected_components(G), key=len, reverse=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)[<span class="hljs-number"><span class="hljs-number">1</span></span>]) little = G.subgraph(little_v) plt.figure(figsize=(<span class="hljs-number"><span class="hljs-number">24</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>), dpi=<span class="hljs-number"><span class="hljs-number">200</span></span>) pos = nx.kamada_kawai_layout(little) nx.draw(little, pos=pos, node_size=<span class="hljs-number"><span class="hljs-number">100</span></span>, edge_color=<span class="hljs-string"><span class="hljs-string">'gray'</span></span>, node_color=[val <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (node, val) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> little.degree()], cmap=plt.cm.jet) plt.show()</code> </pre> <br><img src="https://habrastorage.org/webt/_p/tu/k6/_ptuk61dseuqzz0mviea_1jw4iy.png"><br><p>  Sie k√∂nnen die Aufteilung der Komponenten in Teams sehen.  Dar√ºber hinaus sind die Teams in der Regel durch ein oder zwei gesellige Kenner miteinander verbunden.  In der Mitte befindet sich ein eher kleiner Kern von Experten, die mit einer gro√üen Anzahl anderer Spieler spielten. </p><br><h3 id="graf-odnogo-cheloveka">  Z√§hlung von einer Person </h3><br><p>  Wir werden die engsten Bekannten einer Person finden und sehen, wie sie miteinander verwandt sind.  Um das Diagramm zu vereinfachen, werden wir die Person nicht selbst hinzuf√ºgen (sie ist bereits mit allen verbunden). </p><br><pre> <code class="python hljs">id = <span class="hljs-number"><span class="hljs-number">118622</span></span> ego_graph = [n <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> G.neighbors(id)] <span class="hljs-comment"><span class="hljs-comment">#ego_graph.append(id) ego_graph = G.subgraph(ego_graph) plt.figure(figsize=(24, 16), dpi=200) pos = nx.kamada_kawai_layout(ego_graph) nx.draw(ego_graph, pos=pos, node_size=100, edge_color='gray', node_color=[val for (node, val) in ego_graph.degree()], cmap=plt.cm.jet) plt.show()</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/ag/pq/xx/agpqxx0wdbosfslvdrrl0hu_x8u.png"><br><p>  Die Grafik ist viel dichter, ein Kern von 10-15 Personen, die sich auskennen, ist erkennbar.  Die maximale Klickgr√∂√üe betr√§gt 13. </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><ul><li>  Es ist viel schwieriger, eine Person in der Sport-ChGK kennenzulernen als in einem sozialen Netzwerk. Sie m√ºssen offline gehen und mindestens ein Turnier spielen.  Gleichzeitig sind Experten auf der ganzen Welt verteilt.  Die <strong>durchschnittliche</strong> Entfernung zwischen Experten betr√§gt jedoch weniger als f√ºnf. </li><li>  Die Bewertungsseite verwendet <a href="https://rating.chgk.info/players.php%3Fshow_bacon_stats" rel="nofollow">die Snyatkovsky-Nummer</a> , die <a href="https://ru.wikipedia.org/wiki/%25D0%25A7%25D0%25B8%25D1%2581%25D0%25BB%25D0%25BE_%25D0%25AD%25D1%2580%25D0%25B4%25D1%2591%25D1%2588%25D0%25B0" rel="nofollow">der Erd√∂s-Nummer</a> in der Welt von ChGK entspricht.  Herr Snyatkovsky selbst belegt in unserer Rangliste der geselligsten Kenner den dritten Platz. </li><li>  Code aus einem Artikel in meinem <a href="https://github.com/atepaevm/ChGK" rel="nofollow">Github</a> . </li><li>  F√ºr wertvolle Kommentare <a href="https://habr.com/ru/users/firemoon/" class="user_link">dankt</a> der Autor Roger Federer, Mikhail Akulov, Vera <a href="https://habr.com/ru/users/firemoon/" class="user_link">Terentyeva</a> und <a href="https://habr.com/ru/users/firemoon/" class="user_link">Firemoon</a> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de483356/">https://habr.com/ru/post/de483356/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de483346/index.html">Wie wird die Blockchain die Buchhaltung √§ndern?</a></li>
<li><a href="../de483348/index.html">Wie berechnet man die "√Ñhnlichkeit" von Zahlen in P√§ssen? Und das Gleiche auch mit Tippfehlern</a></li>
<li><a href="../de483350/index.html">Neuigkeiten in unserer .NET-Dokumentation (Dezember 2019)</a></li>
<li><a href="../de483352/index.html">Python in Visual Studio Code - Ver√∂ffentlichung im Januar 2020</a></li>
<li><a href="../de483354/index.html">Fluch des zweiten Monats</a></li>
<li><a href="../de483360/index.html">Elektrische Antriebssteuerung. Amateur Erfahrung</a></li>
<li><a href="../de483364/index.html">Sie k√∂nnen Code bei der Arbeit schreiben, um Ihre Freizeit zu sparen.</a></li>
<li><a href="../de483366/index.html">Internet History: Vernetzung</a></li>
<li><a href="../de483368/index.html">Erstellen des ELF-Dateipackers x86_64 f√ºr Linux</a></li>
<li><a href="../de483372/index.html">So trainieren Sie ein DeepPavlov-neuronales Netzwerk auf einem Laptop mit einer GPU</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>