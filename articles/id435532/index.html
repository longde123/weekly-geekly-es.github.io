<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💝 ❤️ 👩🏾‍🚒 Tornado vs Aiohttp: sebuah perjalanan ke belantara kerangka asinkron 👍 🤲🏽 🚝</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai Saya Dima, dan saya telah duduk di Python selama beberapa waktu sekarang. Hari ini saya ingin menunjukkan kepada Anda perbedaan antara dua kerangk...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tornado vs Aiohttp: sebuah perjalanan ke belantara kerangka asinkron</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/avito/blog/435532/">  Hai  Saya Dima, dan saya telah duduk di Python selama beberapa waktu sekarang.  Hari ini saya ingin menunjukkan kepada Anda perbedaan antara dua kerangka kerja yang tidak sinkron - Tornado dan Aiohttp.  Saya akan menceritakan kisah tentang pilihan antara kerangka kerja dalam proyek kami, bagaimana coroutine di Tornado dan AsyncIO berbeda, saya akan menunjukkan tolok ukur dan memberikan beberapa kiat bermanfaat tentang cara masuk ke belantara kerangka kerja dan berhasil keluar dari sana. <br><br><img src="https://habrastorage.org/webt/df/uz/jm/dfuzjmbmzyoqjfd87asllltamtk.png"><br><a name="habracut"></a><br>  Seperti yang Anda ketahui, Avito adalah layanan iklan yang cukup besar.  Kami memiliki banyak data dan memuat, 35 juta pengguna setiap bulan dan 45 juta iklan aktif setiap hari.  Saya bekerja sebagai penasihat teknis kelompok pengembangan rekomendasi.  Tim saya menulis layanan microser, sekarang kami memiliki sekitar dua puluh di antaranya.  Beban menumpuk pada semua ini - seperti 5k RPS. <br><br><h2>  Memilih Kerangka Asinkron </h2><br>  Pertama, saya akan memberi tahu Anda bagaimana kami berada di tempat sekarang.  Pada 2015, kami perlu memilih kerangka kerja yang tidak sinkron, karena kami tahu: <br><br><ul><li>  Anda harus membuat banyak permintaan ke layanan microser lainnya: http, json, rpc; </li><li>  Anda perlu mengumpulkan data dari berbagai sumber sepanjang waktu: Redis, Postgres, MongoDB. </li></ul><br>  Dengan demikian, kami memiliki banyak tugas jaringan, dan aplikasi ini terutama diisi dengan input / output.  Versi python saat itu adalah 3.4, async dan menunggu belum muncul.  Aiohttp juga - dalam versi 0.x.  Asynchronous Tornado Facebook muncul pada 2010.  Banyak driver database ditulis untuknya yang kita butuhkan.  Tornado menunjukkan hasil yang stabil pada tolok ukur.  Lalu kami menghentikan pilihan kami pada kerangka ini. <br><br>  Tiga tahun kemudian, kami sangat mengerti. <br><br>  Pertama, Python 3.5 keluar dengan mekanik async / menunggu.  Kami menemukan apa perbedaan antara hasil dan hasil dari dan bagaimana Tornado konsisten dengan menunggu (spoiler: tidak terlalu baik). <br>  Kedua, kami mengalami masalah kinerja aneh dengan sejumlah besar coroutine di scheduler, bahkan ketika CPU tidak sepenuhnya terisi. <br>  Ketiga, kami menemukan bahwa ketika melakukan sejumlah besar permintaan http ke layanan Tornado lainnya, Anda harus berteman terutama dengan resolver dns asinkron, tidak menghormati batas waktu untuk membuat koneksi dan mengirimkan permintaan yang kami tentukan.  Dan secara umum, metode terbaik untuk membuat permintaan http di Tornado adalah curl, yang agak aneh dalam dirinya sendiri. <br><br>  Dalam pidatonya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di PyCon Russia 2018,</a> Andrei Svetlov mengatakan: “Jika Anda ingin menulis beberapa jenis aplikasi web yang tidak sinkron, harap hanya menulis async, tunggu.  Event loop, mungkin, Anda tidak akan memerlukannya sama sekali segera.  Jangan masuk ke belantara kerangka agar tidak bingung.  Jangan gunakan primitif level rendah, dan semuanya akan baik-baik saja dengan Anda ... ".  Sayangnya, selama tiga tahun terakhir, kami harus sering naik ke bagian dalam Tornado, belajar banyak hal menarik dari sana dan melihat traysback raksasa untuk 30-40 panggilan. <br><br><h2>  Hasil vs hasil dari </h2><br>  Salah satu masalah terbesar untuk dipahami dalam python asinkron adalah perbedaan antara hasil dan hasil. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Guido Van Rossum menulis</a> lebih banyak tentang ini.  Saya melampirkan terjemahan dengan sedikit singkatan. <br><blockquote>  Saya telah ditanya beberapa kali mengapa PEP 3156 bersikeras menggunakan hasil-dari bukan hasil, yang mengecualikan kemungkinan backporting di Python 3.2 atau bahkan 2.7. <br>  (...) <br>  kapan pun Anda menginginkan hasil di masa depan, Anda menggunakan hasil. <br>  Ini diimplementasikan sebagai berikut.  Fungsi yang berisi hasil adalah (jelas) generator, jadi harus ada semacam kode berulang.  Sebut saja dia perencana.  Bahkan, penjadwal tidak "beralih" dalam arti klasik (dengan for-loop);  alih-alih, ini mendukung dua koleksi mendatang. <br><br>  Saya akan menyebut koleksi pertama sebagai urutan "yang dapat dieksekusi".  Ini adalah masa depan, yang hasilnya tersedia.  Meskipun daftar ini tidak kosong, penjadwal memilih satu item dan mengambil satu langkah iterasi.  Langkah ini memanggil metode generator .send () dengan hasil dari masa depan (yang mungkin merupakan data yang baru saja dibaca dari soket);  di generator, hasil ini muncul sebagai nilai balik dari ekspresi hasil.  Ketika kirim () mengembalikan hasil atau selesai, penjadwal mem-parsing hasil (yang mungkin StopIteration, pengecualian lain, atau semacam objek). <br>  (Jika Anda bingung, Anda mungkin harus membaca tentang cara kerja generator, khususnya, metode .send (). Mungkin PEP 342 adalah titik awal yang baik). <br><br>  (...) <br><br>  koleksi masa depan kedua didukung oleh penjadwal terdiri dari masa depan, yang masih menunggu I / O.  Entah bagaimana mereka diteruskan ke pilih / polling / shell dll  yang memberikan panggilan balik ketika file deskriptor siap untuk I / O.  Callback sebenarnya melakukan operasi I / O yang diminta oleh masa depan, menetapkan nilai masa depan yang dihasilkan ke hasil operasi I / O, dan memindahkan masa depan ke antrian eksekusi. <br><br>  (...) <br><br>  Sekarang kita telah mencapai yang paling menarik.  Misalkan Anda sedang menulis protokol yang kompleks.  Di dalam protokol Anda, Anda membaca byte dari soket menggunakan metode recv ().  Bytes ini sampai ke buffer.  Metode recv () dibungkus dengan shell async, yang menetapkan I / O dan mengembalikan masa depan, yang dieksekusi ketika I / O selesai, seperti yang saya jelaskan di atas.  Sekarang anggaplah bahwa beberapa bagian lain dari kode Anda ingin membaca data dari buffer satu baris pada satu waktu.  Misalkan Anda menggunakan metode readline ().  Jika ukuran buffer lebih besar dari panjang garis rata-rata, metode readline () Anda bisa mendapatkan baris berikutnya dari buffer tanpa memblokir;  tetapi kadang-kadang buffer tidak berisi seluruh baris, dan readline () pada gilirannya panggilan recv () pada soket. <br><br>  Pertanyaan: haruskah readline () kembali lagi atau tidak?  Itu tidak akan sangat baik jika dia kadang-kadang mengembalikan string byte, dan kadang-kadang di masa depan, memaksa penelepon untuk melakukan pengecekan tipe dan hasil bersyarat.  Jadi jawabannya adalah readline () harus selalu mengembalikan masa depan.  Ketika readline () dipanggil, ia memeriksa buffer, dan jika ia menemukan setidaknya seluruh baris di sana, itu menciptakan masa depan, menetapkan hasil masa depan dari sebuah baris yang diambil dari buffer, dan mengembalikan masa depan.  Jika buffer tidak memiliki seluruh baris, ia memulai I / O dan mengharapkannya, dan ketika I / O selesai, ia mulai lagi. <br><br>  (...) <br><br>  Tetapi sekarang kami membuat banyak yang di masa depan yang tidak memerlukan pemblokiran I / O, tetapi masih memaksa panggilan ke penjadwal, karena readline () mengembalikan masa depan, hasil diperlukan dari pemanggil, dan itu berarti panggilan ke penjadwal. <br>  Penjadwal dapat mentransfer kontrol langsung ke coroutine jika melihat bahwa masa depan, yang telah selesai, ditampilkan, atau dapat mengembalikan masa depan ke antrian eksekusi.  Yang terakhir akan sangat memperlambat pekerjaan (asalkan ada lebih dari satu coroutine yang dapat dieksekusi), karena tidak hanya menunggu di akhir antrian diperlukan, tetapi lokalitas memori (jika ada sama sekali) mungkin juga hilang. <br><br>  (...) <br><br>  Efek bersih dari semua ini adalah bahwa penulis coroutine perlu mengetahui tentang yield di masa depan, dan oleh karena itu ada hambatan psikologis yang lebih besar untuk mengatur ulang kode kompleks menjadi coroutine yang lebih mudah dibaca - jauh lebih kuat daripada resistensi yang ada, karena pemanggilan fungsi dengan Python cukup lambat.  Dan saya ingat dari percakapan dengan Glyph bahwa kecepatan itu penting dalam struktur I / O asinkron yang khas. <br>  Sekarang mari kita bandingkan ini dengan hasil-dari. <br><br>  (...) <br><br>  Anda mungkin pernah mendengar bahwa "hasil dari S" kira-kira setara dengan "untuk i di S: hasil i".  Dalam kasus yang paling sederhana, ini benar, tetapi ini tidak cukup untuk memahami coroutine.  Pertimbangkan hal-hal berikut (jangan berpikir tentang I / O async): <br><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">driver</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(g)</span></span></span><span class="hljs-function">:</span></span> print(next(g)) g.send(<span class="hljs-number"><span class="hljs-number">42</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gen1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> val = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-string"><span class="hljs-string">'okay'</span></span> print(val) driver(gen1())</code> </pre> <br>  Kode ini mencetak dua baris yang berisi "oke" dan "42" (dan kemudian menghasilkan StopIteration yang tidak tertangani, yang dapat Anda tekan dengan menambahkan hasil pada akhir gen1).  Anda dapat melihat kode ini beraksi di pythontutor.com di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan</a> . <br><br>  Sekarang pertimbangkan hal berikut: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gen2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gen1() driver(gen2())</code> </pre><br>  Cara kerjanya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sama persis</a> .  Sekarang pikirkan.  Bagaimana cara kerjanya?  Ekstensi hasil-dari yang sederhana di for-loop tidak dapat digunakan di sini, karena dalam hal ini kode akan mengembalikan Tidak ada.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">(Cobalah)</a> .  Hasil-dari bertindak sebagai "saluran transparan" antara driver dan gen1.  Yaitu, ketika gen1 memberikan nilai "oke", ia meninggalkan gen2, melalui hasil-dari, ke pengemudi, dan ketika pengemudi mengirimkan 42 kembali ke gen2, nilai ini dikembalikan kembali melalui hasil-dari ke gen1 lagi (di mana ia menjadi hasil dari hasil ) <br><br>  Hal yang sama akan terjadi jika pengemudi melemparkan kesalahan ke generator: kesalahan melewati hasil-dari ke generator internal yang memprosesnya.  Sebagai contoh: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throwing_driver</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(g)</span></span></span><span class="hljs-function">:</span></span> print(next(g)) g.throw(RuntimeError(<span class="hljs-string"><span class="hljs-string">'booh'</span></span>)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gen1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: val = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-string"><span class="hljs-string">'okay'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> RuntimeError <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> exc: print(exc) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: print(val) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> throwing_driver(gen1())</code> </pre><br>  Kode akan memberikan "oke" dan "bah", serta kode berikut: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gen2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gen1() <span class="hljs-comment"><span class="hljs-comment"># unchanged throwing_driver(gen2())</span></span></code> </pre> <br>  (Lihat di sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">goo.gl/8tnjk</a> ) <br><br>  Sekarang saya ingin memperkenalkan grafis sederhana (ASCII) agar dapat berbicara tentang kode semacam ini.  Saya menggunakan [f1 -&gt; f2 -&gt; ... -&gt; fN) untuk mewakili tumpukan dengan f1 di bagian bawah (bingkai panggilan terlama) dan fN di bagian atas (bingkai panggilan terbaru), di mana setiap item dalam daftar adalah generator, dan -&gt; menghasilkan-dari .  Contoh pertama, driver (gen1 ()) tidak memiliki hasil-dari, tetapi memiliki generator gen1, sehingga terlihat seperti ini: <br><br><pre> <code class="python hljs">[ gen1 )</code> </pre> <br>  Pada contoh kedua, gen2 memanggil gen1 menggunakan yield-from, sehingga terlihat seperti ini: <br><br><pre> <code class="python hljs">[ gen2 -&gt; gen1 )</code> </pre> <br>  Saya menggunakan notasi matematika untuk interval setengah-terbuka [...) untuk menunjukkan bahwa frame lain dapat ditambahkan ke kanan ketika generator paling kanan menggunakan yield-from untuk memanggil generator lain, sedangkan ujung kiri lebih atau kurang diperbaiki.  Akhiran kiri adalah apa yang dilihat pengemudi (mis., Penjadwal). <br><br>  Sekarang saya siap untuk kembali ke contoh readline ().  Kita dapat menulis ulang readline () sebagai generator yang memanggil read (), generator lain menggunakan yield-from;  yang terakhir, pada gilirannya, panggilan recv (), yang melakukan input / output aktual dari soket.  Di sebelah kiri kami adalah aplikasi, yang kami juga anggap sebagai generator yang memanggil readline (), lagi-lagi menggunakan yield-from.  Skemanya adalah sebagai berikut: <br><br><pre> <code class="python hljs">[ app -&gt; readline -&gt; read -&gt; recv )</code> </pre> <br>  Sekarang generator recv () menyetel I / O, mengikatnya ke masa depan, dan meneruskannya ke scheduler menggunakan * yield * (bukan yield-from!).  masa depan pergi ke kiri di sepanjang kedua hasil-dari panah di penjadwal (terletak di sebelah kiri "[").  Perhatikan bahwa penjadwal tidak tahu bahwa itu berisi setumpuk generator;  yang dia tahu adalah dia mengandung generator paling kiri dan dia baru saja mengeluarkan masa depan.  Ketika I / O selesai, penjadwal mengatur hasil di masa depan dan mengirimkannya kembali ke generator;  hasilnya bergerak ke kanan sepanjang kedua yiled-dari panah ke generator recv, yang menerima byte yang ingin dibaca dari soket sebagai hasil hasil. <br><br>  Dengan kata lain, hasil-dari penjadwal kerangka menangani operasi I / O seperti penjadwal kerangka kerja berbasis hasil yang saya jelaskan sebelumnya.  * Tetapi: * dia tidak perlu khawatir tentang optimasi ketika masa depan sudah dieksekusi, karena penjadwal tidak berpartisipasi dalam transfer kontrol antara readline () dan read () atau antara read () dan recv (), dan sebaliknya.  Oleh karena itu, penjadwal tidak berpartisipasi sama sekali ketika app () memanggil readline (), dan readline () dapat memenuhi permintaan dari buffer (tanpa memanggil read ()) - interaksi antara app () dan readline () dalam kasus ini sepenuhnya diproses oleh penerjemah bytecode Python  Penjadwal dapat lebih sederhana, dan jumlah masa depan dibuat dan dikelola oleh penjadwal kurang, karena tidak ada masa depan yang dibuat dan dihancurkan dengan setiap panggilan coroutine.  Satu-satunya masa depan yang masih dibutuhkan adalah yang mewakili I / O aktual, misalnya, dibuat oleh recv (). <br><br>  Jika Anda telah membaca sampai titik ini, Anda layak mendapat hadiah.  Saya menghilangkan banyak detail implementasi, tetapi ilustrasi di atas pada dasarnya mencerminkan gambar dengan benar. <br><br>  Hal lain yang ingin saya tunjukkan.  * Anda dapat * membuat bagian dari kode menggunakan hasil-dari, dan bagian lain menggunakan hasil.  Tetapi hasil mengharuskan setiap tautan dalam rantai memiliki masa depan, bukan hanya coroutine.  Karena ada beberapa keuntungan menggunakan hasil-dari, saya ingin pengguna tidak harus ingat kapan harus menggunakan hasil, dan ketika hasil-dari, lebih mudah untuk selalu menggunakan hasil-dari.  Sebuah solusi sederhana bahkan memungkinkan recv () menggunakan yield-from untuk melewati I / O masa depan ke penjadwal: metode __iter__ sebenarnya adalah generator yang dikeluarkan oleh masa depan. <br><br>  (...) <br><br>  Dan satu hal lagi.  Nilai apa yang dihasilkan dari pengembalian?  Ternyata ini adalah nilai pengembalian generator * eksternal *. <br><br>  (...) <br><br>  Jadi, meskipun panah mengikat frame kiri dan kanan ke target * menghasilkan *, mereka juga melewati nilai pengembalian yang biasa dengan cara biasa, satu frame stack pada suatu waktu.  Pengecualian dipindahkan dengan cara yang sama;  tentu saja, pada setiap level, coba / kecuali diperlukan untuk menangkap mereka. <br></blockquote>  Ternyata hasil dari hampir sama dengan menunggu. <br><br><h2>  hasil dari vs async </h2><br><table><tbody><tr><td><p>  def coro () ^ </p><p>  y = hasil dari a </p></td><td>  async def async_coro (): <p>  y = menunggu a </p></td></tr><tr><td>  0 load_global </td><td>  0 load_global </td></tr><tr><td>  2 get_yield_from_iter </td><td><p>  2 get_awaitable </p></td></tr><tr><td>  4 load_const </td><td><p>  4 load_const </p></td></tr><tr><td>  6 yield_from </td><td>  6 yield_from </td></tr><tr><td>  8 store_fast </td><td><p>  8 store_fast </p></td></tr><tr><td>  10 load_const </td><td>  10 load_const <br></td></tr><tr><td>  12 return_value </td><td>  12 return_value </td></tr></tbody></table><br><br>  Dua coroutine dari sekolah lama dan baru hanya memiliki satu perbedaan kecil - dapatkan hasil dari iter vs dapatkan ditunggu. <br><br>  Kenapa ini semua?  Tornado menggunakan hasil sederhana.  Sebelum versi 5, ini menghubungkan seluruh rangkaian panggilan melalui hasil, yang tidak kompatibel dengan hasil keren baru dari / menunggu paradigma. <br><br><h2>  Benchmark asinkron paling sederhana </h2><br>  Sulit untuk menemukan kerangka kerja yang benar-benar baik, memilihnya hanya berdasarkan tes sintetik.  Dalam kehidupan nyata, banyak hal bisa salah. <br><br>  Saya mengambil Aiohttp versi 3.4.4, Tornado 5.1.1, uvloop 0.11, mengambil prosesor server Intel Xeon, CPU E5 v4, 3.6 GHz, dan dengan Python 3.6.5 saya mulai memeriksa daya saing server web. <br><br>  Masalah umum yang kami pecahkan dengan bantuan layanan microser, dan yang berfungsi dalam mode asinkron, terlihat seperti ini.  Kami akan menerima permintaan.  Untuk masing-masing dari mereka, kami akan membuat satu permintaan ke beberapa layanan mikro, mendapatkan data dari sana, lalu pergi ke dua atau tiga layanan microser lain, juga secara tidak sinkron, kemudian menulis data di suatu tempat ke database dan mengembalikan hasilnya.  Ternyata banyak poin dimana kita akan menunggu. <br><br>  Kami melakukan operasi yang lebih sederhana.  Kami menyalakan server, membuatnya tidur 50 ms.  Buat coroutine dan lengkapi.  Kami tidak akan memiliki RPS yang sangat besar (itu mungkin bukan urutan besarnya mirip dengan apa yang terlihat dalam tolok ukur sepenuhnya sintetis) dengan penundaan yang dapat diterima karena fakta bahwa banyak coroutine secara bersamaan akan berputar di server yang kompetitif. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@tornado.gen.coroutine def old_school_work(): yield tornado.gen.sleep(SLEEP_TIME) async def work(): await tornado.gen.sleep(SLEEP_TIME)</span></span></code> </pre> <br>  Load - DAPATKAN permintaan http.  Durasi - 300an, 1an - pemanasan, 5 pengulangan beban. <br><br><img src="https://habrastorage.org/webt/ep/mq/fw/epmqfwh6bv_vyfu8tymtelvohos.png"><br><br>  <i>Hasil pada persentil waktu respons layanan.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Apa itu persentil?</b> <div class="spoiler_text">  Anda memiliki sejumlah besar angka.  Persentil ke-95 X berarti bahwa 95% dari nilai dalam sampel ini kurang dari X. Dengan probabilitas 5%, angka Anda akan lebih besar dari X. <br></div></div><br>  Kita melihat bahwa Aiohttp melakukan pekerjaan yang baik pada 1000 RPS pada tes sederhana.  Sejauh ini tanpa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">uvloop</a> . <br><br>  Bandingkan Tornado dengan coroutine dari sekolah lama (hasil) dan baru (async).  Penulis sangat menyarankan untuk menggunakan async.  Kita dapat memastikan bahwa mereka benar-benar jauh lebih cepat. <br><br>  Pada 1200 RPS, Tornado, bahkan dengan coroutine sekolah baru, sudah mulai menyerah, dan Tornado dengan coroutine sekolah lama benar-benar terpesona.  Jika kita tidur selama 50 ms, dan microservice bertanggung jawab untuk 80 ms - ini tidak masuk ke gerbang sama sekali. <br><br>  Sekolah baru Tornado di 1.500 RPS telah sepenuhnya menyerah, sementara Aiohttp masih jauh dari batas 3.000 RPS.  Yang paling menarik belum datang. <br><br><h2>  Pyflame, membuat profil microservice yang berfungsi </h2><br>  Mari kita lihat apa yang terjadi saat ini dengan prosesor. <br><br><img src="https://habrastorage.org/webt/mw/-6/c-/mw-6c-vzw_kk-flygqeig93qohe.png"><br><br>  Ketika kami menemukan cara kerja layanan asinkron Python dalam produksi, kami mencoba memahami apa yang ditabraknya.  Dalam kebanyakan kasus, masalahnya adalah dengan CPU atau deskriptor.  Ada alat profil hebat yang dibuat di Uber, profiler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pyflame</a> , yang didasarkan pada panggilan sistem ptrace. <br><br>  Kami memulai beberapa layanan dalam wadah dan mulai melemparkan beban tempur di atasnya.  Seringkali ini bukan tugas yang sangat sepele - untuk membuat hanya beban yang ada dalam pertempuran, karena sering terjadi bahwa Anda menjalankan tes sintetis pada pengujian beban, Anda melihat, dan semuanya berfungsi dengan baik.  Anda mendorong beban tempur padanya, dan di sini microservice mulai tumpul. <br><br>  Selama operasi, profiler ini melakukan snapshot dari tumpukan panggilan untuk kami.  Anda tidak dapat mengubah layanan sama sekali, cukup jalankan pyflame di dekat Anda.  Ini akan mengumpulkan jejak tumpukan sekali dalam periode waktu tertentu, dan kemudian melakukan visualisasi yang keren.  Profiler ini memberikan overhead yang sangat sedikit, terutama jika dibandingkan dengan cProfile.  Pyflame juga mendukung program multithreaded.  Kami meluncurkan hal ini langsung di prod, dan kinerjanya tidak banyak menurun. <br><br><img src="https://habrastorage.org/webt/pk/2s/lu/pk2slutzgqe-szo4mbefnk_zoqe.png"><br><br>  Di sini, sumbu X adalah jumlah waktu, jumlah panggilan, ketika bingkai tumpukan berada di daftar semua bingkai tumpukan Python.  Ini adalah perkiraan jumlah waktu prosesor yang kami habiskan dalam kerangka tumpukan ini. <br><br>  Seperti yang Anda lihat, sebagian besar waktu di aiohttp tidak digunakan.  Baik: inilah yang kami inginkan dari layanan asinkron sehingga akan sering berhubungan dengan panggilan jaringan.  Kedalaman tumpukan dalam hal ini adalah sekitar 15 bingkai. <br><br>  Dalam Tornado (gambar kedua) dengan beban yang sama, lebih sedikit waktu yang dihabiskan untuk siaga dan kedalaman tumpukan dalam kasus ini adalah sekitar 30 frame. <br><br>  Berikut ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan ke svg</a> , Anda dapat memutar sendiri. <br><br><h2>  Benchmark asinkron yang lebih kompleks </h2><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#     await asyncio.sleep(SLEEP_TIME) class HardWorkHandler(tornado.web.RequestHandler): timeout_time = datetime.timedelta(seconds=SLEEP_TIME / 2) async def get(self): await work() #     await tornado.gen.multi([work(), work()]) #     try: await tornado.gen.with_timeout(self.timeout_time, work()) except tornado.util.TimeoutError: #     pass</span></span></code> </pre><br>  Harapkan runtime dari 125 ms. <br><br><img src="https://habrastorage.org/webt/i2/u5/3d/i2u53d-v1qhpmgkqiifa6q8rita.png"><br><br>  Tornado dengan uvloop bertahan lebih baik.  Tapi Aiohttp uvloop membantu lebih banyak.  Aiohttp mulai berperilaku buruk pada 2300-2400 RPS, dan dengan uvloop secara signifikan memperluas rentang beban.  Satu jalur impor, dan sekarang Anda memiliki layanan yang jauh lebih produktif. <br><br><h2>  Ringkasan </h2><br>  Saya akan meringkas apa yang ingin saya sampaikan kepada Anda hari ini. <br><br><ul><li>  Pertama, saya meluncurkan tolok ukur buatan tertentu, di mana ada coroutine panjang yang layak.  Dalam pengujian kami, Aiohttp tampil lebih baik 2,5 kali dari Tornado. </li><li>  Fakta kedua.  Uvloop sangat baik membantu meningkatkan kinerja Aiohttp (lebih baik daripada Tornado). </li><li>  Saya memberi tahu Anda tentang Pyflame, yang sering kami profil aplikasi secara langsung dalam produksi. </li><li>  Dan juga kita berbicara tentang hasil dari (menunggu) versus hasil. </li></ul><br>  Sebagai hasil dari tolok ukur ini, tim rekomendasi kami (dan beberapa yang lain) hampir sepenuhnya pindah ke Aiohttp dengan Tornado untuk layanan microser di Python dalam produksi. <br><br><ul><li>  Untuk layanan tempur, konsumsi CPU turun lebih dari 2 kali. </li><li>  Kami mulai menghormati batas waktu untuk permintaan http. </li><li>  Layanan latensi turun 2 hingga 5 kali. </li></ul><br>  Berikut ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan ke tolok ukur</a> .  Jika tertarik, Anda bisa mengulanginya.  Terima kasih atas perhatiannya.  Ajukan pertanyaan, saya akan mencoba menjawabnya. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id435532/">https://habr.com/ru/post/id435532/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id435520/index.html">Kami menulis bahasa pemrograman kami, bagian 3: Arsitektur penerjemah. Analisis struktur bahasa dan ekspresi matematika</a></li>
<li><a href="../id435522/index.html">Snapshot acara di Axonframework 3, meningkatkan kinerja</a></li>
<li><a href="../id435526/index.html">Petualangan dengan Cluster Rumah Kubernetes</a></li>
<li><a href="../id435528/index.html">5 alasan untuk sukses: mengapa Amazon telah menjadi perusahaan paling mahal di dunia</a></li>
<li><a href="../id435530/index.html">Langganan Berbayar - Ketergantungan Koneksi Otomatis pada Perangkat Seluler</a></li>
<li><a href="../id435534/index.html">Ilmu Data: Buku-Buku Tingkat Awal</a></li>
<li><a href="../id435536/index.html">Robot humanoid: manfaat dan masalah mekanisme antropomorfik</a></li>
<li><a href="../id435538/index.html">Pada 2018, lebih banyak energi "hijau" diterima di Jerman daripada listrik dari pembakaran batu bara</a></li>
<li><a href="../id435540/index.html">Kata kunci baru di Jawa</a></li>
<li><a href="../id435542/index.html">Pengembangan game dan pertahanan diploma, atau "Bagaimana saya membunuh dua burung dengan satu pancake batu pertama"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>