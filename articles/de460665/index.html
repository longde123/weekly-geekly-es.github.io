<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçπ üñåÔ∏è üìº Entwurf einer FAQ: Warum erscheinen alle drei Jahre C ++ - Standards? üñêÔ∏è üîí ‚úíÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="WG21 hat alle drei Jahre einen strengen Zeitplan (siehe P1000 ) f√ºr die Standardversion. Und keine Verz√∂gerungen. 

 W√§hrend jedes Zyklus erhalten wir...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Entwurf einer FAQ: Warum erscheinen alle drei Jahre C ++ - Standards?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/460665/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/u2/9v/zg/u29vzg2wz-7letn3lbp4ulyk9um.jpeg" width="400"></div><br>  WG21 hat alle drei Jahre einen strengen Zeitplan (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P1000</a> ) f√ºr die Standardversion.  Und keine Verz√∂gerungen. <br><br>  W√§hrend jedes Zyklus erhalten wir regelm√§√üig Fragen ‚ÄûWarum ist es so streng?‚Äú, Insbesondere von neuen Mitgliedern des Ausschusses, die mit seiner Geschichte und den Gr√ºnden f√ºr den aktuellen Stand der Dinge nicht vertraut sind.  W√§hrend einer vorl√§ufigen Telefonkonferenz mit der K√∂lner Verwaltung empfahlen mehrere Personen zu beschreiben, warum wir dies tun und wie die Entscheidung getroffen wurde, diesen Zeitplan zu √ºbernehmen. <br><br>  Ich habe das alles in Form von Fragen und Antworten f√ºr den n√§chsten Entwurf von P1000 gemalt und den Ausschussmitgliedern auf ihrem Weg nach K√∂ln eine Kopie geschickt.  Dieses Material wird in der n√§chsten √∂ffentlichen Version von P1000 ver√∂ffentlicht, wir werden es in einigen Wochen ab dem aktuellen Moment senden. <br><br>  Der Entwurf der FAQ kann jedoch f√ºr die √ñffentlichkeit von Interesse sein, daher biete ich Ihnen eine Kopie davon an.  Ich hoffe, dass es Ihnen gr√∂√ütenteils n√ºtzlich sein wird, in gewisser Weise aufkl√§ren und vielleicht sogar ein bisschen unterhalten wird. <br><br><a name="habracut"></a><br><h2>  Es gibt Fehler im Standard, sollten Sie C ++ 20 verschieben? </h2><br>  Nat√ºrlich ja und nein. <br><br>  Wir bewegen uns mit einer bestimmten Geschwindigkeit in eine bestimmte Richtung: F√ºr das letzte Jahr sind Fehlerkorrekturen geplant, daher legt der Zeitplan in C ++ ‚Äû19‚Äú (Kona) eine Frist fest, um das Hinzuf√ºgen von Features (Einfrieren von Features) in C ++ ‚Äû20‚Äú zu stoppen Wir hatten ein Jahr Zeit, um Fehler zu beheben, einschlie√ülich der Arbeit mit Kommentaren aus verschiedenen L√§ndern in diesem Sommer.  Vor Beginn des Jahres 2020 (Treffen in K√∂ln, Belfast und Prag) m√ºssen wir Feedback geben und andere L√∂sungen f√ºr Probleme sowie Fehlerbehebungen anwenden. <br><br><h2>  Wenn wir ein oder zwei weitere Besprechungen haben, k√∂nnen wir einen &lt;Feature-Namen&gt; hinzuf√ºgen, der fast fertig ist. Sollten Sie also C ++ 20 verschieben? </h2><br>  Nat√ºrlich ja und nein. <br><br>  Warten Sie, bis ein paar weitere Besprechungen stattfinden (nach Prag), und C ++ 23 wird f√ºr den Gesch√§ftsbetrieb ge√∂ffnet sein. Zun√§chst werden wir daf√ºr stimmen, dem Funktionsentwurf von C ++ 23 &lt;Feature-Name&gt; hinzuzuf√ºgen.  Dies haben wir mit den Konzepten gemacht: Sie waren nicht bereit f√ºr den √úbergang von TS direkt zu C ++ 17.  Daher stimmten sie beim ersten Treffen zu C ++ 20 (in Toronto) daf√ºr, die Grundfunktionalit√§t von Konzepten auf den Entwurf von C ++ 20 zu √ºbertragen, der viel Zeit gab, um den Rest des widerspr√ºchlichen Teils der eingef√ºhrten TS (Nicht-Template-Syntax) zu verbessern und zu verfeinern n√§chstes Jahr (San Diego).  Jetzt ist die gesamte Funktionalit√§t bereit. <br><br><h2>  Dies scheint zu streng zu sein.  Warum IS-Releases in festgelegten Intervallen (drei Jahre) ver√∂ffentlichen? </h2><br>  Denn im Fall der Ver√∂ffentlichung von C ++ IS ist dies eine der beiden Hauptoptionen f√ºr das Projektmanagement, und die Erfahrung zeigt, dass diese Option besser ist als die zweite. <br><br><h2>  Welche zwei Optionen f√ºr das Projektmanagement gibt es f√ºr die Ver√∂ffentlichung von C ++ IS? </h2><br>  Ich bin froh, dass du gefragt hast. <br><br>  Bei einer Ver√∂ffentlichung gibt es zwei Hauptoptionen: W√§hlen Sie eine Funktion oder ein Ver√∂ffentlichungsdatum aus. Wenn Sie eine ausw√§hlen, verlieren Sie die Kontrolle √ºber die Definition der anderen.  Sie k√∂nnen nicht beide gleichzeitig steuern.  Kurzum: <br><br><div class="scrollable-table"><table><tbody><tr><th>  Wenn wir es kontrollieren <br></th><th>  Wir werden aufh√∂ren, es zu kontrollieren <br></th><th>  K√∂nnen wir an ‚Äûgro√üen‚Äú mehrj√§hrigen Funktionen arbeiten? <br></th><th> Wann f√ºgen wir dem IS-Entwurf Funktionen hinzu? <br></th><th>  Was tun wir, wenn wir Probleme mit hinzugef√ºgten Funktionen finden? <br></th></tr><tr><td>  <b>"Was": Funktionen, die wir versenden</b> <br></td><td>  "Wann": Erscheinungsdatum. <br></td><td>  Ja, in den Dokumenten mit den Vorschl√§gen und dem Entwurf des IS. <br></td><td>  Normalerweise fr√ºher, um mehr Integrationstests durchzuf√ºhren ‚Üí Die durchschnittliche Stabilit√§t des Arbeitsentwurfs wird verringert. <br></td><td>  Wir verz√∂gern die Ver√∂ffentlichung des Standards. <br></td></tr><tr><td>  <b>Wann: Erscheinungsdatum</b> <br></td><td>  "Was": Funktionen, die wir versenden <br></td><td>  Ja, in Dokumenten mit Angeboten und "Feature-Filialen" in TS. <br></td><td>  Normalerweise steigt sp√§ter, wenn das Merkmal besser ausgearbeitet ist ‚Üí die durchschnittliche Stabilit√§t des Arbeitsentwurfs. <br></td><td>  Wir entfernen die Funktion und k√∂nnen sie sp√§ter erneut hinzuf√ºgen, wenn sie zum Zeitpunkt des Versands des n√§chsten IS-Zugs bereit ist. <br></td></tr></tbody></table></div><br>  Ich erkl√§re: <br><br>  <b>(1) "Was": Wir w√§hlen Funktionen aus und versenden als bereit, ohne dass eine Release-Zeit gew√§hlt werden muss</b> .  Wenn sich herausstellt, dass Sie mehr Zeit ben√∂tigen, um ein Feature aus dem Standardentwurf fertigzustellen, muss die ganze Welt auf Sie warten.  Sie arbeiten an gro√üen Funktionen, die mehrere Jahre Entwicklungszeit erfordern, und versuchen dann, die Arbeit an neuen Funktionen √ºberhaupt einzustellen, w√§hrend Sie die Version stabilisieren. <br><br>  So war es mit C ++ 98 (es wurde um 1994 erwartet, Bj√∂rn sagte, wenn die Ver√∂ffentlichung bis dahin nicht herauskommen w√ºrde, w√§re es ein Fehler) mit C ++ 11 (es wurde 0x genannt, weil x bis 2007 erwartet wurde )  Dies ist ein Ansatz, bei dem der Patient auf unbestimmte Zeit ungeschirmt bleibt, was zu einer Verz√∂gerung bei den Integrationstests und der Freigabe f√ºhrte.  Dies wiederum f√ºhrte zu gro√üer Marktunsicherheit hinsichtlich des Zeitpunkts des n√§chsten Standards und der Frage, ob dieser √ºberhaupt ver√∂ffentlicht wird (ja, nicht nur die Entwicklungsteilnehmer, sondern auch einige Mitglieder des Ausschusses, die 1996 und 2009 ernsthaft angezweifelt wurden, werden auftauchen Gibt es relevante Releases?  Mehrere Jahre lang erf√ºllten die meisten Compiler den Standard nicht, weil niemand wusste, wie viele inkompatible √Ñnderungen das Komitee in der neuen Version einf√ºhren w√ºrde, oder wann dies √ºberhaupt zu erwarten w√§re.  Dies hat zu einer Vielzahl und Fragmentierung der C ++ - Unterst√ºtzung in Compilern gef√ºhrt, die der Community zur Verf√ºgung stehen. <br><br>  Warum haben wir das getan, sind wir Idioten?  Nicht wirklich, sie waren nur unerfahren und ... sagen wir "optimistisch".  Es war eine Stra√üe, die mit besten Absichten gepflastert war.  In den Jahren 1994-1996 und 2007-2009 glaubten wir wirklich, dass wir jetzt ein, zwei oder drei weitere Sitzungen verschieben und alles tun w√ºrden, und jedes Mal w√ºrden sie um bis zu vier Jahre verschoben.  Und jetzt haben sie aus eigener Erfahrung gesehen, dass es f√ºr ein oder zwei Jahre keinen Transfer geben kann. <br><br>  Gl√ºcklicherweise hat sich dank Option (2) alles ge√§ndert. <br><br>  <b>(2) ‚ÄûWann‚Äú: Wir w√§hlen das Ver√∂ffentlichungsdatum aus und versenden die bereitgestellten Funktionen. Sie m√ºssen keine Funktionen ausw√§hlen</b> .  Wenn sich herausstellt, dass mehr Zeit ben√∂tigt wird, um ein Feature aus einem Standardentwurf zu verfeinern, verwerfen wir es und versenden, was fertig ist.  Sie k√∂nnen weiterhin an gro√üen Funktionen arbeiten, deren Erstellung wie bei mehreren Releases einige Zeit in Anspruch nimmt. Sie k√∂nnen dies jedoch in "Zweigen" von Drittanbietern tun und diese so bald wie m√∂glich dem IS-Hauptzweig hinzuf√ºgen.  Und Sie arbeiten st√§ndig an Features, da deren Entwicklung v√∂llig unabh√§ngig von der aktuellen Version ist (es gibt keinen gro√üen Verbindungspunkt). <br><br>  Wir halten seit 2012 an diesem Ansatz fest und wollen ihn nicht aufgeben.  Dies ist ein ‚Äûregelm√§√üig vern√§hter Patient‚Äú -Ansatz, der aufgrund erzwungener regelm√§√üiger Integrationen und der Weigerung, dem IS-Entwurf Arbeit hinzuzuf√ºgen, bis er ein bestimmtes Stabilit√§tsniveau erreicht, normalerweise innerhalb des Feature-Zweigs, eine h√∂here Qualit√§t erwartet.  Es schafft auch einen vorhersehbaren Ver√∂ffentlichungszyklus, auf den sich der Markt verlassen kann.  Im Laufe der Jahre begannen Autoren von Compilern nach der n√§chsten Ver√∂ffentlichung immer fr√ºher, Versionen ihrer Produkte zu ver√∂ffentlichen, die dem Standard entsprachen, was noch nie zuvor geschehen war.  Und im Jahr 2020 erwarten wir die Ver√∂ffentlichung vollst√§ndig konformer Implementierungen in einem Jahr mit der Ver√∂ffentlichung des Standards, was auch noch nie zuvor geschehen ist.  Dies ist nur zum Nutzen des gesamten Marktes - Entwickler, Benutzer, Lehrer. <br><br>  Beachten Sie auch, dass wir seit Beginn dieses Ansatzes mehr tun (gemessen an gro√üen, mittleren und kleinen Merkmalen) und mit h√∂herer Qualit√§t (gemessen an einer strikten Reduzierung der Anzahl von Fehlerberichten und Kommentaren zu) Entw√ºrfe jeder Norm).  Obwohl wir versenden, was wir vorbereitet haben (und wenn wir etwas nicht geschafft haben, versenden wir es nicht). <br><br><h2>  Wie ernst nehmen Sie Ansatz (2)?  Wenn laut einem ma√ügeblichen Mitglied des Komitees ein gro√ües Feature ‚Äûfast fertig‚Äú ist, werden Sie versucht sein, ein bisschen zu warten, oder? </h2><br>  Sehr ernst und nein. <br><br>  Wir haben Statistiken: 2016, als wir uns in Jacksonville endg√ºltig f√ºr Funktionen f√ºr C ++ 17 entschieden haben, sprach Bj√∂rn Straustrup auf einer Plenarsitzung mit einem Vorschlag, Konzepte in C ++ 17 aufzunehmen.  Als kein Konsens erzielt wurde, wurde Straustrup direkt gefragt, ob er die Ver√∂ffentlichung von C ++ 17 um ein Jahr verz√∂gern m√∂chte, um Konzepte aufzunehmen.  Bj√∂rn antwortete ohne zu z√∂gern und auszuweichen mit ‚ÄûNein‚Äú und f√ºgte hinzu, dass C ++ 17 ohne Konzepte wichtiger sei als C ++ 18 oder C ++ 19 mit Konzepten, obwohl Straustrup seit etwa 15 Jahren daran arbeite.  Die Wahl war folgende: (2) Wir ver√∂ffentlichen C ++ 17 ohne Konzepte und dann C ++ 20 mit Konzepten (was wir getan haben) oder (1) wir benennen C ++ 17 in C ++ 20 um, was isomorph ist (2). mit Ausnahme des √úberspringens von C ++ 17 und der Weigerung, das freizugeben, was bereits f√ºr C ++ 17 bereit war. <br><br><h2>  Was ist mit dem Kompromiss zwischen (1) und (2)?  Angenommen, wir halten uns normalerweise an (2), aber mit ‚Äûwenig‚Äú Flexibilit√§t, um ‚Äûein wenig‚Äú zus√§tzliche Zeit zu erhalten, wenn Sie die Funktion verfeinern m√ºssen? </h2><br>  Nein, denn es stellt sich heraus (1). <br><br>  Fred Brooks erkl√§rte im <i>Monat</i> des mythischen <i>Mannes im</i> Volksmund ‚Äûdie mythische kleine √úbertragung‚Äú und schloss daraus: ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erlaube keine kleinen √úbertragungen</a> .‚Äú <br><br>  Stellen Sie sich vor, wir haben C ++ 20 portiert.  Wir m√ºssten von (2) nach (1) zur√ºckkehren, egal wie sehr wir uns bem√ºhen, dies zu vermeiden, und w√ºrden gleichzeitig keine Vorteile erhalten.  Wenn wir C ++ 20 verschieben w√ºrden, um es zu polieren, w√ºrden wir den Standard um mindestens zwei Jahre verz√∂gern.  Es gibt keine Konzepte wie die √úbertragung von einem oder drei Meetings, da andere w√§hrend dieser Zeit (ziemlich) weiter sagen: "Nun, mein Feature ben√∂tigt nur noch ein Meeting, wir haben es immer noch neu geplant, lassen Sie uns ein anderes √ºbertragen."  Und wenn wir mindestens zwei Jahre √ºbertragen, bedeutet dies, dass C ++ 20 zu C ++ 22 und h√∂chstwahrscheinlich zu C ++ 23 wird ... aber wir werden bereits C ++ 23 ausliefern!  - Das hei√üt, wir werden auf jeden Fall C ++ 23 ausliefern, und der einzige Unterschied besteht darin, dass wir C ++ 20 nicht mit viel Arbeit √ºbertragen, bereit zur Ver√∂ffentlichung sind und nicht die ganze Welt weitere drei Jahre warten lassen.  Eine Verz√∂gerung kommt diesen Funktionen nicht zugute, die meisten von ihnen oder alle zusammen. <br><br>  Daher ist der Satz gleichbedeutend mit "Lassen Sie uns C ++ 20 in C ++ 22 oder C ++ 23 verwandeln" und der einfachen Antwort darauf: "Ja, wir werden C ++ 23 haben, aber zus√§tzlich zu C ++ 20 und nicht an seiner Stelle. "  Eine C ++ 20-Verz√∂gerung bedeutet, dass C ++ 20 √ºbersprungen wird, anstatt ein gutes, stabiles und fertiges Produkt freizugeben, und dies hat keinen Nutzen. <br><br><h2>  Aber Feature X ist kaputt / es dauert l√§nger als wir, um Fehler in C ++ 20 zu beheben! </h2><br>  Keine Frage!  Wir k√∂nnen es einfach schneiden. <br><br>  In diesem Fall muss jemand einen Brief in EWG oder LEWG (je nach Situation) mit einer Beschreibung der Situation schreiben und anbieten, die Funktion aus dem Arbeitsentwurf IS zu entfernen.  Diese Gruppen werden den Einspruch pr√ºfen. Wenn sie entscheiden, dass die Funktion fehlerhaft ist (und das Plenum mit ihnen √ºbereinstimmt), wird die Funktion auf die n√§chste C ++ - Version verschoben.  Wir haben dies bereits mit C ++ 0x-Konzepten gemacht. <br><br>  Im Fall von (1) √ºbertragen wir jedoch nicht nur diese Funktion, sondern den <b>gesamten Funktionsumfang</b> von C ++ 20 auf C ++ 23!  Das w√§re ... Pleite. <br><br><h2>  Bedeutet Ansatz (2) "Haupt- / Nebenversionen"? </h2><br>  Nein.  Zuerst haben wir dies gesagt, bis wir festgestellt haben, dass (2) nur bedeutet, dass Sie selbst aus Sicht der Haupt- / Nebenversion keine Reihe von Funktionen ausw√§hlen m√ºssen. <br><br>  Ansatz (2) bedeutet nur "wir versenden, was fertig ist".  Ver√∂ffentlichungen werden erhalten: <br><br><ul><li>  Die gleiche Gr√∂√üe (dh normalerweise der Durchschnitt) f√ºr Features ist ‚Äûkleiner‚Äú, da weniger Zeit f√ºr deren Entwicklung aufgewendet wird (z. B. jeweils weniger als drei Jahre), und im Allgemeinen erhalten wir die gleiche Anzahl abgeschlossener Features in der Version. <br></li><li>  und eine variable Gr√∂√üe (nicht ein- oder zweimal erforderlich) f√ºr "gr√∂√üere" Funktionen, die mehr Zeit in Anspruch nehmen (z. B. jeweils mehr als drei Jahre), und jede IS-Version enth√§lt so viele dieser Funktionen, wie sie f√ºr die Ver√∂ffentlichung fertigstellen k√∂nnen.  Daher gibt es in einigen Versionen mehr, in anderen weniger. <br></li></ul><br>  C ++ 14 und C ++ 17 waren relativ klein, da viel Standardisierungsaufwand f√ºr langwierige Funktionen aufgewendet wurde, die in Implementierungsvorschl√§gen (z. B. Vertr√§ge) und ‚ÄûFeature-Zweigen‚Äú in TS (z. B. Konzepte) beschrieben sind. <br><br><h2>  C ++ 20 ist eine gro√üartige Ver√∂ffentlichung ... </h2><br>  Ja  C ++ 20 bietet viele wichtige Funktionen.  Drei der gr√∂√üten beginnen mit ‚Äûko‚Äú (Konzepte, Vertr√§ge, Coroutinen), also k√∂nnten wir es co_cpp20 nennen.  Oder co_dependent. <br><br><h2>  ... und wird im Dreijahreszyklus f√ºr C ++ 20 nicht zu viel getan? </h2><br>  Nein, siehe oben "einmalig ist nicht notwendig." <br><br>  C ++ 20 ist gro√ü, nicht weil wir in drei Jahren mehr getan haben, sondern weil es viele lange Entwicklungen gibt (darunter mindestens zwei, an denen wir in der aktuellen Form seit 2012 in Form von P-S√§tzen und TS-Zweigen arbeiten ) erreichten das Stadium der Bereitschaft und beschlossen, sie in den Entwurf des IS derselben Ver√∂ffentlichung aufzunehmen. <br><br>  Fast immer werden die Hauptmerkmale seit vielen Jahren entwickelt.  Der Hauptunterschied zwischen Ansatz (1) f√ºr C ++ 98 und C ++ 11 und Ansatz (2) besteht darin, dass in C ++ 98 und C ++ 11 die Ver√∂ffentlichung verz√∂gert wurde, bis alle diese Funktionen bereit waren, und jetzt werden wir gro√ü ausgeliefert Sobald wir fertig sind und zusammen mit ihnen werden wir noch viel mehr ver√∂ffentlichen. <br><br>  C ++ 20 durchlief denselben Dreijahreszyklus wie C ++ 14 und C ++ 17.  Wir haben in den letzten drei Jahren nicht mehr getan als in den beiden vorherigen Zyklen. Wir haben lediglich mehr zu den Hauptfunktionen hinzugef√ºgt.  Wenn einer von ihnen nicht bereit w√§re, h√§tten wir ihn weggeworfen und bereits f√ºr C ++ 23 fertiggestellt.  In diesem Fall werden wir dies im Umsetzungsvorschlag melden und die Gr√ºnde erl√§utern. <br><br>  C ++ 14 + 17 + 20 bildete unseren dritten Neunjahreszyklus (2011-2020) nach C ++ 98 (1989-1998) und C ++ 11 (2002-2011).  Da wir uns jedoch an Ansatz (2) hielten, ver√∂ffentlichten wir <b>auch</b> Entwicklungen, die f√ºr das Ende von Drei- und Sechsjahreszyklen bereit waren. <br><br><h2>  Ist es nicht besser, Fehler zu erkennen, wenn sich ein Produkt in der Entwicklung befindet, und nicht, nachdem es ver√∂ffentlicht wurde? </h2><br>  Nat√ºrlich ist es besser. <br><br>  Wenn wir jedoch √ºber die Gr√ºnde f√ºr die Verz√∂gerung bei der Ver√∂ffentlichung des C ++ - Standards sprechen, impliziert diese Frage zwei falsche Annahmen: <br><br><ul><li>  dass vor der Ver√∂ffentlichung des Standards keine Funktionen herauskamen und nicht verwendet wurden (f√ºr viele gibt es bereits Erfahrung in der Produktion); <br></li><li>  und dass alle Funktionen zusammen verwendet werden k√∂nnen, bis der Standard freigegeben wird (nicht zul√§ssig). <br></li></ul><br>  Ich erkl√§re: <br><br><ol><li>  Die meisten Hauptfunktionen von C ++ 20 wurden in der Form implementiert, in der sie sich im aktuellen Entwurf des Standards in mindestens einem Compiler widerspiegeln, und wurden in den meisten F√§llen bereits im Produktionscode verwendet (dh sie sind bereits f√ºr Benutzer verf√ºgbar, die sehr zufrieden sind). .  Zum Beispiel wurden Coroutinen (nur f√ºnf Monate vor diesem Artikel eingef√ºhrt) zwei Jahre lang in der Produktion bei MSVC und ein Jahr lang bei Clang verwendet, was bei gro√üen Kunden (z. B. Azure und Facebook) sehr zufrieden war. </li><li>  Wir werden nicht viele Probleme bei der Interaktion zwischen Features feststellen, bis Benutzer sie in der Produktion verwenden, dh bevor der Standard ver√∂ffentlicht wird, da viele Entwickler darauf warten, dass er ver√∂ffentlicht wird, um verschiedene Projekte zu implementieren.  Und wenn wir Unsicherheit √ºber den Zeitpunkt der Ver√∂ffentlichung zeigen, werden sich diese Implementierungen ebenfalls verz√∂gern.  Nun, sie implementieren immer noch etwas, aber vieles wird angehalten, bis die Entwickler sicher sind, dass wir bereit sind, es zu ver√∂ffentlichen.  Fragen Sie die Ersteller von &lt;Name des bevorzugten Compilers&gt;, was passiert ist, als sie &lt;Name des gro√üen Features&gt; implementiert haben, bevor es im ver√∂ffentlichten Standard erscheint.  In vielen F√§llen ist es notwendig, wiederholt zu implementieren und Verbraucher wiederholt abzubrechen.  Daher warten Entwickler lieber darauf, dass das Komitee bestimmte Funktionen genehmigt. </li></ol><br>  Vergessen Sie nicht das Problem der Interaktionsfunktionen.  Wir ver√∂ffentlichen sie nicht nur, wenn wir bereit sind. Danach brauchen wir noch Zeit, um nach Interaktionsproblemen zwischen Features zu suchen und Unterst√ºtzung f√ºr solche Interaktionen hinzuzuf√ºgen, die wir einfach nicht herausfinden k√∂nnen, bevor neue Features weit verbreitet werden.  Und es spielt keine Rolle, wie sehr wir die Ver√∂ffentlichung des Standards verz√∂gern, es wird immer Interaktionen geben, die wir erst viel sp√§ter untersuchen k√∂nnen.  Sie m√ºssen dieses Risiko mithilfe eines flexiblen Designs verwalten, die Kompatibilit√§t der Funktionen sicherstellen und nicht warten, bis alle Risiken beseitigt sind. <br><br><h2>  Der Standard wird niemals perfekt sein ... ver√∂ffentlichen Sie keine Fehler? </h2><br>  Ja <br><br>  Wenn wir feststellen, dass die Funktion nicht bereit ist, m√ºssen wir sie aus der Version entfernen. <br><br>  Wenn wir sehen, dass eine Funktion besser sein kann und wir wissen, dass sich die √Ñnderung als abw√§rtskompatibel herausstellen kann, ist dies kein Grund, ihre Ver√∂ffentlichung jetzt abzulehnen.  Es kann als Erweiterung im folgenden C ++ ver√∂ffentlicht werden. <br><br>  Wir ver√∂ffentlichen absichtlich Funktionen, die wir in Zukunft verbessern m√∂chten, und sind zuversichtlich, dass wir die Abw√§rtskompatibilit√§t beibehalten k√∂nnen. <br><br><h2>  Aber sollten Sie nicht versuchen, Release-Fehler zu minimieren? </h2><br>  Ja  Wir versuchen es. <br><br>  Wir versuchen jedoch nicht, alle Risiken zu vermeiden.  Es besteht auch das Risiko und der (m√∂gliche) Preis, sich zu weigern, das zu ver√∂ffentlichen, was uns bereit erscheint.  Und meistens haben wir recht. <br><br><h2>  Sind Sie sicher, dass die Qualit√§t jetzt besser ist als mit dem Ansatz (1)? </h2><br>  Ja <br><br>  Gem√§√ü objektiven Metriken waren die Anzahl der Kommentare aus verschiedenen L√§ndern und Fehlerberichte, C ++ 14 und C ++ 17, unsere stabilsten Versionen, und nach diesen Metriken waren sie 3-4-mal h√∂her als C ++ 98 und C ++ 11.  Und der Grund liegt genau in der Regelm√§√üigkeit der Ver√∂ffentlichungen, in der Platzierung gro√üer Funktionen in TS-Filialen (einschlie√ülich vollst√§ndiger Beschreibungen ihrer Integration in den Hauptstandard) und in ihrer anschlie√üenden Infusion, wenn wir von der Bereitschaft √ºberzeugt sind. <br><br>  Seit 2012 wird der Hauptstandard <b>immer</b> in einem fast versandfertigen Zustand gehalten (also auch Arbeitsentw√ºrfe von der gleichen hohen Qualit√§t wie die Versionen der Standards C ++ 98 und C ++ 11).  Dies war noch nie zuvor der Fall, als wir den Patienten lange Zeit ungesichert hielten und lange Listen mit Problemen und Organen verteilten, die wir bald zur√ºckstellen werden.  Jetzt wissen wir, dass wir einen Zeitplan mit qualitativ hochwertiger Arbeit einhalten k√∂nnen, da wir immer in einem Zustand enger Bereitschaft zur Ver√∂ffentlichung bleiben.  Wenn Sie m√∂chten, k√∂nnen Sie auch jetzt noch eine CD ver√∂ffentlichen, ohne sich in K√∂ln zu treffen, und dennoch w√§re die Qualit√§t mit einer CD C ++ 98 oder C ++ 11 (in Wahrheit und ihren ver√∂ffentlichten Standards) viel h√∂her als je zuvor. .  Und wenn man bedenkt, dass C ++ 98 und C ++ 11 erfolgreich waren, bedeutet das Verst√§ndnis, dass die Qualit√§t jetzt noch h√∂her ist, dass wir auf dem richtigen Weg sind. <br><br><h2>  C ++ 98 und C ++ 11 wurden f√ºr ungef√§hr 9 Jahre entwickelt und waren sehr gute Produkte ... </h2><br>  Ja: 1989-1998 und 2002-2011. <br><br><h2>  ... und C ++ 14 und C ++ 17 waren Nebenversionen.  Ist C ++ 20 eine Hauptversion? </h2><br>  Ich wiederhole, ich glaube, es ist richtig, C ++ 14 + 17 + 20 als Ganzes zu vergleichen: Dies ist unser Neunjahreszyklus, aber da wir uns an Ansatz (2) gehalten haben, haben wir auch die Entwicklungen ver√∂ffentlicht, die bereit waren, die Dreijahres- und Sechsjahreszyklen abzuschlie√üen . <br><br><h2>  Ansatz (2) erm√∂glicht es Ihnen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">funktionsbasierte</a> Ziele wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">P0592</a> f√ºr das n√§chste C ++ zu erreichen? </h2><br>  Nat√ºrlich!  Es gibt zwar keine W√∂rter wie "sollte diese Merkmale enthalten", denn dann wird es der Ansatz sein (1). <br><br>  Es ist normal, nach bestimmten Funktionen zu streben und einer davon Priorit√§t einzur√§umen, aber dann ist es eine Frage der Priorit√§t.  Bisher werden wir nur das nehmen, was fertig ist, aber wir k√∂nnen zun√§chst ausw√§hlen, woran wir arbeiten m√∂chten, um uns so schnell wie m√∂glich vorzubereiten. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de460665/">https://habr.com/ru/post/de460665/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de460647/index.html">L√∂sen eines Jobs mit pwnable.kr 05 - Passcode. Schreiben Sie die Prozedur-Link-Tabelle √ºber die Sicherheitsanf√§lligkeit bez√ºglich Formatzeichenfolgen neu</a></li>
<li><a href="../de460651/index.html">Treffen der Society of Anonymous Testers: TMS, √úberwachung, √úberwachung der Bewertung der Suchqualit√§t und native iOS-Tests</a></li>
<li><a href="../de460655/index.html">Wie ich Telegramm gebrochen habe</a></li>
<li><a href="../de460659/index.html">Verwenden von Rohren zum Schwenken</a></li>
<li><a href="../de460661/index.html">Alles was Sie √ºber Node.js wissen m√ºssen</a></li>
<li><a href="../de460667/index.html">Automatisierung des Testens kostenpflichtiger Dienste unter iOS</a></li>
<li><a href="../de460669/index.html">So gew√§hrleisten Sie die Sicherheit der Entwicklung, sparen Zeit und Nerven</a></li>
<li><a href="../de460671/index.html">Eigentum und Ausleihe in D.</a></li>
<li><a href="../de460673/index.html">Enth√ºlle die Magie von DiffUtil</a></li>
<li><a href="../de460675/index.html">Datenextraktion beim maschinellen Lernen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>