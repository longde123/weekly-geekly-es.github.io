<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ™‹ğŸ» ğŸ‘©ğŸ»â€ğŸ­ ğŸ‘¨ğŸ¾â€âš–ï¸ C # est un langage de bas niveau? ğŸ™…ğŸ½ âš™ï¸ ğŸ‘´ğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je suis un grand fan de tout ce que fait Fabien Sanglard , j'aime son blog, et j'ai lu ses deux livres de bout en bout (dÃ©crit dans un podcast rÃ©cent ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C # est un langage de bas niveau?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443804/"> Je suis un grand fan de tout ce que fait <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fabien Sanglard</a> , j'aime son blog, et j'ai lu ses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">deux</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">livres de</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bout en bout</a> (dÃ©crit dans un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">podcast</a> rÃ©cent des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Hansleminutes</a> ). <br><br>  Fabien a rÃ©cemment Ã©crit un excellent article oÃ¹ il a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dÃ©cryptÃ© un minuscule</a> ray tracer, dÃ©sobfusquant le code et expliquant les mathÃ©matiques de maniÃ¨re fantastique.  Je recommande vraiment de prendre le temps de lire ceci! <br><br>  Mais cela m'a fait me demander <i><b>s'il Ã©tait possible de porter ce code C ++ en C #</b></i> ?  Comme j'ai dÃ» Ã©crire beaucoup de C ++ rÃ©cemment dans mon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">travail principal</a> , j'ai pensÃ© que je pouvais l'essayer. <br><br>  Mais plus important encore, je voulais avoir une meilleure idÃ©e de <b>savoir si C # est un langage de bas niveau</b> ? <br><a name="habracut"></a><br>  Une question lÃ©gÃ¨rement diffÃ©rente, mais connexe: dans quelle mesure C # convient-il Ã  la "programmation systÃ¨me"?  Ã€ ce sujet, je recommande vraiment <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'excellent post de Joe Duffy de 2013</a> . <br><br><h1>  Port de ligne </h1><br>  J'ai commencÃ© par porter simplement le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">code C ++ dÃ©sobfusculÃ©</a> ligne par ligne en C #.  C'Ã©tait assez simple: il semble que la vÃ©ritÃ© est toujours en train de dire que C # est C ++++ !!! <br><br>  L'exemple montre la structure de donnÃ©es principale - 'vecteur', voici une comparaison, C ++ Ã  gauche, C # Ã  droite: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/f14/ecc/cbd/f14ecccbd0091486caf57fc43fb2ac7f.png"></a> <br><br>  Il existe donc quelques diffÃ©rences syntaxiques, mais comme .NET vous permet de dÃ©finir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vos propres types de valeur</a> , j'ai pu obtenir les mÃªmes fonctionnalitÃ©s.  Ceci est important car le traitement du Â«vecteurÂ» comme une structure signifie que nous pouvons obtenir une meilleure Â«localitÃ© de donnÃ©esÂ» et nous n'avons pas besoin d'impliquer le garbage collector .NET, car les donnÃ©es seront poussÃ©es sur la pile (oui, je sais que c'est un dÃ©tail d'implÃ©mentation). <br><br>  Pour plus d'informations sur les <code>structs</code> ou les Â«types de valeurÂ» dans .NET, voir ici: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tas contre pile, type de valeur contre type de rÃ©fÃ©rence</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Types de valeur et types de rÃ©fÃ©rence</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MÃ©moire en .NET: oÃ¹</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La vÃ©ritÃ© sur les types de valeur</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La pile est un dÃ©tail d'implÃ©mentation, premiÃ¨re partie</a> </li></ul><br>  En particulier, dans le dernier article d'Eric Lippert, nous trouvons une citation si utile qui montre clairement ce que sont rÃ©ellement les Â«types de valeurÂ»: <br><br><blockquote>  Bien sÃ»r, le fait le plus important sur les types de valeurs n'est <b>pas les dÃ©tails de mise en Å“uvre, la <i>faÃ§on dont ils sont distinguÃ©s</i></b> , mais plutÃ´t la <i>signification sÃ©mantique originale du</i> Â«type de valeurÂ», Ã  <b>savoir qu'il est <i>toujours copiÃ© Â«par valeurÂ»</i></b> .  Si les informations d'allocation Ã©taient importantes, nous les appellerions Â«types de tasÂ» et Â«types de pileÂ».  Mais dans la plupart des cas, cela n'a pas d'importance.  La plupart du temps, la sÃ©mantique de la copie et de l'identification est pertinente. </blockquote><br>  Voyons maintenant Ã  quoi ressemblent certaines autres mÃ©thodes (encore C ++ Ã  gauche, C # Ã  droite), d'abord <code>RayTracing(..)</code> : <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/4d0/3c5/277/4d03c5277ffa4f1e73462dab4edc7dd0.png"></a> <br><br>  Ensuite, <code>QueryDatabase (..)</code> : <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/2fc/c17/839/2fcc17839a00bfc619e14c7323e28f52.png"></a> <br><br>  (voir l'article de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fabian</a> pour une explication de ce que font ces deux fonctions) <br><br>  Mais encore une fois, le fait est que C # facilite l'Ã©criture de code C ++!  Dans ce cas, le mot-clÃ© <code>ref</code> nous aide le plus, ce qui nous permet de passer une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">valeur par rÃ©fÃ©rence</a> .  Nous utilisons <code>ref</code> dans les appels de mÃ©thode depuis un certain temps, mais rÃ©cemment, des efforts ont Ã©tÃ© faits pour rÃ©soudre <code>ref</code> ailleurs: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ref retour et ref local</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SÃ©rie C # 7, partie 9: structure de rÃ©fÃ©rence</a> </li></ul><br>  <i>Parfois, l'</i> utilisation de <code>ref</code> amÃ©liore les performances, car la structure n'a alors pas besoin d'Ãªtre copiÃ©e, voir les benchmarks dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">post d'Adam Stinix</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Â«Performance traps ref locals and ref</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Returns</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">in C #Â»</a> pour plus d'informations. <br><br>  Mais la chose la plus importante est qu'un tel script fournit Ã  notre port C # le mÃªme comportement que le code source C ++.  Bien que je tiens Ã  noter que les soi-disant Â«liens gÃ©rÃ©sÂ» ne sont pas tout Ã  fait les mÃªmes que les Â«pointeursÂ», en particulier, vous ne pourrez pas effectuer d'arithmÃ©tique sur eux, voir plus Ã  ce sujet ici: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ref return n'est pas un pointeur</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pointeurs gÃ©rÃ©s</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les liens ne sont pas des adresses</a> </li></ul><br><h2>  Performances </h2><br>  Ainsi, le code Ã©tait bien portÃ©, mais les performances sont Ã©galement importantes.  Surtout dans le traceur de rayons, qui peut calculer la trame pendant plusieurs minutes.  Le code C ++ contient la variable <code>sampleCount</code> , qui contrÃ´le la qualitÃ© d'image finale, avec <code>sampleCount = 2</code> comme suit: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/10a/17e/e2d/10a17ee2df5205f5fa8bd138693bc4a6.png"><br><br>  Evidemment pas trÃ¨s rÃ©aliste! <br><br>  Mais lorsque vous arrivez Ã  <code>sampleCount = 2048</code> , tout semble <i>beaucoup</i> mieux: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/304/4b2/14d/3044b214da9027dd34dcbc19fdc75d2f.png"><br><br>  Mais commencer avec <code>sampleCount = 2048</code> prend <b>beaucoup de</b> temps, donc toutes les autres exÃ©cutions sont effectuÃ©es avec une valeur de <code>2</code> afin de respecter au moins une minute.  La modification de <code>sampleCount</code> n'affecte que le nombre d'itÃ©rations de la boucle de code la plus externe, voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cet Ã©lÃ©ment essentiel</a> pour une explication. <br><br><h3>  RÃ©sultats aprÃ¨s un port de ligne Â«naÃ¯fÂ» </h3><br>  Afin de comparer substantiellement C ++ et C #, j'ai utilisÃ© l'outil de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fenÃªtres temporelles</a> , c'est le port de la commande <code>time</code> unix.  Les premiers rÃ©sultats ressemblaient Ã  ceci: <br><br><table><thead><tr><th></th><th>  C ++ (VS 2017) </th><th>  .NET Framework (4.7.2) </th><th>  .NET Core (2.2) </th></tr></thead><tbody><tr><td>  Temps (sec) </td><td>  47,40 </td><td>  80.14 </td><td>  78.02 </td></tr><tr><td>  Au cÅ“ur (sec) </td><td>  0,14 (0,3%) </td><td>  0,72 (0,9%) </td><td>  0,63 (0,8%) </td></tr><tr><td>  Dans l'espace utilisateur (sec) </td><td>  43,86 (92,5%) </td><td>  73,06 (91,2%) </td><td>  70,66 (90,6%) </td></tr><tr><td>  Nombre d'erreurs de dÃ©faut de page </td><td>  1143 </td><td>  4818 </td><td>  5945 </td></tr><tr><td>  Ensemble de travail (Ko) </td><td>  4232 </td><td>  13 624 </td><td>  17 052 </td></tr><tr><td>  MÃ©moire extrudÃ©e (Ko) </td><td>  95 </td><td>  172 </td><td>  154 </td></tr><tr><td>  MÃ©moire non prÃ©emptive </td><td>  7 </td><td>  14 </td><td>  16 </td></tr><tr><td>  Fichier d'Ã©change (Ko) </td><td>  1460 </td><td>  10 936 </td><td>  11 024 </td></tr></tbody></table><br>  Initialement, nous voyons que le code C # est lÃ©gÃ¨rement plus lent que la version C ++, mais il s'amÃ©liore (voir ci-dessous). <br><br>  Mais voyons d'abord ce que le JIT .NET nous fait mÃªme avec ce port ligne par ligne Â«naÃ¯fÂ».  Tout d'abord, il fait un bon travail d'intÃ©gration de mÃ©thodes d'assistance plus petites.  Cela peut Ãªtre vu dans la sortie de l'excellent outil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Inlining Analyzer</a> (vert = intÃ©grÃ©): <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/4cc/484/0a5/4cc4840a53f18362d3b4f3a4249fb2d5.png"></a> <br><br>  Cependant, il <code>QueryDatabase(..)</code> pas toutes les mÃ©thodes, par exemple, en raison de la complexitÃ©, <code>QueryDatabase(..)</code> ignorÃ©: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/9e2/648/da2/9e2648da2a8ae7df5f94ceb77771c0ab.png"></a> <br><br>  Une autre fonctionnalitÃ© du compilateur .NET Just-In-Time (JIT) est la conversion d'appels de mÃ©thode spÃ©cifiques en instructions CPU correspondantes.  Nous pouvons le voir en action avec la fonction shell <code>sqrt</code> , voici le code source C # (notez l'appel Ã  <code>Math.Sqrt</code> ): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// intnv square root public static Vec operator !(Vec q) { return q * (1.0f / (float)Math.Sqrt(q % q)); }</span></span></code> </pre> <br>  Et voici le code assembleur que le JIT .NET gÃ©nÃ¨re: il n'y a pas d'appel Ã  <code>Math.Sqrt</code> et l'instruction processeur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vsqrtsd est utilisÃ©e</a> : <br><br><pre> <code class="plaintext hljs">; Assembly listing for method Program:sqrtf(float):float ; Emitting BLENDED_CODE for X64 CPU with AVX - Windows ; Tier-1 compilation ; optimized code ; rsp based frame ; partially interruptible ; Final local variable assignments ; ; V00 arg0 [V00,T00] ( 3, 3 ) float -&gt; mm0 ;# V01 OutArgs [V01 ] ( 1, 1 ) lclBlk ( 0) [rsp+0x00] "OutgoingArgSpace" ; ; Lcl frame size = 0 G_M8216_IG01: vzeroupper G_M8216_IG02: vcvtss2sd xmm0, xmm0 vsqrtsd xmm0, xmm0 vcvtsd2ss xmm0, xmm0 G_M8216_IG03: ret ; Total bytes of code 16, prolog size 3 for method Program:sqrtf(float):float ; ============================================================</code> </pre> <br>  (pour obtenir ce problÃ¨me, suivez <a href="">ces instructions</a> , utilisez le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">module complÃ©mentaire "Disasmo" VS2019</a> ou consultez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SharpLab.io</a> ) <br><br>  Ces remplacements sont Ã©galement appelÃ©s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">intrinsÃ¨ques</a> , et dans le code ci-dessous, nous pouvons voir comment le JIT les gÃ©nÃ¨re.  Cet extrait montre le mappage pour <code>AMD64</code> uniquement, mais le JIT cible Ã©galement <code>X86</code> , <code>ARM</code> et <code>ARM64</code> , la mÃ©thode complÃ¨te <a href="">ici</a> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Compiler::IsTargetIntrinsic(CorInfoIntrinsics intrinsicId) { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(_TARGET_AMD64_) || (defined(_TARGET_X86_) &amp;&amp; !defined(LEGACY_BACKEND)) switch (intrinsicId) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// AMD64/x86 has SSE2 instructions to directly compute sqrt/abs and SSE4.1 // instructions to directly compute round/ceiling/floor. // // </span></span><span class="hljs-doctag"><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span></span><span class="hljs-meta"><span class="hljs-comment"> Because the x86 backend only targets SSE for floating-point code, // it does not treat Sine, Cosine, or Round as intrinsics (JIT32 // implemented those intrinsics as x87 instructions). If this poses // a CQ problem, it may be necessary to change the implementation of // the helper calls to decrease call overhead or switch back to the // x87 instructions. This is tracked by #7097. case CORINFO_INTRINSIC_Sqrt: case CORINFO_INTRINSIC_Abs: return true; case CORINFO_INTRINSIC_Round: case CORINFO_INTRINSIC_Ceiling: case CORINFO_INTRINSIC_Floor: return compSupports(InstructionSet_SSE41); default: return false; } ... }</span></span></span></span></code> </pre> <br>  Comme vous pouvez le voir, certaines mÃ©thodes sont implÃ©mentÃ©es telles que <code>Sqrt</code> et <code>Abs</code> , tandis que d'autres utilisent des fonctions d'exÃ©cution C ++, par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">powf</a> . <br><br>  L'ensemble de ce processus est trÃ¨s bien expliquÃ© dans l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Â«Comment Math.Pow () est-il implÃ©mentÃ© dans le .NET Framework?Â»</a>  , il peut Ã©galement Ãªtre vu dans la source CoreCLR: <br><br><ul><li>  ImplÃ©mentation de <code><a href="">COMSingle::Pow</a></code> , c'est-Ã -dire la mÃ©thode qui est exÃ©cutÃ©e si <code>MathF.Pow(..)</code> appelÃ© Ã  partir du code C # <br></li><li>  Mappage dans l' <a href="">implÃ©mentation de la mÃ©thode d'exÃ©cution C</a> <br></li><li>  Version <a href="">multiplateforme de l'implÃ©mentation de powf</a> qui fournit le mÃªme comportement sur le systÃ¨me d'exploitation </li></ul><br><h3>  RÃ©sultats aprÃ¨s de simples amÃ©liorations de performances </h3><br>  Je me demande si vous pouvez immÃ©diatement amÃ©liorer le port ligne par port naÃ¯f.  AprÃ¨s quelques profils, j'ai fait deux changements majeurs: <br><br><ul><li>  Suppression de l'initialisation de la matrice en ligne </li><li>  Remplacement des fonctions de <code>Math.XXX(..)</code> par des analogues de <code>MathF.()</code> </li></ul><br>  Ces changements sont expliquÃ©s plus en dÃ©tail ci-dessous. <br><br><h4>  Suppression de l'initialisation de la matrice en ligne </h4><br>  Pour plus d'informations sur la raison pour laquelle cela est nÃ©cessaire, consultez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cette excellente rÃ©ponse Stack Overflow</a> d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Andrei Akinshin</a> , ainsi que les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tests de performances</a> et le code assembleur.  Il arrive Ã  la conclusion suivante: <br><br><blockquote>  <b>Conclusion</b> <br><br><ul><li>  <i><b>Est-ce que .NET met en cache les tableaux locaux codÃ©s en dur?</b></i>  Comme ceux qui mettent le compilateur Roslyn dans les mÃ©tadonnÃ©es. </li><li>  <i><b>Dans ce cas, il y aura des frais gÃ©nÃ©raux?</b></i>  Malheureusement, oui: pour chaque appel, JIT copiera le contenu du tableau Ã  partir des mÃ©tadonnÃ©es, ce qui prend plus de temps par rapport Ã  un tableau statique.  Le runtime sÃ©lectionne Ã©galement des objets et crÃ©e du trafic en mÃ©moire. </li><li>  <i><b>Y a-t-il lieu de s'inquiÃ©ter Ã  ce sujet?</b></i>  C'est possible.  S'il s'agit d'une mÃ©thode chaude et que vous souhaitez atteindre un bon niveau de performances, vous devez utiliser un tableau statique.  S'il s'agit d'une mÃ©thode froide qui n'affecte pas les performances de l'application, vous devrez probablement Ã©crire un Â«bonÂ» code source et placer le tableau dans la zone de mÃ©thode. </li></ul></blockquote><br>  Vous pouvez voir les modifications apportÃ©es dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce diff</a> . <br><br><h4>  Utilisation des fonctions MathF au lieu des mathÃ©matiques </h4><br>  DeuxiÃ¨mement, et surtout, j'ai considÃ©rablement amÃ©liorÃ© les performances en apportant les modifications suivantes: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> NETSTANDARD2_1 || NETCOREAPP2_0 || NETCOREAPP2_1 || NETCOREAPP2_2 || NETCOREAPP3_0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// intnv square root public static Vec operator !(Vec q) { return q * (1.0f / MathF.Sqrt(q % q)); } #else public static Vec operator !(Vec q) { return q * (1.0f / (float)Math.Sqrt(q % q)); } #endif</span></span></span></span></code> </pre> <br>  Ã€ partir de .NET Standard 2.1, des implÃ©mentations concrÃ¨tes de fonctions mathÃ©matiques communes <code>float</code> existent.  Ils se trouvent dans la classe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">System.MathF</a> .  Pour en savoir plus sur cette API et sa mise en Å“uvre, voir ici: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nouvelle API mathÃ©matique avec une prÃ©cision unique</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ajouter des fonctions mathÃ©matiques avec une seule prÃ©cision</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fournir une suite de tests unitaires pour les nouvelles API mathÃ©matiques simple prÃ©cision</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">System.Math et System.MathF doivent Ãªtre implÃ©mentÃ©s dans du code managÃ©, pas en tant que FCALL pour le runtime C</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DÃ©placement de Math.Abs â€‹â€‹(double) et Math.Abs â€‹â€‹(float) Ã  implÃ©menter dans le code managÃ©</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Conception et processus pour ajouter des outils intÃ©grÃ©s spÃ©cifiques Ã  la plate-forme Ã  .NET</a> </li></ul><br>  AprÃ¨s ces modifications, la diffÃ©rence dans les performances du code C # et C ++ a Ã©tÃ© rÃ©duite Ã  environ 10%: <br><br><table><thead><tr><th></th><th>  C ++ (VS C ++ 2017) </th><th>  .NET Framework (4.7.2) </th><th>  .NET Core (2.2) TC OFF </th><th>  .NET Core (2.2) TC ON </th></tr></thead><tbody><tr><td>  Temps (sec) </td><td>  41,38 </td><td>  58,89 </td><td>  46.04 </td><td>  44,33 </td></tr><tr><td>  Au cÅ“ur (sec) </td><td>  0,05 (0,1%) </td><td>  0,06 (0,1%) </td><td>  0,14 (0,3%) </td><td>  0,13 (0,3%) </td></tr><tr><td>  Dans l'espace utilisateur (sec) </td><td>  41,19 (99,5%) </td><td>  58,34 (99,1%) </td><td>  44,72 (97,1%) </td><td>  44,03 (99,3%) </td></tr><tr><td>  Nombre d'erreurs de dÃ©faut de page </td><td>  1119 </td><td>  4749 </td><td>  5776 </td><td>  5661 </td></tr><tr><td>  Ensemble de travail (Ko) </td><td>  4136 </td><td>  13 440 </td><td>  16 788 </td><td>  16 652 </td></tr><tr><td>  MÃ©moire extrudÃ©e (Ko) </td><td>  89 </td><td>  172 </td><td>  150 </td><td>  150 </td></tr><tr><td>  MÃ©moire non prÃ©emptive </td><td>  7 </td><td>  13 </td><td>  16 </td><td>  16 </td></tr><tr><td>  Fichier d'Ã©change (Ko) </td><td>  1428 </td><td>  10 904 </td><td>  10 960 </td><td>  11 044 </td></tr></tbody></table><br>  TC - compilation Ã  plusieurs niveaux, compilation Ã  plusieurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">niveaux</a> ( <i>je suppose</i> qu'elle sera activÃ©e par dÃ©faut dans .NET Core 3.0) <br><br>  Pour Ãªtre complet, voici les rÃ©sultats de plusieurs analyses: <br><br><table><thead><tr><th>  ExÃ©cuter </th><th>  C ++ (VS C ++ 2017) </th><th>  .NET Framework (4.7.2) </th><th>  .NET Core (2.2) TC OFF </th><th>  .NET Core (2.2) TC ON </th></tr></thead><tbody><tr><td>  TestRun-01 </td><td>  41,38 </td><td>  58,89 </td><td>  46.04 </td><td>  44,33 </td></tr><tr><td>  TestRun-02 </td><td>  41.19 </td><td>  57,65 </td><td>  46,23 </td><td>  45,96 </td></tr><tr><td>  TestRun-03 </td><td>  42.17 </td><td>  62,64 </td><td>  46,22 </td><td>  48,73 </td></tr></tbody></table><br>  <b>Remarque</b> : la diffÃ©rence entre le .NET Core et le .NET Framework est due Ã  l'absence de l'API MathF dans le .NET Framework 4.7.2, pour plus d'informations, consultez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le ticket de support .Net Framework (4.8?) Pour netstandard 2.1</a> . <br><br><h1>  Augmentez encore la productivitÃ© </h1><br>  Je suis sÃ»r que le code peut encore Ãªtre amÃ©liorÃ©! <br><br>  Si vous souhaitez rÃ©soudre la diffÃ©rence de performances, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">voici le code C #</a> .  Ã€ titre de comparaison, vous pouvez regarder le code assembleur C ++ de l'excellent service <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Explorateur du compilateur</a> . <br><br>  Enfin, si cela vous aide, voici la sortie du profileur Visual Studio avec un affichage Â«hot pathÂ» (aprÃ¨s les amÃ©liorations de performances dÃ©crites ci-dessus): <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/b78/3df/2e6/b783df2e692b62f492b78c8e7affcbf4.png"></a> <br><br><h1>  C # est-il un langage de bas niveau? </h1><br>  Ou plus prÃ©cisÃ©ment: <br><br><blockquote>  <b><b>Quelles fonctionnalitÃ©s linguistiques de la fonctionnalitÃ© C # / F # / VB.NET ou BCL / Runtime signifient une programmation "de bas niveau" *?</b></b> </blockquote><br>  * Oui, je comprends que Â«bas niveauÂ» est un terme subjectif. <br><br>  <b>Remarque:</b> chaque dÃ©veloppeur C # a sa propre idÃ©e de ce qu'est le Â«bas niveauÂ», ces fonctions seront prises pour acquises par les programmeurs C ++ ou Rust. <br><br>  Voici la liste que j'ai faite: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ref ref et locaux ref</a> <br><ul><li>  Â«Passer et retourner par rÃ©fÃ©rence pour Ã©viter de copier de grandes structures.  Les types et la mÃ©moire sÃ»rs peuvent Ãªtre encore <b>plus rapides</b> que dangereux! Â» </li></ul><br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Code non sÃ©curisÃ© dans .NET</a> <br><ul><li>  Â«Le langage C # de base, tel que dÃ©fini dans les chapitres prÃ©cÃ©dents, est trÃ¨s diffÃ©rent de C et C ++ en ce qu'il manque de pointeurs comme type de donnÃ©es.  Au lieu de cela, C # fournit des liens et la possibilitÃ© de crÃ©er des objets rÃ©gis par le garbage collector.  Cette conception, combinÃ©e Ã  d'autres fonctionnalitÃ©s, fait de C # un langage beaucoup plus sÃ»r que C ou C ++. Â» </li></ul><br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pointeurs gÃ©rÃ©s dans .NET</a> <br><ul><li>  Â«Il existe un autre type de pointeur dans le CLR - un pointeur gÃ©rÃ©.  Il peut Ãªtre dÃ©fini comme un type de lien plus gÃ©nÃ©ral qui peut pointer vers d'autres emplacements, et pas seulement vers le dÃ©but de l'objet. Â» </li></ul><br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">C # 7 Series, Part 10: Span &lt;T&gt; et Universal Memory Management</a> <br><ul><li>  Â«System.Span &lt;T&gt; est juste un type de pile ( <code>ref struct</code> ) qui enveloppe tous les modÃ¨les d'accÃ¨s Ã  la mÃ©moire, c'est un type d'accÃ¨s universel Ã  la mÃ©moire continue.  Nous pouvons imaginer une implÃ©mentation Span avec une rÃ©fÃ©rence factice et une longueur qui accepte les trois types d'accÃ¨s Ã  la mÃ©moire. " </li></ul><br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CompatibilitÃ© (Â«Guide de programmation C #Â»)</a> <br><ul><li>  Â«Le .NET Framework fournit l'interopÃ©rabilitÃ© avec du code non managÃ© via les services d'appel de plate-forme, l' <code>System.Runtime.InteropServices</code> , la compatibilitÃ© C ++ et la compatibilitÃ© COM (interopÃ©rabilitÃ© COM).Â» </li></ul></li></ul><br>  J'ai Ã©galement lancÃ© un cri sur Twitter et j'ai obtenu beaucoup plus d'options Ã  inclure dans la liste: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ben Adams</a> : Â«Outils intÃ©grÃ©s pour les plates-formes (instructions CPU)Â» <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mark Gravell</a> : Â«SIMD via Vector (qui va bien avec Span) est * assez * bas;  .NET Core devrait (bientÃ´t?) Offrir des outils directement intÃ©grÃ©s au CPU pour une utilisation plus explicite des instructions spÃ©cifiques du CPU Â» <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mark Gravell</a> : Â«JIT puissant: des choses comme l'Ã©lision de plage sur les tableaux / intervalles, ainsi que l'utilisation de rÃ¨gles per-struct-T pour supprimer les gros morceaux de code que JIT sait avec certitude qu'ils ne sont pas disponibles pour ce T ou sur votre spÃ©cifique CPU (BitConverter.IsLittleEndian, Vector.IsHardwareAccelerated, etc.) " <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Kevin Jones</a> : Â«Je mentionnerais en particulier les classes <code>MemoryMarshal</code> et <code>Unsafe</code> , et peut-Ãªtre quelques autres choses dans les <code>System.Runtime.CompilerServices</code> Â» <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Theodoros Chatsigiannakis</a> : Â«Vous pouvez Ã©galement inclure <code>__makeref</code> et le resteÂ» <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">damageboy</a> : "La capacitÃ© de gÃ©nÃ©rer dynamiquement du code qui correspond exactement Ã  l'entrÃ©e attendue, Ã©tant donnÃ© que cette derniÃ¨re ne sera connue qu'au moment de l'exÃ©cution et pourra changer pÃ©riodiquement?" <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Robert Hacken</a> : "Emission dynamique d'IL" <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Victor Baybekov</a> : Â«Stackalloc n'a pas Ã©tÃ© mentionnÃ©.  Il est Ã©galement possible d'Ã©crire IL pur (non dynamique, donc il est enregistrÃ© sur un appel de fonction), par exemple, utilisez <code>ldftn</code> mis en cache et appelez-les via <code>calli</code> .  Il existe un modÃ¨le de projet dans VS2017 qui rend cela trivial en rÃ©Ã©crivant les mÃ©thodes extern + MethodImplOptions.ForwardRef + ilasm.ex Â» <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Victor Baybekov</a> : "MethodImplOptions.AggressiveInlining" active Ã©galement la programmation de bas niveau "dans le sens oÃ¹ il vous permet d'Ã©crire du code de haut niveau avec de nombreuses petites mÃ©thodes tout en contrÃ´lant le comportement de JIT pour obtenir un rÃ©sultat optimisÃ©.  Sinon, copiez-collez des centaines de mÃ©thodes LOC ... " <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ben Adams</a> : "En utilisant les mÃªmes conventions d'appel (ABI) que dans la plate-forme de base, et p / invoque pour l'interaction?" <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Victor Baibekov</a> : Â«De plus, puisque vous avez mentionnÃ© #fsharp - il a un <code>inline</code> - <code>inline</code> qui fonctionne au niveau IL jusqu'Ã  JIT, donc il Ã©tait considÃ©rÃ© comme important au niveau de la langue.  C # cela ne suffit pas (jusqu'Ã  prÃ©sent) pour les lambdas, qui sont toujours des appels virtuels, et les solutions de contournement sont souvent Ã©tranges (gÃ©nÃ©riques limitÃ©s) " <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Alexandre Mutel</a> : Â«Nouveau SIMD embarquÃ©, post-traitement de classe / IL d'Usafe Unsafe (par exemple, custom, Fody, etc.).  Pour C # 8.0, les prochains pointeurs de fonction ... " <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Alexandre Mutel</a> : Â«Concernant IL, F # supporte directement IL dans une langue par exempleÂ» <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OmariO</a> : Â« <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">BinaryPrimitives</a> .  Niveau bas, mais sÃ»r " <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Koji Matsui</a> : Â«Et votre propre assembleur intÃ©grÃ©?  C'est difficile Ã  la fois pour la boÃ®te Ã  outils et le runtime, mais il peut remplacer la solution p / invoke actuelle et implÃ©menter le code intÃ©grÃ©, le cas Ã©chÃ©ant " <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Frank A. Kruger</a> : Â«Ldobj, stobj, initobj, initblk, cpyblkÂ» <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Conrad Coconut</a> : Â«Peut-Ãªtre diffuser du stockage local?  Tampons de taille fixe?  Vous devriez probablement mentionner les contraintes non gÃ©rÃ©es et les types blittables :) Â» <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sebastiano Mandala</a> : Â«Juste un petit ajout Ã  tout ce qui a Ã©tÃ© dit: que diriez-vous de quelque chose de simple, comme l'organisation des structures et comment le remplissage et l'alignement de la mÃ©moire et de l'ordre des champs peuvent affecter les performances du cache?  C'est quelque chose que je dois moi-mÃªme explorer. Â» <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nino Floris</a> : "Les constantes intÃ©grÃ©es via readonlyspan, stackalloc, finaliseurs, WeakReference, dÃ©lÃ©guÃ©s ouverts, MethodImplOptions, MemoryBarriers, TypedReference, varargs, SIMD, Unsafe.AsRef, peuvent dÃ©finir les types de structures en conformitÃ© exacte avec la disposition (utilisÃ©e pour TaskAwaiter et sa version)". </li></ul><br>  <b>Donc, Ã  la fin, je dirais que C # vous permet certainement d'Ã©crire du code qui ressemble Ã  C ++, et en combinaison avec les bibliothÃ¨ques d'exÃ©cution et de classe de base fournit beaucoup de fonctions de bas niveau.</b> <br><br><h1>  Lectures complÃ©mentaires </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ModÃ¨les pour C # hautes performances.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Federico Andres Lois</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Performance Quiz # 6 - Dictionnaire chinois-anglais</a> (depuis 2005, deux blogueurs Microsoft mÃ¨nent la bataille des performances C ++ contre C #) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Performance Quiz # 6 - Conclusion, exploration spatiale</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Combien C ++ est plus rapide que C #?</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Optimisation du code managÃ© C # et C ++ natif</a> (2005) </li></ul><br>  Compilateur Unity Burst: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comment Unity a fait (un sous-ensemble) de C # aussi vite que C ++</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Unity Burst Compiler: optimisation facile des performances</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Daily Pathtracer, Partie 3: C # et Unity Burst</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">C ++, C # et Unity</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Plongez au cÅ“ur du compilateur Burst - Unite LA</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr443804/">https://habr.com/ru/post/fr443804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr443786/index.html">Analyse du deuxiÃ¨me concours de quiz Android sur le stand HeadHunter au Mobius 2018 Moscou</a></li>
<li><a href="../fr443788/index.html">Les bases du routage statique dans Mikrotik RouterOS</a></li>
<li><a href="../fr443790/index.html">Erreur du survivant</a></li>
<li><a href="../fr443792/index.html">Erreurs typiques lors de l'utilisation de PostgreSQL. 2e partie</a></li>
<li><a href="../fr443798/index.html">Piratage Zotero: stockage synchronisÃ© illimitÃ© et son utilisation fluide avec rmarkdown</a></li>
<li><a href="../fr443808/index.html">Analytique des filles Ã  faible responsabilitÃ© sociale (chargÃ©e de Power BI, Qlik Sense, Tableau)</a></li>
<li><a href="../fr443810/index.html">Combien gagnent les dÃ©veloppeurs de diffÃ©rentes qualifications, 2018</a></li>
<li><a href="../fr443812/index.html">Comment implÃ©menter un langage de programmation en JavaScript. Partie 2: interprÃ¨te</a></li>
<li><a href="../fr443814/index.html">Donner est mon "ancienne entreprise"</a></li>
<li><a href="../fr443816/index.html">Le ministÃ¨re des Communications insiste sur un seul opÃ©rateur 5G</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>