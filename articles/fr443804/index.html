<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙋🏻 👩🏻‍🏭 👨🏾‍⚖️ C # est un langage de bas niveau? 🙅🏽 ⚙️ 👴🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je suis un grand fan de tout ce que fait Fabien Sanglard , j'aime son blog, et j'ai lu ses deux livres de bout en bout (décrit dans un podcast récent ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C # est un langage de bas niveau?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443804/"> Je suis un grand fan de tout ce que fait <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fabien Sanglard</a> , j'aime son blog, et j'ai lu ses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">deux</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">livres de</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bout en bout</a> (décrit dans un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">podcast</a> récent des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Hansleminutes</a> ). <br><br>  Fabien a récemment écrit un excellent article où il a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">décrypté un minuscule</a> ray tracer, désobfusquant le code et expliquant les mathématiques de manière fantastique.  Je recommande vraiment de prendre le temps de lire ceci! <br><br>  Mais cela m'a fait me demander <i><b>s'il était possible de porter ce code C ++ en C #</b></i> ?  Comme j'ai dû écrire beaucoup de C ++ récemment dans mon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">travail principal</a> , j'ai pensé que je pouvais l'essayer. <br><br>  Mais plus important encore, je voulais avoir une meilleure idée de <b>savoir si C # est un langage de bas niveau</b> ? <br><a name="habracut"></a><br>  Une question légèrement différente, mais connexe: dans quelle mesure C # convient-il à la "programmation système"?  À ce sujet, je recommande vraiment <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'excellent post de Joe Duffy de 2013</a> . <br><br><h1>  Port de ligne </h1><br>  J'ai commencé par porter simplement le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">code C ++ désobfusculé</a> ligne par ligne en C #.  C'était assez simple: il semble que la vérité est toujours en train de dire que C # est C ++++ !!! <br><br>  L'exemple montre la structure de données principale - 'vecteur', voici une comparaison, C ++ à gauche, C # à droite: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/f14/ecc/cbd/f14ecccbd0091486caf57fc43fb2ac7f.png"></a> <br><br>  Il existe donc quelques différences syntaxiques, mais comme .NET vous permet de définir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vos propres types de valeur</a> , j'ai pu obtenir les mêmes fonctionnalités.  Ceci est important car le traitement du «vecteur» comme une structure signifie que nous pouvons obtenir une meilleure «localité de données» et nous n'avons pas besoin d'impliquer le garbage collector .NET, car les données seront poussées sur la pile (oui, je sais que c'est un détail d'implémentation). <br><br>  Pour plus d'informations sur les <code>structs</code> ou les «types de valeur» dans .NET, voir ici: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tas contre pile, type de valeur contre type de référence</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Types de valeur et types de référence</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mémoire en .NET: où</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La vérité sur les types de valeur</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La pile est un détail d'implémentation, première partie</a> </li></ul><br>  En particulier, dans le dernier article d'Eric Lippert, nous trouvons une citation si utile qui montre clairement ce que sont réellement les «types de valeur»: <br><br><blockquote>  Bien sûr, le fait le plus important sur les types de valeurs n'est <b>pas les détails de mise en œuvre, la <i>façon dont ils sont distingués</i></b> , mais plutôt la <i>signification sémantique originale du</i> «type de valeur», à <b>savoir qu'il est <i>toujours copié «par valeur»</i></b> .  Si les informations d'allocation étaient importantes, nous les appellerions «types de tas» et «types de pile».  Mais dans la plupart des cas, cela n'a pas d'importance.  La plupart du temps, la sémantique de la copie et de l'identification est pertinente. </blockquote><br>  Voyons maintenant à quoi ressemblent certaines autres méthodes (encore C ++ à gauche, C # à droite), d'abord <code>RayTracing(..)</code> : <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/4d0/3c5/277/4d03c5277ffa4f1e73462dab4edc7dd0.png"></a> <br><br>  Ensuite, <code>QueryDatabase (..)</code> : <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/2fc/c17/839/2fcc17839a00bfc619e14c7323e28f52.png"></a> <br><br>  (voir l'article de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fabian</a> pour une explication de ce que font ces deux fonctions) <br><br>  Mais encore une fois, le fait est que C # facilite l'écriture de code C ++!  Dans ce cas, le mot-clé <code>ref</code> nous aide le plus, ce qui nous permet de passer une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">valeur par référence</a> .  Nous utilisons <code>ref</code> dans les appels de méthode depuis un certain temps, mais récemment, des efforts ont été faits pour résoudre <code>ref</code> ailleurs: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ref retour et ref local</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Série C # 7, partie 9: structure de référence</a> </li></ul><br>  <i>Parfois, l'</i> utilisation de <code>ref</code> améliore les performances, car la structure n'a alors pas besoin d'être copiée, voir les benchmarks dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">post d'Adam Stinix</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Performance traps ref locals and ref</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Returns</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">in C #»</a> pour plus d'informations. <br><br>  Mais la chose la plus importante est qu'un tel script fournit à notre port C # le même comportement que le code source C ++.  Bien que je tiens à noter que les soi-disant «liens gérés» ne sont pas tout à fait les mêmes que les «pointeurs», en particulier, vous ne pourrez pas effectuer d'arithmétique sur eux, voir plus à ce sujet ici: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ref return n'est pas un pointeur</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pointeurs gérés</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les liens ne sont pas des adresses</a> </li></ul><br><h2>  Performances </h2><br>  Ainsi, le code était bien porté, mais les performances sont également importantes.  Surtout dans le traceur de rayons, qui peut calculer la trame pendant plusieurs minutes.  Le code C ++ contient la variable <code>sampleCount</code> , qui contrôle la qualité d'image finale, avec <code>sampleCount = 2</code> comme suit: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/10a/17e/e2d/10a17ee2df5205f5fa8bd138693bc4a6.png"><br><br>  Evidemment pas très réaliste! <br><br>  Mais lorsque vous arrivez à <code>sampleCount = 2048</code> , tout semble <i>beaucoup</i> mieux: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/304/4b2/14d/3044b214da9027dd34dcbc19fdc75d2f.png"><br><br>  Mais commencer avec <code>sampleCount = 2048</code> prend <b>beaucoup de</b> temps, donc toutes les autres exécutions sont effectuées avec une valeur de <code>2</code> afin de respecter au moins une minute.  La modification de <code>sampleCount</code> n'affecte que le nombre d'itérations de la boucle de code la plus externe, voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cet élément essentiel</a> pour une explication. <br><br><h3>  Résultats après un port de ligne «naïf» </h3><br>  Afin de comparer substantiellement C ++ et C #, j'ai utilisé l'outil de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fenêtres temporelles</a> , c'est le port de la commande <code>time</code> unix.  Les premiers résultats ressemblaient à ceci: <br><br><table><thead><tr><th></th><th>  C ++ (VS 2017) </th><th>  .NET Framework (4.7.2) </th><th>  .NET Core (2.2) </th></tr></thead><tbody><tr><td>  Temps (sec) </td><td>  47,40 </td><td>  80.14 </td><td>  78.02 </td></tr><tr><td>  Au cœur (sec) </td><td>  0,14 (0,3%) </td><td>  0,72 (0,9%) </td><td>  0,63 (0,8%) </td></tr><tr><td>  Dans l'espace utilisateur (sec) </td><td>  43,86 (92,5%) </td><td>  73,06 (91,2%) </td><td>  70,66 (90,6%) </td></tr><tr><td>  Nombre d'erreurs de défaut de page </td><td>  1143 </td><td>  4818 </td><td>  5945 </td></tr><tr><td>  Ensemble de travail (Ko) </td><td>  4232 </td><td>  13 624 </td><td>  17 052 </td></tr><tr><td>  Mémoire extrudée (Ko) </td><td>  95 </td><td>  172 </td><td>  154 </td></tr><tr><td>  Mémoire non préemptive </td><td>  7 </td><td>  14 </td><td>  16 </td></tr><tr><td>  Fichier d'échange (Ko) </td><td>  1460 </td><td>  10 936 </td><td>  11 024 </td></tr></tbody></table><br>  Initialement, nous voyons que le code C # est légèrement plus lent que la version C ++, mais il s'améliore (voir ci-dessous). <br><br>  Mais voyons d'abord ce que le JIT .NET nous fait même avec ce port ligne par ligne «naïf».  Tout d'abord, il fait un bon travail d'intégration de méthodes d'assistance plus petites.  Cela peut être vu dans la sortie de l'excellent outil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Inlining Analyzer</a> (vert = intégré): <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/4cc/484/0a5/4cc4840a53f18362d3b4f3a4249fb2d5.png"></a> <br><br>  Cependant, il <code>QueryDatabase(..)</code> pas toutes les méthodes, par exemple, en raison de la complexité, <code>QueryDatabase(..)</code> ignoré: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/9e2/648/da2/9e2648da2a8ae7df5f94ceb77771c0ab.png"></a> <br><br>  Une autre fonctionnalité du compilateur .NET Just-In-Time (JIT) est la conversion d'appels de méthode spécifiques en instructions CPU correspondantes.  Nous pouvons le voir en action avec la fonction shell <code>sqrt</code> , voici le code source C # (notez l'appel à <code>Math.Sqrt</code> ): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// intnv square root public static Vec operator !(Vec q) { return q * (1.0f / (float)Math.Sqrt(q % q)); }</span></span></code> </pre> <br>  Et voici le code assembleur que le JIT .NET génère: il n'y a pas d'appel à <code>Math.Sqrt</code> et l'instruction processeur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vsqrtsd est utilisée</a> : <br><br><pre> <code class="plaintext hljs">; Assembly listing for method Program:sqrtf(float):float ; Emitting BLENDED_CODE for X64 CPU with AVX - Windows ; Tier-1 compilation ; optimized code ; rsp based frame ; partially interruptible ; Final local variable assignments ; ; V00 arg0 [V00,T00] ( 3, 3 ) float -&gt; mm0 ;# V01 OutArgs [V01 ] ( 1, 1 ) lclBlk ( 0) [rsp+0x00] "OutgoingArgSpace" ; ; Lcl frame size = 0 G_M8216_IG01: vzeroupper G_M8216_IG02: vcvtss2sd xmm0, xmm0 vsqrtsd xmm0, xmm0 vcvtsd2ss xmm0, xmm0 G_M8216_IG03: ret ; Total bytes of code 16, prolog size 3 for method Program:sqrtf(float):float ; ============================================================</code> </pre> <br>  (pour obtenir ce problème, suivez <a href="">ces instructions</a> , utilisez le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">module complémentaire "Disasmo" VS2019</a> ou consultez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SharpLab.io</a> ) <br><br>  Ces remplacements sont également appelés <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">intrinsèques</a> , et dans le code ci-dessous, nous pouvons voir comment le JIT les génère.  Cet extrait montre le mappage pour <code>AMD64</code> uniquement, mais le JIT cible également <code>X86</code> , <code>ARM</code> et <code>ARM64</code> , la méthode complète <a href="">ici</a> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Compiler::IsTargetIntrinsic(CorInfoIntrinsics intrinsicId) { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(_TARGET_AMD64_) || (defined(_TARGET_X86_) &amp;&amp; !defined(LEGACY_BACKEND)) switch (intrinsicId) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// AMD64/x86 has SSE2 instructions to directly compute sqrt/abs and SSE4.1 // instructions to directly compute round/ceiling/floor. // // </span></span><span class="hljs-doctag"><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span></span><span class="hljs-meta"><span class="hljs-comment"> Because the x86 backend only targets SSE for floating-point code, // it does not treat Sine, Cosine, or Round as intrinsics (JIT32 // implemented those intrinsics as x87 instructions). If this poses // a CQ problem, it may be necessary to change the implementation of // the helper calls to decrease call overhead or switch back to the // x87 instructions. This is tracked by #7097. case CORINFO_INTRINSIC_Sqrt: case CORINFO_INTRINSIC_Abs: return true; case CORINFO_INTRINSIC_Round: case CORINFO_INTRINSIC_Ceiling: case CORINFO_INTRINSIC_Floor: return compSupports(InstructionSet_SSE41); default: return false; } ... }</span></span></span></span></code> </pre> <br>  Comme vous pouvez le voir, certaines méthodes sont implémentées telles que <code>Sqrt</code> et <code>Abs</code> , tandis que d'autres utilisent des fonctions d'exécution C ++, par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">powf</a> . <br><br>  L'ensemble de ce processus est très bien expliqué dans l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Comment Math.Pow () est-il implémenté dans le .NET Framework?»</a>  , il peut également être vu dans la source CoreCLR: <br><br><ul><li>  Implémentation de <code><a href="">COMSingle::Pow</a></code> , c'est-à-dire la méthode qui est exécutée si <code>MathF.Pow(..)</code> appelé à partir du code C # <br></li><li>  Mappage dans l' <a href="">implémentation de la méthode d'exécution C</a> <br></li><li>  Version <a href="">multiplateforme de l'implémentation de powf</a> qui fournit le même comportement sur le système d'exploitation </li></ul><br><h3>  Résultats après de simples améliorations de performances </h3><br>  Je me demande si vous pouvez immédiatement améliorer le port ligne par port naïf.  Après quelques profils, j'ai fait deux changements majeurs: <br><br><ul><li>  Suppression de l'initialisation de la matrice en ligne </li><li>  Remplacement des fonctions de <code>Math.XXX(..)</code> par des analogues de <code>MathF.()</code> </li></ul><br>  Ces changements sont expliqués plus en détail ci-dessous. <br><br><h4>  Suppression de l'initialisation de la matrice en ligne </h4><br>  Pour plus d'informations sur la raison pour laquelle cela est nécessaire, consultez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cette excellente réponse Stack Overflow</a> d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Andrei Akinshin</a> , ainsi que les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tests de performances</a> et le code assembleur.  Il arrive à la conclusion suivante: <br><br><blockquote>  <b>Conclusion</b> <br><br><ul><li>  <i><b>Est-ce que .NET met en cache les tableaux locaux codés en dur?</b></i>  Comme ceux qui mettent le compilateur Roslyn dans les métadonnées. </li><li>  <i><b>Dans ce cas, il y aura des frais généraux?</b></i>  Malheureusement, oui: pour chaque appel, JIT copiera le contenu du tableau à partir des métadonnées, ce qui prend plus de temps par rapport à un tableau statique.  Le runtime sélectionne également des objets et crée du trafic en mémoire. </li><li>  <i><b>Y a-t-il lieu de s'inquiéter à ce sujet?</b></i>  C'est possible.  S'il s'agit d'une méthode chaude et que vous souhaitez atteindre un bon niveau de performances, vous devez utiliser un tableau statique.  S'il s'agit d'une méthode froide qui n'affecte pas les performances de l'application, vous devrez probablement écrire un «bon» code source et placer le tableau dans la zone de méthode. </li></ul></blockquote><br>  Vous pouvez voir les modifications apportées dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce diff</a> . <br><br><h4>  Utilisation des fonctions MathF au lieu des mathématiques </h4><br>  Deuxièmement, et surtout, j'ai considérablement amélioré les performances en apportant les modifications suivantes: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> NETSTANDARD2_1 || NETCOREAPP2_0 || NETCOREAPP2_1 || NETCOREAPP2_2 || NETCOREAPP3_0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// intnv square root public static Vec operator !(Vec q) { return q * (1.0f / MathF.Sqrt(q % q)); } #else public static Vec operator !(Vec q) { return q * (1.0f / (float)Math.Sqrt(q % q)); } #endif</span></span></span></span></code> </pre> <br>  À partir de .NET Standard 2.1, des implémentations concrètes de fonctions mathématiques communes <code>float</code> existent.  Ils se trouvent dans la classe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">System.MathF</a> .  Pour en savoir plus sur cette API et sa mise en œuvre, voir ici: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nouvelle API mathématique avec une précision unique</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ajouter des fonctions mathématiques avec une seule précision</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fournir une suite de tests unitaires pour les nouvelles API mathématiques simple précision</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">System.Math et System.MathF doivent être implémentés dans du code managé, pas en tant que FCALL pour le runtime C</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Déplacement de Math.Abs ​​(double) et Math.Abs ​​(float) à implémenter dans le code managé</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Conception et processus pour ajouter des outils intégrés spécifiques à la plate-forme à .NET</a> </li></ul><br>  Après ces modifications, la différence dans les performances du code C # et C ++ a été réduite à environ 10%: <br><br><table><thead><tr><th></th><th>  C ++ (VS C ++ 2017) </th><th>  .NET Framework (4.7.2) </th><th>  .NET Core (2.2) TC OFF </th><th>  .NET Core (2.2) TC ON </th></tr></thead><tbody><tr><td>  Temps (sec) </td><td>  41,38 </td><td>  58,89 </td><td>  46.04 </td><td>  44,33 </td></tr><tr><td>  Au cœur (sec) </td><td>  0,05 (0,1%) </td><td>  0,06 (0,1%) </td><td>  0,14 (0,3%) </td><td>  0,13 (0,3%) </td></tr><tr><td>  Dans l'espace utilisateur (sec) </td><td>  41,19 (99,5%) </td><td>  58,34 (99,1%) </td><td>  44,72 (97,1%) </td><td>  44,03 (99,3%) </td></tr><tr><td>  Nombre d'erreurs de défaut de page </td><td>  1119 </td><td>  4749 </td><td>  5776 </td><td>  5661 </td></tr><tr><td>  Ensemble de travail (Ko) </td><td>  4136 </td><td>  13 440 </td><td>  16 788 </td><td>  16 652 </td></tr><tr><td>  Mémoire extrudée (Ko) </td><td>  89 </td><td>  172 </td><td>  150 </td><td>  150 </td></tr><tr><td>  Mémoire non préemptive </td><td>  7 </td><td>  13 </td><td>  16 </td><td>  16 </td></tr><tr><td>  Fichier d'échange (Ko) </td><td>  1428 </td><td>  10 904 </td><td>  10 960 </td><td>  11 044 </td></tr></tbody></table><br>  TC - compilation à plusieurs niveaux, compilation à plusieurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">niveaux</a> ( <i>je suppose</i> qu'elle sera activée par défaut dans .NET Core 3.0) <br><br>  Pour être complet, voici les résultats de plusieurs analyses: <br><br><table><thead><tr><th>  Exécuter </th><th>  C ++ (VS C ++ 2017) </th><th>  .NET Framework (4.7.2) </th><th>  .NET Core (2.2) TC OFF </th><th>  .NET Core (2.2) TC ON </th></tr></thead><tbody><tr><td>  TestRun-01 </td><td>  41,38 </td><td>  58,89 </td><td>  46.04 </td><td>  44,33 </td></tr><tr><td>  TestRun-02 </td><td>  41.19 </td><td>  57,65 </td><td>  46,23 </td><td>  45,96 </td></tr><tr><td>  TestRun-03 </td><td>  42.17 </td><td>  62,64 </td><td>  46,22 </td><td>  48,73 </td></tr></tbody></table><br>  <b>Remarque</b> : la différence entre le .NET Core et le .NET Framework est due à l'absence de l'API MathF dans le .NET Framework 4.7.2, pour plus d'informations, consultez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le ticket de support .Net Framework (4.8?) Pour netstandard 2.1</a> . <br><br><h1>  Augmentez encore la productivité </h1><br>  Je suis sûr que le code peut encore être amélioré! <br><br>  Si vous souhaitez résoudre la différence de performances, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">voici le code C #</a> .  À titre de comparaison, vous pouvez regarder le code assembleur C ++ de l'excellent service <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Explorateur du compilateur</a> . <br><br>  Enfin, si cela vous aide, voici la sortie du profileur Visual Studio avec un affichage «hot path» (après les améliorations de performances décrites ci-dessus): <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/b78/3df/2e6/b783df2e692b62f492b78c8e7affcbf4.png"></a> <br><br><h1>  C # est-il un langage de bas niveau? </h1><br>  Ou plus précisément: <br><br><blockquote>  <b><b>Quelles fonctionnalités linguistiques de la fonctionnalité C # / F # / VB.NET ou BCL / Runtime signifient une programmation "de bas niveau" *?</b></b> </blockquote><br>  * Oui, je comprends que «bas niveau» est un terme subjectif. <br><br>  <b>Remarque:</b> chaque développeur C # a sa propre idée de ce qu'est le «bas niveau», ces fonctions seront prises pour acquises par les programmeurs C ++ ou Rust. <br><br>  Voici la liste que j'ai faite: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ref ref et locaux ref</a> <br><ul><li>  «Passer et retourner par référence pour éviter de copier de grandes structures.  Les types et la mémoire sûrs peuvent être encore <b>plus rapides</b> que dangereux! » </li></ul><br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Code non sécurisé dans .NET</a> <br><ul><li>  «Le langage C # de base, tel que défini dans les chapitres précédents, est très différent de C et C ++ en ce qu'il manque de pointeurs comme type de données.  Au lieu de cela, C # fournit des liens et la possibilité de créer des objets régis par le garbage collector.  Cette conception, combinée à d'autres fonctionnalités, fait de C # un langage beaucoup plus sûr que C ou C ++. » </li></ul><br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pointeurs gérés dans .NET</a> <br><ul><li>  «Il existe un autre type de pointeur dans le CLR - un pointeur géré.  Il peut être défini comme un type de lien plus général qui peut pointer vers d'autres emplacements, et pas seulement vers le début de l'objet. » </li></ul><br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">C # 7 Series, Part 10: Span &lt;T&gt; et Universal Memory Management</a> <br><ul><li>  «System.Span &lt;T&gt; est juste un type de pile ( <code>ref struct</code> ) qui enveloppe tous les modèles d'accès à la mémoire, c'est un type d'accès universel à la mémoire continue.  Nous pouvons imaginer une implémentation Span avec une référence factice et une longueur qui accepte les trois types d'accès à la mémoire. " </li></ul><br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Compatibilité («Guide de programmation C #»)</a> <br><ul><li>  «Le .NET Framework fournit l'interopérabilité avec du code non managé via les services d'appel de plate-forme, l' <code>System.Runtime.InteropServices</code> , la compatibilité C ++ et la compatibilité COM (interopérabilité COM).» </li></ul></li></ul><br>  J'ai également lancé un cri sur Twitter et j'ai obtenu beaucoup plus d'options à inclure dans la liste: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ben Adams</a> : «Outils intégrés pour les plates-formes (instructions CPU)» <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mark Gravell</a> : «SIMD via Vector (qui va bien avec Span) est * assez * bas;  .NET Core devrait (bientôt?) Offrir des outils directement intégrés au CPU pour une utilisation plus explicite des instructions spécifiques du CPU » <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mark Gravell</a> : «JIT puissant: des choses comme l'élision de plage sur les tableaux / intervalles, ainsi que l'utilisation de règles per-struct-T pour supprimer les gros morceaux de code que JIT sait avec certitude qu'ils ne sont pas disponibles pour ce T ou sur votre spécifique CPU (BitConverter.IsLittleEndian, Vector.IsHardwareAccelerated, etc.) " <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Kevin Jones</a> : «Je mentionnerais en particulier les classes <code>MemoryMarshal</code> et <code>Unsafe</code> , et peut-être quelques autres choses dans les <code>System.Runtime.CompilerServices</code> » <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Theodoros Chatsigiannakis</a> : «Vous pouvez également inclure <code>__makeref</code> et le reste» <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">damageboy</a> : "La capacité de générer dynamiquement du code qui correspond exactement à l'entrée attendue, étant donné que cette dernière ne sera connue qu'au moment de l'exécution et pourra changer périodiquement?" <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Robert Hacken</a> : "Emission dynamique d'IL" <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Victor Baybekov</a> : «Stackalloc n'a pas été mentionné.  Il est également possible d'écrire IL pur (non dynamique, donc il est enregistré sur un appel de fonction), par exemple, utilisez <code>ldftn</code> mis en cache et appelez-les via <code>calli</code> .  Il existe un modèle de projet dans VS2017 qui rend cela trivial en réécrivant les méthodes extern + MethodImplOptions.ForwardRef + ilasm.ex » <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Victor Baybekov</a> : "MethodImplOptions.AggressiveInlining" active également la programmation de bas niveau "dans le sens où il vous permet d'écrire du code de haut niveau avec de nombreuses petites méthodes tout en contrôlant le comportement de JIT pour obtenir un résultat optimisé.  Sinon, copiez-collez des centaines de méthodes LOC ... " <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ben Adams</a> : "En utilisant les mêmes conventions d'appel (ABI) que dans la plate-forme de base, et p / invoque pour l'interaction?" <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Victor Baibekov</a> : «De plus, puisque vous avez mentionné #fsharp - il a un <code>inline</code> - <code>inline</code> qui fonctionne au niveau IL jusqu'à JIT, donc il était considéré comme important au niveau de la langue.  C # cela ne suffit pas (jusqu'à présent) pour les lambdas, qui sont toujours des appels virtuels, et les solutions de contournement sont souvent étranges (génériques limités) " <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Alexandre Mutel</a> : «Nouveau SIMD embarqué, post-traitement de classe / IL d'Usafe Unsafe (par exemple, custom, Fody, etc.).  Pour C # 8.0, les prochains pointeurs de fonction ... " <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Alexandre Mutel</a> : «Concernant IL, F # supporte directement IL dans une langue par exemple» <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OmariO</a> : « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">BinaryPrimitives</a> .  Niveau bas, mais sûr " <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Koji Matsui</a> : «Et votre propre assembleur intégré?  C'est difficile à la fois pour la boîte à outils et le runtime, mais il peut remplacer la solution p / invoke actuelle et implémenter le code intégré, le cas échéant " <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Frank A. Kruger</a> : «Ldobj, stobj, initobj, initblk, cpyblk» <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Conrad Coconut</a> : «Peut-être diffuser du stockage local?  Tampons de taille fixe?  Vous devriez probablement mentionner les contraintes non gérées et les types blittables :) » <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sebastiano Mandala</a> : «Juste un petit ajout à tout ce qui a été dit: que diriez-vous de quelque chose de simple, comme l'organisation des structures et comment le remplissage et l'alignement de la mémoire et de l'ordre des champs peuvent affecter les performances du cache?  C'est quelque chose que je dois moi-même explorer. » <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nino Floris</a> : "Les constantes intégrées via readonlyspan, stackalloc, finaliseurs, WeakReference, délégués ouverts, MethodImplOptions, MemoryBarriers, TypedReference, varargs, SIMD, Unsafe.AsRef, peuvent définir les types de structures en conformité exacte avec la disposition (utilisée pour TaskAwaiter et sa version)". </li></ul><br>  <b>Donc, à la fin, je dirais que C # vous permet certainement d'écrire du code qui ressemble à C ++, et en combinaison avec les bibliothèques d'exécution et de classe de base fournit beaucoup de fonctions de bas niveau.</b> <br><br><h1>  Lectures complémentaires </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Modèles pour C # hautes performances.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Federico Andres Lois</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Performance Quiz # 6 - Dictionnaire chinois-anglais</a> (depuis 2005, deux blogueurs Microsoft mènent la bataille des performances C ++ contre C #) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Performance Quiz # 6 - Conclusion, exploration spatiale</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Combien C ++ est plus rapide que C #?</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Optimisation du code managé C # et C ++ natif</a> (2005) </li></ul><br>  Compilateur Unity Burst: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comment Unity a fait (un sous-ensemble) de C # aussi vite que C ++</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Unity Burst Compiler: optimisation facile des performances</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Daily Pathtracer, Partie 3: C # et Unity Burst</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">C ++, C # et Unity</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Plongez au cœur du compilateur Burst - Unite LA</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr443804/">https://habr.com/ru/post/fr443804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr443786/index.html">Analyse du deuxième concours de quiz Android sur le stand HeadHunter au Mobius 2018 Moscou</a></li>
<li><a href="../fr443788/index.html">Les bases du routage statique dans Mikrotik RouterOS</a></li>
<li><a href="../fr443790/index.html">Erreur du survivant</a></li>
<li><a href="../fr443792/index.html">Erreurs typiques lors de l'utilisation de PostgreSQL. 2e partie</a></li>
<li><a href="../fr443798/index.html">Piratage Zotero: stockage synchronisé illimité et son utilisation fluide avec rmarkdown</a></li>
<li><a href="../fr443808/index.html">Analytique des filles à faible responsabilité sociale (chargée de Power BI, Qlik Sense, Tableau)</a></li>
<li><a href="../fr443810/index.html">Combien gagnent les développeurs de différentes qualifications, 2018</a></li>
<li><a href="../fr443812/index.html">Comment implémenter un langage de programmation en JavaScript. Partie 2: interprète</a></li>
<li><a href="../fr443814/index.html">Donner est mon "ancienne entreprise"</a></li>
<li><a href="../fr443816/index.html">Le ministère des Communications insiste sur un seul opérateur 5G</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>