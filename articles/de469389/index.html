<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ò¶Ô∏è üåã üçö Parametrisierung eines physikalischen Modells durch ein neuronales Netzwerk zur L√∂sung eines topologischen Optimierungsproblems ‚öΩÔ∏è ‚úÇÔ∏è ü§∏üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="K√ºrzlich wurde ein Artikel mit dem nicht so faszinierenden Titel " Neuronale Neuparametrisierung verbessert Strukturoptimierung " auf arXiv.org hochge...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Parametrisierung eines physikalischen Modells durch ein neuronales Netzwerk zur L√∂sung eines topologischen Optimierungsproblems</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469389/"> K√ºrzlich wurde ein Artikel mit dem nicht so faszinierenden Titel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Neuronale Neuparametrisierung verbessert Strukturoptimierung</a> " auf arXiv.org hochgeladen [arXiv: 1909.04240].  Es stellte sich jedoch heraus, dass die Autoren tats√§chlich eine sehr nicht triviale Methode zur Verwendung eines neuronalen Netzwerks entwickelten, um eine L√∂sung f√ºr das Problem der strukturellen / topologischen Optimierung physikalischer Modelle zu erhalten (obwohl die Autoren selbst sagen, dass die Methode universeller ist).  Der Ansatz ist sehr merkw√ºrdig, produktiv und scheint v√∂llig neu zu sein (ich kann jedoch nicht f√ºr Letzteres b√ºrgen, aber weder f√ºr die Autoren der Arbeit noch f√ºr die ODS-Community, noch k√∂nnte ich mich an Analoga erinnern). Daher kann es n√ºtzlich sein, dies f√ºr diejenigen zu wissen, die an der Verwendung neuronaler Netze interessiert sind. sowie das L√∂sen verschiedener Optimierungsprobleme. <br><a name="habracut"></a><br><h3>  Wor√ºber sprichst du?  Was ist die Aufgabe der topologischen Optimierung? </h3><br>  Stellen Sie sich vor, was Sie zum Beispiel ben√∂tigen, um einen Br√ºckenfaden, ein mehrst√∂ckiges Geb√§ude, einen Flugzeugfl√ºgel, ein Turbinenblatt oder was auch immer zu entwerfen.  In der Regel wird dies gel√∂st, indem ein Spezialist gefunden wird, z. B. ein Architekt, der sein Wissen √ºber Matan, Sopromat, das Zielgebiet sowie seine Erfahrung, Intuition, Testlayouts usw. nutzt.  usw.  w√ºrde das gew√ºnschte Projekt erstellen.  Hier ist es wichtig, dass dieses erhaltene Projekt nur den Besten dieses Spezialisten zugute kommt.  Und das ist nat√ºrlich nicht immer genug.  Als Computer leistungsf√§hig genug wurden, versuchten wir daher, solche Aufgaben auf sie zu verlagern.  Denn <s>es ist offensichtlich, was ein Computer im Speicher behalten und kurzschlie√üen kann ...</s> warum nicht? <br><br>  Solche Aufgaben werden "strukturelle Optimierungsprobleme" genannt, d.h.  Erzeugung einer optimalen Auslegung tragender mechanischer Strukturen [1].  Ein Unterabschnitt von Strukturoptimierungsproblemen sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">topologische Optimierungsprobleme</a> (tats√§chlich konzentriert sich die fragliche Arbeit speziell auf sie, aber dies ist absolut nicht der Punkt, und dazu sp√§ter mehr).  Ein typisches topologisches Optimierungsproblem sieht ungef√§hr so ‚Äã‚Äãaus: F√ºr ein bestimmtes Konzept (Br√ºcke, Haus usw.) im Raum in zwei oder drei Dimensionen, mit spezifischen Einschr√§nkungen in Form von Materialien, Technologien und anderen Anforderungen, mit einigen externen Lasten, m√ºssen Sie entwerfen Eine optimale Struktur, die Lasten h√§lt und Einschr√§nkungen erf√ºllt. <br><br><ul><li>  "Entwerfen" bedeutet im Wesentlichen, einen Unterraum des Quellraums zu finden / beschreiben, der mit Baumaterial gef√ºllt werden muss. </li><li>  Optimalit√§t kann zum Beispiel in Form einer Anforderung ausgedr√ºckt werden, das Gesamtgewicht der Struktur unter Einschr√§nkungen in Form der maximal zul√§ssigen Spannungen im Material und m√∂glicher Verschiebungen bei gegebenen Lasten zu minimieren. </li></ul><br>  Um dieses Problem auf einem Computer zu l√∂sen, wird der Ziell√∂sungsraum in eine Reihe von finiten Elementen (Pixel f√ºr 2D und Voxel f√ºr 3D) abgetastet. Anschlie√üend entscheidet der Computer mithilfe eines Algorithmus, ob dieses einzelne Element mit Material gef√ºllt oder leer gelassen werden soll. <br><br><img src="https://habrastorage.org/webt/6f/jj/d4/6fjjd4sff2nktgus9h39f3qbpri.png"><br>  (Bild aus "Entwicklungen in der Topologie und Formoptimierung", Chau Hoai Le, 2010) <br><br>  Schon aus der Erkl√§rung des Problems geht hervor, dass seine L√∂sung f√ºr Wissenschaftler ein ziemlich gro√üer Splitter ist.  Ich kann denjenigen, die einige Details w√ºnschen, beispielsweise einen sehr alten (2010, der f√ºr ein sich aktiv entwickelndes Gebiet noch viel ist), aber eine ziemlich detaillierte und leicht zu googelnde Chau Hoai Le-Dissertation mit dem Titel "Entwicklungen in der Topologie und Formoptimierung" [2] anbieten, von wo aus Ich habe die oberen und unteren Bilder gestohlen. <br><br><img src="https://habrastorage.org/webt/mq/ht/ob/mqhtoblrisswuw36kzdtslpgm4i.png"><br>  (Bild aus "Entwicklungen in der Topologie und Formoptimierung", Chau Hoai Le, 2010) <br><br>  In diesem Bild k√∂nnen Sie beispielsweise deutlich sehen, wie sehr unterschiedliche Algorithmen eine L√∂sung f√ºr das scheinbar einfache Designproblem der L-f√∂rmigen Aufh√§ngung erzeugen. <br><br>  Nun zur√ºck zur fraglichen Arbeit. <br><br>  Die Autoren schlugen sehr witzig vor, solche Optimierungsprobleme zu l√∂sen, indem sie eine Kandidatenl√∂sung durch ein neuronales Netzwerk und die anschlie√üende Entwicklung der L√∂sung durch Gradientenabstiegsmethoden in Bezug auf die objektive Compliance-Funktion generierten.  Die √úbereinstimmung der resultierenden Struktur wird unter Verwendung eines differenzierbaren physikalischen Modells gesch√§tzt, das tats√§chlich die Verwendung eines Gradientenabfalls erm√∂glicht.  Ihnen zufolge (die Autoren haben die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Quellcodes von</a> [5] ver√∂ffentlicht) ergibt dies entweder das gleiche Ergebnis wie die besten traditionellen Algorithmen f√ºr einfache Probleme oder die besten dieser Algorithmen, die als Basis f√ºr komplexe Probleme verwendet werden. <br><br><h3>  Methode </h3><br>  Als n√§chstes werde ich versuchen zu beschreiben, was und wie genau die Autoren vorgeschlagen haben, aber ich warne sofort, dass ich keine 100% ige Korrektheit garantiere, da ich zus√§tzlich zu meiner extrem rostigen Gelehrsamkeit auf dem Gebiet zus√§tzlich zu der √§u√üerst mageren K√ºrze der Beschreibung eine allgemeine "Unreife" des Artikels hinzuf√ºgen sollte. Das, gemessen am Vorhandensein von zwei Ausgaben in 4 Tagen, wird gerade fertiggestellt ( <i>hinzugef√ºgt:</i> Im Moment glaube ich, dass zumindest im Grunde alles richtig beschrieben wird). <br><br>  Die Autoren verfolgen im Allgemeinen den Ansatz zur L√∂sung solcher Optimierungsprobleme, der als ‚Äûmodifizierte SIMP-Methode‚Äú bezeichnet wird und in [3] ‚ÄûEffiziente Topologieoptimierung in MATLAB mit 88 Codezeilen‚Äú ausf√ºhrlich beschrieben wird.  Der Preprint dieser Arbeit und der damit verbundene Code finden Sie unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">http://www.topopt.mek.dtu.dk/Apps-and-software/Efficient-topology-optimization-in-MATLAB</a> .  Diese Arbeit wird h√§ufig verwendet, um Sch√ºler √ºber topologische Optimierungsprobleme zu unterrichten. Um sie besser zu verstehen, wird daher empfohlen, sich damit vertraut zu machen. <br><br>  Bei ‚Äûmodifiziertem SIMP‚Äú wird die L√∂sung direkt optimiert, indem die Pixel des Bildes mit physikalischer Dichte ge√§ndert werden.  Die Autoren der Arbeit schlugen nicht vor, das Bild direkt zu modifizieren (obwohl ein solcher Algorithmus bei sonst gleichen Bedingungen ein Kontrollalgorithmus war), sondern die Parameter und Eingaben des Faltungs-Neuronalen Netzwerks zu √§ndern, das ein Bild der physikalischen Dichte erzeugt.  So sieht die gesamte Methode global aus: <br><br><img src="https://habrastorage.org/webt/tr/sw/dh/trswdhp-xuxe08qyanusa4nahbc.png"><br>  (Bild aus der betreffenden Publikation) <br><br><h4>  Schritt 1, Generieren eines Kandidaten </h4><br>  Ein neuronales Netzwerk (im Folgenden als NS bezeichnet), das den zuf√§lligen prim√§ren Eingabevektor _beta verwendet (es ist wie das Netzwerkgewicht ein trainierter Parameter), erzeugt (einige) Bilder der L√∂sung (es funktioniert mit 2D, aber in 3D kann es meiner Meinung nach auch verteilt werden )  Der Upsampling-Teil der bekannten U-Net-Architektur wird als NS-Generator verwendet. <br><br><h4>  Schritt 2: Anwenden von Einschr√§nkungen und Konvertieren eines Kandidaten in ein physisches Modell-Framework </h4><br>  Pixelwerte werden in zwei Schritten in physikalische Dichten umgewandelt: <br><ol><li>  Zun√§chst wird in einem Schritt das Problem der Normalisierung der nicht normalisierten Werte der generierten Pixel gel√∂st (der NS ist so ausgelegt, dass er die sogenannten Logits - Werte im Bereich (-inf, + inf) ausgibt) und Einschr√§nkungen f√ºr die Gesamtmenge der resultierenden L√∂sung angewendet.  Hierzu wird ein Sigmoid elementweise auf das Bild angewendet, dessen Argument in Abh√§ngigkeit von dem zu transformierenden Bild und dem Volumen der gew√ºnschten L√∂sung um eine Konstante verschoben wird (der Wert dieser Vorspannungskonstante wird durch bin√§re Suche so ausgew√§hlt, dass das Gesamtvolumen der so erhaltenen Dichten gleich einem bestimmten vorbestimmten Volumen w√§re V0).  Eine detaillierte Analyse dieser Phase, siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kommentar</a> ); </li><li>  Ferner wird das resultierende normalisierte Bild der Dichten der Struktur von den sogenannten verarbeitet  ein Dichtefilter mit einem Radius von 2. Bekannter ist dieser Filter nichts anderes als ein normalgewichteter Durchschnitt benachbarter Punkte im Bild.  Die Gewichte in diesem Filter (Filterkern) k√∂nnen als Werte der H√∂hen von Punkten dargestellt werden, die sich auf der Oberfl√§che eines regul√§ren Kegels befinden, der auf der Ebene liegt, so dass sein Scheitelpunkt am aktuellen Punkt liegt. Daher nennen die Autoren ihn Kegelfilter (ausf√ºhrlicher zu diesem Thema) siehe Beschreibung des Dichtefilters in Kapitel 2.3 Filterung von [3]). <br></li></ol><br><br>  Kurz gesagt, das Wesentliche des gesamten Schritts 2 ist, dass sich die nicht normalisierte Ausgabe eines v√∂llig normalen NS in einen richtig normalisierten, leicht gegl√§tteten Rahmen des physikalischen Modells (eine Reihe physikalischer Dichten von Elementen) verwandelt, auf den bereits die erforderlichen Einschr√§nkungen von vornherein angewendet wurden (dies ist die Menge des verwendeten Materials). <br><br><h4>  Schritt 3, Bewertung des resultierenden physikalischen Rahmenmodells </h4><br>  Das resultierende Ger√ºst wird durch einen differenzierbaren physikalischen Motor gef√ºhrt, um den Vektor (/ Tensor?) Der strukturellen Verschiebung unter Last (einschlie√ülich Schwerkraft) U zu erhalten. Der Schl√ºssel hier ist die Differenzierbarkeit des Motors, die es uns erm√∂glicht, Gradienten zu erhalten (ich erinnere mich, dass der Gradient der Funktion im Allgemeinen ist Ein Tensor, der aus partiellen Ableitungen einer Funktion in Bezug auf alle ihre Argumente besteht. Der Gradient zeigt die Richtung und √Ñnderungsrate der Funktion am aktuellen Punkt. Wenn Sie dies wissen, k√∂nnen Sie die Argumente so "verdrehen", dass die gew√ºnschte √Ñnderung mit der Funktion auftritt   - es nahm ab oder zu).  Solch eine differenzierbare physische Engine muss nicht von Grund auf neu geschrieben werden - sie existiert seit langem und ist bekannt.  Die Autoren mussten ihre Paarung nur mit Berechnungspaketen f√ºr neuronale Netze wie TensorFlow / PyTorch durchf√ºhren. <br><br><h4>  Schritt 4: Berechnen des Werts der Zielfunktion f√ºr das Drahtmodell / den Kandidaten </h4><br>  Die zu minimierende skalare Zielfunktion c (x) wird berechnet, die die √úbereinstimmung (es ist die Umkehrung der Steifigkeit) des resultierenden Ger√ºsts beschreibt.  Die Compliance-Funktion h√§ngt vom Verschiebungsvektor U ab, der im letzten Schritt erhalten wurde, und von der Steifigkeitsmatrix der Struktur K (ich habe nicht gen√ºgend Kenntnisse √ºber die Topologieoptimierung, um zu verstehen, woher K kommt - ich gehe davon aus, dass dies direkt aus dem Framework betrachtet wird). <br><br>  / * <br>  siehe auch Kommentare <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(1)</a> von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">kxx</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(2)</a> von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">350 Stealth</a> , obwohl es sich lohnt, zur grundlegenden Erleuchtung zu gehen [3]. <br>  * / <br><br>  Und dann ist es geschafft.  Da alles in einer Umgebung mit automatischer Differenzierung erstellt wird, erhalten wir in diesem Stadium automatisch alle Gradienten der Zielfunktion, die aufgrund der Differenzierbarkeit aller Transformationen bei jedem Schritt auf die Gewichte und den Eingabevektor des erzeugenden neuronalen Netzwerks zur√ºckgeschoben werden.  Die Gewichte bzw. der Eingabevektor mit ihren partiellen Ableitungen √§ndern sich und verursachen die notwendige √Ñnderung - wodurch die Zielfunktion minimiert wird.  Als n√§chstes tritt ein neuer Zyklus des direkten Durchgangs durch die NS auf -&gt; Anwendung von Beschr√§nkungen -&gt; Berechnung des physikalischen Modells -&gt; Berechnung der Zielfunktion -&gt; neue Gradienten und Aktualisierung der Gewichte.  Und so weiter bis zur Konvergenz von Algo. <br><br>  Ein wichtiger Punkt, dessen Beschreibung ich in der Arbeit nicht gefunden habe, ist die Auswahl des Gesamtvolumens der Konstruktion V0, mit deren Hilfe die Kandidatenl√∂sung in Schritt 2 in das Framework konvertiert wird. Offensichtlich h√§ngen die Eigenschaften der resultierenden L√∂sung stark von ihrer Wahl ab.  Durch indirekte Angaben (alle Beispiele der erhaltenen L√∂sungen [4] unterscheiden sich in mehreren F√§llen genau in der Volumenbegrenzung) gehe ich davon aus, dass sie V0 einfach auf einem bestimmten Gitter aus dem Bereich [0,05, 0,5] fixieren und dann die erhaltenen L√∂sungen mit unterschiedlichen Augen betrachten V0.  Nun, f√ºr eine konzeptionelle Arbeit ist dies im Allgemeinen ausreichend, obwohl es nat√ºrlich furchtbar interessant w√§re, auch bei der Auswahl dieser V0 eine Option zu sehen, aber es wird wahrscheinlich in die n√§chste Entwicklungsstufe der Arbeit √ºbergehen. <br><br>  Der zweite wichtige Punkt, den ich nicht verstanden habe, ist, wie sie Einschr√§nkungen / Anforderungen f√ºr die spezifische Art der L√∂sung auferlegen.  Das hei√üt,  Wenn Sie die Br√ºcke dank des physischen Modells immer noch vom Geb√§ude trennen k√∂nnen (das Geb√§ude hat volle Unterst√ºtzung und die Br√ºcke befindet sich nur an den Grenzenden), wie kann man dann beispielsweise ein Geb√§ude mit 3 Etagen von einem Geb√§ude mit 4 Etagen trennen? <br><br><h3>  Wie funktioniert es </h3><br>  Es stellte sich heraus, dass das Verfahren f√ºr kleine Probleme (in Bezug auf die Gr√∂√üe des L√∂sungsraums = Anzahl der Pixel) ¬± die gleiche Qualit√§t der Ergebnisse liefert wie die besten herk√∂mmlichen Methoden zur topologischen Optimierung, jedoch f√ºr gro√üe (Gittergr√∂√üe von 2 ^ 15 oder mehr Pixeln, d. H. Zum Beispiel ist es ab 128 * 256 und mehr wahrscheinlicher, qualitativ hochwertige L√∂sungen mit der Methode zu erhalten als mit der besten traditionellen (von 116 getesteten Problemen ergab die Methode eine bevorzugte L√∂sung bei 99 Problemen gegen√ºber 66 bevorzugten bei der besten traditionellen). <br><br>  Au√üerdem beginnt hier etwas besonders Interessantes.  Traditionelle Methoden zur topologischen Optimierung bei gro√üen Problemen leiden unter der Tatsache, dass sie in den fr√ºhen Arbeitsphasen schnell ein kleines Netz bilden, das dann die Entwicklung gro√üer Strukturen st√∂rt.  Dies f√ºhrt zu der Tatsache, dass das erhaltene Ergebnis schwierig / unm√∂glich physikalisch umzusetzen ist.  Daher gibt es bei Problemen mit der Topologieoptimierung zwangsweise eine ganze Richtung, in der Methoden untersucht / entwickelt werden, wie die resultierenden L√∂sungen technologisch bequemer gestaltet werden k√∂nnen. <br><br>  Hier erfolgt offenbar dank des Faltungsnetzwerks gleichzeitig eine Optimierung auf mehreren r√§umlichen Skalen gleichzeitig, wodurch das "Web" vermieden / stark reduziert und einfachere, aber qualitativ hochwertige und technologisch freundliche L√∂sungen erhalten werden k√∂nnen! <br><br>  Dar√ºber hinaus werden dank der Faltung des Netzwerks grundlegend andere L√∂sungen erhalten als bei herk√∂mmlichen Standardmethoden. <br><br>  Zum Beispiel in Designs: <br><br><ul><li>  Cantilever-Beam-Methode fand eine L√∂sung von nur 8 Komponenten, w√§hrend die beste traditionelle - 18. </li><li>  Die Methode der d√ºnnen St√ºtzbr√ºcke w√§hlte eine St√ºtze mit einem baumartigen Verzweigungsmuster, w√§hrend die traditionelle ein - zwei St√ºtzen </li><li>  Bei der Dachmethode werden S√§ulen verwendet, w√§hrend bei der herk√∂mmlichen Methode ein Verzweigungsmuster verwendet wird.  Usw. </li></ul><br><img src="https://habrastorage.org/webt/07/tv/np/07tvnpzon5tzafpl_wm5xtd3h7a.png"><br>  (Bild aus der betreffenden Publikation) <br><br><h3>  Was ist das Besondere an dieser Arbeit? </h3><br>  Ich habe noch nie eine solche Verwendung eines neuronalen Netzwerks gesehen.  Typischerweise werden neuronale Netze verwendet, um eine sehr knifflige und komplexe Funktion y = F (x, Theta) zu erhalten (wobei x das Argument und Theta die einstellbaren Parameter sind), die etwas N√ºtzliches bewirken kann.  Wenn x beispielsweise ein Bild von der Kamera eines Autos ist, kann der y-Wert der Funktion beispielsweise ein Zeichen daf√ºr sein, ob sich ein Fu√üg√§nger in gef√§hrlicher N√§he des Autos befindet.  Das hei√üt,  Hierbei ist es wichtig, dass die jeweilige Art von Funktion selbst, die wiederholt zur L√∂sung eines Problems verwendet wird, wertvoll ist. <br><br>  Hier wird das neuronale Netzwerk als gerissener Repository-Modifikator-Einsteller von Parametern eines physikalischen Modells verwendet, der aufgrund seiner Architektur bestimmte Einschr√§nkungen f√ºr die Werte und Variationen von √Ñnderungen dieser Parameter auferlegt (tats√§chlich sind die Beispiele unter der √úberschrift Pixel-LBFGS ein Versuch, Pixel direkt zu optimieren, nicht Wenn Sie ein neuronales Netzwerk verwenden, um sie zu generieren, sind die Ergebnisse sichtbar. Der NS ist wichtig.  Hier wird die Faltung des verwendeten neuronalen Netzwerks kritisch, da Sie mit seiner Architektur das Konzept der √úbertragungsinvarianz und einer kleinen Rotation ‚Äûerfassen‚Äú k√∂nnen (stellen Sie sich vor, Sie erkennen Text aus einem Bild - es ist wichtig, dass Sie den Text extrahieren, und es spielt keine Rolle, welcher Teile des Bildes, es befindet sich und wie es gedreht wird - das hei√üt, Sie ben√∂tigen die Invarianz der √úbertragung und Drehung).  Bei diesem Problem bleibt eine Art physischer Stab, der eine Struktureinheit darstellt und von dem viele optimiert werden, unabh√§ngig von seiner Position und Ausrichtung im Raum erhalten. <br><br>  Ein klassisches vollst√§ndig verbundenes Netzwerk zum Beispiel w√ºrde hier wahrscheinlich nicht funktionieren (genauso gut), weil seine Architektur zu viel / zu wenig zul√§sst (na ja, so ein Dualismus, wie man aussieht).  Gleichzeitig ist es uns bei dieser Aufgabe trotz der Tatsache, dass der NS hier die sehr, sehr knifflige und komplexe Funktion y = F (x, Theta) bleibt, egal, ob es sich um sein Argument x und seine Parameter Theta handelt und wie die Funktion verwendet wird.  Wir sind nur besorgt √ºber seinen Einzelwert y, der bei der Optimierung einer bestimmten Zielfunktion f√ºr ein bestimmtes physikalisches Modell erhalten wird, bei dem {x, Theta} nur konfigurierbare Parameter sind! <br><br>  Dies ist meiner Meinung nach eine unglaublich coole und neue Idee!  (obwohl sich dann nat√ºrlich wie immer herausstellen kann, dass Schmidhuber es Anfang der 90er Jahre beschrieben hat, aber wir werden abwarten und sehen) <br><br>  Im Allgemeinen erinnert die Bedeutung der Methode etwas an verst√§rktes Lernen - dort wird der NS grob gesagt als ‚ÄûErfahrungsspeicher‚Äú eines Agenten verwendet, der in einer bestimmten Umgebung handelt, und aktualisiert, wenn die Umgebung Feedback zu den Aktionen des Agenten erh√§lt.  Nur dort wird dieses ‚ÄûRepository of Experience‚Äú st√§ndig verwendet, um neue Entscheidungen des Agenten zu treffen, und hier ist es nur ein Repository von Parametern des physikalischen Modells, von dem wir nur an dem einzigen Endergebnis der Optimierung interessiert sind. <br><br>  Nun, der letzte.  Ein interessanter Moment fiel mir auf. <br><br>  So sehen optimale L√∂sungen f√ºr die Aufgabe eines mehrst√∂ckigen Geb√§udes aus: <br><br><img src="https://habrastorage.org/webt/of/06/0c/of060ck8cb027lspglsbcxu1g7q.png"><br>  (Bild aus der betreffenden Publikation) <br><br>  Und so: <br><br><img src="https://habrastorage.org/webt/87/xc/v8/87xcv8ohejt3zk3x4-l-ufnb1k0.jpeg"><br><br>  Es befindet sich in der fantastischen Sagrada Familia, dem Tempel der Heiligen Familie in Barcelona, ‚Äã‚ÄãSpanien, der vom brillanten Antonio Gaudi ‚Äûentworfen‚Äú wurde. <br><br><hr><br><h3>  Danksagung </h3><br>  Ich danke dem Erstautor des Artikels, Stephan Hoyer, f√ºr die schnelle Unterst√ºtzung bei der Erl√§uterung einiger dunkler Details der Arbeit sowie den Habr-Teilnehmern, die ihre Erg√§nzungen und / oder n√ºtzlichen provokativen Ideen vorgenommen haben. <br><br><hr><br>  [1] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Option zur Bestimmung des strukturellen / topologischen Optimierungsproblems</a> <br><br>  [2] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">"Entwicklungen in der Topologie und Formoptimierung"</a> <br><br>  [3] Andreassen, E., Clausen, A., Schevenels, M., Lazarov, BS und Sigmund, O. Effiziente Topologieoptimierung in MATLAB unter Verwendung von 88 Codezeilen.  Strukturelle und multidisziplin√§re Optimierung, 43 (1): 1‚Äì16, 2011. Ein Preprint dieser Arbeit und dieses Codes ist unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">http://www.topopt.mek.dtu.dk/Apps-and-software/Efficient-topology-optimization-in</a> verf√ºgbar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">-MATLAB</a> <br><br>  [4] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Beispiele f√ºr Arbeitsl√∂sungen</a> <br><br>  [5] Arbeitscodes: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">https://github.com/google-research/neural-structural-optimization</a> <br><br><hr><br><br><h3>  Siehe auch </h3><br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">https://greydanus.github.io/2019/12/15/neural-reparam/</a> - ein erweitertes Verst√§ndnis der Arbeit von Sam Greydanus, einem der Autoren des Originalartikels </li></ul><br><br><hr><br>  Letzte Aktualisierung dieser Publikation 2020.01.23 09:18 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de469389/">https://habr.com/ru/post/de469389/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de469375/index.html">Warum stellen Mozilla, Coil und Creative Commons 100 Millionen US-Dollar f√ºr Open Source-Projekte zur Verf√ºgung?</a></li>
<li><a href="../de469379/index.html">Anwendung formaler Modellvalidierungsmethoden f√ºr die Benutzeroberfl√§che</a></li>
<li><a href="../de469381/index.html">Agones, erstellen Sie einen Mehrbenutzer-Spieleserver. Architektur und Installation</a></li>
<li><a href="../de469383/index.html">Hyperkonvergente L√∂sung AERODISK vAIR. Basis - ARDFS-Dateisystem</a></li>
<li><a href="../de469387/index.html">Die Geschichte eines "Entwicklers" oder wie ein Neuling eine Anwendung f√ºr iOS schreibt</a></li>
<li><a href="../de469391/index.html">Audio-Schnittstellen: Ton als Informationsquelle auf der Stra√üe, im B√ºro und am Himmel</a></li>
<li><a href="../de469393/index.html">Flare-On 2019 Zuschreibung</a></li>
<li><a href="../de469395/index.html">Wo und wie werden Mehrspalten verwendet (CSS-Spalten)</a></li>
<li><a href="../de469399/index.html">Wi-Fi im Arkhangelskoye Museum-Estate</a></li>
<li><a href="../de469401/index.html">3CX WebMeeting Service Update, Elastix Online Converter und neue Video-Tutorials</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>