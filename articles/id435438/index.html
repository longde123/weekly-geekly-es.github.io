<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ú°Ô∏è ü§Ωüèª üç¢ PHP: mengubah struktur basis data dalam pengembangan tim üìö üçå üç±</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Di dunia PHP, alat migrasi struktur basis data sudah terkenal - Doktrin , Phinx dari CakePHP, dari Laravel , dari Yii - ini adalah hal pertama yang te...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PHP: mengubah struktur basis data dalam pengembangan tim</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435438/"><img src="https://habrastorage.org/webt/9w/hm/1i/9whm1icwtg7per-15vfhyjejcx8.png"><br><br>  Di dunia PHP, alat migrasi struktur basis data sudah terkenal - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Doktrin</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Phinx</a> dari CakePHP, dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Laravel</a> , dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Yii</a> - ini adalah hal pertama yang terlintas dalam pikiran.  Tentunya ada selusin lagi.  Dan kebanyakan dari mereka bekerja dengan migrasi - perintah untuk membuat perubahan tambahan ke skema database. <br><br>  Saya tidak akan menjelaskan mengapa ini terjadi, ada banyak posting tentang topik ini di Habr√©.  Sebagai contoh: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Migrasi berversi dari struktur database: pendekatan dasar</a> - meskipun artikel lama, prinsip-prinsipnya tidak menua </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Desain Basis Data Evolusi</a> - terjemahan artikel Martin Fowler, deskripsi yang bagus [pendekatan bertahap] </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Alami 1440 migrasi basis data</a> - pos praktis tentang bekerja dengan PostgesSQL </li></ul><br>  Selanjutnya, pengembangan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengalaman</a> saya sebagai tim dengan perubahan konstan dalam struktur database di cabang yang berbeda. <br><a name="habracut"></a><br><h2>  SQL mentah vs PHP api </h2><br>  Kami menulis migrasi dalam SQL murni.  Banyak alat menyediakan api PHP untuk menulis instruksi yang diterjemahkan ke dalam kode SQL.  Sekarang saya tidak mengerti mengapa ini?  Alat seperti itu akan selalu terbatas dalam kemampuannya.  Mereka tidak mengizinkan untuk menulis instruksi spesifik untuk mesin tertentu, Anda masih harus menggunakan SQL murni.  Saya tidak berbicara tentang prosedur dan pandangan penulisan. <br><br>  Seseorang mengeluh bahwa dia tidak ingin mempelajari sintaksis perintah ALTER ... Ya, saya tidak tahu, saya membuka direktori dan menulis contoh gunung, terutama dalam proyek besar. <br><br>  Migrasi data (INSERT, UPDATE) juga selalu ditulis dalam SQL.  Karena Anda tidak pernah bisa mengandalkan versi ORM dan Model saat ini.  Dalam satu revisi mereka, yang lain tidak lagi. <br><br>  Sebagai contoh: <br><br><pre><code class="plaintext hljs">Rollback Country::delete()-&gt;where(....)-&gt;execute();</code> </pre> <br>  Ingin memutar kembali keadaan basis data.  Dan kelas PHP ini tidak lagi dalam repo.  Anda perlu mencari komit terakhir di mana dia berada dan mundur dari sana.  Brrr ... <br><br>  Oleh karena itu, SQL sederhana dan dapat diandalkan: <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--TRANSACTION --UP ALTER TABLE authors ADD COLUMN code INT; ALTER TABLE posts ADD COLUMN slug TEXT; UPDATE authors SET ... --DOWN ALTER TABLE authors DROP COLUMN code; ALTER TABLE posts DROP COLUMN slug;</span></span></code> </pre><br><h2>  Transaksi dalam DDL </h2><br>  Dengan transisi ke PostgreSQL, saya lupa tentang migrasi yang rusak seperti mimpi buruk - migrasi jatuh di tengah, ada yang terguling, ada yang hilang, duduk dan tangan kanan ... Ini memaksa kami untuk menulis perintah baris tunggal atom dan menjalankannya satu per satu.  Semuanya sederhana dengan transaksi: jika ada yang rusak - semuanya berputar kembali (well, hampir semuanya))).  Perbaiki dan mulai kembali.  Perakitan otomatis bekerja dengan keras, jika sesuatu jatuh, ia dengan cepat memperbaiki dan naik. <br><br><h2>  Tampilan (views) dan fungsi </h2><br>  Masalahnya di sini adalah bahwa mereka tidak dapat diperbarui secara bertahap, seperti ALTER dalam tabel.  Butuh DROP dan BUAT.  Yaitu  pada diferensial (teks migrasi) sama sekali tidak jelas apa yang berubah pada akhirnya.  Terutama ketika logika dipelintir, itu agak tidak nyaman.  Sebagai contoh: <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--UP DROP VIEW ... CREATE VIEW mvstock AS SELECT (now() - '7 days'::interval) AS refreshed_at, o.pid, COALESCE(sum(o.debit), 0)::integer AS debit, COALESCE(sum(o.credit) FILTER (WHERE d.type &lt;&gt; 104), 0)::integer AS credit, COALESCE(sum(o.debit), 0) - COALESCE(sum(o.credit), 0)::integer AS total FROM operations o JOIN docs d ON d.id = o.doc_id AND d.deleted_at IS NULL WHERE d.closed_at &lt; (now() - '7 days'::interval) AND d.type &lt;&gt; 500 GROUP BY o.pid WITH DATA; --DOWN DROP VIEW ... CREATE VIEW mvstock AS SELECT (now() - '10 days'::interval) AS refreshed_at, o.pid, COALESCE(sum(o.debit), 0)::integer AS debit, COALESCE(sum(o.credit) FILTER (WHERE d.type &lt;&gt; 104), 0)::integer AS credit, COALESCE(sum(o.debit), 0) - COALESCE(sum(o.credit), 0)::integer AS total FROM operations o JOIN docs d ON d.id = o.doc_id AND d.deleted_at IS NULL WHERE d.closed_at &lt; (now() - '10 days'::interval) AND d.type &lt;&gt; 500 GROUP BY o.pid WITH DATA;</span></span></code> </pre><br>  Apa yang berubah di sini? <br><br>  Kami berhenti pada fakta bahwa di sebelah migrasi adalah ayah, tempat tampilan saat ini dan kode prosedur disimpan, yang diperbarui dan disalin dalam migrasi rollback. <br><br>  Dan sekarang diffnya menjadi seperti: <br><br><img src="https://habrastorage.org/webt/it/lh/rx/itlhrxyorlounbpannounrvyewa.png"><br><br>  Kembali di Avito, kami membuat solusi menarik untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memvariasikan kode prosedur yang tersimpan.</a> <br><br>  Secara umum, kasus ini menimbulkan masalah yang bagus - bagaimana melihat sejarah perubahan pada objek tertentu dari struktur database.  Untuk setiap tabel, saya ingin melihat riwayat perubahan sehubungan dengan solusi tugas tertentu. <br><br><img src="https://habrastorage.org/webt/hr/pw/rz/hrpwrzndgamurxtdv9i0g4ixai8.png"><br><br>  Ditemukan di Habr√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pendekatan yang</a> menarik untuk otomatisasi memperbaiki perubahan dalam struktur basis data. <br><br><h2>  Bekerja dengan cabang </h2><br>  Rasa sakit abadi saya adalah bagaimana beralih antara dua cabang A- dan B, yang masing-masing telah diedit pada struktur database. <br><br><img src="https://habrastorage.org/webt/m7/te/j8/m7tej8krsjwkp6dw7vf3d7yb9iy.png"><br><br>  Diperlukan untuk mengembalikan migrasi di cabang-A (kita juga harus ingat yang mana dan berapa banyak), kemudian beralih ke cabang-B dan memutar migrasi baru.  Oke, jika pengeditan kami kompatibel dan saya bisa beralih ke cabang kedua dan memutar migrasi tambahan dari B. <br><br>  Dan jika tidak?  Dan jika saya memiliki lebih dari satu cabang seperti itu?  Dan kemudian gulung balik semua kondisi ulasan ini?  Saya selalu membencinya ... <br><br>  Sekarang, ketika beralih ke cabang orang lain, saya dapat secara otomatis menghapus migrasi orang lain dan menggulir yang sekarang: <br><br><img src="https://habrastorage.org/webt/9w/hm/1i/9whm1icwtg7per-15vfhyjejcx8.png"><br><br>  dimana: <br><br>  <b>D</b> - migrasi-A yang diluncurkan di cabang-A, tetapi tidak ada di cabang saat ini, dan disarankan untuk menghapusnya <br>  <b>A</b> - migrasi-B yang muncul di cabang baru dan perlu digulirkan <br><br>  Menjadi sangat nyaman saat pengujian dan perakitan otomatis di satu pangkalan.  Ketika tidak ada akal atau peluang untuk setiap cabang untuk membuat basis dari awal.  Beralih ke cabang dan secara otomatis menyinkronkan keadaan database. <br><br><h2>  Penomoran dan urutan eksekusi </h2><br>  Semua alat yang saya tahu migrasi cap waktunya adalah solusi yang baik.  Jika saya menulis beberapa migrasi, urutan yang diperlukan dipertahankan.  Pengembang lain dapat memiliki tanggal di utas lain, bahkan utas saya - tetapi tidak masalah dalam urutan apa kami bergabung dengannya, perubahan kami tidak tergantung satu sama lain.  Bahkan jika kita bekerja dengan tabel yang sama (tambahkan dengan kolom), maka semua perubahan yang diperlukan akan terjadi dalam urutan apa pun.  Hal utama adalah bahwa urutan suntingan dependen saya dihormati. <br><br><img src="https://habrastorage.org/webt/n9/4q/dg/n94qdgqakyab2tmjoa2bmhw5oga.png"><br><br>  Saya tidak mempertimbangkan kasus ketika kita perlu mengedit hal yang sama - poin ini selalu konsisten.  Nah, atau akan ada kegagalan pada tahap perakitan dan pengujian. <br><br>  Ini adalah contoh yang menarik. <br><br>  Kami melakukan pengeditan yang berbeda dalam satu tampilan atau prosedur, mis.  dalam struktur yang diperbarui melalui penghapusan.  Yaitu  Misalnya, saya menambahkan kolom col_A ke tampilan, dan rekan saya col_B.  Dengan demikian, jika kodenya diluncurkan setelah saya, maka kolomnya tidak akan memiliki kolom saya: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> vusers <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> login, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, <span class="hljs-comment"><span class="hljs-comment">-- ....</span></span></code> </pre><table><tbody><tr><th>  cabang-A </th><th>  cabang-B </th></tr><tr><td><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> vusers; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> vusers <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> login, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, col_A, <span class="hljs-comment"><span class="hljs-comment">-- ....</span></span></code> </pre></td><td><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> vusers; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> vusers <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> login, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, col_B, <span class="hljs-comment"><span class="hljs-comment">-- ....</span></span></code> </pre></td></tr></tbody></table>  Dalam hal ini, satu cabang harus dibuat tergantung pada yang lain. <br><br>  Kasus lain yang menarik adalah koreksi dalam migrasi. <br><br>  Intinya adalah bahwa migrasi yang diterapkan tidak akan lagi diterapkan lagi, tidak peduli berapa banyak perubahan yang Anda lakukan untuk itu (Anda harus memutar kembali terlebih dahulu, dan kemudian menerapkannya lagi).  Yaitu  Anda mengirim Migrasi untuk pengujian, semua aturan, dan kemudian Anda menyadarinya dan melakukan edit kecil.  Tetapi tes atau server lain tempat Anda menggunakannya tidak akan mengetahuinya. <br><br>  Dalam kasus ini, kami mengganti nama file migrasi, menambahkan nomor versi baru, sehingga migrator mulai menafsirkan ini sebagai 2 perintah - gulung balik 1 dan gulung 2, <br>  misalnya: <br><br><img src="https://habrastorage.org/webt/x4/kn/7f/x4kn7fbvvoi0uhm-3yktgq3pkz0.png"><br><br><h2>  Kembalikan </h2><br>  Selalu tulis ROLLBACK, bahkan jika itu tidak dapat mengembalikan basis ke keadaan semula.  Misalnya, DROP TABLE, ROLLBACK macam apa itu? <br><br>  Dalam kasus seperti itu, kami menulis CREATE TABLE kosong.  Intinya adalah bahwa sistem dev selalu dapat dengan mudah beralih antar cabang.  Untuk PROD, manajemen revisi yang ireversibel sudah diputuskan pada tingkat yang berbeda.  Saya bisa membuat salinan tabel, atau mengganti nama alih-alih menghapusnya.  Tetapi prinsip penulisan migrasi - rollback DIPEROLEH untuk mengembalikan STRUKTUR pangkalan ke tingkat awal, dan data sudah mungkin. <br><br>  Dalam lingkungan pertempuran, saya menggunakan kemunduran hanya 1-2 kali dalam hidup saya.  Dan di dev sepanjang waktu.  Oleh karena itu, saya selalu memeriksa bahwa rollback mengembalikan semuanya ke keadaan yang diinginkan. <br><br>  Seringkali, pengembang dapat membuat kesalahan dalam rollback.  Karena  mereka terutama berkonsentrasi pada suntingan baru, mereka diuji dan bekerja dengannya.  Orang lain dan proses sudah bekerja dengan rollback.  Karenanya, saya selalu menguji migrasi UP - ROLLBACK - UP <br><br>  Poin yang menarik muncul pada basis tes permanen (database tidak dihapus).  Mereka menulis migrasi, rollback berfungsi dengan baik, mereka mengirimnya untuk pengujian, tester menghasilkan data dalam format baru, mencoba memutar kembali, tetapi mereka tidak memberikan data baru.  Contoh klasik <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> abc <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COLUMN</span></span> code <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span></code> </pre> <br>  Hebat!  Setelah pengujian, database penuh dengan nilai NULL.  Lakukan ROLLBACK: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> abc <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COLUMN</span></span> code <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span></code> </pre> <br>  dan sebaliknya :-( <br><br>  Anda perlu menambahkan perintah: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> abc <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> code <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span></code> </pre> <br>  Kesulitannya adalah Anda perlu mengingat hal ini dan tidak mengotomatiskannya jika kita tidak berbicara tentang membuat kembali basis data dari awal setiap saat. <br><br><h5>  Sedikit tentang penghapusan data </h5><br>  Biasanya kami mencoba TIDAK menghapus tabel dan kolom yang diisi sekaligus.  Lebih baik untuk mengubah nama atau membuat salinan, dan menghapusnya nanti, ketika semuanya beres dan data kehilangan relevansi: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> user_logs <span class="hljs-keyword"><span class="hljs-keyword">RENAME</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> user_logs_20190223; <span class="hljs-comment"><span class="hljs-comment">--  CREATE TABLE user_logs_20190223 AS TABLE user_logs;</span></span></code> </pre><br><h2>  Migrator </h2><br>  Kami sedang bekerja dengan Laravel sekarang - ia memiliki mesin manajemen migrasi standar yang dikenal.  Jika Anda mau, tulislah bahkan dalam SQL murni, meskipun masih dalam kelas PHP.  Tetapi upaya berulang saya untuk membuatnya bekerja seperti yang kami butuhkan menghasilkan repo yang terpisah: <br><br><ul><li>  Solusinya terdiri dari 2 bagian - lib dan implementasi untuk konsol tertentu (Laravel, Symfony).  Anda dapat berintegrasi ke konsol mana pun, atau setidaknya di moncong web. </li><li>  Tidak ada konfigurasi dan koneksi - mengapa, ketika sudah ada di proyek Anda.  Tutup koneksi Anda ke antarmuka dan pergi. </li><li>  Rollback SQL disimpan dalam database.  Ini diperlukan untuk beralih antar cabang. </li><li>  Diuji pada Postgesql, Mysql (tidak ada transaksi).  Ini pada prinsipnya cocok untuk pangkalan dan struktur apa pun, karena format baku digunakan. </li></ul><br><br>  Referensi <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">migrasi-lib</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">implementasi di bawah Laravel / Artisan</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">implementasi di bawah Symfony / Console</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id435438/">https://habr.com/ru/post/id435438/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id435426/index.html">Cara Microsoft Excel bekerja dengan ketinggian baris</a></li>
<li><a href="../id435428/index.html">Remote control emulator Fceux menggunakan Python</a></li>
<li><a href="../id435430/index.html">Berita paling keren CES 2019</a></li>
<li><a href="../id435432/index.html">Tahun Baru, GitHub Baru: Repositori Pribadi Gratis Tanpa Batas</a></li>
<li><a href="../id435436/index.html">5 tren dalam infrastruktur TI: perkiraan untuk 2019</a></li>
<li><a href="../id435442/index.html">Saluran perubahan</a></li>
<li><a href="../id435444/index.html">Kami menerapkan OSGI di platform Karaf</a></li>
<li><a href="../id435446/index.html">Algoritma Verhuff untuk sistem bilangan genap acak</a></li>
<li><a href="../id435448/index.html">Tentang pengalaman berkomunikasi dengan generator sinyal melalui QTcpSocket dan SCPI</a></li>
<li><a href="../id435450/index.html">Selamat Tahun Baru, Selamat Baru MQTT / UDP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>