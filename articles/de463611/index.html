<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍉 💜 🌸 Fantastische Plugins, vol. 2. Üben 🙆🏻 🤶🏿 👩‍👩‍👧‍👧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hier können Sie den ersten Artikel mit der Theorie des Plug-In-Engineerings lesen. 


 Und in diesem Teil werde ich Ihnen sagen, auf welche Probleme w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fantastische Plugins, vol. 2. Üben</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/hh/blog/463611/"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier</a> können Sie den ersten Artikel mit der Theorie des Plug-In-Engineerings lesen. </p><br><p>  Und in diesem Teil werde ich Ihnen sagen, auf welche Probleme wir bei der Erstellung des Plugins gestoßen sind und wie wir versucht haben, sie zu lösen. <br><img src="https://habrastorage.org/webt/db/cn/c-/dbcnc-m5gfz68a0hpvnt2qjdcgw.png" alt="Bild"></p><a name="habracut"></a><br><h1 id="o-chem-budu-govorit">  Worüber werde ich sprechen? </h1><br><ul><li>  Praktischer Teil <br><ul><li>  Mehrseitige Benutzeroberfläche </li><li>  DI in Plugins </li><li>  Codegenerierung </li><li>  Codeänderung </li></ul></li><li>  Was ist als nächstes zu tun? <br><ul><li>  Tipps </li><li>  FAQ </li></ul></li></ul><br><h2 id="mnogostranichnyy-ui">  Mehrseitige Benutzeroberfläche </h2><br><p>  Als erstes mussten wir eine mehrseitige Benutzeroberfläche erstellen.  Wir haben das erste komplexe Formular mit einer Reihe von Häkchen und Eingabefeldern erstellt.  Wenig später haben wir beschlossen, die Möglichkeit hinzuzufügen, eine Liste von Modulen auszuwählen, die der Benutzer mit dem neuen Modul verbinden kann.  Außerdem möchten wir die Anwendungsmodule auswählen, mit denen das erstellte Modul verbunden werden soll. </p><br><p>  Es ist nicht sehr praktisch, so viele Steuerelemente in einem Formular zu haben, dass drei separate Seiten und drei separate Ausstechformen erstellt wurden.  Kurz gesagt, das Dialogfeld "Assistent". </p><br><p><img src="https://habrastorage.org/webt/hd/jw/wf/hdjwwfojlb6w7gj_sacdswi802g.png" alt="Bild"></p><br><p>  Da das Erstellen einer mehrseitigen Benutzeroberfläche in Plugins sehr schmerzhaft ist, wollte ich etwas bereit finden.  Und im Darm von IDEA haben wir eine Klasse namens <em>WizardDialog entdeckt</em> . </p><br><p><img src="https://habrastorage.org/webt/tl/gr/6z/tlgr6ztp3yro6-yyyqyhjsd55ky.png" alt="Bild"></p><br><p>  Dies ist eine Wrapper-Klasse über einen regulären Dialog, die den Fortschritt des Benutzers im Assistenten unabhängig überwacht und die erforderlichen Schaltflächen (Zurück, Weiter, Fertig stellen usw.) anzeigt.  Ein spezielles <em>WizardModel ist</em> an den <em>WizardDialog angehängt</em> , zu dem einzelne WizardSteps hinzugefügt werden.  Jeder <em>WizardStep</em> ist ein separates Formular. </p><br><p>  In seiner einfachsten Form erfolgt die Umsetzung des Dialogs wie folgt: </p><br><div class="spoiler">  <b class="spoiler_title">Wizarddialog</b> <div class="spoiler_text"><pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyWizardDialog</span></span></span></span>( model: MyWizardModel, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> onFinishButtonClickedListener: (MyWizardModel) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> ): WizardDialog&lt;MyWizardModel&gt;(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, model) { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onWizardGoalAchieved</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onWizardGoalAchieved() onFinishButtonClickedListener.invoke(myModel) } }</code> </pre> </div></div><br><p>  <em>Wir erben</em> von der <em>WizardDialog-</em> Klasse und parametrisieren mit der Klasse unseres <em>WizardModel</em> .  Diese Klasse hat einen speziellen Rückruf ( <em>onWizardGoalAchieved</em> ), der uns mitteilt, dass der Benutzer den Assistenten bis zum Ende durchlaufen und auf die Schaltfläche „Fertig stellen“ geklickt hat. <br>  Es ist wichtig zu beachten, dass innerhalb dieser Klasse nur das <em>WizardModel erreicht werden kann</em> .  Dies bedeutet, dass Sie alle Daten, die der Benutzer während des Durchlaufs des Assistenten <em>sammelt</em> , im <em>WizardModel</em> hinzufügen <em>müssen</em> . </p><br><div class="spoiler">  <b class="spoiler_title">Assistentenmodell</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyWizardModel</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">WizardModel</span></span></span></span>(<span class="hljs-string"><span class="hljs-string">"Title for my wizard"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.add(MyWizardStep1()) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.add(MyWizardStep2()) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.add(MyWizardStep3()) } }</code> </pre> </div></div><br><p>  Das Modell lautet wie folgt: Wir erben von der <em>WizardModel-</em> Klasse und <em>fügen</em> mithilfe der integrierten <em>add-</em> Methode separate <em>WizardSteps</em> zum Dialogfeld hinzu. </p><br><div class="spoiler">  <b class="spoiler_title">Zaubererschritt</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyWizardStep1</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">WizardStep</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyWizardModel</span></span></span><span class="hljs-class">&gt;</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contentPanel: JPanel <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(state: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">WizardNavigationState</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span>: JComponent { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> contentPanel } }</code> </pre> </div></div><br><p>  <em>WizardSteps sind</em> ebenfalls einfach: Wir erben von der <em>WizardStep-</em> Klasse, parametrisieren sie mit unserer Modellklasse und definieren vor allem die <em>Prepare-</em> Methode neu, die die <em>Stammkomponente</em> Ihres zukünftigen Formulars zurückgibt. </p><br><p>  In einfachen Worten sieht es wirklich so aus.  Aber in der realen Welt wird Ihre Form höchstwahrscheinlich ungefähr so ​​aussehen: </p><br><p><img src="https://habrastorage.org/webt/as/6d/mc/as6dmcznqssdt7zwhdz7ndebuv8.png" alt="Bild"></p><br><p>  Hier können Sie sich an jene Zeiten erinnern, als wir in der Android-Welt noch nicht wussten, was Clean Architecture, MVP, und den gesamten Code in einer Aktivität geschrieben haben.  Es gibt ein neues Feld für Architekturschlachten, und wenn Sie verwirrt werden möchten, können Sie Ihre eigene Architektur für Plugins implementieren. </p><br><h3 id="vyvod">  Fazit </h3><br><p>  Wenn Sie eine mehrseitige Benutzeroberfläche benötigen, verwenden Sie <em>WizardDialog</em> - dies wird einfacher. </p><br><p>  Wir fahren mit dem nächsten Thema fort - DI in Plugins. </p><br><h2 id="di-v-plaginah">  DI in Plugins </h2><br><p>  Warum ist möglicherweise eine Abhängigkeitsinjektion in einem Plugin erforderlich? <br>  Der erste Grund ist die Organisation der Architektur innerhalb des Plugins. </p><br><p>  Es scheint, warum im Allgemeinen eine Art Architektur innerhalb des Plugins zu beobachten?  Ein Plug-In ist eine nützliche Sache, nachdem ich es geschrieben habe, und das war's, ich habe es vergessen. <br>  Ja, aber nein. <br>  Wenn Ihr Plugin wächst und Sie viel Code schreiben, stellt sich die Frage nach strukturiertem Code von selbst.  Hier kann DI nützlich sein. </p><br><p>  Der zweite, wichtigere Grund: Mit Hilfe von DI können Sie die Komponenten erreichen, die von den Entwicklern anderer Plugins geschrieben wurden.  Es können Eventbusse, Logger und vieles mehr sein. </p><br><p>  Trotz der Tatsache, dass Sie jedes DI-Framework (Spring, Dagger usw.) verwenden können, gibt es in IntelliJ IDEA Ihr eigenes DI-Framework, das auf den ersten drei Abstraktionsebenen basiert, über die ich bereits gesprochen habe: <em>Anwendung</em> , <em>Projekt</em> und <em>Modul</em> . </p><br><p><img src="https://habrastorage.org/webt/ix/kh/dk/ixkhdkerqkc0sapkdvgj5qsg_44.png" alt="Bild"></p><br><p>  Jede dieser Ebenen hat ihre eigene Abstraktion namens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Komponente</em></a> .  Die Komponente der erforderlichen Ebene wird pro Instanz des Objekts dieser Ebene erstellt.  Daher wird <em>ApplicationComponent</em> einmal für jede Instanz der <em>Application-</em> Klasse erstellt, ähnlich wie <em>ProjectComponent</em> für <em>Project-</em> Instanzen usw. </p><br><p>  Was muss getan werden, um das DI-Framework zu verwenden? </p><br><p>  Erstellen Sie zunächst eine Klasse, die eine der benötigten Schnittstellenkomponenten implementiert, z. B. eine Klasse, die <em>ApplicationComponent</em> , <em>ProjectComponent</em> oder <em>ModuleComponent implementiert</em> .  Gleichzeitig haben wir die Möglichkeit, ein Objekt der Ebene einzufügen, deren Schnittstelle wir implementieren.  Das heißt, Sie können beispielsweise in <em>ProjectComponent</em> ein Objekt der <em>Project-</em> Klasse <em>einfügen</em> . </p><br><div class="spoiler">  <b class="spoiler_title">Komponentenklassen erstellen</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyAppComponent</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> application: Application, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> anotherApplicationComponent: AnotherAppComponent ): ApplicationComponent <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyProjectComponent</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> project: Project, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> anotherProjectComponent: AnotherProjectComponent, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> myAppComponent: MyAppComponent ): ProjectComponent <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyModuleComponent</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> module: Module, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> anotherModuleComponent: AnotherModuleComponent, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> myProjectComponent: MyProjectComponent, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> myAppComponent: MyAppComponent ): ModuleComponent</code> </pre> </div></div><br><p>  Zweitens ist es möglich, andere Komponenten des gleichen Niveaus oder höher zu injizieren.  Das heißt, Sie können beispielsweise in <em>ProjectComponent</em> andere <em>ProjectComponent</em> oder <em>ApplicationComponent</em> <em>einfügen</em> .  Hier können Sie auf Instanzen von "fremden" Komponenten zugreifen. </p><br><p>  Gleichzeitig garantiert IDEA, dass der gesamte Abhängigkeitsgraph korrekt zusammengestellt wird, alle Objekte in der richtigen Reihenfolge erstellt und korrekt initialisiert werden. </p><br><p>  Als Nächstes registrieren Sie die Komponente in der Datei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>plugin.xml</em></a> .  Sobald Sie eine der Komponentenschnittstellen (z. B. <em>ApplicationComponent</em> ) implementieren, bietet IDEA sofort an, Ihre Komponente in plugin.xml zu registrieren. </p><br><div class="spoiler">  <b class="spoiler_title">Registrieren Sie die Komponente in plugin.xml</b> <div class="spoiler_text"><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">idea-plugin</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">project-components</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">component</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">interface-class</span></span></span><span class="hljs-tag">&gt;</span></span> com.experiment.MyProjectComponent <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">interface-class</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">implementation-class</span></span></span><span class="hljs-tag">&gt;</span></span> com.experiments.MyProjectComponentImpl <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">implementation-class</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">component</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">project-components</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">idea-plugin</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> </div></div><br><p>  Wie wird das gemacht?  Ein spezielles <em>&lt;Projekt-Komponenten&gt;</em> -Tag wird angezeigt ( <em>&lt;Anwendungskomponente&gt;</em> , <em>&lt;Modulkomponente&gt;</em> - abhängig von der Ebene).  Darin befindet sich ein Tag <em>mit zwei weiteren Tags: <em>&lt;Schnittstellenklasse&gt;</em> , in der der Schnittstellenname Ihrer Komponente angegeben ist, und <em>&lt;Implementierungsklasse&gt;</em> , in der die Implementierungsklasse angegeben ist.</em>  <em>Ein und dieselbe Klasse kann entweder eine Schnittstelle einer Komponente oder deren Implementierung sein, sodass Sie mit einem einzelnen <em>&lt;implementation-class&gt; -Tag arbeiten können</em> .</em> <br></p><p>  Als letztes müssen Sie die Komponente vom entsprechenden Objekt <em>abrufen</em> , <em>dh</em> wir erhalten die <em>ApplicationComponent</em> von der <em>Application-</em> Instanz, <em>ProjectComponent</em> von <em>Project</em> usw. </p><br><div class="spoiler">  <b class="spoiler_title">Holen Sie sich die Komponente</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> myAppComponent = application.getComponent(MyAppComponent::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">myProjectComponent</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">project</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">getComponent</span></span></span></span>(MyProjectComponent::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">myModuleComponent</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">module</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">getComponent</span></span></span></span>(MyModuleComponent::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">)</span></span></code> </pre> </div></div><br><h3 id="vyvody">  Schlussfolgerungen </h3><br><ol><li>  In IDEA gibt es ein DI-Framework - Sie müssen nichts alleine ziehen: weder Dolch noch Frühling.  Obwohl Sie natürlich können. </li><li>  Mit diesem DI können Sie die vorgefertigten Komponenten erreichen, und dies ist der Saft selbst. </li></ol><br><p>  Fahren wir mit der dritten Aufgabe fort - der Codegenerierung. </p><br><h2 id="generaciya-koda">  Codegenerierung </h2><br><p>  Denken Sie daran, in der Checkliste hatten wir die Aufgabe, viele Dateien zu generieren?  Jedes Mal, wenn wir ein neues Modul erstellen, erstellen wir eine Reihe von Dateien: Interaktoren, Präsentatoren, Fragmente.  Beim Erstellen eines neuen Moduls sind diese Komponenten einander sehr ähnlich, und ich möchte lernen, wie dieses Framework automatisch generiert wird. </p><br><h3 id="shablony">  Muster </h3><br><p>  Was ist der einfachste Weg, um eine Menge ähnlichen Codes zu generieren?  Verwenden Sie Muster.  Zuerst müssen Sie sich Ihre Vorlagen ansehen und verstehen, welche Anforderungen an den Codegenerator gestellt werden. </p><br><div class="spoiler">  <b class="spoiler_title">Ein Teil der build.gradle-Dateivorlage</b> <div class="spoiler_text"><pre> <code class="java hljs">apply plugin: <span class="hljs-string"><span class="hljs-string">'com.android.library'</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isKotlinProject) { apply plugin: <span class="hljs-string"><span class="hljs-string">'kotlin-android'</span></span> apply plugin: <span class="hljs-string"><span class="hljs-string">'kotlin-kapt'</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isModuleWithUI) { apply plugin: <span class="hljs-string"><span class="hljs-string">'kotlin-android-extensions'</span></span> }&gt; }&gt; ... android { ... &lt;<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isMoxyEnabled) { kapt { arguments { arg(<span class="hljs-string"><span class="hljs-string">"moxyReflectorPackage"</span></span>, <span class="hljs-string"><span class="hljs-string">'&lt;include var="packageName"&gt;'</span></span>) } } }&gt; ... } ... dependencies { <span class="hljs-function"><span class="hljs-function">compileOnly </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">project</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">':common'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> compileOnly </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">project</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">':core-utils'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> &lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(moduleName in enabledModules)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">compileOnly </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">project</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'&lt;include var="moduleName"&gt;'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> }&gt; ... }</span></span></code> </pre> </div></div><br><p>  Erstens: Wir wollten in der Lage sein, Bedingungen innerhalb dieser Muster zu verwenden.  Ich gebe ein Beispiel: Wenn das Plugin irgendwie mit der Benutzeroberfläche verbunden ist, möchten wir die speziellen Gradle-Plugin- <em>Kotlin-Android-Erweiterungen verbinden</em> . </p><br><div class="spoiler">  <b class="spoiler_title">Bedingung innerhalb der Vorlage</b> <div class="spoiler_text"><pre> <code class="java hljs">&lt;<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isKotlinProject) { apply plugin: <span class="hljs-string"><span class="hljs-string">'kotlin-android'</span></span> apply plugin: <span class="hljs-string"><span class="hljs-string">'kotlin-kapt'</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isModuleWithUI) { apply plugin: <span class="hljs-string"><span class="hljs-string">'kotlin-android-extensions'</span></span> }&gt; }&gt;</code> </pre> </div></div><br><p>  Das zweite, was wir wollen, ist die Möglichkeit, eine Variable in dieser Vorlage zu verwenden.  Wenn wir beispielsweise kapt für Moxy konfigurieren, möchten wir den Paketnamen als Argument für den Anmerkungsprozessor einfügen. </p><br><div class="spoiler">  <b class="spoiler_title">Ersetzen Sie den Wert der Variablen in der Vorlage</b> <div class="spoiler_text"><pre> <code class="java hljs">kapt { arguments { arg(<span class="hljs-string"><span class="hljs-string">"moxyReflectorPackage"</span></span>, <span class="hljs-string"><span class="hljs-string">'&lt;include var="packageName"&gt;'</span></span>) } }</code> </pre> </div></div><br><p>  Eine andere Sache, die wir brauchen, ist die Fähigkeit, Schleifen innerhalb der Vorlage zu verarbeiten.  Erinnern Sie sich an das Formular, in dem wir die Liste der Module ausgewählt haben, die wir mit dem neu erstellten Modul verbinden möchten?  Wir wollen sie in einer Schleife umgehen und dieselbe Zeile hinzufügen. </p><br><div class="spoiler">  <b class="spoiler_title">Verwenden Sie die Schleife in der Vorlage.</b> <div class="spoiler_text"><pre> <code class="java hljs">&lt;<span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (moduleName in enabledModules) { <span class="hljs-function"><span class="hljs-function">compileOnly </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">project</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'&lt;include var="moduleName"&gt;'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> }&gt;</span></span></code> </pre> </div></div><br><p>  Daher stellen wir drei Bedingungen für den Codegenerator vor: </p><br><ul><li>  Wir wollen die Bedingungen nutzen </li><li>  Möglichkeit, variable Werte zu ersetzen </li><li>  Wir brauchen Schleifen in Mustern </li></ul><br><h3 id="generatory-koda">  Codegeneratoren </h3><br><p>  Welche Möglichkeiten gibt es, um den Codegenerator zu implementieren?  Sie können beispielsweise Ihren eigenen Codegenerator schreiben.  Zum Beispiel haben die Jungs von Uber dies getan: Sie haben ihr eigenes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Plug-In für die Erzeugung von Riblets geschrieben</a> (die sogenannten Architektureinheiten).  Sie entwickelten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine eigene Vorlagensprache</a> , in der sie nur die Möglichkeit zum Einfügen von Variablen verwendeten.  Sie brachten die Bedingungen auf das <a href="">Niveau des Generators</a> .  Aber wir dachten, dass wir das nicht tun würden. </p><br><p>  Die zweite Option ist die Verwendung der in IDEA integrierten Dienstprogrammklasse FileTemplateManager. Ich würde dies jedoch nicht empfehlen.  Weil er <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Velocity</a> als Engine hat, die einige Probleme beim Weiterleiten von Java-Objekten an Vorlagen hat.  Darüber hinaus kann der <em>FileTemplateManager</em> keine anderen Dateien als Java oder XML aus der Box generieren.  Und wir mussten Groovy-Dateien, Kotlin, Proguard und andere Dateitypen generieren. </p><br><p>  Die dritte Option war ... <em>FreeMarker</em> .  Wenn Sie vorgefertigte <em>FreeMarker-</em> Vorlagen haben, werfen Sie sie nicht weg - sie können Ihnen im Plugin nützlich sein. </p><br><p>  Was muss getan werden, was muss <em>FreeMarker</em> im Plugin verwenden?  Fügen Sie zunächst Dateivorlagen hinzu.  Sie können den Ordner <em>/ templates im</em> Ordner <em>/ resources</em> erstellen und dort alle unsere Vorlagen für alle Dateien hinzufügen - Präsentatoren, Fragmente usw. </p><br><p><img src="https://habrastorage.org/webt/gk/ww/fe/gkwwfelyl443hdze6vd6a99ecmw.png" alt="Bild"></p><br><p>  Danach müssen Sie eine Abhängigkeit von der FreeMarker-Bibliothek hinzufügen.  Da das Plugin Gradle verwendet, ist das Hinzufügen einer Abhängigkeit unkompliziert. </p><br><div class="spoiler">  <b class="spoiler_title">Fügen Sie eine Abhängigkeit von der FreeMarker-Bibliothek hinzu</b> <div class="spoiler_text"><pre> <code class="java hljs">dependencies { ... compile <span class="hljs-string"><span class="hljs-string">'org.freemarker:freemarker:2.3.28'</span></span> }</code> </pre> </div></div><br><p>  Konfigurieren Sie danach FreeMarker in unserem Plugin.  Ich rate Ihnen, diese Konfiguration einfach hier zu kopieren - sie wird gefoltert, gelitten, kopiert und alles funktioniert einfach. </p><br><div class="spoiler">  <b class="spoiler_title">FreeMarker-Konfiguration</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TemplatesFactory</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> project: Project) : ProjectComponent { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> freeMarkerConfig <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> lazy { Configuration(Configuration.VERSION_2_3_28).apply { setClassForTemplateLoading( TemplatesFactory::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">"/templates" ) defaultEncoding = Charsets.UTF_8.name</span></span></span></span>() templateExceptionHandler = TemplateExceptionHandler.RETHROW_HANDLER logTemplateExceptions = <span class="hljs-literal"><span class="hljs-literal">false</span></span> wrapUncheckedExceptions = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } } ...</code> </pre> </div></div><br><p>  Es ist Zeit, Dateien mit <em>FreeMarker</em> zu erstellen.  Dazu erhalten wir eine Vorlage aus der Konfiguration anhand ihres Namens und erstellen mit einem normalen <em>FileWriter</em> eine Datei mit dem gewünschten Text direkt auf der Festplatte. </p><br><div class="spoiler">  <b class="spoiler_title">Erstellen einer Datei mit FileWriter</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TemplatesFactory</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> project: Project) : ProjectComponent { ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( pathToFile: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, templateFileName: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">data</span></span></span></span><span class="hljs-function"><span class="hljs-params">: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Map</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Any&gt; )</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> template = freeMarkerConfig.getTemplate(templateFileName) FileWriter(pathToFile, <span class="hljs-literal"><span class="hljs-literal">false</span></span>).use { writer -&gt; template.process(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>, writer) } } }</code> </pre> </div></div><br><p>  Und die Aufgabe scheint gelöst zu sein, aber nein.  Im theoretischen Teil habe ich erwähnt, dass die gesamte IDEE von der PSI-Struktur durchdrungen ist, und dies muss berücksichtigt werden.  Wenn Sie Dateien erstellen, die die PSI-Struktur umgehen (z. B. über FileWriter), versteht IDEA einfach nicht, dass Sie etwas erstellt haben, und zeigt die Dateien nicht im Projektbaum an.  Wir haben ungefähr sieben Minuten gewartet, bevor IDEA indiziert und die erstellten Dateien gesehen hat. </p><br><p>  Fazit - Machen Sie es richtig, erstellen Sie Dateien unter Berücksichtigung der Struktur des PSI. </p><br><h3 id="sozdaem-psi-strukturu-dlya-faylov">  Erstellen Sie eine PSI-Struktur für Dateien </h3><br><p>  <a href="">Lassen Sie uns zunächst die</a> Ordnerstruktur mit <a href="">PsiDirectory anzeigen</a> .  Das Startverzeichnis des Projekts kann mit den Erweiterungsfunktionen <em>rateProjectDir</em> und <em>toPsiDirectory</em> abgerufen werden: </p><br><div class="spoiler">  <b class="spoiler_title">Holen Sie sich das PsiDirectory-Projekt</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> projectPsiDirectory = project.guessProjectDir()?.toPsiDirectory(project)</code> </pre> </div></div><br><p>  Nachfolgende Verzeichnisse können entweder mit der <em>Klassenmethode</em> <em>psiDirectory</em> <em>findSubdirectory</em> <em>gefunden</em> oder mit der Methode <em>createSubdirectory erstellt</em> werden. </p><br><div class="spoiler">  <b class="spoiler_title">Suchen und erstellen Sie PsiDirectory</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> coreModuleDir = projectPsiDirectory.findSubdirectory(<span class="hljs-string"><span class="hljs-string">"core"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> newModulePsiDir = coreModuleDir.createSubdirectory(config.mainParams.moduleName)</code> </pre> </div></div><br><p>  Ich empfehle außerdem, dass Sie eine <em>Map</em> erstellen, aus der Sie alle <em>PsiDirectory-</em> Ordnerstrukturen mithilfe eines Zeichenfolgenschlüssels <em>abrufen</em> und die erstellten Dateien dann zu einem dieser Ordner hinzufügen können. </p><br><div class="spoiler">  <b class="spoiler_title">Erstellen Sie eine Ordnerstrukturzuordnung</b> <div class="spoiler_text"><p>  return mutableMapOf &lt;String, PsiDirectory?&gt; (). apply { <br>  this ["root"] = modulePsiDir <br>  this ["src"] = modulePsiDir.createSubdirectory ("src") <br>  this ["main"] = this ["src"] ?. createSubdirectory ("main") <br>  this ["java"] = this ["main"] ?. createSubdirectory ("java") <br>  this ["res"] = this ["main"] ?. createSubdirectory ("res") </p><br><pre> <code class="plaintext hljs">//   PsiDirectory   package name: // ru.hh.feature_worknear → ru / hh / feature_worknear createPackageNameFolder(config) // data this["data"] = this["package"]?.createSubdirectory("data") // ...</code> </pre> <br><p>  }} </p></div></div><br><p>  Ordner erstellt.  Wir werden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PsiFiles</a> mit <a href="">PsiFileFactory</a> erstellen.  Diese Klasse verfügt über eine spezielle Methode namens <em>createFileFromText</em> .  Die Methode akzeptiert drei Parameter als Eingabe: Name (String fileName), Text (String text) und Typ (FileType fileType) der Ausgabedatei.  Zwei der drei Parameter sind klar, woher sie stammen: Wir kennen den Namen selbst und den Text von FreeMarker.  Und wo bekomme ich <em>FileType</em> ?  Und worum geht es? </p><br><h3 id="filetype">  Dateityp </h3><br><p>  <a href=""><em>FileType</em></a> ist eine spezielle Klasse, die den Dateityp angibt.  Aus der "Box" stehen uns nur zwei FileType zur Verfügung: JavaFileType und XmlFileType für Java-Dateien bzw. XML-Dateien.  Aber es stellt sich die Frage: <em>Woher</em> bekommen Sie die Typen für die <em>build.gradle-</em> Datei, für die <em>Kotlin-</em> Dateien, für <em>Proguard</em> , für <em>.gitignore</em> ?! </p><br><p>  Erstens können die meisten dieser <em>Dateitypen</em> von anderen Plugins übernommen werden, die bereits von jemandem geschrieben wurden.  GroovyFileType kann aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Groovy-Plugin</a> , KotlinFileType aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kotlin-Plugin</a> und Proguard aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Android-Plugin</a> entnommen werden. </p><br><p>  Wie fügen wir die Abhängigkeit eines anderen Plugins zu unserem hinzu?  Wir verwenden das <em>Gradle-Intellij-Plugin</em> .  Es fügt der build.gradle-Datei des Plugins einen speziellen Intellij-Block hinzu, in dem sich eine spezielle Eigenschaft befindet - <em>Plugins</em> .  In dieser Eigenschaft können Sie die Liste der Plugin-IDs auflisten, von denen wir abhängen möchten. </p><br><div class="spoiler">  <b class="spoiler_title">Fügen Sie Abhängigkeiten zu anderen Plugins hinzu</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// build.gradle  intellij { … plugins = ['android', 'Groovy', 'kotlin'] }</span></span></code> </pre> </div></div><br><p>  Wir nehmen die Schlüssel aus dem offiziellen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JetBrains-Plugin-Repository</a> .  Für in IDEA integrierte Plugins (Groovy, Kotlin und Android) reicht der Name des Plugin-Ordners in IDEA aus.  Im Übrigen müssen Sie zur Seite eines bestimmten Plugins im offiziellen JetBrains-Plugin-Repository gehen. Dort wird die <em>XML-ID-</em> Eigenschaft des Plugins sowie die Version angegeben (hier ist beispielsweise die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Seite des Docker-Plugins</a> ).  Lesen Sie mehr über das Verbinden anderer Plugins <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf GitHub</a> . </p><br><p>  Zweitens müssen Sie der Datei <em>plugin.xml</em> eine Abhängigkeitsbeschreibung <em>hinzufügen</em> .  Dies erfolgt über das Tag <em>.</em> <br></p><div class="spoiler">  <b class="spoiler_title">Wir verbinden Plugins in plugin.xml</b> <div class="spoiler_text"><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">idea-plugin</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">depends</span></span></span><span class="hljs-tag">&gt;</span></span>org.jetbrains.android<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">depends</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">depends</span></span></span><span class="hljs-tag">&gt;</span></span>org.jetbrains.kotlin<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">depends</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">depends</span></span></span><span class="hljs-tag">&gt;</span></span>org.intellij.groovy<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">depends</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">idea-plugin</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> </div></div><br><p>  Nachdem wir das Projekt synchronisiert haben, werden wir die Abhängigkeiten von anderen Plugins verschärfen und sie verwenden können. </p><br><p>  Aber was ist, wenn wir uns nicht auf andere Plugins verlassen wollen?  In diesem Fall können wir einen Stub für den Dateityp erstellen, den wir benötigen.  Erstellen Sie dazu zunächst eine Klasse, die von der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Sprachklasse</em></a> erbt.  Die eindeutige Kennung unserer Programmiersprache wird an diese Klasse übergeben (in unserem Fall <strong>"ru.hh.plugins.Ignore"</strong> ). </p><br><div class="spoiler">  <b class="spoiler_title">Erstellen Sie eine Sprache für GitIgnore-Dateien</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IgnoreLanguage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">private</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>() : Language(<span class="hljs-string"><span class="hljs-string">"ru.hh.plugins.Ignore"</span></span>, <span class="hljs-string"><span class="hljs-string">"ignore"</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>), InjectableLanguage { <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> INSTANCE = IgnoreLanguage() } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDisplayName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: String { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Ignore() (</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$id</span></span></span><span class="hljs-string">)"</span></span> } }</code> </pre> </div></div><br><p>  Hier gibt es eine Funktion: Einige Entwickler fügen eine nicht eindeutige Zeile als Kennung hinzu.  Aus diesem Grund kann die Integration Ihres Plugins in andere Plugins unterbrochen werden.  Wir sind großartig, wir haben eine einzigartige Linie. </p><br><p>  Nachdem Sie <em>Language</em> erstellt haben, müssen Sie als <em>Nächstes</em> einen <em>Dateityp</em> erstellen.  Wir erben von der <em>LanguageFileType-</em> Klasse, verwenden die von uns definierte Sprachinstanz zum Initialisieren und überschreiben einige sehr einfache Methoden.  Fertig.  Jetzt können wir den neu erstellten <em>FileType verwenden</em> . </p><br><div class="spoiler">  <b class="spoiler_title">Erstellen Sie Ihren eigenen Dateityp für .gitignore</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IgnoreFileType</span></span></span></span>(language: Language) : LanguageFileType(language) { <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> INSTANCE = IgnoreFileType(IgnoreLanguage.INSTANCE) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: String = <span class="hljs-string"><span class="hljs-string">"gitignore file"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDescription</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: String = <span class="hljs-string"><span class="hljs-string">"gitignore files"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDefaultExtension</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: String = <span class="hljs-string"><span class="hljs-string">"gitignore"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIcon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Icon? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> }</code> </pre></div></div><br><h3 id="zavershaem-sozdanie-fayla">  Beenden Sie die Erstellung der Datei </h3><br><p>  Nachdem Sie alle erforderlichen <em>Dateitypen gefunden haben</em> , empfehle ich, einen speziellen Container namens <em>TemplateData</em> zu erstellen. Dieser enthält alle Daten zu der Vorlage, aus der Sie Code generieren möchten.  Es enthält den Namen der Vorlagendatei, den Namen der <em>Ausgabedatei</em> , die Sie nach dem Generieren des Codes erhalten, den gewünschten <em>Dateityp</em> und schließlich <em>PsiDirectory</em> , in dem Sie die erstellte Datei hinzufügen. </p><br><div class="spoiler">  <b class="spoiler_title">TemplateData</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TemplateData</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> templateFileName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> outputFileName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> outputFileType: FileType, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> outputFilePsiDirectory: PsiDirectory? )</code> </pre> </div></div><br><p>  Dann kehren wir zu <em>FreeMarker zurück</em> - wir erhalten die Vorlagendatei daraus, mit <em>StringWriter erhalten</em> wir den Text, in der <em>PsiFileFactory</em> generieren <em>wir</em> die <em>PsiFile</em> mit dem gewünschten Text und Typ.  Die erstellte Datei wird dem gewünschten Verzeichnis hinzugefügt. </p><br><div class="spoiler">  <b class="spoiler_title">Erstellen Sie PsiFile im gewünschten Ordner</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createFromTemplate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">data</span></span></span></span><span class="hljs-function"><span class="hljs-params">: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">FileTemplateData</span></span></span></span><span class="hljs-function"><span class="hljs-params">, properties: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Map</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Any&gt;)</span></span></span></span>: PsiFile { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> template = freeMarkerConfig.getTemplate(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.templateFileName) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> text = StringWriter().use { writer -&gt; template.process(properties, writer) writer.buffer.toString() } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> psiFileFactory.createFileFromText(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.outputFileName, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.outputFileType, text) }</code> </pre> </div></div><br><p>  Somit wird die PSI-Struktur berücksichtigt und IDEA sowie andere Plugins werden sehen, was wir getan haben.  Dies kann einen Gewinn bringen: Wenn das Plugin für Git beispielsweise feststellt, dass Sie eine neue Datei hinzugefügt haben, wird automatisch ein Dialogfeld angezeigt, in dem Sie gefragt werden, ob Sie diese Dateien zu Git hinzufügen möchten. </p><br><h3 id="vyvody-pro-generaciyu-koda">  Schlussfolgerungen zur Codegenerierung </h3><br><ul><li>  Textdateien können von FreeMarker generiert werden.  Sehr bequem. </li><li>  Beim Generieren von Dateien müssen Sie die PSI-Struktur berücksichtigen, da sonst alles schief geht. </li><li>  Wenn Sie Dateien mit PsiFileFactory generieren möchten, müssen Sie FileType irgendwo finden. </li></ul><br><p>  Nun wenden wir uns dem letzten, köstlichsten praktischen Teil zu - dies ist eine Modifikation des Codes. </p><br><h2 id="modifikaciya-koda">  Codeänderung </h2><br><p>  Tatsächlich ist das Erstellen eines Plugins nur zum Generieren von Code Unsinn, da Sie Code mit anderen Tools und demselben <em>FreeMarker</em> generieren können.  Was <em>FreeMarker</em> jedoch nicht tun kann, ist den Code zu ändern. </p><br><p>  Unsere Checkliste enthält mehrere Aufgaben im Zusammenhang mit dem Ändern des Codes. Beginnen wir mit der einfachsten - dem Ändern der Datei <em>settings.gradle</em> . </p><br><h3 id="modifikaciya-settingsgradle">  Modification settings.gradle </h3><br><p>  Ich möchte Sie daran erinnern, was wir tun möchten: Wir müssen dieser Datei einige Zeilen hinzufügen, die den Pfad zum neu erstellten Modul beschreiben: </p><br><div class="spoiler">  <b class="spoiler_title">Beschreibung des Pfades zum Modul</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// settings.gradle include ':analytics project(':analytics').projectDir = new File(settingsDir, 'core/framework-metrics/analytics) ... include ':feature-worknear' project(':feature-worknear').projectDir = new File(settingsDir, 'feature/feature-worknear')</span></span></code> </pre> </div></div><br><p>  Ich habe Sie etwas früher erschreckt, dass Sie bei der Arbeit mit Dateien sonst immer die PSI-Struktur berücksichtigen müssen <del>  alles wird brennen </del>  wird nicht funktionieren.  Tatsächlich kann dies bei einfachen Aufgaben wie dem Hinzufügen einiger Zeilen am Ende einer Datei weggelassen werden.  Sie können der Datei mit der üblichen Datei <em>java.io.File</em> einige Zeilen <em>hinzufügen</em> .  Dazu finden wir den Pfad zur Datei, erstellen die Instanz <em>java.io.File</em> und fügen mit Hilfe der Kotlin- <em>Erweiterungsfunktionen</em> zwei Zeilen am Ende dieser Datei hinzu.  Sie können dies tun, IDEA wird Ihre Änderungen sehen. </p><br><div class="spoiler">  <b class="spoiler_title">Hinzufügen von Zeilen zur Datei settings.gradle</b> <div class="spoiler_text"><p>  val projectBaseDirPath = project.basePath?: return <br>  val settingsPathFile = projectBaseDirPath + "/settings.gradle" </p><br><p>  val settingsFile = Datei (settingsPathFile) </p><br><p>  settingsFile.appendText ("include ': $ moduleName'") <br>  settingsFile.appendText ( <br>  "project (': $ moduleName'). projectDir = neue Datei (settingsDir, '$ folderPath')" <br>  ) </p></div></div><br><p>  Im Idealfall ist es natürlich besser durch die PSI-Struktur - es ist zuverlässiger. </p><br><h3 id="donastroyka-kapt-a-dlya-toothpick">  Kapt Tuning für Zahnstocher </h3><br><p>  Ich erinnere Sie noch einmal an das Problem: Im Anwendungsmodul befindet sich eine <em>build.gradle-</em> Datei und darin befinden sich Einstellungen für den Anmerkungsprozessor.  Und wir möchten ein Paket unseres erstellten Moduls an einer bestimmten Stelle hinzufügen. </p><br><div class="spoiler">  <b class="spoiler_title">Wohin wohin? ..</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/jt/hv/1b/jthv1bxuiigvexnvwnrvzs41wh8.png" alt="Bild"></p></div></div><br><p>  Unser Ziel ist es, ein bestimmtes <em>PsiElement</em> zu finden. <em>Danach</em> planen wir, unsere Linie hinzuzufügen.  Die Suche nach dem Element beginnt mit der Suche nach der <em>PsiFile</em> , die die Datei <em>build.gradle</em> des Anwendungsmoduls bezeichnet.  Und dafür müssen Sie das Modul finden, in dem wir nach der Datei suchen. </p><br><div class="spoiler">  <b class="spoiler_title">Wir suchen ein Modul mit Namen</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> appModule = ModuleManager.getInstance(project) .modules.toList() .first { it.name == <span class="hljs-string"><span class="hljs-string">"headhunter-applicant"</span></span> }</code> </pre> </div></div><br><p>  Als Nächstes können Sie mithilfe der Dienstprogrammklasse <em>FilenameIndex PsiFile</em> anhand seines Namens finden und das als Suchbereich gefundene Modul <em>angeben</em> . </p><br><div class="spoiler">  <b class="spoiler_title">Suche nach PsiFile mit Namen</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> buildGradlePsiFile = FilenameIndex.getFilesByName( appModule.project, <span class="hljs-string"><span class="hljs-string">"build.gradle"</span></span>, appModule.moduleContentScope ).first()</code> </pre> </div></div><br><p>  Nachdem wir die PsiFile gefunden haben, können wir nach dem PsiElement suchen.  Um es zu finden, empfehle ich die Installation eines speziellen Plug-Ins - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PSI Viewer</a> .     IDEA  ,    PSI-  . </p><br><p><img src="https://habrastorage.org/webt/sd/nl/ac/sdnlac9nrqcqqt14wtrhohr9pf8.png" alt="Bild"></p><br><p>    -  (, build.gradle)        ,      PSI-   . </p><br><p><img src="https://habrastorage.org/webt/gt/et/xo/gtetxo8_4hbk0gzzfty7p_zmawu.png" alt="Bild"></p><br><p>    –   ,        <em>PsiFile</em> -. </p><br><p>    .   <em>PsiFile</em> .            . </p><br><div class="spoiler"> <b class="spoiler_title">  PsiElement</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> toothpickRegistryPsiElement = buildGradlePsiFile.originalFile .collectDescendantsOfType&lt;GrAssignmentExpression&gt;() .firstOrNull { it.text.startsWith(<span class="hljs-string"><span class="hljs-string">"arguments"</span></span>) } ?.lastChild ?.children?.firstOrNull { it.text.startsWith(<span class="hljs-string"><span class="hljs-string">"toothpick_registry_children_package_names"</span></span>) } ?.collectDescendantsOfType&lt;GrListOrMap&gt;() ?.first() ?: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span></code> </pre> </div></div><br><p><del>  ?.. </del>   ?          PSI-.        <em>GrAssignmentExpression</em> ,   ,    <em>arguments = [ … ]</em> .      ,      <em>toothpick_registry_children_package_names = [...]</em> ,       Groovy-. </p><br><p>    <em>PsiElement</em> ,   .            .      . </p><br><p>     PSI- ,       <em>PsiElementFactory</em>   ,    .  Java-?    Java-.   Groovy?  <em>GroovyPsiElementFactory</em> .  Usw. </p><br><p>  <em>PsiElementFactory</em>       .       Groovy  Kotlin ,        . </p><br><div class="spoiler"> <b class="spoiler_title"> PsiElement  package name</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> factory = GroovyPsiElementFactory.getInstance(buildGradlePsiFile.project) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> packageName = config.mainParams.packageName <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> newArgumentItem = factory.createStringLiteralForReference(packageName)</code> </pre> </div></div><br><p>         <em>PsiElement</em> . </p><br><div class="spoiler"> <b class="spoiler_title">   Map-</b> <div class="spoiler_text"><pre> <code class="kotlin hljs">targetPsiElement.add(newArgumentItem)</code> </pre> </div></div><br><h3 id="donastroyka-kapt-a-dlya-moxy-v-application-module">  kapt-  Moxy  application  </h3><br><p>    -,    , –  kapt-  Moxy  application .  :          <em>@RegisterMoxyReflectorPackages</em> . </p><br><div class="spoiler"> <b class="spoiler_title">-?</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/us/17/in/us17inlvgteb4k9pmegkurtl7y8.png" alt="Bild"></p></div></div><br><p>         ,  :  <em>PsiFile</em> ,  <em>PsiElement</em> ,  …      ,         <em>PsiElement</em> -. </p><br><p>     :  ,    <em>@RegisterMoxyReflectorPackages</em> ,       <em>value</em>  ,          . </p><br><p>    ,       . ,     <em>PsiManager</em> ,   <em>PsiClass</em>  . </p><br><div class="spoiler"> <b class="spoiler_title"> PsiClass  @RegisterMoxyReflectorPackages</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> appModule = ModuleManager.getInstance(project) .modules.toList() .first { it.name == <span class="hljs-string"><span class="hljs-string">"headhunter-applicant"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> psiManager = PsiManager.getInstance(appModule.project) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> annotationPsiClass = ClassUtil.findPsiClass( psiManager, <span class="hljs-string"><span class="hljs-string">"com.arellomobile.mvp.RegisterMoxyReflectorPackages"</span></span> ) ?: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span></code> </pre> </div></div><br><p>     <em>AnnotatedMembersSearch</em>   ,      . </p><br><div class="spoiler"> <b class="spoiler_title"> ,  </b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> annotatedPsiClass = AnnotatedMembersSearch.search( annotationPsiClass, appModule.moduleContentScope ).findAll() ?.firstOrNull() ?: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span></code> </pre> </div></div><br><p>  ,  <em>PsiElement</em>  ,        value.     ,      . </p><br><div class="spoiler"> <b class="spoiler_title">      </b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> annotationPsiElement = (annotatedPsiClass .annotations .first() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> KtLightAnnotationForSourceEntry ).kotlinOrigin <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> packagesPsiElements = annotationPsiElement .collectDescendantsOfType&lt;KtValueArgumentList&gt;() .first() .collectDescendantsOfType&lt;KtValueArgument&gt;() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> updatedPackagesList = packagesPsiElements .mapTo(mutableListOf()) { it.text } .apply { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> += <span class="hljs-string"><span class="hljs-string">"\"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${config.packageName}</span></span></span><span class="hljs-string">\""</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> newAnnotationValue = updatedPackagesList.joinToString(separator = <span class="hljs-string"><span class="hljs-string">",\n"</span></span>)</code> </pre> </div></div><br><p>   <em>KtPsiFactory</em>   <em>PsiElement</em> –          . </p><br><div class="spoiler"> <b class="spoiler_title">      </b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kotlinPsiFactory = KtPsiFactory(project) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> newAnnotationPsiElement = kotlinPsiFactory.createAnnotationEntry( <span class="hljs-string"><span class="hljs-string">"@RegisterMoxyReflectorPackages(\n</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$newAnnotationValue</span></span></span><span class="hljs-string">\n)"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> replaced = annotationPsiElement.replace(newAnnotationPsiElement)</code> </pre> </div></div><br><p>  . </p><br><p>     ?    code style.  ,      IDEA    : CodeStyleManager. </p><br><div class="spoiler"> <b class="spoiler_title"> code style</b> <div class="spoiler_text"><pre> <code class="kotlin hljs">CodeStyleManager.getInstance(module.project).reformat(replacedElement)</code> </pre> </div></div><br><p>    -  ,     . </p><br><h3 id="vyvody-1">  Schlussfolgerungen </h3><br><ul><li>     ,      PSI-,      . </li><li> ,  PSI     ,    ,    PsiElement-. </li></ul><br><h1 id="chto-delat-dalshe">  Was ist als nächstes zu tun? </h1><br><p>   . </p><br><ul><li>      –    ,       . </li><li>       .       .   :            . </li><li>     ?      .  , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   IDEA</a>   ,   .       ,        . —   -  ,    GitHub  .  ,    ,  . </li><li>    -   –    IntelliJ IDEA   .  ,   <em>Util</em>  <em>Manager</em> ,  ,    ,    . </li><li>   :     .  ,  <em>runIde</em> ,     IDEA,   .   ,           hh.ru,       . </li></ul><br><p>  Das ist alles. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  </a> ,  ,   – . </p><br><h2 id="faq"> FAQ </h2><br><ul><li>       ? </li></ul><br><p>       ,       .      ,   2  3 . </p><br><ul><li>       IDEA   ,   -  ? </li></ul><br><p> ,    IDEA   IDEA SDK ,   deprecated,   ,  .   SDK-   ,   ,     . </p><br><ul><li>         ? </li></ul><br><p>    –    gitignore .   -   . </p><br><ul><li>          ? </li></ul><br><p>      Android Studio  Mac OS,    Ubuntu,   . ,     Windows,    . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de463611/">https://habr.com/ru/post/de463611/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de463599/index.html">"Dies ist ein Albtraum": Astronauten teilen Meinungen darüber, welche Fehler Hollywood macht, wenn er Filme über den Weltraum dreht</a></li>
<li><a href="../de463601/index.html">Separate Methodenprotokollierung in Java / Logback</a></li>
<li><a href="../de463605/index.html">Die technische Intelligenz - aus dem Weltraum</a></li>
<li><a href="../de463607/index.html">Redux integrierte Alternative mit React Context und Hooks</a></li>
<li><a href="../de463609/index.html">Empfehlungssystem für Directum Club. Erster Teil, kollaborativ</a></li>
<li><a href="../de463613/index.html">Docker-Images können auch mit der üblichen Docker-Datei in werf erstellt werden</a></li>
<li><a href="../de463617/index.html">Funktionen zum Testen von mobilem MMO</a></li>
<li><a href="../de463619/index.html">Fernarbeit: unsere Erfahrung</a></li>
<li><a href="../de463623/index.html">Wir werden aus dem Dschungel der Tests ausgewählt: Wir bauen einen kurzen Weg von den Vorrichtungen zum Testen</a></li>
<li><a href="../de463625/index.html">Netzwerküberwachung und Erkennung abnormaler Netzwerkaktivitäten mithilfe von Flowmon Networks-Lösungen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>