<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛳️ ⚾️ 🈶 Guia do Node.js, parte 2: JavaScript, V8, alguns truques de desenvolvimento 👩🏿‍🤝‍👩🏽 🐖 👨‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ao publicar a primeira parte da tradução deste guia no Node.js, decidimos descobrir a opinião do público sobre se devemos continuar trabalhando no pro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Guia do Node.js, parte 2: JavaScript, V8, alguns truques de desenvolvimento</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/423153/">  Ao publicar a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">primeira parte da</a> tradução <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">deste</a> guia no Node.js, decidimos descobrir a opinião do público sobre se devemos continuar trabalhando no projeto e realizamos uma pequena pesquisa.  Como se viu, aproximadamente 94% dos que votaram apoiaram nossa iniciativa.  Portanto, conheça a segunda parte do tutorial Node.js. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/he/di/2j/hedi2j_qyfbnwfo_jqnnqd3ub6o.png"></a> <br><br>  Hoje, falaremos sobre o tipo de conhecimento de JS que você precisa ter para desenvolver aplicativos com eficiência na plataforma Node.js. discutiremos as diferenças entre o código JavaScript do navegador e o servidor e falaremos sobre os mecanismos JS e algumas técnicas de desenvolvimento do Node.js. <br><br><div class="spoiler">  <b class="spoiler_title">[Aconselhamos a ler] Outras partes do ciclo</b> <div class="spoiler_text">  Parte 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Informações gerais e introdução</a> <br>  Parte 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">JavaScript, V8, alguns truques de desenvolvimento</a> <br>  Parte 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Hospedagem, REPL, trabalho com o console, módulos</a> <br>  Parte 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">arquivos npm, package.json e package-lock.json</a> <br>  Parte 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">npm e npx</a> <br>  Parte 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">loop de eventos, pilha de chamadas, temporizadores</a> <br>  Parte 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Programação assíncrona</a> <br>  Parte 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Guia Node.js, Parte 8: Protocolos HTTP e WebSocket</a> <br>  Parte 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Guia Node.js, parte 9: trabalhando com o sistema de arquivos</a> <br>  Parte 10: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Guia do Node.js, Parte 10: Módulos padrão, fluxos, bancos de dados, NODE_ENV</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PDF completo do Guia Node.js.</a> <br></div></div><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Que tipo de conhecimento de JS eu preciso para o desenvolvimento do Node.js.</font> </h2><br>  Suponha que você acabou de começar a programar.  Qual a profundidade necessária para aprender JavaScript para dominar o Node.js com êxito?  É difícil para um iniciante atingir esse nível quando ganha confiança suficiente em suas habilidades profissionais.  Além disso, ao estudar programação, você pode achar que não entende exatamente onde o JavaScript do navegador termina e o desenvolvimento do Node.js. começa. <br><br>  Se você está no começo do caminho de um programador JavaScript, aconselho você, antes de escrever para o Node.js, a dominar bem os seguintes conceitos de linguagem: <br><br><ul><li>  Construções lexicais. </li><li>  Expressões. </li><li>  Tipos. </li><li>  Variáveis </li><li>  Funções </li><li>  Esta palavra-chave. </li><li>  Funções de seta </li><li>  Ciclos </li><li>  Escopos. </li><li>  Matrizes </li><li>  Sequências de modelos. </li><li>  Aplique um ponto e vírgula. </li><li>  Trabalhe em modo estrito. </li></ul><br>  De fato, esta lista continua, mas se você dominar tudo, significa que você estabelecerá uma boa base para o desenvolvimento produtivo de clientes e servidores em JavaScript. <br>  Os seguintes conceitos de linguagem também são muito importantes para entender as idéias de programação assíncrona, que são uma das partes básicas do Node.js.  Em particular, estamos falando sobre o seguinte: <br><br><ul><li>  Programação assíncrona e funções de retorno de chamada. </li><li>  Temporizadores. </li><li>  Promessas. </li><li>  Construção assíncrona / aguardada. </li><li>  Curto-circuito. </li><li>  Ciclo de eventos. </li></ul><br>  Existem muitos materiais JavaScript que permitem que os iniciantes aprendam o idioma.  Por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui está</a> o curso de treinamento do autor para este guia, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui está uma</a> seção muito útil do MDN, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui está o</a> tutorial para javascript.ru.  Você pode aprender mecanismos básicos de JavaScript em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">freecodecamp.com</a> . <br><br>  Acima, falamos sobre como os iniciantes podem se preocupar com a questão de onde está o limite entre o desenvolvimento do JavaScript do servidor e do cliente.  Vamos conversar sobre isso. <br><br><h2>  <font color="#3AC1EF">Diferenças entre a plataforma Node.js e o navegador</font> </h2><br>  Como o desenvolvimento JS para Node.js é diferente da programação do navegador?  A semelhança entre esses ambientes é que a mesma linguagem é usada lá e ali.  Mas o desenvolvimento de aplicativos projetados para serem executados em um navegador é muito diferente do desenvolvimento de aplicativos de servidor.  Apesar de usar a mesma linguagem, existem algumas diferenças importantes que transformam esses dois tipos de desenvolvimento em atividades completamente diferentes. <br><br>  Deve-se notar que, se alguém que costumava fazer o trabalho de front-end começa a aprender o Node.js., ele tem uma oportunidade muito séria de dominar rapidamente tudo o que é necessário, devido ao fato de escrever em um idioma que já conhece.  Se a necessidade de aprender um novo ambiente for adicionada e a necessidade de aprender um novo idioma, a tarefa será muito mais complicada. <br>  Portanto, a principal diferença entre o cliente e o servidor é o ambiente para o qual você deve programar, nos ecossistemas desses ambientes. <br><br>  No navegador, a maior parte do trabalho recai sobre várias operações com documentos da web por meio do DOM, bem como o uso de outras APIs da plataforma da web, como, por exemplo, mecanismos para trabalhar com cookies.  O Node.js, é claro, tem tudo isso.  Não há objeto de <code>document</code> , objeto de <code>window</code> e outros objetos fornecidos pelo navegador. <br><br>  O navegador, por sua vez, não possui os mecanismos de software disponíveis no ambiente Node.js. e existe na forma de módulos que podem ser conectados ao aplicativo.  Por exemplo, esta é uma API para acessar o sistema de arquivos. <br><br>  Outra diferença entre o desenvolvimento de clientes e servidores em JS é que, ao trabalhar em um ambiente Node.js., o desenvolvedor tem controle total sobre o ambiente.  A menos que você esteja desenvolvendo um aplicativo de código aberto que possa ser executado em qualquer lugar, você sabe exatamente, por exemplo, em qual versão do Node.js o seu projeto trabalhará.  Isso é muito conveniente se comparado ao ambiente do cliente em que seu código precisa funcionar no navegador do usuário.  Além disso, isso significa que você pode, sem medo de problemas, usar os recursos mais recentes do idioma. <br><br>  Como o JavaScript está se desenvolvendo extremamente rápido, os navegadores simplesmente não têm tempo suficiente para implementar rapidamente todas as suas inovações.  Além disso, nem todos os usuários trabalham nas versões mais recentes dos navegadores.  Como resultado, os desenvolvedores que desejam usar algo novo em seus programas são forçados a levar isso em conta, cuidar da compatibilidade de seus aplicativos com os navegadores que usam, o que pode resultar na necessidade de abandonar os recursos modernos do JavaScript.  Obviamente, é possível usar o transportador Babel para converter o código em um formato compatível com o padrão EcmaScript 5, suportado por todos os navegadores, mas você não precisará disso ao trabalhar com o Node.js. <br><br>  Outra diferença entre o Node.js e os navegadores é que o Node.js usa o sistema do módulo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CommonJS</a> , enquanto nos navegadores você pode ver o início da implementação do padrão ES Modules.  Na prática, isso significa que atualmente no Node.js., a construção <code>require()</code> é usada para conectar código externo e <code>import</code> no código do navegador. <br><br><h2>  <font color="#3AC1EF">V8 e outros mecanismos JavaScript</font> </h2><br>  V8 é o nome do mecanismo JavaScript usado no navegador Google Chrome.  É ele quem é responsável pela execução do código JavaScript, que entra no navegador quando se trabalha na Internet.  V8 fornece um tempo de execução para JavaScript.  O DOM e outras APIs da plataforma da web são fornecidas pelo navegador. <br><br>  O mecanismo JS é independente do navegador em que é executado.  É esse fato que possibilitou o surgimento e o desenvolvimento da plataforma Node.js.  O V8 foi escolhido como o mecanismo para o Node.js em 2009.  Como resultado do crescimento explosivo da popularidade, o Node.js V8 acabou sendo um mecanismo que agora é responsável por executar uma enorme quantidade de código JS do lado do servidor. <br><br>  O ecossistema do Node.js é enorme.  Graças a isso, o V8 também é usado, através de projetos como o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Electron</a> , para desenvolver aplicativos de desktop. <br><br>  Note-se que, além do V8, existem outros mecanismos: <br><br><ul><li>  O Firefox usa o mecanismo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SpiderMonkey</a> . </li><li>  O Safari usa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">JavaScriptCore</a> (também chamado Nitro). </li><li>  O Edge usa o mecanismo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Chakra</a> . </li></ul><br>  A lista de mecanismos JS não se limita a isso. <br><br>  Esses mecanismos implementam a especificação ECMA-262, também chamada de ECMAScript.  É essa especificação que padroniza o JavaScript.  A versão mais recente do padrão pode ser encontrada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br><h3>  <font color="#3AC1EF">Desenvolvimento do motor SJS e aspiração de desempenho</font> </h3><br>  O mecanismo V8 é escrito em C ++, sendo constantemente aprimorado.  Pode ser executado em muitos sistemas, particularmente Mac, Windows e Linux.  Aqui não falaremos sobre os detalhes da implementação do V8.  Informações sobre eles podem ser encontradas em outras publicações, inclusive no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">site oficial da V8</a> .  Eles mudam com o tempo, às vezes muito a sério. <br><br>  V8 está em constante evolução, o mesmo pode ser dito de outros motores.  Isso leva, em particular, a um aumento no desempenho dos navegadores da web e da plataforma Node.js.  Os fabricantes de motores de navegadores estão constantemente competindo, lutando pela velocidade de execução do código, isso ocorre há muitos anos.  Tudo isso é benéfico para usuários e programadores. <br><br><h3>  <font color="#3AC1EF">▍ Interpretação e compilação</font> </h3><br>  O JavaScript é considerado uma linguagem interpretada, mas os mecanismos modernos estão longe de interpretar apenas o código JS.  Eles o compilam.  Essa tendência pode ser observada desde 2009, quando o compilador JavaScript foi adicionado no Firefox 3.5, após o qual outros fabricantes de mecanismos e navegadores adotaram essa idéia. <br><br>  V8 compila JavaScript para melhorar o desempenho do código.  Desde o advento do Google Maps em 2004, o JavaScript evoluiu, evoluiu de uma linguagem na qual, para implementar os recursos interativos de aplicativos da Web, eles geralmente escreviam algumas dezenas de linhas, em uma linguagem na qual os aplicativos de navegador compostos por milhares ou mesmo centenas são escritos. mil linhas de código.  Esses aplicativos podem ser executados por horas no navegador, o que é muito diferente dos antigos cenários de uso de JS, o código no qual, por exemplo, só poderia ser usado para verificar a correção dos dados inseridos nos formulários.  Em condições modernas, compilar o código faz muito sentido, porque, embora a execução dessa etapa possa atrasar o momento em que o código é lançado, após a compilação, o código é muito mais produtivo do que aquele que seria processado exclusivamente pelo intérprete e funcionaria mais rápido, mas funcionaria mais lentamente. <br><br>  Agora, tendo discutido algumas disposições sobre mecanismos JS, interpretação e compilação de código, vamos continuar praticando.  Ou seja, vamos falar sobre como desligar os aplicativos Node.js. <br><br><h2>  <font color="#3AC1EF">Saindo do aplicativo Node.js.</font> </h2><br>  Existem várias maneiras de desligar os aplicativos Node.js. <br><br>  Portanto, ao executar um programa no console, você pode finalizar seu trabalho usando o atalho de teclado <code>ctrl+c</code> .  Mas estamos mais interessados ​​em métodos de software para desligar aplicativos.  E começaremos, talvez, com o comando mais rude para sair do programa, o que, como você agora entenderá, é melhor não usá-lo. <br><br>  O módulo de <code>process</code> kernel fornece um método conveniente que permite sair programaticamente de um aplicativo Node.js.  É assim: <br><br><pre> <code class="hljs vhdl"><span class="hljs-keyword"><span class="hljs-keyword">process</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>()</code> </pre> <br>  Quando o Node.js encontra esse comando no código, isso leva ao fato de que seu processo termina instantaneamente.  Isso significa que absolutamente tudo o que o programa fez será bastante rude e incondicionalmente interrompido.  Estamos falando de retornos de chamada não convidados, sobre solicitações de rede sendo executadas no momento do lançamento, sobre ações com arquivos, sobre operações de gravação em <code>stdout</code> ou <code>stderr</code> . <br><br>  Se essa situação lhe convier, você pode usar este método.  Quando você o chama, pode transmitir um número inteiro que será percebido pelo sistema operacional como o código de saída do programa. <br><br><pre> <code class="hljs vhdl"><span class="hljs-keyword"><span class="hljs-keyword">process</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Por padrão, esse código é definido como 0, o que significa conclusão bem-sucedida.  Outros códigos de saída têm significados diferentes, que podem ser úteis para usá-los em seu próprio sistema para estabelecer a interação de alguns programas com outros. <br>  Detalhes sobre os códigos de desligamento do programa podem ser encontrados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  Você também pode atribuir um código de saída à propriedade <code>process.exitCode</code> .  É assim: <br><br><pre> <code class="hljs vhdl"><span class="hljs-keyword"><span class="hljs-keyword">process</span></span>.exitCode = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Após o término do programa, o Node.js retornará esse código ao sistema. <br><br>  Deve-se notar que o trabalho do programa terminará naturalmente por si só depois de executar todas as ações especificadas nele.  No entanto, no caso do Node.js, geralmente existem programas que, em condições ideais, são projetados para funcionar por tempo indeterminado.  Estamos falando, por exemplo, sobre servidores HTTP como este: <br><br><pre> <code class="hljs coffeescript">const express = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'express'</span></span>) const app = express() app.get(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(req, res)</span></span></span><span class="hljs-function"> =&gt;</span></span> { res.send(<span class="hljs-string"><span class="hljs-string">'Hi!'</span></span>) }) app.listen(<span class="hljs-number"><span class="hljs-number">3000</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Server ready'</span></span>))</code> </pre> <br>  Tal programa, se nada acontecer, em teoria, pode funcionar para sempre.  Nesse caso, se você chamar <code>process.exit()</code> , as operações executadas por ele no momento da chamada deste comando serão interrompidas.  E isso é ruim. <br><br>  Para concluir o trabalho de tais programas, você precisa usar o sinal <code>SIGTERM</code> e executar as ações necessárias usando o manipulador apropriado. <br><br>  Observe que, para usar o objeto de <code>process</code> , você não precisa conectar nada usando o <code>require</code> , pois esse objeto está disponível para aplicativos Node.js. por padrão. <br><br>  Considere o seguinte exemplo: <br><br><pre> <code class="hljs coffeescript">const express = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'express'</span></span>) const app = express() app.get(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(req, res)</span></span></span><span class="hljs-function"> =&gt;</span></span> { res.send(<span class="hljs-string"><span class="hljs-string">'Hi!'</span></span>) }) app.listen(<span class="hljs-number"><span class="hljs-number">3000</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Server ready'</span></span>)) process.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'SIGTERM'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { app.close(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Process terminated'</span></span>) }) })</code> </pre> <br>  O que são sinais?  Sinais são um meio de interação entre processos no padrão POSIX (Interface do sistema operacional portátil).  São notificações enviadas ao processo para informá-lo sobre determinados eventos. <br><br>  Por exemplo, um sinal <code>SIGKILL</code> informa ao processo que ele precisa ser desligado imediatamente.  Idealmente, funciona exatamente como <code>process.exit()</code> . <br><br>  O sinal <code>SIGTERM</code> informa ao processo que ele precisa executar um procedimento normal de desligamento.  Esses sinais são enviados por gerentes de processo, como <code>upstart</code> ou <code>supervisord</code> , e por muitos outros. <br><br>  Você pode enviar esse sinal a partir do próprio programa, usando o seguinte comando: <br><br><pre> <code class="hljs vhdl"><span class="hljs-keyword"><span class="hljs-keyword">process</span></span>.kill(<span class="hljs-keyword"><span class="hljs-keyword">process</span></span>.pid, <span class="hljs-symbol"><span class="hljs-symbol">'SIGTERM</span></span>')</code> </pre> <br>  Para concluir com êxito esse comando, você precisa conhecer o <code>PID</code> processo que planeja concluir. <br><br><h2>  <font color="#3AC1EF">Lendo variáveis ​​de ambiente do Node.js</font> </h2><br>  O módulo do kernel do <code>process</code> possui a propriedade <code>env</code> , que fornece acesso a todas as variáveis ​​de ambiente definidas no momento em que o processo foi iniciado. <br><br>  Aqui está um exemplo de trabalho com a variável de ambiente <code>NODE_ENV</code> , que, por padrão, está configurada para <code>development</code> : <br><br><pre> <code class="hljs mel">process.<span class="hljs-keyword"><span class="hljs-keyword">env</span></span>.NODE_ENV <span class="hljs-comment"><span class="hljs-comment">// "development"</span></span></code> </pre> <br>  Se, antes de executar o script, defina-o como <code>production</code> , isso indicará ao Node.js que o programa está sendo executado em um ambiente de produção. <br><br>  Da mesma forma, você pode trabalhar com outras variáveis ​​de ambiente, por exemplo, aquelas que você mesmo definiu. <br><br><h2>  <font color="#3AC1EF">Sumário</font> </h2><br>  Hoje, abordamos questões de programação de navegadores e servidores em JavaScript, conversamos sobre mecanismos JS, como desligar aplicativos de servidor e como ler variáveis ​​de ambiente dos programas Node.js.  Da próxima vez, falaremos sobre hospedagem para aplicativos Node.js., como usar o Node.js. no modo REPL, como trabalhar com argumentos que podem ser passados ​​para scripts quando chamados, como interagir com o console e como projetar o código como módulos. <br><br>  <b>Caros leitores!</b>  Quais tutoriais de JavaScript você recomendaria para iniciantes? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt423153/">https://habr.com/ru/post/pt423153/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt423143/index.html">October Slerm: Intensivo em Kubernetes</a></li>
<li><a href="../pt423145/index.html">Extensão PHP e Kotlin Native. Parte três, provavelmente final</a></li>
<li><a href="../pt423147/index.html">Sobre a estratégia e o formato de armazenamento na era Hadoop</a></li>
<li><a href="../pt423149/index.html">Comparação direta dos métodos de correção da miopia a laser ou o que você paga ao escolher o ReLEx SMILE</a></li>
<li><a href="../pt423151/index.html">Objetos globais em PHP</a></li>
<li><a href="../pt423155/index.html">Curso MIT "Segurança de sistemas de computadores". Aula 8: Modelo de Segurança de Rede, Parte 2</a></li>
<li><a href="../pt423157/index.html">Usando a função connect () do react-redux</a></li>
<li><a href="../pt423159/index.html">Feliz dia do programador! Ame seus desenvolvedores</a></li>
<li><a href="../pt423161/index.html">As empresas querem dados pessoais</a></li>
<li><a href="../pt423163/index.html">Conectando o CryptoPro ao Mono</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>