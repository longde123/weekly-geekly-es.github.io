<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😼 🌆 🍣 Fonctionnement de la composition alpha 🥐 👨🏽‍🤝‍👨🏻 🌓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La transparence peut ne pas sembler être un sujet intéressant. Le format GIF, qui permettait à certains pixels de briller à l'arrière-plan, a été publ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fonctionnement de la composition alpha</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468067/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/fd/bw/7x/fdbw7xdswtd_k6crz13wprtqbtm.gif" alt="image"></div><br>  La transparence peut ne pas sembler être un sujet intéressant.  Le format GIF, qui permettait à certains pixels de briller à l'arrière-plan, a été publié il y a plus de 30 ans.  Presque toutes les applications de conception graphique publiées au cours des deux dernières décennies prennent en charge la création de contenu translucide.  Ces concepts ont depuis longtemps cessé d'être quelque chose de nouveau. <br><br>  Dans mon article, je veux montrer qu'en fait, la transparence dans les images numériques est beaucoup plus intéressante qu'il n'y paraît - dans ce que nous tenons pour acquis, il y a une profondeur et une beauté invisibles. <br><a name="habracut"></a><br><h1>  L'opacité </h1><br>  Si vous avez déjà regardé à travers des lunettes roses, vous pouvez voir quelque chose de similaire à ce qui est illustré dans la figure ci-dessous.  [Dans l'article d'origine, de nombreuses images sont interactives.] Essayez de déplacer les lunettes pour voir comment elles affectent ce qui est visible à travers elles: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tu/zo/mz/tuzomzqhbl9mcfzbxxcaneot3aq.png"></div><br>  Ces lunettes fonctionnent comme suit: il leur manque beaucoup de rouge, une quantité décente de bleu et très peu de vert.  Les mathématiques de ces points peuvent être écrites dans un ensemble de trois équations.  La lettre <strong>R</strong> indique le résultat de l'opération, et la lettre <strong>D</strong> décrit le point que nous regardons.  Les indices RVB indiquent les composantes rouge, verte et bleue: <br><br><blockquote><code>R <sub>R</sub> = D <sub>R</sub> × 1.0 <br> R <sub>G</sub> = D <sub>G</sub> × 0.7 <br> R <sub>B</sub> = D <sub>B</sub> × 0.9</code> </blockquote> <br>  Ce vitrail transmet les composants rouges, verts et bleus de l'arrière-plan avec des forces variables.  En d'autres termes, la <em>transparence des</em> verres roses dépend de la couleur de la lumière incidente.  En général, la transparence peut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">varier en fonction de la longueur d'onde de la lumière</a> , mais dans cet exemple simplifié, nous nous intéressons uniquement à la façon dont les lunettes affectent les composants RVB classiques. <br><br>  La simulation du comportement des lunettes de soleil ordinaires est beaucoup plus simple, elles atténuent généralement la lumière incidente d'une certaine manière: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qf/lq/8k/qflq8kkgpnh__pk8lpv5rx6txya.png"></div><br>  Ces verres ne laissent passer que 30% de la lumière.  Leur comportement peut être décrit par les équations suivantes: <br><br><blockquote> <code>R <sub>R</sub> = D <sub>R</sub> × 0.3 <br> R <sub>G</sub> = D <sub>G</sub> × 0.3 <br> R <sub>B</sub> = D <sub>B</sub> × 0.3</code> </blockquote> <br>  Les trois composantes de couleur sont réduites de la même valeur - l'absorption de la lumière incidente est la même.  On peut dire que les verres noirs sont 30% transparents (opaques) ou 70% opaques.  <em>L'opacité d'un</em> objet détermine la quantité de couleur qu'il bloque.  En infographie, nous avons généralement affaire à un modèle simplifié dans lequel une seule valeur est nécessaire pour décrire cette propriété.  L'opacité peut varier spatialement.  comme, par exemple, une colonne de fumée qui devient plus haute et plus transparente. <br><br>  Dans le monde réel, les objets avec une opacité de 100% sont simplement opaques et ne transmettent pas du tout la lumière.  Le monde des images numériques est un peu différent.  Il y a des cas limites lorsque même des objets opaques solides passent une certaine quantité de lumière. <br><br><h1>  Couverture </h1><br>  Les graphiques vectoriels traitent de descriptions claires et infiniment précises de formes définies à l'aide de points, de segments de ligne, de courbes de Bézier et d'autres primitives mathématiques.  Lorsque vous devez afficher des figures sur un écran d'ordinateur, ces entités impeccables doivent être pixellisées en un bitmap: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ebc/a01/6ed/ebca016ed191611e29f68dfca5aebe62.svg" width="492" height="202"></div><br>  <i>Rastérisation d'une forme vectorielle en bitmap</i> <br><br>  La façon la plus primitive de pixelliser est de vérifier où se trouve l'échantillon de pixels - à l'intérieur ou à l'extérieur de la forme vectorielle.  Dans les exemples ci-dessous, vous pouvez faire glisser le triangle, dans une vue agrandie, les mouvements seront plus précis.  Un contour bleu indique la géométrie vectorielle d'origine.  Comme vous pouvez le voir, l'échelle sur les bords du triangle a l'air moche et scintille beaucoup lors du déplacement de la géométrie: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mp/kn/pg/mpknpgk1lauj0ruzaobm6azr2wy.png"></div><br>  L'inconvénient de cette approche est que nous n'effectuons qu'une seule vérification pour chaque pixel affiché, et les résultats sont discrétisés à l'une des deux valeurs possibles - à l'intérieur ou à l'extérieur. <br><br>  Vous pouvez échantillonner la géométrie vectorielle plusieurs fois par pixel pour obtenir une grande gradation des étapes et décider que certains pixels ne sont que <em>partiellement</em> fermés.  Une solution possible consiste à utiliser quatre points d'échantillonnage pour représenter cinq niveaux de couverture: 0, <sup>1</sup> ⁄ <sub>4</sub> , <sup>2</sup> ⁄ <sub>4</sub> , <sup>3</sup> ⁄ <sub>4</sub> et 1: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hi/uu/pw/hiuupwrv88cjcfjxv5_f-b1hege.png"></div><br>  La qualité des bords du triangle s'est améliorée, mais seulement cinq niveaux de couverture possibles ne sont souvent pas suffisants et nous pouvons facilement obtenir un bien meilleur résultat.  Bien que la vue d'un pixel comme un petit carré dans le monde du traitement du signal soit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">considérée avec désapprobation</a> , dans certains contextes, c'est un modèle utile qui nous permet de calculer la couverture exacte en pixels par géométrie vectorielle.  L'intersection d'une ligne et d'un carré peut toujours être décomposée en un <i>trapèze</i> et un <i>rectangle</i> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/24e/b9f/494/24eb9f494ab4259257189da367efef01.svg" alt="image"></div><br>  <i>Un segment de ligne divise un carré en un trapèze et un rectangle</i> <br><br>  Vous pouvez facilement calculer l'aire des deux parties, et leur somme divisée par l'aire du carré détermine le pourcentage de couverture en pixels.  Ainsi, la couverture est calculée comme un nombre exact avec une précision arbitraire.  Dans la démonstration ci-dessous, cette méthode est utilisée pour rendre de bien meilleurs bords qui restent lisses même lorsque vous faites glisser un triangle: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xj/pd/fw/xjpdfwcvkdgujdwittnyzxan6ce.png"></div><br>  Lorsqu'il s'agit de formes plus complexes, par exemple des ellipses ou des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Béziers</a> , elles sont souvent divisées en simples segments de ligne droite qui vous permettent de calculer la couverture avec la bonne précision. <br><br>  Le concept de couverture partielle est essentiel pour un rendu de haute qualité des graphiques vectoriels et, plus important encore, pour le rendu du texte.  Si vous prenez une capture d'écran de cet article et l'examinez attentivement, vous remarquerez que presque tous les bords des glyphes ne couvrent que partiellement les pixels: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/69a/b93/1ef/69ab931ef9b9eeb4f669f29652044c0d.png" height="50%" width="50%"></div><br>  <i>La couverture partielle est activement utilisée dans le rendu de texte</i> <br><br>  Ayant l'opacité de l'objet et le couvrant avec des pixels individuels, vous pouvez les combiner en une seule valeur. <br><br><h1>  Alpha </h1><br>  Le produit de l'opacité d'un objet et de sa couverture en pixels est appelé <em>alpha</em> : <br><br><blockquote> <code> =  × </code> </blockquote> <br>  Un objet avec une opacité de 60%, couvrant 30% de la zone de pixels, a une valeur alpha de 18% dans ce pixel.  Naturellement, lorsque l'objet est transparent ou ne couvre pas complètement le pixel, la valeur alpha dans ce pixel est 0. Après multiplication, les différences entre l'opacité et le revêtement disparaissent, ce qui justifie en quelque sorte le fait que les concepts d '"alpha" et "d'opacité" sont utilisés comme synonymes. <br><br>  Alpha est souvent représenté comme un quatrième canal d'une image bitmap.  Les valeurs habituelles de rouge, vert et bleu sont complétées par une valeur alpha, formant quatre valeurs RGBA. <br><br>  Lorsqu'il s'agit de stocker des valeurs alpha en mémoire, il y a une tentation d'utiliser seulement quelques bits pour cela.  Dans le cas du recouvrement des pixels des bords d'objets opaques, il semble que 4 voire 3 bits suffiront, en fonction de la densité de pixels de l'écran: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qr/xt/pr/qrxtpr2tyhpn1znd0brdi8ehhns.png"></div><br>  Cependant, l'opacité affecte également la valeur alpha, de sorte qu'une faible profondeur de bits peut être catastrophique dans certains cas de changement de transparence en douceur.  L'image ci-dessous montre un dégradé du noir opaque au blanc, ce qui démontre qu'une faible profondeur de bits entraîne de très fortes variations de couleur: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jm/8a/bv/jm8abvbbl5mejxely1nbhefyv8u.png"></div><br>  De toute évidence, plus il y a de bits, mieux c'est, et le plus souvent pour l'alpha, une profondeur de 8 bits est utilisée pour correspondre à la précision des composantes de couleur, c'est pourquoi de nombreux tampons RGBA occupent 32 bits par pixel.  Il convient également de noter que, contrairement aux composants de couleur, qui sont souvent codés à l'aide d'une transformation non linéaire, l'alpha est stocké linéairement - la valeur codée de 0,5 correspond à une valeur alpha de 0,5. <br><br>  En parlant d'alpha, nous avons complètement ignoré toutes les autres composantes de couleur, mais en plus de bloquer la couleur d'arrière-plan, le pixel lui-même peut ajouter un peu de couleur.  L'idée est assez simple - un objet rose translucide bloque une partie de l'éclairage de fond entrant et émet ou réfléchit un peu de lumière rose: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tc/_w/kf/tc_wkf6dtsblbjvxx1nslytlu2u.gif"></div><br>  Notez qu'il ne <em>se</em> comporte <em>pas</em> comme un vitrail.  Le verre bloque simplement une partie de l'éclairage de fond avec une luminosité différente.  Si vous regardez un objet complètement noir à travers du verre rose, sa noirceur restera, car l'objet noir n'émet pas et ne réfléchit aucune lumière.  Cependant, l'objet rose translucide <em>ajoute</em> sa propre lumière.  Si vous le placez sur un objet noir, le résultat sera rosâtre.  Un bon analogue de ce comportement est un matériau fin en suspension dans l'air, comme de la brume, de la fumée, du brouillard ou de la poudre colorée. <br><br>  Le rendu d'un canal alpha est un peu plus difficile - un objet parfaitement transparent est invisible par définition, donc pour distinguer les objets, nous devons utiliser deux astuces.  Un arrière-plan en damier montre quelles parties de l'image sont transparentes;  Ce modèle est utilisé dans de nombreuses applications graphiques: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b4/ff5/064/6b4ff5064b6cd9262e4d381125b406c4.svg" width="280" height="144"></div><br>  <i>Le motif d'échecs montre des pièces transparentes.</i> <br><br>  Les quatre petits carrés sous l'image nous indiquent que nous voyons les composantes rouge, verte, bleue et alpha de l'image.  Dans certains cas, il est utile de voir directement les valeurs du canal alpha, et la façon la plus simple de les afficher consiste à utiliser des nuances de gris: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c9a/c12/c33/c9ac12c335263552b56dda8f3bd35262.svg" width="280" height="306"></div><br>  <i>Afficher les valeurs RVB et A sur différentes surfaces</i> <br><br>  Plus la nuance de gris est brillante, plus la valeur alpha est élevée, c'est-à-dire que le noir pur correspond à 0% alpha et le blanc pur à 100% alpha.  Les petits carrés indiquent que les composants RVB et A de l'image sont divisés en deux parties. <br><br>  Le composant alpha lui-même n'est pas particulièrement utile, mais il devient très important lorsque nous parlons de compositing. <br><br><h1>  Compositing simple </h1><br>  Très peu d'effets de rendu 2D peuvent être implémentés en une seule opération, et pour créer un résultat final, nous utilisons un processus de <em>composition</em> qui combine différentes images.  Par exemple, un simple bouton «Annuler» peut être créé en composant cinq éléments distincts: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cd5/2d1/80f/cd52d180f6aba101c8fd2bf95bd721fe.svg" width="318" height="328"></div><br>  <i>Éléments de composition pour le bouton Annuler</i> <br><br>  Le compositing est souvent réalisé en plusieurs étapes, à chacune desquelles deux images sont combinées.  L'image de premier plan utilisée en compositing est communément appelée <em>source</em> .  L'image d'arrière-plan utilisée en compositing, sur laquelle la source est superposée, est généralement appelée <em>destination</em> . <br><br>  Nous commencerons par composer sur un fond opaque, car c'est un cas très courant.  Tout ce que vous voyez à l'écran est finalement superposé par la composition sur une destination opaque. <br><br>  Lorsque la valeur alpha de la source est de 100%, la source est opaque et doit couvrir complètement la destination.  Si la valeur alpha est de 0%, la source est complètement transparente et n'affecte en aucune façon la destination.  Une valeur alpha de 25% permet à l'objet d'émettre 25% de sa lumière et passe 75% de la lumière de l'arrière-plan, etc.: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/985/719/921/985719921b6dc06496caba46db08a5c5.svg" width="520" height="248"></div><br>  <i>Composition d'une source violette avec différentes valeurs alpha vers une destination jaune</i> <br><br>  Vous pouvez déjà comprendre ce que tout va faire - un cas simple de composition alpha sur un fond opaque - c'est juste une interpolation linéaire entre les couleurs de destination et source.  Dans le graphique ci-dessous, le curseur contrôle la valeur alpha de la source et les graphiques rouge, vert et bleu affichent les valeurs des composants RVB.  Le résultat de <strong>R</strong> est juste un mélange entre la source <strong>S</strong> et la destination <strong>D</strong> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fd/bw/7x/fdbw7xdswtd_k6crz13wprtqbtm.gif"></div><br>  Ce qui se passe ici peut être décrit par les équations ci-dessous.  Comme précédemment, l'index dénote le composant, c'est-à-dire que S <sub>A</sub> est la valeur alpha dans la source et D <sub>G</sub> est la valeur verte dans la destination: <br><br><blockquote> <code>R <sub>R</sub> = S <sub>R</sub> × S <sub>A</sub> + D <sub>R</sub> × (1 − S <sub>A</sub> ) <br> <br> R <sub>G</sub> = S <sub>G</sub> × S <sub>A</sub> + D <sub>G</sub> × (1 − S <sub>A</sub> ) <br> <br> R <sub>B</sub> = S <sub>B</sub> × S <sub>A</sub> + D <sub>B</sub> × (1 − S <sub>A</sub> )</code> </blockquote> <br>  Les équations des composants rouge, vert et bleu ont la même apparence, vous pouvez donc simplement utiliser l'index <sub>RVB</sub> et les combiner en une seule ligne: <br><br><blockquote> <code>R <sub>RGB</sub> = S <sub>RGB</sub> × S <sub>A</sub> + D <sub>RGB</sub> × (1 − S <sub>A</sub> )</code> </blockquote> <br>  De plus, comme la destination est opaque et bloque déjà toute la lumière de fond, nous savons que la valeur alpha du résultat est toujours 1: <br><br><blockquote> <code>R <sub>A</sub> = 1</code> </blockquote> <br>  Compositer sur un fond opaque est simple, mais ses capacités sont assez limitées.  Dans de nombreux cas, une solution plus fiable est requise. <br><br><h1>  Tampons intermédiaires </h1><br>  L'image ci-dessous montre le processus en deux étapes de composition de trois couches différentes, étiquetées A, B et C. Le symbole ⇨ signifie "superposé par composition sur": <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a9/fb8/ca5/6a9fb8ca58b71a7327785e10b54ef8da.svg" width="620" height="310"></div><br>  <i>Le résultat du compositing en deux étapes de trois couches</i> <br><br>  D'abord, nous superposons B à C en composant, puis superposons A à eux pour obtenir l'image finale.  Dans l'exemple suivant, nous ferons les choses un peu différemment.  Tout d'abord, nous allons connecter les deux couches supérieures par compositing, puis superposer le résultat sur la dernière destination: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a99/a10/e40/a99a10e409562f903fa7e66b4a363706.svg" width="620" height="310"></div><br>  <i>Le résultat du compositing en deux étapes de trois couches dans un ordre différent</i> <br><br>  Vous vous demandez probablement si une telle situation se présente dans la pratique, mais en fait, elle est très courante.  De nombreuses opérations de composition et effets de rendu non triviaux, tels que le masquage et le flou, nécessitent de passer par un tampon intermédiaire contenant uniquement des résultats de composition partiels.  Ce concept a des noms différents: passes hors écran, couches de transparence ou tampons latéraux, mais ils sont généralement basés sur la même idée. <br><br>  Ce qui est plus important pour nous, c'est que presque <em>toutes les</em> images transparentes peuvent être perçues comme le résultat partiel d'un certain rendu, qui sera ensuite superposé par la composition sur la dernière destination: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/862/2cc/804/8622cc804d280c508244ccfc60c0e461.svg" width="128" height="48"></div><br>  <i>Compositing partiel d'un bouton dans un presse-papiers</i> <br><br>  Nous devons comprendre comment remplacer la composition d'images translucides A et B par une image (A⇨B) ayant la même couleur et l'opacité.  Commençons par calculer la valeur alpha du tampon final. <br><br><h1>  Combinaison de valeurs alpha </h1><br>  Vous ne savez peut-être pas comment combiner l'opacité de deux objets, mais il est plus facile de parler de cette tâche si nous parlons plutôt de transparence. <br><br>  Supposons qu'une certaine quantité de lumière passe à travers le premier objet, puis à travers le deuxième objet.  Si la transparence du premier objet est de 80%, il passera alors 80% de la lumière incidente.  De même, un deuxième objet avec 60% de transparence permettra à 60% de la lumière de le traverser, ce qui nous donne 60% × 80% = 48% de la lumière d'origine.  Vous pouvez expérimenter la transparence dans l'article d'origine;  n'oubliez pas que les curseurs contrôlent la <em>transparence</em> et non l'opacité des objets sur le chemin de la lumière: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/av/f5/lv/avf5lvv7kve1zkgnztkd_i_hylq.png"></div><br>  Naturellement, lorsque le premier ou le deuxième objet est opaque, aucune lumière ne les traverse, même un autre est complètement transparent. <br><br>  Si l'objet D a la transparence D <sub>T</sub> , et l'objet S a la transparence S <sub>T</sub> , alors la transparence générale finale R <sub>T de</sub> ces deux objets est égale à leur produit: <br><br><blockquote>  R <sub>T</sub> = D <sub>T</sub> × S <sub>T</sub> </blockquote><br>  Cependant, la transparence est juste une unité moins alpha, donc la substitution nous donne ce qui suit: <br><br><blockquote>  1 - R <sub>A</sub> = (1 - D <sub>A</sub> ) × (1 - S <sub>A</sub> ) </blockquote><br>  Cette expression peut être développée en: <br><br><blockquote>  1 - R <sub>A</sub> = 1 - D <sub>A</sub> - S <sub>A</sub> + D <sub>A</sub> × S <sub>A</sub> </blockquote><br>  Et simplifiez comme ceci: <br><br><blockquote>  R <sub>A</sub> = D <sub>A</sub> + S <sub>A</sub> - D <sub>A</sub> × S <sub>A</sub> </blockquote><br>  Il peut être réduit à l'un des deux types similaires: <br><br><blockquote>  R <sub>A</sub> = S <sub>A</sub> + D <sub>A</sub> × (1 - S <sub>A</sub> ) <br><br>  R <sub>A</sub> = D <sub>A</sub> + S <sub>A</sub> × (1 - D <sub>A</sub> ) </blockquote><br>  Bientôt, nous verrons que le second est le plus souvent utilisé.  Il est également intéressant de noter que la valeur alpha résultante ne dépend pas de l'ordre relatif des objets - l'opacité des pixels résultants est la même, même si vous échangez la source et la destination.  C'est très logique.  La lumière traversant deux objets devrait s'estomper de la même manière, de n'importe quel côté de l'étoile, de l'avant ou de l'arrière. <br><br><h1>  Combinaison de couleurs </h1><br>  Le calcul de l'alpha n'a pas été si difficile, alors essayons de comprendre les calculs des composants RVB.  L'image source a la couleur S <sub>RGB</sub> , mais son opacité S <sub>A</sub> force uniquement le produit de ces deux valeurs à prendre en compte dans le résultat final: <br><br><blockquote>  S <sub>RVB</sub> × S <sub>A</sub> </blockquote><br>  L'image de destination a la couleur D <sub>RGB</sub> , l'opacité lui fait émettre de la lumière D <sub>RGB</sub> × D <sub>A</sub> , cependant, une partie de la lumière est bloquée par l'opacité de l'image S, donc tout l'effet de destination est <br><br><blockquote>  D <sub>RVB</sub> × D <sub>A</sub> × (1 - S <sub>A</sub> ) </blockquote><br>  L'apport total de lumière de S et D est égal à leur somme: <br><br><blockquote>  S <sub>RVB</sub> × S <sub>A</sub> + D <sub>RVB</sub> × D <sub>A</sub> × (1 - S <sub>A</sub> ) </blockquote><br>  De même, la contribution des couches fusionnées est égale à leur couleur multipliée par leur opacité: <br><br><blockquote>  R <sub>RVB</sub> × R <sub>A</sub> </blockquote><br>  Nous voulons que ces deux valeurs correspondent: <br><br><blockquote>  R <sub>RGB</sub> × R <sub>A</sub> = S <sub>RGB</sub> × S <sub>A</sub> + D <sub>RGB</sub> × D <sub>A</sub> × (1 - S <sub>A</sub> ) </blockquote><br>  Ce qui nous donne les équations finales: <br><br><blockquote>  R <sub>A</sub> = S <sub>A</sub> + D <sub>A</sub> × (1 - S <sub>A</sub> ) <br><br>  R <sub>RGB</sub> = (S <sub>RGB</sub> × S <sub>A</sub> + D <sub>RGB</sub> × D <sub>A</sub> × (1 - S <sub>A</sub> )) / R <sub>A</sub> </blockquote><br>  Voyez comme la deuxième équation est compliquée!  Notez que pour obtenir les valeurs RVB du résultat, nous devons diviser par la valeur alpha.  Cependant, pour la prochaine étape de la compositine, la multiplication par la valeur alpha sera à nouveau nécessaire, car le résultat de l'opération en cours deviendra la nouvelle source ou destination de la prochaine opération.  C'est tout simplement moche. <br><br>  Revenons à la forme presque finale de R <sub>RGB</sub> pendant une seconde: <br><br><blockquote>  R <sub>RGB</sub> × R <sub>A</sub> = S <sub>RGB</sub> × S <sub>A</sub> + D <sub>RGB</sub> × D <sub>A</sub> × (1 - S <sub>A</sub> ) </blockquote><br>  La source, la destination <em>et le</em> résultat sont multipliés par leurs composants alpha.  Cela nous fait comprendre que la couleur et l'alpha du pixel «aiment» être ensemble, nous devons donc prendre du recul et repenser la façon dont nous stockons les informations sur les couleurs. <br><br><h1>  Alpha prémultiplié </h1><br>  Rappelons que nous avons parlé d'opacité - si l'objet est partiellement opaque, sa contribution au résultat sera également partielle.  Le concept d'alpha prémultiplié («pré-multiplication par alpha») met en œuvre cette idée.  Les valeurs des composants RVB, comme leur nom l'indique, sont pré-multipliées par le composant alpha.  Commençons par la couleur sans multiplication préalable: <br><br><blockquote>  (1,00, 0,80, 0,30, 0,40) </blockquote><br>  La multiplication préliminaire par alpha nous donne ce qui suit: <br><br><blockquote>  (0,40, 0,32, 0,12, 0,40) </blockquote><br>  Jetons un coup d'œil à plusieurs pixels à la fois.  La figure ci-dessous montre comment les informations de couleur sont stockées sans multiplier d'abord l'alpha: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e20/ba7/338/e20ba7338feb27cdf22f3c25d3afa697.svg" width="440" height="262"></div><br>  <i>Informations RVB et A dans l'image sans multiplication préalable</i> <br><br>  Notez que les zones où alpha est 0 peuvent avoir des valeurs RVB arbitraires, comme le montrent les pépins vert et bleu de l'image.  Dans le cas d'une multiplication préliminaire par alpha, les informations de couleur stockent également les valeurs d'opacité des pixels: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/613/5d9/ede/6135d9ede6ea6789bbcd979e48a2cce0.svg" width="440" height="262"></div><br>  <i>Informations RVB et A dans une image pré-multipliée</i> <br><br>  L'alpha prémultiplié est parfois appelé alpha associé, et l'alpha non prémultiplié est parfois appelé alpha droit ou non associé. <br><br>  Lorsque le composant alpha de la couleur est 0, la multiplication préliminaire réinitialise tous les autres composants, quelles que soient leurs valeurs: <br><br><blockquote>  (0,0, 0,0, 0,0, 0,0) </blockquote><br>  Dans le cas de l'alpha prémultiplié, il n'y a qu'une <em>seule</em> couleur complètement transparente, et c'est charmant. <br><br>  Les avantages de ce traitement des composants de couleur deviendront progressivement clairs pour vous, mais avant de revenir à l'exemple de la composition, voyons comment l'alpha prémultiplié aide à résoudre certains autres problèmes de rendu. <br><br><h2>  Filtrage </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le flou gaussien</a> est un moyen populaire de créer un arrière-plan défocalisé intéressant ou de réduire la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fréquence élevée de l'</a> arrière <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">-</a> plan du contenu de certains éléments de l'interface utilisateur.  Comme nous le verrons, la pré-multiplication de l'alpha est essentielle pour créer le flou parfait. <br><br>  L'image que nous analyserons est créée en remplissant l'arrière-plan avec 1% de bleu opaque, sur lequel un cercle rouge opaque est dessiné.  Voyons d'abord un exemple sans multiplication préalable.  J'ai séparé les canaux RVB du canal alpha pour comprendre ce qui se passait.  La flèche indique l'opération de flou: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ce/0eb/7f9/1ce0eb7f9342c4d90ca7c18bb827afba.png" width="530" height="264"></div><br>  <i>Flou du contenu sans multiplication préalable</i> <br><br>  Le résultat final a un laid halo bleu.  Cela s'est produit parce que le fond bleu s'est infiltré dans la zone rouge pendant le flou, et seulement <em>ensuite</em> , pendant le compositing, le poids alpha y a été ajouté. <br><br>  Lorsque les couleurs sont pré-multipliées par alpha, le résultat est correct: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c6/9f8/aa9/2c69f8aa9cba7a689eb2094d89661576.png" width="530" height="264"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flou du contenu pré-multiplié</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En raison de la pré-multiplication, la couleur bleue de l'image est réduite à 1% de sa force d'origine, de sorte que son effet sur les couleurs du cercle flou est extrêmement faible.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Interpolation </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le rendu d'une image dont les pixels correspondent parfaitement à la destination est une tâche simple car nous devons effectuer un mappage univoque trivial entre les échantillons. </font><font style="vertical-align: inherit;">Un problème survient lorsqu'il n'y a pas de mappage simple, par exemple, en raison de la rotation, de la mise à l'échelle ou de la césure. </font><font style="vertical-align: inherit;">La figure ci-dessous montre que les pixels de l'image pivotée indiqués par le contour rouge ne correspondent plus à la destination:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7c/55c/d9d/a7c55cd9d320d2fc5b8b4dd80622b54c.svg" width="596" height="290"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Orientation relative de l'image et pixels de destination avant et après rotation</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Il existe de nombreuses façons de sélectionner une couleur de l'image à écrire sur le pixel de destination, et la plus simple d'entre elles est l'interpolation dite du plus proche voisin, dans laquelle comme pixel final, l'échantillon le plus proche dans la texture est simplement sélectionné. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans la démonstration ci-dessous, le contour rouge montre la position de l'image dans la destination. Le côté droit montre les positions des échantillons du point de vue de l' </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">image</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . En faisant glisser le curseur (dans l'article d'origine), vous pouvez faire pivoter le quadrilatère et observer comment les échantillons sélectionnent les couleurs du bitmap. J'ai mis en évidence un pixel dans la source et la destination, afin que leur relation soit plus claire:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zd/0v/if/zd0vifjvna1jjf_apdomph8bmd0.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette solution est assez fonctionnelle et les pixels ont une couleur holistique, mais la qualité est inacceptable. Il serait préférable d'utiliser une </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interpolation bilinéaire</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui calcule la moyenne pondérée des quatre pixels les plus proches de l'image échantillonnée:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/s0/fy/qi/s0fyqirq3p9cpyfb5vl4gxzsz0q.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela fonctionne mieux, mais les bords autour des rectangles ne semblent pas corrects, le contenu des pixels fusionne sans multiplication, car l'alpha est "appliqué" après l'interpolation. Parfois, la solution recommandée pour fusionner la couleur du bon contenu, qui est montrée dans l' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article étonnant d'</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adrian Correger [ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">traduction</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sur Habré], est loin d'être idéale - pas une seule couleur dans l'espace entre les rectangles rouges et bleus ne semblera droite. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voyons à quoi tout ressemblera dans l’image avec de l’alpha prémultiplié et du compositing avec une formule avancée, que nous allons bientôt dériver:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/to/ax/zy/toaxzyjkgdouyossh7kzgkgudyi.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout simplement parfait - nous nous sommes débarrassés de toutes les fusions de couleurs et les </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dents sont</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> introuvables </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En fin de compte, les problèmes associés au flou et à l'interpolation sont étroitement liés. </font><font style="vertical-align: inherit;">Toute opération qui nécessite une combinaison de couleurs translucides, sans d'abord multiplier les couleurs par alpha, est susceptible de donner des résultats incorrects.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le bon compositing </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Revenons au compositing. </font><font style="vertical-align: inherit;">Nous nous sommes installés sur une équation presque dérivée:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> × R </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> × S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> × D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> × (1 - S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous imaginez des couleurs utilisant l'alpha prémultiplié, toutes ces multiplications inconfortables disparaîtront, car l'alpha fera déjà partie des valeurs de couleur. </font><font style="vertical-align: inherit;">Ensuite, nous obtenons ce qui suit:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> × (1 - S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Regardons l'équation alpha: </font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> × (1 - S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les coefficients pour les canaux rouge, vert, bleu et alpha sont les mêmes, nous pouvons donc exprimer l'expression entière avec une équation et nous rappeler juste que chaque composant subit la même opération: </font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S + D × (1 - S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Découvrez comment l'alpha prémultiplié a facilité les choses. </font><font style="vertical-align: inherit;">Lorsque nous analysons les composants de l'équation, ils sont tous en place. </font><font style="vertical-align: inherit;">L'opération </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">masque une</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> partie de la lumière d'arrière-plan et ajoute une nouvelle lumière:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S + D × (1 - S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette opération de mixage est appelée source over, sover ou tout simplement normale, et c'est sans aucun doute le mode de composition le plus courant. </font><font style="vertical-align: inherit;">Presque tout ce que vous voyez sur mon site Web est mélangé dans ce mode.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Associativité </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une propriété source-over importante réalisée sur des couleurs pré-alpha-multipliées est l' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">associativité de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cette opération. </font><font style="vertical-align: inherit;">Grâce à lui, dans l'équation de mélange complexe, nous pouvons placer les parenthèses de manière complètement arbitraire. </font><font style="vertical-align: inherit;">Toutes les compositions présentées ci-dessous sont équivalentes:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = (((A⇨B) ⇨C) ⇨D) ⇨E </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = (A⇨B) ⇨ (C⇨ (D⇨E)) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = A⇨ (B⇨ (C⇨ (D⇨E)) )</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La preuve en est assez simple, mais je ne vous encombrerai pas de manipulations algébriques. </font><font style="vertical-align: inherit;">Dans la pratique, cela signifie que nous pouvons rendre partiellement des dessins complexes sans craindre que la composition finale soit incorrecte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans la grande majorité des cas, l'alpha n'est utilisé que pour la composition en utilisant la source-over, mais ses avantages ne s'arrêtent pas là. </font><font style="vertical-align: inherit;">Les valeurs alpha peuvent également être utilisées pour d'autres opérations de rendu utiles.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Porter-Duff Compositing </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En juillet 1984, Thomas Porter et Tom Duff ont publié l'article original, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«Compositing Digital Images»</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Les auteurs ont non seulement introduit le concept d'alpha prémultiplié et dérivé de l'équation de composition source sur over, mais ont également présenté toute une famille d'opérations de composition alpha, dont beaucoup sont peu connues, bien que très utiles. </font><font style="vertical-align: inherit;">Les nouvelles fonctions sont également appelées </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">opérateurs</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , car, comme l'ajout ou la multiplication, elles effectuent des actions sur les valeurs d'entrée pour créer une valeur de sortie.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Plus </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans de futurs exemples, nous utiliserons des démos interactives montrant les opérations de divers modes de fusion. </font><font style="vertical-align: inherit;">L'image de destination sera le symbole «club» noir et l'image source sera le symbole «vers» rouge. </font><font style="vertical-align: inherit;">Vous pouvez faire glisser le cœur sur l'image et observer le comportement des formes qui se chevauchent sous différents opérateurs de composition. </font><font style="vertical-align: inherit;">Faites attention à la petite minicarte dans le coin. </font><font style="vertical-align: inherit;">Certains modes de fusion sont très destructeurs et faciles à confondre. </font><font style="vertical-align: inherit;">La mini-carte montre toujours le résultat d'un simple compositing source-over, ce qui simplifie la compréhension:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vx/nb/n3/vxnbn3qhwfuiobes7rws0ardxtq.gif"></div><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S + D × (1 - S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></blockquote><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S × (1 - D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) + D</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous passez à destination-over, vous vous rendrez immédiatement compte qu'il «retourne» simplement la source-over - destination et source sont échangées dans l'équation et le résultat est équivalent à ce que nous considérerons comme destination comme image source. </font><font style="vertical-align: inherit;">Bien qu'il semble redondant, l'opérateur destination-over est extrêmement utile car il vous permet de composer des objets qui se trouvent </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sous</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> un contenu existant.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Out </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les instructions source-out et destination-out sont idéales pour percer des trous dans la source ou la destination: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/c1/pn/ou/c1pnoudiz66kdmddiaqkmdxcyuq.gif"></div><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S × (1 - D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></blockquote><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = D × (1 - S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parmi ces deux opérateurs, Destination-out est plus pratique car il utilise le canal alpha pour percer des trous dans le formulaire de destination. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dans </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les opérateurs source-in et destination-in sont essentiellement des opérateurs de masquage: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fx/je/jc/fxjejc-my5ewd7otz8_r2ylueas.gif"></div><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S × D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub> </blockquote><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = D × S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub> </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ils permettent de créer assez facilement des intersections complexes de géométrie non triviale sans résoudre les intersections relativement difficiles à calculer des contours vectoriels. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Au sommet </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les opérateurs </font></font><code>source-atop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>destination-atop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vous permettent de superposer du nouveau contenu sur ceux existants, tout en le masquant le long du chemin de destination:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/js/f-/2o/jsf-2on9uxoowdzpk73ugiadypw.gif"></div><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S × D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + D × (1 - S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></blockquote><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S × (1 - D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) + D × S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub> </blockquote><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Xor </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'opérateur OU exclusif ( </font></font><code>xor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) enregistre </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> source ou la destination, et leurs zones correspondantes disparaissent:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bm/i6/uo/bmi6uoidqbrytp4e4gbmy6afvck.png"></div><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S × (1 - D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) + D × (1 - S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></blockquote><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Source, destination, effacer </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les trois derniers modes de composition classiques sont assez ennuyeux. </font></font><code>Source</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, également appelé </font></font><code>copy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, prend simplement la source de couleur. </font><font style="vertical-align: inherit;">De même, il </font></font><code>destination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ignore la source de couleur et revient simplement </font></font><code>destination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">L'opérateur </font></font><code>clear</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">efface simplement tout:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fw/li/mo/fwlimouoegmu9ff1r1tqno-uags.gif"></div><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R = S </font></font></blockquote><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R = D </font></font></blockquote><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R = 0 </font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'applicabilité de ces modes est limitée. </font><font style="vertical-align: inherit;">En l'utilisant </font></font><code>clear</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, vous pouvez vider un tampon rempli, mais cette opération peut être optimisée en remplissant simplement la mémoire avec des zéros. </font><font style="vertical-align: inherit;">De plus, dans certains cas, il </font></font><code>source</code> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peut être</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> plus économique dans les calculs, car il ne nécessite aucun mélange, mais remplace simplement le contenu du tampon par les informations source.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Porter Duff en action </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Après avoir traité avec des opérateurs individuels, voyons comment vous pouvez les combiner. </font><font style="vertical-align: inherit;">Dans l'exemple ci-dessous, nous allons dessiner un logo marin sans utiliser de masquage ou de formes géométriques complexes. </font><font style="vertical-align: inherit;">Les contours bleus montrent la géométrie simple en cours de création. </font><font style="vertical-align: inherit;">Vous pouvez parcourir les étapes en cliquant sur le côté droit de l'image, et revenir en arrière en cliquant sur la gauche:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qf/-l/ct/qf-lctetuaygx6y7nwxhl95breu.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bien sûr, nous ne sommes en aucun cas obligés d'abandonner les masques et les contours de découpe, mais nous oublions souvent un outil comme les modes de composition Porter-Duff, bien qu'il soit beaucoup plus facile de créer des effets visuels avec leur aide. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les opérateurs </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous regardez attentivement les opérateurs Porter-Duff, vous remarquerez qu'ils ont tous le même formulaire. </font><font style="vertical-align: inherit;">La source est toujours multipliée par un certain coefficient F </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et ajoutée à la destination multipliée par un coefficient F </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S × F </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + D × F </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D</font></font></sub> </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> peut prendre les valeurs 0, 1, D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1 - D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , F et </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> peuvent être égales à 0, 1, S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou 1 - S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Cela n'a aucun sens de multiplier la source ou la destination par leur propre alpha, car ils sont déjà pré-multipliés, et nous obtenons juste l'effet fantaisiste, mais pas très utile, de l'alpha quadratique. </font><font style="vertical-align: inherit;">Tous les opérateurs peuvent être représentés sous la forme d'un tableau:</font></font><br><br><div class="scrollable-table"><table><tbody><tr><td></td><td>  0 </td><td>  1 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 - D </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub> </td></tr><tr><td>  0 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> clair </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> source </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> source-in </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> source-out </font></font></td></tr><tr><td>  1 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> destination </font></font></td><td></td><td></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> destination </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> destination </font></font></td><td></td><td></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> destination au sommet </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 - S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> destination-out </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> source-over </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> source-au sommet </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> xor </font></font></td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Faites attention à la symétrie des opérateurs sur la diagonale. </font><font style="vertical-align: inherit;">Les quatre éléments centraux du tableau sont manquants et c'est arrivé parce qu'ils sont différents des autres.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Éclairage additif </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans son article, Porter et Duff a </font><font style="vertical-align: inherit;">présenté un autre opérateur, dans lequel les </font><font style="vertical-align: inherit;">deux F </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et F </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> égal à 1. Il est connu sous le nom </font></font><code>plus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>lighter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>plus-lighter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R = S + D </font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette opération </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ajoute</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> essentiellement </font><em><font style="vertical-align: inherit;">un</font></em><font style="vertical-align: inherit;"> éclairage source à la destination:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a2f/a9b/31c/a2fa9b31c91913bc0445b91ea8217670.png" width="488" height="226"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'éclairage additif mis en œuvre avec l'opérateur</font></font><code><em>plus</em></code></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vert et rouge forme correctement le jaune, tandis que le vert et le bleu forment le cyan. </font><font style="vertical-align: inherit;">Le noir est l'absence d'opération; il ne change en rien les valeurs de couleur, car l'ajout de zéro à un nombre ne change rien. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les trois opérateurs restants n'ont pas reçu de nom car ils ne sont pas particulièrement utiles. </font><font style="vertical-align: inherit;">Ils sont juste une combinaison de masquage et de mélange. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il convient également de noter que l'alpha prémultiplié nous permet d'utiliser l'opérateur de </font></font><code>source-over</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">manière inattendue. </font><font style="vertical-align: inherit;">Jetons à nouveau un coup d'oeil à l'équation:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = S + D × (1 - S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si nous parvenons à rendre la valeur alpha de la source égale à zéro, alors s'il y a des valeurs non nulles dans les canaux RVB, nous pouvons obtenir un éclairage additif sans utiliser l'opérateur </font></font><code>plus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/400/42b/fbf/40042bfbf25d98ec04a5609fcf828f39.png" width="488" height="290"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Éclairage additif implémenté à l'aide de l'opérateur</font></font><code><em>source-over</em></code></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Notez que vous devez faire attention ici - les valeurs ne sont plus correctement multipliées par alpha. Dans certains programmes, il peut y avoir une optimisation qui évite complètement de mélanger les couleurs avec zéro alpha, tandis que d'autres programmes peuvent inverser la pré-multiplication par des valeurs alpha, effectuer certaines opérations de couleur, puis pré-multiplier à nouveau par alpha, ce qui détruit complètement les canaux de couleur. Il peut également être difficile d'exporter des ressources dans ce format, donc si vous n'avez pas un contrôle total sur le pipeline de rendu, vous devez vous en tenir à l'opérateur </font></font><code>plus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jusqu'à présent, tous les éléments dont nous discutons ont été bien combinés. </font><font style="vertical-align: inherit;">Maintenant, retirons nos lunettes roses et discutons de certaines questions qui doivent être prises en compte lors de l'utilisation de la composition alpha.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Opacité du groupe </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetons un coup d'œil à ce dessin de pilule simple composé de seulement six primitives: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e7/b44/c84/6e7b44c84ff94dfbe3e0f2943cd44b89.png" width="512" height="208"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dessiner une pilule à l'aide de formes simples</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si on nous demandait de rendre une pilule avec une opacité de 50%, nous pourrions être tentés de simplement diviser l'opacité en deux à chaque opération de dessin, mais cela se révélerait être une décision erronée:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/13a/63a/26b/13a63a26b176861264010a8d43aefb7a.png" width="160" height="96"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Résultat inattendu du rendu d'une pilule avec une demi-opacité.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour obtenir le résultat correct, nous ne pouvons pas simplement répartir l'opacité d'un objet sur chacun de ses composants individuels. </font><font style="vertical-align: inherit;">Il faut d' </font><font style="vertical-align: inherit;">abord créer un objet pour le </font><font style="vertical-align: inherit;">rendre dans un bitmap, et seulement </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ensuite</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> modifier l'opacité du bitmap, et à la fin de compositing effectuer:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/798/7d0/708/7987d07084e48d8b3a51e99111c8a3ae.png" width="512" height="96"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Résultat attendu du rendu d'une pilule avec une demi-opacité</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Il s'agit d'un autre cas qui démontre l'utilité du concept de rendu dans un tampon latéral.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Couverture de compositing </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La conversion d'une couverture géométrique en une seule valeur alpha a des conséquences inconfortables. </font><font style="vertical-align: inherit;">Considérons le cas où deux bords parfaitement adaptés de figures de géométrie vectorielle, illustrés dans la figure ci-dessous avec des contours orange et bleu, sont rendus dans une image bitmap. </font><font style="vertical-align: inherit;">Dans un monde idéal, les résultats devraient ressembler à ceci, car chaque pixel est complètement fermé:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45d/728/ca1/45d728ca1d4b35c64a2a3b1499930353.svg" width="555" height="255"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un résultat de rendu idéal avec une couverture correcte.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cependant, si nous rendons d'abord la géométrie orange puis le bleu, puis dans l'image finale un petit fond blanc fuira toujours dans les pixels de la bordure:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2f/cdd/66f/f2fcdd66f6b53504a36c5db42c17bfc5.svg" width="555" height="255"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le résultat d'un compositing en deux étapes</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dès que le revêtement est stocké dans le canal alpha, toutes ses informations géométriques sont perdues, et nous ne pouvons en aucun cas les restaurer. La géométrie bleue se mélange simplement avec une </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">partie du</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> contenu du tampon, mais ne sait pas que la géométrie représentée par les pixels rougeâtres doit y correspondre. Ce problème est particulièrement visible lorsque les géométries sont précisément superposées les unes aux autres. Dans l'image ci-dessous, un cercle blanc est dessiné au-dessus d'un noir. Les bords sombres sont visibles, bien que les deux cercles aient </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exactement le même</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rayon et </font><em><font style="vertical-align: inherit;">la même</font></em><font style="vertical-align: inherit;"> position:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9a8/33f/e2c/9a833fe2c9881ed7c89ece47c0984f38.svg" width="180" height="180"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un cercle blanc dessiné au-dessus d'un cercle noir</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Une façon de résoudre ce problème est de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne pas</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> calculer la couverture partielle des pixels et d'utiliser des tampons beaucoup plus grands. En pixellisant la géométrie vectorielle avec un simple revêtement d'entrée / sortie, puis en réduisant l'échelle du résultat à la taille de l'image d'origine, vous pouvez obtenir le résultat attendu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, pour une comparaison parfaite de la qualité de rendu des bords du canal alpha 8 bits, les tampons doivent être 256 fois plus grands dans les </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deux</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sens, c'est-à-dire que le nombre de pixels doit augmenter de 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fois. </font><font style="vertical-align: inherit;">Comme nous l'avons vu ci-dessus, tout en réduisant la profondeur de bits pour les valeurs de couverture, vous pouvez toujours obtenir des résultats satisfaisants, donc en pratique, vous pouvez utiliser une échelle plus petite. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il convient également de noter que de tels problèmes peuvent souvent être évités relativement facilement sans l'utilisation d'énormes bitmaps. </font><font style="vertical-align: inherit;">Par exemple, au lieu de dessiner deux cercles superposés, vous pouvez simplement dessiner deux carrés l'un sur l'autre, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puis</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> masquer le résultat pour former un cercle.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Valeurs linéaires </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous avez actualisé vos connaissances sur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">les espaces colorimétriques</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , vous vous souvenez que la plupart d'entre eux codent les valeurs chromatiques de manière non linéaire et qu'une linéarisation préliminaire est nécessaire pour effectuer les opérations mathématiques correctes. </font><font style="vertical-align: inherit;">Une fois cette étape terminée, le résultat du compositing est le suivant; </font><font style="vertical-align: inherit;">attention à la belle teinte jaunâtre des pièces superposées les unes aux autres:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb0/24f/14d/bb024f14d3ede0fe13e72eb1de4a115a.png" width="280" height="300"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cercles rouges flous superposés par compositing sur un fond vert à l'aide de valeurs linéaires</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mais dans la plupart des cas, la compositing </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne l'</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est </font><em><font style="vertical-align: inherit;">pas</font></em><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">La méthode standard pour le Web et la plupart des logiciels graphiques consiste à mélanger directement des valeurs non linéaires:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/245/77c/a2e/24577ca2e1dd42a2ef6c2ef1d33884d9.png" width="280" height="300"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cercles rouges flous superposés par un compositeur sur un fond vert en utilisant des valeurs non linéaires</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Notez que les zones où le rouge sur le vert se superposent sont beaucoup plus sombres. </font><font style="vertical-align: inherit;">Ils sont loin d'être idéaux, mais dans certains cas, des opérations incorrectes sont profondément enracinées dans la compréhension de la façon dont nous percevons la couleur. </font><font style="vertical-align: inherit;">Par exemple, le gris opaque à 50% de l'espace sRGB ressemble exactement au noir pur avec une opacité de 50% mélangée à un fond blanc:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/366/ca1/573/366ca1573d720de845ce276d7ef0d5b4.svg" width="405" height="133"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Composition de deux couleurs sur un fond blanc</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sans </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">linéarisation</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dans la figure ci-dessous, les couleurs sRGB des images source et de destination sont linéarisées puis reconverties en encodage non linéaire pour l'affichage. </font><font style="vertical-align: inherit;">Voici à quoi devraient ressembler ces couleurs:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ae/c74/90a/1aec7490a8fdf2a096f5e4c8f2b56cdc.svg" width="405" height="133"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Composition de deux couleurs sur fond blanc</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> avec </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">linéarisation</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous avons un écart qui ne correspond pas à nos attentes. </font><font style="vertical-align: inherit;">La seule façon d'obtenir l'uniformité visuelle à l'aide de cette méthode est de sélectionner toutes les couleurs à l'aide de valeurs linéaires, mais cela est très différent de ce à quoi tout le monde est habitué. </font><font style="vertical-align: inherit;">50% de gris avec des valeurs linéaires ressemble à du gris sur 73,5% de l'espace sRGB. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, vous devez être particulièrement prudent lorsque vous travaillez avec un alpha prémultiplié. </font><font style="vertical-align: inherit;">La pré-multiplication doit être effectuée avec </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> valeurs </font><em><font style="vertical-align: inherit;">linéaires</font></em><font style="vertical-align: inherit;"> , c'est-à-dire </font><font style="vertical-align: inherit;">avant de coder en non linéaire. </font><font style="vertical-align: inherit;">Pour cette raison, l'étape de linéarisation se terminera correctement avec les valeurs linéaires correctes, précédemment multipliées par alpha.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Profondeur Alpha et Bit prémultipliée </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Malgré sa grande utilité pour la composition, le filtrage et l'interpolation, l'alpha prémultiplié n'est pas une «solution miracle» et a ses inconvénients. </font><font style="vertical-align: inherit;">Le plus sérieux d'entre eux est la réduction de la profondeur de bits des couleurs imaginables. </font><font style="vertical-align: inherit;">Imaginez un encodage 8 bits d'une valeur de 150, qui est pré-multiplié par alpha 20%. </font><font style="vertical-align: inherit;">Après une multiplication préliminaire par alpha, on obtient</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rond (150 × 0,2) = 30 </font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si nous répétons la même procédure avec une valeur de 151, nous obtenons: </font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rond (151 × 0,2) = 30 </font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La valeur codée sera la même, malgré la différence des valeurs initiales. </font><font style="vertical-align: inherit;">En fait, après multiplication par alpha, les valeurs de 148, 149, 150, 151 et 152 sont codées en 30, et la différence d'origine entre ces cinq couleurs uniques est perdue:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af3/a80/76c/af3a8076caef4fdae6146e6d503ea639.svg" width="560" height="203"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La pré-multiplication par alpha de 20% réduit les différentes valeurs de 8 bits à</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1. Naturellement, plus l'alpha est petit, plus son effet est destructeur. Sur la plage possible de 256 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (environ 4,3 milliards) de diverses combinaisons de valeurs RGBA 8 bits, après multiplication préliminaire par alpha, seulement 25,2% conservent une représentation unique; en fait, nous perdons près de 2 bits de la plage 32 bits.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour convertir les couleurs entre différents espaces colorimétriques, il est parfois nécessaire d'inverser la multiplication préliminaire, c'est-à-dire de diviser les valeurs dans le composant alpha pour obtenir la luminosité des couleurs d'origine. Cette étape est nécessaire car, comme mentionné ci-dessus, le codage est effectué de manière non linéaire. L'existence d'une pré-multiplication réduit la précision de la représentation des couleurs et les conversions entre les espaces colorimétriques peuvent être imparfaites. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En pratique, la réduction de la profondeur de bits est rarement importante, en particulier dans la composition. Plus la valeur alpha est faible, moins la couleur est visible et moins elle a d'influence sur la composition. En fin de compte, si vous vous efforcez de réaliser des opérations chromatiques précises, vous n'utiliserez pas leur représentation 8 bits - à cette fin, les formats sont beaucoup mieux adaptés</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">virgule flottante</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lecture complémentaire </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le concept du canal alpha a été créé par les co-fondateurs du studio Pixar </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">Elvy </font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Smith</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ed Catmell</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . L'article de Smith </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«Alpha et l'histoire de la composition numérique»</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> décrit l'histoire de l'invention et les sources du nom «alpha», ainsi que la façon dont ces concepts ont évolué et ont progressivement remplacé le concept de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">masques</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans la production cinématographique </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour comprendre le sens de l'alpha, je vous recommande fortement de lire </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«Interpreting Alpha» d'</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Andrew Glassner </font><font style="vertical-align: inherit;">. Cet article fournit une dérivation mathématique rigoureuse mais très accessible de l'alpha comme mesure de l'interaction entre l'opacité et la couverture. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une discussion détaillée de l'alpha prémultiplié peut être explorée dans</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«Les GPU préfèrent la prémultiplication» par</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eric Haines. </font><font style="vertical-align: inherit;">L'article fournit non seulement un excellent aperçu des problèmes causés par le </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">manque de</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> multiplication préliminaire, en particulier dans le rendu 3D, mais fournit également des liens vers de nombreux autres articles sur ce sujet.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En conclusion </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initialement, cet article était destiné à expliquer les opérateurs de composition de Porter-Duff, mais tous les autres concepts liés à la composition alpha se sont avérés si intéressants que je ne pouvais pas les manquer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce que j'aime le plus à propos de l'alpha, c'est que c'est juste un nombre supplémentaire qui accompagne les composants RVB, mais en même temps, il crée de nombreuses capacités de rendu uniques. </font><font style="vertical-align: inherit;">Alpha a littéralement créé un nouveau changement d'opportunité dans l'ancien monde ennuyeux de la composition et du rendu 2D. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La prochaine fois que vous verrez les bords lisses des formes vectorielles ou remarquerez une superposition sombre qui assombrit certaines parties de l'interface utilisateur, pensez à un composant petit mais puissant qui a rendu tout cela possible.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr468067/">https://habr.com/ru/post/fr468067/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr468053/index.html">Apprentissage automatique pour votre chasse à plat. Partie 1</a></li>
<li><a href="../fr468057/index.html">Développement de système d'exploitation de type Unix - Multitâche et appels système (7)</a></li>
<li><a href="../fr468059/index.html">Ma deuxième semaine avec Haiku: beaucoup de diamants cachés et d'agréables surprises, ainsi que quelques problèmes</a></li>
<li><a href="../fr468061/index.html">Cron sur Linux: historique, utilisation et appareil</a></li>
<li><a href="../fr468063/index.html">Angulareact</a></li>
<li><a href="../fr468071/index.html">Eduard Medvedev, CTO chez Tungsten Labs: «Nous avons grandi au point où la technologie peut causer des dommages considérables»</a></li>
<li><a href="../fr468073/index.html">Andrei Terekhov: "Vous pouvez dire autant que vous le souhaitez que l'Américain est meilleur, mais notre voiture ne tombe jamais en panne"</a></li>
<li><a href="../fr468075/index.html">L'utilisation des réseaux de neurones siamois dans la recherche</a></li>
<li><a href="../fr468077/index.html">Posit les tests de façon adulte. Analyse spectrale</a></li>
<li><a href="../fr468079/index.html">Dimensions personnalisées dans Google Analytics qui nous ont fait économiser plus d'une fois</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>