<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👔 🌀 👨‍⚖️ Implementasi OpenStack LBaaS UI 👶🏻 🌖 🚳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ketika saya mengimplementasikan antarmuka pengguna penyeimbang beban untuk cloud pribadi virtual, saya harus menghadapi kesulitan yang signifikan. Hal...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementasi OpenStack LBaaS UI</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/selectel/blog/455523/"><img src="https://habrastorage.org/webt/ct/q8/3-/ctq83--b7viz0r6evi5um6brnam.png"><br><br>  Ketika saya mengimplementasikan antarmuka pengguna <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penyeimbang beban</a> untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cloud pribadi virtual,</a> saya harus menghadapi kesulitan yang signifikan.  Hal ini membuat saya merenungkan peran frontend, yang ingin saya bagikan terlebih dahulu.  Dan kemudian membenarkan pikiran mereka, menggunakan contoh tugas tertentu. <br><br>  Solusi untuk masalah itu ternyata, menurut saya, cukup kreatif, dan saya harus mencarinya dalam kerangka kerja yang sangat terbatas, jadi saya pikir itu bisa menarik. <br><a name="habracut"></a><br><h2>  Peran frontend </h2><br>  Saya harus segera mengatakan bahwa saya tidak berpura-pura kebenaran dan mengangkat masalah kontroversial.  Saya agak tertekan oleh ironi front-end dan web khususnya, sebagai sesuatu yang tidak signifikan.  Dan bahkan lebih menyedihkan bahwa kadang-kadang ini terjadi secara wajar.  Sekarang mode sudah tertidur, tetapi ada saat ketika semua orang berlarian dengan kerangka kerja, paradigma dan entitas lainnya, mereka dengan keras mengatakan bahwa semua ini sangat penting dan sangat diperlukan, dan sebagai imbalannya mereka menerima ironi bahwa front-end berurusan dengan output dari bentuk dan memproses klik pada tombol, yang dapat dilakukan "di lutut". <br><br>  Sekarang, tampaknya, semuanya telah lebih atau kurang kembali normal.  Tidak ada yang benar-benar ingin berbicara tentang setiap rilis kecil dari kerangka kerja berikutnya.  Hanya sedikit orang yang mencari alat atau pendekatan yang sempurna, karena meningkatnya kesadaran akan utilitas mereka.  Tetapi bahkan ini, misalnya, tidak mengganggu kritik yang hampir tidak dapat dibenarkan terhadap Elektron dan aplikasi di dalamnya.  Saya pikir ini karena kurangnya pemahaman tentang tugas yang diselesaikan oleh front-end. <br><br>  Frontend bukan hanya sarana menampilkan informasi yang disediakan oleh backend, dan bukan hanya sarana untuk memproses tindakan pengguna.  Frontend adalah sesuatu yang lebih, sesuatu yang abstrak, dan jika Anda memberikan definisi yang sederhana dan jelas, maka maknanya pasti akan hilang. <br><br>  Frontend ada dalam beberapa "kerangka".  Misalnya, dalam istilah teknis, itu adalah antara API yang disediakan oleh backend dan API yang disediakan oleh fasilitas I / O.  Dalam hal tugas, itu adalah antara tugas-tugas antarmuka pengguna yang memecahkan UX dan tugas-tugas yang memecahkan backend.  Dengan demikian, spesialisasi frontend agak sempit diperoleh, spesialisasi lapisan.  Ini tidak berarti bahwa penyedia front-end tidak dapat memberikan pengaruh pada area di luar spesialisasi mereka, tetapi pada saat pengaruh ini tidak mungkin, tugas front-end yang sebenarnya muncul. <br><br>  Masalah ini dapat diekspresikan melalui kontradiksi.  Antarmuka pengguna tidak diperlukan untuk menyesuaikan dengan model data dan perilaku backend.  Model perilaku dan data backend tidak diperlukan untuk memenuhi tugas-tugas antarmuka pengguna.  Dan kemudian tugas dari front-end adalah untuk menghilangkan kontradiksi ini.  Semakin besar perbedaan antara tugas-tugas backend dan antarmuka pengguna, semakin penting peran frontend.  Dan untuk memperjelas apa yang saya bicarakan, saya akan memberikan contoh di mana perbedaan ini, untuk beberapa alasan, ternyata signifikan. <br><br><h2>  Pernyataan masalah </h2><br>  OpenStack LBaaS, menurut pendapat saya, adalah perangkat keras-lunak dari alat yang diperlukan untuk menyeimbangkan beban antar server.  Penting bagi saya bahwa implementasinya tergantung pada faktor-faktor objektif, pada tampilan fisik.  Karena itu, ada beberapa kekhasan dalam API dan cara berinteraksi dengan API ini. <br><br>  Saat mengembangkan antarmuka pengguna, minat utama bukanlah fitur teknis backend, tetapi kemampuan dasarnya.  Antarmuka dibuat untuk pengguna, dan pengguna membutuhkan antarmuka untuk mengelola parameter penyeimbang, dan pengguna tidak perlu masuk ke fitur internal implementasi backend. <br><br>  Backend sebagian besar dikembangkan oleh masyarakat, dan dimungkinkan untuk mempengaruhi perkembangannya dalam jumlah yang sangat terbatas.  Salah satu fitur utama bagi saya adalah bahwa pengembang backend siap untuk mengorbankan kenyamanan dan kesederhanaan kontrol demi kinerja, dan ini benar-benar dibenarkan, karena ini adalah masalah menyeimbangkan beban. <br><br>  Ada satu hal lagi yang halus, dan saya ingin segera menguraikannya, memperingatkan beberapa pertanyaan.  Jelas bahwa pada OpenStack dan API mereka lampu tidak menyatu.  Anda selalu dapat mengembangkan set alat Anda sendiri atau "lapisan" yang akan bekerja dengan OpenStack API, menghasilkan API sendiri yang nyaman untuk tugas-tugas pengguna.  Satu-satunya pertanyaan adalah kemanfaatan.  Jika alat yang tersedia awalnya memungkinkan Anda untuk mengimplementasikan antarmuka pengguna seperti yang dimaksudkan, apakah masuk akal untuk menghasilkan entitas? <br><br>  Jawaban untuk pertanyaan ini beragam dan untuk bisnis akan bergantung pada pengembang, pekerjaan mereka, kompetensi mereka, pertanyaan tentang tanggung jawab, dukungan dan sebagainya.  Dalam kasus kami, itu paling bijaksana untuk menyelesaikan beberapa tugas di front-end. <br><br><h3>  Fitur dari OpenStack LBaaS </h3><br>  Saya hanya ingin mengidentifikasi fitur-fitur yang memiliki pengaruh kuat di frontend.  Pertanyaan mengapa fitur ini muncul atau apa yang mereka andalkan sudah berada di luar cakupan artikel ini. <br><br>  Saya bekerja dengan dokumentasi yang sudah jadi dan harus menerima fitur-fiturnya.  Mereka yang tertarik dengan apa OpenStack Octavia dari dalam dapat berkenalan dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi resmi</a> .  Octavia adalah nama seperangkat alat yang dirancang untuk menyeimbangkan beban di ekosistem OpenStack. <br><br>  Fitur pertama yang saya temui selama pengembangan adalah sejumlah besar model dan hubungan yang diperlukan untuk menampilkan keadaan penyeimbang.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Octavia API</a> menggambarkan 12 model, tetapi hanya 7 yang diperlukan untuk sisi klien. Model-model ini memiliki koneksi, sering didenormalisasi, gambar di bawah ini menunjukkan perkiraan diagram: <br><br><div style="text-align:center;"><img title="Diagram contoh model dan hubungan OpenStack Octavia" src="https://habrastorage.org/webt/p2/fw/2v/p2fw2vvyascudv9zjx5a0m-5bkq.png"></div><br><br>  "Seven" tidak terdengar sangat mengesankan, tetapi pada kenyataannya, untuk memastikan pengoperasian penuh antarmuka, pada saat menulis teks ini, saya harus menggunakan 16 model data dan sekitar 30 hubungan di antara mereka.  Karena Octavia hanya penyeimbang, ia membutuhkan modul OpenStack lainnya untuk berfungsi.  Dan semua ini diperlukan hanya untuk dua halaman di antarmuka pengguna. <br><br>  Fitur kedua dan ketiga adalah Octavia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">asinkron</a> dan transaksional.  Model data memiliki bidang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">status</a> yang mencerminkan keadaan operasi yang dilakukan pada objek. <br><div class="scrollable-table"><table><tbody><tr><th>  Status </th><th>  Deskripsi </th></tr><tr><td>  AKTIF </td><td>  Objek dalam kondisi baik </td></tr><tr><td>  DIHAPUS </td><td>  Objek dihapus </td></tr><tr><td>  Kesalahan </td><td>  Obyek rusak </td></tr><tr><td>  PENDING_CREATE </td><td>  Obyek dalam pembuatan </td></tr><tr><td>  PENDING_UPDATE </td><td>  Obyek dalam proses memperbarui </td></tr><tr><td>  PENDING_DELETE </td><td>  Obyek dalam proses penghapusan </td></tr></tbody></table></div>  Operasi membaca objek terjadi secara serempak dan tidak memiliki batasan.  Tetapi membuat, memperbarui, dan menghapus operasi dapat membutuhkan waktu yang tidak terbatas.  Hal ini disebabkan oleh fakta bahwa model data memiliki, secara umum, makna fisik. <br><br>  Setelah mengirim permintaan untuk pembuatan, kita dapat mengetahui bahwa catatan telah muncul, kita dapat membacanya, tetapi sampai operasi pembuatan selesai, kita tidak dapat melakukan operasi lain pada catatan ini.  Upaya semacam itu akan menghasilkan kesalahan.  Operasi mengubah objek hanya dapat dimulai ketika objek dalam status <b>ACTIVE</b> , Anda dapat mengirim objek untuk dihapus dalam status <b>ACTIVE</b> dan <b>ERROR</b> . <br><br>  Status ini dapat datang melalui WebSockets, yang sangat memudahkan pemrosesan mereka, tetapi transaksi adalah masalah yang jauh lebih besar.  Saat melakukan perubahan pada objek apa pun, semua model terkait juga akan berpartisipasi dalam transaksi.  Misalnya, ketika membuat perubahan pada <b>Anggota</b> , <b>Pool</b> , <b>Listener,</b> dan <b>Loadbalancer terkait</b> akan diblokir.  Ini seperti apa dalam hal peristiwa yang diterima di soket web: <br><br><div style="text-align:center;"><img title="Proses mengubah status objek terkait." src="https://habrastorage.org/webt/ia/fp/ff/iafpffzblzikgdekdrrs83br1_y.png"></div><ul><li>  empat peristiwa pertama adalah transfer objek ke status <strong>PENDING_UPDATE</strong> : bidang <strong>target</strong> berisi nama model objek yang berpartisipasi dalam transaksi; </li><li>  acara kelima hanyalah duplikat (saya tidak tahu terhubung dengan apa); </li><li>  empat yang terakhir adalah kembali ke status <strong>AKTIF</strong> .  Dalam hal ini, ini adalah operasi perubahan berat badan, dan itu membutuhkan waktu kurang dari satu detik, tetapi kadang-kadang membutuhkan lebih banyak waktu. </li></ul><br>  Anda juga dapat melihat di tangkapan layar bahwa urutan acara tidak harus ketat.  Dengan demikian, ternyata bahwa untuk memulai operasi apa pun, perlu untuk mengetahui tidak hanya status objek itu sendiri, tetapi juga status semua dependensi yang juga akan berpartisipasi dalam transaksi. <br><br><h3>  Fitur Antarmuka Pengguna </h3><br>  Sekarang bayangkan diri Anda di tempat pengguna yang perlu tahu di suatu tempat bahwa untuk menyeimbangkan antara dua server: <br><br><ol><li>  Penting untuk membuat pendengar di mana algoritma penyeimbang akan ditentukan. </li><li>  Buat kolam. </li><li>  Tetapkan kelompok untuk pendengar. </li><li>  Tambahkan tautan ke port seimbang ke pool. </li></ol><br>  Setiap kali perlu menunggu penyelesaian operasi, yang tergantung pada semua objek yang dibuat sebelumnya. <br><br>  Seperti yang ditunjukkan oleh studi internal, dalam pandangan pengguna biasa, hanya ada perkiraan perkiraan bahwa penyeimbang harus memiliki titik masuk, harus ada titik keluar dan parameter penyeimbangan yang harus dilakukan: algoritma, berat dan lain-lain.  Pengguna tidak harus tahu apa itu OpenStack. <br><br>  Saya tidak tahu betapa rumitnya antarmuka untuk persepsi, di mana pengguna sendiri harus mengikuti semua fitur teknis backend yang dijelaskan di atas.  Untuk konsol, ini mungkin diizinkan, karena penggunaannya menyiratkan tingkat tinggi perendaman dalam teknologi, tetapi untuk web antarmuka seperti itu mengerikan. <br><br>  Di web, pengguna berharap untuk mengisi satu formulir yang jelas dan logis, tekan satu tombol, tunggu dan semuanya akan berfungsi.  Mungkin ini bisa diperdebatkan, tetapi saya mengusulkan untuk berkonsentrasi pada fitur-fitur yang mempengaruhi implementasi frontend. <br><br>  Antarmuka dirancang sedemikian rupa sehingga melibatkan penggunaan operasi kaskade: satu tindakan dalam antarmuka dapat melibatkan beberapa operasi.  Antarmuka tidak menyiratkan bahwa pengguna dapat melakukan tindakan yang saat ini tidak mungkin, tetapi antarmuka mengasumsikan bahwa pengguna harus memahami mengapa demikian.  Antarmuka adalah satu kesatuan tunggal, dan oleh karena itu, elemen individualnya dapat menggunakan informasi dari berbagai entitas dependen, termasuk meta-informasi. <br><br><div style="text-align:center;"><img title="Antarmuka daftar penyeimbang di panel Selectel" src="https://habrastorage.org/webt/cc/no/am/ccnoamyjre40swvpswygbqezn_w.png"></div><br><br>  Jika kita mempertimbangkan bahwa ada beberapa fitur antarmuka yang tidak unik untuk penyeimbang, seperti sakelar, akordeon, tab, menu konteks, dan menganggap bahwa prinsip pengoperasian mereka jelas pada awalnya, maka saya pikir untuk pengguna yang tahu apa penyeimbangan beban, bukan akan sangat sulit untuk membaca sebagian besar antarmuka di atas dan membuat asumsi tentang cara mengelolanya.  Tetapi untuk menyoroti bagian antarmuka mana yang tersembunyi di balik model penyeimbang, pendengar, kelompok, anggota, dan entitas lainnya bukan lagi tugas yang paling jelas. <br><br><h3>  Menyelesaikan Kontradiksi </h3><br>  Saya harap saya dapat menunjukkan bahwa fitur-fitur backend tidak cocok dengan antarmuka dengan baik, dan bahwa fitur-fitur ini tidak selalu dapat dihilangkan oleh backend.  Bersamaan dengan ini, fitur antarmuka tidak pas di backend, dan juga tidak selalu dapat dihilangkan tanpa menyulitkan antarmuka.  Masing-masing bidang ini memecahkan masalahnya sendiri.  Tanggung jawab front-end adalah untuk menyelesaikan masalah untuk memastikan tingkat interaksi yang diperlukan antara antarmuka dan back-end. <br><br>  Dalam latihan saya, saya segera bergegas ke kolam dengan kepala saya, tidak memperhatikan, atau bahkan tidak mencoba untuk mencari tahu fitur-fitur yang lebih tinggi, tetapi saya beruntung atau pengalaman membantu (dan vektor yang benar dipilih).  Saya berulang kali memperhatikan sendiri bahwa ketika menggunakan API atau pustaka pihak ketiga, sangat berguna untuk membiasakan diri Anda dengan dokumentasi terlebih dahulu: semakin detail, semakin baik.  Dokumentasi sering mirip satu sama lain, orang masih mengandalkan pengalaman orang lain, tetapi ada deskripsi fitur dari masing-masing sistem individu, dan terkandung dalam detailnya. <br><br>  Jika saya awalnya menghabiskan beberapa jam ekstra mempelajari dokumentasi, daripada menarik informasi yang diperlukan dengan kata kunci, saya akan memikirkan masalah yang harus dihadapi, dan pengetahuan ini dapat berdampak pada arsitektur proyek dari tahap awal.  Kembali untuk menghilangkan kesalahan yang dilakukan di awal sangat melemahkan semangat.  Dan tanpa konteks penuh, terkadang Anda harus kembali beberapa kali. <br><br>  Sebagai pilihan, Anda dapat menekuk baris Anda, secara bertahap menghasilkan lebih banyak dan lebih banyak kode "dengan gigitan", tetapi semakin banyak tumpukan kode ini, semakin banyak yang akan disapu pada akhirnya.  Ketika mendesain arsitektur, tentu saja, seseorang tidak boleh menyelam terlalu dalam, memperhitungkan semua opsi yang mungkin dan tidak mungkin, menghabiskan banyak waktu untuk itu, penting untuk mencari keseimbangan.  Tetapi perkenalan yang kurang lebih terperinci dengan dokumentasi sering terbukti menjadi investasi yang sangat bermanfaat dan tidak terlalu banyak waktu. <br><br>  Namun demikian, sejak awal, setelah melihat sejumlah besar model yang terlibat, saya menyadari bahwa akan perlu untuk membangun pemetaan kondisi backend ke klien dengan semua koneksi terpelihara.  Setelah saya berhasil menampilkan semua informasi yang diperlukan pada klien, dengan semua koneksi dan sebagainya, perlu untuk mengatur antrian tugas. <br><br>  Data diperbarui secara tidak sinkron, ketersediaan operasi ditentukan oleh berbagai kondisi, dan ketika operasi cascading diperlukan, tidak ada antrian yang dapat ditiadakan dalam kondisi seperti itu.  Singkatnya, ini adalah seluruh arsitektur solusi saya: penyimpanan dengan refleksi dari keadaan backend dan antrian tugas. <br><br><h2>  Arsitektur Solusi </h2><br>  Karena jumlah model dan hubungan yang tidak terbatas, saya menempatkan skalabilitas ke dalam struktur repositori dengan melakukan ini menggunakan pabrik yang mengembalikan deskripsi deklaratif dari koleksi repositori.  Koleksinya memiliki layanan, kelas model sederhana dengan CRUD.  Dimungkinkan untuk membuat deskripsi tautan dalam model, seperti yang dilakukan, misalnya, dalam RoR atau dalam Backbone lama yang baik, tetapi ini membutuhkan sejumlah besar kode untuk diubah.  Oleh karena itu, deskripsi relasi terletak di sebelah kelas model: <br><br><div style="text-align:center;"><img title="Contoh Deskripsi Tautan" src="https://habrastorage.org/webt/_y/jw/pr/_yjwpryzsckc_by0igzpq5vlog0.png"></div><br><br>  Secara total, saya mendapat 2 jenis koneksi: satu ke satu, satu ke banyak.  Umpan balik juga dapat diuraikan.  Selain tipe, kumpulan dependensi ditunjukkan, bidang tempat dependensi yang ditemukan dilampirkan dan bidang dari mana ID objek dependen dibaca (dalam kasus komunikasi satu-ke-banyak, daftar ID dibaca).  Jika kondisi suatu objek untuk komunikasi lebih rumit daripada tautan sederhana ke objek, maka di pabrik seseorang dapat menggambarkan fungsi pengujian dua objek, yang hasilnya akan menentukan keberadaan koneksi.  Semuanya terlihat sedikit "sepeda", tetapi bekerja tanpa ketergantungan yang tidak perlu dan persis seperti seharusnya. <br><br>  Repositori memiliki modul untuk menunggu untuk menambah dan menghapus sumber daya, pada dasarnya ia sedang memproses peristiwa satu kali dengan pemeriksaan bersyarat dan dengan antarmuka promis.  Saat berlangganan, jenis acara (tambah, hapus), fungsi tes, dan pawang dilewatkan.  Ketika peristiwa tertentu terjadi dan dengan hasil tes positif, pawang dieksekusi, setelah itu pelacakan berhenti.  Suatu peristiwa dapat terjadi ketika berlangganan secara sinkron. <br><br>  Penggunaan pola semacam itu memungkinkan untuk secara otomatis membubuhkan hubungan kompleks yang sewenang-wenang antara model, dan melakukannya di satu tempat.  Tempat ini saya sebut pelacak.  Saat menambahkan objek ke repositori, ia mulai melacak hubungannya.  Modul menunggu memungkinkan Anda untuk merespons acara dan memeriksa koneksi antara objek yang dipantau dan objek di penyimpanan.  Jika objek sudah ada di repositori, maka modul tunggu segera memanggil pawang. <br><br>  Perangkat penyimpanan semacam itu memungkinkan Anda untuk menggambarkan sejumlah koleksi dan hubungan di antara mereka.  Saat menambahkan dan menghapus objek, toko secara otomatis menempatkan atau me-reset properti dengan konten objek dependen.  Keuntungan dari pendekatan ini adalah bahwa semua hubungan dijelaskan secara eksplisit, dan mereka dimonitor dan diperbarui oleh satu sistem;  kontra - dalam kompleksitas implementasi dan debugging. <br><br>  Secara umum, repositori semacam itu cukup sepele dan saya melakukannya sendiri, karena akan jauh lebih sulit untuk mengintegrasikan solusi yang sudah jadi ke dalam basis kode yang ada, tetapi akan lebih sulit untuk melampirkan antrian tugas ke solusi yang sudah jadi. <br><br>  Semua tugas, seperti koleksi, memiliki deskripsi deklaratif dan dibuat oleh pabrik.  Tugas dapat memiliki dalam deskripsi kondisi untuk memulai dan daftar tugas yang perlu ditambahkan ke antrian setelah yang saat ini selesai. <br><br><div style="text-align:center;"><img title="Contoh menghasilkan tugas untuk membuat kumpulan" src="https://habrastorage.org/webt/03/7w/fo/037wfo0c0fn7uxeblixnsahw7j8.png"></div><br>  Contoh di atas menjelaskan tugas membuat kumpulan.  Dalam dependensi, penyeimbang dan pendengar ditunjukkan, secara default, pemeriksaan dilakukan untuk status <b>AKTIF</b> .  Objek penyeimbang diblokir, karena tugas pemrosesan dalam antrian dapat terjadi secara serempak, memblokir menghindari konflik pada saat permintaan eksekusi dikirim, tetapi statusnya belum berubah, tetapi diasumsikan bahwa itu akan berubah.  Alih-alih <b>ORANGTUA</b> , jika kumpulan dibuat sebagai hasil dari kaskade tugas, <b>ID</b> akan diganti secara otomatis. <br><br>  Setelah membuat kumpulan, tugas akan ditambahkan ke antrian untuk membuat monitor ketersediaan dan membuat semua anggota kumpulan ini.  Outputnya adalah struktur yang dapat sepenuhnya dikonversi ke JSON.  Ini dilakukan untuk dapat mengembalikan antrian jika terjadi kegagalan. <br><br>  Antrian, berdasarkan pada deskripsi tugas, secara independen memonitor semua perubahan dalam repositori dan memeriksa kondisi yang harus dipenuhi untuk menjalankan tugas.  Seperti yang sudah saya katakan, status datang melalui soket web, dan sangat mudah untuk menghasilkan acara yang diperlukan untuk antrian, tetapi jika perlu tidak akan ada masalah untuk melampirkan mekanisme pembaruan data pengatur waktu (ini awalnya diletakkan dalam arsitektur, karena soket web dibuat karena berbagai alasan mungkin tidak bekerja dengan sangat stabil).  Setelah tugas selesai, antrian secara otomatis menginformasikan repositori tentang perlunya memperbarui tautan dalam objek yang ditentukan. <br><br><h2>  Kesimpulan </h2><br>  Kebutuhan akan skalabilitas telah mengarah pada pendekatan deklaratif.  Kebutuhan untuk menampilkan model dan hubungan di antara mereka telah menyebabkan repositori tunggal.  Kebutuhan untuk memproses objek dependen telah menyebabkan antrian. <br><br>  Menggabungkan kebutuhan ini mungkin bukan tugas yang paling mudah dalam hal implementasi (tetapi ini adalah masalah yang terpisah).  Tetapi dalam hal arsitektur, solusinya sangat sederhana dan memungkinkan Anda untuk menghilangkan semua kontradiksi antara tugas-tugas backend dan antarmuka pengguna, untuk membangun interaksi mereka dan meletakkan dasar untuk fitur-fitur lain yang mungkin dari salah satu pihak. <br><br>  Dari sisi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">panel kontrol</a> Selectel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">,</a> proses penyeimbangan sederhana dan mudah, yang memungkinkan pelanggan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">layanan</a> untuk tidak menghabiskan sumber daya pada implementasi independen penyeimbang, sambil mempertahankan kemampuan untuk mengontrol lalu lintas secara fleksibel. <br><br>  Coba penyeimbang kami dalam tindakan sekarang dan tulis ulasan Anda di komentar. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id455523/">https://habr.com/ru/post/id455523/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id455511/index.html">Tidur adalah sumber daya utama bagi otak seorang programmer</a></li>
<li><a href="../id455513/index.html">Ledakan dan konspirasi global: kisah penciptaan baterai lithium-ion</a></li>
<li><a href="../id455515/index.html">Membalikkan dan meretas HDD eksternal Aigo yang mengenkripsi sendiri. Bagian 1: Membedah menjadi beberapa bagian</a></li>
<li><a href="../id455517/index.html">Lulusan program Netologi "Ilmu Data" tentang pekerjaannya di sektor perbankan</a></li>
<li><a href="../id455519/index.html">Bagaimana kami menerapkan orientasi pengembang baru</a></li>
<li><a href="../id455525/index.html">Zimbra dan Pertahanan Bom Surat</a></li>
<li><a href="../id455527/index.html">Apa yang tertulis di sini? Di belakang layar objek JavaScript</a></li>
<li><a href="../id455529/index.html">Membalikkan dan meretas HDD eksternal Aigo yang mengenkripsi sendiri. Bagian 2: Membuang dengan Cypress PSoC</a></li>
<li><a href="../id455533/index.html">Bubble Physics: Pencarian untuk Mekanisme Penghancuran Busa</a></li>
<li><a href="../id455535/index.html">Mengelola sertifikat SSL / TLS di awan dan kontainer - bukan pekerjaan manusia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>