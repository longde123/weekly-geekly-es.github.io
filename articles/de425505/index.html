<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöû üï∫ üë©‚Äç‚öñÔ∏è Analyse des Linux-Kernel-Boot-Prozesses üíü üìí üèÇüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! 

 W√§hrend Leonid sich auf seine erste offene Lektion in unserem Linux-Administrator- Kurs vorbereitet, sprechen wir weiterhin √ºber ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analyse des Linux-Kernel-Boot-Prozesses</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/425505/">  Hallo allerseits! <br><br>  W√§hrend <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Leonid</a> sich auf seine erste <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offene Lektion</a> in unserem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Linux-Administrator-</a> Kurs vorbereitet, sprechen wir weiterhin √ºber das Laden des Linux-Kernels. <br><br>  Lass uns gehen! <br><br>  Verstehen, wie ein System ohne Fehler funktioniert - Vorbereiten, um die unvermeidlichen Ausf√§lle zu beheben <br><br>  Der √§lteste Witz im Open-Source-Bereich ist die Aussage, dass ‚Äûder Code sich selbst dokumentiert‚Äú.  Die Erfahrung hat gezeigt, dass das Lesen von Quellcode dem Abh√∂ren von Wettervorhersagen gleicht: Intelligente Menschen gehen immer noch nach drau√üen und schauen in den Himmel.  Im Folgenden finden Sie Tipps zum √úberpr√ºfen und Untersuchen des Linux-Systemstarts mit bekannten Debugging-Tools.  Eine Analyse des Startvorgangs eines gut funktionierenden Systems bereitet Benutzer und Entwickler auf die L√∂sung unvermeidlicher Abst√ºrze vor. <br><br>  Einerseits ist der Downloadvorgang √ºberraschend einfach.  Der Kernel des Betriebssystems (Kernel) l√§uft Single-Threaded und synchron auf einem Kern (Kern), was selbst f√ºr einen erb√§rmlichen menschlichen Verstand verst√§ndlich erscheint.  Aber wie startet der Kernel des Betriebssystems?  Welche Funktionen haben initrd ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine RAM-Disk f√ºr die Erstinitialisierung</a> ) und Bootloader?  Und warten Sie, warum leuchtet die LED am Ethernet-Port immer? <br><br><img src="https://habrastorage.org/webt/dl/v5/cc/dlv5cchbiput5mmnbjyzz1nloho.png"><a name="habracut"></a><br><br>  Lesen Sie weiter, um Antworten auf diese und einige andere Fragen zu erhalten.  Der Code f√ºr die beschriebenen Demos und √úbungen ist auch auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> verf√ºgbar. <br><br>  <b>Start des Startvorgangs: Status AUS</b> <br><br>  <i><b>Wake-on-LAN</b></i> <br><br>  Der Status AUS bedeutet, dass das System nicht mit Strom versorgt wird, oder?  Scheinbare Einfachheit t√§uscht.  Beispielsweise leuchtet die Ethernet-LED auch in diesem Zustand, da Wake-on-LAN (WOL, Wake-up auf [Signal von] LAN) in Ihrem System eingeschaltet ist.  Stellen Sie sicher, indem Sie schreiben: <br><br><pre><code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$#</span></span> sudo ethtool &lt;interface name&gt;</code> </pre> <br>  Wobei es stattdessen beispielsweise eth0 sein kann (ethtool befindet sich in gleichnamigen Linux-Paketen).  Wenn das "Wake-on" in der Ausgabe g anzeigt, k√∂nnen Remote-Hosts das System durch Senden von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MagicPacket starten</a> .  Wenn Sie Ihr System nicht selbst aus der Ferne einschalten und anderen diese M√∂glichkeit geben m√∂chten, deaktivieren Sie WOL im System-BIOS-Men√º oder verwenden Sie: <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$#</span></span> sudo ethtool -s &lt;interface name&gt; wol d</code> </pre> <br>  Ein Prozessor, der auf MagicPacket reagiert, kann ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Baseboard Management Controller</a> (BMC) oder Teil einer Netzwerkschnittstelle sein. <br><br>  <i><b>Intel Management Engine, Platform Controller Hub und Minix</b></i> <br><br>  BMC ist nicht der einzige Mikrocontroller (MCU), der ein nominell ausgeschaltetes System ‚Äûabh√∂ren‚Äú kann.  X86_64-Systeme verf√ºgen √ºber das IME-Softwarepaket (Intel Management Engine) f√ºr die Remote-Systemverwaltung.  Eine Vielzahl von Ger√§ten, von Servern bis hin zu Laptops, verf√ºgen √ºber Technologien <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mit Funktionen</a> wie KVM Remote Control oder Intel Capability Licensing Service.  Laut dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eigenen Tool</a> von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inte</a> l hat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IME nicht gepatchte Schwachstellen.</a>  Die schlechte Nachricht ist, dass das Deaktivieren von IME schwierig ist.  Trammell Hudson hat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das me_cleaner-Projekt erstellt, das</a> einige der ungeheuerlichsten IME-Komponenten wie den eingebetteten Webserver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">l√∂scht.</a> Gleichzeitig besteht jedoch die M√∂glichkeit, dass die Verwendung des Projekts das System, auf dem es ausgef√ºhrt wird, in einen Baustein verwandelt. <br><br>  Die IME-Firmware und das darauf folgende System Management Mode (SMM) -Programm basieren auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dem Minix-Betriebssystem</a> und werden auf einem separaten Platform Controller Hub-Prozessor ausgef√ºhrt, nicht auf der Haupt-CPU des Systems.  Anschlie√üend startet SMM das UEFI-Programm (Universal Extensible Firmware Interface) auf dem Hauptprozessor, √ºber das bereits mehrmals <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">geschrieben wurde</a> .  Die Coreboot-Gruppe startete bei Google ein spektakul√§r ehrgeiziges <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NERF-</a> Projekt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(Non-Extensible Reduced Firmware)</a> , das nicht nur UEFI, sondern auch fr√ºhe Komponenten des Linux-Benutzerbereichs wie systemd ersetzen soll.  In der Zwischenzeit warten wir auf die Ergebnisse. Linux-Benutzer k√∂nnen Laptops von Purism, System76 oder Dell kaufen, auf denen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IME deaktiviert ist.</a> Au√üerdem k√∂nnen wir auf Laptops mit einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">64-Bit-ARM-Prozessor</a> hoffen. <br><br>  <i><b>Lader</b></i> <i><b><br></b></i> <br>  Was macht die bootf√§hige Firmware neben dem Starten der verd√§chtigen Spyware?  Die Aufgabe des Bootloaders besteht darin, dem gerade eingeschalteten Prozessor die erforderlichen Ressourcen zur Verf√ºgung zu stellen, um ein Allzweckbetriebssystem wie Linux auszuf√ºhren.  W√§hrend des Einschaltens gibt es nicht nur virtuellen Speicher, sondern auch DRAM, bis der Controller angehoben wird.  Der Bootloader schaltet dann die Netzteile ein und durchsucht die Busse und Schnittstellen, um das Kernel-Image und das Root-Dateisystem zu finden.  Beliebte Bootloader wie U-Boot und GRUB unterst√ºtzen sowohl g√§ngige Schnittstellen wie USB, PCI und NFS als auch andere speziellere Embedded-Ger√§te wie NOR- und NAND-Flash.  Loader interagieren auch mit Sicherheitshardwareger√§ten wie dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Trusted Platform Module (TPM)</a> , um vom Beginn des Downloads an eine Vertrauenskette einzurichten. <br><br><img src="https://habrastorage.org/webt/ur/fy/-n/urfy-neq9uuqezexjmitgdyg4aa.png"><br>  <i>Ausf√ºhren des U-Boot-Loaders in der Sandbox auf dem Build-Server.</i> <br><br>  Der beliebte Open-Source- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">U-Boot-</a> Bootloader wird von Systemen vom Raspberry Pi bis zu Nintendo-Ger√§ten, Autokarten und Chromebooks unterst√ºtzt.  Es gibt kein Systemprotokoll, und wenn etwas schief geht, wird m√∂glicherweise nicht einmal die Konsole ausgegeben.  Um das Debuggen zu erleichtern, bietet das U-Boot-Team eine Sandbox zum Testen von Patches auf dem Build-Host oder sogar im Continuous Integration-System.  Auf einem System mit g√§ngigen Entwicklungstools wie Git und der installierten GNU Compiler Collection (GCC) ist das Verst√§ndnis der U-Boot-Sandbox einfach. <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$#</span></span> git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> git://git.denx.de/u-boot; <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> u-boot <span class="hljs-variable"><span class="hljs-variable">$#</span></span> make ARCH=sandbox defconfig <span class="hljs-variable"><span class="hljs-variable">$#</span></span> make; ./u-boot =&gt; printenv =&gt; <span class="hljs-built_in"><span class="hljs-built_in">help</span></span></code> </pre><br>  Das ist alles: Sie haben U-Boot auf x86_64 gestartet und k√∂nnen knifflige Funktionen testen, z. B. die Neupartitionierung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fiktiver Speicherger√§te</a> , die TPM-basierte Manipulation geheimer Schl√ºssel und den Hotplug von USB-Ger√§ten.  Die U-Boot-Sandbox kann innerhalb des GDB-Debuggers einstufig sein.  Die Entwicklung mit der Sandbox ist zehnmal schneller als das Testen durch √úberschreiben des Bootloaders auf der Platine. Au√üerdem kann die Sandstein-Sandbox durch Dr√ºcken von Strg + C wiederhergestellt werden. <br><br>  <b>Kernel-Start</b> <br><br>  <i><b>Booten der Kernelversorgung</b></i> <br><br>  Nach Abschluss seiner Aufgaben wechselt der Bootloader zu dem Kernel-Code, den er in den Hauptspeicher geladen hat, und beginnt mit der Ausf√ºhrung, wobei alle vom Benutzer angegebenen Befehlszeilenparameter √ºbergeben werden.  Welches Programm ist der Kernel?  file / boot / vmlinuz zeigt, dass dies bzImage ist.  Der Linux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">-Quellbaum</a> verf√ºgt √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Tool</a> zum Extrahieren von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vmlinux</a> , mit dem Sie die Datei extrahieren k√∂nnen: <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$#</span></span> scripts/extract-vmlinux /boot/vmlinuz-$(uname -r) &gt; vmlinux <span class="hljs-variable"><span class="hljs-variable">$#</span></span> file vmlinux vmlinux: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, stripped</code> </pre><br>  Der Kernel ist eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ELF-</a> Bin√§rdatei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(Executable and Linking Format)</a> , wie Linux-User-Space-Programme.  Dies bedeutet, dass wir binutils-Befehle wie readelf verwenden k√∂nnen, um es zu lernen.  Vergleichen Sie zum Beispiel die folgenden Schlussfolgerungen: <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$#</span></span> readelf -S /bin/date <span class="hljs-variable"><span class="hljs-variable">$#</span></span> readelf -S vmlinux</code> </pre><br>  Die Liste der Partitionen in Bin√§rdateien ist gr√∂√ütenteils √§hnlich. <br><br>  Der Kernel sollte also andere ELF Linux-Bin√§rdateien starten ... Aber wie werden User Space-Programme ausgef√ºhrt?  In der <code>main()</code> Funktion, richtig?  Nicht wirklich. <br><br>  Vor dem Ausf√ºhren der Funktion <code>main()</code> ben√∂tigen Programme einen Ausf√ºhrungskontext, einschlie√ülich Heap- (Heap) und Stack- (Stack) Speicher sowie Dateideskriptoren f√ºr <code>stdio</code> , <code>stdout</code> und <code>stderr</code> .  User Space-Programme beziehen diese Ressourcen aus der Standardbibliothek ( <code>glibc</code> f√ºr die meisten Linux-Systeme).  Beachten Sie Folgendes: <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$#</span></span> file /bin/date /bin/date: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> GNU/Linux 2.6.32, BuildID[sha1]=14e8563676febeb06d701dbee35d225c5a8e565a, stripped</code> </pre> <br>  ELF-Bin√§rdateien haben einen Interpreter, genau wie Bash- und Python-Skripte.  Es muss jedoch nicht durch <code>#!</code> angegeben werden <code>#!</code>  wie in Skripten, da ELF ein natives Linux-Format ist.  Der ELF-Interpreter versorgt die Bin√§rdatei mit allen erforderlichen Ressourcen, indem er <code>_start()</code> , eine Funktion, die im <code>glibc</code> <code>_start()</code> verf√ºgbar ist und √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GDB</a> gelernt werden kann.  Der Kernel hat offensichtlich keinen Interpreter und sollte sich selbstst√§ndig versorgen, aber wie? <br><br>  Eine Studie zum Starten eines Kernels mit GDB liefert eine Antwort auf diese Frage.  Installieren Sie zun√§chst das Kernel-Debugging-Paket, das die ungeschnittene Version von <code>vmlinux</code> , z. B. <code>apt-get install linux-image-amd64-dbg</code> .  Oder kompilieren und installieren Sie Ihren eigenen Kernel aus einer Quelle, zum Beispiel gem√§√ü den Anweisungen aus dem hervorragenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Debian-Kernel-Handbuch</a> .  <code>gdb vmlinux</code> gefolgt von <code>info files</code> zeigt den ELF-Abschnitt <code>init.text</code> .  <code>init.text</code> den Start der Programmausf√ºhrung in <code>init.text</code> mit <code>l *(address)</code> , wobei address der hexadezimale Start von <code>init.text</code> .  GDB gibt an, dass der x86_64-Kernel in der <code><a href="">arch/x86/kernel/head_64.S</a></code> gestartet wird. Dort finden wir die Build-Funktion <code>start_cpu0()</code> und den Code, der den Stack explizit erstellt und zImage dekomprimiert, bevor <code>x86_64 start_kernel()</code> .  32-Bit-ARM-Kerne haben einen √§hnlichen <code><a href="">arch/arm/kernel/head.S. start_kernel()</a></code>  <code><a href="">arch/arm/kernel/head.S. start_kernel()</a></code> ist architekturunabh√§ngig, daher befindet sich die Funktion im Kernel <code>init/main.c</code>  Wir k√∂nnen sagen, dass <code>start_kernel()</code> eine echte <code>main()</code> Linux-Funktion ist. <br><br>  <b>Von start_kernel () zu PID 1</b> <br>  <i><b>Kernel-Hardware-Manifest: ACPI-Tabellen und Ger√§teb√§ume</b></i> <br><br>  Beim Booten ben√∂tigt der Kernel zus√§tzlich zum Prozessortyp, f√ºr den er kompiliert wurde, Informationen zur Hardware.  Die Anweisungen im Code werden durch Konfigurationsdaten erg√§nzt, die separat gespeichert werden.  Es gibt zwei Hauptmethoden zum Speichern von Daten: Ger√§teb√§ume und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ACPI-Tabellen</a> .  Aus diesen Dateien ermittelt der Kernel, welche Ger√§te bei jedem Start ausgef√ºhrt werden m√ºssen. <br><br>  Bei eingebetteten Ger√§ten ist der Ger√§tebaum (DU) ein Manifest der installierten Ger√§te.  DU ist eine Datei, die gleichzeitig mit der <code>vmlinux</code> kompiliert wird und sich normalerweise zusammen mit <code>vmlinux</code> in / boot <code>vmlinux</code> .  Um zu sehen, was sich im bin√§ren Ger√§tebaum auf dem ARM-Ger√§t befindet, verwenden Sie einfach den Befehl <code>strings</code> aus dem binutils-Paket in der Datei, deren Name <code>/boot/*.dtb</code> , da <code>dtb</code> die Bin√§rdatei des Ger√§tebaums (Device-Tree Binary) bedeutet.  Sie k√∂nnen die Fernbedienung √§ndern, indem Sie die JSON-√§hnlichen Dateien bearbeiten, aus denen sie besteht, und den speziellen dtc-Compiler neu starten, der mit der Kernelquelle bereitgestellt wird.  DU ist eine statische Datei, deren Pfad normalerweise von Bootloadern in der Befehlszeile an den Kernel √ºbergeben wird. In den letzten Jahren wurde jedoch eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ger√§tebaum√ºberlagerung</a> hinzugef√ºgt, in der der Kernel nach dem Laden dynamisch zus√§tzliche Fragmente als Reaktion auf Hotplug-Ereignisse laden kann. <br><br>  Die x86-Familie und viele ARM64-Ger√§te auf Unternehmensebene verwenden den alternativen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ACPI-</a> Mechanismus (Advanced Configuration and Power Interface <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">)</a> .  Im Gegensatz zur Fernbedienung werden ACPI-Informationen im virtuellen Dateisystem <code>/sys/firmware/acpi/tables</code> , das vom Kernel beim Start durch Zugriff auf das interne ROM erstellt wird.  Verwenden <code>acpidump</code> zum Lesen von ACPI-Tabellen den Befehl <code>acpidump</code> aus dem Paket <code>acpica-tools</code> .  Hier ist ein Beispiel: <br><br><img src="https://habrastorage.org/webt/gq/gw/mj/gqgwmjbpkadcvz6fbzyp7uc8gvg.png"><br>  <i>ACPI-Tabellen auf Lenovo Laptops sind f√ºr Windows 2001 bereit.</i> <br><br>  Ja, Ihr Linux-System ist f√ºr Windows 2001 bereit, wenn Sie es installieren m√∂chten.  ACPI verf√ºgt sowohl √ºber Methoden als auch √ºber Daten, im Gegensatz zur Fernbedienung, die eher einer Hardwarebeschreibungssprache √§hnelt.  ACPI-Methoden sind nach dem Start weiterhin aktiv.  Wenn Sie beispielsweise den Befehl acpi_listen (aus dem apcid-Paket) ausf√ºhren und dann den Deckel des Laptops schlie√üen und √∂ffnen, werden Sie feststellen, dass die ACPI-Funktionalit√§t die ganze Zeit √ºber funktioniert hat.  Tempor√§res und dynamisches <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Umschreiben von ACPI-Tabellen</a> ist m√∂glich, aber eine permanente √Ñnderung erfordert eine Interaktion mit dem BIOS-Men√º beim Booten oder Flashen des ROM.  Anstelle dieser Komplexit√§t sollten Sie m√∂glicherweise nur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">coreboot installieren</a> , einen Ersatz f√ºr Open Source-Firmware. <br><br>  Von start_kernel () zum User Space <br><br>  Der Code in <code><a href="">init/main.c</a></code> ist √ºberraschend leicht zu lesen und tr√§gt seltsamerweise immer noch das urspr√ºngliche Copyright von Linus Torvalds von 1991-1992.  Linien gefunden in <code>dmesg | head</code>  <code>dmesg | head</code> laufenden Systems stammt im Wesentlichen aus dieser Quelldatei.  Die erste CPU wird vom System registriert, die globalen Datenstrukturen werden initialisiert, nacheinander werden der Scheduler, die Interrupt-Handler (IRQs), die Timer und die Konsole ausgel√∂st.  Alle Zeitstempel vor dem Ausf√ºhren von <code>timekeeping_init()</code> sind Null.  Dieser Teil der Kernelinitialisierung ist synchron, dh die Ausf√ºhrung erfolgt nur in einem Thread.  Funktionen werden erst ausgef√ºhrt, wenn die letzte abgeschlossen und zur√ºckgegeben ist.  Infolgedessen ist die <code>dmesg</code> Ausgabe auch zwischen den beiden Systemen vollst√§ndig reproduzierbar, sofern sie √ºber dieselbe Fernbedienungs- oder ACPI- <code>dmesg</code> verf√ºgen.  Linux verh√§lt sich auch wie ein Echtzeitbetriebssystem (RTOS), das auf einer MCU wie QNX oder VxWorks ausgef√ºhrt wird.  Diese Situation wird in der Funktion <code>rest_init()</code> gespeichert, die zum Zeitpunkt ihrer Fertigstellung von <code>start_kernel()</code> aufgerufen wird. <br><br><img src="https://habrastorage.org/webt/dt/ge/49/dtge49gofpzdjlzk__surv1x9-o.png"><br>  <i>Eine kurze Beschreibung des fr√ºhen Kernel-Boot-Prozesses</i> <i><br></i> <br>  Der bescheidene Name <code>rest_init()</code> erstellt einen neuen Thread, in dem <code>kernel_init()</code> , der wiederum <code>do_initcalls()</code> .  Benutzer k√∂nnen den Betrieb von <code>initcalls</code> √ºberwachen, indem sie <code>initcalls_debug</code> zur Kernel-Befehlszeile hinzuf√ºgen.  Infolgedessen erhalten Sie die Entit√§t <code>dmesg</code> jedes Mal, wenn Sie die Funktion <code>initcall</code> .  <code>initcalls</code> durchl√§uft sieben aufeinanderfolgende Ebenen: Early, Core, Postcore, Arch, Subsys, Fs, Device und Late.  Der auff√§lligste Teil von <code>initcalls</code> f√ºr Benutzer ist die Identifizierung und Installation von Peripherieger√§ten des Prozessors: Busse, Netzwerk, Speicher, Anzeigen usw., begleitet vom Laden ihrer Kernelmodule.  <code>rest_init()</code> erstellt auch einen zweiten Thread im Bootprozessor, der zun√§chst <code>cpu_idle()</code> w√§hrend der Scheduler seine Arbeit verteilt. <br><br>  <code>kernel_init()</code> richtet auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">symmetrisches Multiprocessing</a> (SMP) ein.  In modernen Kerneln finden Sie diesen Moment in der dmesg-Ausgabe in der Zeile "Sekund√§re CPUs hochfahren ...".  SMP stellt dann den CPU-Hot-Plug her, was bedeutet, dass er seinen Lebenszyklus mithilfe einer Zustandsmaschine verwaltet, die denen √§hnelt, die in Ger√§ten wie der automatischen Erkennung von USB-Speichersticks verwendet werden.  Das Kernel-Energieverwaltungssystem f√§hrt h√§ufig einzelne Kerne (Kerne) herunter und weckt sie nach Bedarf, sodass auf einem nicht besetzten Computer wiederholt derselbe Hotplug-CPU-Code aufgerufen wird.  Sehen Sie sich an, wie ein Energieverwaltungssystem einen CPU-Hotplug mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einem BCC-Tool</a> namens <code>offcputime.py</code> . <br><br>  Beachten Sie, dass der Code in <code>init/main.c</code> fast ausgef√ºhrt wurde, als <code>smp_init()</code> .  Der Boot-Prozessor hat den gr√∂√üten Teil der einmaligen Initialisierung abgeschlossen, die andere Kernel nicht wiederholen m√ºssen.  F√ºr jeden Kern m√ºssen jedoch Threads erstellt werden, um Interrupts (IRQs), Workqueue, Timer und Energieereignisse auf jedem Kern zu steuern.  Sehen Sie sich beispielsweise Prozessorthreads an, die Softirqs und Workqueues mit dem Befehl <code>ps -o psr.</code> <br><br><pre> <code class="bash hljs">$\<span class="hljs-comment"><span class="hljs-comment"># ps -o pid,psr,comm $(pgrep ksoftirqd) PID PSR COMMAND 7 0 ksoftirqd/0 16 1 ksoftirqd/1 22 2 ksoftirqd/2 28 3 ksoftirqd/3 $\# ps -o pid,psr,comm $(pgrep kworker) PID PSR COMMAND 4 0 kworker/0:0H 18 1 kworker/1:0H 24 2 kworker/2:0H 30 3 kworker/3:0H [ . . . ]</span></span></code> </pre> <br>  wobei das PSR-Feld "Prozessor" bedeutet.  Jeder Kern muss √ºber eigene Timer und CPU-Hotplug-Handler verf√ºgen. <br><br>  Und schlie√ülich, wie wird User Space gestartet?  Gegen Ende sucht <code>kernel_init()</code> nach einem <code>initrd</code> , der den <code>init</code> Prozess in seinem Namen starten kann.  Wenn nicht, f√ºhrt der Kernel <code>init</code> selbst aus.  Warum kann dann <code>initrd</code> ben√∂tigt werden? <br><br>  <i><b>Early User Space: Wer hat initrd bestellt?</b></i> <br><br>  Zus√§tzlich zum Ger√§tebaum geh√∂rt ein weiterer Init-Pfad zur Datei, der optional vom Kernel beim Booten bereitgestellt wird, zu <code>initrd</code> .  <code>initrd</code> h√§ufig in / boot zusammen mit der Datei bzImage vmlinuz auf x86 oder mit einem √§hnlichen uImage- und Ger√§tebaum f√ºr ARM.  Eine Liste der <code>intrd</code> Inhalte kann mit dem Tool <code>lsinitramfs</code> angezeigt werden, das Teil des Pakets <code>initramfs-tools-core</code> .  Das initrd-Distributionsimage enth√§lt die Mindestverzeichnisse <code>/bin</code> , <code>/sbin</code> und <code>/etc</code> sowie Kernelmodule und -dateien in <code>/scripts</code> .  Alles sollte mehr oder weniger vertraut aussehen, da <code>initrd</code> gr√∂√ütenteils dem vereinfachten Linux-Root-Dateisystem √§hnelt.  Diese √Ñhnlichkeit ist etwas irref√ºhrend, da fast alle ausf√ºhrbaren Dateien in <code>/bin</code> und <code>/sbin</code> in ramdisk Symlinks zur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BusyBox-Bin√§rdatei sind</a> , wodurch die Verzeichnisse / bin und / sbin zehnmal kleiner sind als in <code>glibc</code> . <br><br>  Warum sollten Sie versuchen, eine <code>initrd</code> erstellen, wenn nur einige Module geladen und <code>init</code> auf einem regul√§ren Root-Dateisystem ausgef√ºhrt werden?  Betrachten Sie ein verschl√ºsseltes Root-Dateisystem.  Die Entschl√ºsselung kann vom Laden des in <code>/lib/modules</code> Root-Dateisystems gespeicherten Kernelmoduls abh√§ngen ... und erwartungsgem√§√ü in <code>initrd</code> .  Das Kryptomodul kann statisch in den Kernel kompiliert und nicht aus einer Datei geladen werden. Es gibt jedoch mehrere Gr√ºnde, dies abzulehnen.  Beispielsweise kann die statische Kompilierung eines Kernels mit Modulen zu gro√ü werden, um in den verf√ºgbaren Speicher zu passen, oder die statische Kompilierung kann gegen Softwarelizenzbestimmungen versto√üen.  Es √ºberrascht nicht, dass Speichertreiber, Netzwerke und HIDs (menschliche Eingabeger√§te) auch in <code>initrd</code> - im Wesentlichen jeder Code, der kein erforderlicher Bestandteil des Kernels ist, der zum Mounten des Root-Dateisystems ben√∂tigt wird.  Auch in initrd k√∂nnen Benutzer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ihren eigenen ACPI-Code f√ºr Tabellen</a> speichern. <br><br><img src="https://habrastorage.org/webt/gx/nj/lj/gxnjljvh-gs47qpacftktsubl2e.png"><br>  <i>Spa√ü mit Rescue Shell und Custom Initrd.</i> <br><br>  <code>initrd</code> auch hervorragend zum Testen von Dateisystemen und Speicherger√§ten.  Setzen Sie die Testtools in <code>initrd</code> und f√ºhren Sie die Tests aus dem Speicher aus, nicht aus dem Testobjekt. <br><br>  Wenn <code>init</code> , wird das System ausgef√ºhrt!  Da die sekund√§ren Prozessoren bereits ausgef√ºhrt werden, ist die Maschine zu einer asynchronen, ausgelagerten, unvorhersehbaren und leistungsstarken Kreatur geworden, die wir alle kennen und lieben.  In der Tat gibt <code>ps -o pid,psr,comm -p</code> an, dass der <code>ps -o pid,psr,comm -p</code> f√ºr den Benutzerbereich nicht mehr auf dem Bootprozessor ausgef√ºhrt wird. <br><br>  <b>Zusammenfassung</b> <br><br>  Der Linux-Startvorgang klingt angesichts der Menge der betroffenen Software selbst auf einem einfachen eingebetteten Ger√§t verboten.  Auf der anderen Seite ist der Startvorgang recht einfach, da es keine √ºberm√§√üige Komplexit√§t gibt, die durch Verdr√§ngung von Multitasking-, RCU- und Rennbedingungen verursacht wird.  Wenn man nur den Kernel und PID 1 ber√ºcksichtigt, kann man die gro√üartige Arbeit √ºbersehen, die Bootloader und Hilfsprozessoren geleistet haben, um die Plattform f√ºr den Kernelstart vorzubereiten.  Der Kernel unterscheidet sich sicherlich von anderen Linux-Programmen, aber die Verwendung von Tools zur Arbeit mit anderen ELF-Bin√§rdateien hilft, seine Struktur besser zu verstehen.  Das Studium eines funktionsf√§higen Startvorgangs bereitet sich auf zuk√ºnftige Abst√ºrze vor. <br><br>  DAS ENDE <br><br>  Wir warten wie gewohnt auf Ihre Kommentare und Fragen, entweder hier oder in unserer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offenen Lektion,</a> in der Leonid umgehauen wird. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de425505/">https://habr.com/ru/post/de425505/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de425493/index.html">MikroTik hAP mini f√ºr IPTV Beeline konfigurieren</a></li>
<li><a href="../de425497/index.html">Tutu PHP Meetup # 2: Live-√úbertragung von Ereignissen</a></li>
<li><a href="../de425499/index.html">HyperX Impact DDR4 - SO-DIMM, das k√∂nnte! Oder warum in einem Laptop 64 GB Speicher mit einer Frequenz von 3200 MHz?</a></li>
<li><a href="../de425501/index.html">A / B-Tests auf Android von A bis Z.</a></li>
<li><a href="../de425503/index.html">Cassandra Sink f√ºr Spark Structured Streaming</a></li>
<li><a href="../de425507/index.html">Parsim Wikipedia f√ºr NLP-Aufgaben in 4 Teams</a></li>
<li><a href="../de425511/index.html">Nicht offensichtliche Funktionen der Rotativa-Anwendung zum Generieren von PDF in der ASP.NET MVC-Anwendung</a></li>
<li><a href="../de425515/index.html">Apple blockiert die unabh√§ngige Reparatur neuer MacBook-Modelle</a></li>
<li><a href="../de425517/index.html">Wie Yandex mithilfe von Radar und Satelliten eine globale Niederschlagsvorhersage erstellte</a></li>
<li><a href="../de425521/index.html">Gesch√ºtzte Methoden in JavaScript ES5</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>